[
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,l,a[200005];\nvector<int>za;\nvector<int>pos[200005];\n\nbool in[200005];\nint par[200005][2],ran[200005];\nvoid init(){ for(int i=0;i<200005;i++) par[i][0] = par[i][1] = i; }\nint find(int x,int a){\n\tif(x == par[x][a]) return x;\n\telse return par[x][a] = find(par[x][a],a); \n}\nvoid unite(int x,int y){\n\tx = find(x,0); y = find(y,0);\n\tif(x != y){\n\t\tif(x < y) par[y][0] = x;\n\t\telse par[x][0] = y;\n\t}\n\tx = find(x,1); y = find(y,1);\n\tif(x != y){\n\t\tif(x > y) par[y][1] = x;\n\t\telse par[x][1] = y;\n\t}\n}\n\nmap<P,vector<P>>dp;\nmap<P,int>mx;\nvector<P>query[200005];\nll ans;\npair<pair<vector<int>,vector<int>>,int>rec(int L,int R){\n\tif(L > R){\n\t\tvector<int>vi; vi.pb(1);\n\t\treturn mp(mp(vi,vi),-100);\n\t}\n\tvector<pair<pair<vector<int>,vector<int>>,int>>ret;\n\tvector<vector<int>>ruirui;\n\n\tSORT(dp[mp(L,R)]);\n\tvector<int>rui,rui2;\n\tint cur_v = 0, cur_v2 = 0;\n\tvector<int>forbid;\n\tfor(auto x:dp[mp(L,R)]){\n\t\tret.pb(rec(x.fi,x.sc));\n\t\tint dif = mx[mp(L,R)]-ret.back().sc;\n\t\tll dv = 1;\n\t\trep(q,dif) { dv = dv*l; if(dv >= mod) { dv = mod; break; }}\n\t\tint DV = (int)(dv);\n\t\tcur_v += (ret.back().fi.fi.size()-1) / dv + 1;\n\t\tvector<int>hoge; int sum = 0;\n\t\tfor(int i=0;i<ret.back().fi.fi.size();i++){\n\t\t\tsum += ret.back().fi.fi[i];\n\t\t\thoge.pb(sum);\n\t\t}\n\t\tfor(int i=0;i<ret.back().fi.fi.size();i++){\n\t\t\tif(i && i<dv) continue;\n\t\t\tif(i==0 && ret.size() >= 2) continue;\n\t\t\tcur_v2 += ret.back().fi.fi[i];\n\t\t}\n\t\tif(ret.back().fi.fi.size() >= 2 && ret.back().fi.fi.size() <= dv && ret.size() >= 2) forbid.pb(ret.size()-2);\n\t\tcur_v2 ++;\n\t\trui.pb(cur_v);\n\t\trui2.pb(cur_v2);\n\t\truirui.pb(hoge);\n\t}\n\t//if(L == 1 && R == 8) cout << ret.size() << \" \" << rui.size() << \" \" << rui2.size() << \" \" << ruirui.size() << endl;\n\tassert(rui.size() >= 1 && rui2.size() >= 1);\n\trui.back()--; rui2.back()--;\n\tint nxt = 0;\n\tfor(int i=0;i<ret.size()-1;i++){\n\t\tint dif = mx[mp(L,R)]-ret[i].sc;\n\t\tll dv = 1;\n\t\trep(q,dif) { dv = dv*l; if(dv >= mod) { dv = mod; break; }}\n\t\tint DV = (int)(dv);\n\t\tnxt = max(nxt,i);\n\t\tfor(int j=ret[i].fi.sc.size()-1;j>=0;j--){\n\t\t\tif(j && j<dv) continue;\n\t\t\tll coef = ret[i].fi.sc[j];\n\t\t\tint num = j/dv+1;\n\t\t\twhile(nxt < rui.size() && rui[nxt]-rui[i]+num < l) nxt++;\n\t\t\t//if(L==1&&R==8) cout << i << \" \" << j << \" \" << nxt << endl;\n\t\t\tif(nxt == rui.size()) break;\n\t\t\tif(nxt == i){\n\t\t\t\tint a = POSL(forbid,i);\n\t\t\t\tint x = rui2.size()-1;\n\t\t\t\tif(a < forbid.size()) x = forbid[a];\n\t\t\t\tans += 1LL * coef * (rui2[x]-rui2[i]+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint a = POSL(forbid,i);\n\t\t\t\tint x = rui2.size()-1;\n\t\t\t\tif(a < forbid.size()) x = forbid[a];\n\t\t\t\t//cout << L << R << x << nxt << endl;\n\t\t\t\tif(x >= nxt) ans += 1LL * coef * (rui2[x]-rui2[nxt]+1);\n\t\t\t\t//cout<<ans<<endl;\n\t\t\t\tint cur = rui[nxt-1]-rui[i]+num; assert(l > cur);\n\t\t\t\tint need = l-cur;\n\t\t\t\tint dif = mx[mp(L,R)]-ret[nxt].sc;\n\t\tll dvv = 1;\n\t\trep(q,dif) { dvv = dvv*l; if(dvv >= mod) { dvv = mod; break; }}\n\t\t\n\t\t\t\tll beg = min(1LL*mod,1LL*need*dvv); \n\t\t\t\t//if(L==1 && R==8) cout << need << \" \" << dv << \" \" << i << \" \" << j << endl;\n\t\t\t\tif(beg < ret[nxt].fi.fi.size()) ans += 1LL * coef * (ruirui[nxt][ret[nxt].fi.fi.size()-1] - ruirui[nxt][beg-1]);\n\t\t\t}\n\t\t\t//cout<<ans<<endl;\n\t\t}\n\t}\n\tvector<int>le,ri;\n\tfor(int i=0;i<ret.size();i++){\n\t\tint dif = mx[mp(L,R)]-ret[i].sc;\n\t\tll dv = 1;\n\t\trep(q,dif) { dv = dv*l; if(dv >= mod) { dv = mod; break; }}\n\t\tint DV = (int)(dv);\n\t\tassert(ret[i].fi.fi.size());\n\t\tint num = (ret[i].fi.fi.size()-1) / dv;\n\t\tif(num == 0){\n\t\t\tle.pb(1);\n\t\t\tif(ret[i].fi.fi.size() >= 2) break;\n\t\t}\n\t\telse{\n\t\t\tle.pb(1);\n\t\t\tint cnt = 0;\n\t\t\tfor(int ii=dv;ii<ret[i].fi.fi.size();ii++){\n\t\t\t\tcnt += ret[i].fi.fi[ii];\n\t\t\t\tif(ii%dv == dv-1 || ii+1 == ret[i].fi.fi.size()){\n\t\t\t\t\tle.pb(cnt); cnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=ret.size()-1;i>=0;i--){\n\t\tint dif = mx[mp(L,R)]-ret[i].sc;\n\t\tll dv = 1;\n\t\trep(q,dif) { dv = dv*l; if(dv >= mod) { dv = mod; break; }}\n\t\tint DV = (int)(dv);\n\t\tint num = (ret[i].fi.sc.size()-1) / dv;\n\t\tassert(ret[i].fi.sc.size());\n\t\tif(num == 0){\n\t\t\tri.pb(1);\n\t\t\tif(ret[i].fi.sc.size() >= 2) break;\n\t\t}\n\t\telse{\n\t\t\tri.pb(1);\n\t\t\tint cnt = 0;\n\t\t\tfor(int ii=dv;ii<ret[i].fi.sc.size();ii++){\n\t\t\t\tcnt += ret[i].fi.sc[ii];\n\t\t\t\tif(ii%dv == dv-1 || ii+1 == ret[i].fi.sc.size()){\n\t\t\t\t\tri.pb(cnt); cnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    /*cout << L << \" \" << R << \" \" << ans << endl; /*\n\tcout << \"=======\" << endl;\n\trep(i,le.size()) cout << le[i] << \" i \" << endl;\n\tcout << \"=======\" << endl;\n\trep(i,ri.size()) cout << ri[i] << \" j \" << endl;\n\tcout << \"=======\" << endl;\n\tcout << L << \"  \" << R << \" \" << ans << endl;*/\n\treturn mp(mp(le,ri),mx[mp(L,R)]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tza.pb(a[i]);\n\t}\n\tinit();\n\tSORT(za); ERASE(za);\n\tfor(int i=1;i<=n;i++){\n\t\tint x = POSL(za,a[i]);\n\t\tpos[x].pb(i);\n\t}\n\tfor(int i=0;i<za.size();i++){\n\t\tfor(int j=0;j<pos[i].size();j++){\n\t\t\tin[pos[i][j]] = 1;\n\t\t}\n\t\tfor(int j=0;j<pos[i].size();j++){\n\t\t\tint x = pos[i][j];\n\t\t\tif(in[x-1]) unite(x-1,x);\n\t\t\tif(in[x+1]) unite(x,x+1);\n\t\t}\n\t\tset<int>S;\n\t\tfor(int j=0;j<pos[i].size();j++){\n\t\t\tint hoge = find(pos[i][j],0);\n\t\t\tint hoge2 = find(pos[i][j],1);\n\t\t\tquery[hoge].pb(mp(pos[i][j],hoge2));\n\t\t\tS.insert(hoge);\n\t\t}\n\t\tfor(auto le:S){\n\t\t\tint pre = -1;\n\t\t\trep(x,query[le].size()){\n\t\t\t\tif(pre == -1) pre = query[le][x].sc;\n\t\t\t\telse assert(pre == query[le][x].sc);\n\t\t\t}\n\t\t\tint ri = pre;\n\t\t\tassert(le <= ri);\n\t\t\tmx[mp(le,ri)] = za[i];\n\t\t\tdp[mp(le,ri)].pb(mp(query[le].back().fi+1,ri));\n\t\t\tfor(int x=query[le].size()-1;x>=0;x--){\n\t\t\t\tint R = query[le][x].fi-1;\n\t\t\t\tint L = (x?query[le][x-1].fi+1:le);\n\t\t\t\tdp[mp(le,ri)].pb(mp(L,R));\n\t\t\t}\n\t\t}\n\t\tfor(auto le:S) query[le].clear();\n\t}\n\trec(1,n);\n\tcout << ans+n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (200010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\n#define fi first\n#define se second\n#define mkp make_pair\nint n,m,now,a[N]; pair<int,int> pos[N];\nLL ans; vector<pair<pair<int,int>,pair<int,int> > >t,tmp;\nvector<pair<int,int> > wk,pp;\n//当前位置,当前 \nint calc(vector<pair<int,int> > &a){\n\tLL sum=0,ans=0;\n\tfor(int i=0,j=m-1;j<a.size();i++,j++)\n\tsum+=a[i].fi,ans+=sum*a[j].se;\n\treturn ans;\n}\nint main(){\n\tread(n),read(m),ans=n;\n\tfor(int i=1;i<=n;i++)read(a[i]),pos[i]=mkp(a[i],i);\n\tsort(pos+1,pos+n+1);\n\tfor(int p=1,val=0;p<=n||!t.empty();){\n//\t\tcout<<p<<endl;\n\t\tif(t.empty())val=pos[p].fi;else val++;\n\t\tfor(;pos[p].fi==val;p++)t.emplace_back(mkp(pos[p].se,pos[p].se),mkp(1,1));\n\t\ttmp.clear(),sort(t.begin(),t.end());\n//\t\tputs(\"faq\");\n\t\tfor(int i=0,j=0;i<t.size();i=j+1){\n\t\t\tfor(j=i;j+1<t.size()&&t[j+1].fi.fi==t[j].fi.se+1;j++);\n//\t\t\tcout<<t.size()<<\" \"<<i<<\" \"<<j<<endl;\n\t\t\tint len=j-i+1,cnt=len/m;\n\t\t\tif(cnt){\n//\t\t\t\tputs(\"faq2\");\n\t\t\t\twk.clear();\n\t\t\t\tfor(int k=i;k<=j;k++)wk.push_back(t[k].se);\n\t\t\t\tans+=calc(wk),wk.clear(),wk.resize(cnt),pp.clear();\n\t\t\t\tfor(int k=1;k<=cnt;k++)\n\t\t\t\tpp.emplace_back(t[i].fi.fi+k-1,(k==cnt)?t[j].fi.se:t[i].fi.fi+k-1);\n\t\t\t\tfor(int k=i;k<=j;k++){\n\t\t\t\t\tint l=k-i+1,r=j-k+1;\n\t\t\t\t\tif(l>=m)wk[l/m-1].se+=t[k].se.se;\n\t\t\t\t\tif(r>=m)wk[cnt-r/m].fi+=t[k].se.fi;\n\t\t\t\t}\n//\t\t\t\tputs(\"faq3\");\n//\t\t\t\tcout<<cnt<<\" faq \"<<wk.size()<<\" \"<<val<<endl;\n\t\t\t\tans-=calc(wk);\n\t\t\t\tfor(int k=0;k<pp.size();k++)tmp.emplace_back(pp[k],wk[k]);\n//\t\t\t\tcout<<tmp[k].fi.fi<<\" \"<<tmp[k].fi.se<<\" \"<<tmp[k].se.fi<<\" \"<<tmp[k].se.se<<endl;\n\t\t\t}\n\t\t}\n\t\tt=tmp;\n//\t\tcout<<t.size()<<\" faq4\\n\";\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * じょえチャンネル\n * 高評価・チャンネル登録よろしくおねがいします！\n * https://www.youtube.com/channel/UCRXsI3FL_kvaVL9zoolBfbQ\n */\n\n#include <bits/stdc++.h>\n\n//#pragma GCC target(\"avx2\")\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n\n\n\n//here!!!\n// define int long long !!!!!\n\n#define int long long\n\n// define int long long !!!!!\n\n\n#define mod 1000000007ll\n//constexpr int mod = 998244353ll;\n\ntypedef long long ll;\n\n#ifdef int\n#define inf (int)(3e18)\n#else\n#define inf (int)(5e8)\n#endif\n\n#define intt long long\n#define itn long long\n#define P pair<long long,long long>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define rev_rep(i,n) for(int i=n-1;i>=0;i--)\n#define REV_REP(i,n) for(int i=n;i>=1;i--)\n\n#define ALL(v) v.begin(),v.end()\n\n#define smallpriority_queue(x) priority_queue<x,vector<x>,greater<x>>\n\nusing namespace std;\n\n//Library\n//モッドパウ\ninline int modpow(int x, int y, int m = mod) {\n    int res = 1;\n    while (y) {\n        if (y & 1) {\n            res *= x;\n            res %= m;\n        }\n        x = x * x % m;\n        y /= 2;\n    }\n    return res;\n}\n\nint mypow(int x, int y) {\n    int res = 1;\n    while (y) {\n        if (y % 2) {\n            res *= x;\n        }\n        x = x * x;\n        y /= 2;\n    }\n    return res;\n}\n//is the number (x) a prime number?\nbool prime(int x) {\n    if (!x || x == 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= x; i++) {\n        if (!(x % i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n//saidai-kouyakusuu\ninline int gcd(int x, int y) {\n    if (!y) {\n        return x;\n    }\n    return gcd(y, x % y);\n}\n\n\n//number of keta\nint keta(int x) {\n    int ans = 0;\n    while (x) {\n        x /= 10;\n        ans++;\n    }\n    return ans;\n}\n\n//number of 2shinsuu keta\nint bitketa(int x) {\n    int ans = 0;\n    while (x) {\n        x >>= 1;\n        ans++;\n    }\n    return ans;\n}\n\n//sum of keta\nint ketasum(int x) {\n    int ans = 0;\n    while (x) {\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\ninline int lcm(int x, int y) {\n    int ans = x / gcd(x, y) * y;\n    return ans;\n}\nint twobeki(int x) {\n    int ans = 0;\n    while (1) {\n        if (!(x & 1)) {\n            ans++;\n            x >>= 1;\n        }\n        else {\n            break;\n        }\n    }\n    return ans;\n}\n\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n    if (lhs < rhs) {\n        lhs = rhs;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n    if (lhs > rhs) {\n        lhs = rhs;\n        return 1;\n    }\n    return 0;\n}\nvoid Yes(){\n    cout<<\"Yes\"<<endl;\n}\nvoid No(){\n    cout<<\"No\"<<endl;\n}\nvoid YES(){\n    cout<<\"YES\"<<endl;\n}\nvoid NO(){\n    cout<<\"NO\"<<endl;\n}\n\n\n#define fin(i) scanf(\"%lld\",&i)\n#define fout(i) printf(\"%lld\",i)\n#define fendl printf(\"\\n\")\n\nint kai(int x, int y) {\n    int res = 1;\n    for (int i = x - y + 1; i <= x; i++) {\n        res *= i; res %= mod;\n    }\n    return res;\n}\n\nint comb(int x, int y) {\n    if (y > x)return 0;\n    //    cout<<kai(x, y)<<' '<<modpow(kai(y, y), mod - 2)<<endl;\n    return kai(x, y) * modpow(kai(y, y), mod - 2) % mod;\n}\n//Library-End\n\n\n#define vecin(v) for(int i=0;i<v.size();i++)scanf(\"%lld\",&v[i]);\n#define vecout(v) {for(int i=0;i<(int)v.size();i++)printf(\"%lld \",v[i]);printf(\"\\n\");}\n\n\ntemplate<typename T>\nclass kaageSegTree {\nprotected:\n    unsigned int n = 1, rank = 0;\n    std::vector<T> node;\n    T nodee;\n    virtual T nodef(const T&, const T&)const = 0;\npublic:\n    kaageSegTree(unsigned int m, T init, T nodee):nodee(nodee) {\n        while (n < m) {\n            n *= 2;\n            rank++;\n        }\n        node.resize(2 * n);\n        for (unsigned int i = n; i < 2 * n; i++)node[i] = init;\n    }\n    kaageSegTree(const std::vector<T>& initvec, T nodee):nodee(nodee) {\n        unsigned int m = initvec.size();\n        while (n < m) {\n            n *= 2;\n            rank++;\n        }\n        node.resize(2 * n);\n        for (unsigned int i = n; i < 2 * n; i++) {\n            if (i - n < m)node[i] = initvec[i - n];\n        }\n    }\n    virtual void update(int i, T x) {\n        i += n;\n        node[i] = x;\n        while (i != 1) {\n            i >>= 1;\n            node[i] = nodef(node[2 * i], node[2 * i + 1]);\n        }\n    }\n    virtual T query(int l, int r) {\n        l += n; r += n;\n        T ls = nodee, rs = nodee;\n        while (l < r) {\n            if (l & 1) {\n                ls = nodef(ls, node[l]);\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                rs = nodef(node[r], rs);\n            }\n            l >>= 1; r >>= 1;\n        }\n        return nodef(ls, rs);\n    }\n    virtual T operator[](const int& x) {\n        return node[n + x];\n    }\n    void fill(T x) {\n        std::fill(ALL(node), x);\n    }\n    void print() {\n        rep(i, n)std::cout << operator[](i) << \" \";\n        std::cout << std::endl;\n    }\n};\nclass RSQ :public kaageSegTree<int> {\n    int nodef(const int& lhs,const int& rhs)const{return lhs+rhs;}\npublic:\n    RSQ(int size, const int& def = 0) :kaageSegTree<int>(size, def, 0) {}\n    RSQ(const std::vector<int>& initvec) :kaageSegTree<int>(initvec, 0) {}\n};\nclass RMiQ :public kaageSegTree<int> {\n    int nodef(const int& lhs,const int& rhs)const{return std::min(lhs,rhs);}\npublic:\n    RMiQ(int size, const int& def = 0) :kaageSegTree<int>(size, def, inf) {}\n    RMiQ(const std::vector<int>& initvec) :kaageSegTree<int>(initvec, inf) {}\n};\nclass RMaQ :public kaageSegTree<int> {\n    int nodef(const int& lhs,const int& rhs)const{return std::max(lhs,rhs);}\npublic:\n    RMaQ(int size, const int& def = 0) :kaageSegTree<int>(size, def, -inf) {}\n    RMaQ(const std::vector<int>& initvec) :kaageSegTree<int>(initvec, -inf) {}\n};\ntemplate<typename T, typename U>\nclass IntervalSegTree :public kaageSegTree<T> {\nprotected:\n    using kaageSegTree<T>::n;\n    using kaageSegTree<T>::rank;\n    using kaageSegTree<T>::node;\n    using kaageSegTree<T>::nodef;\n    using kaageSegTree<T>::nodee;\n    std::vector<U> lazy;\n    std::vector<bool> lazyflag;\n    std::vector<int> width;\n    virtual void lazyf(U&, const U&) = 0;\n    virtual void updf(T&, const U&, const unsigned int&) = 0;\n    void eval(int k) {\n        for (int i = rank; i > 0; i--) {\n            int nk = k >> i;\n            if (lazyflag[nk]) {\n                updf(node[2 * nk], lazy[nk], width[2 * nk]);\n                updf(node[2 * nk + 1], lazy[nk], width[2 * nk + 1]);\n                if (lazyflag[2 * nk])lazyf(lazy[2 * nk], lazy[nk]);\n                else lazy[2 * nk] = lazy[nk];\n                if (lazyflag[2 * nk + 1])lazyf(lazy[2 * nk + 1], lazy[nk]);\n                else lazy[2 * nk + 1] = lazy[nk];\n                lazyflag[2 * nk] = lazyflag[2 * nk + 1] = true;\n                lazyflag[nk] = false;\n            }\n        }\n    }\npublic:\n    IntervalSegTree(unsigned int m, T init, T nodee) :kaageSegTree<T>(m, init, nodee) {\n        lazy.resize(2 * n); lazyflag.resize(2 * n); width.resize(2 * n);\n        width[1] = n;\n        for (unsigned int i = 2; i < 2 * n; i++) {\n            width[i] = width[i >> 1] >> 1;\n        }\n    }\n    IntervalSegTree(T nodee, const std::vector<T>& initvec) :kaageSegTree<T>(initvec, nodee) {\n        lazy.resize(2 * n); lazyflag.resize(2 * n); width.resize(2 * n);\n        width[1] = n;\n        for (unsigned int i = 2; i < 2 * n; i++) {\n            width[i] = width[i >> 1] >> 1;\n        }\n    }\n    void update(int i, U x) {\n        i += n;\n        eval(i);\n        updf(node[i], x, width[i]);\n        if (lazyflag[i])lazyf(lazy[i], x);\n        else {\n            lazyflag[i] = true;\n            lazy[i] = x;\n        }\n        while (i /= 2)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    void update(int l, int r, U x) {\n        l += n; r += n;\n        int nl = l, nr = r;\n        while (!(nl & 1))nl >>= 1;\n        while (!(nr & 1))nr >>= 1;\n        nr--;\n        eval(nl); eval(nr);\n        while (l < r) {\n            if (l & 1) {\n                updf(node[l], x, width[l]);\n                if (lazyflag[l])lazyf(lazy[l], x);\n                else {\n                    lazyflag[l] = true;\n                    lazy[l] = x;\n                }\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                updf(node[r], x, width[r]);\n                if (lazyflag[r])lazyf(lazy[r], x);\n                else {\n                    lazyflag[r] = true;\n                    lazy[r] = x;\n                }\n            }\n            l >>= 1; r >>= 1;\n        }\n        while (nl >>= 1)node[nl] = nodef(node[2 * nl], node[2 * nl + 1]);\n        while (nr >>= 1)node[nr] = nodef(node[2 * nr], node[2 * nr + 1]);\n    }\n    T query(int l, int r) {\n        l += n; r += n;\n        eval(l); eval(r - 1);\n        int ls = nodee, rs = nodee;\n        while (l < r) {\n            if (l & 1) {\n                ls = nodef(ls, node[l]);\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                rs = nodef(node[r], rs);\n            }\n            l >>= 1; r >>= 1;\n        }\n        return nodef(ls, rs);\n    }\n    T operator[](const int& x) {\n        eval(n + x);\n        return node[n + x];\n    }\n    T queryForAll() {\n        return node[1];\n    }\n};\nclass RAQRSQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return a + b; }\n    void lazyf(int& a, const int& b) { a += b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a += width * b; }\npublic:\n    RAQRSQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, 0) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RAQRSQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>((int)0, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RAQRMiQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::min(a, b); }\n    void lazyf(int& a, const int& b) { a += b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a += b; }\npublic:\n    RAQRMiQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RAQRMiQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RAQRMaQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::max(a, b); }\n    void lazyf(int& a, const int& b) { a += b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a += b; }\npublic:\n    RAQRMaQ(unsigned int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, -inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RAQRMaQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(-inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RUQRSQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return a + b; }\n    void lazyf(int& a, const int& b) { a = b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a = width * b; }\npublic:\n    RUQRSQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, 0) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RUQRSQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>((int)0, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RUQRMiQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::min(a, b); }\n    void lazyf(int& a, const int& b) { a = b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a = b; }\npublic:\n    RUQRMiQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RUQRMiQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RUQRMaQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::max(a, b); }\n    void lazyf(int& a, const int& b) { a = b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a = b; }\npublic:\n    RUQRMaQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, -inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RUQRMaQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(-inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\n\n////SegTree\n//template <class T>\n//class SegTree {\n//    int n;                       // 葉の数\n//    vector<T> node;              // データを格納するvector\n//    T def;                       // 初期値かつ単位元\n//    function<T(T, T)> operation; // 区間クエリで使う処理\n//    function<T(T, T)> update;    // 点更新で使う処理\n//\n//    // 区間[a,b)の総和。ノードk=[l,r)に着目している。\n//    T _query(int a, int b, int k, int l, int r) {\n//        if (r <= a || b <= l) return def; // 交差しない\n//        if (a <= l && r <= b)\n//            return node[k]; // a,l,r,bの順で完全に含まれる\n//        else {\n//            T c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n//            T c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n//            return operation(c1, c2);\n//        }\n//    }\n//\n//public:\n//    // _n:必要サイズ, _def:初期値かつ単位元, _operation:クエリ関数,\n//    // _update:更新関数\n//    SegTree(size_t _n, T _def, function<T(T, T)> _operation,\n//            function<T(T, T)> _update)\n//    : def(_def), operation(_operation), update(_update) {\n//        n = 1;\n//        while (n < _n) {\n//            n *= 2;\n//        }\n//        node = vector<T>(2 * n , def);\n//    }\n//\n//    // 場所i(0-indexed)の値をxで更新\n//    void change(int i, T x) {\n//        i += n - 1;\n//        node[i] = update(node[i], x);\n//        while (i > 0) {\n//            i = (i - 1) / 2;\n//            node[i] = operation(node[i * 2 + 1], node[i * 2 + 2]);\n//        }\n//    }\n//\n//    // [a, b)の区間クエリを実行\n//    T query(int a, int b) {\n//        return _query(a, b, 0, 0, n);\n//    }\n//\n//    // 添字でアクセス\n//    T operator[](int i) {\n//        return node[i + n - 1];\n//    }\n//};\n\ntemplate <class T>\nclass SegTree {\n    int n;\n    vector<T> node;\n    T def;\n    function<T(T,T)> operation;\n    function<T(T,T)> update;\n    \npublic:\n    SegTree(unsigned int _n, T _def, function<T(T, T)> _operation,\n            function<T(T, T)> _update)\n    : def(_def), operation(_operation), update(_update) {\n        n=1;\n        while (n < _n) {\n            n *= 2;\n        }\n        node = vector<T>(n * 2, def);\n    }\n    SegTree(vector<int>& initvec, function<T(T, T)> _operation,\n            function<T(T, T)> _update)\n    :  operation(_operation), update(_update) {\n        n=1;\n        while (n < initvec.size()) {\n            n *= 2;\n        }\n        node = vector<T>(n * 2, def);\n        for(int i=n;i<n+initvec.size();i++){\n            node[i]=initvec[i-n];\n        }\n        for(int i=n-1;i>=1;i--){\n            node[i]=operation(node[i*2],node[i*2+1]);\n        }\n    }\n    void change(int i,T x){\n        i+=n;\n        node[i]=update(node[i],x);\n        while (i>=1) {\n            i>>=1;\n            node[i]=operation(node[i*2],node[i*2+1]);\n        }\n    }\n    T query(int l, int r){\n        l+=n;\n        r+=n;\n        T rx=def,lx=def;\n        while(l<r){\n            if (l&1) {\n                lx=operation(lx,node[l]);\n                l++;\n            }\n            if (r&1) {\n                r--;\n                rx=operation(node[r],rx);\n            }\n            l>>=1; r>>=1;\n        }\n        return operation(lx,rx);\n    }\n    T operator [] (const int& x){\n        return node[x+n];\n    }\n    void fill(T x) {\n        std::fill(ALL(node), x);\n    }\n    void print() {\n        rep(i, n)std::cout << operator[](i) << \" \";\n        std::cout << std::endl;\n    }\n    \n};\n\n#define R_MIN ([](P a, P b) { return min(a, b); })\n#define R_MAX ([](long long a, long long b) { return max(a, b); })\n#define R_SUM ([](long long a, long long b) { return a + b; })\n\n#define NORMAL_UPDATE ([](P a, P b) { return b; })\n#define ADD_UPDATE ([](long long a, long long b) { return a + b; })\n#define MINUS_UPDATE ([](long long a, long long b) { return a - b; }\n\nclass Union_Find {\n    vector<int> par;\n    vector<int> rankmy;\n    vector<int> ookisa;\n    \npublic:\n    Union_Find(int size) {\n        par = vector<int>(size);\n        rankmy = vector<int>(size);\n        ookisa=vector<int>(size);\n        for (int i = 0; i < size; i++) {\n            par[i] = i;\n            ookisa[i]=1;\n        }\n    }\n    \n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        return par[x] = find(par[x]);\n    }\n    \n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return;\n        }\n        if (rankmy[x] < rankmy[y]) {\n            par[x] = y;\n            ookisa[y]+=ookisa[x];\n            ookisa[x]=0;\n        }\n        else {\n            par[y] = x;\n            ookisa[x]+=ookisa[y];\n            ookisa[y]=0;\n            if (rankmy[x] == rankmy[y]) {\n                rankmy[x]++;\n            }\n        }\n    }\n    int size(int i){\n        i=find(i);\n        return ookisa[i];\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    \n};\n\nclass BIT {\n    vector<int> data;\n    int size=0;\npublic:\n    BIT(int _size){\n        data=vector<int>(_size+1);\n        size=_size;\n    }\n    void add(int i,int x){\n        while (i<=size) {\n            data[i]+=x;\n            i += i & -i;\n        }\n    }\n    int sum(int i){\n        assert(i<=size);\n        int s=0;\n        while(i>0){\n            s+=data[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n    int lower_bound(int x){\n        if(x<=0){\n            return 0;\n        }else{\n            int i=0;int r=1;\n            while(r<size) r=r<<1;\n            for(int len=r;len>0;len=len>>1) {\n                if(i+len<size && data[i+len]<x){\n                    x-=data[i+len];\n                    i+=len;\n                }\n            }\n            return i+1;\n        }\n    }\n};\n\n//Union-Find-End\n\nint perm[2000005];\nvoid init_perm() {\n    perm[0] = 1;\n    REP(i, 2000004) {\n        perm[i] = perm[i - 1] * i % mod;\n    }\n}\n\nint nCk(int x, int y) {\n    if (y>x) {\n        return 0;\n    }\n    if (x<0) {\n        return 0;\n    }\n    return perm[x] * modpow(perm[x - y], mod - 2) % mod * modpow(perm[y], mod - 2) % mod;\n}\n\ndouble kyori(pair<int, int> f, pair<int, int> s) {\n    double ans = 0;\n    double t = fabs(f.first - s.first);\n    double y = fabs(f.second - s.second);\n    ans = sqrt(t * t + y * y);\n    return ans;\n}\n\ninline string stringmax(string& x,string& y){\n    if (x.size()>y.size()) {\n        return x;\n    }\n    if (x.size()<y.size()) {\n        return y;\n    }\n    rep(i,x.size()){\n        if (x[i]>y[i]) {\n            return x;\n        }\n        if (x[i]<y[i]) {\n            return y;\n        }\n    }\n    return x;\n}\n\nvector<int>  RollingHash(string &s, string& t){\n    vector<int> ans;\n    __int128 h=0,hamod=0,ki=0,kim=0,hikaku=0,one=0;\n    one=1;\n    ki=1000000007ll;\n    hamod=(one<<61)-1;\n    kim=1;\n    rep(i,t.size()){\n        hikaku*=ki;\n        h*=ki;\n        kim*=ki;\n        hikaku+=t[i];\n        h+=s[i];\n        hikaku%=hamod;\n        h%=hamod;\n        kim%=hamod;\n    }\n    rep(i,(int)s.size()-(int)t.size()+1){\n        if (h==hikaku) {\n            ans.emplace_back(i);\n        }\n        h*=ki;\n        h%=hamod;\n        h+=s[i+(int)t.size()];\n        h%=hamod;\n        h+=hamod;\n        h-=s[i]*kim%hamod;\n        h%=hamod;\n    }\n    return ans;\n}\nstruct edge {\n    int to;\n    int length;\n    edge(int _to, int _length){\n        to=_to;\n        length=_length;\n    }\n};\nvector<int> djkstra(vector<vector<edge>> &road,int start){\n    vector<int> kyo(road.size(),inf);\n    smallpriority_queue(P) q;\n    q.push({0,start});\n    kyo[start]=0;\n    while (q.size()) {\n        int x=q.top().second;\n        itn now=q.top().first;\n        q.pop();\n        if (kyo[x]<now) {\n            continue;\n        }\n        for(auto&i:road[x]){\n            if (kyo[i.to]>now+i.length) {\n                kyo[i.to]=now+i.length;\n                q.push({kyo[i.to],i.to});\n            }\n        }\n    }\n    return kyo;\n}\n\n#define endl \"\\n\" //interactive の時に注意！！！\n#define Endl \"\\n\" //interactive の時に注意！！！\n#define printd cout<<fixed<<setprecision(10)\n#define rrep(i,f,s) for(int i=f;i<s;i++)\n#define RREP(i,f,s) for(int i=f;i<=s;i++)\n\nint n,k;\nstring s,t,t2;\nsigned main() {\n    ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    cin>>n>>k>>s;\n    char c='a'+27;\n    rep(i,n){\n        chmin(c, s[i]);\n    }\n    \n    if (bitketa(n)+1<=k) {\n        rep(i,n){\n            cout<<c;\n        }\n        cout<<endl;\n        return 0;\n    }\n    t=s;\n    t2=s;\n    rep(i,k){\n        string v(n+1,'z'),v2(n+1,'z');\n        string l=t;\n        reverse(ALL(t));\n        l+=t;\n        rep(j,n+1){\n            string k=l.substr(j,n);\n            chmin(v,k);\n            reverse(ALL(k));\n            chmin(v2,k);\n        }\n        l=t2;\n        reverse(ALL(t2));\n        l+=t2;\n        rep(j,n+1){\n            string k=l.substr(j,n);\n            chmin(v,k);\n            reverse(ALL(k));\n            chmin(v2,k);\n        }\n        t=v;\n        reverse(ALL(v2));\n        t2=v2;\n    }\n    cout<<t<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nlong long ans;\nint n,L;\nint st[200005],top,vl[200005],vr[200005];\nint sl[200005],sr[200005];\nvoid pop(){\n\tint len=1,v=st[top];\n\twhile(st[top-1]==v)top--,len++;\n\ttop--;\n\tif(len<L){\n\t\twhile(top)pop();\n\t\treturn;\n\t}\n\tint w=len/L;\n\tsl[0]=0;\n\tfor(int i=1;i<=len;i++)sl[i]=sl[i-1]+vl[i+top];\n\tsr[0]=0;\n\tfor(int i=1;i<=len;i++)sr[i]=sr[i-1]+vr[i+top];\n\tfor(int i=L;i<=len;i++)ans+=1ll*sl[i-L+1]*vr[i+top];\n\tfor(int i=1;i<=w;i++){\n\t\tvl[top+i]=sl[len-L*(w-i+1)+1]-sl[max(len-L*(w-i+2)+1,0)];\n\t\tvr[top+i]=sr[min(L*(i+1)-1,len)]-sr[L*i-1];\n\t}\n\tfor(int i=L,s=0;i<=w;i++)s+=vl[top+i-L+1],ans-=1ll*s*vr[top+i];\n\tfor(int i=1;i<=w;i++)st[++top]=v+1;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&L);\n\tans=n;\n\tfor(int i=1;i<=n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\twhile(top&&st[top]<x)pop();\n\t\tst[++top]=x;\n\t\tvl[top]=vr[top]=1;\n\t\t/*\n\t\tfor(int i=1;i<=top;i++)printf(\"%d \",st[i]); puts(\"\");\n\t\tfor(int i=1;i<=top;i++)printf(\"%d \",vl[i]); puts(\"\");\n\t\tfor(int i=1;i<=top;i++)printf(\"%d \",vr[i]); puts(\"\");\n\t\t*/\n\t}\n\twhile(top)pop();\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, m;\nint tab[nax];\n\nvector <pii> pref[nax];\nvector <pii> suf[nax];\nint cal[nax];\n\nmap <int,vector <pii>> mapa;\n\nll wyn;\n\nll fen[nax];\n\nvoid pisz(int v, ll w)\n{\n\tv+=nax/2;\n\tfor (int i=v; i; i-=(i&(-i)))\n\t\tfen[i]+=w;\n}\n\nll czyt(int v)\n{\n\tv+=nax/2;\n\tll ret=0;\n\tfor (int i=v; i<nax; i+=(i&(-i)))\n\t\tret+=fen[i];\n\treturn ret;\n}\n\nint scal[nax];\nint tyl[nax];\n\nvoid lacz(vector <pii> &wek)\n{\n\tsort(wek.begin(), wek.end());\n\tvector <pii> pom;\n\tfor (pii i : wek)\n\t{\n\t\tif (pom.empty() || pom.back().first!=i.first)\n\t\t\tpom.push_back({i.first, 0});\n\t\tpom.back().second+=i.second;\n\t}\n\twek=pom;\n}\n\nvoid biegnij(int v, vector <pii> wek)\n{\n\tdebug() << v << \" \" << wek;\n\tint k=wek.size();\n\tscal[0]=0;\n\tfor (int i=0; i<k; i++)\n\t{\n\t\tif (scal[i]==-1 || cal[wek[i].first]==-1)\n\t\t\tscal[i+1]=-1;\n\t\telse\n\t\t\tscal[i+1]=scal[i]+cal[wek[i].first];\n\t}\n\ttyl[k]=0;\n\tfor (int i=k-1; i>=0; i--)\n\t{\n\t\tif (tyl[i+1]==-1 || cal[wek[i].first]==-1)\n\t\t\ttyl[i]=-1;\n\t\telse\n\t\t\ttyl[i]=tyl[i+1]+cal[wek[i].first];\n\t}\n\t\n\tint c=0;\n\tvector <pii> kum;\n\tfor (int i=0; i<k; i++)\n\t{\n\t\tfor (pii j : pref[wek[i].first])\n\t\t\twyn+=czyt(m-(j.first+c))*j.second;\n\t\tc+=cal[wek[i].first];\n\t\tif (cal[wek[i].first]==-1)\n\t\t{\n\t\t\tfor (pii j : kum)\n\t\t\t\tpisz(j.first, -j.second);\n\t\t\tkum.clear();\n\t\t\tc=0;\n\t\t}\n\t\tfor (pii j : suf[wek[i].first])\n\t\t{\n\t\t\tpisz(j.first-c, j.second);\n\t\t\tkum.push_back({j.first-c, j.second});\n\t\t}\n\t}\n\tfor (pii j : kum)\n\t\tpisz(j.first, -j.second);\n\tkum.clear();\n\t\n\tvector <pii> npref, nsuf;\n\tfor (int i=0; i<k; i++)\n\t{\n\t\tif (scal[i]==-1)\n\t\t\tcontinue;\n\t\tfor (pii j : pref[wek[i].first])\n\t\t{\n\t\t\t//~ debug() << i << \" \" << j << \" \" << scal[i];\n\t\t\tint x=j.first+scal[i];\n\t\t\tif (x>=m)\n\t\t\t\tnpref.push_back({x/m, j.second});\n\t\t}\n\t}\n\tfor (int i=k-1; i>=0; i--)\n\t{\n\t\tif (tyl[i]==-1)\n\t\t\tcontinue;\n\t\tfor (pii j : suf[wek[i].first])\n\t\t{\n\t\t\tint x=j.first+tyl[i+1];\n\t\t\tif (x>=m)\n\t\t\t\tnsuf.push_back({x/m, j.second});\n\t\t}\n\t}\n\t\n\t//~ debug() << npref << \" \" << nsuf;\n\tlacz(npref);\n\tlacz(nsuf);\n\t//~ exit(0);\n\tint ncal=scal[k];\n\t\n\tdebug() << \"  \" << ncal << \" \" << npref << \" \" << nsuf << \" \" << imie(wyn);\n\t//~ exit(0);\n\t\n\tif (!npref.empty() || !nsuf.empty() || ncal>=m)\n\t{\n\t\tpref[wek[0].first]=npref;\n\t\tsuf[wek[0].first]=nsuf;\n\t\tcal[wek[0].first]=ncal/m;\n\t\tif (ncal<m)\n\t\t\tcal[wek[0].first]=-1;\n\t\tmapa[v+1].push_back({wek[0].first, wek.back().second});\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tpref[i].push_back({1, 1});\n\t\tsuf[i].push_back({1, 1});\n\t\tcal[i]=1;\n\t\tmapa[tab[i]].push_back({i, i});\n\t}\n\tfor (auto i : mapa)\n\t{\n\t\tsort(i.second.begin(), i.second.end());\n\t\tvector <pii> pom;\n\t\tfor (pii j : i.second)\n\t\t{\n\t\t\tif (!pom.empty() && pom.back().second+1!=j.first)\n\t\t\t{\n\t\t\t\tbiegnij(i.first, pom);\n\t\t\t\tpom.clear();\n\t\t\t}\n\t\t\tpom.push_back(j);\n\t\t}\n\t\tbiegnij(i.first, pom);\n\t}\n\t\n\t\n\tprintf(\"%lld\\n\", wyn+n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, L;\nvector<int> v;\n\nstruct Elem {\n\tint value = 0;\n\tint l = 0, r = 0;\n\tint order;\n\n\tfriend bool operator<(Elem a, Elem b) {\n\t\treturn a.order < b.order;\n\t}\n};\n\nint calc_cost(vector<Elem> v) { \n\tint r = 0;\n\tint s = 0;\n\tfor (int i = L - 1; i < len(v); i++)\n\t\ts += v[i].r;\n\tfor (int i = 0; i < len(v); i++) {\n\t\tr += v[i].l * (v[i].r + s);\n\t\tif (i + L - 1 < len(v))\n\t\t\ts -= v[i + L - 1].r;\n\t}\n\treturn r;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, L;\n\tv.resize(n);\n\tscan v;\n\tset<Elem> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.insert({v[i], 1, 1, i});\n\tll rez = 0;\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tvector<Elem> t;\n\t\tvector<Elem> buf;\n\t\tint cur = 2e9;\n\t\tfor (auto e : s)\n\t\t\tif (e.value != -1) \n\t\t\t\tcur = min(cur, e.value);\n\t\tfor (auto e : s)\n\t\t\tif (e.value == cur)\n\t\t\t\tt.pb(e);\n\t\tt.pb({(int)-1e9, -1, -1});\n\t\tfor (auto e : t) {\n\t\t\tif (s.find(e) != s.end() && (buf.empty() || (--s.find(e)) == s.find(buf.back()))) {\n\t\t\t\tbuf.pb(e);\n\t\t\t} else {\n\t\t\t\tvector<Elem> _new(len(buf) / L, {cur + 1, 0, 0, -1});\n\t\t\t\tfor (int i = 0; i < len(_new); i++)\n\t\t\t\t\t_new[i].order = buf[i].order;\n\t\t\t\tif (len(buf) < L) {\n\t\t\t\t\tfor (int i = 0; i < len(buf); i++) {\n\t\t\t\t\t\trez += buf[i].l * buf[i].r;\n\t\t\t\t\t\tif (buf[i].value != -1)\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\tbuf[i].l = buf[i].r = 0;\n\t\t\t\t\t\tbuf[i].value = -1;\n\t\t\t\t\t}\n\t\t\t\t\t_new = buf;\n\t\t\t\t} else {\n\t\t\t\t\tchange = true;\n\t\t\t\t\trez += calc_cost(buf);\t\n\t\t\t\t\tint k = len(buf) % L + 1;\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].l += buf[j].l;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].l += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.l;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].r += buf[j].r;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].r += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.r;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\trez -= calc_cost(_new);\n\t\t\t\t}\n\t\t\t\tfor (auto e : buf)\n\t\t\t\t\ts.erase(e);\n\t\t\t\tfor (auto e : _new)\n\t\t\t\t\ts.insert(e);\n\t\t\t\tbuf.clear();\n\t\t\t\tif (e.value != -1e9)\n\t\t\t\t\tbuf.pb(e);\n\t\t\t}\n\t\t}\n\t\t// for (int i = 0; i < len(s); i++) {\n\t\t// \tprint \"{\", s[i].value, s[i].l, s[i].r, \"}\";\n\t\t// \t// print s[i].value;\n\t\t// \tsmart_io::print_start = \" \";\n\t\t// }\n\t\t// smart_io::print_start = \"\\n\";\n\t\tcur++;\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define N 400600\nmap<int,int> tp1;\nset<int> tp3;\nstruct sth{int l,r,lb,rb;friend bool operator <(sth a,sth b){return a.l<b.l;}};\nvector<sth> v[N];\nint su[N][2],vl[N][2],tp[N][2],ct,n,k,s[N],cnt;\nlong long as;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&s[i]);\n\t\ttp3.insert(s[i]);if(!tp1[s[i]])tp1[s[i]]=++cnt;\n\t\tv[tp1[s[i]]].push_back((sth){i,i,1,1});\n\t}\n\tint lb=1;\n\twhile(1)\n\t{\n\t\tint st=tp1[lb];\n\t\tsort(v[st].begin(),v[st].end());\n\t\tint sz=v[st].size(),las=v[st][0].l;\n\t\tfor(int i=0;i<sz;i++)\n\t\t{\n\t\t\tif(ct&&v[st][i].l!=v[st][i-1].r+1)\n\t\t\t{\n\t\t\t\tsu[ct+1][0]=su[ct+1][1]=0;\n\t\t\t\tint s1=ct/k;\n\t\t\t\tif(s1)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=1;j<=ct;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long r1=j+k-1,r2=j+1ll*k*k-2;\n\t\t\t\t\t\tif(r1<=ct&&r2>ct)as+=1ll*vl[j][1]*(su[ct][0]-su[r1-1][0]);\n\t\t\t\t\t\telse if(r1<=ct)as+=1ll*vl[j][1]*(su[r2][0]-su[r1-1][0]);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=1;j<s1;j++)tp[j][0]=su[(j+1)*k-1][0]-su[j*k-1][0];\n\t\t\t\t\ttp[s1][0]=su[ct][0]-su[s1*k-1][0];\n\t\t\t\t\tfor(int j=1;j<s1;j++)tp[s1-j+1][1]=-su[ct-(j+1)*k+1][1]+su[ct-j*k+1][1];\n\t\t\t\t\ttp[1][1]=su[ct-s1*k+1][1];\n\t\t\t\t\tif(!tp1[lb+1])tp1[lb+1]=++ct,tp3.insert(lb+1);\n\t\t\t\t\tfor(int j=1;j<=s1;j++)v[tp1[lb+1]].push_back((sth){las+j-1,j==s1?v[st][i-1].r:las+j-1,tp[j][0],tp[j][1]});\n\t\t\t\t}\n\t\t\t\tct=0;las=v[st][i].l;\n\t\t\t}\n\t\t\tvl[++ct][0]=v[st][i].lb;vl[ct][1]=v[st][i].rb;\n\t\t\tsu[ct][0]=su[ct-1][0]+vl[ct][0];su[ct][1]=su[ct-1][1]+vl[ct][1];\n\t\t}\n\t\tsu[ct+1][0]=su[ct+1][1]=0;\n\t\tint s1=ct/k;\n\t\tif(s1)\n\t\t{\n\t\t\tfor(int j=1;j<=ct;j++)\n\t\t\t{\n\t\t\t\tlong long r1=j+k-1,r2=j+1ll*k*k-2;\n\t\t\t\tif(r1<=ct&&r2>ct)as+=1ll*vl[j][1]*(su[ct][0]-su[r1-1][0]);\n\t\t\t\telse if(r1<=ct)as+=1ll*vl[j][1]*(su[r2][0]-su[r1-1][0]);\n\t\t\t}\n\t\t\tfor(int j=1;j<s1;j++)tp[j][0]=su[(j+1)*k-1][0]-su[j*k-1][0];\n\t\t\ttp[s1][0]=su[ct][0]-su[s1*k-1][0];\n\t\t\tfor(int j=1;j<s1;j++)tp[s1-j+1][1]=-su[ct-(j+1)*k+1][1]+su[ct-j*k+1][1];\n\t\t\ttp[1][1]=su[ct-s1*k+1][1];\n\t\t\tif(!tp1[lb+1])tp1[lb+1]=++cnt,tp3.insert(lb+1);\n\t\t\tfor(int j=1;j<=s1;j++)v[tp1[lb+1]].push_back((sth){las+j-1,j==s1?v[st][sz-1].r:las+j-1,tp[j][0],tp[j][1]});\n\t\t}\n\t\tct=0;\n\t\tset<int>::iterator it=tp3.lower_bound(lb+1);\n\t\tif(it==tp3.end())break;\n\t\tlb=*it;\n\t}\n\tprintf(\"%lld\\n\",as+n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ui unsigned int\n#define ull unsigned long long\n#define db long double\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define vi vector<int>\n#define vii vector<vi>\n#define lb lower_bound\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,b,a) for(int i=(b);i>=(a);--i)\n#define rep0(i,a,b) for(int i=(a);i<(b);++i)\n#define fore(i,a) for(int i=0;i<a.size();++i)\n#define gc() getchar()\n#define ls x<<1,l,m\n#define rs x<<1|1,m+1,r\ninline ll rd()\n{\n\tll x=0,w=1;char c=gc();while(!isdigit(c)&&c!='-')c=gc();\n\tif(c=='-')c=gc(),w=-1;while(isdigit(c))x=x*10+c-48,c=gc();return x*w;\n}\nconst int N=200005;\nint n,L,pre[N],nxt[N];ll ans,f1[N],f2[N],g1[N],g2[N];\nvi V1,V2;priority_queue<pii,vector<pii>,greater<pii> >Q;\ninline void link(int x,int y){pre[y]=x;nxt[x]=y;}\ninline ll calc(int x)\n{\n\tint m=V2.size(),c=m/L,pl=pre[V2[0]],pr=nxt[V2[m-1]];ll res=0;\n\tll s=0;rep0(i,0,m){s+=i>=L-1?f1[V2[i-L+1]]:0;res+=s*f2[V2[i]];}\n\tfor(int i:V2)g1[i]=f1[i],g2[i]=f2[i],f1[i]=f2[i]=0;\n\tif(!c){nxt[pl]=n+1,pre[pr]=0;return res;}\n\trep0(i,L-1,m){int t=(i+1)/L-1;f2[V2[t]]+=g2[V2[i]];}\n\tper(i,m-L,0){int t=c-(m-i)/L;f1[V2[t]]+=g1[V2[i]];}\n\tlink(pl,V2[0]);rep0(i,1,c)link(V2[i-1],V2[i]);link(V2[c-1],pr);\n\trep0(i,0,c)Q.push(mp(x+1,V2[i]));\n\ts=0;rep0(i,0,c){s+=i>=L-1?f1[V2[i-L+1]]:0;res-=s*f2[V2[i]];}\n\treturn res;\n}\nint main()\n{\n\tn=rd();L=rd();rep(i,0,n)link(i,i+1);\n\trep(i,1,n){Q.push(mp(rd(),i));f1[i]=f2[i]=1;}\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.top().X;V1.clear();V2.clear();\n\t\twhile(!Q.empty()&&Q.top().X==x)V1.pb(Q.top().Y),Q.pop();\n\t\tfore(i,V1)\n\t\t{\n\t\t\tif(i&&nxt[V1[i-1]]!=V1[i])ans+=calc(x),V2.clear();\n\t\t\tV2.pb(V1[i]);\n\t\t}\n\t\tans+=calc(x);\n\t}\n\tprintf(\"%lld\\n\",ans+n);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[200005],cur,is[200005],pw[200005],fa[200005];\nint *pre[200005],*suf[200005],cnt[200005],nwa[200005];\nll ans;\nint dp[600005],*f=dp+400000;\nint w[25000005],*at=w;\npii b[200005];\nint *newI(int n){\n\tat+=n;\n\treturn at-n;\n}\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nint nex[200005],stk[400005],tp,ist[200005];\nvoid add(int x,int y){\n//\twrite(x,'-',y,'\\n');\n\tif(!ist[x]){stk[++tp]=x;}\n\tif(!ist[y]){stk[++tp]=y;}\n\tist[y]=-1;if(!ist[x])ist[x]=1;\t\n\tnex[x]=y;\n}\nvoid put(int x){\n\tis[x]=1;\n\tnwa[x]=a[x];\n\tcnt[x]=1;\n\tpre[x]=newI(1);pre[x][0]=1;suf[x]=newI(1);suf[x][0]=1;\n\tfa[x]=x;\n\tif(is[x-1]){add(find(x-1),x);}\n\tif(is[x+1]){add(x,find(x+1));}\n}\nint id[200005],m,n,l;\nvoid solve(){\n\tint cc=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(nwa[id[i]]!=cur){\n\t\t\tint S=pw[min(cur-nwa[id[i]],n)];\n//\t\t\twrite(id[i],' ',cnt[id[i]],' ',nwa[id[i]],' ',S,'\\n');\n\t\t\tint *p=pre[id[i]],*s=suf[id[i]];\n\t\t\tfor(int j=1;j<=cnt[id[i]];++j){\n\t\t\t\tint w=p[j-1];\n\t\t\t\tp[j-1]=0;\n\t\t\t\tif(j>=S)p[j/S-1]+=w;\n\t\t\t\tw=s[j-1];\n\t\t\t\ts[j-1]=0;\n\t\t\t\tif(j>=S)s[j/S-1]+=w;\n\t\t\t}\n\t\t\tcnt[id[i]]/=S;\n\t\t\tnwa[id[i]]=cur;\n\t\t}\n\t\tcc+=cnt[id[i]];\n\t}\t\n\n/*\twrite(m,'\\n');\n\tfor(int i=1;i<=m;++i){\n\t\twrite(cnt[id[i]],':');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('|');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('\\n');\n\t}*/\n\tint *np=newI(cc),*ns=newI(cc);\n\tint t=0;\n\tfor(int i=1;i<=m;++i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tnp[t]=pre[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tt=0;\n\tfor(int i=m;i;--i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tns[t]=suf[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tfor(int i=m;i;--i){\n\t\tfor(int j=1;j<=cnt[id[i]];++j)ans+=(ll)suf[id[i]][j-1]*f[max(1,l-j)];\n\t\tfor(int j=cnt[id[i]];j;--j){f[0]=f[1]+pre[id[i]][j-1];--f;}\n\t}\n\tfor(int i=1;i<=cc;++i)*(++f)=0;\n\t/*write(ans,'\\n');\n\twrite(cc,'|',id[1],'\\n');*/\n\tcnt[id[1]]=cc;\n\tpre[id[1]]=np;\n\tsuf[id[1]]=ns;\n}\nvoid work(){\n\tfor(;tp;--tp){\n\t\tif(ist[stk[tp]]<=0){ist[stk[tp]]=0;continue;}\n\t\tist[stk[tp]]=0;\n\t\tint at=stk[tp];\n\t\tm=0;\n\t\twhile(at){\n//\t\t\twrite(at,'(');\n\t\t\tid[++m]=at;\n\t\t\tfa[at]=stk[tp];\n\t\t\tint nx=nex[at];\n\t\t\tnex[at]=0;\n\t\t\tat=nx;\n\t\t}\n\t\tsolve();\n\t}\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tread(n,l);\n\tpw[0]=1;\n\tint iee=n/l+1;\n\tfor(int i=1;i<=n;++i)pw[i]=min(pw[i-1],iee)*l;\n\tfor(int i=1;i<=n;++i){read(a[i]);b[i]=make_pair(a[i],i);}\n\tsort(b+1,b+n+1);\n\tfor(int i=1,j=1;i<=n;i=j){\n\t\tcur=b[i].x;\n\t\twhile(b[i].x==b[j].x){put(b[j].y);++j;}\n\t\twork();\n\t}\n\twrite(ans+n,'\\n');\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 08.12.2019 08:24:29       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, len;\n  cin >> n >> len;\n  vector<int> a(n);\n  vector<int> L(n);\n  vector<int> R(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    L[i] = 1;\n    R[i] = 1;\n  }\n  long long ans = n;\n  set<pair<int, int>> s;\n  set<int> alive;\n  for (int i = 0; i < n; i++) {\n    s.emplace(a[i], i);\n    alive.insert(i);\n  }\n  while (!s.empty()) {\n    int id = s.begin()->second;\n    s.erase(s.begin());\n    vector<int> pos(1, id);\n    while (true) {\n      auto it = alive.lower_bound(pos.back() + 1);\n      if (it == alive.end() || a[*it] != a[id]) {\n        break;\n      }\n      s.erase(make_pair(a[*it], *it));\n      pos.push_back(*it);\n    }\n    int sz = (int) pos.size();\n    if (sz < len) {\n      continue;\n    }\n    {\n      long long sumL = 0;\n      for (int i = len - 1; i < sz; i++) {\n        sumL += L[pos[i - len + 1]];\n        ans += sumL * R[pos[i]];\n      }\n    }\n    for (int x : pos) {\n      alive.erase(x);\n    }\n    int new_sz = sz / len;\n    vector<int> newL(new_sz);\n    vector<int> newR(new_sz);\n    for (int i = 0; i < sz; i++) {\n      if (i >= len - 1) {\n        newR[(i - (len - 1)) / len] += R[pos[i]];\n      }\n      if (i <= sz - len) {\n        newL[new_sz - 1 - ((sz - len) - i) / len] += L[pos[i]];\n      }\n    }\n    for (int i = 0; i < new_sz; i++) {\n      alive.insert(pos[i]);\n      L[pos[i]] = newL[i];\n      R[pos[i]] = newR[i];\n      a[pos[i]] += 1;\n      s.emplace(a[pos[i]], pos[i]);\n    }\n    if (len <= new_sz) {\n      long long sumL = 0;\n      for (int i = len - 1; i < new_sz; i++) {\n        sumL += L[pos[i - len + 1]];\n        ans -= sumL * R[pos[i]];\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 2e5 + 10, MAX_LOG_N = 40;\n\nint N, L, M, A[MAX_N], rnk[MAX_N], height[MAX_N];\nll powL[MAX_LOG_N], ans;\nvector<int> ltor[MAX_N], rtol[MAX_N];\nint segmax[MAX_N];\n\nstruct DSU {\n    int pa[MAX_N], lb[MAX_N], rb[MAX_N];\n\n    int find(int x) { return pa[x] == x ? x : pa[x] = find(pa[x]); }\n\n    int lbound(int x) { return lb[find(x)]; }\n\n    int rbound(int x) { return rb[find(x)]; }\n\n    void init(int n) {\n        for (int i = 1; i <= n; i++) pa[i] = lb[i] = rb[i] = i;\n    }\n\n    void merge(int a, int b) {\n        a = find(a); b = find(b);\n        pa[a] = b;\n        rb[b] = max(rb[a], rb[b]);\n        lb[b] = min(lb[a], lb[b]);\n    }\n} dsu;\n\nbool adjacent(int a, int b) {\n    if (a > b) swap(a, b);\n    if (b - a == 1) return true;\n    return A[a + 1] <= A[a] && dsu.find(a + 1) == dsu.find(b - 1);\n}\n\nvoid init() {\n    scanf(\"%d%d\", &N, &L); ans = N;\n    powL[0] = 1;\n    while (powL[M] * L <= N) powL[M + 1] = powL[M] * L, M++;\n    for (int i = 1; i <= N; i++) scanf(\"%d\", &A[i]);\n    for (int i = 1; i <= N; i++) rnk[i] = i;\n    sort(rnk + 1, rnk + N + 1, [](const int &lhs, const int &rhs) {\n                                   if (A[lhs] != A[rhs]) return A[lhs] < A[rhs];\n                                   return lhs < rhs;\n                               });\n    dsu.init(N);\n}\n\nvoid get_ans(int lb, int rb, const vector<int> &walls) {\n    int wh = A[walls.front()];\n    list<int> pending;\n    int lcnt = 0;\n    auto add = [&](int x){\n                   pending.push_back(x);\n                   if (pending.size() >= L) {\n                       lcnt += pending.front();\n                       pending.pop_front();\n                   }\n               };\n\n    auto eraseAll = [&]{\n                        pending.clear();\n                        lcnt = 0;\n                    };\n    if (walls.front() != lb) {\n        int x = dsu.find(lb);\n        int h = height[x];\n        if (wh - h <= M) {\n            int r = powL[wh - h];\n            vector<int> t;\n            for (int i = 1; i <= rtol[x].size(); i++) {\n                if (i < r) continue;\n                if (i % r == 0) t.push_back(0);\n                t.back() += rtol[x][i - 1];\n            }\n            for (int i = t.size() - 1; i >= 0; i--)\n                add(t[i]);\n        }\n    }\n    for (int wall : walls) {\n        add(1);\n        vector<int> tr;\n        tr.push_back(1);\n        int x = wall + 1;\n        if (x <= rb && A[x] != wh) {\n            x = dsu.find(x);\n            int h = height[x];\n            if (wh - h <= M) {\n                int r = powL[wh - h];\n                for (int i = 1; i <= ltor[x].size(); i++) {\n                    if (i < r) continue;\n                    if (i % r == 0) tr.push_back(0);\n                    tr.back() += ltor[x][i - 1];\n                }\n            }\n        }\n        ll tcnt = lcnt;\n        list<int>::iterator j = pending.begin();\n        for (int i = 0; i < tr.size(); i++) {\n            ans += tr[i] * tcnt;\n            if (i + 1 + pending.size() >= L && j != pending.end()) {\n                tcnt += *j;\n                j++;\n            }\n        }\n        if (x <= rb && A[x] != wh) {\n            int h = height[x];\n            if (wh - h <= M) {\n                int r = powL[wh - h];\n                if (segmax[x] < r) eraseAll();\n                vector<int> t;\n                for (int i = 1; i <= rtol[x].size(); i++) {\n                    if (i < r) continue;\n                    if (i % r == 0) t.push_back(0);\n                    t.back() += rtol[x][i - 1];\n                }\n                for (int i = t.size() - 1; i >= 0; i--)\n                    add(t[i]);\n            } else eraseAll();\n        }\n    }\n}\n\nvector<int> get_ltor(int lb, int rb, const vector<int> &walls) {\n    int wh = A[walls.front()];\n    vector<int> res;\n    if (lb != walls.front()) {\n        int x = dsu.find(lb);\n        int h = height[x];\n        if (wh - h > M) return res;\n        int r = powL[wh - h];\n        for (int i = 1; i <= ltor[x].size(); i++) {\n            if (i < r) continue;\n            if (i % r == 0) res.push_back(0);\n            res.back() += ltor[x][i - 1];\n        }\n        if (segmax[x] < r) return res;\n    }\n    for (int i = 0; i < walls.size(); i++) {\n        res.push_back(1);\n        int x = walls[i] + 1;\n        if (x > rb || A[x] == wh) continue;\n        x = dsu.find(x);\n        int h = height[x];\n        if (wh - h > M) return res;\n        int r = powL[wh - h];\n        for (int i = 1; i <= ltor[x].size(); i++) {\n            if (i < r) continue;\n            if (i % r == 0) res.push_back(0);\n            res.back() += ltor[x][i - 1];\n        }\n        if (segmax[x] < r) return res;\n    }\n    return res;\n}\n\nvector<int> get_rtol(int lb, int rb, const vector<int> &walls) {\n    vector<int> res;\n    int wh = A[walls.back()];\n    if (rb != walls.back()) {\n        int x = dsu.find(rb);\n        int h = height[x];\n        if (wh - h > M) return res;\n        int r = powL[wh - h];\n        for (int i = 1; i <= rtol[x].size(); i++) {\n            if (i < r) continue;\n            if (i % r == 0) res.push_back(0);\n            res.back() += rtol[x][i - 1];\n        }\n        if (segmax[x] < r) return res;\n    }\n    for (int i = walls.size() - 1; i >= 0; i--) {\n        res.push_back(1);\n        int x = walls[i] - 1;\n        if (x < lb || A[x] == wh) continue;\n        x = dsu.find(x);\n        int h = height[x];\n        if (wh - h > M) return res;\n        int r = powL[wh - h];\n        for (int i = 1; i <= rtol[x].size(); i++) {\n            if (i < r) continue;\n            if (i % r == 0) res.push_back(0);\n            res.back() += rtol[x][i - 1];\n        }\n        if (segmax[x] < r) return res;\n    }\n    return res;\n}\n\nint get_segmax(int lb, int rb, const vector<int> &walls) {\n    int res = 0;\n    int wh = A[walls.front()];\n    if (lb != walls.front()) {\n        int x = dsu.find(lb);\n        int h = height[x];\n        if (wh - h > M) return -1;\n        int r = powL[wh - h];\n        if (segmax[x] < r) return -1;\n        res += segmax[x] / r;\n    }\n    for (int i = 0; i < walls.size(); i++) {\n        res++;\n        int x = walls[i] + 1;\n        if (x > rb || A[x] == wh) continue;\n        x = dsu.find(x);\n        int h = height[x];\n        if (wh - h > M) return -1;\n        int r = powL[wh - h];\n        if (segmax[x] < r) return -1;\n        res += segmax[x] / r;\n    }\n    return res;\n}\n\nvoid solve() {\n    for (int l = 1, r; l <= N; l = r + 1) {\n        vector<int> walls = {rnk[l]};\n        for (r = l; r < N && A[rnk[r + 1]] == A[rnk[l]] && adjacent(rnk[r + 1], rnk[r]); r++) walls.push_back(rnk[r + 1]);\n        int lb = walls.front(), rb = walls.back();\n        if (lb > 1 && A[lb - 1] <= A[lb]) lb = dsu.lbound(lb - 1);\n        if (rb < N && A[rb + 1] <= A[rb]) rb = dsu.rbound(rb + 1);\n        get_ans(lb, rb, walls);\n        vector<int> curr_ltor = get_ltor(lb, rb, walls);\n        vector<int> curr_rtol = get_rtol(lb, rb, walls);\n        int curr_segmax = get_segmax(lb, rb, walls);\n        int curr_height = A[walls.front()];\n        for (int i = 0; i < walls.size(); i++) {\n            if (walls[i] + 1 <= rb)\n                dsu.merge(walls[i], walls[i] + 1);\n            if (walls[i] - 1 >= lb)\n                dsu.merge(walls[i], walls[i] - 1);\n        }\n        int x = dsu.find(walls.front());\n        ltor[x] = curr_ltor;\n        rtol[x] = curr_rtol;\n        segmax[x] = curr_segmax;\n        height[x] = curr_height;\n    }\n}\n\nvoid print() {\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    init();\n    solve();\n    print();\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n  if(abs(a) < eps && abs(b) < eps) return 0;\n  else if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n  if(a < b) return -1;\n  return 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n  if(a < b) return -1;\n  if(a == b) return 0;\n  return 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n  if(na == 0) return 0;\n  int be = 0, en = na - 1;\n  if(*a <= *(a + na - 1)){\n    if(f_lb == 0) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != 1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != -1) en = mid;\n      else be = mid + 1;\n    }\n    if(f_small && jud(*(a + be), val) == 1) be--;\n    if(!f_small && jud(*(a + be), val) == -1) be++;\n  } else {\n    if(f_lb) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != -1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != 1) en = mid;\n      else be = mid + 1;\n    }\n    if(!f_small && jud(*(a + be), val) == -1) be--;\n    if(f_small && jud(*(a + be), val) == 1) be++;\n  }\n  return be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n  if(m < 0) return 0;\n  long long ans = 1;\n  long long k = n;\n  while(m){\n    if(m & 1) {\n      ans *= k;\n      if(mod) ans %= mod;\n    }\n    k *= k;\n    if(mod) k %= mod;\n    m >>= 1;\n  }\n  return ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n  if(mod == -1) mod = MOD;\n  a += b;\n  while(a >= mod) a -= mod;\n  while(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    cerr << arr[i] << ' ';\n  cerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    output1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 200100;\nint n, l;\nint orig[maxn];\nstruct Range {\n  int from, to;\n  vi align_to[2];\n  bool operator < (const Range& other) const {\n    if (from == other.from) {\n      return to < other.to;\n    }\n    return from < other.from;\n  }\n} buf[maxn * 3];\nint lbuf;\nmap<int, vector<int>> all_range;\nint temp[2][maxn], ltemp;\n\n\nint main() {\n  //............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！........................................\n  ios_base::sync_with_stdio(0);\n  #ifdef DEBUG //......................................................................................................\n  freopen(\"input.txt\", \"r\", stdin);\n  #endif //...........................................................................................................\n\n  scanf(\"%d%d\", &n, &l);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", orig + i);\n    buf[lbuf].from = i;\n    buf[lbuf].to = i + 1;\n    buf[lbuf].align_to[0].push_back(0);\n    buf[lbuf].align_to[1].push_back(0);\n    buf[lbuf].align_to[0].push_back(1);\n    buf[lbuf].align_to[1].push_back(1);\n    all_range[orig[i]].push_back(lbuf++);\n  }\n\n  ll ans = 0;\n  for (auto& it : all_range) {\n    vi& all_r = it.second;\n    sort(all_r.begin(), all_r.end(), [&](const int& a, const int& b) {\n      return buf[a] < buf[b];\n    });\n    for (int i = 0, nxt_i = 0; i < (int)all_r.size(); i = nxt_i) {\n      while (nxt_i < (int)all_r.size() - 1 &&\n          buf[all_r[nxt_i + 1]].from == buf[all_r[nxt_i]].to) {\n        nxt_i++;\n      }\n      nxt_i++;\n      ltemp = 1;\n      temp[0][0] = temp[1][0] = 0;\n      for (int j = i; j < nxt_i; j++) {\n        int no = all_r[j];\n        auto rbuf = buf[no];\n        ltemp--;\n        for (int k = 0, rsum = 0; k < (int)rbuf.align_to[0].size(); k++) {\n          temp[0][ltemp] += rbuf.align_to[0][k];\n          temp[1][ltemp++] += rbuf.align_to[1][rbuf.align_to[0].size() - k - 1];\n          if (k >= l) {\n            rsum += rbuf.align_to[1][rbuf.align_to[0].size() - k - 1 + l];\n          }\n          temp[0][ltemp] = temp[1][ltemp] = 0;\n          ans -= 1ll * rbuf.align_to[0][k] * rsum;\n        }\n      }\n      for (int j = l, sum = 0; j < ltemp; j++) {\n        sum += temp[1][j - l];\n        ans += 1ll * temp[0][j] * sum;\n      }\n\n      if (ltemp > l) {\n        buf[lbuf].from = buf[all_r[i]].from;\n        buf[lbuf].to = buf[all_r[nxt_i - 1]].to;\n        buf[lbuf].align_to[0].push_back(0);\n        buf[lbuf].align_to[1].push_back(0);\n        for (int j = l; j < ltemp; j++) {\n          if (j % l == 0) {\n            buf[lbuf].align_to[0].push_back(0);\n            buf[lbuf].align_to[1].push_back(0);\n          }\n          buf[lbuf].align_to[0].back() += temp[0][j];\n          buf[lbuf].align_to[1].back() += temp[1][ltemp - j - 1];\n        }\n        all_range[it.first + 1].push_back(lbuf++);\n      }\n    }\n  }\n\n  cout << ans + n << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint L;\n\nvector<int> a;\n\nstruct I {\n\tint amax;\n\tunordered_map<int,int> pref, suff;\n\tbool tot_okay;\n\tint tot_num;\n\tI() {\n\t\tamax = 0;\n\t\tpref[0] = 1; suff[0] = 1;\n\t\ttot_okay = true;\n\t\ttot_num = 0;\n\t}\n};\n\nI level_up(I v, int a){\n\tassert(a >= v.amax);\n\twhile(v.amax < a){\n\t\tv.amax += 1;\n\t\tbool did_something = false;\n\t\tunordered_map<int,int> newpref, newsuff;\n\t\tfor(auto q : v.pref){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewpref[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewpref[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tfor(auto q : v.suff){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewsuff[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewsuff[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tv.pref = newpref;\n\t\tv.suff = newsuff;\n\t\tif(v.tot_okay){\n\t\t\tif(v.tot_num == 0){\n\t\t\t} else if(v.tot_num < L){\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_okay = false;\n\t\t\t\tv.tot_num = 0;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_num /= L;\n\t\t\t}\n\t\t}\n\t\tif(!did_something) break;\n\t}\n\tv.amax = a;\n\treturn v;\n}\n\nlong long ans = 0;\n\nvector<int> arr(const unordered_map<int, int> f){\n\tvector<int> a(f.size(), -1);\n\tfor(pair<int,int> x : f){\n\t\ta[x.first] = x.second;\n\t}\n\treturn a;\n}\n\nI combine(I l, int a, I r){\n\tl = level_up(l, a);\n\tr = level_up(r, a);\n\tassert(a == l.amax);\n\tassert(a == r.amax);\n\tI res;\n\tres.amax = a;\n\tres.pref = res.suff = {};\n\tif(l.tot_okay && r.tot_okay){\n\t\tres.tot_okay = true;\n\t\tres.tot_num = l.tot_num + 1 + r.tot_num;\n\t} else {\n\t\tres.tot_okay = false;\n\t\tres.tot_num = 0;\n\t}\n\tfor(auto q : l.pref){\n\t\tres.pref[q.first] += q.second;\n\t}\n\tif(l.tot_okay){\n\t\tfor(auto q : r.pref){\n\t\t\tres.pref[q.first + l.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tfor(auto q : r.suff){\n\t\tres.suff[q.first] += q.second;\n\t}\n\tif(r.tot_okay){\n\t\tfor(auto q : l.suff){\n\t\t\tres.suff[q.first + r.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tvector<int> la = arr(l.suff);\n\tvector<int> ra = arr(r.pref);\n\tlong long cur = 0;\n\tcur += 1;\n\tlong long tot = 0;\n\tint j = (int)ra.size();\n\tfor(int i = 0; i < (int)la.size(); i++){\n\t\twhile(j > 0 && (j-1) + 1 + i >= L){\n\t\t\tj -= 1;\n\t\t\ttot += ra[j];\n\t\t}\n\t\tcur += la[i] * tot;\n\t}\n\tans += cur;\n\treturn res;\n}\n\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n >> L;\n\ta.resize(n);\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\n\tvector<int> b(n+2);\n\tvector<int> f(n+2);\n\tfor(int i = 0; i <= n+1; i++){\n\t\tb[i] = i-1;\n\t\tf[i] = i+1;\n\t}\n\tvector<I> data(n+2);\n\tvector<pair<int,int> > apos;\n\tfor(int i = 0; i < n; i++){\n\t\tapos.push_back({a[i], i+1});\n\t}\n\tsort(apos.begin(), apos.end());\n\tfor(auto _x : apos){\n\t\tint x = _x.second;\n\t\tf[b[x]] = f[x];\n\t\tb[f[x]] = b[x];\n\t\tdata[b[x]] = combine(data[b[x]], a[x-1], data[x]);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {int l, r, x;};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, l;\n    cin >> n >> l;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    struct Node {\n        int pre, nxt, val, l, r;\n        bool isNew;\n    };\n    vector<Node> t(n);\n    vector<pair<int, int>> s;\n    for (int i = 0; i < n; ++i) {\n        t[i].pre = i - 1;\n        t[i].nxt = i == n - 1 ? -1 : i + 1;\n        t[i].l = t[i].r = 1;\n        t[i].val = a[i];\n        t[i].isNew = false;\n        s.emplace_back(a[i], i);\n    }\n    sort(s.begin(), s.end(), greater<pair<int, int>>());\n    long long ans = 0;\n    auto connect = [&](int l, int r) {\n        if (l != -1)\n            t[l].nxt = r;\n        if (r != -1)\n            t[r].pre = l;\n    };\n    while (!s.empty()) {\n        int x = s.back().first;\n        vector<int> v, v1;\n        while (!s.empty() && s.back().first == x) {\n            int p = s.back().second;\n            if (t[p].pre == -1 || t[t[p].pre].val != x)\n                v.push_back(p);\n            if ((t[p].pre == -1 || t[t[p].pre].val != x || !t[t[p].pre].isNew) && t[p].isNew)\n                v1.push_back(p);\n            s.pop_back();\n        }\n        for (int p : v1) {\n            vector<int> ver;\n            for (int i = p; ; i = t[i].nxt) {\n                if (i == -1 || t[i].val != x || !t[i].isNew)\n                    break;\n                ver.push_back(i);\n            }\n            int sum = 0;\n            for (int i = l - 1; i < (int)ver.size(); ++i) {\n                sum += t[ver[i - l + 1]].l;\n                ans -= 1LL * sum * t[ver[i]].r;\n            }\n        }\n        for (int p : v) {\n            vector<int> ver;\n            for (int i = p; ; i = t[i].nxt) {\n                if (i == -1 || t[i].val != x)\n                    break;\n                ver.push_back(i);\n            }\n            if ((int)ver.size() < l) {\n                connect(t[p].pre, -1);\n                connect(-1, t[ver.back()].nxt);\n                continue;\n            }\n            int sum = 0;\n            for (int i = l - 1; i < (int)ver.size(); ++i) {\n                sum += t[ver[i - l + 1]].l;\n                ans += 1LL * sum * t[ver[i]].r;\n            }\n            int cnt = ver.size() / l;\n            vector<int> newL(cnt), newR(cnt);\n            for (int i = l - 1; i < (int)ver.size(); ++i) {\n                newL[cnt - (i - l + 1) / l - 1] += t[ver[ver.size() - i - 1]].l;\n                newR[(i - l + 1) / l] += t[ver[i]].r;\n            }\n            int lst = t[p].pre;\n            for (int i = 0; i < cnt; ++i) {\n                ++t[ver[i]].val;\n                t[ver[i]].isNew = true;\n                t[ver[i]].l = newL[i];\n                t[ver[i]].r = newR[i];\n                connect(lst, ver[i]);\n                s.emplace_back(t[ver[i]].val, ver[i]);\n                lst = ver[i];\n            }\n            connect(lst, t[ver.back()].nxt);\n        }\n    }\n    cout << ans + n << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint L;\n\nvector<int> a;\n\nstruct I {\n\tint amax;\n\tunordered_map<int,int> pref, suff;\n\tbool tot_okay;\n\tint tot_num;\n\tI() {\n\t\tamax = 0;\n\t\tpref[0] = 1; suff[0] = 1;\n\t\ttot_okay = true;\n\t\ttot_num = 0;\n\t}\n};\n\nI level_up(I v, int a){\n\tassert(a >= v.amax);\n\twhile(v.amax < a){\n\t\tv.amax += 1;\n\t\tbool did_something = false;\n\t\tunordered_map<int,int> newpref, newsuff;\n\t\tfor(auto q : v.pref){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewpref[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewpref[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tfor(auto q : v.suff){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewsuff[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewsuff[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tv.pref = newpref;\n\t\tv.suff = newsuff;\n\t\tif(v.tot_okay){\n\t\t\tif(v.tot_num == 0){\n\t\t\t} else if(v.tot_num < L){\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_okay = false;\n\t\t\t\tv.tot_num = 0;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_num /= L;\n\t\t\t}\n\t\t}\n\t\tif(!did_something) break;\n\t}\n\tv.amax = a;\n\treturn v;\n}\n\nlong long ans = 0;\n\nvector<int> arr(const unordered_map<int, int> f){\n\tvector<int> a(f.size(), -1);\n\tfor(pair<int,int> x : f){\n\t\ta[x.first] = x.second;\n\t}\n\treturn a;\n}\n\nI combine(I l, int a, I r){\n\tl = level_up(l, a);\n\tr = level_up(r, a);\n\tassert(a == l.amax);\n\tassert(a == r.amax);\n\tI res;\n\tres.amax = a;\n\tres.pref = res.suff = {};\n\tif(l.tot_okay && r.tot_okay){\n\t\tres.tot_okay = true;\n\t\tres.tot_num = l.tot_num + 1 + r.tot_num;\n\t} else {\n\t\tres.tot_okay = false;\n\t\tres.tot_num = 0;\n\t}\n\tres.pref = move(l.pref);\n\tif(l.tot_okay){\n\t\tfor(auto q : r.pref){\n\t\t\tres.pref[q.first + l.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tres.suff = move(r.suff);\n\tif(r.tot_okay){\n\t\tfor(auto q : l.suff){\n\t\t\tres.suff[q.first + r.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tvector<int> la = arr(l.suff);\n\tvector<int> ra = arr(r.pref);\n\tlong long cur = 0;\n\tcur += 1;\n\tlong long tot = 0;\n\tint j = (int)ra.size();\n\tfor(int i = 0; i < (int)la.size(); i++){\n\t\twhile(j > 0 && (j-1) + 1 + i >= L){\n\t\t\tj -= 1;\n\t\t\ttot += ra[j];\n\t\t}\n\t\tcur += la[i] * tot;\n\t}\n\tans += cur;\n\treturn res;\n}\n\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n >> L;\n\ta.resize(n);\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\n\tvector<int> b(n+2);\n\tvector<int> f(n+2);\n\tfor(int i = 0; i <= n+1; i++){\n\t\tb[i] = i-1;\n\t\tf[i] = i+1;\n\t}\n\tvector<I> data(n+2);\n\tvector<pair<int,int> > apos;\n\tfor(int i = 0; i < n; i++){\n\t\tapos.push_back({a[i], i+1});\n\t}\n\tsort(apos.begin(), apos.end());\n\tfor(auto _x : apos){\n\t\tint x = _x.second;\n\t\tf[b[x]] = f[x];\n\t\tb[f[x]] = b[x];\n\t\tdata[b[x]] = combine(data[b[x]], a[x-1], data[x]);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\nint a[1000010];\nstruct Val{\n\tint pos,val;\n\tVal(int a=0,int b=0)\n\t{\n\t\tpos=a;\n\t\tval=b;\n\t}\n};\nbool operator <(const Val& a,const Val& b)\n{\n\treturn a.val>b.val;\n}\npriority_queue<Val>q;\nint pre[2000010],nxt[2000010];\nint f[2000010],g[2000010];\nint sum1[2000010];\nint sum2[2000010];\nbool vis[2000010];\nint main()\n{\n\tlong long ans=0;\n\tint n,L;\n\tscanf(\"%d %d\",&n,&L);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tf[i]=g[i]=1;\n\t\tpre[i]=i-1;\n\t\tnxt[i]=i+1;\n\t\tq.push(Val(i,a[i]));\n\t}\n\tnxt[n]=0;\n\tint tot=n;\n\twhile(!q.empty())\n\t{\n\t\tint pos=q.top().pos;\n\t\tq.pop();\n\t\tif(vis[pos])continue;\n\t\tint lpos=pos,rpos=pos;\n\t\twhile(a[pre[lpos]]==a[pos])lpos=pre[lpos];\n\t\twhile(a[nxt[rpos]]==a[pos])rpos=nxt[rpos];\n\t\tint cnt=0;\n\t\tint lst=0;\n\t\tfor(int i=lpos;i!=nxt[rpos];i=nxt[i])\n\t\t{\n\t\t\tcnt++;\n\t\t\tif(i<=n)lst=cnt;\n\t\t\tsum1[cnt]=sum1[cnt-1]+f[i];\n\t\t\tsum2[cnt]=sum2[cnt-1]+g[i];\n\t\t\tvis[i]=true;\n\t\t\tif(lst&&cnt>=L)\n\t\t\t\tans+=(long long)g[i]*sum1[min(lst,cnt-L+1)];\n\t\t}\n\t\tif(cnt<L){\n\t\t\tnxt[pre[lpos]]=pre[nxt[rpos]]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<cnt/L;i++)\n\t\t{\n\t\t\tnxt[tot+i]=tot+i+1;\n\t\t\tpre[tot+i+1]=tot+i;\n\t\t}\n\t\tfor(int i=1;i<=cnt/L;i++)\n\t\t\ta[tot+i]=a[pos]+1;\n\t\tnxt[pre[lpos]]=tot+1;pre[tot+1]=pre[lpos];\n\t\tpre[nxt[rpos]]=tot+cnt/L;nxt[tot+cnt/L]=nxt[rpos];\n\t\tfor(int i=1;i<=cnt/L;i++)\n\t\t{\n\t\t\tg[tot+i]=sum2[min((i+1)*L-1,cnt)]-sum2[i*L-1];\n\t\t\tint ii=cnt/L-i+1;\n\t\t\tf[tot+i]=sum1[cnt-ii*L+1]-sum1[max(cnt-(ii+1)*L+1,0)];\n\t\t}\n\t\tq.push(Val(tot+1,a[tot+1]));\n\t\ttot+=cnt/L;\n\t\t/*\n\t\tprintf(\"current ans=%lld\\n\",ans);\n\t\tprintf(\"a:\");\n\t\tfor(int i=nxt[0];i;i=nxt[i])\n\t\t\tprintf(\" %d\",a[i]);\n\t\tprintf(\"\\nf:\");\n\t\tfor(int i=nxt[0];i;i=nxt[i])\n\t\t\tprintf(\" %d\",f[i]);\n\t\tprintf(\"\\ng:\");\n\t\tfor(int i=nxt[0];i;i=nxt[i])\n\t\t\tprintf(\" %d\",g[i]);\n\t\tprintf(\"\\n\\n\");\n\t\t*/\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxp];\nint main()\n{\n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<25;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue; assert(H[i+1]==H[i]+1);\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int j=1;j<=k;++j)\n\t\t\t{\n\t\t\t\ttmp[j].l=tmp[j].r=tmp[j-1].l+1;\n\t\t\t\ttmp[j].L=tmp[j].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\twhile(k) rec[i+1].push_back(tmp[k--]);\n\t\t}\n\t}\n\tassert(an>0);\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n//\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxp];\nint main()\n{\n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<25;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue;\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int i=1;i<=k;++i)\n\t\t\t{\n\t\t\t\ttmp[i].l=tmp[i].r=tmp[i-1].l+1;\n\t\t\t\ttmp[i].L=tmp[i].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\twhile(k) rec[i+1].push_back(tmp[k--]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>V;\ntypedef long long ll;\nconst int N=2e5+5;\nlong long ans;\nint n,L,a[N],i,j,x,aa[N];\nint g[N];\nV lv[N],rv[N];int mx[N];\nint gfa(int x){return g[x]==x?x:g[x]=gfa(g[x]);}\ninline bool cmp(int x,int y){return a[x]==a[y]?x<y:a[x]<a[y];}\nlong long mi;\nstruct atom{\n\tV l,r;int mx;bool full;\n\tinline void set(const atom&a,int mx2){\n\t\tll z=1;int zz=max(a.l.empty()?0:a.l.back(),a.r.empty()?0:a.r.back());\n\t\tfull=0;l.clear();r.clear();\n\t\tfor(mx=a.mx;mx<mx2 && z<=zz;z*=L,++mx);\n\t\tif(zz<z){mx=mx2;return;}\n\t\tfull=a.full;\n\t\tfor(int x:a.l)if(x>=z)l.push_back(x/z);\n\t\tfor(int x:a.r)if(x>=z)r.push_back(x/z);\n\t}\n}b[N],v[N];int xb;\nint w,l,s,st[N];bool bb[N];\ninline void uni(atom&zz){\n\tw=s=0;l=1;\n\tzz.full=1;zz.mx=b[1].mx;\n\tfor(int i=1;i<=xb;++i){\n\t\tzz.full&=b[i].full;\n\t\tif(!b[i].full)w=s=0,l=1;\n\t\tfor(int x:b[i].l){\n\t\t\tfor(;l<=w && st[l]+s+x>=L;++l)if(l<w && bb[l+1])s-=st[l+1];\n\t\t\tans+=l-1;\n\t\t}\n\t\tif(!b[i].r.empty()){\n\t\t\tif(l<=w)s+=b[i].r[0];int ow=w;\n\t\t\tfor(int x:b[i].r)st[++w]=x,bb[w]=0;bb[ow+1]=1;\n\t\t}\n\t}\n\tzz.r.resize(w);s=0;for(int i=w;i;--i)zz.r[i-1]=st[i]+s,s+=bb[i]?st[i]:0;\n\tw=0;\n\tfor(int i=xb;i;--i){\n\t\tif(!b[i].full)w=0;\n\t\tif(!b[i].l.empty()){\n\t\t\tint ow=w;reverse(b[i].l.begin(),b[i].l.end());\n\t\t\tfor(int x:b[i].l)st[++w]=x,bb[w]=0;bb[ow+1]=1;\n\t\t}\n\t}\n\tzz.l.resize(w);s=0;for(int i=w;i;--i)zz.l[w-i]=st[i]+s,s+=bb[i]?st[i]:0;\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>L;for(i=1;i<=n;++i)cin>>a[i],aa[i]=i,g[i]=i,v[i].l=v[i].r={1},v[i].mx=a[i],v[i].full=1;\n\tstd::sort(aa+1,aa+n+1,cmp);\n\tfor(i=1;i<=n;i=j){\n\t\txb=0;\n\t\tif(aa[i]>1 && a[aa[i]-1]<a[aa[i]])b[++xb].set(v[aa[i]-1],a[aa[i]]),g[aa[i]-1]=aa[i];\n\t\tfor(j=i+1,b[++xb]=v[aa[i]];j<=n && a[aa[j]]==a[aa[i]] && a[gfa(aa[j-1]+1)]<=a[aa[j]];++j){\n\t\t\tif(aa[j-1]+1<aa[j])b[++xb].set(v[aa[j]-1],a[aa[i]]),g[aa[j]-1]=aa[j];\n\t\t\tb[++xb]=v[aa[j]];g[aa[j-1]]=aa[j-1]+1;\n\t\t}\n\t\tif(aa[j-1]<n && a[aa[j-1]]>a[aa[j-1]+1])b[++xb].set(v[gfa(aa[j-1]+1)],a[aa[i]]),g[aa[j-1]]=aa[j-1]+1;\n\t\tuni(v[gfa(aa[i])]);\n\t}\n\tcout<<ans+n<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool convert(vector<int> tet, int k){\n\twhile (tet.size() > 1){\n\t\tif (tet[0] == tet.back() && tet.size() >= k) return true;\n\t\tint same = 1;\n\t\tint X = tet.back();\n\t\twhile (same < tet.size() && tet[tet.size()-same-1] == tet[tet.size()-1]) same++;\n\t\tif (same < k){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int e=0; e < same;e++) tet.pop_back();\n\t\tfor (int e=0; e < same/k; e++) tet.push_back(X+1);\n\t}\n\treturn (tet.size()==1);\n}\nsigned main() {\n\t#ifdef LOCAL\n\t\tfreopen(\"H_input.txt\", \"r\", stdin);\n\t\t//freopen(\"C_output.txt\", \"w\", stdout);\n\t#endif\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n, k;\n    cin >> n >> k;\n    vector<int> v(n);\n    for (int i=0; i < n; i++) cin >> v[i];\n    long long ans=0;\n\tfor (int i=0; i < n; i++){\n\t\tvector<int> tet;\n\t\tfor (int j=i; j < n; j++){\n\t\t\tif (!tet.size()){\n\t\t\t\tans++;\n\t\t\t\ttet.push_back(v[j]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbool good = true;\n\t\t\t\twhile (tet.back() < v[j]){\n\t\t\t\t\tint same = 1;\n\t\t\t\t\tint X = tet.back();\n\t\t\t\t\twhile (same < tet.size() && tet[tet.size()-same-1] == tet[tet.size()-1]) same++;\n\t\t\t\t\tif (same < k){\n\t\t\t\t\t\tgood = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int e=0; e < same;e++) tet.pop_back();\n\t\t\t\t\tfor (int e=0; e < same/k; e++) tet.push_back(X+1);\n\t\t\t\t}\n\t\t\t\tif (!good) break;\n\t\t\t\ttet.push_back(v[j]);\n\t\t\t\tif (convert(tet, k)){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define fi first\n#define se second\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii; \nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L;\nvector<pii> num;\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[2];\nint main()\n{\n//\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout); \n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x; read(x);\n\t\tnum.push_back(make_pair(x,i));\n\t}\n\tsort(num.begin(),num.end());\n\tll an=n;\n\tint cur=0,now=0,pt=0;\n\twhile(true)\n\t{\n\t\tcur^=1; rec[cur^1].clear();\n\t\tif(rec[cur].size()==0)\n\t\t{\n\t\t\tif(pt<num.size()) now=num[pt].fi;\n\t\t\telse break;\n\t\t}\n\t\telse ++now;\n\t\twhile(pt<num.size()&&num[pt].fi==now) rec[cur].push_back(node(num[pt].se,num[pt].se,1,1)),++pt;\n\t\tsort(rec[cur].begin(),rec[cur].end());\n\t\tfor(int l=0,r;l<rec[cur].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[cur].size()&&rec[cur][r+1].l==rec[cur][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue;\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[cur][j].R;\n\t\t\t\tan+=(ll)rec[cur][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[cur][l].l-1;\n\t\t\tfor(int j=1;j<=k;++j)\n\t\t\t{\n\t\t\t\ttmp[j].l=tmp[j].r=tmp[j-1].l+1;\n\t\t\t\ttmp[j].L=tmp[j].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[cur][r].r;\n\t\t\tfor(int j=l;j<=r;++j)\n\t\t\t{\n\t\t\t\tint x=j-l+1,y=r-j+1;\n\t\t\t\tif(x>=L) tmp[x/L].R+=rec[cur][j].R;\n\t\t\t\tif(y>=L) tmp[k-y/L+1].L+=rec[cur][j].L;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\tfor(int j=1;j<=k;++j) rec[cur^1].push_back(tmp[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst int N=2e5+1;\nint n,z;\npair<int,int>a[N];\nint l[N],r[N];\nint sl[N],sr[N],sx[N];\nint sz=0;\ndeque<pair<int,int> >v[2*N];\nvector<ll>pw;\nll ans=0;\nvoid shrink(int vt,int sf){\n\tint ls=v[vt].size()/sf;\n\tif(ls==0){\n\t\tv[vt].clear();return;\n\t}\n\tint gd=v[vt].back().se;\n\tfor(int i=0; i<ls ;i++){\n\t\tv[vt][i].fi=v[vt][(i+1)*sf-1].fi;\n\t\tif(i!=ls-1) v[vt][i].se=v[vt][(i+2)*sf-2].se;\n\t}\n\tv[vt][ls-1].se=gd;\n\tv[vt].resize(ls);\n}\nvoid merge(int ml,int mr){\n\tif(sx[mr]<=sx[ml]){\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=r[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sl[ml],pr=sr[ml];\n\t\tint ql=sl[mr],qr=sr[mr];\n\t\tint dl=l[ml],dr=r[mr];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint bona=v[ql][i].se-v[ql][i].fi+1;\n\t\t\tans+=1LL*bona*(v[pr][x-1].fi-dl+1);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++) v[pl].push_back(v[ql][i]);\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--) v[pr].push_front(v[qr][i]);\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dr]=sx[dl];\n\t\tsl[dr]=sl[dl];\n\t\tsr[dr]=sr[dl];\n\t}\n\telse{\n\t\tswap(ml,mr);\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=l[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sr[ml],pr=sl[ml];\n\t\tint ql=sr[mr],qr=sl[mr];\n\t\tint dl=l[mr],dr=r[ml];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint nxt=dl-1;\n\t\t\tint bona=v[ql][i].fi-v[ql][i].se+1;\n\t\t\tans+=1LL*bona*(dr-v[pr][x-1].fi+1);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++) v[pl].push_back(v[ql][i]);\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--) v[pr].push_front(v[qr][i]);\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dl]=sx[dr];\n\t\tsl[dl]=sl[dr];\n\t\tsr[dl]=sr[dr];\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> z;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> a[i].fi;\n\t\ta[i].se=i;\n\t}\n\tpw.push_back(1);\n\twhile(pw.back()*z<=n){\n\t\tpw.push_back(pw.back()*z);\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1; i<=n ;i++){\n\t\tint cl=i,cr=i;\n\t\twhile(cr<n && a[cr+1].fi==a[cl].fi) cr++;\n\t\ti=cr;\n\t\tfor(int j=cl; j<=cr ;j++){\n\t\t\tint x=a[j].se;\n\t\t\tl[x]=r[x]=x;\n\t\t\tsx[x]=a[j].fi;\n\t\t\tsl[x]=++sz;v[sz].push_back({x,x});\n\t\t\tsr[x]=++sz;v[sz].push_back({x,x});\n\t\t\tif(r[x-1]!=0) merge(x-1,x);\n\t\t\tif(l[x+1]!=0) merge(x,x+1);\n\t\t}\n\t}\n\tcout << ans+n << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 200005;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct NODE\n{\n\tint pre, nxt, wl, wr;\n\n\tNODE () {pre = nxt = wl = wr = 0;}\n};\n\nll ans;\nNODE chn[MX];\nint n, m;\npriority_queue<pii, vector<pii>, greater<pii> > que;\n\nvoid link(int a, int b)\n{\n\tchn[a].nxt = b;\n\tchn[b].pre = a;\n}\n\nbool near(int a, int b)\n{\n\treturn (chn[a].nxt == b);\n}\n\nvoid input()\n{\n\tread(n), read(m);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tint x;\n\t\tread(x);\n\t\tchn[i].wl = chn[i].wr = 1;\n\t\tlink(i, i+1);\n\t\tque.push(make_pair(x, i));\n\t}\n}\n\nvoid calc(int x, vector<int> pos)\n{\n\tint suml = 0;\n\tfor(int i=0; i<pos.size(); i++)\n\t{\n\t\tif(i-m+1 >= 0) suml += chn[pos[i-m+1]].wl;\n\t\tans += 1ll*suml*chn[pos[i]].wr;\n\t}\n\tif(pos.size() / m)\n\t{\n\t\tvector<NODE> new_node(pos.size() / m);\n\t\tfor(int i=0; i<pos.size(); i++)\n\t\t{\n\t\t\tif(i >= m-1) new_node[(i+1)/m-1].wr += chn[pos[i]].wr;\n\t\t\tif(pos.size()-i >= m) new_node[new_node.size()-(pos.size()-i)/m].wl += chn[pos[i]].wl;\n\t\t}\n\t\tsuml = 0;\n\t\tfor(int i=0; i<new_node.size(); i++)\n\t\t{\n\t\t\tif(i-m+1 >= 0) suml += new_node[i-m+1].wl;\n\t\t\tans -= 1ll*suml*new_node[i].wr;\n\t\t}\n\t\tfor(int i=0; i<new_node.size(); i++)\n\t\t{\n\t\t\tchn[pos[i]].wl = new_node[i].wl;\n\t\t\tchn[pos[i]].wr = new_node[i].wr;\n\t\t\tque.push(make_pair(x+1, pos[i]));\n\t\t}\n\t\tlink(pos[new_node.size()-1], chn[pos.back()].nxt);\n\t}\n\telse link(chn[*pos.begin()].pre, n+1), link(0, chn[pos.back()].nxt);\n}\n\nvoid work()\n{\n\twhile(!que.empty())\n\t{\n\t\tint curx = que.top().first;\n\t\tvector<int> pos, subpos;\n\t\twhile(!que.empty() && que.top().first==curx) pos.push_back(que.top().second), que.pop();\n\t\tfor(auto i : pos)\n\t\t{\n\t\t\tif(subpos.empty() || near(subpos.back(), i)) subpos.push_back(i);\n\t\t\telse calc(curx, subpos), subpos.clear(), subpos.push_back(i);\n\t\t}\n\t\tcalc(curx, subpos);\n\t}\n\tprintf(\"%lld\\n\", ans+n);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005;\nint n,l,p,v,a[N];\nll ans;\nvector<pair<int,int> > b,t1,t2,t3;\nvector<pair<pair<int,int>,pair<int,int> > > x,y;\nll calc(vector<pair<int,int> > &x){\n\tll sum=0,res=0;\n\tfor(unsigned i=l-1,j=0;i<x.size();i++,j++){\n\t\tsum+=x[j].first;\n\t\tres+=x[i].second*sum;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tb.push_back(make_pair(a[i],i));\n\t}\n\tsort(b.begin(),b.end());\n\twhile(1){\n\t\tif(x.empty()){\n\t\t\tif(p==n){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tv=b[p].first;\n\t\t\t}\n\t\t}else{\n\t\t\tv++;\n\t\t}\n\t\twhile(p<n&&b[p].first==v){\n\t\t\tx.push_back(make_pair(make_pair(b[p].second,b[p].second),make_pair(1,1)));\n\t\t\tp++;\n\t\t}\n\t\ty.clear();\n\t\tsort(x.begin(),x.end());\n\t\tfor(unsigned i=0,j;i<x.size();i=j+1){\n\t\t\tj=i;\n\t\t\twhile(j+1<x.size()&&x[j+1].first.first==x[j].first.second+1){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tint len=j-i+1,tot=len/l;\n\t\t\tif(tot){\n\t\t\t\tt1.clear();\n\t\t\t\tfor(unsigned k=i;k<=j;k++){\n\t\t\t\t\tt1.push_back(x[k].second);\n\t\t\t\t}\n\t\t\t\tans+=calc(t1);\n\t\t\t\tt2.clear();\n\t\t\t\tt3.clear();\n\t\t\t\tfor(int k=1;k<=tot;k++){\n\t\t\t\t\tt2.push_back(make_pair(x[i].first.first+k-1,k==tot?x[j].first.second:x[i].first.first+k-1));\n\t\t\t\t\tt3.push_back(make_pair(0,0));\n\t\t\t\t}\n\t\t\t\tfor(unsigned k=i;k<=j;k++){\n\t\t\t\t\tint l1=k-i+1,l2=j-k+1;\n\t\t\t\t\tif(l1>=l){\n\t\t\t\t\t\tt3[l1/l-1].second+=x[k].second.second;\n\t\t\t\t\t}\n\t\t\t\t\tif(l2>=l){\n\t\t\t\t\t\tt3[tot-l2/l].first+=x[k].second.first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans-=calc(t3);\n\t\t\t\tfor(int k=0;k<tot;k++){\n\t\t\t\t\ty.push_back(make_pair(t2[k],t3[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx=y;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000100000;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-11;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tinline long long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nint p[210000];\nset<pair<int,int> > S;\nset<pair<int,int> > T;\nint L[210000];\nint R[210000];\nint C[210000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tL[i]=R[i]=1;\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tS.insert(make_pair(i,p[i]));\n\t\tT.insert(make_pair(p[i],i));\n\t}\n\tlong long ret=0;\n\twhile(1){\n\t\tpair<int,int> d=*(T.begin());\n\t\tif(d.first>=mod)break;\n\t\tvector<int>v;\n\t\tset<pair<int,int> >::iterator it=S.lower_bound(make_pair(d.second,d.first));\n\t\twhile(it!=S.end()&&it->second==d.first){\n\t\t\tv.push_back(it->first);\n\t\t\tit++;\n\t\t}\n\t\tint cur=0;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tret+=(long long)L[v[i]]*R[v[i]];\n\t\t\tif(i-b+1>=0){\n\t\t\t\tcur+=L[v[i-b+1]];\n\t\t\t}\n\t\t\tret+=(long long)cur*R[v[i]];\n\t\t}\n\t\tvector<pair<pair<int,int>,pair<int,int> > >ad;\n\t\tif(v.size()<b){\n\t\t\tad.push_back(make_pair(make_pair(d.second,mod),make_pair(0,0)));\n\t\t}else{\n\t\t\tfor(int i=0;i<v.size()/b;i++){\n\t\t\t\tad.push_back(make_pair(make_pair(d.second+i,d.first+1),make_pair(0,0)));\n\t\t\t}\n\t\t\tint s=v.size();\n\n\t\t\tfor(int i=0;i<v.size();i++){\n\t\t\t\tint lv=L[v[i]];\n\t\t\t\tint rv=R[v[i]];\n\t\t\t\tif(v.size()/b-(v.size()-i)/b<ad.size())ad[v.size()/b-(v.size()-i)/b].second.first+=lv;\n\t\t\t\tif(i>=b-1)ad[(i-b+1)/b].second.second+=rv;\n\t\t\t}\n\t\t\tcur=0;\n\t\t\tfor(int i=0;i<ad.size();i++){\n\t\t\t\tret-=(long long)ad[i].second.first*ad[i].second.second;\n\t\t\t\tif(i-b+1>=0){\n\t\t\t\t\tcur+=ad[i-b+1].second.first;\n\t\t\t\t}\n\t\t\t\tret-=(long long)cur*ad[i].second.second;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tS.erase(make_pair(v[i],d.first));\n\t\t\tT.erase(make_pair(d.first,v[i]));\n\t\t}\n\t\tfor(int i=0;i<ad.size();i++){\n\t\t\tS.insert(ad[i].first);\n\t\t\tT.insert(make_pair(ad[i].first.second,ad[i].first.first));\n\t\t\tL[ad[i].first.first]=ad[i].second.first;\n\t\t\tR[ad[i].first.first]=ad[i].second.second;\n\t\t}\n\t\t// printf(\"%d %d: %lld\\n\",d.first,d.second,ret);\n\t\t// for(set<pair<int,int> >::iterator it=S.begin();it!=S.end();it++){\n\t\t\t// printf(\"%d %d %d %d\\n\",it->first,it->second,L[it->first],R[it->first]);\n\t\t// }\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define N 400600\nmap<int,int> tp1;\nset<int> tp3;\nstruct sth{int l,r,lb,rb;friend bool operator <(sth a,sth b){return a.l<b.l;}};\nvector<sth> v[N];\nint su[N][2],vl[N][2],tp[N][2],ct,n,k,s[N],cnt;\nlong long as;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&s[i]);\n\t\ttp3.insert(s[i]);if(!tp1[s[i]])tp1[s[i]]=++cnt;\n\t\tv[tp1[s[i]]].push_back((sth){i,i,1,1});\n\t}\n\tint lb=*tp3.lower_bound(1);\n\twhile(1)\n\t{\n\t\tint st=tp1[lb];\n\t\tsort(v[st].begin(),v[st].end());\n\t\tint sz=v[st].size(),las=v[st][0].l;\n\t\tfor(int i=0;i<sz;i++)\n\t\t{\n\t\t\tif(ct&&v[st][i].l!=v[st][i-1].r+1)\n\t\t\t{\n\t\t\t\tsu[ct+1][0]=su[ct+1][1]=0;\n\t\t\t\tint s1=ct/k;\n\t\t\t\tif(s1)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=1;j<=ct;j++){int r1=j+k-1;if(r1<=ct)as+=1ll*vl[j][1]*(su[ct][0]-su[r1-1][0]);}\n\t\t\t\t\tfor(int j=1;j<s1;j++)tp[j][0]=su[(j+1)*k-1][0]-su[j*k-1][0];\n\t\t\t\t\ttp[s1][0]=su[ct][0]-su[s1*k-1][0];\n\t\t\t\t\tfor(int j=1;j<s1;j++)tp[s1-j+1][1]=-su[ct-(j+1)*k+1][1]+su[ct-j*k+1][1];\n\t\t\t\t\ttp[1][1]=su[ct-s1*k+1][1];\n\t\t\t\t\tif(!tp1[lb+1])tp1[lb+1]=++ct,tp3.insert(lb+1);\n\t\t\t\t\tfor(int j=1;j<=s1;j++)v[tp1[lb+1]].push_back((sth){las+j-1,j==s1?v[st][i-1].r:las+j-1,tp[j][0],tp[j][1]});\n\t\t\t\t\tfor(int j=1;j<=s1;j++)vl[j][0]=tp[j][0],vl[j][1]=tp[j][1],su[j][0]=su[j-1][0]+vl[j][0],su[j][1]=su[j-1][0];\n\t\t\t\t\tfor(int j=1;j<=s1;j++){int r1=j+k-1;if(r1<=s1)as-=1ll*vl[j][1]*(su[s1][0]-su[r1-1][0]);}\n\t\t\t\t}\n\t\t\t\tct=0;las=v[st][i].l;\n\t\t\t}\n\t\t\tvl[++ct][0]=v[st][i].lb;vl[ct][1]=v[st][i].rb;\n\t\t\tsu[ct][0]=su[ct-1][0]+vl[ct][0];su[ct][1]=su[ct-1][1]+vl[ct][1];\n\t\t}\n\t\tsu[ct+1][0]=su[ct+1][1]=0;\n\t\tint s1=ct/k;\n\t\tif(s1)\n\t\t{\n\t\t\tfor(int j=1;j<=ct;j++)\n\t\t\t{\n\t\t\t\tint r1=j+k-1;\n\t\t\t\tif(r1<=ct)as+=1ll*vl[j][1]*(su[ct][0]-su[r1-1][0]);\n\t\t\t}\n\t\t\tfor(int j=1;j<s1;j++)tp[j][0]=su[(j+1)*k-1][0]-su[j*k-1][0];\n\t\t\ttp[s1][0]=su[ct][0]-su[s1*k-1][0];\n\t\t\tfor(int j=1;j<s1;j++)tp[s1-j+1][1]=-su[ct-(j+1)*k+1][1]+su[ct-j*k+1][1];\n\t\t\ttp[1][1]=su[ct-s1*k+1][1];\n\t\t\tif(!tp1[lb+1])tp1[lb+1]=++cnt,tp3.insert(lb+1);\n\t\t\tfor(int j=1;j<=s1;j++)v[tp1[lb+1]].push_back((sth){las+j-1,j==s1?v[st][sz-1].r:las+j-1,tp[j][0],tp[j][1]});\n\t\t\tfor(int j=1;j<=s1;j++)vl[j][0]=tp[j][0],vl[j][1]=tp[j][1],su[j][0]=su[j-1][0]+vl[j][0],su[j][1]=su[j-1][0];\n\t\t\tfor(int j=1;j<=s1;j++){int r1=j+k-1;if(r1<=s1)as-=1ll*vl[j][1]*(su[s1][0]-su[r1-1][0]);}\n\t\t}\n\t\tct=0;\n\t\tset<int>::iterator it=tp3.lower_bound(lb+1);\n\t\tif(it==tp3.end())break;\n\t\tlb=*it;\n\t}\n\tprintf(\"%lld\\n\",as+n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 12/11/2019, 4:20:39 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/optional.hpp> // for C++14\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\nconstexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nstruct Element\n{\n  int ind;\n  ll left, right;\n  boost::optional<int> value; // for C++14\n  bool operator<(Element const &rhs) const\n  {\n    return ind < rhs.ind;\n  }\n  bool operator==(Element const &rhs) const\n  {\n    return ind == rhs.ind;\n  }\n};\n\nElement make_element(int ind)\n{\n  return Element{ind, 0, 0, boost::none};\n}\n\nclass Solve\n{\n  int N, L;\n  set<Element> A;\n  map<int, vector<int>> indexes; // value -> inds\n\npublic:\n  Solve(int N, int L, vector<int> input) : N{N}, L{L}\n  {\n    for (auto i = 0; i < N; i++)\n    {\n      A.insert({i, 1, 1, input[i]});\n      indexes[input[i]];\n      indexes[input[i]].push_back(i);\n    }\n  }\n\n  ll count()\n  {\n    ll ans{N};\n    while (!indexes.empty())\n    {\n      vector<Element> tmp;\n      auto &vec{indexes.begin()->second};\n      sort(vec.begin(), vec.end());\n      int min_value{indexes.begin()->first};\n#if DEBUG == 1\n      cerr << \"min_value = \" << min_value << endl;\n#endif\n      for (auto ind : indexes[min_value])\n      {\n        auto it{A.find(make_element(ind))};\n#if DEBUG == 1\n        cerr << \"A[\" << it->ind << \"] = (\" << (it->value ? to_string(*it->value) : \"n\") << \", \" << it->right << \", \" << it->left << \")\" << endl;\n#endif\n        assert(it != A.end());\n        tmp.push_back(*it);\n        auto old{it};\n        ++it;\n        if (it == A.end() || it->value != min_value)\n        {\n          update(ans, tmp);\n        }\n        A.erase(old);\n      }\n      if (!tmp.empty())\n      {\n        update(ans, tmp);\n      }\n      indexes.erase(indexes.begin());\n    }\n    return ans;\n  }\n\nprivate:\n  void update(ll &ans, vector<Element> &tmp)\n  {\n    ans += calc(tmp);\n    tmp = press(tmp);\n    ans -= calc(tmp);\n    for (auto &&e : tmp)\n    {\n      A.insert(move(e));\n    }\n    tmp.clear();\n#if DEBUG == 1\n    cerr << \"updated.\" << endl;\n#endif\n  }\n\n  ll calc(vector<Element> const &X)\n  {\n    ll ans{0};\n    ll sum_right{0};\n    int S{static_cast<int>(X.size())};\n    for (auto i = L - 1; i < S; i++)\n    {\n      sum_right += X[i].right;\n    }\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans += X[i].left * sum_right;\n      sum_right -= X[i + L - 1].right;\n    }\n    assert(sum_right == 0);\n    return ans;\n  }\n\n  vector<Element> press(vector<Element> const &V)\n  {\n    assert(!V.empty());\n    int S{static_cast<int>(V.size())};\n    if (S < L)\n    {\n      return {{V[0].ind, 0, 0, boost::none}};\n    }\n    int index{V[0].ind};\n    int K{*V[0].value + 1};\n    vector<Element> ans(S / L);\n    for (auto &e : ans)\n    {\n      e.ind = index;\n      e.value = K;\n      indexes[K];\n      indexes[K].push_back(index);\n      ++index;\n    }\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].right += V[i].right;\n    }\n    int mod{S % L};\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans[(i + L - mod - 1) / L].left += V[i].left;\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  int N, L;\n  cin >> N >> L;\n  vector<int> A(N);\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> A[i];\n  }\n  Solve solve(N, L, A);\n  cout << solve.count() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxp];\nint main()\n{\n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<25;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue;\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int i=1;i<=k;++i)\n\t\t\t{\n\t\t\t\ttmp[i].l=tmp[i].r=tmp[i-1].l+1;\n\t\t\t\ttmp[i].L=tmp[i].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\twhile(k) rec[i+1].push_back(tmp[k--]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 200000\n#define pa pair<int,int>\n#define mp(x,y) make_pair(x,y)\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\npriority_queue<pa> q;\nint n,a[MN+5],b[MN+5],ans;\ninline int lst(int x){return x==1?n:x-1;}\ninline int nxt(int x){return x==n?1:x+1;}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) a[i]=read();\n    for(int i=1;i<=n;++i)\n    {\n        b[i]=read();\n        if(b[i]<a[i]) return 0*puts(\"-1\");\n        if(b[i]!=a[i]) q.push(mp(b[i],i));\n    }\n    while(!q.empty())\n    {\n        int x=q.top().second;q.pop();\n        int per=b[lst(x)]+b[nxt(x)];\n        int mx=q.empty()?int(1e9):((b[x]-max(b[lst(x)],b[nxt(x)]))/per+1);\n        mx=min(mx,(b[x]-a[x]+per-1)/per);\n        b[x]-=mx*per;\n        if(b[x]<a[x]) return 0*puts(\"-1\");\n        if(b[x]!=a[x]) q.push(mp(b[x],x));\n        ans+=mx;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=200000 +117;\nconst int MM=200000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n#define pii pair<int,int>\n#define mp make_pair \nint m,n,l;\nint a[NN]={};\nint v[NN][2]={};\nint xt[NN]={};\nint pre[NN]={};\nset<pii> all;\nint tp[NN][2]={};\nint sum[NN]={};\nint id[NN]={};\nint res[NN][2]={};\nLL calc(int v[NN][2],int len){\n\tfor(int i=1;i<=len;++i){\n\t\tsum[i]=sum[i-1]+v[i][1];\n\t}\n\tLL ans=0;\n\tfor(int i=1;i+l-1<=len;++i){\n\t\tans+=(LL)v[i][0]*(sum[len]-sum[i+l-2]);\n\t}\n\treturn ans;\n}\nint main(){\n\t//open();\n\tn=read();\n\tl=read();\n\tLL ans=n;\n\tfor(int i=1;i<=n;++i){\n\t\ta[i]=read();\n\t\tall.insert(mp(a[i],i));\n\t\tv[i][0]=v[i][1]=1;\n\t\txt[i]=i+1;\n\t\tpre[i]=i-1;\n\t}\n\twhile(!all.empty()){\n\t\tpii now=*all.begin();\n\t\tint val=now.first;\n\t\tint pos=now.second;\n\t\tint cnt=0;\n\t\twhile(a[pos]==val){\n\t\t\ttp[++cnt][0]=v[pos][0];\n\t\t\ttp[cnt][1]=v[pos][1];\n\t\t\tid[cnt]=pos;\n\t\t\tall.erase(mp(val,pos));\n\t\t\tpos=xt[pos];\n\t\t}\n\t\tif(cnt>=l){\n\t\t\tans+=calc(tp,cnt);\n\t\t\tint bcnt=cnt/l;\n\t\t\tfor(int i=1;i<=bcnt;++i){\n\t\t\t\tres[i][0]=res[i][1]=0;\n\t\t\t}\n\t\t\tfor(int i=l;i<=cnt;++i){\n\t\t\t\tres[i/l][1]+=tp[i][1];\n\t\t\t}\n\t\t\tfor(int i=cnt-l+1;i>=1;--i){\n\t\t\t\tres[bcnt+1-(cnt+1-i)/l][0]+=tp[i][0];\n\t\t\t}\n\t\t\tans-=calc(res,bcnt);\n\t\t\tfor(int i=1;i<=bcnt;++i){\n\t\t\t\tint pos=id[i];\n\t\t\t\tall.insert(mp(val+1,pos));\n\t\t\t\ta[pos]=val+1;\n\t\t\t\tv[pos][0]=res[i][0];\n\t\t\t\tv[pos][1]=res[i][1];\n\t\t\t}\n\t\t\txt[id[bcnt]]=xt[id[cnt]];\n\t\t\tpre[xt[id[bcnt]]]=id[bcnt];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 200233, inf = 1000000007;\nint n, L, a[N], lf[N], rf[N], lp[N], rp[N];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> s;\nll ans = 0;\n\nint main() {\n  scanf(\"%d%d\", &n, &L);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    lf[i] = rf[i] = 1;\n    lp[i] = i - 1;\n    rp[i] = i + 1;\n    s.push(make_pair(a[i], i));\n  }\n  rf[0] = 1;\n  lf[n + 1] = n;\n  while (1) {\n    int x = s.top().second;\n    s.pop();\n    if (a[x] == inf) break;\n    int y = x, cnt = 1;\n    vector<int> v(1, x);\n    while (a[rp[y]] == a[y]) {\n      cnt++;\n      y = rp[y];\n      v.push_back(y);\n      s.pop();\n    }\n    for (int i = 0, sum = 0; i < cnt; i++) {\n      ans += (ll) lf[v[i]] * rf[v[i]];\n      if (i - L + 1 >= 0) {\n        sum += lf[v[i - L + 1]];\n      }\n      ans += (ll) sum * rf[v[i]];\n    }\n    int lt = lp[x], rt = rp[y];\n    if (lt == 0 && rt == n + 1) {\n      break;\n    }\n    int cnt2 = cnt / L;\n    vector<int> nlf(cnt2, 0), nrf(cnt2, 0);\n    for (int i = 0; i < cnt; i++) {\n      if (cnt - i >= L) {\n        nlf[cnt2 - 1 - (cnt - i - L) / L] += rf[v[i]];\n      }\n      if (i + 1 >= L) {\n        nrf[(i + 1 - L) / L] += rf[v[i]];\n      }\n    }\n    for (int i = 0, sum = 0; i < cnt2; i++) {\n      ans -= (ll) nlf[i] * nrf[i];\n      if (i - L + 1 >= 0) {\n        sum += nlf[i - L + 1];\n      }\n      ans -= (ll) sum * nrf[i];\n    }\n    if (!cnt2) {\n      ++cnt2;\n      a[v[0]] = inf - 1;\n      nlf[0] = nrf[0] = 0;\n    }\n    for (int i = 0; i < cnt2; i++) {\n      a[v[i]]++;\n      s.push(make_pair(a[v[i]], v[i]));\n      lf[v[i]] = nlf[i];\n      rf[v[i]] = nrf[i];\n    }\n    lp[v[0]] = lt;\n    rp[v[cnt2 - 1]] = rt;\n    rp[lt] = v[0];\n    lp[rt] = v[cnt2 - 1];\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {int l, r, x;};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, l;\n    cin >> n >> l;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    struct Node {\n        int pre, nxt, val, l, r;\n        bool isNew;\n    };\n    vector<Node> t(n);\n    set<pair<int, int>> s;\n    for (int i = 0; i < n; ++i) {\n        t[i].pre = i - 1;\n        t[i].nxt = i == n - 1 ? -1 : i + 1;\n        t[i].l = t[i].r = 1;\n        t[i].val = a[i];\n        t[i].isNew = false;\n        s.emplace(a[i], i);\n    }\n    long long ans = 0;\n    auto connect = [&](int l, int r) {\n        if (l != -1)\n            t[l].nxt = r;\n        if (r != -1)\n            t[r].pre = l;\n    };\n    while (!s.empty()) {\n        int x = s.begin()->first;\n        vector<int> v, v1;\n        while (!s.empty() && s.begin()->first == x) {\n            int p = s.begin()->second;\n            if (t[p].pre == -1 || t[t[p].pre].val != x)\n                v.push_back(p);\n            if ((t[p].pre == -1 || t[t[p].pre].val != x || !t[t[p].pre].isNew) && t[p].isNew)\n                v1.push_back(p);\n            s.erase(s.begin());\n        }\n        for (int p : v1) {\n            vector<int> ver;\n            for (int i = p; ; i = t[i].nxt) {\n                if (i == -1 || t[i].val != x || !t[i].isNew)\n                    break;\n                ver.push_back(i);\n            }\n            int sum = 0;\n            for (int i = l - 1; i < (int)ver.size(); ++i) {\n                sum += t[ver[i - l + 1]].l;\n                ans -= 1LL * sum * t[ver[i]].r;\n            }\n        }\n        for (int p : v) {\n            vector<int> ver;\n            for (int i = p; ; i = t[i].nxt) {\n                if (i == -1 || t[i].val != x)\n                    break;\n                ver.push_back(i);\n            }\n            if ((int)ver.size() < l) {\n                connect(t[p].pre, t[ver.back()].nxt);\n                continue;\n            }\n            int sum = 0;\n            for (int i = l - 1; i < (int)ver.size(); ++i) {\n                sum += t[ver[i - l + 1]].l;\n                ans += 1LL * sum * t[ver[i]].r;\n            }\n            int cnt = ver.size() / l;\n            vector<int> newL(cnt), newR(cnt);\n            for (int i = l - 1; i < (int)ver.size(); ++i) {\n                newL[cnt - (i - l + 1) / l - 1] += t[ver[ver.size() - i - 1]].l;\n                newR[(i - l + 1) / l] += t[ver[i]].r;\n            }\n            int lst = t[p].pre;\n            for (int i = 0; i < cnt; ++i) {\n                ++t[ver[i]].val;\n                t[ver[i]].isNew = true;\n                t[ver[i]].l = newL[i];\n                t[ver[i]].r = newR[i];\n                connect(lst, ver[i]);\n                s.emplace(t[ver[i]].val, ver[i]);\n                lst = ver[i];\n            }\n            connect(lst, t[ver.back()].nxt);\n        }\n    }\n    cout << ans + n << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=500005,inf=0x3f3f3f3f;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,m,L,cnt,h[N],b[N],sl[N],sr[N];\nll ans;\ntypedef pair<int,int> pr;\npriority_queue<pr,vector<pr>,greater<pr> > f;\nstruct node{int val,l,r,pre,nex,col;}a[N];\nint getsum(int *s,int l,int r){return s[r]-s[l-1];}\nvoid split(int x){\n\tint cur=x;m=0;\n\twhile (a[x].val==a[cur].val){\n\t\tb[++m]=cur;\n\t\tsl[m]=sl[m-1]+a[cur].l;\n\t\tsr[m]=sr[m-1]+a[cur].r;\n\t\tcur=a[cur].nex;\n\t}\n}\nint getpre(int x){while(a[a[x].pre].val==a[x].val) x=a[x].pre;return x;}\nvoid recalc(){\n\tfor (int i=1,j=1;i<=m;i++){\n\t\twhile ((j-i+1<L)||(a[b[i]].col==a[b[j]].col)) j++;\n\t\tif (j<=m) ans+=(ll)a[b[i]].l*getsum(sr,j,m);\n\t\telse break;\n\t}\n}\nvoid printch(int x){\n\twhile (a[x].pre) x=a[x].pre;\n\tfor (;x;x=a[x].nex) printf(\"%d \",x);\n\tprintf(\"\\n\");\n}\nint main(){\n\tn=read();L=read();ans=cnt=n;\n\tfor (int i=1;i<=n;i++){\n\t\ta[i].val=read();a[i].l=a[i].r=1;\n\t\ta[i].pre=i-1;a[i].nex=i+1;h[i]=1;\n\t\tf.push(make_pair(a[i].val,i));\n\t}\n\ta[n].nex=0;\n\tfor (int i=1,j;i<=n;i=j){\n\t\tfor (j=i;a[i].val==a[j].val;j++);\n\t\tint len=j-i;\n\t\tif (len>=L) ans+=(ll)(len-L+1)*(len-L+2)/2;\n\t\twhile (i<j){a[i].col=j-1;i++;}\n\t}\n\twhile (1){\n\t\twhile (!h[f.top().second]) f.pop();\n\t\tint x=getpre(f.top().second),y;f.pop();\n\t\t//printch(x);\n\t\tif (a[x].val>=inf) break;\n\t\tsplit(x);\n\t\tfor (int i=1;i<=m;i++) h[b[i]]=0;\n\t\tx=a[b[1]].pre,y=a[b[m]].nex;\n\t\tif (m<L){\n\t\t\ta[++cnt].val=inf;\n\t\t\ta[cnt].pre=x;a[cnt].nex=y;\n\t\t\ta[cnt].col=cnt;\n\t\t\tif (x) a[x].nex=cnt;\n\t\t\tif (y) a[y].pre=cnt;\n\t\t\th[cnt]=1;f.push(make_pair(a[cnt].val,cnt));\n\t\t\tcontinue;\n\t\t}\n\t\trecalc();\n\t\tint r=m/L;\n\t\tfor (int i=1;i<=r;i++){\n\t\t\ta[cnt+i].val=a[b[1]].val+1;\n\t\t\tint tl=m-(r-i+1)*L+1,tr=max(1,tl-(L-1));\n\t\t\ta[cnt+i].l=getsum(sl,tr,tl);\n\t\t\ttl=i*L,tr=min(m,tl+L-1);\n\t\t\ta[cnt+i].r=getsum(sr,tl,tr);\n\t\t\ta[cnt+i].pre=(i!=1) ? (cnt+i-1) : x;\n\t\t\ta[cnt+i].nex=(i!=r) ? (cnt+i+1) : y;\n\t\t\ta[cnt+i].col=cnt+r;\n\t\t\th[cnt+i]=1;f.push(make_pair(a[cnt+i].val,cnt+i));\n\t\t}\n\t\tif (x) a[x].nex=cnt+1;\n\t\tif (y) a[y].pre=cnt+r;\n\t\tcnt+=r;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#define meow(args...) fprintf(stderr, args)\n\ntypedef std::pair<int, int> pair;\nstruct Element {\n\tint l, r;\n\tpair v;\n\tbool operator<(const Element &o) const {return l<o.l;}\n};\n\nconst int N=2e5;\n\nint n, l, x[N];\npair y[N];\n\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\nint read() {\n\tint a=0;\n\tunsigned char c;\n\twhile((c=getchar()-'0')>9);\n\twhile(a=a*10+c, (c=getchar()-'0')<=9);\n\treturn a;\n}\nlong long calc(std::vector<pair> jar) {\n\tint len=jar.size();\n\tlong long ans=0, lsum=0;\n\tfor(int i=l-1; i<len; ++i) {\n\t\tlsum+=jar[i-l+1].first;\n\t\tans+=lsum*jar[i].second;\n\t}\n\treturn ans;\n}\nint main() {\n\tn=read(), l=read();\n\tstd::generate(x, x+n, read);\n\tfor(int i=0; i<n; ++i) y[i]=pair(x[i], i);\n\tstd::sort(y, y+n);\n\n\tint m=0;\n\tpair *pos=y;\n\tlong long ans=n;\n\tstd::vector<Element> a, b;\n\twhile(true) {\n\t\tif(a.empty()) {\n\t\t\tif(pos==y+n) break;\n\t\t\tm=pos->first;\n\t\t} else ++m;\n\t\tfor(; pos->first==m; ++pos) a.push_back({pos->second, pos->second+1, pair(1, 1)});\n\t\tstd::sort(a.begin(), a.end());\n\t\tb.clear();\n\t\tfor(int i=0, j=0; i<a.size(); i=j) {\n\t\t\twhile(++j<a.size()&&a[j-1].r==a[j].l);\n\t\t\tint len=j-i, cnt=len/l;\n\t\t\tif(cnt!=0) {\n\t\t\t\tstd::vector<pair> cur, val(cnt);\n\t\t\t\tfor(int k=i; k<j; ++k) cur.push_back(a[k].v);\n\t\t\t\tfor(int k=i; k<j; ++k) {\n\t\t\t\t\tint tl=k-i+1, tr=j-k;\n\t\t\t\t\tif(tl>=l) val[tl/l-1].second+=a[k].v.second;\n\t\t\t\t\tif(tr>=l) val[cnt-tr/l].first+=a[k].v.first;\n\t\t\t\t}\n\t\t\t\tans+=calc(cur)-calc(val);\n\t\t\t\tfor(int k=0; k<cnt; ++k) b.push_back({a[i].l+k, a[i].l+k+1, val[k]});\n\t\t\t\tb.back().r=a[j-1].r;\n\t\t\t}\n\t\t}\n\t\ta=b;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair<int,int >\n#define iiii pair<pii,pii >\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i,x) for(int (i)=0;(i)<(x);(i)++)\ninline int getint(){\n\tint x=0,p=1;char c=getchar();\n\twhile (c<=32)c=getchar();\n\tif(c==45)p=-p,c=getchar();\n\twhile (c>32)x=x*10+c-48,c=getchar();\n\treturn x*p;\n}\nusing namespace std;\n//ruogu_alter\nconst int N=2e5+5;\nint n,l;\nll res;\npii b[N];\nvector<iiii >a;\n//\ninline ll calc(vector<pii >&v){\n\tll ans=0,sum=0;\n\tfor(int i=l-1,j=0;i<v.size();i++,j++){\n\t\tsum+=1ll*v[j].first;\n\t\tans+=1ll*v[i].second*sum;\n\t}\n\treturn ans;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=getint();l=getint();\n\trep(i,n){\n\t\tint x=getint();\n\t\tb[i]=mp(x,i);\n\t}\n\tsort(b,b+n);\n\tint pos=0,val=0;res=1ll*n;\n\twhile(1){\n\t\tif(a.empty()){\n\t\t\tif(pos==n)break;\n\t\t\telse val=b[pos].first;\n\t\t}\n\t\telse ++val;\n\t\twhile(pos<n&&b[pos].first==val){\n\t\t\ta.emplace_back(pii(b[pos].second,b[pos].second),pii(1,1));\n\t\t\t++pos;\n\t\t}\n\t\tsort(a.begin(),a.end());\n\t\tvector<iiii >toa;\n\t\tfor(int i=0,j;i<a.size();i=j+1){\n\t\t\tj=i;while(j<a.size()-1&&a[j].first.second+1==a[j+1].first.first)++j;\n\t\t\tint len=j-i+1,cnt=len/l;\n\t\t\tif(cnt){\n\t\t\t\tvector<pii >v,posx,posy;\n\t\t\t\tfor(int k=i;k<=j;k++)v.push_back(a[k].second);\n\t\t\t\tres+=calc(v);\n\t\t\t\trep(k,cnt){\n\t\t\t\t\tposx.emplace_back(a[i].first.first+k,a[i].first.first+k);\n\t\t\t\t\tposy.emplace_back(0,0);\n\t\t\t\t\tif(k==cnt-1)posx.back().second=a[j].first.second;\n\t\t\t\t}\n\t\t\t\tfor(int k=i;k<=j;k++){\n\t\t\t\t\tint tx=k-i+1,ty=j-k+1;\n\t\t\t\t\tif(tx>=l)posy[tx/l-1].second+=a[k].second.second;\n\t\t\t\t\tif(ty>=l)posy[cnt-ty/l].first+=a[k].second.first;\n\t\t\t\t}\n\t\t\t\tres-=calc(posy);\n\t\t\t\trep(k,posx.size())toa.emplace_back(posx[k],posy[k]);\n\t\t\t}\n\t\t}\n\t\ta=toa;\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 17.08.2019 16:20:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    // don't forget to set default value (used for leaves)\n    // not necessarily neutral element!\n    int sum = 0;\n\n    void apply(int l, int r, int v, bool SET = false) {\n      if (SET) {\n        sum = v;\n      } else {\n        sum += v;\n      }\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.sum = a.sum + b.sum;\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> vals;\n  for (int i = 0; i < n; i++) {\n    vals.push_back(a[i]);\n  }\n  sort(vals.begin(), vals.end());\n  vals.resize(unique(vals.begin(), vals.end()) - vals.begin());\n  segtree segt((int) vals.size());\n  auto Modify = [&](int at, int delta, bool SET = false) {\n    auto it = lower_bound(vals.begin(), vals.end(), at);\n    if (it != vals.end() && *it == at) {\n      int pos = (int) (it - vals.begin());\n      segt.modify(pos, pos, delta, SET);\n    }\n  };\n  vector<int> st;\n  vector<int> ends;\n  vector<int> good;\n  long long ans = 0;\n  map<int, int> how_many;\n  map<int, set<int>> at;\n  set<pair<int, int>> segs;\n  for (int itt = 0; itt < n; itt++) {\n    int x = a[itt];\n    while (!st.empty() && x > st.back()) {\n      int val = st.back();\n      int cnt = 0;\n      for (int j = (int) st.size() - 1; j >= 0; j--) {\n        if (st[j] != val) {\n          break;\n        }\n        ++cnt;\n      }\n      if (cnt < k) {\n        for (int y : st) {\n          Modify(y, 0, true);\n        }\n        st.clear();\n        ends.clear();\n        good.clear();\n        how_many.clear();\n        at.clear();\n        break;\n      }\n      for (int i = 0; i < k - 1; i++) {\n        if (good.back()) {\n          Modify(st.back(), -ends.back());\n        }\n        st.pop_back();\n        ends.pop_back();\n        good.pop_back();\n        --cnt;\n      }\n      vector<int> to_push;\n      while (cnt > 0) {\n        int sum = 0;\n        for (int i = 0; i < k && cnt > 0; i++) {\n          sum += ends.back();\n          if (good.back()) {\n            Modify(st.back(), -ends.back());\n          }\n          st.pop_back();\n          ends.pop_back();\n          good.pop_back();\n          --cnt;\n        }\n        to_push.push_back(sum);\n      }\n      while (!to_push.empty()) {\n        st.push_back(val + 1);\n        ends.push_back(to_push.back());\n        good.push_back(0);\n        at[st.back()].insert((int) st.size() - 1);\n        to_push.pop_back();\n      }\n      at[val].clear();\n      assert(how_many[val] >= k);\n      how_many.erase(val);\n      auto it = segs.lower_bound({val + 1, -1});\n      assert(it != segs.begin());\n      --it;\n      auto p = *it;\n      assert(p.first <= val && val <= p.second);\n      segs.erase(it);\n      if (p.first < val) {\n        segs.emplace(p.first, val - 1);\n      }\n      if (val < p.second) {\n        segs.emplace(val + 1, p.second);\n      }\n    }\n    while ((int) at[x].size() >= k) {\n      int pos = *at[x].begin();\n      at[x].erase(at[x].begin());\n      Modify(x, ends[pos]);\n      good[pos] = 1;\n    }\n    st.push_back(x);\n    ends.push_back(1);\n    good.push_back(0);\n    at[st.back()].insert((int) st.size() - 1);\n    int ptr = x;\n    while (true) {\n      int u = ++how_many[ptr];\n      if (u == k) {\n        int val = ptr;\n        int L = val;\n        int R = val;\n        auto it = segs.lower_bound({val + 1, -1});\n        if (it != segs.end() && it->first == val + 1) {\n          R = it->second;\n          it = segs.erase(it);\n        }\n        if (it != segs.begin() && prev(it)->second == val - 1) {\n          L = prev(it)->first;\n          segs.erase(prev(it));\n        }\n        segs.emplace(L, R);\n      }\n      if (u >= k) {\n        if (!at[ptr].empty()) {\n          int pos = *at[ptr].begin();\n          at[ptr].erase(at[ptr].begin());\n          Modify(ptr, ends[pos]);\n          good[pos] = 1;\n        }\n      }\n      if (u % k == 0) {\n        ++ptr;\n      } else {\n        break;\n      }\n    }\n    int val = x;\n    auto it = segs.lower_bound({val + 1, -1});\n    int up_to = x;\n    if (it != segs.begin()) {\n      --it;\n      auto p = *it;\n      if (p.first <= val && val <= p.second) {\n        up_to = p.second + 1;\n      }\n    }\n    int z = (int) (lower_bound(vals.begin(), vals.end(), up_to + 1) - vals.begin());\n    long long real_total = (z == 0 ? 0 : segt.get(0, z - 1).sum);\n    ans += real_total + 1;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef KOMAKI_LOCAL\n#define NDEBUG\n#endif\n\n#include <bits/stdc++.h>\n#include <sys/time.h>\n#include <unistd.h>\nusing namespace std;\n#define i64         int64_t\n#define rep(i, n)   for(i64 i = 0; (i) < ((i64)(n)); ++(i))\n#define bit(n)      (((i64)1)<<((i64)(n)))\n#define sz(v)       ((i64)((v).size()))\n\nstd::string dbgDelim(int &i){ return (i++ == 0 ? \"\" : \", \"); }\n#define dbgEmbrace(exp) { int i = 0; os << \"{\"; { exp; } os << \"}\"; return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp);\ntemplate <int INDEX, class TUPLE> void dbgDeploy(std::ostream &os, TUPLE _){}\ntemplate <int INDEX, class TUPLE, class H, class ...Ts> void dbgDeploy(std::ostream &os, TUPLE t){ os << (INDEX == 0 ? \"\" : \", \") << get<INDEX>(t); dbgDeploy<INDEX + 1, TUPLE, Ts...>(os, t); }\ntemplate <class T, class K> void dbgDeploy(std::ostream &os, std::pair<T, K> p, std::string delim){ os << \"(\" << p.first << delim << p.second << \")\"; }\ntemplate <class ...Ts> std::ostream& operator<<(std::ostream &os, std::tuple<Ts...> t){ os << \"(\"; dbgDeploy<0, std::tuple<Ts...>, Ts...>(os, t); os << \")\"; return os; }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p){ dbgDeploy(os, p, \", \"); return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v){ dbgEmbrace( for(T t: v){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> s){ dbgEmbrace( for(T t: s){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q){ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << q.front(); }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q){ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << (T) q.top();   }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp){ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp){ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\n#define DBG_OUT std::cerr\n#define DBG_OVERLOAD(_1, _2, _3, _4, _5, _6, macro_name, ...) macro_name\n#define DBG_LINE() { char s[99]; sprintf(s, \"line:%3d | \", __LINE__); DBG_OUT << s; }\n#define DBG_OUTPUT(v) { DBG_OUT << (#v) << \"=\" << (v); }\n#define DBG1(v, ...) { DBG_OUTPUT(v); }\n#define DBG2(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG1(__VA_ARGS__); }\n#define DBG3(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG2(__VA_ARGS__); }\n#define DBG4(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG3(__VA_ARGS__); }\n#define DBG5(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG4(__VA_ARGS__); }\n#define DBG6(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG5(__VA_ARGS__); }\n\n#define DEBUG0() { DBG_LINE(); DBG_OUT << std::endl; }\n#define DEBUG(...)                                                      \\\n  {                                                                     \\\n    DBG_LINE();                                                         \\\n    DBG_OVERLOAD(__VA_ARGS__, DBG6, DBG5, DBG4, DBG3, DBG2, DBG1)(__VA_ARGS__); \\\n    DBG_OUT << std::endl;                                               \\\n  }\n\n\n\nclass State\n{\npublic:\n    State(i64 l, i64 k, i64 num, State *inner):\n        l(l), k(k), cache(make_pair(0, -1)), q(queue<i64>()), total_score(0), inner(inner) {}\n\n    i64 score(i64 num)\n    {\n      if(num == 0) return 0;\n      if(cache.first) return cache.second;\n\n      //DEBUG(l, sz(q), num);\n      while(l <= sz(q) + num){\n        total_score += q.front();\n        q.pop();\n      }\n\n      i64 next_num = num + this->num;\n      i64 next_k = k;\n      while(0 < next_num && next_k < inner->k){\n        next_k += 1;\n        next_num /= l;\n      }\n\n      i64 ans = total_score;\n      if(next_k == inner->k) ans += inner->score(next_num);\n      cache = make_pair(1, ans);\n      return ans;\n    }\n\n    void inc(i64 n)\n    {\n      cache.first = 0;\n      q.push(n);\n    }\n\n    pair<i64, i64> cache;\n\n    i64 l;\n    i64 k;\n\n    queue<i64> q;\n    i64 total_score;\n\n    i64 num;\n    State* inner;\n};\n\nint main()\n{\n  State *state = new State(-1, bit(50), 1, NULL);\n\n  i64 n, l;\n  cin >> n >> l;\n  i64 ans = 0;\n\n  rep(step, n){\n    i64 k;\n    cin >> k;\n    while(state->k < k){\n      i64 cur_k = state->k;\n      i64 cur_num = state->num;\n      state = state->inner;\n\n      i64 t = 1;\n      for(i64 i = cur_k; t <= cur_num && i < state->k; ++i){\n        t *= l;\n      }\n      if(t <= cur_num){\n        vector<i64> v;\n        while(0 < cur_num){\n          if(cur_num < 2 * t){\n            v.push_back(cur_num);\n            cur_num = 0;\n          }else{\n            v.push_back(t);\n            cur_num -= t;\n          }\n        }\n        reverse(v.begin(), v.end());\n        for(auto d: v) state->inc(d);\n      }\n    }\n    if(state->k == k){\n      ans += state->score(1);\n      state->inc(1);\n    }else{\n      state = new State(l, k, 1, state);\n      state->inc(1);\n    }\n    //DEBUG(step, ans);\n  }\n  cout << ans + n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxp];\nint main()\n{\n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<25;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue; assert(H[i+1]==H[i]+1);\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int j=1;j<=k;++j)\n\t\t\t{\n\t\t\t\ttmp[j].l=tmp[j].r=tmp[j-1].l+1;\n\t\t\t\ttmp[j].L=tmp[j].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\tfor(int j=1;j<=k;++j) rec[i+1].push_back(tmp[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*20;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxn];\nint main()\n{\n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<20;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue;\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int i=1;i<=k;++i)\n\t\t\t{\n\t\t\t\ttmp[i].l=tmp[i].r=tmp[i-1].l+1;\n\t\t\t\ttmp[i].L=tmp[i].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\twhile(k) rec[i+1].push_back(tmp[k--]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst int N=2e5+1;\nint n,z;\npair<int,int>a[N];\nint l[N],r[N];\nint sl[N],sr[N],sx[N];\nint sz=0;\ndeque<pair<int,int> >v[2*N];\ndeque<int>gg[2*N];\nll hh[2*N];\nvector<ll>pw;\nll ans=0;\nvoid shrink(int vt,int sf){\n\tint ls=v[vt].size()/sf;\n\tif(ls==0){\n\t\tv[vt].clear();return;\n\t}\n\tint gd=v[vt].back().se;\n\tfor(int i=0; i<ls ;i++){\n\t\tv[vt][i].fi=v[vt][(i+1)*sf-1].fi;\n\t\tif(i!=ls-1) v[vt][i].se=v[vt][(i+2)*sf-2].se;\n\t}\n\tv[vt][ls-1].se=gd;\n\tv[vt].resize(ls);\n\thh[vt]=0;\n\tgg[vt].resize(ls);\n\tll mz=0;\n\tfor(int i=0; i<ls ;i++){\n\t\tmz+=max(v[vt][i].se,v[vt][i].fi)-min(v[vt][i].se,v[vt][i].fi)+1;\n\t\tgg[vt][i]=mz;\n\t}\n}\nvoid merge(int ml,int mr){\n\t//cout << \"merge \" << ml << ' ' << mr << endl;\n\tif(sx[mr]<=sx[ml]){\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();gg[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();gg[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=r[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sl[ml],pr=sr[ml];\n\t\tint ql=sl[mr],qr=sr[mr];\n\t\tint dl=l[ml],dr=r[mr];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint bona=v[ql][i].se-v[ql][i].fi+1;\n\t\t\tll bruh=0;\n\t\t\tif(x>=2) bruh=gg[pr][x-2];\n\t\t\tans+=1LL*bona*(gg[pr].back()-bruh);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tv[pl].push_back(v[ql][i]);\n\t\t\tgg[pl].push_back(gg[pl].back()+v[ql][i].se-v[ql][i].fi+1);\n\t\t}\n\t\tll mz=hh[pr];\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--){\n\t\t\tv[pr].push_front(v[qr][i]);\n\t\t\tgg[pr].push_front(mz);\n\t\t\tmz-=v[qr][i].fi-v[qr][i].se+1;\n\t\t\t//cout << v[qr][i].fi-v[qr][i].se+1 << endl;\n\t\t}\n\t\thh[pr]=mz;\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dr]=sx[dl];\n\t\tsl[dr]=sl[dl];\n\t\tsr[dr]=sr[dl];\n\t}\n\telse{\n\t\tswap(ml,mr);\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();gg[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();gg[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=l[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sr[ml],pr=sl[ml];\n\t\tint ql=sr[mr],qr=sl[mr];\n\t\tint dl=l[mr],dr=r[ml];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint bona=v[ql][i].fi-v[ql][i].se+1;\n\t\t\tll bruh=0;\n\t\t\tif(x>=2) bruh=gg[pr][x-2];\n\t\t\tans+=1LL*bona*(gg[pr].back()-bruh);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tv[pl].push_back(v[ql][i]);\n\t\t\tgg[pl].push_back(gg[pl].back()+v[ql][i].fi-v[ql][i].se+1);\n\t\t}\n\t\tll mz=hh[pr];\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--){\n\t\t\tv[pr].push_front(v[qr][i]);\n\t\t\tgg[pr].push_front(mz);\n\t\t\tmz-=v[qr][i].se-v[qr][i].fi+1;\n\t\t}\n\t\thh[pr]=mz;\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dl]=sx[dr];\n\t\tsl[dl]=sl[dr];\n\t\tsr[dl]=sr[dr];\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> z;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> a[i].fi;\n\t\ta[i].se=i;\n\t}\n\tpw.push_back(1);\n\twhile(pw.back()*z<=n){\n\t\tpw.push_back(pw.back()*z);\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1; i<=n ;i++){\n\t\tint cl=i,cr=i;\n\t\twhile(cr<n && a[cr+1].fi==a[cl].fi) cr++;\n\t\ti=cr;\n\t\tfor(int j=cl; j<=cr ;j++){\n\t\t\tint x=a[j].se;\n\t\t\tl[x]=r[x]=x;\n\t\t\tsx[x]=a[j].fi;\n\t\t\tsl[x]=++sz;v[sz].push_back({x,x});gg[sz].push_back(1);\n\t\t\tsr[x]=++sz;v[sz].push_back({x,x});gg[sz].push_back(1);\n\t\t\tif(r[x-1]!=0) merge(x-1,x);\n\t\t\tif(l[x+1]!=0) merge(x,x+1);\n\t\t}\n\t}\n\tcout << ans+n << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 12/11/2019, 4:20:39 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/optional.hpp> // for C++14\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\n// constexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nstruct Element\n{\n  int ind;\n  ll left, right;\n  boost::optional<int> value; // for C++14\n  bool operator<(Element const &rhs) const\n  {\n    return ind < rhs.ind;\n  }\n  bool operator==(Element const &rhs) const\n  {\n    return ind == rhs.ind;\n  }\n};\n\nElement make_element(int ind)\n{\n  return Element{ind, 0, 0, boost::none};\n}\n\nclass Solve\n{\n  int N, L;\n  set<Element> A;\n  map<int, vector<int>> indexes; // value -> inds\n\npublic:\n  Solve(int N, int L, vector<int> input) : N{N}, L{L}\n  {\n    for (auto i = 0; i < N; i++)\n    {\n      A.insert({i, 1, 1, input[i]});\n      indexes[input[i]];\n      indexes[input[i]].push_back(i);\n    }\n  }\n\n  ll count()\n  {\n    ll ans{N};\n    while (!indexes.empty())\n    {\n      vector<Element> tmp;\n      auto &vec{indexes.begin()->second};\n      sort(vec.begin(), vec.end());\n      int min_value{indexes.begin()->first};\n#if DEBUG == 1\n      cerr << \"min_value = \" << min_value << endl;\n#endif\n      for (auto ind : indexes[min_value])\n      {\n        auto it{A.find(make_element(ind))};\n#if DEBUG == 1\n        cerr << \"A[\" << it->ind << \"] = (\" << (it->value ? to_string(*it->value) : \"n\") << \", \" << it->right << \", \" << it->left << \")\" << endl;\n#endif\n        assert(it != A.end());\n        tmp.push_back(*it);\n        it = A.erase(it);\n        if (it == A.end() || it->value != min_value)\n        {\n          update(ans, tmp);\n        }\n      }\n      if (!tmp.empty())\n      {\n        update(ans, tmp);\n      }\n      indexes.erase(indexes.begin());\n    }\n    return ans;\n  }\n\nprivate:\n  void\n  update(ll &ans, vector<Element> &tmp)\n  {\n    ans += calc(tmp);\n    tmp = press(tmp);\n    ans -= calc(tmp);\n    for (auto e : tmp)\n    {\n      A.insert(e);\n    }\n    tmp.clear();\n#if DEBUG == 1\n    cerr << \"updated.\" << endl;\n#endif\n  }\n\n  ll calc(vector<Element> const &X)\n  {\n    ll ans{0};\n    ll sum_right{0};\n    int S{static_cast<int>(X.size())};\n    for (auto i = L - 1; i < S; i++)\n    {\n      sum_right += X[i].right;\n    }\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans += X[i].left * sum_right;\n      sum_right -= X[i + L - 1].right;\n    }\n    assert(sum_right == 0);\n    return ans;\n  }\n\n  vector<Element> press(vector<Element> const &V)\n  {\n    assert(!V.empty());\n    int S{static_cast<int>(V.size())};\n    if (S < L)\n    {\n      return {{V[0].ind, 0, 0, boost::none}};\n    }\n    int index{V[0].ind};\n    int K{*V[0].value + 1};\n    vector<Element> ans(S / L);\n    for (auto &e : ans)\n    {\n      e.ind = index;\n      e.value = K;\n      indexes[K];\n      indexes[K].push_back(index);\n      ++index;\n    }\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].right += V[i].right;\n    }\n    int mod{S % L};\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans[(i + L - mod - 1) / L].left += V[i].left;\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  int N, L;\n  cin >> N >> L;\n  vector<int> A(N);\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> A[i];\n  }\n  Solve solve(N, L, A);\n  cout << solve.count() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define N 200002\nusing namespace std;\nint a[N],b[N],c[N],d[N],e[N],f[N],i,j,k,m,n,o[N],p[N],q,w;long long x;bool g[N];\ninline bool cmp(int u,int v){return c[u]<c[v];}\ninline void solve(int u,int v)\n{\n    for(;c[a[u]]==c[u];g[u=a[u]]=true);\n    for(;c[b[v]]==c[v];g[v=b[v]]=true);\n    for(j=v,q=0;u<=j;j=a[j])o[++q]=e[j];\n    for(j=u,q=0;j<=v;j=b[j])p[++q]=f[j];\n    for(j=q,o[q+1]=p[q+1]=0;j;j--)o[j]+=o[j+1],p[j]+=p[j+1];\n    for(j=0;j<=q-m;j++)x+=(long long)(o[q-j]-o[q-j+1])*p[m+j];\n    for(w=c[u];w!=c[a[u]]&&w!=c[b[v]]&&m<=q;q=j,w++)for(j=k=0;(k+=m)<=q;)o[++j]=o[k],p[j]=p[k];\n    if(w!=c[a[u]]&&w!=c[b[v]])b[a[u]]=n+1,a[b[v]]=0;\n    else\n    {\n        for(j=o[q+1]=p[q+1]=0;j<=q-m;j++)x-=(long long)(o[q-j]-o[q-j+1])*p[m+j];\n        for(j=1,o[q+1]=p[q+1]=0;j<=q;j++)o[j]-=o[j+1],p[j]-=p[j+1];\n        for(j=u,k=0;k<q;j=b[j])c[j]=w,e[j]=o[q-k],f[j]=p[++k];\n        a[b[v]]=a[j],b[a[j]]=b[v];\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m),x=n;\n    for(i=1;i<=n;i++)scanf(\"%d\",c+i),d[i]=i,e[i]=f[i]=1,a[i]=i-1,b[i]=i+1;\n    for(sort(d+1,d+n+1,cmp),i=1;i<=n;i++)if(!g[d[i]])solve(d[i],d[i]);\n    return 0&printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,L;\nll ans;\nstruct Inter{\n\tint pos,val,l,r;\n\tInter(int _p=0,int _v=0,int _l=0,int _r=0){pos=_p,val=_v,l=_l,r=_r;}\n};\nstruct cmp1{\n\tbool operator ()(const Inter a,const Inter b)const{\n\t\treturn a.pos<b.pos;\n\t}\n};\nstruct cmp2{\n\tbool operator ()(const Inter a,const Inter b)const{\n\t\treturn a.val==b.val?a.pos<b.pos:a.val<b.val;\n\t}\n};\nset<Inter,cmp1> p;\nset<Inter,cmp2> s;\ninline ll calc(vector<Inter> &v){\n\tll tot=0,sum=0;\n\tfor(int i=0;i+L-1<(int)v.size();++i){\n\t\tsum+=v[i].l;\n\t\ttot+=sum*v[i+L-1].r;\n\t}\n\treturn tot;\n}\nint main(){\n\tn=read(),L=read();\n\tfor(int i=1;i<=n;++i){\n\t\tint x=read();\n\t\tInter zyk(i,x,1,1);\n\t\tp.insert(zyk),s.insert(zyk);\n\t}\n\twhile(!s.empty()){\n\t\tint w=s.begin()->val;\n\t\tvector<Inter> t;\n\t\twhile(s.begin()->val==w){\n\t\t\tt.push_back(*s.begin());\n\t\t\ts.erase(s.begin());\n\t\t}\n\t\tfor(int l=0,r=1;l<(int)t.size();l=r++){\n\t\t\twhile(r<(int)t.size()&&(--p.find(t[r]))==p.find(t[r-1]))++r;\n\t\t\tint len=r-l,cnt=len/L;\n\t\t\tif(!cnt)continue;\n\t\t\tvector<Inter> myh,zyy;\n\t\t\tmyh.insert(myh.begin(),t.begin()+l,t.begin()+r);\n\t\t\tfor(auto x:myh){\n\t\t\t\tp.erase(x);\n\t\t\t}\n\t\t\tans+=calc(myh);\n\t\t\tfor(int i=0;i<cnt;++i){\n\t\t\t\tzyy.push_back(Inter(myh[0].pos+i,w+1,0,0));\n\t\t\t}\n\t\t\tfor(int i=0;i+L-1<(int)myh.size();++i){\n\t\t\t\tzyy[cnt-((int)myh.size()-i)/L].l+=myh[i].l;\n\t\t\t}\n\t\t\tfor(int i=L-1;i<(int)myh.size();++i){\n\t\t\t\tzyy[(i-L+1)/L].r+=myh[i].r;\n\t\t\t}\n\t\t\tans-=calc(zyy);\n\t\t\tfor(auto x:zyy){\n\t\t\t\tp.insert(x),s.insert(x);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 12/11/2019, 4:20:39 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/optional.hpp> // for C++14\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\nconstexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nstruct Element\n{\n  ll left, right;\n  boost::optional<ll> value; // for C++14\n};\n\nclass Solve\n{\n  ll N;\n  ll L;\n  vector<Element> A;\n\npublic:\n  Solve(ll N, ll L, vector<ll> input) : N{N}, L{L}, A(N)\n  {\n    for (auto i = 0; i < N; i++)\n    {\n      A[i].value = input[i];\n      A[i].left = 1;\n      A[i].right = 1;\n    }\n  }\n\n  ll count()\n  {\n    ll ans{N};\n    while (true)\n    {\n#if DEBUG == 1\n      cerr << \"A = {\";\n      for (auto const &e : A)\n      {\n        if (e.value)\n        {\n          cerr << *e.value << \", \";\n        }\n        else\n        {\n          cerr << \"n, \";\n        }\n      }\n      cerr << \"}\" << endl;\n      cerr << \"L = {\";\n      for (auto const &e : A)\n      {\n        cerr << e.left << \", \";\n      }\n      cerr << \"}\" << endl;\n      cerr << \"R = {\";\n      for (auto const &e : A)\n      {\n        cerr << e.right << \", \";\n      }\n      cerr << \"}\" << endl;\n#endif\n      boost::optional<ll> M{min_value()};\n      if (!M)\n      {\n        break;\n      }\n      vector<Element> T;\n      vector<Element> tmp;\n      for (auto const &e : A)\n      {\n        if (e.value == M)\n        {\n          tmp.push_back(e);\n        }\n        else if (!tmp.empty())\n        {\n          update(ans, T, tmp);\n          T.push_back(e);\n        }\n        else\n        {\n          T.push_back(e);\n        }\n      }\n      if (!tmp.empty())\n      {\n        update(ans, T, tmp);\n      }\n      swap(A, T);\n      delete_none();\n    }\n    return ans;\n  }\n\nprivate:\n  boost::optional<ll> min_value()\n  {\n    boost::optional<ll> ans;\n    for (auto const &e : A)\n    {\n      if (e.value)\n      {\n        if (ans)\n        {\n          ch_min(*ans, *e.value);\n        }\n        else\n        {\n          ans = e.value;\n        }\n      }\n    }\n    return ans;\n  }\n\n  void update(ll &ans, vector<Element> &T, vector<Element> &tmp)\n  {\n    ans += calc(tmp);\n    tmp = press(tmp);\n    ans -= calc(tmp);\n    copy(tmp.begin(), tmp.end(), back_inserter(T));\n    tmp.clear();\n  }\n\n  ll calc(vector<Element> const &X)\n  {\n    ll ans{0};\n    ll sum_right{0};\n    int S{static_cast<int>(X.size())};\n    for (auto i = L - 1; i < S; i++)\n    {\n      sum_right += X[i].right;\n    }\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans += X[i].left * sum_right;\n      sum_right -= X[i + L - 1].right;\n    }\n    assert(sum_right == 0);\n    return ans;\n  }\n\n  vector<Element> press(vector<Element> &V)\n  {\n    ll S{static_cast<ll>(V.size())};\n    if (S < L)\n    {\n      return {{0, 0, boost::none}};\n    }\n    ll K{*V[0].value + 1};\n    vector<Element> ans(S / L);\n    for (auto &e : ans)\n    {\n      e.value = K;\n    }\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].right += V[i].right;\n    }\n    reverse(V.begin(), V.end());\n    reverse(ans.begin(), ans.end());\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].left += V[i].left;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans;\n  }\n\n  void delete_none()\n  {\n    vector<Element> T;\n    int S{static_cast<int>(A.size())};\n    for (auto i = 0; i < S; i++)\n    {\n      if (i < S - 1 && !A[i].value && !A[i + 1].value)\n      {\n        continue;\n      }\n      T.push_back(move(A[i]));\n    }\n    swap(A, T);\n  }\n};\n\nint main()\n{\n  ll N, L;\n  cin >> N >> L;\n  vector<ll> A(N);\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> A[i];\n  }\n  Solve solve(N, L, move(A));\n  cout << solve.count() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define N 200127\n#define INF 0x3f3f3f3f\nint n,m,a[N],mi=INF,L[N],R[N],vl[N],vr[N],v1[N],v2[N];\nstruct Point{\n\tint x,v;\n\tinline bool operator<(const Point &b)const{return (v>b.v)||((v==b.v)&&(x>b.x));}\n};\npriority_queue<Point>q;\nint b[N],cn=0;long long ans=0;\nint main(){\n\tscanf(\"%d%d\",&n,&m);ans=n;int i,j,k,v,l,r,p,sum;for(i=1;i<=n;i++)scanf(\"%d\",&a[i]),L[i]=i-1,R[i]=i+1,vl[i]=vr[i]=1,q.push((Point){i,a[i]});\n\twhile(!q.empty())\n\t{\n\t\tcn=0;v=q.top().v;while((!q.empty())&&(v==q.top().v))b[++cn]=q.top().x,q.pop();\n\t\tfor(i=1;i<=cn;i=r+1)\n\t\t{\n\t\t\tl=r=i;while((r<cn)&&(R[b[r]]==b[r+1]))++r;\n\t\t\tsum=0;for(i=l;i<=r;i++){if(i-m+1>=l)sum+=vl[b[i-m+1]];ans+=1ll*sum*vr[b[i]];}\n\t\t\tif(r-l+1<m){R[L[b[l]]]=n+1;L[R[b[r]]]=0;continue;}p=(r-l+1)/m;\n\t\t\tfor(i=l;i<=r;i++)k=b[i],v1[k]=vl[k],v2[k]=vr[k],vl[k]=vr[k]=0;\n\t\t\tfor(i=r-m+1,k=p;i>=l;i-=m,--k)for(j=i;(j>=l)&&(j>=i-m+1);j--)vl[b[l+k-1]]+=v1[b[j]];\n\t\t\tfor(i=l+m-1,k=1;i<=r;i+=m,++k)for(j=i;(j<=r)&&(j<=i+m-1);j++)vr[b[l+k-1]]+=v2[b[j]];\n\t\t\tfor(i=l;i<=l+p-1;i++)++a[b[i]],q.push((Point){b[i],a[b[i]]});L[R[b[r]]]=b[l]+p-1;R[b[l]+p-1]=R[b[r]];\n\t\t\tsum=0;for(i=l;i<=l+p-1;i++){if(i-m+1>=l)sum+=vl[b[i-m+1]];ans-=1ll*sum*vr[b[i]];}\n\t\t}\n\t}printf(\"%lld\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define pii pair<int,int>\n#define riterator reverse_iterator\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 2e5;\npriority_queue<pii,vector<pii>,greater<pii> > que;\nint nxt[N+3],prv[N+3];\nint a[N+3];\nllong cl[N+3],cr[N+3],cl2[N+3],cr2[N+3];\nvector<int> vec;\nint n,m; llong ans;\n\nvoid solve(int l,int r)\n{\n//\tprintf(\"solve %d %d\\n\",l,r);\n\tllong sum = 0ll;\n\tfor(int i=m-1; i<vec.size(); i++)\n\t{\n\t\tsum += cl[vec[i-m+1]];\n\t\tans += cr[vec[i]]*sum;\n\t}\n\tint cnt = vec.size()/m;\n\tfor(int i=l; i<=l+cnt-1; i++) cl2[i] = cr2[i] = 0ll;\n\tfor(int i=vec.size()-m,j=0,k=l+cnt-1; i>=0; i--)\n\t{\n\t\tcl2[k] += cl[vec[i]];\n\t\tif(j==m-1) {k--,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=m-1,j=0,k=l; i<vec.size(); i++)\n\t{\n\t\tcr2[k] += cr[vec[i]];\n\t\tif(j==m-1) {k++,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=l; i<=l+cnt-1; i++) cl[i] = cl2[i],cr[i] = cr2[i];\n\tsum = 0ll;\n\tfor(int i=l+m-1; i<=l+cnt-1; i++)\n\t{\n\t\tsum += cl[i-m+1];\n\t\tans -= cr[i]*sum;\n\t}\n\tnxt[l+cnt-1] = nxt[r]; prv[nxt[r]] = l+cnt-1;\n\tfor(int i=l; i<l+cnt-1; i++) nxt[i] = i+1;\n\tfor(int i=l+1; i<=l+cnt-1; i++) prv[i] = i-1;\n\tint val = a[l]; for(int i=l; i<=l+cnt-1; i++) a[i] = val+1;\n\tfor(int i=l; i<=l+cnt-1; i++) que.push(mkpr(a[i],i));\n//\tprintf(\"cnt=%d\\n\",cnt);\n//\tprintf(\"prv: \"); for(int i=1; i<=n; i++) printf(\"%d \",prv[i]); puts(\"\");\n//\tprintf(\"nxt: \"); for(int i=1; i<=n; i++) printf(\"%d \",nxt[i]); puts(\"\");\n//\tprintf(\"cl: \"); for(int i=1; i<=n; i++) printf(\"%lld \",cl[i]); puts(\"\");\n//\tprintf(\"cr: \"); for(int i=1; i<=n; i++) printf(\"%lld \",cr[i]); puts(\"\");\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&a[i]),que.push(mkpr(a[i],i)),cl[i] = cr[i] = 1ll,nxt[i] = i+1,prv[i] = i-1;\n\twhile(1)\n\t{\n\t\tint l = que.top().second,r = l; que.pop(); vec.clear(); vec.push_back(l);\n\t\twhile(!que.empty() && que.top().first==a[l] && que.top().second==nxt[r]) {r = nxt[r]; vec.push_back(r); que.pop();}\n\t\tsolve(l,r);\n\t\tif(prv[l]==0&&nxt[r]==n+1) break;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define last last_2\nint num[200005],n,L;\nll ans;\nnamespace SGT {\n\tint maxv[800000];\n\tvoid build(int l,int r,int o) {\n\t\tif (l==r) maxv[o]=l;\n\t\telse {\n\t\t\tint m=((l+r)>>1);\n\t\t\tbuild(l,m,o*2);\n\t\t\tbuild(m+1,r,o*2+1);\n\t\t\tmaxv[o]=((num[maxv[o*2]]>=num[maxv[o*2+1]])?maxv[o*2]:maxv[o*2+1]);\n\t\t}\n\t}\n\tint query(int l,int r,int o,int lx,int rx) {\n\t\tif (l>=lx&&r<=rx) return maxv[o];\n\t\telse {\n\t\t\tint m=((l+r)>>1);\n\t\t\tif (m>=rx) return query(l,m,o*2,lx,rx);\n\t\t\tif (m<lx) return query(m+1,r,o*2+1,lx,rx);\n\t\t\tint a=query(l,m,o*2,lx,rx),b=query(m+1,r,o*2+1,lx,rx);\n\t\t\treturn (num[a]>=num[b])?a:b;\n\t\t}\n\t}\n}\nint nxt[200005],powd[200005];\nmap<int,int> last;\nvoid pre() {\n\tpowd[0]=1;\n\tfor(int i=1; i<=n; i++) powd[i]=min((ll)powd[i-1]*L,n+1LL);\n\tfor(int i=n; i>0; i--) {\n\t\tnxt[i]=((last[num[i]])?last[num[i]]:n+1);\n\t\tlast[num[i]]=i;\n\t}\n}\nvector <int> suml[200005],sumr[200005];\nvector <int> pos[200005],son[200005];\nint size[200005],lsize[200005],rsize[200005];\nint val[200005],tot;\nvoid calc(int o,int d) {\n\tstatic int sum[200005];\n\tif (d>n||powd[d]>n) {\n\t\tsize[o]=-1;\n\t\tsuml[o].resize(1);\n\t\tsumr[o].resize(1);\n\t\tlsize[o]=rsize[o]=0;\n\t\treturn;\n\t}\n\tsize[o]=((size[o]>=powd[d])?size[o]/powd[d]:-1);\n\tif (lsize[o]) {\n\t\tfor(int i=1; i<=lsize[o]; i++) sum[i]=0;\n\t\tint maxn=0;\n\t\tfor(int i=powd[d]; i<=lsize[o]; i++) {\n\t\t\tmaxn=i/powd[d];\n\t\t\tsum[maxn]+=suml[o][i];\n\t\t}\n\t\tlsize[o]=maxn;\n\t\tsuml[o].resize(maxn+1);\n\t\tfor(int i=1; i<=maxn; i++) suml[o][i]=sum[i];\n\t}\n\tif (rsize[o]) {\n\t\tfor(int i=1; i<=rsize[o]; i++) sum[i]=0;\n\t\tint maxn=0;\n\t\tfor(int i=powd[d]; i<=rsize[o]; i++) {\n\t\t\tmaxn=i/powd[d];\n\t\t\tsum[maxn]+=sumr[o][i];\n\t\t}\n\t\trsize[o]=maxn;\n\t\tsumr[o].resize(maxn+1);\n\t\tfor(int i=1; i<=maxn; i++) sumr[o][i]=sum[i];\n\t}\n}\nint solve(int l,int r) {\n\tstatic int q[200005];\n\tint o=++tot;\n\tfor(int i=SGT::query(1,n,1,l,r); i<=r; i=nxt[i])\n\t\tpos[o].push_back(i);\n\tval[o]=num[pos[o][0]];\n\tson[o].resize(pos[o].size()+1);\n\tif (pos[o][0]>l) son[o][0]=solve(l,pos[o][0]-1);\n\tfor(int i=1; i<(int)pos[o].size(); i++)\n\t\tif (pos[o][i]>pos[o][i-1]+1) son[o][i]=solve(pos[o][i-1]+1,pos[o][i]-1);\n\tif (pos[o][pos[o].size()-1]<r) son[o][son[o].size()-1]=solve(pos[o][pos[o].size()-1]+1,r);\n\tfor(int i=0; i<(int)son[o].size(); i++)\n\t\tif (son[o][i]) calc(son[o][i],val[o]-val[son[o][i]]);\n\tint rx=0,lx=0;\n\tfor(int i=rsize[son[o][0]]; i>0; i--) q[++rx]=sumr[son[o][0]][i];\n\tint s=0;\n\tfor(int i=0; i<(int)pos[o].size(); i++) {\n\t\tq[++rx]=1;\n\t\twhile (lx<rx&&rx-lx>=L) s+=q[++lx];\n\t\tans+=s;\n\t\tif (son[o][i+1]) {\n\t\t\tint u=son[o][i+1];\n\t\t\tfor(int j=1; j<=lsize[u]; j++) {\n\t\t\t\twhile (lx<rx&&rx-lx+j>=L) s+=q[++lx];\n\t\t\t\tans+=(ll)s*suml[u][j];\n\t\t\t}\n\t\t\tif (size[u]==-1) lx=rx,s=0;\n\t\t\tfor(int j=rsize[u]; j>0; j--) q[++rx]=sumr[u][j];\n\t\t}\n\t}\n\tbool v=1;\n\tint sz=pos[o].size();\n\tfor(int i=0; i<(int)son[o].size(); i++)\n\t\tif (size[son[o][i]]==-1) v=0;\n\t\telse sz+=size[son[o][i]];\n\tsize[o]=((v)?sz:-1);\n\tsuml[o].resize(1);\n\tfor(int i=0; i<(int)son[o].size(); i++) {\n\t\tint u=son[o][i];\n\t\tfor(int j=1; j<=lsize[u]; j++) suml[o].push_back(suml[u][j]);\n\t\tif (size[u]==-1) break;\n\t\tif (i+1<(int)son[o].size()) suml[o].push_back(1);\n\t}\n\tlsize[o]=suml[o].size()-1;\n\tsumr[o].resize(1);\n\tfor(int i=son[o].size()-1; i>=0; i--) {\n\t\tint u=son[o][i];\n\t\tfor(int j=1; j<=rsize[u]; j++) sumr[o].push_back(sumr[u][j]);\n\t\tif (size[u]==-1) break;\n\t\tif (i) sumr[o].push_back(1);\n\t}\n\trsize[o]=sumr[o].size()-1;\n\treturn o;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&num[i]);\n\t}\n\tpre();\n\tSGT::build(1,n,1);\n\tsolve(1,n);\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxp];\nint main()\n{\n//\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout); \n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<25;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue; assert(H[i+1]==H[i]+1);\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; \n\t\t\tvector<node> tmp(k+1,0); tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int j=1;j<=k;++j)\n\t\t\t{\n\t\t\t\ttmp[j].l=tmp[j].r=tmp[j-1].l+1;\n\t\t\t\ttmp[j].L=tmp[j].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\tfor(int j=1;j<=k;++j) rec[i+1].push_back(tmp[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=500005,inf=0x3f3f3f3f;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,m,L,cnt,h[N],b[N],sl[N],sr[N];\nll ans;\ntypedef pair<int,int> pr;\npriority_queue<pr,vector<pr>,greater<pr> > f;\nstruct node{int val,l,r,pre,nex;}a[N];\nint getsum(int *s,int l,int r){return s[r]-s[l-1];}\nvoid split(int x){\n\tint cur=x;m=0;\n\twhile (a[x].val==a[cur].val){\n\t\tb[++m]=cur;\n\t\tsl[m]=sl[m-1]+a[cur].l;\n\t\tsr[m]=sr[m-1]+a[cur].r;\n\t\tcur=a[cur].nex;\n\t}\n}\nint getpre(int x){while(a[a[x].pre].val==a[x].val) x=a[x].pre;return x;}\nvoid recalc(int x,int y){\n\tsplit(getpre(x));\n\tfor (int i=1;i<=m;i++) if (b[i]==x) {x=i;break;}\n\tfor (int i=1;i<=m;i++) if (b[i]==y) {y=i;break;}\n\tfor (int i=1;i<=y;i++){\n\t\tint l=max((i<x) ? x : (y+1),i+L-1),r=m;\n\t\tif (l<=r) ans+=(ll)a[b[i]].l*getsum(sr,l,r);\n\t}\n}\nvoid printch(int x){\n\twhile (a[x].pre) x=a[x].pre;\n\tfor (;x;x=a[x].nex) printf(\"%d \",x);\n\tprintf(\"\\n\");\n}\nint main(){\n\tn=read();L=read();ans=cnt=n;\n\tfor (int i=1;i<=n;i++){\n\t\ta[i].val=read();a[i].l=a[i].r=1;\n\t\ta[i].pre=i-1;a[i].nex=i+1;h[i]=1;\n\t\tf.push(make_pair(a[i].val,i));\n\t}\n\ta[n].nex=0;\n\tfor (int i=1,j;i<=n;i=j){\n\t\tfor (j=i;a[i].val==a[j].val;j++);\n\t\tint len=j-i;\n\t\tif (len>=L) ans+=(ll)(len-L+1)*(len-L+2)/2;\n\t}\n\twhile (1){\n\t\twhile (!h[f.top().second]) f.pop();\n\t\tint x=getpre(f.top().second),y;f.pop();\n\t\t//printch(x);\n\t\tif (a[x].val>=inf) break;\n\t\tsplit(x);\n\t\tfor (int i=1;i<=m;i++) h[b[i]]=0;\n\t\tx=a[b[1]].pre,y=a[b[m]].nex;\n\t\tif (m<L){\n\t\t\ta[++cnt].val=inf;a[cnt].pre=x;a[cnt].nex=y;\n\t\t\tif (x) a[x].nex=cnt;\n\t\t\tif (y) a[y].pre=cnt;\n\t\t\th[cnt]=1;f.push(make_pair(a[cnt].val,cnt));\n\t\t\tcontinue;\n\t\t}\n\t\tint r=m/L;\n\t\tfor (int i=1;i<=r;i++){\n\t\t\ta[cnt+i].val=a[b[1]].val+1;\n\t\t\tint tl=m-(r-i+1)*L+1,tr=max(1,tl-(L-1));\n\t\t\ta[cnt+i].l=getsum(sl,tr,tl);\n\t\t\ttl=i*L,tr=min(m,tl+L-1);\n\t\t\ta[cnt+i].r=getsum(sr,tl,tr);\n\t\t\ta[cnt+i].pre=(i!=1) ? (cnt+i-1) : x;\n\t\t\ta[cnt+i].nex=(i!=r) ? (cnt+i+1) : y;\n\t\t\th[cnt+i]=1;f.push(make_pair(a[cnt+i].val,cnt+i));\n\t\t}\n\t\tif (x) a[x].nex=cnt+1;\n\t\tif (y) a[y].pre=cnt+r;\n\t\trecalc(cnt+1,cnt+r);\n\t\tcnt+=r;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<Pii> Vp;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 266666, inf = 0x3f3f3f3f;\nint n,l,a[N];ll res;map<Pii,Vp>Set;//pos,val: vector<Pii>\nset<Pii>heap;//val,pos\nvoid merge_front(map<Pii,Vp>::iterator it){\n\tif(it==Set.begin())return;map<Pii,Vp>::iterator it1=it;it1--;\n\tif((*it).fi.se!=(*it1).fi.se)return;\n//\tcerr<<\"merge \"<<(*it).fi.fi<<' '<<(*it1).fi.fi<<endl;\n\theap.erase(Pii((*it).fi.se,(*it).fi.fi));\n\trep(i,0,SZ((*it).se)-1)(*it1).se.pb((*it).se[i]);Set.erase(it);\n}\ninline ll calc(Vp a){\n\tstatic ll qz[N];\n\trep(i,0,SZ(a)-1)qz[i]=(i-1>=0?qz[i-1]:0)+a[i].fi;\n\tll res=0;rep(i,l-1,SZ(a)-1)res+=qz[i-l+1]*a[i].se;\n\trep(i,0,SZ(a)-1)res+=1LL*a[i].fi*a[i].se;\n\treturn res;\n}\nint main() {\n\tread(n);read(l);rep(i,1,n)read(a[i]);\n\trep(i,1,n){\n\t\tint j=i;while(j+1<=n&&a[j+1]==a[i])j++;\n\t\tVp b;rep(k,i,j)b.pb(Pii(1,1));Set[Pii(i,a[i])]=b;//Set.insert(pair<Pii,Vp>(Pii(i,a[i]),b));\n\t\theap.insert(Pii(a[i],i));i=j;\n\t}\n\twhile(!Set.empty()){\n\t\tPii tmp=*heap.begin();heap.erase(heap.begin());\n\t\tif(tmp.fi==inf)break;\n\t\tmap<Pii,Vp>::iterator it=Set.find(Pii(tmp.se,tmp.fi)),it1;\n\t//\tcerr<<(*it).fi.fi<<' '<<res<<endl;\n\t\tif(SZ((*it).se)<l){\n\t\t\tres+=calc((*it).se);\n\t\t\tint pos=(*it).fi.fi;\n\t\t\tSet.erase(it);Set.insert(pair<Pii,Vp>(Pii(pos,inf),{}));heap.insert(Pii(inf,pos));\n\t\t\tcontinue;\n\t\t}\n\t\tres+=calc((*it).se);\n\t\tVp b(SZ((*it).se)/l,Pii(0,0));\n\t\trep(i,l-1,SZ((*it).se)-1)b[(i+1)/l-1].se+=(*it).se[i].se;\n\t\tint pos=SZ(b)-1,cnt=0;per(i,SZ((*it).se)-l,0){\n\t\t\tcnt++;if(cnt>l)cnt-=l,pos--;\n\t\t\tb[pos].fi+=(*it).se[i].fi;\n\t\t}\n\t\tpos=(*it).fi.fi;int val=(*it).fi.se+1;Set.erase(it);\n\t\tit=Set.insert(pair<Pii,Vp>(Pii(pos,val),b)).fi;heap.insert(Pii(val,pos));\n\t\tres-=calc((*it).se);\n\t\tit1=it;it1++;merge_front(it);if(it1!=Set.end())merge_front(it1);\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 200020\ntypedef long long ll;\n\nint n, L, a[N];\n\nstruct data {\n\tint le, ri, lv, rv;\n\tdata(int le = 0, int ri = 0, int lv = 0, int rv = 0):le(le), ri(ri), lv(lv), rv(rv) {}\n\tbool operator < (const data &a) const {return le < a.le;}\n};\n\ntypedef pair<int, int>  pii;\nset<data> S;\n\nll calc(vector<data> &v) {\n\tll sum = 0;\n\tll rlt = 0;\n\tfor (int i = 0; i < v.size(); i ++) {\n\t\tsum += v[i].lv;\n\t\tif (i + L <= v.size()) rlt += sum * v[i+L-1].rv;\n\t}\n\treturn rlt;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n\tcin>>n>>L;\n\tvector<pii> pos;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tcin>>a[i];\n\t\tpos.emplace_back(a[i], i);\n\t}\n\tsort(pos.begin(), pos.end());\n\tint now = 1;\n\tint cur = 0;\n\tll ans = n;\n\twhile (1) {\n\t\tif (S.empty()) {\n\t\t\tif (cur >= pos.size()) break;\n\t\t\tnow = pos[cur].first;\n\t\t}\n        while (cur < pos.size() && pos[cur].first == now) {\n\t\t\tS.insert(data(pos[cur].second, pos[cur].second, 1, 1));\n\t\t\tcur ++;\n        }\n        vector<data> all;\n        while (!S.empty()) {\n\t\t\tset<data>::iterator it = S.begin();\n\t\t\tvector<data> tmp = {*it};\n\t\t\tS.erase(*it);\n\t\t\twhile (!S.empty() && S.begin()->le == tmp.back().ri + 1) {\n\t\t\t\ttmp.push_back(*S.begin());\n\t\t\t\tS.erase(*S.begin());\n\t\t\t}\n\t\t\tif (tmp.size() >= L) {\n\t\t\t\tans += calc(tmp);\n\t\t\t\tint c = tmp.size() / L;\n\t\t\t\tvector<data> nw = tmp;\n\t\t\t\tnw.resize(c);\n\t\t\t\tfor (int i = 0; i < c; i ++) {\n\t\t\t\t\tnw[i].le = tmp[0].le + i;\n\t\t\t\t\tif (i < c - 1) nw[i].ri = nw[i].le;\n\t\t\t\t\telse nw[i].ri = tmp.back().ri;\n\t\t\t\t\tnw[i].lv = nw[i].rv = 0;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < tmp.size(); i ++) {\n\t\t\t\t\tint l = i + 1, r = tmp.size() - i;\n\t\t\t\t\tif (l >= L) nw[l/L-1].rv += tmp[i].rv;\n\t\t\t\t\tif (r >= L) nw[c-r/L].lv += tmp[i].lv;\n\t\t\t\t}\n\t\t\t\tans -= calc(nw);\n\t\t\t\tfor (auto q:nw) all.push_back(q);\n\t\t\t}\n        }\n\t\tfor (auto q:all) S.insert(q);\n        now ++;\n\t}\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nstruct number {\n\tint pos,val;\n\tint l,r,o;\n};\nbool operator < (const number &a,const number &b) {\n\treturn a.pos<b.pos;\n}\nbool operator ==(const number &a,const number &b) {\n\treturn a.pos==b.pos;\n}\n\nconst int N=201000;\nset<number> ps;\nset<PII> hs;\nint n,l,ss[N];\nll ans;\nint main() {\n\tscanf(\"%d%d\",&n,&l);\n\trep(i,0,n) {\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ths.insert(mp(x,i));\n\t\tps.insert((number){i,x,1,1,1});\n\t}\n\twhile (!hs.empty()) {\n\t\tint c=hs.begin()->fi;\n\t\tauto it=ps.lower_bound((number){hs.begin()->se,0,0,0,0});\n\t\tvector<number> cc;\n\t\twhile (1) {\n\t\t\tcc.pb(*it);\n\t\t\tif (it==ps.end()) break;\n\t\t\t++it; if (it->val!=c) break;\n\t\t}\n\t\tfor (auto p:cc) hs.erase(mp(p.val,p.pos));\n\t\tif (SZ(cc)<l) continue;\n\t\tint nxt=1<<30,m=SZ(cc);\n\t\tif (SZ(cc)>=l) {\n\t\t\tss[m]=0;\n\t\t\tper(i,0,m) ss[i]=ss[i+1]+cc[i].l;\n\t\t\tper(i,0,m) {\n\t\t\t\tif (cc[i].o) nxt=i;\n\t\t\t\tif (nxt<m&&i+l-1<m) {\n\t\t\t\t\tans+=(ll)cc[i].r*ss[max(nxt,i+l-1)];\n//\t\t\t\t\tprintf(\"gg %d %d\\n\",cc[i].r,ss[max(nxt,i+l-1)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,0,m) ps.erase(cc[i]);\n\t\t}\n\t\tint z=m/l;\n\t\tVI fl(z,0),fr(z,0);\n\t\trep(i,0,m) {\n\t\t\tif (i>=l-1) fl[(i+1)/l-1]+=cc[i].l;\n\t\t\tif (m-i-1>=l-1) fr[(m-i)/l-1]+=cc[i].r;\n\t\t}\n\t\treverse(all(fr));\n\t\trep(i,0,z) {\n\t\t\tps.insert((number){cc[i*l].pos,c+1,fl[i],fr[i],0});\n\t\t\ths.insert(mp(c+1,cc[i*l].pos));\n\t\t}\n/*\t\tputs(\"ffff\");\n\t\tfor (auto p:ps) {\n\t\t\tprintf(\"%d %d %d %d %d\\n\",p.pos,p.val,p.l,p.r,p.o);\n\t\t}\n\t\tprintf(\"zz %lld\\n\",ans);*/\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {int l, r, x;};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, l;\n    cin >> n >> l;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    struct Node {\n        int pre, nxt, val, l, r;\n        bool isNew;\n    };\n    vector<Node> t(n);\n    vector<pair<int, int>> s;\n    for (int i = 0; i < n; ++i) {\n        t[i].pre = i - 1;\n        t[i].nxt = i == n - 1 ? -1 : i + 1;\n        t[i].l = t[i].r = 1;\n        t[i].val = a[i];\n        t[i].isNew = false;\n        s.emplace_back(a[i], i);\n    }\n    sort(s.begin(), s.end(), greater<pair<int, int>>());\n    long long ans = 0;\n    auto connect = [&](int l, int r) {\n        if (l != -1)\n            t[l].nxt = r;\n        if (r != -1)\n            t[r].pre = l;\n    };\n    while (!s.empty()) {\n        int x = s.back().first;\n        vector<int> v, v1;\n        while (!s.empty() && s.back().first == x) {\n            int p = s.back().second;\n            if (t[p].pre == -1 || t[t[p].pre].val != x)\n                v.push_back(p);\n            if ((t[p].pre == -1 || t[t[p].pre].val != x || !t[t[p].pre].isNew) && t[p].isNew)\n                v1.push_back(p);\n            s.pop_back();\n        }\n        for (int p : v1) {\n            vector<int> ver;\n            for (int i = p; ; i = t[i].nxt) {\n                if (i == -1 || t[i].val != x || !t[i].isNew)\n                    break;\n                ver.push_back(i);\n            }\n            int sum = 0;\n            for (int i = l - 1; i < (int)ver.size(); ++i) {\n                sum += t[ver[i - l + 1]].l;\n                ans -= 1LL * sum * t[ver[i]].r;\n            }\n        }\n        for (int p : v) {\n            vector<int> ver;\n            for (int i = p; ; i = t[i].nxt) {\n                if (i == -1 || t[i].val != x)\n                    break;\n                ver.push_back(i);\n            }\n            if ((int)ver.size() < l) {\n                connect(t[p].pre, -1);\n                connect(-1, t[ver.back()].nxt);\n                continue;\n            }\n            int sum = 0;\n            for (int i = l - 1; i < (int)ver.size(); ++i) {\n                sum += t[ver[i - l + 1]].l;\n                ans += 1LL * sum * t[ver[i]].r;\n            }\n            int cnt = ver.size() / l;\n            vector<int> newL(cnt), newR(cnt);\n            for (int i = l - 1; i < (int)ver.size(); ++i) {\n                newL[cnt - (i - l + 1) / l - 1] += t[ver[ver.size() - i - 1]].l;\n                newR[(i - l + 1) / l] += t[ver[i]].r;\n            }\n            int lst = t[p].pre;\n            for (int i = 0; i < cnt; ++i) {\n                ++t[ver[i]].val;\n                t[ver[i]].isNew = true;\n                t[ver[i]].l = newL[i];\n                t[ver[i]].r = newR[i];\n                connect(lst, ver[i]);\n                s.emplace_back(t[ver[i]].val, ver[i]);\n                lst = ver[i];\n            }\n            connect(lst, t[ver.back()].nxt);\n        }\n    }\n    cout << ans + n << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=200005;\nint n,L;\nint a[N];\nint rp[N];\nvector <int> vl[N],vr[N];\nbool cmp(int x,int y){\n\tif (a[x]!=a[y])\n\t\treturn a[x]<a[y];\n\treturn x<y;\n}\nmap <int,vector <int> > pos;\nset <int> S;\nvector <int> v,v2,tl,tr;\nint vis[N];\nint main(){\n\tn=read(),L=read();\n\tFor(i,1,n){\n\t\ta[i]=read();\n\t\tpos[a[i]].pb(i);\n\t\tS.insert(a[i]);\n\t}\n\tLL ans=n;\n\tint k=0;\n\twhile (!S.empty()){\n\t\tk++;\n\t\tif (k==*S.begin())\n\t\t\tS.erase(S.begin());\n\t\tfor (auto i : pos[k]){\n\t\t\trp[i]=i;\n\t\t\tvl[i].pb(1),vr[i].pb(1);\n\t\t\tv.pb(i);\n\t\t}\n\t\tif (v.empty()){\n\t\t\tassert(!S.empty());\n\t\t\tk=*S.begin()-1;\n\t\t\tcontinue;\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tFor(i,1,(int)v.size()-1)\n\t\t\tassert(v[i]!=v[i-1]);\n\t\tint las=v[0];\n\t\tv2.clear();\n\t\ttl.clear(),tr.clear();\n\t\ttr.pb(0);\n\t\t#define tls (int)tl.size()\n\t\t#define trs (int)tr.size()\n\t\tFor(_,0,(int)v.size()-1){\n\t\t\tint i=v[_];\n\t\t\tFor(j,0,(int)vl[i].size()-1){\n\t\t\t\tans+=(LL)vl[i][j]*tr[max(trs-max(L-(j+1),1),0)];\n\t\t\t\tif (j<(int)vl[i].size()-1)\n\t\t\t\t\ttl.pb(vl[i][j]-vl[i][j+1]);\n\t\t\t\telse\n\t\t\t\t\ttl.pb(vl[i][j]);\n\t\t\t}\n\t\t\tint tmp=tr.back();\n\t\t\tFod(j,(int)vr[i].size()-1,0)\n\t\t\t\ttr.pb(vr[i][j]+tmp);\n\t\t\tif (_==(int)v.size()-1||v[_+1]!=rp[i]+1){\n\t\t\t\trp[las]=rp[i];\n\t\t\t\tFod(i,trs-1,1)\n\t\t\t\t\ttr[i]-=tr[i-1];\n\t\t\t\tvl[las]=tl;\n\t\t\t\tvr[las].clear();\n\t\t\t\tFod(i,trs-1,1)\n\t\t\t\t\tvr[las].pb(tr[i]);\n\t\t\t\tFor(i,0,(int)vl[las].size()-1)\n\t\t\t\t\tvl[las][(i+1)/L]+=vl[las][i],vl[las][i]=0;\n\t\t\t\tvl[las][0]=0;\n\t\t\t\tFor(i,0,(int)vl[las].size()-2)\n\t\t\t\t\tvl[las][i]=vl[las][i+1],vl[las][i+1]=0;\n\t\t\t\twhile (!vl[las].empty()&&!vl[las].back())\n\t\t\t\t\tvl[las].pop_back();\n\t\t\t\tFod(i,(int)vl[las].size()-1,1)\n\t\t\t\t\tvl[las][i-1]+=vl[las][i];\n\t\t\t\tFor(i,0,(int)vr[las].size()-1)\n\t\t\t\t\tvr[las][(i+1)/L]+=vr[las][i],vr[las][i]=0;\n\t\t\t\tvr[las][0]=0;\n\t\t\t\tFor(i,0,(int)vr[las].size()-2)\n\t\t\t\t\tvr[las][i]=vr[las][i+1],vr[las][i+1]=0;\n\t\t\t\twhile (!vr[las].empty()&&!vr[las].back())\n\t\t\t\t\tvr[las].pop_back();\n\t\t\t\tFod(i,(int)vr[las].size()-1,1)\n\t\t\t\t\tvr[las][i-1]+=vr[las][i];\n\t\t\t\tif (!vl[las].empty())\n\t\t\t\t\tv2.pb(las);\n\t\t\t\tif (_!=(int)v.size()-1){\n\t\t\t\t\tlas=v[_+1];\n\t\t\t\t\ttl.clear(),tr.clear();\n\t\t\t\t\ttr.pb(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv=v2;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\nusing pi = pair<int, int>;\n\nint main(){\n\tint n, l; \n\tscanf(\"%d %d\",&n,&l);\n\tvector<pair<int, vector<int>>> stk;\n\tlint dap = 0;\n\tfor(int i=0; i<n; i++){\n\t\tint x; scanf(\"%d\",&x);\n\t\twhile(sz(stk) && stk.back().first < x){\n\t\t\tauto lev = stk.back().first;\n\t\t\tauto vec = stk.back().second;\n\t\t\tvector<int> nvec;\n\t\t\tstk.pop_back();\n\t\t\tif(sz(vec) < l){\n\t\t\t\tstk.clear();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=sz(vec)-l; i>=0; i-=l) nvec.push_back(vec[i]);\n\t\t\treverse(all(nvec));\n\t\t\tif(sz(stk) && stk.back().first == lev + 1){\n\t\t\t\tint foo = stk.back().second.back();\n\t\t\t\tfor(auto &j : nvec) stk.back().second.push_back(foo + j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstk.emplace_back(lev + 1, nvec);\n\t\t\t}\n\t\t}\n\t\tdap += 1;\n\t\tif(sz(stk) && stk.back().first == x){\n\t\t\tint foo = stk.back().second.back();\n\t\t\tstk.back().second.push_back(foo + 1);\n\t\t}\n\t\telse{\n\t\t\tstk.emplace_back(x, vector<int>{1});\n\t\t}\n\t\tif(sz(stk.back().second) >= l) dap += stk.back().second[sz(stk.back().second) - l];\n\t\tint sum = sz(stk.back().second);\n\t\tint clvl = x;\n\t\tfor(int j=sz(stk)-2; j>=0; j--){\n\t\t\twhile(sum && clvl < stk[j].first){\n\t\t\t\tsum /= l;\n\t\t\t\tclvl++;\n\t\t\t}\n\t\t\tif(sum == 0) break;\n\t\t\tsum += sz(stk[j].second);\n\t\t\tif(sum >= l) dap += stk[j].second[min(sz(stk[j].second) - 1, sum - l)];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dap);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 12/11/2019, 4:20:39 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/optional.hpp> // for C++14\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\n// constexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nstruct Element\n{\n  int ind;\n  ll left, right;\n  boost::optional<int> value; // for C++14\n  bool operator<(Element const &rhs) const\n  {\n    return ind < rhs.ind;\n  }\n  bool operator==(Element const &rhs) const\n  {\n    return ind == rhs.ind;\n  }\n};\n\nElement make_element(int ind) // helper function avoiding contaminating the default constructor.\n{\n  return Element{ind, 0, 0, boost::none};\n}\n\nclass Solve\n{\n  int N, L;\n  set<Element> A;\n  map<int, vector<int>> indexes; // value -> inds\n\npublic:\n  Solve(int N, int L, vector<int> input) : N{N}, L{L}\n  {\n    for (auto i = 0; i < N; i++)\n    {\n      A.insert({i, 1, 1, input[i]});\n      indexes[input[i]];\n      indexes[input[i]].push_back(i);\n    }\n  }\n\n  ll count()\n  {\n    ll ans{N};\n    while (!indexes.empty())\n    {\n      vector<Element> tmp;\n      auto &vec{indexes.begin()->second};\n      sort(vec.begin(), vec.end());\n      int min_value{indexes.begin()->first};\n      for (auto ind : indexes[min_value]) // in order not to touch all elements of A.\n      {\n        auto it{A.find(make_element(ind))};\n        assert(it != A.end()); // it must be found.\n        tmp.push_back(*it);\n        it = A.erase(it); // We must erase elements before inserting pressed elements. Fortunately `erase` returns the next iterator.\n        if (it == A.end() || it->value != min_value)\n        {\n          update(ans, tmp);\n        }\n      }\n      if (!tmp.empty())\n      {\n        update(ans, tmp);\n      }\n      indexes.erase(indexes.begin());\n    }\n    return ans;\n  }\n\nprivate:\n  void update(ll &ans, vector<Element> &tmp)\n  {\n    ans += calc(tmp);\n    tmp = press(tmp);\n    ans -= calc(tmp);\n    for (auto e : tmp)\n    {\n      A.insert(e);\n    }\n    tmp.clear();\n  }\n\n  ll calc(vector<Element> const &X)\n  {\n    ll ans{0};\n    ll sum_right{0};\n    int S{static_cast<int>(X.size())};\n    for (auto i = L - 1; i < S; i++)\n    {\n      sum_right += X[i].right;\n    }\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans += X[i].left * sum_right;\n      sum_right -= X[i + L - 1].right;\n    }\n    assert(sum_right == 0);\n    return ans;\n  }\n\n  vector<Element> press(vector<Element> const &V)\n  {\n    assert(!V.empty());\n    int S{static_cast<int>(V.size())};\n    if (S < L)\n    {\n      return {{V[0].ind, 0, 0, boost::none}};\n    }\n    int index{V[0].ind};\n    int K{*V[0].value + 1};\n    vector<Element> ans(S / L);\n    for (auto &e : ans)\n    {\n      e.ind = index;\n      e.value = K;\n      indexes[K];\n      indexes[K].push_back(index);\n      ++index;\n    }\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].right += V[i].right;\n    }\n    int mod{S % L};\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans[(i + L - mod - 1) / L].left += V[i].left;\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  int N, L;\n  cin >> N >> L;\n  vector<int> A(N);\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> A[i];\n  }\n  Solve solve(N, L, A);\n  cout << solve.count() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-25 16:54:48\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<set>\n#define pii std::pair<int,int>\nconst int N=200010;\ni64 n,pre[N],suf[N],k,a[N],l[N],r[N],ans,s[N],l_[N],r_[N];\nstd::set<pii> S;\nint q[N],m,m_;\nint main()\n{\n\tn=read(); k=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n) if(a[i]!=a[i-1]) S.insert(pii(a[i],i));\n\tfr(i,2,n){ pre[i]=i-1; suf[i-1]=i; }\n\tfr(i,1,n) l[i]=r[i]=1;\n\twhile(!S.empty())\n\t{\n\t\tint u=S.begin()->second,v=u,na=a[u]+1; q[m=1]=u; S.erase(S.begin());\n\t\tsuf[pre[u]]=pre[suf[v]]=0;\n\t\twhile(a[suf[v]]==a[u]) q[++m]=(v=suf[v]);\n\t\tfr(i,1,m){ s[i]=s[i-1]+l[q[i]]; ans+=(l[q[i]]+s[std::max(i-k+1,0ll)])*r[q[i]]; }\n//\t\tfr(i,1,m) printf(\"+ %d %d\\n\",l[q[i]],r[q[i]]);\n//\t\tprintf(\"+%d %d %d\\n\",int(m),int(na-1),int(ans));\n\t\tm_=m/k;\n\t\tif(!m_) continue;\n\t\tfr(i,1,m) s[i]=s[i-1]+l[q[i]];\n\t\tfr(i,1,m_) l_[i]=s[m-(m_-i+1)*k+1];\n\t\tfd(i,m_,2) l_[i]-=l_[i-1];\n//\t\tfr(i,1,m_) printf(\"%d%c\",s[m-(m_-i+1)*k+1],i==end_i?'\\n':' ');\n\t\tfr(i,1,m) s[i]=s[i-1]+r[q[i]];\n\t\tfr(i,1,m_) r_[i]=s[m]-s[i*k-1];\n\t\tfr(i,1,m_-1) r_[i]-=r_[i+1];\n//\t\tfr(i,1,m_) printf(\"- %d %d\\n\",l_[i],r_[i]);\n\t\tfr(i,1,m_){ l[q[i]]=l_[i]; r[q[i]]=r_[i]; a[q[i]]=na; }\n\t\tsuf[pre[u]]=u; pre[suf[v]]=q[m_]; suf[q[m_]]=suf[v]; m=m_;\n\t\tfr(i,1,m){ s[i]=s[i-1]+l[q[i]]; ans-=(l[q[i]]+s[std::max(i-k+1,0ll)])*r[q[i]]; }\n\t\tif(a[pre[u]]!=na) S.insert(pii(na,u));\n\t\tif(a[suf[v]]==na) S.erase(pii(na,suf[v]));\n//\t\tprintf(\"-%d %d %d\\n\",int(m),int(na-1),int(ans));\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 12/11/2019, 4:20:39 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/optional.hpp> // for C++14\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\nconstexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nstruct Element\n{\n  int ind;\n  ll left, right;\n  boost::optional<int> value; // for C++14\n  bool operator<(Element const &rhs) const\n  {\n    return ind < rhs.ind;\n  }\n};\n\nclass Solve\n{\n  int N, L;\n  set<Element> A;\n\npublic:\n  Solve(int N, int L, vector<int> input) : N{N}, L{L}\n  {\n    for (auto i = 0; i < N; i++)\n    {\n      A.insert({i, 1, 1, input[i]});\n    }\n  }\n\n  ll count()\n  {\n    ll ans{N};\n    while (true)\n    {\n#if DEBUG == 1\n      for (auto const &e : A)\n      {\n        cerr << \"A[\" << e.ind << \"] = (\" << (e.value ? to_string(*e.value) : \"n\") << \", \" << e.left << \", \" << e.right << \")\" << endl;\n      }\n#endif\n      auto M{min_value()};\n      if (!M)\n      {\n        break;\n      }\n      vector<Element> tmp;\n      for (auto const &e : A)\n      {\n        if (e.value == M)\n        {\n          tmp.push_back(e);\n        }\n        else if (!tmp.empty())\n        {\n          update(ans, tmp);\n        }\n      }\n      if (!tmp.empty())\n      {\n        update(ans, tmp);\n      }\n    }\n    return ans;\n  }\n\nprivate:\n  boost::optional<int> min_value()\n  {\n    boost::optional<int> ans;\n    for (auto const &e : A)\n    {\n      if (e.value)\n      {\n        if (ans)\n        {\n          ch_min(*ans, *e.value);\n        }\n        else\n        {\n          ans = e.value;\n        }\n      }\n    }\n    return ans;\n  }\n\n  void update(ll &ans, vector<Element> &tmp)\n  {\n    for (auto const &e : tmp)\n    {\n      A.erase(A.find(e));\n    }\n    ans += calc(tmp);\n    tmp = press(tmp);\n    ans -= calc(tmp);\n    for (auto &&e : tmp)\n    {\n      A.insert(move(e));\n    }\n    tmp.clear();\n  }\n\n  ll calc(vector<Element> const &X)\n  {\n    ll ans{0};\n    ll sum_right{0};\n    int S{static_cast<int>(X.size())};\n    for (auto i = L - 1; i < S; i++)\n    {\n      sum_right += X[i].right;\n    }\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans += X[i].left * sum_right;\n      sum_right -= X[i + L - 1].right;\n    }\n    assert(sum_right == 0);\n    return ans;\n  }\n\n  vector<Element> press(vector<Element> const &V)\n  {\n    assert(!V.empty());\n    int S{static_cast<int>(V.size())};\n    if (S < L)\n    {\n      return {{V[0].ind, 0, 0, boost::none}};\n    }\n    int index{V[0].ind};\n    int K{*V[0].value + 1};\n    vector<Element> ans(S / L);\n    for (auto &e : ans)\n    {\n      e.ind = index++;\n      e.value = K;\n    }\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].right += V[i].right;\n    }\n    int mod{S % L};\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans[(i + L - mod - 1) / L].left += V[i].left;\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  int N, L;\n  cin >> N >> L;\n  vector<int> A(N);\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> A[i];\n  }\n  Solve solve(N, L, A);\n  cout << solve.count() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  long long ans = n;\n  vector<int> l(n), r(n);\n  set<pair<int, int>> st;\n  set<int> cur;\n  for (int i = 0; i < n; ++i) {\n    l[i] = r[i] = 1;\n    st.emplace(a[i], i);\n    cur.insert(i);\n  }\n  while (!st.empty()) {\n    int p = st.begin()->second;\n    st.erase(st.begin());\n    vector<int> pos(1, p);\n    while (true) {\n      auto it = cur.lower_bound(pos.back() + 1);\n      if (it == cur.end() || a[*it] != a[p]) {\n        break;\n      }\n      st.erase(make_pair(a[p], *it));\n      pos.push_back(*it);\n    }\n    int s = pos.size();\n    if (s >= m) {\n      for (int p : pos) {\n        cur.erase(p);\n      }\n      long long pref = 0;\n      for (int i = m - 1; i < s; ++i) {\n        pref += l[pos[i - m + 1]];\n        ans += pref * r[pos[i]];\n      }\n      int new_s = s / m;\n      vector<int> new_l(new_s), new_r(new_s);\n      for (int i = 0; i < s; ++i) {\n        int p = pos[i];\n        if (i >= m - 1) {\n          new_r[(i - m + 1) / m] += r[p];\n        }\n        if (i + m <= s) {\n          new_l[new_s - 1 - (s - m - i) / m] += l[p];\n        }\n      }\n      for (int i = 0; i < new_s; ++i) {\n        int p = pos[i];\n        l[p] = new_l[i]; r[p] = new_r[i];\n        st.emplace(++a[p], p);\n        cur.insert(p);\n      }\n      if (new_s >= m) {\n        pref = 0;\n        for (int i = m - 1; i < new_s; ++i) {\n          pref += l[pos[i - m + 1]];\n          ans -= pref * r[pos[i]];\n        }\n      }\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\ntypedef long long LL;\n\nint read() {\n  int ans = 0, c, f = 1;\n  while (!isdigit(c = getchar()))\n    if (c == '-') f *= -1;\n  do ans = ans * 10 + c - '0';\n  while (isdigit(c = getchar()));\n  return ans * f;\n}\n\nconst int N = 200050;\n\nint n, l, k[N];\nint val[N], nxt[N], pre[N];\nint q1[N], h1, t1, q2[N], h2, t2;\n\nbool cmp(int a, int b) {\n  if (val[a] == val[b]) return a < b;\n  return val[a] < val[b];\n}\n\nint p[N];\nLL L[N], R[N], Sl[N], Sr[N];\n\nLL Solve(int v) {\n  int m = 0;\n  while (true) {\n    int a = (h1 < t1 && val[q1[h1]] == v) ? q1[h1] : N;\n    int b = (h2 < t2 && val[q2[h2]] == v) ? q2[h2] : N;\n    if (a > n && b > n) break;\n    else if (a < b) p[m++] = q1[h1++];\n    else p[m++] = q2[h2++];\n  }\n  LL ans = 0;\n  p[m] = 0;\n  for (int i = 0, j; i < m; i = j + 1) {\n    for (j = i; nxt[p[j]] == p[j + 1]; ++j);\n    int u = j - i + 1;\n    if (u < l) {\n      nxt[pre[p[i]]] = n + 1;\n      pre[nxt[p[j]]] = 0;\n    } else {\n      Sl[0] = L[p[i]];\n      Sl[u] = Sr[u] = 0;\n      for (int k = 1; k < u; ++k)\n        Sl[k] = Sl[k - 1] + L[p[i + k]];\n      for (int k = l - 1; k < u; ++k)\n        ans += R[p[i + k]] * Sl[k - l + 1];\n      Sr[u - 1] = L[p[j]];\n      for (int k = u - 2; k >= 0; --k)\n        Sr[k] = Sr[k + 1] + R[p[i + k]];\n      int u1 = u / l;\n      for (int k = 0; k < u1; ++k) {\n        int v = p[i + k];\n        L[v] = Sl[u - (u1 - k) * l] - (k == 0 ? 0 : Sl[u - (u1 - k + 1) * l]);\n        R[v] = Sr[(k + 1) * l - 1] - (k == u1 - 1 ? 0 : Sr[(k + 2) * l - 1]);\n        ++val[v]; q2[t2++] = v;\n      }\n      Sl[0] = L[p[i]];\n      for (int k = 1; k < u1; ++k)\n        Sl[k] = Sl[k - 1] + L[p[i + k]];\n      for (int k = l - 1; k < u1; ++k)\n        ans -= R[p[i + k]] * Sl[k - l + 1];\n      int a = p[i + u1 - 1], b = nxt[p[j]];\n      nxt[a] = b; pre[b] = a;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  n = read(), l = read();\n  for (int i = 1; i <= n; ++i)\n    k[i] = i + k[i / l];\n  LL ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    val[q1[i - 1] = i] = read();\n    L[i] = R[i] = 1;\n    nxt[i] = i + 1;\n    pre[i] = i - 1;\n  }\n  h1 = h2 = t2 = 0; t1 = n;\n  std::sort(q1, q1 + n, cmp);\n  while (h1 < t1 || h2 < t2)\n    ans += Solve(std::min(h1 < t1 ? val[q1[h1]] : 0x7f7f7f7f\n                        , h2 < t2 ? val[q2[h2]] : 0x7f7f7f7f));\n  printf(\"%lld\\n\", ans + n);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=4e5+10;\nstruct node{int x,L,R,l,r;};\nbool operator < (node a,node b){\n\tif (a.x==b.x)return a.l<b.l;\n\treturn a.x<b.x;\n}\nset<node> s,s1;\nvector<node> d;\nint n,L;\nll ans;\nint al[N],ar[N],q[N],pl[N],pr[N];\nvoid calc(int x){\n\tll cnt=0;\n\tfor (int i=0;i<d.size();i++){\n\t\tif (i>=L-1)cnt+=d[i-L+1].L;\n\t\tans+=cnt*d[i].R;\n\t}\n\tint c1=1,t=0,t1,L1=0;\n\tL1=d[0].l;\n\tfor (int i=0;i<d.size();i++){\n\t\tif (c1==L){\n\t\t\tar[++t]=0;\n\t\t\tpl[t]=1e9;\n\t\t\tpr[t]=0;\n\t\t\tc1=0;\n\t\t}\n\t\tar[t]+=d[i].R;\n\t\tpl[t]=min(pl[t],d[i].l);\n\t\tpr[t]=max(pr[t],d[i].r);\n\t\tc1++;\n\t}t1=t;\n\tc1=1,t++;\n\tfor (int i=d.size()-1;i>=0;i--){\n\t\tif (c1==L){\n\t\t\tal[--t]=0;\n//\t\t\tpl[t]=1e9;\n//\t\t\tpr[t]=0;\n\t\t\tc1=0;\n\t\t}\n\t\tal[t]+=d[i].L;\n\t\tc1++;\n\t}\n\td.clear();\n\tpl[1]=L1;\n\tfor (int i=1;i<=t1;i++){\n\t\td.push_back((node){x+1,al[i],ar[i],pl[i],pr[i]});\n\t}\n\tcnt=0;\n\tfor (int i=0;i<d.size();i++){\n\t\tif (i>=L-1)cnt+=d[i-L+1].L;\n\t\tans-=cnt*d[i].R;\n\t}\n}\nint main(){\n\tcin>>n>>L;\n\tfor (int i=1;i<=n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ts.insert((node){x,1,1,i,i});\n\t}\n\twhile (s.size()){\n\t\ts1.clear();\n\t\tint v=s.begin()->x;\n\t\tfor (auto i:s){\n\t\t\tif (!d.empty()){\n\t\t\t\tif (d.back().r+1<i.l||i.x!=v){\n\t\t\t\t\tfor (auto x:d)s.erase(x);\n\t\t\t\t\tif (d.size()<L){\n\t\t\t\t\t\td.clear();\n\t\t\t\t\t}\n\t\t\t\t\telse calc(v);\n\t\t\t\t\tfor (auto x:d)s.insert(x);\n\t\t\t\t\td.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i.x!=v)break;\n\t\t\td.push_back(i);\n\t\t}\n\t\tint tag=0;\n\t\twhile (d.size()>=L){\n\t\t\tcalc(v);\n\t\t\ttag=1;\n\t\t}\n\t\tif (d.size()||tag)break;\n\t}\n\tcout<<ans+n<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sz(x) (int)x.size()\n\nint read(){\n\tint a = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c)){f = c == '-'; c = getchar();}\n\twhile(isdigit(c)){\n\t\ta = a * 10 + c - 48; c = getchar();\n\t}\n\treturn f ? -a : a;\n}\n\n#define ll long long\nstruct node{int plc , val , l , r;};\nstruct cmp1{bool operator ()(node a , node b){return a.plc < b.plc;}};\nstruct cmp2{bool operator ()(node a , node b){return a.val < b.val || a.val == b.val && a.plc < b.plc;}};\nset < node , cmp1 > N1; set < node , cmp2 > N2;\nint N , L; ll ans;\n\nll calc(vector < node > &cur){\n\tll sum = 0 , all = 0;\n\tfor(int i = 0 ; i + L - 1 < sz(cur) ; ++i){\n\t\tsum += cur[i].l;\n\t\tall += sum * cur[i + L - 1].r;\n\t}\n\treturn all;\n}\n\nint main(){\n\tN = read(); L = read();\n\tfor(int i = 1 ; i <= N ; ++i){\n\t\tnode now; now.plc = i; now.val = read(); now.l = now.r = 1;\n\t\tN1.insert(now); N2.insert(now);\n\t}\n\twhile(!N2.empty()){\n\t\tint val = N2.begin()->val; vector < node > mn;\n\t\twhile(N2.begin()->val == val){mn.push_back(*N2.begin()); N2.erase(*N2.begin());}\n\t\tfor(int i = 0 , pi = 1 ; i < sz(mn) ; i = pi , pi = i + 1){\n\t\t\twhile(pi < sz(mn) && ++N1.find(mn[pi - 1]) == N1.find(mn[pi])) ++pi;\n\t\t\tvector < node > tmp; tmp.insert(tmp.end() , mn.begin() + i , mn.begin() + pi);\n\t\t\tint len = pi - i , cnt = len / L;\n\t\t\tif(cnt){\n\t\t\t\tans += calc(tmp); vector < node > ntmp;\n\t\t\t\tfor(auto t : tmp) N1.erase(t);\n\t\t\t\tfor(int j = 0 ; j < cnt ; ++j) ntmp.push_back((node){tmp[0].plc + j , val + 1 , 0 , 0});\n\t\t\t\tfor(int j = 0 ; j + L - 1 < sz(tmp) ; ++j) ntmp[cnt - (sz(tmp) - j) / L].l += tmp[j].l;\n\t\t\t\tfor(int j = L - 1 ; j < sz(tmp) ; ++j) ntmp[(j + 1) / L - 1].r += tmp[j].r;\n\t\t\t\tans -= calc(ntmp);\n\t\t\t\tfor(auto t : ntmp){N1.insert(t); N2.insert(t);}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans + N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tchar ch=getchar();int f=0;x=0;\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=200005,inf=1e9+99;\nstruct node{\n\tint level,mx;\n\tvi pre,suf;\t\t\t//pre[i] 前缀至少有 i + 1 个的右端点数量\n\tnode(int _x=inf){\n\t\tlevel=_x,mx=1;\n\t\tif(_x>=0)pre=suf={1};\n\t}\n\tvoid Assert(){\n\t\tassert(pre.size()==mx&&pre[mx-1]);\n\t\tassert(suf.size()==mx&&suf[mx-1]);\n\t}\n}stk[N],emp;\nint a[N],n,L,top;\nll ans;\n\nnode merge(node a[],int n){\n/*\n\tputs(\"==================\\nmerge: \");\n\trep(i,1,n){\n\t\tprintf(\"a[%d] = {%d, %d, { \",i,a[i].level,a[i].mx);\n\t\tfor(auto x:a[i].pre)printf(\"%d \",x);\n\t\tprintf(\"}, { \");\n\t\tfor(auto x:a[i].suf)printf(\"%d \",x);\n\t\tputs(\"}}\");\n\t}\n\tll las=ans;\n*/\n\tstatic int sum[N],tot[N];\n\trep(i,1,n)sum[i]=sum[i-1]+a[i].mx;\n\tif(sum[n]<L)return emp;\n\ttot[n+1]=0;\n\tper(i,n,1)tot[i]=tot[i+1]+a[i].pre[0];\n\tfor(int l=1,r=1,q=1;r<=n;l++)\n\t\tper(i,a[l].mx,1){\n\t\t\twhile(l==r)r++,q=1;\n\t\t\twhile(r<=n&&i+sum[r-1]-sum[l]+q<L){\n\t\t\t\tq++;\n\t\t\t\tif(q<=a[r].mx)continue;\n\t\t\t\tr++,q=1;\n\t\t\t}\n\t\t\tif(r<=n){\n\t\t\t\tint A=a[l].suf[i-1]-(i<a[l].mx?a[l].suf[i]:0);\n\t\t\t\tint B=a[r].pre[q-1]+tot[r+1];\n//\t\t\t\tprintf(\"# %d %d   %d %d   %d\\n\",l,r,i,q,A*B);\n\t\t\t\tans+=(ll)A*B;\n\t\t\t}\n\t\t}\n\tnode res(-1);\n\tres.level=a[1].level+1;\n\tres.mx=sum[n]/L;\n\tres.pre.resize(res.mx);\n\tres.suf.resize(res.mx);\n\tfor(int i=1,cnt=0;i<=n;i++)\n\t\trep(j,1,a[i].mx)\n\t\t\tif(++cnt>=L){\n\t\t\t\tint tmp=a[i].pre[j-1]-(j<a[i].mx?a[i].pre[j]:0);\n\t\t\t\tres.pre[cnt/L-1]+=tmp;\n\t\t\t}\n\tfor(int i=n,cnt=0;i>=1;i--)\n\t\trep(j,1,a[i].mx)\n\t\t\tif(++cnt>=L){\n\t\t\t\tint tmp=a[i].suf[j-1]-(j<a[i].mx?a[i].suf[j]:0);\n\t\t\t\tres.suf[cnt/L-1]+=tmp;\n\t\t\t}\n\tper(i,res.mx-1,1){\n\t\tres.pre[i-1]+=res.pre[i];\n\t\tres.suf[i-1]+=res.suf[i];\n\t}\n/*\n\tll now=ans;\n\tprintf(\"res = %lld\\n\",now-las);\n\tprintf(\"ret = {%d, %d, { \",res.level,res.mx);\n\tfor(auto x:res.pre)printf(\"%d \",x);\n\tprintf(\"}, { \");\n\tfor(auto x:res.suf)printf(\"%d \",x);\n\tputs(\"}}\");\n*/\n\treturn res;\n}\n\nint main(){\n\tread(n),read(L),ans=n;\n\trep(i,1,n)read(a[i]);\n\ta[n+1]=inf;\n\trep(i,1,n){\n\t\tstk[++top]=node(a[i]);\n\t\twhile(stk[top].level<a[i+1]){\n\t\t\tint cur=top;\n\t\t\twhile(cur&&stk[cur].level==stk[top].level)\n\t\t\t\tcur--;\n\t\t\tstk[cur+1]=merge(stk+cur,top-cur);\n\t\t\ttop=cur+1;\n\t\t\tstk[top].Assert();\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define ll long long\nusing namespace std;\nint n,k,tot,pre[400005],nxt[400005],a[400005],l[400005],r[400005],sl[400005],sr[400005];\nll ans;\nbool flag[400005];\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\ttot=n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tpre[i]=i-1,nxt[i]=i+1;\n\t\tq.push(make_pair(a[i],i));\n\t\tl[i]=r[i]=1;\n\t}\n\tnxt[n]=0;\n\twhile(!q.empty())\n\t{\n\t\tint node=q.top().second;\n\t\tq.pop();\n\t\tif(flag[node])continue;\n\t\tint L=node,R=node,len=1;\n\t\twhile(a[pre[L]]==a[node])L=pre[L],len++;\n\t\twhile(a[nxt[R]]==a[node])R=nxt[R],len++;\n\t\tint last=0;\n\t\tfor(int i=L,j=1;i!=nxt[R];i=nxt[i],j++)\n\t\t{\n\t\t\tsl[j]=sl[j-1]+l[i];\n\t\t\tsr[j]=sr[j-1]+r[i];\n\t\t\tif(i<=n)last=j;\n\t\t\tif(last&&j>=k)ans+=1ll*sl[min(j-k+1,last)]*r[i];\n\t\t\tflag[i]=1;\n\t\t}\n\t\tif(len<k)\n\t\t{\n\t\t\tnxt[pre[L]]=pre[nxt[R]]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<=len/k;i++)\n\t\t{\n\t\t\tr[tot+i]=sr[min(len,(i+1)*k-1)]-sr[i*k-1];\n\t\t\tl[tot+i]=sl[len-(len/k-i+1)*k+1]-sl[max(0,len-(len/k-i+2)*k+1)];\n\t\t}\n\t\tnxt[pre[L]]=tot+1,pre[tot+1]=pre[L];\n\t\tpre[nxt[R]]=tot+len/k,nxt[tot+len/k]=nxt[R];\n\t\tfor(int i=1;i<len/k;i++)\n\t\t{\n\t\t\tnxt[tot+i]=tot+i+1;\n\t\t\tpre[tot+i+1]=tot+i;\n\t\t}\n\t\tfor(int i=1;i<=len/k;i++)a[tot+i]=a[L]+1;\n\t\tq.push(make_pair(a[tot+1],tot+1));\n\t\ttot+=len/k;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 200010\n#define ll long long\nint n,m;\nint a[N];\nstruct Node{\n\tNode *pre,*suc;\n\tint v,L,R;\n\tll s;\n\tbool f;\n} *fir,*lst;\nNode *ins(int v,int L,int R,int s,Node *pre,Node *suc){\n\tNode *nw=new Node;\n\t*nw=(Node){pre,suc,v,L,R,s,0};\n\tif (pre) pre->suc=nw;\n\tif (suc) suc->pre=nw;\n\treturn nw;\n}\nNode *h[N];\nint nh;\nbool cmph(Node *son,Node *fa){return son->v>fa->v;}\nint L[N],R[N],L_[N],R_[N];\nll calc(int L[],int R[],int k){\n\tll sL=0,s=0;\n\tfor (int i=1;i<=k;++i){\n\t\tif (i-m+1>0)\n\t\t\tsL+=L[i-m+1];\n\t\ts+=(sL+L[i])*R[i];\n\t}\n\treturn s;\n}\nll ans;\nint main(){\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&a[i]);\n\tans=n;\n\tfir=lst=ins(a[1],1,1,1,NULL,NULL);\n\th[nh++]=fir,fir->f=1;\n\tfor (int i=2;i<=n;++i){\n\t\tlst=ins(a[i],1,1,1,lst,NULL);\n\t\tif (lst->v!=lst->pre->v)\n\t\t\th[nh++]=lst,lst->f=1;\n\t}\n\tmake_heap(h,h+nh,cmph);\n\twhile (nh){\n\t\tNode *fir=h[0];\n\t\tpop_heap(h,h+nh--,cmph);\n\t\tif (fir->f==0 || fir->pre && fir->pre->v==fir->v)\n\t\t\tcontinue;\n\t\tint v=fir->v,k=0;\n\t\tNode *p=fir,*lst=p;\n\t\tfor (int i=1;p && p->v==v;++i,p=p->suc)\n\t\t\tL[i]=p->L,R[i]=p->R,++k,lst=p;\n\t\tNode *pre=fir->pre,*suc=lst->suc;\n\t\tif (pre) pre->suc=NULL;\n\t\tif (suc) suc->pre=NULL;\n\t\tfir->f=0;\n\t\tfir->pre=lst->suc=NULL;\n\t\tif (k==1 || k>=m){\n\t\t\tfor (Node *p=fir;p && p->v==v;p=p->suc)\n\t\t\t\tans-=p->s;\n\t\t\tans+=calc(L,R,k);\n\t\t\tif (k==1)\n\t\t\t\tcontinue;\n\t\t\tint d=k/m;\n\t\t\tmemset(L_,0,sizeof(int)*(d+1));\n\t\t\tmemset(R_,0,sizeof(int)*(d+1));\n\t\t\tfor (int i=m;i<=k;++i)\n\t\t\t\tR_[i/m]+=R[i];\n\t\t\tfor (int i=k-m+1;i>=1;--i)\n\t\t\t\tL_[d-(k-i+1)/m+1]+=L[i];\n\t\t\tfor (int i=d;i>=1;--i)\n\t\t\t\tsuc=ins(v+1,L_[i],R_[i],0,pre,suc);\n\t\t\tsuc->f=1;\n\t\t\tsuc->s=calc(L_,R_,d);\n\t\t\th[nh++]=suc;\n\t\t\tpush_heap(h,h+nh,cmph);\n\t\t\tcontinue;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define pii pair<int,int>\n#define riterator reverse_iterator\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 2e5;\npriority_queue<pii,vector<pii>,greater<pii> > que;\nint nxt[N+3],prv[N+3];\nint a[N+3];\nllong cl[N+3],cr[N+3],cl2[N+3],cr2[N+3];\nvector<int> vec;\nint n,m; llong ans;\n\nvoid solve(int l,int r)\n{\n//\tprintf(\"solve %d %d\\n\",l,r);\n\tllong sum = 0ll;\n\tfor(int i=m-1; i<vec.size(); i++)\n\t{\n\t\tsum += cl[vec[i-m+1]];\n\t\tans += cr[vec[i]]*sum;\n\t}\n\tint cnt = vec.size()/m;\n\tfor(int i=l; i<=l+cnt-1; i++) cl2[i] = cr2[i] = 0ll;\n\tfor(int i=vec.size()-m,j=0,k=l+cnt-1; i>=0; i--)\n\t{\n\t\tcl2[k] += cl[vec[i]];\n\t\tif(j==m-1) {k--,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=m-1,j=0,k=l; i<vec.size(); i++)\n\t{\n\t\tcr2[k] += cr[vec[i]];\n\t\tif(j==m-1) {k++,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=l; i<=l+cnt-1; i++) cl[i] = cl2[i],cr[i] = cr2[i];\n\tsum = 0ll;\n\tfor(int i=l+m-1; i<=l+cnt-1; i++)\n\t{\n\t\tsum += cl[i-m+1];\n\t\tans -= cr[i]*sum;\n\t}\n\tif(cnt==0)\n\t{\n\t\tnxt[prv[l]] = nxt[r]; prv[nxt[r]] = prv[l];\n\t}\n\telse\n\t{\n\t\tnxt[l+cnt-1] = nxt[r]; prv[nxt[r]] = l+cnt-1;\n\t\tfor(int i=l; i<l+cnt-1; i++) nxt[i] = i+1;\n\t\tfor(int i=l+1; i<=l+cnt-1; i++) prv[i] = i-1;\n\t\tint val = a[l]; for(int i=l; i<=l+cnt-1; i++) a[i] = val+1;\n\t\tfor(int i=l; i<=l+cnt-1; i++) que.push(mkpr(a[i],i));\n\t}\n//\tprintf(\"cnt=%d\\n\",cnt);\n//\tprintf(\"prv: \"); for(int i=1; i<=n; i++) printf(\"[%d]%d \",i,prv[i]); puts(\"\");\n//\tprintf(\"nxt: \"); for(int i=1; i<=n; i++) printf(\"[%d]%d \",i,nxt[i]); puts(\"\");\n//\tprintf(\"cl: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cl[i]); puts(\"\");\n//\tprintf(\"cr: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cr[i]); puts(\"\");\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&a[i]),que.push(mkpr(a[i],i)),cl[i] = cr[i] = 1ll,nxt[i] = i+1,prv[i] = i-1;\n\tnxt[0] = 1,prv[n+1] = n;\n\twhile(1)\n\t{\n\t\tint l = que.top().second,r = l; que.pop(); vec.clear(); vec.push_back(l);\n\t\twhile(!que.empty() && que.top().first==a[l] && que.top().second==nxt[r]) {r = nxt[r]; vec.push_back(r); que.pop();}\n\t\tsolve(l,r);\n\t\tif(l==r&&prv[l]==0&&nxt[r]==n+1) break;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}\n/*\n15 3\n3 2 2 2 3 4 8 2 2 2 2 2 2 2 8\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>V;\ntypedef long long ll;\nconst int N=2e5+5;\nlong long ans;\nint n,L,a[N],i,j,x,aa[N];\nint g[N];\nV lv[N],rv[N];int mx[N];\nint gfa(int x){return g[x]==x?x:g[x]=gfa(g[x]);}\ninline bool cmp(int x,int y){return a[x]==a[y]?x<y:a[x]<a[y];}\nlong long mi;\nstruct atom{\n\tV l,r;int mx;bool full;\n\tinline void set(const atom&a,int mx2){\n\t\tll z=1;int zz=max(a.l.empty()?0:a.l.back(),a.r.empty()?0:a.r[0]);\n\t\tfull=0;l.clear();r.clear();\n\t\tfor(mx=a.mx;mx<mx2 && z<=zz;z*=L,++mx);\n\t\tif(zz<z){mx=mx2;return;}\n\t\tfull=a.full;\n\t\tfor(int x:a.l)if(x>=z)l.push_back(x/z);\n\t\tfor(int x:a.r)if(x>=z)r.push_back(x/z);\n\t}\n}b[N],v[N];int xb;\nint w,l,s,st[N];bool bb[N];\ninline void uni(atom&zz){\n\tw=s=0;l=1;\n\tzz.full=1;zz.mx=b[1].mx;\n\tfor(int i=1;i<=xb;++i){\n\t\tzz.full&=b[i].full;\n\t\tif(!b[i].full)w=s=0,l=1;\n\t\tfor(int x:b[i].l){\n\t\t\tfor(;l<=w && st[l]+s+x>=L;++l)if(l<w && bb[l+1])s-=st[l+1];\n\t\t\tans+=l-1;\n\t\t}\n\t\tif(!b[i].r.empty()){\n\t\t\tif(l<=w)s+=b[i].r[0];int ow=w;\n\t\t\tfor(int x:b[i].r)st[++w]=x,bb[w]=0;bb[ow+1]=1;\n\t\t}\n\t}\n\tzz.r.resize(w);s=0;for(int i=w;i;--i)zz.r[i-1]=st[i]+s,s+=bb[i]?st[i]:0;\n\tw=0;\n\tfor(int i=xb;i;--i){\n\t\tif(!b[i].full)w=0;\n\t\tif(!b[i].l.empty()){\n\t\t\tint ow=w;reverse(b[i].l.begin(),b[i].l.end());\n\t\t\tfor(int x:b[i].l)st[++w]=x,bb[w]=0;bb[ow+1]=1;\n\t\t}\n\t}\n\tzz.l.resize(w);s=0;for(int i=w;i;--i)zz.l[w-i]=st[i]+s,s+=bb[i]?st[i]:0;\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>L;for(i=1;i<=n;++i)cin>>a[i],aa[i]=i,g[i]=i,v[i].l=v[i].r={1},v[i].mx=a[i],v[i].full=1;\n\tstd::sort(aa+1,aa+n+1,cmp);\n\tfor(i=1;i<=n;i=j){\n\t\txb=0;\n\t\tif(aa[i]>1 && a[aa[i]-1]<a[aa[i]])b[++xb].set(v[aa[i]-1],a[aa[i]]),g[aa[i]-1]=aa[i];\n\t\tfor(j=i+1,b[++xb]=v[aa[i]];j<=n && a[aa[j]]==a[aa[i]] && a[gfa(aa[j-1]+1)]<=a[aa[j]];++j){\n\t\t\tif(aa[j-1]+1<aa[j])b[++xb].set(v[aa[j]-1],a[aa[i]]),g[aa[j]-1]=aa[j];\n\t\t\tb[++xb]=v[aa[j]];g[aa[j-1]]=aa[j-1]+1;\n\t\t}\n\t\tif(aa[j-1]<n && a[aa[j-1]]>a[aa[j-1]+1])b[++xb].set(v[gfa(aa[j-1]+1)],a[aa[i]]),g[aa[j-1]]=aa[j-1]+1;\nif(a[aa[i]]==99)\n++i,--i;\n\t\tuni(v[gfa(aa[i])]);\n\t}\n\tcout<<ans+n<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#define PB push_back\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\n\nconst int N=6e5+10,inf=2e9;\nint fa[N],ch[N][2],mx[N],mi[N],sz[N],val[N],ncnt,rt;\nint Lx[N],Rx[N],vis[N];\nint L;\ninline void push_up(int c) {\n\tif(c==0) printf(\"!!!\\n\");\n\tsz[c]=sz[ch[c][0]]+sz[ch[c][1]]+1;\n\tmi[c]=min(min(mi[ch[c][0]],mi[ch[c][1]]),vis[c]?inf:val[c]);\n\tmx[c]=max(max(mx[ch[c][0]],mx[ch[c][1]]),vis[c]?0:val[c]);\n}\ninline bool get(int x) { return ch[fa[x]][1]==x; }\ninline void rotate(int x) {\n\tint f=fa[x],ff=fa[f],d=get(x);\n\tfa[x]=ff; if(ff) ch[ff][ch[ff][1]==f]=x;\n\tfa[ch[x][d^1]]=f,ch[f][d]=ch[x][d^1];\n\tfa[f]=x,ch[x][d^1]=f; push_up(f),push_up(x);\n}\nvoid splay(int x,int gl) {\n\tfor(int f=fa[x];f!=gl;rotate(x),f=fa[x])\n\t\tif(fa[f]!=gl) rotate(get(x)==get(f)?f:x);\n\tif(!gl) rt=x;\n}\nint kth(int x,int k) {\n//\tcout<<\"kth:\"<<x<<' '<<sz[x]<<' '<<sz[ch[x][0]]<<' '<<k<<endl;\n\tif(sz[ch[x][0]]+1==k) return x;\n\tif(k<=sz[ch[x][0]]) return kth(ch[x][0],k);\n\treturn kth(ch[x][1],k-sz[ch[x][0]]-1);\n}\nvoid debug(int x) {\n\tif(!x) return;\n\tdebug(ch[x][0]);\n\tprintf(\"%d \",vis[x]?-1:val[x]);\n\tdebug(ch[x][1]);\n\tpush_up(x);\n}\nvoid Debug() { printf(\"debug:\"),debug(rt),puts(\"\"); sz[0]=0; }\nint split(int l,int r) {\n//\tif(l==1&&r==sz[rt]) return rt;\n//\tif(l==1) {\n//\t\tint y=kth(rt,r+1); splay(y,0);\n//\t\treturn ch[y][0];\n//\t}\n//\tif(r==sz[rt]) {\n//\t\tint x=kth(rt,l-1); splay(x,0);\n//\t\treturn ch[x][1];\n//\t}\n//\tcout<<\"KTH:\"<<rt<<' '<<sz[rt]<<endl;\n\tint x=kth(rt,l-1),y=kth(rt,r+1);\n//\tcout<<\"SPLIT:\"<<x<<' '<<y<<' '<<l-1<<' '<<r+1<<' '<<endl;\n\tsplay(x,0),splay(y,x);\n\treturn ch[y][0];\n}\nint lv[N],rv[N],V[N],Vi[N],lim;\nvoid build(int l,int r,int &c,int f) {\n\tif(l>r) return (void)(c=0);\n\tint mid=l+r>>1; c=++ncnt;\n\tval[c]=V[mid],vis[c]=Vi[mid],fa[c]=f;\n\tLx[c]=lv[mid],Rx[c]=rv[mid];\n\tbuild(l,mid-1,ch[c][0],c);\n\tbuild(mid+1,r,ch[c][1],c);\n\tpush_up(c);\n}\nstruct item {\n\tint p,l,r;\n\titem(int p=0,int l=0,int r=0): p(p),l(l),r(r) {}\n};\nvector<item> A;\nvoid find(int x,int pr) {\n\tif(mi[x]>lim) return;\n\tfind(ch[x][0],pr); pr+=sz[ch[x][0]];\n\tif(val[x]==lim&&!vis[x]) A.PB(item(pr+1,Lx[x],Rx[x]));\n\tfind(ch[x][1],pr+1);\n}\n\nint main() {\n\tmi[0]=inf;\n\tint n; rd(n),rd(L);\n\tfor(int i=1;i<=n;++i) rd(V[i]),lv[i]=rv[i]=1;\n\tVi[0]=Vi[n+1]=1;\n\tbuild(0,n+1,rt,0);\n\tVi[0]=Vi[n+1]=0;\n\tll ans=0;\n\twhile(true) {\n//\t\tcout<<rt<<' '<<mi[rt]<<' '<<mx[rt]<<endl;\n\t\tA.clear(),lim=mi[rt],find(rt,0);\n//\t\tfor(int i=0;i<A.size();++i) printf(\"(%d,%d,%d) \",A[i].p,A[i].l,A[i].r); puts(\"\");\n//\t\tcout<<\"OK\"<<endl;\n\t\tfor(int l=0,r;l<A.size();l=r+1) {\n\t\t\tr=l; while(r+1<A.size()&&A[r+1].p==A[r].p+1) ++r;\n\t\t\tll s=0;\n\t\t\tfor(int i=l;i<=r;++i) {\n\t\t\t\tif(i-L+1>=l) s+=A[i-L+1].l;\n\t\t\t\tans+=s*A[i].r;\n\t\t\t\tans+=A[i].l*A[i].r;\n\t\t\t}\n\t\t}\n\t\tif(mi[rt]>=mx[rt]) break;\n\t\tint pre=0;\n\t\tfor(int l=0,r;l<A.size();l=r+1) {\n\t\t\tr=l; while(r+1<A.size()&&A[r+1].p==A[r].p+1) ++r;\n\t\t\tint len=(r-l+1)/L;\n\t\t\tint u=split(A[l].p+pre,A[r].p+pre);\n\t\t\tpre-=r-l+1; pre+=max(len,1);\n//\t\t\tcout<<\"fa:\"<<A[l].p<<' '<<A[r].p<<' '<<u<<' '<<fa[u]<<' '<<fa[fa[u]]<<endl;\n\t\t\tif(!len) {\n\t\t\t\tvis[u]=1;\n\t\t\t\tch[u][0]=ch[u][1]=0;\n//\t\t\t\tcout<<\"PUSH:\"<<u<<' '<<fa[u]<<' '<<rt<<endl;\n\t\t\t\tpush_up(u),push_up(fa[u]),push_up(rt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<len;++i) lv[i]=rv[i]=0,V[i]=lim+1;\n\t\t\tfor(int i=l+L-1;i<=r;++i) rv[(i-l+1)/L-1]+=A[i].r;\n\t\t\tfor(int i=l;i<=r-L+1;++i) lv[len-(r-i+1)/L]+=A[i].l;\n//\t\t\tfor(int i=0;i<len;++i) printf(\"(%d,%d) \",lv[i],rv[i]); puts(\"\");\n\t\t\tfor(int i=0,s=0;i<len;++i) {\n\t\t\t\tif(i-L+1>=0) s+=lv[i-L+1];\n\t\t\t\tans-=s*rv[i];\n\t\t\t\tans-=lv[i]*rv[i];\n\t\t\t}\n\t\t\tbuild(0,len-1,ch[fa[u]][0],fa[u]);\n\t\t\tpush_up(fa[u]),push_up(rt);\n//\t\t\tcout<<\"PUSH:\"<<fa[u]<<' '<<rt<<endl;\n\t\t}\n//\t\tcout<<ans<<' '<<sz[rt]<<endl;\n//\t\tDebug();\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,L;\n#define Maxn 200010\nll Ans=0;\nstruct data{\n    int val,pos;\n    bool operator <(const data &z)const{return val==z.val?pos<z.pos:val<z.val;}\n}seq[Maxn];\nstruct Data{\n    int l,r;\n\tint x,y;\n\tbool operator <(const Data &z)const{return l<z.l;}\n};\nvector<Data> A,B,vec2;\nvector<pair<int,int> > vec1;\nint num[Maxn];\n\ninline ll calc(vector< pair<int,int> > &a){\n\tll res=0,sum=0;\n\tfor(int i=L-1,j=0;i<a.size();i++,j++){\n\t\tsum+=a[j].first;\n\t\tres+=a[i].second*sum;\n\t}\n\treturn res;\n}\n\ninline void rd(int &x){\n\tx=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9')ch=getchar();\n\twhile(ch>='0'&&ch<='9'){\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t} \n}\n\nint main(){\n\trd(n);rd(L);\n\tfor(register int i=1;i<=n;++i){\n\t\trd(num[i]);\n\t\tseq[i]=(data){num[i],i};\n\t}\n\tsort(seq+1,seq+n+1);\n\tll Ans=n;\n\tint at=1,tmp;\n\twhile(true){\n\t\tif(A.empty()){\n\t\t\tif(at>n)break;\n\t\t\telse tmp=seq[at].val;\n\t\t}else tmp++;\n\t\twhile(tmp==seq[at].val)A.push_back((Data){seq[at].pos,seq[at].pos,1,1}),at++;\n\t\tB.clear();sort(A.begin(),A.end());\n\t\tfor(int i=0,j;i<A.size();i=j+1){\n\t\t\tj=i;\n\t\t\twhile(j+1<A.size()&&A[j+1].l==A[j].r+1)j++;\n\t\t\tint len=j-i+1,cnt=len/L;\n\t\t\tif(cnt){\n\t\t\t\tvec1.clear();\n\t\t\t\tvec2.clear();\n\t\t\t\tfor(register int k=i;k<=j;++k)vec1.push_back(make_pair(A[k].x,A[k].y));\n\t\t\t\tAns+=calc(vec1);\n\t\t\t\tfor(register int k=1;k<=cnt;++k)\n\t\t\t\t\tvec2.push_back((Data){A[i].l+k-1,(k==cnt)?A[j].r:A[i].l+k-1,0,0});\n\t\t\t\tfor(register int k=i;k<=j;++k){\n\t\t\t\t\tint tl=k-i+1,tr=j-k+1;\n\t\t\t\t\tvec2[tl/L-1].y+=A[k].y;\n\t\t\t\t\tvec2[cnt-tr/L].x+=A[k].x;\n\t\t\t\t}\n\t\t\t\tvec1.clear();\n\t\t\t    for(register int k=0;k<cnt;++k)vec1.push_back(make_pair(vec2[k].x,vec2[k].y));\n\t\t\t\tAns-=calc(vec1);\n\t\t\t\tfor(register int k=0;k<cnt;++k)B.push_back(vec2[k]);\n\t\t\t}\n\t\t}\n\t\tA.clear();\n\t\tfor(int i=0;i<B.size();++i)A.push_back(B[i]);\n\t}\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace mine\n{\n    typedef long long ll;\n    #define pr pair<int,int>\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define PB push_back\n    #define vc vector\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n    #define bin(x) (1ll<<(x))\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) putchar('-'),num=-num;\n        if(num>=10) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    template<typename T> void chmax(T &x,const T y) {x=(x>y?x:y);}\n    template<typename T> void chmin(T &x,const T y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):0;}\n    const int INF=0x3f3f3f3f;\n    const int MOD=998244353;\n    inline int mm(const int x){return x>=MOD?x-MOD:x;}\n    inline ll qpower(ll x,ll e)\n    {\n        ll ans=1;\n        while(e)\n        {\n            if(e&1) ans=ans*x%MOD;\n            x=x*x%MOD;e>>=1;\n        }\n        return ans;\n    }\n    ll invm(ll x){return qpower(x,MOD-2);}\n    const int N=1e6+10;\n\n    vc<pr> nw;int L;\n    ll calcnw()\n    {\n        ll ans=0,sum=0;\n        for(int t=L-1;t<sz(nw);t++) sum+=nw[t-L+1].FR,ans+=sum*nw[t].SE;\n        return ans;\n    }\n    vc< pair<pr,pr> > all,all2;//(fl,fr,li,ri)表示覆盖区间、作为端点的系数；里面所有数当前都是val\n    vc<pr> num;\n    void main()\n    {\n        int n=qread();L=qread();\n        for(int i=1;i<=n;i++) num.PB(MP(qread(),i));sort(all(num));\n        ll ans=n;int val=0,numpos=0;\n        while(1)\n        {\n            if(!sz(all))\n            {\n                if(numpos==n) break;\n                val=num[numpos].FR;\n            } else val++;\n            while(numpos<n and num[numpos].FR==val)//newguy\n                all.PB(MP( MP(num[numpos].SE,num[numpos].SE),MP(1,1) )),numpos++;\n            sort(all(all));all2.clear();\n            for(int i=0,j;i<sz(all);i=j+1)\n            {\n                j=i;while(j+1<sz(all) and all[j].FR.SE+1==all[j+1].FR.FR) j++;//极长连续段\n                int cnt=(j-i+1)/L;if(!cnt) continue;\n                nw.clear();for(int k=i;k<=j;k++) nw.PB(all[k].SE);ans+=calcnw();\n                vc<pr> pos,pp;pp.resize(cnt);\n                for(int k=i;k<=j;k++)\n                {\n                    int tl=k-i+1,tr=j-k+1;\n                    if(tl>=L) pp[tl/L-1].SE+=all[k].SE.SE;\n                    if(tr>=L) pp[cnt-tr/L].FR+=all[k].SE.FR;\n                }\n                nw=pp;ans-=calcnw();\n                for(int t=0;t<cnt;t++) pos.PB(MP(all[i].FR.FR+t,all[i].FR.FR+t));pos[cnt-1].SE=all[j].FR.SE;\n                for(int t=0;t<cnt;t++) all2.PB(MP(pos[t],pp[t]));\n            }\n            all=all2;\n        }\n        write(ans);\n    }\n};\nint main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[200005],cur,is[200005],pw[200005],fa[200005];\nint *pre[200005],*suf[200005],cnt[200005],nwa[200005];\nll ans;\nint dp[400005],*f=dp+400000;\nint w[25000005],*at=w;\npii b[200005];\nint *newI(int n){\n\tat+=n;\n\treturn at-n;\n}\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nint nex[200005],stk[200005],tp,ist[200005];\nvoid add(int x,int y){\n//\twrite(x,'-',y,'\\n');\n\tist[y]=-1;if(!ist[x])ist[x]=1;\t\n\tstk[++tp]=x;\n\tnex[x]=y;\n}\nvoid put(int x){\n\tis[x]=1;\n\tnwa[x]=a[x];\n\tcnt[x]=1;\n\tpre[x]=newI(1);pre[x][0]=1;suf[x]=newI(1);suf[x][0]=1;\n\tfa[x]=x;\n\tif(is[x-1]){add(find(x-1),x);}\n\tif(is[x+1]){add(x,find(x+1));}\n}\nint id[200005],m,n,l;\nvoid solve(){\n\tint cc=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(nwa[id[i]]!=cur){\n\t\t\tint S=pw[min(cur-nwa[id[i]],n)];\n//\t\t\twrite(id[i],' ',cnt[id[i]],' ',nwa[id[i]],' ',S,'\\n');\n\t\t\tint *p=pre[id[i]],*s=suf[id[i]];\n\t\t\tfor(int j=1;j<=cnt[id[i]];++j){\n\t\t\t\tint w=p[j-1];\n\t\t\t\tp[j-1]=0;\n\t\t\t\tif(j>=S)p[j/S-1]+=w;\n\t\t\t\tw=s[j-1];\n\t\t\t\ts[j-1]=0;\n\t\t\t\tif(j>=S)s[j/S-1]+=w;\n\t\t\t}\n\t\t\tcnt[id[i]]/=S;\n\t\t}\n\t\tcc+=cnt[id[i]];\n\t}\t\n\n/*\twrite(m,'\\n');\n\tfor(int i=1;i<=m;++i){\n\t\twrite(cnt[id[i]],':');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('|');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('\\n');\n\t}*/\n\tint *np=newI(cc),*ns=newI(cc);\n\tint t=0;\n\tfor(int i=1;i<=m;++i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tnp[t]=pre[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tt=0;\n\tfor(int i=m;i;--i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tns[t]=suf[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tfor(int i=m;i;--i){\n\t\tfor(int j=1;j<=cnt[id[i]];++j)ans+=(ll)suf[id[i]][j-1]*f[max(1,l-j)];\n\t\tfor(int j=cnt[id[i]];j;--j){f[0]=f[1]+pre[id[i]][j-1];--f;}\n\t}\n\tfor(int i=1;i<=cc;++i)*(++f)=0;\n\t/*write(ans,'\\n');\n\twrite(cc,'|',id[1],'\\n');*/\n\tcnt[id[1]]=cc;\n\tpre[id[1]]=np;\n\tsuf[id[1]]=ns;\n}\nvoid work(){\n\tfor(;tp;--tp){\n\t\tif(ist[stk[tp]]<=0){ist[stk[tp]]=0;continue;}\n\t\tist[stk[tp]]=0;\n\t\tint at=stk[tp];\n\t\tm=0;\n\t\twhile(at){\n//\t\t\twrite(at,'(');\n\t\t\tid[++m]=at;\n\t\t\tfa[at]=stk[tp];\n\t\t\tint nx=nex[at];\n\t\t\tnex[at]=0;\n\t\t\tat=nx;\n\t\t}\n\t\tsolve();\n\t}\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tread(n,l);\n\tpw[0]=1;\n\tint iee=n/l+1;\n\tfor(int i=1;i<=n;++i)pw[i]=min(pw[i-1],iee)*l;\n\tfor(int i=1;i<=n;++i){read(a[i]);b[i]=make_pair(a[i],i);}\n\tsort(b+1,b+n+1);\n\tfor(int i=1,j=1;i<=n;i=j){\n\t\tcur=b[i].x;\n\t\twhile(b[i].x==b[j].x){put(b[j].y);++j;}\n\t\twork();\n\t}\n\twrite(ans+n,'\\n');\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 08.12.2019 08:24:29       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, len;\n  cin >> n >> len;\n  vector<int> a(n);\n  vector<int> L(n);\n  vector<int> R(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    L[i] = 1;\n    R[i] = 1;\n  }\n  long long ans = n;\n  set<pair<int, int>> s;\n  set<int> alive;\n  for (int i = 0; i < n; i++) {\n    s.emplace(a[i], i);\n    alive.insert(i);\n  }\n  while (!s.empty()) {\n    int id = s.begin()->second;\n    s.erase(s.begin());\n    vector<int> pos(1, id);\n    while (true) {\n      auto it = alive.lower_bound(pos.back() + 1);\n      if (it == alive.end() || a[*it] != a[id]) {\n        break;\n      }\n      s.erase(make_pair(a[*it], *it));\n      pos.push_back(*it);\n    }\n    int sz = (int) pos.size();\n    if (sz < len) {\n      continue;\n    }\n    {\n      long long sumL = 0;\n      for (int i = len - 1; i < sz; i++) {\n        sumL += L[pos[i - len + 1]];\n        ans += sumL * R[pos[i]];\n      }\n    }\n    if (len * 1LL * len <= sz) {\n      long long sumL = 0;\n      for (int i = len * len - 1; i < sz; i++) {\n        sumL += L[pos[i - len * len + 1]];\n        ans -= sumL * R[pos[i]];\n      }\n    }\n    debug(ans);\n    for (int x : pos) {\n      alive.erase(x);\n    }\n    int new_sz = sz / len;\n    vector<int> newL(new_sz);\n    vector<int> newR(new_sz);\n    for (int i = 0; i < sz; i++) {\n      if (i >= len - 1) {\n        newR[(i - (len - 1)) / len] += R[pos[i]];\n      }\n      if (i <= sz - len) {\n        newL[new_sz - 1 - ((sz - len) - i) / len] += L[pos[i]];\n      }\n    }\n    debug(newL, newR);\n    for (int i = 0; i < new_sz; i++) {\n      alive.insert(pos[i]);\n      L[pos[i]] = newL[i];\n      R[pos[i]] = newR[i];\n      a[pos[i]] += 1;\n      s.emplace(a[pos[i]], pos[i]);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sz(x) (int)x.size()\n\nint read(){\n\tint a = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c)){f = c == '-'; c = getchar();}\n\twhile(isdigit(c)){\n\t\ta = a * 10 + c - 48; c = getchar();\n\t}\n\treturn f ? -a : a;\n}\n\n#define ll long long\nstruct node{int plc , val , l , r;};\nstruct cmp1{bool operator ()(node a , node b){return a.plc < b.plc;}};\nstruct cmp2{bool operator ()(node a , node b){return a.val < b.val || a.val == b.val && a.plc < b.plc;}};\nset < node , cmp1 > N1; set < node , cmp2 > N2;\nint N , L; ll ans;\n\nll calc(vector < node > &cur){\n\tll sum = 0 , all = 0;\n\tfor(int i = 0 ; i + L - 1 < sz(cur) ; ++i){\n\t\tsum += cur[i].l;\n\t\tall += sum * cur[i + L - 1].r;\n\t}\n\treturn all;\n}\n\nint main(){\n\tN = read(); L = read();\n\tfor(int i = 1 ; i <= N ; ++i){\n\t\tnode now; now.plc = i; now.val = read(); now.l = now.r = 1;\n\t\tN1.insert(now); N2.insert(now);\n\t}\n\twhile(!N2.empty()){\n\t\tint val = N2.begin()->val; vector < node > mn;\n\t\twhile(N2.begin()->val == val){mn.push_back(*N2.begin()); N2.erase(*N2.begin());}\n\t\tif(N2.empty()) ans += calc(mn);\n\t\telse\n\t\t\tfor(int i = 0 , pi = 1 ; i < sz(mn) ; i = pi , pi = i + 1){\n\t\t\t\twhile(pi < sz(mn) && ++N1.find(mn[pi - 1]) == N1.find(mn[pi])) ++pi;\n\t\t\t\tvector < node > tmp; tmp.insert(tmp.end() , mn.begin() + i , mn.begin() + pi);\n\t\t\t\tint len = pi - i , cnt = len / L;\n\t\t\t\tif(cnt){\n\t\t\t\t\tans += calc(tmp); vector < node > ntmp;\n\t\t\t\t\tfor(auto t : tmp) N1.erase(t);\n\t\t\t\t\tfor(int j = 0 ; j < cnt ; ++j) ntmp.push_back((node){tmp[0].plc + j , val + 1 , 0 , 0});\n\t\t\t\t\tfor(int j = 0 ; j + L - 1 < sz(tmp) ; ++j) ntmp[cnt - (sz(tmp) - j) / L].l += tmp[j].l;\n\t\t\t\t\tfor(int j = L - 1 ; j < sz(tmp) ; ++j) ntmp[(j + 1) / L - 1].r += tmp[j].r;\n\t\t\t\t\tans -= calc(ntmp);\n\t\t\t\t\tfor(auto t : ntmp){N1.insert(t); N2.insert(t);}\n\t\t\t\t}\n\t\t\t}\n\t}\n\tcout << ans + N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\npriority_queue<pint,vector<pint>,greater<pint> >q;\nint n,L,l[MAXN],r[MAXN];ll lf[MAXN],rf[MAXN],f1[MAXN],f2[MAXN];\nvector<int>S1,S2;\ninline void add(int x,int y){r[l[y]=x]=y;}\ninline ll Solve(int x){\n\tll res=0,tmp=0;int len=S2.size(),lb=l[S2[0]],rb=r[S2[len-1]];\n\tfor(int i=0;i<len;i++)(i-L+1>=0?tmp+=lf[S2[i-L+1]]:0),res+=rf[S2[i]]*tmp;\n\tfor(int i=0;i<len;i++)f1[S2[i]]=lf[S2[i]],f2[S2[i]]=rf[S2[i]],lf[S2[i]]=rf[S2[i]]=0;\n\tint cnt=len/L;\n\tif(cnt){\n\t\tfor(int i=L-1;i<len;i++){int t=(i+1)/L-1;rf[S2[t]]+=f2[S2[i]];}\n\t\tfor(int i=len-L;i>=0;i--){int t=cnt-(len-i)/L;lf[S2[t]]+=f1[S2[i]];}\n\t\tfor(int i=1;i<cnt;i++)add(S2[i-1],S2[i]);add(lb,S2[0]),add(S2[cnt-1],rb);\n\t\tfor(int i=0;i<cnt;i++)q.push(mk(x+1,S2[i]));tmp=0;\n\t\tfor(int i=0;i<cnt;i++)(i-L+1>=0?tmp+=lf[S2[i-L+1]]:0),res-=rf[S2[i]]*tmp;\n\t}else r[lb]=n+1,l[rb]=0;S2.clear();\n\treturn res;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),L=read();\n\tRep(i,1,n){int x=read();q.push(mk(x,i)),add(i,i+1),lf[i]=rf[i]=1;}\n\tadd(0,1);ll ans=0;\n\tfor(;!q.empty();){\n\t\tint x=q.top().fir;S1.clear();\n\t\tfor(;!q.empty()&&q.top().fir==x;q.pop())S1.push_back(q.top().sec);\n\t\tS2.clear();S2.push_back(S1[0]);\n\t\tfor(int i=1,len=S1.size();i<len;i++){if(r[S1[i-1]]!=S1[i])ans+=Solve(x);S2.push_back(S1[i]);}\n\t\tans+=Solve(x);\n\t}cout<<ans+n<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=200005;\nint n,L;\nint a[N];\nint rp[N];\nvector <int> vl[N],vr[N];\nbool cmp(int x,int y){\n\tif (a[x]!=a[y])\n\t\treturn a[x]<a[y];\n\treturn x<y;\n}\nvector <int> pos[N],v,v2,tl,tr;\nint vis[N];\nint main(){\n\tn=read(),L=read();\n\tFor(i,1,n){\n\t\ta[i]=read();\n\t\tif (a[i]<=n)\n\t\t\tpos[a[i]].pb(i);\n\t}\n\tLL ans=n;\n\tFor(k,1,n){\n//\t\touttag();outval(k);\n\t\tfor (auto i : pos[k]){\n\t\t\trp[i]=i;\n\t\t\tvl[i].pb(1),vr[i].pb(1);\n\t\t\tv.pb(i);\n//\t\t\tprintf(\"new[%d]: pos = [%d..%d]\\n\",i,i,rp[i]);\n//\t\t\toutarr(vl[i],0,(int)vl[i].size()-1);\n//\t\t\toutarr(vr[i],0,(int)vr[i].size()-1);\n\t\t}\n\t\tif (v.empty())\n\t\t\tcontinue;\n\t\tsort(v.begin(),v.end());\n\t\tFor(i,1,(int)v.size()-1)\n\t\t\tassert(v[i]!=v[i-1]);\n\t\tint las=v[0];\n\t\tv2.clear();\n\t\ttl.clear(),tr.clear();\n\t\ttr.pb(0);\n\t\t#define tls (int)tl.size()\n\t\t#define trs (int)tr.size()\n\t\tFor(_,0,(int)v.size()-1){\n\t\t\tint i=v[_];\n\t\t\tFor(j,0,(int)vl[i].size()-1){\n\t\t\t\tans+=(LL)vl[i][j]*tr[max(trs-max(L-(j+1),1),0)];\n\t\t\t\tif (j<(int)vl[i].size()-1)\n\t\t\t\t\ttl.pb(vl[i][j]-vl[i][j+1]);\n\t\t\t\telse\n\t\t\t\t\ttl.pb(vl[i][j]);\n\t\t\t}\n//\t\t\tprintf(\"i = %d, ans = %lld\\n\",i,ans);\n\t\t\tint tmp=tr.back();\n\t\t\tFod(j,(int)vr[i].size()-1,0)\n\t\t\t\ttr.pb(vr[i][j]+tmp);\n\t\t\tif (_==(int)v.size()-1||v[_+1]!=rp[i]+1){\n\t\t\t\trp[las]=rp[i];\n//\t\t\t\toutarr(tl,0,tls-1);\n//\t\t\t\toutarr(tr,0,trs-1);\n\t\t\t\tFod(i,trs-1,1)\n\t\t\t\t\ttr[i]-=tr[i-1];\n\t\t\t\tvl[las]=tl;\n\t\t\t\tvr[las].clear();\n\t\t\t\tFod(i,trs-1,1)\n\t\t\t\t\tvr[las].pb(tr[i]);\n//\t\t\t\toutarr(vl[las],0,(int)vl[las].size()-1);\n//\t\t\t\toutarr(vr[las],0,(int)vr[las].size()-1);\n\t\t\t\tFor(i,0,(int)vl[las].size()-1)\n\t\t\t\t\tvl[las][(i+1)/L]+=vl[las][i],vl[las][i]=0;\n\t\t\t\tvl[las][0]=0;\n\t\t\t\tFor(i,0,(int)vl[las].size()-2)\n\t\t\t\t\tvl[las][i]=vl[las][i+1],vl[las][i+1]=0;\n\t\t\t\twhile (!vl[las].empty()&&!vl[las].back())\n\t\t\t\t\tvl[las].pop_back();\n\t\t\t\tFod(i,(int)vl[las].size()-1,1)\n\t\t\t\t\tvl[las][i-1]+=vl[las][i];\n\t\t\t\tFor(i,0,(int)vr[las].size()-1)\n\t\t\t\t\tvr[las][(i+1)/L]+=vr[las][i],vr[las][i]=0;\n\t\t\t\tvr[las][0]=0;\n\t\t\t\tFor(i,0,(int)vr[las].size()-2)\n\t\t\t\t\tvr[las][i]=vr[las][i+1],vr[las][i+1]=0;\n\t\t\t\twhile (!vr[las].empty()&&!vr[las].back())\n\t\t\t\t\tvr[las].pop_back();\n\t\t\t\tFod(i,(int)vr[las].size()-1,1)\n\t\t\t\t\tvr[las][i-1]+=vr[las][i];\n//\t\t\t\tprintf(\"new[%d]: pos = [%d..%d]\\n\",las,las,rp[las]);\n//\t\t\t\toutarr(vl[las],0,(int)vl[las].size()-1);\n//\t\t\t\toutarr(vr[las],0,(int)vr[las].size()-1);\n\t\t\t\tif (!vl[las].empty())\n\t\t\t\t\tv2.pb(las);\n\t\t\t\tif (_!=(int)v.size()-1){\n\t\t\t\t\tlas=v[_+1];\n\t\t\t\t\ttl.clear(),tr.clear();\n\t\t\t\t\ttr.pb(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv=v2;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Remember...\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int maxn=1e5+10, inf=2e9;\n\nint n,k;\n\nvector< pair<int, pll> >vec;\nvector<pll> vec2, vec3;\n\nll ans;\n\nvoid handle();\n\nll solve(vector<pll> &v){\n    ll ans=0, sm=0;\n    for(auto p:v){\n\tans+= p.F * p.S;\n\tsm+= p.S;\n    }\n    if(sz(v)<k) return ans;\n    \n    for(int i=0;i<k-1;i++){\n\tsm-= v[i].S;\n    }\n    for(int i=0;i<sz(v)-k+1;i++){\n\tans+= v[i].F * sm;\n\tsm-= v[i+k-1].S;\n    }\n    return ans;\n}\nvoid add(int x){\n    while(vec.back().F < x) handle();\n    vec.PB({x,{1,1}});\n}\nvoid handle(){\n    int x=vec.back().F;\n    vec2.clear();\n    while(vec.back().F == x){\n\tvec2.PB(vec.back().S);\n\tvec.pop_back();\n    }\n    reverse(vec2.begin(),vec2.end());\n    ans+= solve(vec2);\n    \n    if(sz(vec2)<k){ add(inf); return; }\n    vec3.resize( sz(vec2)/k );\n\n    for(int i=k;i<=sz(vec2);i+=k){\n\tll sm=0;\n\tfor(int j=i;j<=min(sz(vec2),i+k-1);j++)\n\t    sm+= vec2[j-1].S;\n\tvec3[(i/k)-1].S= sm;\n    }    \n    reverse(vec2.begin(),vec2.end());\n    reverse(vec3.begin(),vec3.end());\n    for(int i=k;i<=sz(vec2);i+=k){\n\tll sm=0;\n\tfor(int j=i;j<=min(sz(vec2),i+k-1);j++)\n\t    sm+= vec2[j-1].F;\n\tvec3[(i/k)-1].F= sm;\n    }\n    reverse(vec3.begin(),vec3.end());\n\n    ans-= solve(vec3);\n\n    for(auto p:vec3){\n\tvec.PB({x+1,p});\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie();\n\n    cin>>n>>k;\n    vec.PB({inf,{1,1}});   \n    while(n--){\n\tint x; cin>>x;\n\tadd(x);\n    }\n    add(inf);    \n    return cout<<ans<<endl,0;\n}\n// Deathly mistakes:\n//  * Read the problem carefully.\n//  * Check maxn.\n//  * Overflows.\n\n\n// #pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nstruct node\n{\n\tint l,r,from,L,R;\n\tnode() {}\n\tnode(int l1,int r1,int from1,int L1,int R1):l(l1),r(r1),from(from1),L(L1),R(R1) {}\n}g[200010];\n\ninline bool operator <(const node &x,const node &y) { return x.l<y.l; }\n\nset<node> st;\nvector<int> v[200010];\n\nint L[200010],R[200010];\nint num[200010],h[200010],n,m,l,tt,tot;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline ll calc(int j,int k)\n{\n\tstatic ll suf[200010];\n\tll res=0;int now=j;\n\tsuf[k+1]=0;\n\tfor (int i=k;i>=j;i--) suf[i]=suf[i+1]+g[i].R;\n\tfor (int i=j;i<=k;i++)\n\t{\n\t\twhile (now<=k&&(g[now].from==g[i].from||now-i+1<l)) now++;\n\t\tif (now<=k) res+=(ll)g[i].L*suf[now];\n\t\telse break;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tn=rd();l=rd();\n\tfor (int i=1;i<=n;i++) num[i]=rd();\n\ttt=0;\n\tfor (int i=1;i<=n;i++) h[++tt]=num[i];\n\tsort(h+1,h+tt+1);\n\ttt=unique(h+1,h+tt+1)-h-1;\n\tfor (int i=1;i<=n;i++) v[lower_bound(h+1,h+tt+1,num[i])-h].push_back(i);\n\ttot=0;\n\tll ans=n;h[tt+1]=INT_MAX;\n\tfor (int i=1;i<=tt;i++)\n\t{\n\t\tfor (int t:v[i]) st.insert(node(t,t,++tot,1,1));\n\t\tfor (int hhh=h[i];hhh<h[i+1]&&!st.empty();hhh++)\n\t\t{\n\t\t\tm=0;\n\t\t\tfor (set<node>::iterator it=st.begin();it!=st.end();it++) g[++m]=*it;\n\t\t\tst.clear();\n\t\t\tfor (int j=1,k;j<=m;j=k+1)\n\t\t\t{\n\t\t\t\tfor (k=j;k<m&&g[k+1].l==g[k].r+1;k++);\n\t\t\t\tif (k-j+1<l) continue;\n\t\t\t\tans+=calc(j,k);\n\t\t\t\tint hh=(k-j+1)/l;\n\t\t\t\tfor (int i=1;i<=hh;i++) L[i]=R[i]=0;\n\t\t\t\tfor (int i=j;i<=k;i++)\n\t\t\t\t{\n\t\t\t\t\tint h1=(i-j+1)/l,h2=(k-i+1)/l;\n\t\t\t\t\tif (h1>0) R[h1]+=g[i].R;\n\t\t\t\t\tif (h2>0) L[hh-h2+1]+=g[i].L;\n\t\t\t\t}\n\t\t\t\ttot++;\n\t\t\t\tfor (int i=1;i<hh;i++) st.insert(node(g[j].l+i-1,g[j].l+i-1,tot,L[i],R[i]));\n\t\t\t\tst.insert(node(g[j].l+hh-1,g[k].r,tot,L[hh],R[hh]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace::std;\n//struct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n__attribute__((constructor))\nvoid init(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(15);\n}\n// random_device rd;\n// mt19937 mt(rd());\n// #include <boost/numeric/interval.hpp>\n// #include <boost/numeric/interval/io.hpp>\n// #include <boost/intrusive/rbtree.hpp>\n// #include <boost/dynamic_bitset.hpp>\n// #include <boost/geometry.hpp>\n// #include <boost/geometry/geometries/linestring.hpp>\n// #include <boost/geometry/geometries/polygon.hpp>\n// #include <boost/geometry/geometries/point_xy.hpp>\n// #include <boost/math/tools/minima.hpp>\n// using boost::math::tools::brent_find_minima;\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<256>> cdouble;\n// typedef mp::cpp_int cint;\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T=long long>using pbds=tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pbds_map=tree<T,T,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pqueue =__gnu_pbds::priority_queue<T, less<T>,rc_binomial_heap_tag>;\ntypedef long long lint;\ntypedef long long ll;\ntypedef long double ldouble;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<double> dvec;\ntypedef vector<vector<double>> dmat;\ntypedef vector<vector<vector<double>>> dmat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntypedef vector<vector<vector<string>>> smat3;\ntypedef vector<pair<lint,lint>> pvec;\ntypedef vector<vector<pair<lint,lint>>> pmat;\ntypedef vector<vector<vector<pair<lint,lint>>>> pmat3;\n#define rep(i, n) for(lint i = 0; i < (lint)(n); i++)\n#define irep(i) for(lint i = 0;; i++)\n#define irep1(i) for(lint i = 1;; i++)\n#define irep2(i) for(lint i = 2;; i++)\n#define rrep(i, n) for(lint i = (lint)(n-1); i >-1; i--)\n#define rrepi(i,a,b) for(lint i = (lint)(b-1); i >a-1; i--)\n#define repi(i,a,b) for(lint i=lint(a);i<lint(b);i++)\n#define rep2(i,a,b,c) for(lint i=lint(a);i>lint(b);i+=c)\n#define all(x) (x).begin(),(x).end()\n#define PI 3.141592653589793\n#define dist(x1,y1,x2,y2) (pow(pow(x2-x1,2)+pow(y2-y1,2),0.5))\n#define output(v) do{bool f=0;for(auto i:v){cout<<(f?\" \":\"\");if(i>INF/2)cout<<\"INF\";else cout<<i;f=1;}cout<<\"\\n\";}while(0);\n#define output2(v) for(auto j:v)output(j);\n#define _output(v) do{bool f=0;rep(i,v.size()){cout<<(f?\" \":\"\");if(v[i]>INF/2)cout<<\"INF\";else cout<<v[i];f=1;}cout<<\"\\n\";}while(0)\n#define _output2(v) rep(j,v.size()){_output(v[j]);}\n#define input(a,n) lint n;cin>>n;vector<lint>a(n);rep(i,n)cin>>a[i];\n#define SUM(v) accumulate(all(v),0LL)\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define LINF 9223372036854775807\n#define MOD 998244353LL\n#define endl \"\\n\"\ntemplate<typename T=lint>T in(){return *istream_iterator<T>(cin);}\ninline lint gcd(lint a,lint b){return b?gcd(b,a%b):a;}\ntemplate<typename T=lint>inline T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<typename T=lint>inline T add(T a,T b){return a+b;}\ntemplate<typename T=lint>inline T minq(T a,T b){return min(a,b);}\ninline bool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\ninline bool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nvector<lint> dx={-1,1,0,0,1,1,-1,-1};\nvector<lint> dy={0,0,-1,1,1,-1,1,-1};\n\n\n\n// template<typename T,typename E>\n// struct RBST{\n// \tstruct node{\n// \t\tint cnt=1,l=-1,r=-1;\n// \t\tT key;E val;\n// \t\tnode(){}\n// \t\tnode(T key,E val):key(key),val(val){}\n// \t};\n// \tvector<node> v;\n// \tRBST(){\n// \t}\n// \tint root=1;\n// \tint count(int idx){return idx==-1?0:v[idx].cnt;}\n// \tint update(int idx){\n// \t\tif(idx!=-1)v[idx].cnt=1+count(v[idx].l)+count(v[idx].r);\n// \t\treturn idx;\n// \t}\n// \tprivate:\n// \tinline int merge(int l,int r){\n//         if(l==-1||r==-1)return l==-1?r:l;\n//         if((unsigned long)count(v[l])>rnd()%(unsigned long)(count(v[l])+count(v[r]))){\n//             v[l].r=merge(v[l].r,r);\n//             return update(l);\n//         }else{\n//             v[r].l=merge(l,v[r].l);\n//             return update(r);\n//         }\n//     }\n// \tinline pair<int,int> split(int t,int k){\n//         if(t==-1)return make_pair(-1,-1);\n//         if(k<=count(v[t].l)){\n//             auto s=split(v[t].l,k);\n//             v[t].l=s.second;\n//             return make_pair(s.first,update(t));\n//         }else{\n//             auto s=split(v[t].r,k-count(v[t].l)-1);\n//             v[t].r=s.first;\n//             return make_pair(update(t),s.second);\n//         }\n//     }\n// \tinline unsigned long rnd() {\n//         static unsigned long x=123456789, y=362436069, z=521288629, w=88675123;\n//         unsigned long t=(x^(x<<11));\n//         x=y; y=z; z=w;\n//         return ( w=(w^(w>>19))^(t^(t>>8)) );\n//     }\n// };\n\n\n\nint main(){\n    lint n,k;\n    cin>>n>>k;\n    string s;\n    cin>>s;\n    set<string>t,next[2];\n    t.insert(s);\n    next[0].insert(s);\n    rep(i,k){\n        next[(i+1)%2].clear();\n        for(string s2:next[i%2]){\n            string u=s2;\n            reverse(all(s2));\n            u+=s2;\n            rep(j,n){\n                auto s3=u.substr(j,n);\n                if(!t.count(s3)){\n                    t.insert(s3);\n                    next[(i+1)%2].insert(s3);\n                }\n            }\n        }\n        if(next[i%2].empty())break;\n    }\n    cout<<*t.begin();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (200010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\n#define int long long\n#define fi first\n#define se second\n#define mkp make_pair\nint n,m,now,a[N]; pair<int,int> pos[N];\nLL ans; vector<pair<pair<int,int>,pair<int,int> > >t,tmp;\nvector<pair<int,int> > wk,pp;\n//当前位置,当前 \nint calc(vector<pair<int,int> > &a){\n\tLL sum=0,ans=0;\n\tfor(int i=0,j=m-1;j<a.size();i++,j++)\n\tsum+=a[i].fi,ans+=sum*a[j].se;\n\treturn ans;\n}\nint main(){\n\tread(n),read(m),ans=n;\n\tfor(int i=1;i<=n;i++)read(a[i]),pos[i]=mkp(a[i],i);\n\tsort(pos+1,pos+n+1);\n\tfor(int p=1,val=0;p<=n||!t.empty();){\n//\t\tcout<<p<<endl;\n\t\tif(t.empty())val=pos[p].fi;else val++;\n\t\tfor(;pos[p].fi==val;p++)t.emplace_back(mkp(pos[p].se,pos[p].se),mkp(1,1));\n\t\ttmp.clear(),sort(t.begin(),t.end());\n//\t\tputs(\"faq\");\n\t\tfor(int i=0,j=0;i<t.size();i=j+1){\n\t\t\tfor(j=i;j+1<t.size()&&t[j+1].fi.fi==t[j].fi.se+1;j++);\n//\t\t\tcout<<t.size()<<\" \"<<i<<\" \"<<j<<endl;\n\t\t\tint len=j-i+1,cnt=len/m;\n\t\t\tif(cnt){\n//\t\t\t\tputs(\"faq2\");\n\t\t\t\twk.clear();\n\t\t\t\tfor(int k=i;k<=j;k++)wk.push_back(t[k].se);\n\t\t\t\tans+=calc(wk),wk.clear(),wk.resize(cnt),pp.clear();\n\t\t\t\tfor(int k=1;k<=cnt;k++)\n\t\t\t\tpp.emplace_back(t[i].fi.fi+k-1,(k==cnt)?t[j].fi.se:t[i].fi.fi+k-1);\n\t\t\t\tfor(int k=i;k<=j;k++){\n\t\t\t\t\tint l=k-i+1,r=j-k+1;\n\t\t\t\t\tif(l>=m)wk[l/m-1].se+=t[k].se.se;\n\t\t\t\t\tif(r>=m)wk[cnt-r/m].fi+=t[k].se.fi;\n\t\t\t\t}\n//\t\t\t\tputs(\"faq3\");\n//\t\t\t\tcout<<cnt<<\" faq \"<<wk.size()<<\" \"<<val<<endl;\n\t\t\t\tans-=calc(wk);\n\t\t\t\tfor(int k=0;k<pp.size();k++)tmp.emplace_back(pp[k],wk[k]);\n//\t\t\t\tcout<<tmp[k].fi.fi<<\" \"<<tmp[k].fi.se<<\" \"<<tmp[k].se.fi<<\" \"<<tmp[k].se.se<<endl;\n\t\t\t}\n\t\t}\n\t\tt=tmp;\n//\t\tcout<<t.size()<<\" faq4\\n\";\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=200005;\nint k,A[N],lx[N],rx[N],a[N],nxt[N],pre[N];\nll ycl[N];\npriority_queue<PI,vector<PI>,greater<PI> > q;\nll solve(int l,int r){\n\tr=nxt[r];\n\tint dq=l;\n\tll ans=0;\n\tint sum=0;\n\tFor(i,1,k-1){dq=nxt[dq]; ans++; if(dq==r)return ans;}\n\twhile(dq!=r){\n\t\tsum+=lx[l]; l=nxt[l]; \n\t\tans+=(ll)sum*rx[dq]+1;\n\t\tdq=nxt[dq];\n\t}\n\treturn ans;\n}\nint main(){\n\tint n=read(); k=read();\n\tFor(i,k,n)ycl[i]=ycl[i-1]+(i-k+1);\n\tFor(i,1,n){\n\t\ta[i]=read(); lx[i]=1; rx[i]=1;\n\t}\n\tnxt[0]=1; pre[n+1]=n;\n\tFor(i,1,n){pre[i]=i-1; nxt[i]=i+1; q.push(mp(a[i],i)); }\n\t//For(i,1,n)wri(ycl[i]); puts(\"\");\n\tll ans=0;\n\twhile(q.size()){\n\t\tPI t=q.top();  q.pop();\n\t\tint l=t.se,r=l,cnt=1;\n\t\twhile(a[nxt[r]]==a[l]){r=nxt[r]; cnt++; q.pop(); } \n\t\t//cout<<q.size()<<\" \"<<cnt<<\" \"<<t.fi<<\" \"<<t.se<<\" \"<<l<<\" \"<<r<<\" \"<<\" \"<<ycl[cnt]<<endl;\n\t\tl=pre[l]; r=nxt[r];\n\t\tans+=solve(nxt[l],pre[r]);\n\t\tif(cnt<k)continue;\n\t\tint zs=cnt,jb=l;\n\t\tzs-=k; For(i,1,k)jb=nxt[jb];\n\t\tFor(i,1,cnt/k){\n\t\t\tint meiju=min(k,zs+1);\n\t\t\trx[l+i]=0; For(j,1,meiju){rx[l+i]+=rx[jb]; jb=nxt[jb];} zs-=k;\n\t\t}\n\t\tzs=cnt-k; jb=r; For(i,1,k)jb=pre[jb];\n\t\tRep(i,cnt/k,1){\n\t\t\tint meiju=min(k,zs+1);\n\t\t\tA[i]=0; For(j,1,meiju){A[i]+=lx[jb]; jb=pre[jb];} zs-=k;\n\t\t}\n\t\tFor(i,1,cnt/k)lx[l+i]=A[i];\n\t\tFor(i,1,cnt/k){nxt[l+i]=l+i+1; pre[l+i]=l+i-1; a[l+i]=t.fi+1; q.push(mp(a[l+i],l+i));}\n\t\tnxt[l]=l+1; pre[r]=l+cnt/k; nxt[l+cnt/k]=r;\n\t\t//cout<<ans<<endl;\n\t\tans-=solve(nxt[l],pre[r]);\n\t\t//For(i,1,cnt/k)wri(lx[l+i]); puts(\"\");\n\t\t//cout<<ans<<\" \"<<nxt[jb]<<\" \"<<pre[r]<<endl;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define st first\n#define nd second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<long long>;\nusing ld = long double;\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int kMaxN = 2e5 + 100;\n\nint n, L;\nint vals[kMaxN];\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> n >> L;\n  for (int i = 0; i < n; ++i) {\n    cin >> vals[i];\n  }\n\n  struct Number {\n    int num;\n    int lends, rends;\n  };\n\n  map<int, Number> nums;\n  for (int i = 0; i < n; ++i) {\n    nums[i] = Number{vals[i], 1, 1};\n  }\n\n  vi order(n);\n  iota(ALL(order), 0);\n  sort(ALL(order), [&](int lhs, int rhs) {\n        return MP(vals[lhs], lhs) < MP(vals[rhs], rhs);\n      });\n\n  ll ans = n;\n  vector<bool> visited(n);\n\n  for (int loc : order) {\n    if (visited[loc]) { continue; }\n    debug(loc);\n    auto iter = nums.find(loc);\n    assert(iter != nums.end());\n    assert(iter->nd.lends == 1 && iter->nd.rends == 1);\n    \n    vi other_locs;\n    auto piter = iter, niter = iter;\n    while (piter != nums.begin() && prev(piter)->nd.num == vals[loc]) { --piter; }\n    while (niter != nums.end() && niter->nd.num == vals[loc]) { ++niter; }\n\n    for (auto it = piter; it != niter; ++it) {\n      other_locs.PB(it->st);\n    }\n\n    const int S = SZ(other_locs);\n\n    if (S >= L) {\n      int rgt = 0;\n      int ways_rgt = 0;\n      int num_good = !visited[other_locs[0]];\n      for (int v : other_locs) { ways_rgt += nums[v].rends; }\n\n      for (int lft = 0; lft + L <= S; ++lft) {\n        while (rgt < S && (rgt-lft < L-1 || !num_good)) {\n          const int v = other_locs[rgt];\n          ways_rgt -= nums[v].rends;\n          ++rgt;\n          if (rgt < S) { num_good += !visited[other_locs[rgt]]; }\n        }\n\n        const int ways_lft = nums[other_locs[lft]].lends ;\n        debug(lft, rgt, ways_rgt);\n\n        ans += (ll)ways_lft * ways_rgt;\n        num_good -= !visited[other_locs[lft]];\n      }\n    }\n\n    for (int v : other_locs) {\n      visited[v] = true;\n    }\n\n    vi lends(S), rends(S);\n    for (int i = 0; i < S; ++i) {\n      lends[i] = nums[other_locs[i]].lends;\n      rends[i] = nums[other_locs[i]].rends;\n    }\n\n    for (int v : other_locs) { nums.erase(v); }\n    const int num_add = S / L;\n    vector<Number> xs(num_add);\n    for (int idx_add = 0; idx_add < num_add; ++idx_add) {\n      xs[idx_add].num = vals[loc] + 1;\n\n      const int lft = (idx_add + 1) * L - 1;\n      const int rgt = min(S, (idx_add + 2) * L - 1);\n      for (int i = lft; i < rgt; ++i) {\n        xs[idx_add].rends += rends[i];\n        xs[num_add - idx_add - 1].lends += lends[S - i - 1];\n      }\n    }\n\n    for (int idx_add = 0; idx_add < num_add; ++idx_add) {\n      debug(idx_add, xs[idx_add].num, xs[idx_add].lends, xs[idx_add].rends);\n      nums.emplace(other_locs[0] + idx_add, xs[idx_add]);\n    }\n\n    if (num_add == 0) {\n      Number dummy{-1, 0, 0};\n      nums[other_locs[0]] = dummy;\n    }\n  }\n\n  cout << ans << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define pii pair<int,int>\n#define riterator reverse_iterator\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 2e5;\npriority_queue<pii,vector<pii>,greater<pii> > que;\nint nxt[N+3],prv[N+3];\nint a[N+3];\nllong cl[N+3],cr[N+3],cl2[N+3],cr2[N+3];\nvector<int> vec;\nint n,m; llong ans;\n\nvoid solve(int l,int r)\n{\n//\tprintf(\"solve %d %d\\n\",l,r);\n\tllong sum = 0ll;\n\tfor(int i=m-1; i<vec.size(); i++)\n\t{\n\t\tsum += cl[vec[i-m+1]];\n\t\tans += cr[vec[i]]*sum;\n\t}\n\tint cnt = vec.size()/m;\n\tfor(int i=l; i<=l+cnt-1; i++) cl2[i] = cr2[i] = 0ll;\n\tfor(int i=vec.size()-m,j=0,k=l+cnt-1; i>=0; i--)\n\t{\n\t\tcl2[k] += cl[vec[i]];\n\t\tif(j==m-1) {k--,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=m-1,j=0,k=l; i<vec.size(); i++)\n\t{\n\t\tcr2[k] += cr[vec[i]];\n\t\tif(j==m-1) {k++,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=l; i<=l+cnt-1; i++) cl[i] = cl2[i],cr[i] = cr2[i];\n\tsum = 0ll;\n\tfor(int i=l+m-1; i<=l+cnt-1; i++)\n\t{\n\t\tsum += cl[i-m+1];\n\t\tans -= cr[i]*sum;\n\t}\n\tif(cnt==0)\n\t{\n\t\tnxt[prv[l]] = nxt[r]; prv[nxt[r]] = prv[l];\n\t}\n\telse\n\t{\n\t\tnxt[l+cnt-1] = nxt[r]; prv[nxt[r]] = l+cnt-1;\n\t\tfor(int i=l; i<l+cnt-1; i++) nxt[i] = i+1;\n\t\tfor(int i=l+1; i<=l+cnt-1; i++) prv[i] = i-1;\n\t\tint val = a[l]; for(int i=l; i<=l+cnt-1; i++) a[i] = val+1;\n\t\tfor(int i=l; i<=l+cnt-1; i++) que.push(mkpr(a[i],i));\n\t}\n//\tprintf(\"cnt=%d\\n\",cnt);\n//\tprintf(\"prv: \"); for(int i=1; i<=n+1; i++) printf(\"[%d]%d \",i,prv[i]); puts(\"\");\n//\tprintf(\"nxt: \"); for(int i=0; i<=n; i++) printf(\"[%d]%d \",i,nxt[i]); puts(\"\");\n//\tprintf(\"cl: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cl[i]); puts(\"\");\n//\tprintf(\"cr: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cr[i]); puts(\"\");\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&a[i]),que.push(mkpr(a[i],i)),cl[i] = cr[i] = 1ll,nxt[i] = i+1,prv[i] = i-1;\n\tnxt[0] = 1,prv[n+1] = n;\n\twhile(1)\n\t{\n\t\tint l = que.top().second,r = l; que.pop(); vec.clear(); vec.push_back(l);\n\t\twhile(!que.empty() && que.top().first==a[l] && que.top().second==nxt[r]) {r = nxt[r]; vec.push_back(r); que.pop();}\n\t\tsolve(l,r);\n\t\tif(nxt[0]==n+1) break;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\n\nconst int maxn=200111;\nint n,l,a[maxn],f[maxn],lv[maxn],rv[maxn];\nLL ans;\nint gf(int x){return x==f[x]?x:f[x]=gf(f[x]);}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\t\n\tset<pii> st;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",a+i);\n\t\tst.insert(mp(a[i],i));\n\t\tf[i]=i;lv[i]=rv[i]=1;\n\t}\n\tf[n+1]=n+1;\n\twhile(st.size())\n\t{\n\t\tint mn=st.begin()->ff,cur=st.begin()->ss,sum;\n\t\tvector<int> vs;\n\t\twhile(cur<=n&&a[cur]==mn)\n\t\t{\n\t\t\tst.erase(mp(mn,cur));\n\t\t\tvs.pb(cur);\n\t\t\tcur=gf(cur+1);\n\t\t}\n\t\t\n\t\tif((int)vs.size()<l)continue;\n\t\tcur=0;sum=0;\n\t\tfor(int i=0;i<(int)vs.size();i++)\n\t\t{\n\t\t\twhile(cur<(int)vs.size()&&i-cur+1>=l)sum+=lv[vs[cur++]];\n\t\t\tans+=(LL)sum*rv[vs[i]];\n\t\t}\n\t\tint sz=(int)vs.size()/l;\n\t\tvector<int> nl,nr;\n\t\tfor(int i=1;i<=sz;i++)\n\t\t{\n\t\t\tint lb=i*l-1,rb=min((i+1)*l-1,(int)vs.size()),s=0;\n\t\t\tfor(int j=lb;j<rb;j++)s+=rv[vs[j]];\n\t\t\tnr.pb(s);\n\t\t}\n\t\treverse(vs.begin(),vs.end());\n\t\tfor(int i=1;i<=sz;i++)\n\t\t{\n\t\t\tint lb=i*l-1,rb=min((i+1)*l-1,(int)vs.size()),s=0;\n\t\t\tfor(int j=lb;j<rb;j++)s+=lv[vs[j]];\n\t\t\tnl.pb(s);\n\t\t}\n\t\treverse(nl.begin(),nl.end());\n\t\treverse(vs.begin(),vs.end());\n\t\t\n\t\tfor(int i=0;i<sz;i++)\n\t\t{\n\t\t\tlv[vs[i]]=nl[i];\n\t\t\trv[vs[i]]=nr[i];\n\t\t}\n\t\tfor(int i=sz;i<(int)vs.size();i++)f[vs[i]]=vs[i]+1;\n\t\tvs.resize(sz);\n\t\t\n\t\tcur=0;sum=0;\n\t\tfor(int i=0;i<(int)vs.size();i++)\n\t\t{\n\t\t\twhile(cur<(int)vs.size()&&i-cur+1>=l)sum+=lv[vs[cur++]];\n\t\t\tans-=(LL)sum*rv[vs[i]];\n\t\t}\n\t\tfor(int i=0;i<(int)vs.size();i++)\n\t\t{\n\t\t\ta[vs[i]]++;\n\t\t\tst.insert(mp(a[vs[i]],vs[i]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define N 200127\n#define INF 0x3f3f3f3f\nint n,m,a[N],mi=INF,L[N],R[N],vl[N],vr[N],v1[N],v2[N];\nstruct Point{\n\tint x,v;\n\tinline bool operator<(const Point &b)const{return (v>b.v)||((v==b.v)&&(x>b.x));}\n};\npriority_queue<Point>q;\nint b[N],cn=0;long long ans=0;\nint main(){\n\tscanf(\"%d%d\",&n,&m);ans=n;int i,j,k,v,l,r,p,sum;for(i=1;i<=n;i++)scanf(\"%d\",&a[i]),L[i]=i-1,R[i]=i+1,vl[i]=vr[i]=1,q.push((Point){i,a[i]});\n\twhile(!q.empty())\n\t{\n\t\tcn=0;v=q.top().v;while((!q.empty())&&(v==q.top().v))b[++cn]=q.top().x,q.pop();\n\t\tfor(i=1;i<=cn;i=r+1)\n\t\t{\n\t\t\tl=r=i;while((r<cn)&&(R[b[r]]==b[r+1]))++r;\n\t\t\tsum=0;for(i=l;i<=r;i++){if(i-m+1>=l)sum+=vl[b[i-m+1]];ans+=1ll*sum*vr[b[i]];}\n\t\t\tif(r-l+1<m){R[L[b[l]]]=n+1;L[R[b[r]]]=0;continue;}p=(r-l+1)/m;\n\t\t\tfor(i=l;i<=r;i++)k=b[i],v1[k]=vl[k],v2[k]=vr[k],vl[k]=vr[k]=0;\n\t\t\tfor(i=r-m+1,k=p;i>=l;i-=m,--k)for(j=i;(j>=l)&&(j>=i-m+1);j--)vl[b[l+k-1]]+=v1[b[j]];\n\t\t\tfor(i=l+m-1,k=1;i<=r;i+=m,++k)for(j=i;(j<=r)&&(j<=i+m-1);j++)vr[b[l+k-1]]+=v2[b[j]];\n\t\t\tfor(i=l;i<=l+p-1;i++)++a[b[i]],q.push((Point){b[i],a[b[i]]});L[R[b[r]]]=b[l]+p-1;R[b[l]+p-1]=R[b[r]];\n\t\t\tsum=0;for(i=l;i<=l+p-1;i++){if(i-m+1>=l)sum+=vl[b[i]-m+1];ans-=1ll*sum*vr[b[i]];}\n\t\t}\n\t}printf(\"%lld\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define ll long long\nusing namespace std;\nint n,k,tot,pre[400005],nxt[400005],a[400005],l[400005],r[400005],sl[400005],sr[400005];\nll ans;\nbool flag[400005];\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\ttot=n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tpre[i]=i-1,nxt[i]=i+1;\n\t\tq.push(make_pair(a[i],i));\n\t\tl[i]=r[i]=1;\n\t}\n\tnxt[n]=0;\n\twhile(!q.empty())\n\t{\n\t\tint node=q.top().second;\n\t\tq.pop();\n\t\tif(flag[node])continue;\n\t\tint L=node,R=node,len=1;\n\t\twhile(a[pre[L]]==a[node])L=pre[L],len++;\n\t\twhile(a[nxt[R]]==a[node])R=nxt[R],len++;\n//\t\tprintf(\"solve(%d,%d,%d)\\n\",node,a[node],len);\n//\t\tprintf(\"L=%d,R=%d\\n\",L,R);\n\t\tint last=0;\n\t\tfor(int i=L,j=1;i!=nxt[R];i=nxt[i],j++)\n\t\t{\n\t\t\tsl[j]=sl[j-1]+l[i];\n\t\t\tsr[j]=sr[j-1]+r[i];\n\t\t\tif(i<=n)last=i;\n\t\t\tif(last&&j>=k)ans+=1ll*sl[min(j-k+1,last)]*r[i];\n\t\t\tflag[i]=1;\n\t\t}\n\t\tif(len<k)\n\t\t{\n\t\t\tnxt[pre[L]]=pre[nxt[R]]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<=len/k;i++)\n\t\t{\n\t\t\tr[tot+i]=sr[min(len,(i+1)*k-1)]-sr[i*k-1];\n\t\t\tl[tot+i]=sl[len-(len/k-i+1)*k+1]-sl[max(0,len-(len/k-i+2)*k+1)];\n\t\t}\n\t\tnxt[pre[L]]=tot+1,pre[tot+1]=pre[L];\n\t\tpre[nxt[R]]=tot+len/k,nxt[tot+len/k]=nxt[R];\n\t\tfor(int i=1;i<len/k;i++)\n\t\t{\n\t\t\tnxt[tot+i]=tot+i+1;\n\t\t\tpre[tot+i+1]=tot+i;\n\t\t}\n\t\tfor(int i=1;i<=len/k;i++)a[tot+i]=a[L]+1;\n\t\tq.push(make_pair(a[tot+1],tot+1));\n\t\ttot+=len/k;\n//\t\tprintf(\"ans=%lld\\n\",ans);\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 2.1e5;\nint N, L;\nint A[MAXN];\n\nconst int S = 1 << 18;\nint seg[2 * S];\nunordered_map<int, vector<int>> vals;\n\nvoid precomp() {\n\tmemset(seg, -1, sizeof(seg));\n\tfor (int i = 0; i < N; i++) {\n\t\tseg[S + i] = A[i];\n\t\tvals[A[i]].push_back(i);\n\t}\n\tfor (int i = S-1; i > 0; i--) {\n\t\tseg[i] = max(seg[2 * i], seg[2 * i + 1]);\n\t}\n}\n\nint query_max(int a, int b) {\n\tint res = -1;\n\tfor (int l = a+S, r = b+S; l < r; l /= 2, r /= 2) {\n\t\tif (l & 1) {\n\t\t\tres = max(res, seg[l]);\n\t\t\t++l;\n\t\t}\n\t\tif (r & 1) {\n\t\t\t--r;\n\t\t\tres = max(res, seg[r]);\n\t\t}\n\t}\n\treturn res;\n}\n\nll ans = 0;\n\nstruct rangeData {\n\tint k = -1;\n\tint wholeValue = -1;\n\tvector<int> lPts = vector<int>({1}); // number of pts of each size\n\tvector<int> rPts = vector<int>({1}); // number of pts of each size\n};\n\nvector<int> upCast(vector<int> v) {\n\tassert(!v.empty());\n\tassert(v[0] == 1);\n\tvector<int> res((v.size() - 1) / L + 1);\n\tres[0] = v[0];\n\tfor (int i = L; i < int(v.size()); i++) {\n\t\tres[i / L] += v[i];\n\t}\n\treturn res;\n}\n\nrangeData upCast(rangeData r, int v) {\n\tassert(r.k < v);\n\twhile (r.k < v) {\n\t\tif (r.lPts.size() == 1 && r.rPts.size() == 1) {\n\t\t\tassert(r.wholeValue == 0 || r.wholeValue == -1);\n\t\t\t// no more shrinking is possible;\n\t\t\tr.k = v;\n\t\t\tbreak;\n\t\t}\n\t\tassert(r.wholeValue != 0);\n\t\tif (r.wholeValue >= L) {\n\t\t\tr.wholeValue /= L;\n\t\t} else {\n\t\t\tr.wholeValue = -1;\n\t\t}\n\t\tr.lPts = upCast(std::move(r.lPts));\n\t\tr.rPts = upCast(std::move(r.rPts));\n\t\tr.k ++;\n\t}\n\treturn r;\n}\n\nint EPOCH = 1;\n\nint numLeft[MAXN * 2];\nint lastUpdated[MAXN * 2];\n\nint getNumLeft(int i) {\n\tif (lastUpdated[i] < EPOCH) {\n\t\tnumLeft[i] = 0;\n\t\tlastUpdated[i] = EPOCH;\n\t}\n\treturn numLeft[i];\n}\nvoid setNumLeft(int i, int v) {\n\tnumLeft[i] = v;\n\tlastUpdated[i] = EPOCH;\n}\n\nrangeData dfs(int l, int r) {\n\tif (l == r) {\n\t\t// wholeValue = 0 means it's empty\n\t\treturn rangeData {-1, 0, vector<int>({1}), vector<int>({1})};\n\t}\n\n\tassert(l < r);\n\tint k = query_max(l, r);\n\tvector<int> locs;\n\tlocs.push_back(l-1);\n\t{\n\t\tconst vector<int>& v = vals[k];\n\t\tlocs.insert(locs.end(), lower_bound(v.begin(), v.end(), l), lower_bound(v.begin(), v.end(), r));\n\t}\n\tlocs.push_back(r);\n\tint M = int(locs.size()) - 1;\n\tvector<rangeData> ranges;\n\tfor (int i = 0; i < M; i++) {\n\t\tranges.emplace_back(upCast(dfs(locs[i]+1, locs[i+1]), k));\n\t}\n\n\tint offset = L+1;\n\tEPOCH ++;\n\tfor (int i = 0; i < M; i++) {\n\t\tconst rangeData& d = ranges[i];\n\t\tassert(d.k == k);\n\t\tfor (int z = 0; z < int(d.lPts.size()); z++) {\n\t\t\t//cerr << z << ' ' << d.lPts[z] << ' ' << getNumLeft(offset - (L - min(z+1, L))) << '\\n';\n\t\t\tans += 1ll * d.lPts[z] * getNumLeft(offset - (L-min(z+1, L)));\n\t\t}\n\t\tif (d.wholeValue == -1) {\n\t\t\toffset = L+1;\n\t\t\tEPOCH++;\n\t\t}\n\t\tfor (int z = int(d.rPts.size()) - 1; z >= 0; z--) {\n\t\t\toffset++;\n\t\t\tsetNumLeft(offset, getNumLeft(offset-1) + d.rPts[z]);\n\t\t}\n\t}\n\n\trangeData res{k, M-1, vector<int>({}), vector<int>({})};\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ranges[i].wholeValue == -1) {\n\t\t\tres.wholeValue = -1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tres.wholeValue += ranges[i].wholeValue;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tconst rangeData& d = ranges[i];\n\t\tres.lPts.insert(res.lPts.end(), d.lPts.begin(), d.lPts.end());\n\t\tif (d.wholeValue == -1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = M-1; i >= 0; i--) {\n\t\tconst rangeData& d = ranges[i];\n\t\tres.rPts.insert(res.rPts.end(), d.rPts.begin(), d.rPts.end());\n\t\tif (d.wholeValue == -1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\tcerr << \"return \" << l << ' ' << r << '\\n';\n\tcerr << res.k << ' ' << res.wholeValue << '\\n';\n\tfor (auto c : res.lPts) { cerr << c << ' '; } cerr << '\\n';\n\tfor (auto c : res.rPts) { cerr << c << ' '; } cerr << '\\n';\n\tfor (int i = 0; i < M; i++) {\n\t\tcerr << \"range\" << '\\n';\n\t\tcerr << ranges[i].k << ' ' << ranges[i].wholeValue << '\\n';\n\t\tfor (auto c : ranges[i].lPts) { cerr << c << ' '; } cerr << '\\n';\n\t\tfor (auto c : ranges[i].rPts) { cerr << c << ' '; } cerr << '\\n';\n\t}\n\t*/\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> L;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t}\n\tprecomp();\n\tdfs(0, N);\n\tans += N;\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 12/11/2019, 4:20:39 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/optional.hpp> // for C++14\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\nconstexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nstruct Element\n{\n  ll left, right;\n  boost::optional<int> value; // for C++14\n};\n\nclass Solve\n{\n  int N, L;\n  vector<Element> A;\n\npublic:\n  Solve(int N, int L, vector<int> input) : N{N}, L{L}, A(N)\n  {\n    for (auto i = 0; i < N; i++)\n    {\n      A[i].value = input[i];\n      A[i].left = 1;\n      A[i].right = 1;\n    }\n  }\n\n  ll count()\n  {\n    ll ans{N};\n    while (true)\n    {\n      auto M{min_value()};\n      if (!M)\n      {\n        break;\n      }\n      vector<Element> T;\n      vector<Element> tmp;\n      for (auto const &e : A)\n      {\n        if (e.value == M)\n        {\n          tmp.push_back(e);\n        }\n        else if (!tmp.empty())\n        {\n          update(ans, T, tmp);\n          T.push_back(e);\n        }\n        else\n        {\n          T.push_back(e);\n        }\n      }\n      if (!tmp.empty())\n      {\n        update(ans, T, tmp);\n      }\n      swap(A, T);\n    }\n    return ans;\n  }\n\nprivate:\n  boost::optional<int> min_value()\n  {\n    boost::optional<int> ans;\n    for (auto const &e : A)\n    {\n      if (e.value)\n      {\n        if (ans)\n        {\n          ch_min(*ans, *e.value);\n        }\n        else\n        {\n          ans = e.value;\n        }\n      }\n    }\n    return ans;\n  }\n\n  void update(ll &ans, vector<Element> &T, vector<Element> &tmp)\n  {\n    ans += calc(tmp);\n    tmp = press(tmp);\n    ans -= calc(tmp);\n    copy(tmp.begin(), tmp.end(), back_inserter(T));\n    tmp.clear();\n  }\n\n  ll calc(vector<Element> const &X)\n  {\n    ll ans{0};\n    ll sum_right{0};\n    int S{static_cast<int>(X.size())};\n    for (auto i = L - 1; i < S; i++)\n    {\n      sum_right += X[i].right;\n    }\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans += X[i].left * sum_right;\n      sum_right -= X[i + L - 1].right;\n    }\n    assert(sum_right == 0);\n    return ans;\n  }\n\n  vector<Element> press(vector<Element> const &V)\n  {\n    int S{static_cast<int>(V.size())};\n    if (S < L)\n    {\n      return {{0, 0, boost::none}};\n    }\n    int K{*V[0].value + 1};\n    vector<Element> ans(S / L);\n    for (auto &e : ans)\n    {\n      e.value = K;\n    }\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].right += V[i].right;\n    }\n    int mod{S % L};\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans[(i + L - mod - 1) / L].left += V[i].left;\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  int N, L;\n  cin >> N >> L;\n  vector<int> A(N);\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> A[i];\n  }\n  Solve solve(N, L, A);\n  cout << solve.count() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>V;\ntypedef long long ll;\nconst int N=2e5+5;\nlong long ans;\nint n,L,a[N],i,j,x,aa[N];\nint g[N];\nV lv[N],rv[N];int mx[N];\nint gfa(int x){return g[x]==x?x:g[x]=gfa(g[x]);}\ninline bool cmp(int x,int y){return a[x]==a[y]?x<y:a[x]<a[y];}\nlong long mi;\nstruct atom{\n\tV l,r;int mx;bool full;\n\tinline void set(const atom&a,int mx2){\n\t\tll z=1;int zz=max(a.l.empty()?0:a.l.back(),a.r.empty()?0:a.r[0]);\n\t\tfull=0;l.clear();r.clear();\n\t\tfor(mx=a.mx;mx<mx2 && z<=zz;z*=L,++mx);\n\t\tif(zz<z){mx=mx2;return;}\n\t\tfull=a.full;\n\t\tfor(int x:a.l)if(x>=z)l.push_back(x/z);\n\t\tfor(int x:a.r)if(x>=z)r.push_back(x/z);\n\t}\n}b[N],v[N];int xb;\nint w,l,s,st[N];bool bb[N];\ninline void uni(atom&zz){\n\tw=s=0;l=1;\n\tzz.full=1;zz.mx=b[1].mx;\n\tfor(int i=1;i<=xb;++i){\n\t\tzz.full&=b[i].full;\n\t\tfor(int x:b[i].l){\n\t\t\tfor(;l<=w && st[l]+s+x>=L;++l)if(l<w && bb[l+1])s-=st[l+1];\n\t\t\tans+=l-1;\n\t\t}\n\t\tif(!b[i].full)w=s=0,l=1;\n\t\tif(!b[i].r.empty()){\n\t\t\tif(l<=w)s+=b[i].r[0];int ow=w;\n\t\t\tfor(int x:b[i].r)st[++w]=x,bb[w]=0;bb[ow+1]=1;\n\t\t}\n\t}\n\tzz.r.resize(w);s=0;for(int i=w;i;--i)zz.r[i-1]=st[i]+s,s+=bb[i]?st[i]:0;\n\tw=0;\n\tfor(int i=xb;i;--i){\n\t\tif(!b[i].full)w=0;\n\t\tif(!b[i].l.empty()){\n\t\t\tint ow=w;reverse(b[i].l.begin(),b[i].l.end());\n\t\t\tfor(int x:b[i].l)st[++w]=x,bb[w]=0;bb[ow+1]=1;\n\t\t}\n\t}\n\tzz.l.resize(w);s=0;for(int i=w;i;--i)zz.l[w-i]=st[i]+s,s+=bb[i]?st[i]:0;\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>L;for(i=1;i<=n;++i)cin>>a[i],aa[i]=i,g[i]=i,v[i].l=v[i].r={1},v[i].mx=a[i],v[i].full=1;\n\tstd::sort(aa+1,aa+n+1,cmp);\n\tfor(i=1;i<=n;i=j){\n\t\txb=0;\n\t\tif(aa[i]>1 && a[aa[i]-1]<a[aa[i]])b[++xb].set(v[aa[i]-1],a[aa[i]]),g[aa[i]-1]=aa[i];\n\t\tfor(j=i+1,b[++xb]=v[aa[i]];j<=n && a[aa[j]]==a[aa[i]] && gfa(aa[j-1]+1)>=aa[j]-1\n\t\t\t && a[aa[j-1]+1]<=a[aa[i]];++j){\n\t\t\tif(aa[j-1]+1<aa[j])b[++xb].set(v[aa[j]-1],a[aa[i]]),g[aa[j]-1]=aa[j];\n\t\t\tb[++xb]=v[aa[j]];g[aa[j-1]]=aa[j-1]+1;\n\t\t}\n\t\tif(aa[j-1]<n && a[aa[j-1]]>a[aa[j-1]+1])b[++xb].set(v[gfa(aa[j-1]+1)],a[aa[i]]),g[aa[j-1]]=aa[j-1]+1;\n\t\tuni(v[gfa(aa[i])]);\n\t}\n\tcout<<ans+n<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 12/11/2019, 4:20:39 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/optional.hpp> // for C++14\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\nconstexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nstruct Element\n{\n  ll left, right;\n  boost::optional<int> value; // for C++14\n};\n\nclass Solve\n{\n  int N, L;\n  vector<Element> A;\n\npublic:\n  Solve(int N, int L, vector<int> input) : N{N}, L{L}, A(N)\n  {\n    for (auto i = 0; i < N; i++)\n    {\n      A[i].value = input[i];\n      A[i].left = 1;\n      A[i].right = 1;\n    }\n  }\n\n  ll count()\n  {\n    ll ans{N};\n    while (true)\n    {\n      auto M{min_value()};\n      if (!M)\n      {\n        break;\n      }\n      vector<Element> T;\n      vector<Element> tmp;\n      for (auto const &e : A)\n      {\n        if (e.value == M)\n        {\n          tmp.push_back(e);\n        }\n        else if (!tmp.empty())\n        {\n          update(ans, T, tmp);\n          T.push_back(e);\n        }\n        else\n        {\n          T.push_back(e);\n        }\n      }\n      if (!tmp.empty())\n      {\n        update(ans, T, tmp);\n      }\n      swap(A, T);\n    }\n    return ans;\n  }\n\nprivate:\n  boost::optional<int> min_value()\n  {\n    boost::optional<int> ans;\n    for (auto const &e : A)\n    {\n      if (e.value)\n      {\n        if (ans)\n        {\n          ch_min(*ans, *e.value);\n        }\n        else\n        {\n          ans = e.value;\n        }\n      }\n    }\n    return ans;\n  }\n\n  void update(ll &ans, vector<Element> &T, vector<Element> &tmp)\n  {\n    ans += calc(tmp);\n    tmp = press(tmp);\n    ans -= calc(tmp);\n    copy(tmp.begin(), tmp.end(), back_inserter(T));\n    tmp.clear();\n  }\n\n  ll calc(vector<Element> const &X)\n  {\n    ll ans{0};\n    ll sum_right{0};\n    int S{static_cast<int>(X.size())};\n    for (auto i = L - 1; i < S; i++)\n    {\n      sum_right += X[i].right;\n    }\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans += X[i].left * sum_right;\n      sum_right -= X[i + L - 1].right;\n    }\n    assert(sum_right == 0);\n    return ans;\n  }\n\n  vector<Element> press(vector<Element> &V)\n  {\n    int S{static_cast<int>(V.size())};\n    if (S < L)\n    {\n      return {{0, 0, boost::none}};\n    }\n    int K{*V[0].value + 1};\n    vector<Element> ans(S / L);\n    for (auto &e : ans)\n    {\n      e.value = K;\n    }\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].right += V[i].right;\n    }\n    int mod{S % L};\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans[(i + L - mod - 1) / L].left += V[i].left;\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  int N, L;\n  cin >> N >> L;\n  vector<int> A(N);\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> A[i];\n  }\n  Solve solve(N, L, A);\n  cout << solve.count() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n  if(abs(a) < eps && abs(b) < eps) return 0;\n  else if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n  if(a < b) return -1;\n  return 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n  if(a < b) return -1;\n  if(a == b) return 0;\n  return 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n  if(na == 0) return 0;\n  int be = 0, en = na - 1;\n  if(*a <= *(a + na - 1)){\n    if(f_lb == 0) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != 1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != -1) en = mid;\n      else be = mid + 1;\n    }\n    if(f_small && jud(*(a + be), val) == 1) be--;\n    if(!f_small && jud(*(a + be), val) == -1) be++;\n  } else {\n    if(f_lb) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != -1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != 1) en = mid;\n      else be = mid + 1;\n    }\n    if(!f_small && jud(*(a + be), val) == -1) be--;\n    if(f_small && jud(*(a + be), val) == 1) be++;\n  }\n  return be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n  if(m < 0) return 0;\n  long long ans = 1;\n  long long k = n;\n  while(m){\n    if(m & 1) {\n      ans *= k;\n      if(mod) ans %= mod;\n    }\n    k *= k;\n    if(mod) k %= mod;\n    m >>= 1;\n  }\n  return ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n  if(mod == -1) mod = MOD;\n  a += b;\n  while(a >= mod) a -= mod;\n  while(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    cerr << arr[i] << ' ';\n  cerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    output1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 200100;\nint n, l;\nint orig[maxn];\nstruct Range {\n  int from, to;\n  vi align_to[2];\n  bool operator < (const Range& other) const {\n    if (from == other.from) {\n      return to < other.to;\n    }\n    return from < other.from;\n  }\n} buf[maxn * 3];\nint lbuf;\nmap<int, vector<int>> all_range;\nint temp[2][maxn], ltemp;\n\n\nint main() {\n  //............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！........................................\n  ios_base::sync_with_stdio(0);\n  #ifdef DEBUG //......................................................................................................\n  freopen(\"input.txt\", \"r\", stdin);\n  #endif //...........................................................................................................\n\n  scanf(\"%d%d\", &n, &l);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", orig + i);\n    buf[lbuf].from = i;\n    buf[lbuf].to = i + 1;\n    buf[lbuf].align_to[0].push_back(0);\n    buf[lbuf].align_to[1].push_back(0);\n    buf[lbuf].align_to[0].push_back(1);\n    buf[lbuf].align_to[1].push_back(1);\n    all_range[orig[i]].push_back(lbuf++);\n  }\n\n  ll ans = 0;\n  for (auto& it : all_range) {\n    vi& all_r = it.second;\n    sort(all_r.begin(), all_r.end(), [&](const int& a, const int& b) {\n      return buf[a] < buf[b];\n    });\n    for (int i = 0, nxt_i = 0; i < (int)all_r.size(); i = nxt_i) {\n      while (nxt_i < (int)all_r.size() - 1 &&\n          buf[all_r[nxt_i + 1]].from == buf[all_r[nxt_i]].to) {\n        nxt_i++;\n      }\n      nxt_i++;\n      ltemp = 1;\n      temp[0][0] = temp[1][0] = 0;\n      for (int j = i; j < nxt_i; j++) {\n        int no = all_r[j];\n        auto rbuf = buf[no];\n        ltemp--;\n        for (int k = 0, rsum = 0; k < (int)rbuf.align_to[0].size(); k++) {\n          temp[0][ltemp] += rbuf.align_to[0][k];\n          temp[1][ltemp++] += rbuf.align_to[1][rbuf.align_to[0].size() - k - 1];\n          if (k >= l) {\n            rsum += rbuf.align_to[1][rbuf.align_to[0].size() - k - 1 + l];\n          }\n          temp[0][ltemp] = temp[1][ltemp] = 0;\n          ans -= 1ll * rbuf.align_to[0][k] * rsum;\n        }\n      }\n      for (int j = l, sum = 0; j < ltemp; j++) {\n        sum += temp[1][j - l];\n        ans += 1ll * temp[0][j] * sum;\n      }\n\n      if (ltemp >= l) {\n        buf[lbuf].from = buf[all_r[i]].from;\n        buf[lbuf].to = buf[all_r[nxt_i - 1]].to;\n        buf[lbuf].align_to[0].push_back(0);\n        buf[lbuf].align_to[1].push_back(0);\n        for (int j = l; j < ltemp; j++) {\n          if (j % l == 0) {\n            buf[lbuf].align_to[0].push_back(0);\n            buf[lbuf].align_to[1].push_back(0);\n          }\n          buf[lbuf].align_to[0].back() += temp[0][j];\n          buf[lbuf].align_to[1].back() += temp[1][ltemp - j - 1];\n        }\n        all_range[it.first + 1].push_back(lbuf++);\n      }\n    }\n  }\n\n  cout << ans + n << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<iostream>\nusing namespace std;\n#define mp make_pair\n#define fi first\n#define se second\nconst int MAXN = 200000;\ntypedef pair<int, int> pii;\ntypedef long long ll;\npriority_queue<pii, vector<pii>, greater<pii> >que;\nint lst[MAXN + 5], nxt[MAXN + 5], N, L;\nvoid link(int x, int y) {lst[y] = x, nxt[x] = y;}\nvoid cut(int x) {nxt[lst[x]] = nxt[x], lst[nxt[x]] = lst[x];}\nbool check(int x, int y) {return nxt[x] == y;}\nll lf[MAXN + 5], rf[MAXN + 5], f1[MAXN + 5], f2[MAXN + 5];\nvector<int>v1, v2;\nll solve(int x) {\n\tll ret = 0, tmp = 0;\n\tint lt = v2.size(), lb = lst[v2[0]], rb = nxt[v2[lt-1]];\n\tfor(int i=0;i<lt;i++) {\n\t\tif( i - L + 1 >= 0 ) tmp += lf[v2[i-L+1]];\n\t\tif( i - L*L + 1 >= 0 ) tmp -= lf[v2[i-L*L+1]];\n\t\tret += tmp * rf[v2[i]], cut(v2[i]);\n\t}\n\tfor(int i=0;i<lt;i++)\n\t\tf1[v2[i]] = lf[v2[i]], f2[v2[i]] = rf[v2[i]], lf[v2[i]] = rf[v2[i]] = 0;\n\tint c = lt / L;\n\tif( c ) {\n\t\tfor(int i=L-1;i<lt;i++) {\n\t\t\tint t = (i + 1)/L - 1;\n\t\t\trf[v2[t]] += f2[v2[i]];\n\t\t}\n\t\tfor(int i=lt-L;i>=0;i--) {\n\t\t\tint t = c - (lt - i)/L;\n\t\t\tlf[v2[t]] += f1[v2[i]];\n\t\t}\n\t\tfor(int i=1;i<c;i++)\n\t\t\tlink(v2[i-1], v2[i]);\n\t\tlink(lb, v2[0]), link(v2[c-1], rb);\n\t\tfor(int i=0;i<c;i++)\n\t\t\tque.push(mp(x + 1, v2[i]));\n\t}\n\tv2.clear();\n\treturn ret;\n}\nint main() {\n\tscanf(\"%d%d\", &N, &L);\n\tfor(int i=1;i<=N;i++) {\n\t\tint x; scanf(\"%d\", &x);\n\t\tque.push(mp(x, i)), link(i, i + 1);\n\t\tlf[i] = rf[i] = 1;\n\t}\n\tll ans = 0; link(0, 1);\n\twhile( !que.empty() ) {\n\t\tint x = que.top().fi; v1.clear();\n\t\twhile( !que.empty() && que.top().fi == x )\n\t\t\tv1.push_back(que.top().se), que.pop();\n\t\tv2.clear(); v2.push_back(v1[0]);\n\t\tfor(int i=1;i<v1.size();i++) {\n\t\t\tif( !check(v1[i-1], v1[i]) )\n\t\t\t\tans += solve(x);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\tans += solve(x);\n\t}\n\tprintf(\"%lld\\n\", ans + N);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool convert(vector<int> tet, int k){\n\twhile (tet.size() > 1){\n\t\tint same = 1;\n\t\tint X = tet.back();\n\t\twhile (same < tet.size() && tet[tet.size()-same-1] == tet[tet.size()-1]) same++;\n\t\tif (same < k){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int e=0; e < same;e++) tet.pop_back();\n\t\tfor (int e=0; e < same/k; e++) tet.push_back(X+1);\n\t}\n\treturn (tet.size()==1);\n}\nsigned main() {\n\t#ifdef LOCAL\n\t\tfreopen(\"H_input.txt\", \"r\", stdin);\n\t\t//freopen(\"C_output.txt\", \"w\", stdout);\n\t#endif\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n, k;\n    cin >> n >> k;\n    vector<int> v(n);\n    for (int i=0; i < n; i++) cin >> v[i];\n    long long ans=0;\n\tfor (int i=0; i < n; i++){\n\t\tvector<int> tet;\n\t\tfor (int j=i; j < n; j++){\n\t\t\tif (!tet.size()){\n\t\t\t\tans++;\n\t\t\t\ttet.push_back(v[j]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbool good = true;\n\t\t\t\twhile (tet.back() < v[j]){\n\t\t\t\t\tint same = 1;\n\t\t\t\t\tint X = tet.back();\n\t\t\t\t\twhile (same < tet.size() && tet[tet.size()-same-1] == tet[tet.size()-1]) same++;\n\t\t\t\t\tif (same < k){\n\t\t\t\t\t\tgood = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int e=0; e < same;e++) tet.pop_back();\n\t\t\t\t\tfor (int e=0; e < same/k; e++) tet.push_back(X+1);\n\t\t\t\t}\n\t\t\t\tif (!good) break;\n\t\t\t\ttet.push_back(v[j]);\n\t\t\t\tif (convert(tet, k)){\n\t\t\t\t\t//cout << i << \" \" << j << endl;\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long li;\ntypedef unsigned long long lu;\nconst int inf = ~0U >> 2;\nconst li infl = ~0LLU >> 2;\n\ntemplate <class T> inline void Min(T &x, T y) { if (y < x) x = y; }\ntemplate <class T> inline void Max(T &x, T y) { if (y > x) x = y; }\n\n// const int mod = 1e9 + 7;\n// inline int Add(int x) { return x >= mod ? x - mod : x; }\n// inline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\n// inline int Sub(int x) { return x < 0 ? x + mod : x; }\n// inline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\n// inline int Mul(int x, int y) { return (int)((li)x * y % mod); }\n// inline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\n// int Pow(int x, int y) { int z = 1;\n//   for (; y; y >>= 1, x = Mul(x, x)) { if (y & 1) z = Mul(z, x); } return z; }\n// inline int Inv(int x) { return Pow(x, mod - 2); }\n// inline int Fix(li x) { x %= mod; if (x < 0) x += mod; return (int)x; }\n// inline int Fix(int x) { x %= mod; if (x < 0) x += mod; return x; }\n\n// ----------------------------------------\n\nconst int maxn = 2e5;\n\nint n, lim;\nint st[maxn], top;\nint L[maxn], R[maxn];\nli ans;\n\nli Ways(int l, int r) {\n  li sum = 0, tot = 0;\n  for (int i = r - 1; i >= l + lim - 1; --i) {\n    sum += R[i];\n    tot += (li)L[i - lim + 1] * sum;\n  }\n  for (int i = l; i < r; ++i) {\n    tot += (li)L[i] * R[i];\n  }\n  return tot;\n}\n\nvoid Merge(void) {\n  int val = st[top - 1];\n  int begin = top - 1;\n  while (begin > 0 && st[begin - 1] == st[begin]) {\n    --begin;\n  }\n  int end = top;\n  ans += Ways(begin, end);\n\n  if (end - begin < lim) {\n    top = begin;\n    while (top > 0) Merge();\n    return;\n  }\n  int len = (end - begin) / lim;\n\n  static int cntP[maxn + 1], cntS[maxn + 1];\n  FILL(cntP, len + 1, 0);\n  FILL(cntS, len + 1, 0);\n  for (int i = begin; i < end; ++i) {\n    int c = i - begin + 1;\n    if (c >= lim) {\n      cntP[c / lim] += R[i];\n    }\n    c = end - i;\n    if (c >= lim) {\n      cntS[c / lim] += L[i];\n    }\n  }\n  top = begin + len;\n  for (int i = 0; i < len; ++i) {\n    st[begin + i] = val + 1;\n    L[begin + i] = cntS[len - i];\n    R[begin + i] = cntP[i + 1];\n  }\n\n  ans -= Ways(begin, top);\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &lim);\n  top = 0;\n  ans = 0;\n  for (int i = 0; i < n; ++i) {\n    int now;\n    scanf(\"%d\", &now);\n    while (top > 0 && st[top - 1] < now) {\n      Merge();\n    }\n    L[top] = R[top] = 1;\n    st[top++] = now;\n  }\n  while (top > 0) {\n    Merge();\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define last last2\n\nusing namespace std;\n\ntypedef long long ll;\n\nint num[200005],n,L;\nll ans;\n\nnamespace SGT {\n\nint maxv[800000];\n\nvoid build(int l,int r,int o) {\n  if (l==r) maxv[o]=l;\n  else {\n  \tint m=((l+r)>>1);\n    build(l,m,o*2);\n    build(m+1,r,o*2+1);\n    maxv[o]=((num[maxv[o*2]]>=num[maxv[o*2+1]])?maxv[o*2]:maxv[o*2+1]);\n  }\n}\n\nint query(int l,int r,int o,int lx,int rx) {\n  if (l>=lx&&r<=rx) return maxv[o];\n  else {\n  \tint m=((l+r)>>1);\n  \tif (m>=rx) return query(l,m,o*2,lx,rx);\n  \tif (m<lx) return query(m+1,r,o*2+1,lx,rx);\n  \tint a=query(l,m,o*2,lx,rx),b=query(m+1,r,o*2+1,lx,rx);\n  \treturn (num[a]>=num[b])?a:b;\n  }\n}\n\n}\n\nint nxt[200005],powd[200005];\n\nvoid pre() {\n  static int last[200005];\n  powd[0]=1;\n  for(int i=1;i<=n;i++) powd[i]=min((ll)powd[i-1]*L,n+1LL);\n  for(int i=n;i>0;i--) {\n  \tnxt[i]=((last[num[i]])?last[num[i]]:n+1);\n  \tlast[num[i]]=i;\n  } \n}\n\nvector <int> suml[200005],sumr[200005];\nvector <int> pos[200005],son[200005];\nint size[200005],lsize[200005],rsize[200005];\nint val[200005],tot;\n\nvoid calc(int o,int d) {\n  static int sum[200005];\n  if (d>n||powd[d]>n) {\n  \tsize[o]=-1;\n  \tsuml[o].resize(1);sumr[o].resize(1);\n  \tlsize[o]=rsize[o]=0;\n  \treturn;\n  }\n  size[o]=((size[o]>=powd[d])?size[o]/powd[d]:-1);\n  if (lsize[o]) {\n  \tfor(int i=1;i<=lsize[o];i++) sum[i]=0;\n    int cnt=0,maxn=0;\n    for(int i=powd[d];i<=lsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=suml[o][i];\n    }\n    lsize[o]=maxn;\n    suml[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) suml[o][i]=sum[i];\n  }\n  if (rsize[o]) {\n  \tfor(int i=1;i<=rsize[o];i++) sum[i]=0;\n    int cnt=0,maxn=0;\n    for(int i=powd[d];i<=rsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=sumr[o][i];\n    }\n    rsize[o]=maxn;\n    sumr[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) sumr[o][i]=sum[i];\n  }\n}\n\nint solve(int l,int r) {\n  static int q[200005];\n  int o=++tot;\n  for(int i=SGT::query(1,n,1,l,r);i<=r;i=nxt[i]) \n    pos[o].push_back(i);\n  val[o]=num[pos[o][0]];\n  son[o].resize(pos[o].size()+1);\n  if (pos[o][0]>l) son[o][0]=solve(l,pos[o][0]-1);\n  for(int i=1;i<pos[o].size();i++)\n    if (pos[o][i]>pos[o][i-1]+1) son[o][i]=solve(pos[o][i-1]+1,pos[o][i]-1);\n  if (pos[o][pos[o].size()-1]<r) son[o][son[o].size()-1]=solve(pos[o][pos[o].size()-1]+1,r);\n  for(int i=0;i<son[o].size();i++)\n    if (son[o][i]) calc(son[o][i],val[o]-val[son[o][i]]);\n  int rx=0,lx=0;\n  for(int i=rsize[son[o][0]];i>0;i--) q[++rx]=sumr[son[o][0]][i];\n  int s=0;\n  for(int i=0;i<pos[o].size();i++) {\n  \tq[++rx]=1;\n  \twhile (lx<rx&&rx-lx>=L) s+=q[++lx];\n  \tans+=s;\n  \tif (son[o][i+1]) {\n  \t\tint u=son[o][i+1];\n  \t\tfor(int j=1;j<=lsize[u];j++) {\n  \t\t\twhile (lx<rx&&rx-lx+j>=L) s+=q[++lx];\n  \t\t\tans+=(ll)s*suml[u][j];\n\t\t  }\n\t\tif (size[u]==-1) lx=rx,s=0;\n\t\tfor(int j=rsize[u];j>0;j--) q[++rx]=sumr[u][j];\n\t  }\n  }\n  bool v=1;\n  int sz=pos[o].size();\n  for(int i=0;i<son[o].size();i++)\n    if (size[son[o][i]]==-1) v=0; else sz+=size[son[o][i]];\n  size[o]=((v)?sz:-1);\n  suml[o].resize(1);\n  for(int i=0;i<son[o].size();i++) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=lsize[u];j++) suml[o].push_back(suml[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i+1<son[o].size()) suml[o].push_back(1);\n  }\n  lsize[o]=suml[o].size()-1;\n  sumr[o].resize(1);\n  for(int i=son[o].size()-1;i>=0;i--) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=rsize[u];j++) sumr[o].push_back(sumr[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i) sumr[o].push_back(1);\n  }\n  rsize[o]=sumr[o].size()-1;\n  return o;\n}\n\nint main() {\n  scanf(\"%d%d\",&n,&L);\n  for(int i=1;i<=n;i++) scanf(\"%d\",&num[i]);\n  pre();\n  SGT::build(1,n,1);\n  solve(1,n);\n  printf(\"%lld\\n\",ans+n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nint mul(int a,int b){\n\tif(b==0)return 0;\n\telse if(a<=inf/b)return a*b;\n\telse return inf;\n}\n\nint myp(int a,int b){\n\tint res=1;\n\twhile(b){\n\t\tif(b%2)res=mul(res,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nconst int nmax=200010;\nint L;\nint ch[nmax][2];\n\nstruct waf{\n\tvi head,tail;\n\tint hs,ts,al,mx;\n\twaf():head(1,1),tail(1,1),hs(0),ts(0),al(0),mx(0){}\n\twaf(const vi&h,const vi&t,int hhs,int tts,int aal,int mmx):\n\t\thead(h),tail(t),hs(hhs),ts(tts),al(aal),mx(mmx){}\n\tvoid upd(int to){\n\t\tint w=myp(L,to-mx);\n\t\tif(w==1)return;\n\t\tvi h(hs/w+1);\n\t\trep(i,hs+1)if(i==0||i>=w)h[i/w]+=head[i];\n\t\tvi t(ts/w+1);\n\t\trep(i,ts+1)if(i==0||i>=w)t[i/w]+=tail[i];\n\t\tswap(h,head);\n\t\tswap(t,tail);\n\t\ths/=w;\n\t\tts/=w;\n\t\tif(al!=-1)al/=w;\n\t\tif(mx&&al==0)al=-1;\n\t\tmx=to;\n\t}\t\n};\n\nint ans;\n\nwaf dfs(int v,const vi&arr){\n\tdmp(v);\n\tif(v==-1)\n\t\treturn waf();\n\twaf a=dfs(ch[v][0],arr);\n\twaf b=dfs(ch[v][1],arr);\n\ta.upd(arr[v]);\n\tb.upd(arr[v]);\n\tvi p=a.tail;\n\tper(i,a.ts)p[i]+=p[i+1];\n\trep(i,b.hs+1){\n\t\tint need=max(int(0),L-1-i);\n\t\tif(need<=a.ts)\n\t\t\tans+=p[need]*b.head[i];\n\t}\n\t//dmp(v);\n\tans++;\n\t//dmp(ans);\n\tvi h=a.head,t=b.tail;\n\tint hs=a.hs,ts=b.ts,al=-1,mx=arr[v];\n\tif(a.al!=-1){\n\t\tassert(a.hs==a.al);\n\t\ths+=1+b.hs;\n\t\th.resize(hs+1);\n\t\trep(i,b.hs+1)\n\t\t\th[a.al+1+i]+=b.head[i];\n\t}\n\t//dmp(v);\n\tif(b.al!=-1){\n\t\tassert(b.ts==b.al);\n\t\tts+=1+a.ts;\n\t\tt.resize(ts+1);\n\t\trep(i,a.ts+1)\n\t\t\tt[b.al+1+i]+=a.tail[i];\n\t}\n\tif(a.al!=-1&&b.al!=-1)\n\t\tal=a.al+1+b.al;\n\treturn waf(h,t,hs,ts,al,mx);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\tcin>>L;\n\tvi a;\n\tif(n==-1){\n\t\tn=200000;\n\t\ta=vi(n,1);\n\t\tiota(all(a),1);\n\t}else{\n\t\ta=readvi(n);\n\t}\n\tvc<pi> w(n);\n\trep(i,n)\n\t\tw[i]=pi(a[i],rand_int(0,ten(9)));\n\tvi idx;\n\tvi par(n,-1);\n\trep(i,n){\n\t\tint last=-1;\n\t\twhile(idx.size()&&w[idx.back()]<w[i]){\n\t\t\tlast=idx.back();\n\t\t\tidx.pop_back();\n\t\t}\n\t\tif(last!=-1)\n\t\t\tpar[last]=i;\n\t\tif(idx.size())\n\t\t\tpar[i]=idx.back();\n\t\tidx.pb(i);\n\t}\n\tone(ch);\n\tint root=-1;\n\trep(i,n)if(par[i]!=-1)\n\t\tch[par[i]][par[i]<i]=i;\n\telse\n\t\troot=i;\n\tdfs(root,a);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, L;\nvector<int> v;\n\nstruct Elem {\n\tint value;\n\tint l, r;\n};\n\nint calc_cost(vector<Elem> v) { \n\tint r = 0;\n\tfor (int i = 0; i < len(v); i++) {\n\t\tr += v[i].l * v[i].r;\n\t\tfor (int j = i + L - 1; j < len(v); j++) {\n\t\t\tr += v[i].l * v[j].r;\n\t\t}\n\t}\n\treturn r;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, L;\n\tv.resize(n);\n\tscan v;\n\tvector<Elem> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.pb({v[i], 1, 1});\n\tll rez = 0;\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tvector<Elem> t;\n\t\tvector<Elem> buf;\n\t\tint cur = 2e9;\n\t\tfor (int i = 0; i < len(s); i++)\n\t\t\tif (s[i].value != -1) {\n\t\t\t\tcur = min(cur, s[i].value);\n\t\t\t}\n\t\ts.pb({(int)-1e9, -1, -1});\n\t\tfor (int i = 0; i < len(s); i++) {\n\t\t\tif (s[i].value == cur) {\n\t\t\t\tbuf.pb(s[i]);\t\n\t\t\t} else {\n\t\t\t\tvector<Elem> _new(len(buf) / L, {cur + 1, 0, 0});\n\t\t\t\tif (len(buf) < L) {\n\t\t\t\t\tfor (int i = 0; i < len(buf); i++) {\n\t\t\t\t\t\trez += buf[i].l * buf[i].r;\n\t\t\t\t\t\tbuf[i].l = buf[i].r = 0;\n\t\t\t\t\t\tbuf[i].value = -1;\n\t\t\t\t\t}\n\t\t\t\t\t_new = buf;\n\t\t\t\t} else {\n\t\t\t\t\tchange = true;\n\t\t\t\t\trez += calc_cost(buf);\t\n\t\t\t\t\tint k = len(buf) % L + 1;\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].l += s[j].l;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].l += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.l;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].r += s[j].r;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].r += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.r;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\trez -= calc_cost(_new);\n\t\t\t\t}\n\t\t\t\tt.insert(t.end(), _new.begin(), _new.end());\n\t\t\t\tif (s[i].value != -1e9)\n\t\t\t\t\tt.pb(s[i]);\n\t\t\t\tbuf.clear();\n\t\t\t}\n\t\t}\n\t\tswap(t, s);\n\t\t// for (int i = 0; i < len(s); i++) {\n\t\t// \tprint \"{\", s[i].value, s[i].l, s[i].r, \"}\";\n\t\t// \tsmart_io::print_start = \" \";\n\t\t// }\n\t\t// smart_io::print_start = \"\\n\";\n\t\tcur++;\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bo[400010];\nint n,L,sum[400010],a[400010],tot,q[400010],l,r,fl[400010],fr[400010],pre[400010],suf[400010],t[400010],tn,Q[400010],Qn,x,nxt[400010];\npair<int,int> val[200010];\nlong long ans;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&L),a[0]=a[n+1]=-1;\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]),val[i]=make_pair(a[i],i),fl[i]=fr[i]=1;\n\tsort(val+1,val+1+n),l=200000,r=l-1,suf[0]=1,pre[n+1]=n,tot=n+1,ans=n;\n\tfor (int i=1; i<=n; i++) q[++r]=val[i].second,pre[i]=i-1,suf[i]=i+1;\n\twhile (l<=r)\n\t{\n\t\tint R=l;\n\t\twhile (R<r&&a[q[R+1]]==a[q[l]]) R++;\n\t\tfor (int i=l; i<=R; i++) if (!bo[q[i]])\n\t\t{\n\t\t\tx=q[i];\n\t\t\twhile (a[pre[x]]==a[x]) x=pre[x];\n\t\t\tt[tn=1]=x,bo[x]=1;\n\t\t\twhile (a[suf[x]]==a[x]) x=suf[x],t[++tn]=x,bo[x]=1;\n\t\t\tnxt[tn+1]=tn+1;\n\t\t\tfor (int j=tn; j; j--) if (t[j]<=n) nxt[j]=j; else nxt[j]=nxt[j+1];\n\t\t\tsum[tn+1]=0;\n\t\t\tfor (int j=tn; j; j--) sum[j]=sum[j+1]+fr[t[j]];\n\t\t\tfor (int j=1; j<=tn; j++) ans+=1ll*fl[t[j]]*sum[min(max(j+L-1,nxt[j]),tn+1)];\n\t\t\tfor (int j=1; j<=tn; j++) pre[suf[t[j]]]=pre[t[j]],suf[pre[t[j]]]=suf[t[j]];\n\t\t\tint pr=pre[t[1]],sf=suf[t[tn]],cnt=tn/L;\n\t\t\tfor (int j=1; j<=cnt; j++) suf[pr]=(++tot),a[tot]=a[t[1]]+1,pre[sf]=tot,pre[tot]=pr,suf[tot]=sf,pr=tot,Q[++Qn]=tot;\n\t\t\tfor (int j=1; j<=cnt; j++)\n\t\t\t{\n\t\t\t\tfr[tot-cnt+j]=0;\n\t\t\t\tfor (int k=j*L; k<(j+1)*L&&k<=tn; k++) fr[tot-cnt+j]+=fr[t[k]];\n\t\t\t}\n\t\t\tfor (int j=cnt; j; j--)\n\t\t\t{\n\t\t\t\tfl[tot-cnt+j]=0;\n\t\t\t\tfor (int k=tn-(cnt-j+1)*L+1; k>tn-(cnt-j+2)*L+1&&k; k--) fl[tot-cnt+j]+=fl[t[k]];\n\t\t\t}\n\t\t}\n\t\tl=R+1;\n\t\tfor (int i=1; i<=Qn; i++) q[--l]=Q[i];\n\t\tQn=0;\n\t}\n\treturn printf(\"%lld\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define pii pair<int,int>\n#define riterator reverse_iterator\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 2e5;\npriority_queue<pii,vector<pii>,greater<pii> > que;\nint nxt[N+3],prv[N+3];\nint a[N+3];\nllong cl[N+3],cr[N+3],cl2[N+3],cr2[N+3];\nvector<int> vec;\nint n,m; llong ans;\n\nvoid solve(int l,int r)\n{\n//\tprintf(\"solve %d %d\\n\",l,r);\n\tllong sum = 0ll;\n\tfor(int i=m-1; i<vec.size(); i++)\n\t{\n\t\tsum += cl[vec[i-m+1]];\n\t\tans += cr[vec[i]]*sum;\n\t}\n\tint cnt = vec.size()/m;\n\tfor(int i=l; i<=l+cnt-1; i++) cl2[i] = cr2[i] = 0ll;\n\tfor(int i=vec.size()-m,j=0,k=l+cnt-1; i>=0; i--)\n\t{\n\t\tcl2[k] += cl[vec[i]];\n\t\tif(j==m-1) {k--,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=m-1,j=0,k=l; i<vec.size(); i++)\n\t{\n\t\tcr2[k] += cr[vec[i]];\n\t\tif(j==m-1) {k++,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=l; i<=l+cnt-1; i++) cl[i] = cl2[i],cr[i] = cr2[i];\n\tsum = 0ll;\n\tfor(int i=l+m-1; i<=l+cnt-1; i++)\n\t{\n\t\tsum += cl[i-m+1];\n\t\tans -= cr[i]*sum;\n\t}\n\tif(cnt==0)\n\t{\n\t\tnxt[prv[l]] = nxt[r]; prv[nxt[r]] = prv[l];\n\t}\n\telse\n\t{\n\t\tnxt[l+cnt-1] = nxt[r]; prv[nxt[r]] = l+cnt-1;\n\t\tfor(int i=l; i<l+cnt-1; i++) nxt[i] = i+1;\n\t\tfor(int i=l+1; i<=l+cnt-1; i++) prv[i] = i-1;\n\t\tint val = a[l]; for(int i=l; i<=l+cnt-1; i++) a[i] = val+1;\n\t\tfor(int i=l; i<=l+cnt-1; i++) que.push(mkpr(a[i],i));\n\t}\n//\tprintf(\"cnt=%d\\n\",cnt);\n//\tprintf(\"prv: \"); for(int i=1; i<=n; i++) printf(\"[%d]%d \",i,prv[i]); puts(\"\");\n//\tprintf(\"nxt: \"); for(int i=1; i<=n; i++) printf(\"[%d]%d \",i,nxt[i]); puts(\"\");\n//\tprintf(\"cl: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cl[i]); puts(\"\");\n//\tprintf(\"cr: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cr[i]); puts(\"\");\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&a[i]),que.push(mkpr(a[i],i)),cl[i] = cr[i] = 1ll,nxt[i] = i+1,prv[i] = i-1;\n\tnxt[0] = 1,prv[n+1] = n;\n\twhile(1)\n\t{\n\t\tint l = que.top().second,r = l; que.pop(); vec.clear(); vec.push_back(l);\n\t\twhile(!que.empty() && que.top().first==a[l] && que.top().second==nxt[r]) {r = nxt[r]; vec.push_back(r); que.pop();}\n\t\tsolve(l,r);\n\t\tif(prv[l]==0&&nxt[r]==n+1) break;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}\n/*\n15 3\n3 2 2 2 3 4 8 2 2 2 2 2 2 2 8\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define last last2\n\nusing namespace std;\n\ntypedef long long ll;\n\nint num[200005],n,L;\nll ans;\n\nnamespace SGT {\n\nint maxv[800000];\n\nvoid build(int l,int r,int o) {\n  if (l==r) maxv[o]=l;\n  else {\n  \tint m=((l+r)>>1);\n    build(l,m,o*2);\n    build(m+1,r,o*2+1);\n    maxv[o]=((num[maxv[o*2]]>=num[maxv[o*2+1]])?maxv[o*2]:maxv[o*2+1]);\n  }\n}\n\nint query(int l,int r,int o,int lx,int rx) {\n  if (l>=lx&&r<=rx) return maxv[o];\n  else {\n  \tint m=((l+r)>>1);\n  \tif (m>=rx) return query(l,m,o*2,lx,rx);\n  \tif (m<lx) return query(m+1,r,o*2+1,lx,rx);\n  \tint a=query(l,m,o*2,lx,rx),b=query(m+1,r,o*2+1,lx,rx);\n  \treturn (num[a]>=num[b])?a:b;\n  }\n}\n\n}\n\nint nxt[200005],powd[200005];\n\nvoid pre() {\n  static int last[200005];\n  powd[0]=1;\n  for(int i=1;i<=n;i++) powd[i]=min((ll)powd[i-1]*L,n+1LL);\n  for(int i=n;i>0;i--) {\n  \tnxt[i]=((last[num[i]])?last[num[i]]:n+1);\n  \tlast[num[i]]=i;\n  } \n}\n\nvector <int> suml[200005],sumr[200005];\nvector <int> pos[200005],son[200005];\nint size[200005],lsize[200005],rsize[200005];\nint val[200005],tot;\n\nvoid calc(int o,int d) {\n  static int sum[200005];\n  if (d>n||powd[d]>n) {\n  \tsize[o]=-1;\n  \tsuml[o].resize(1);sumr[o].resize(1);\n  \tlsize[o]=rsize[o]=1;\n  \treturn;\n  }\n  size[o]=((size[o]>=powd[d])?size[o]/powd[d]:-1);\n  if (lsize[o]) {\n  \tfor(int i=1;i<=lsize[o];i++) sum[i]=0;\n    int cnt=0,maxn=0;\n    for(int i=powd[d];i<=lsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=suml[o][i];\n    }\n    lsize[o]=maxn;\n    suml[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) suml[o][i]=sum[i];\n  }\n  if (rsize[o]) {\n  \tfor(int i=1;i<=rsize[o];i++) sum[i]=0;\n    int cnt=0,maxn=0;\n    for(int i=powd[d];i<=rsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=sumr[o][i];\n    }\n    rsize[o]=maxn;\n    sumr[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) sumr[o][i]=sum[i];\n  }\n}\n\nint solve(int l,int r) {\n  static int q[200005];\n  int o=++tot;\n  for(int i=SGT::query(1,n,1,l,r);i<=r;i=nxt[i]) \n    pos[o].push_back(i);\n  val[o]=num[pos[o][0]];\n  son[o].resize(pos[o].size()+1);\n  if (pos[o][0]>l) son[o][0]=solve(l,pos[o][0]-1);\n  for(int i=1;i<pos[o].size();i++)\n    if (pos[o][i]>pos[o][i-1]+1) son[o][i]=solve(pos[o][i-1]+1,pos[o][i]-1);\n  if (pos[o][pos[o].size()-1]<r) son[o][son[o].size()-1]=solve(pos[o][pos[o].size()-1]+1,r);\n  for(int i=0;i<son[o].size();i++)\n    if (son[o][i]) calc(son[o][i],val[o]-val[son[o][i]]);\n  int rx=0,lx=0;\n  for(int i=rsize[son[o][0]];i>0;i--) q[++rx]=sumr[son[o][0]][i];\n  int s=0;\n  for(int i=0;i<pos[o].size();i++) {\n  \tq[++rx]=1;\n  \twhile (lx<rx&&rx-lx>=L) s+=q[++lx];\n  \tans+=s;\n  \tif (son[o][i+1]) {\n  \t\tint u=son[o][i+1];\n  \t\tfor(int j=1;j<=lsize[u];j++) {\n  \t\t\twhile (lx<rx&&rx-lx+j>=L) s+=q[++lx];\n  \t\t\tans+=(ll)s*suml[u][j];\n\t\t  }\n\t\tif (size[u]==-1) lx=rx,s=0;\n\t\tfor(int j=rsize[u];j>0;j--) q[++rx]=sumr[u][j];\n\t  }\n  }\n  bool v=1;\n  int sz=pos[o].size();\n  for(int i=0;i<son[o].size();i++)\n    if (size[son[o][i]]==-1) v=0; else sz+=size[son[o][i]];\n  size[o]=((v)?sz:-1);\n  suml[o].resize(1);\n  for(int i=0;i<son[o].size();i++) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=lsize[u];j++) suml[o].push_back(suml[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i+1<son[o].size()) suml[o].push_back(1);\n  }\n  lsize[o]=suml[o].size()-1;\n  sumr[o].resize(1);\n  for(int i=son[o].size()-1;i>=0;i--) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=rsize[u];j++) sumr[o].push_back(sumr[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i) sumr[o].push_back(1);\n  }\n  rsize[o]=sumr[o].size()-1;\n  return o;\n}\n\nint main() {\n  scanf(\"%d%d\",&n,&L);\n  for(int i=1;i<=n;i++) scanf(\"%d\",&num[i]);\n  pre();\n  SGT::build(1,n,1);\n  solve(1,n);\n  printf(\"%lld\\n\",ans+n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[200005],cur,is[200005],pw[200005],fa[200005];\nint *pre[200005],*suf[200005],cnt[200005],nwa[200005];\nll ans;\nint dp[600005],*f=dp+400000;\nint w[25000005],*at=w;\npii b[200005];\nint *newI(int n){\n\tat+=n;\n\treturn at-n;\n}\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nint nex[200005],stk[400005],tp,ist[200005];\nvoid add(int x,int y){\n//\twrite(x,'-',y,'\\n');\n\tif(!ist[x]){stk[++tp]=x;}\n\tif(!ist[y]){stk[++tp]=y;}\n\tist[y]=-1;if(!ist[x])ist[x]=1;\t\n\tnex[x]=y;\n}\nint id[200005],m,n,l;\nvoid upd(int x){\n\tif(!is[x])return;\n\tx=find(x);\n\tif(nwa[x]!=cur){\n\t\tint S=pw[min(cur-nwa[x],n)];\n\t\tint *p=pre[x],*s=suf[x];\n\t\tfor(int j=1;j<=cnt[x];++j){\n\t\t\tint w=p[j-1];\n\t\t\tp[j-1]=0;\n\t\t\tif(j>=S)p[j/S-1]+=w;\n\t\t\tw=s[j-1];\n\t\t\ts[j-1]=0;\n\t\t\tif(j>=S)s[j/S-1]+=w;\n\t\t}\n\t\tcnt[x]/=S;\n\t\tnwa[x]=cur;\n\t\tif(!cnt[x]){\n\t\t\tint y=x;\n\t\t\twhile(is[--y])is[y]=0;\n\t\t\ty=x;while(is[++y])is[y]=0;\n\t\t\tis[x]=0;\n\t\t}\n\t}\n}\nvoid put(int x){\n\tupd(x-1);\n\tupd(x+1);\n\tis[x]=1;\n\tnwa[x]=a[x];\n\tcnt[x]=1;\n\tpre[x]=newI(1);pre[x][0]=1;suf[x]=newI(1);suf[x][0]=1;\n\tfa[x]=x;\n\tif(is[x-1]){add(find(x-1),x);}\n\tif(is[x+1]){add(x,find(x+1));}\n}\nvoid solve(){\n\tint cc=0;\n\tfor(int i=1;i<=m;++i){\n\n\t\tcc+=cnt[id[i]];\n\t}\t\n\n/*\twrite(m,'\\n');\n\tfor(int i=1;i<=m;++i){\n\t\twrite(cnt[id[i]],':');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('|');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('\\n');\n\t}*/\n\tint *np=newI(cc),*ns=newI(cc);\n\tint t=0;\n\tfor(int i=1;i<=m;++i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tnp[t]=pre[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tt=0;\n\tfor(int i=m;i;--i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tns[t]=suf[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tfor(int i=m;i;--i){\n\t\tfor(int j=1;j<=cnt[id[i]];++j)ans+=(ll)suf[id[i]][j-1]*f[max(1,l-j)];\n\t\tfor(int j=cnt[id[i]];j;--j){f[0]=f[1]+pre[id[i]][j-1];--f;}\n\t}\n\tfor(int i=1;i<=cc;++i)*(++f)=0;\n\t/*write(ans,'\\n');\n\twrite(cc,'|',id[1],'\\n');*/\n\tcnt[id[1]]=cc;\n\tpre[id[1]]=np;\n\tsuf[id[1]]=ns;\n}\nvoid work(){\n\tfor(;tp;--tp){\n\t\tif(ist[stk[tp]]<=0){ist[stk[tp]]=0;continue;}\n\t\tist[stk[tp]]=0;\n\t\tint at=stk[tp];\n\t\tm=0;\n\t\twhile(at){\n//\t\t\twrite(at,'(');\n\t\t\tid[++m]=at;\n\t\t\tfa[at]=stk[tp];\n\t\t\tint nx=nex[at];\n\t\t\tnex[at]=0;\n\t\t\tat=nx;\n\t\t}\n\t\tsolve();\n\t}\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tread(n,l);\n\tpw[0]=1;\n\tint iee=n/l+1;\n\tfor(int i=1;i<=n;++i)pw[i]=min(pw[i-1],iee)*l;\n\tfor(int i=1;i<=n;++i){read(a[i]);b[i]=make_pair(a[i],i);}\n\tsort(b+1,b+n+1);\n\tfor(int i=1,j=1;i<=n;i=j){\n\t\tcur=b[i].x;\n\t\twhile(b[i].x==b[j].x){put(b[j].y);++j;}\n\t\twork();\n\t}\n\twrite(ans+n,'\\n');\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    // friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend void pr(const modular& a) { pr(a.val); }\n    friend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n    friend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint N,L;\nvi A,lef,rig,nex;\nll ans;\nset<int> pos;\nset<pi> vals;\n\n/*int nex(int x) {\n\tauto it = pos.find(x); it ++;\n\tif (it == end(pos)) return MOD;\n\treturn *it;\n}*/\n\nll eval(vi v) {\n\tll res = 0, sum = 0;\n\tF0R(i,sz(v)) res += (ll)lef[v[i]]*rig[v[i]];\n\tF0Rd(i,sz(v)) {\n\t\tif (i+L-1 < sz(v)) sum += rig[v[i+L-1]];\n\t\tres += lef[v[i]]*sum;\n\t}\n\treturn res;\n}\n\nvoid compress(vi v) {\n\tans += eval(v);\n\t//ps(\"HUH\",v,A[v[0]],eval(v));\n\t//trav(t,v) ps(lef[t],rig[t]);\n\t//ps(pos);\n\tif (sz(v) < L) {\n\t\tauto it = pos.find(v[0]);\n\t\tif (it != begin(pos)) nex[*prev(it)] = -1;\n\t\ttrav(t,v) pos.erase(t);\n\t} else {\n\t\tvi LEF(sz(v)/L), RIG(sz(v)/L);\n\t\tF0R(i,sz(v)) if (i+1 >= L) {\n\t\t\tint ind = (i+1)/L-1;\n\t\t\tLEF[ind] += lef[v[sz(v)-1-i]];\n\t\t\tRIG[ind] += rig[v[i]];\n\t\t}\n\t\treverse(all(LEF));\n\t\ttrav(t,v) pos.erase(t);\n\t\tvi V; F0R(i,sz(v)/L) V.pb(v[i]);\n\t\tF0R(i,sz(V)-1) nex[V[i]] = V[i+1];\n\t\tnex[V.back()] = nex[v.back()];\n\t\tF0R(i,sz(V)) {\n\t\t\tlef[V[i]] = LEF[i], rig[V[i]] = RIG[i];\n\t\t\tpos.insert(V[i]);\n\t\t\tvals.insert({++A[V[i]],V[i]});\n\t\t}\n\t\tans -= eval(V);\n\t\t//ps(\"HA\",LEF,RIG,eval(V),sz(V),ans);\n\t}\n}\n\nint main() {\n    setIO(); re(N,L); A.rsz(N); re(A);\n    lef = rig = vi(N,1);\n    F0R(i,N) {\n    \tif (i+1 == N) nex.pb(-1);\n    \telse nex.pb(i+1);\n    }\n    F0R(i,N) {\n    \tpos.insert(i);\n    \tvals.insert({A[i],i});\n    }\n    while (sz(vals)) {\n    \tint x = vals.begin()->f;\n    \tvi v;\n    \twhile (sz(vals) && vals.begin()->f == x) {\n    \t\tv.pb(vals.begin()->s);\n    \t\tvals.erase(vals.begin());\n    \t}\n    \tvector<vi> inter;\n    \tfor (int i = 0; i < sz(v); ) {\n    \t\tint r = i; while (r+1 < sz(v) && nex[v[r]] == v[r+1]) r ++;\n    \t\tvi t; FOR(j,i,r+1) t.pb(v[j]);\n    \t\tinter.pb(t);\n    \t\ti = r+1;\n    \t}\n    \ttrav(t,inter) compress(t);\n    \t//ps(pos,vals,ans);\n    \t//exit(0);\n    }\n    ps(ans);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, L;\nvector<int> v;\n\nstruct Elem {\n\tint value = 0;\n\tint l = 0, r = 0;\n\tint order;\n\n\tfriend bool operator<(Elem a, Elem b) {\n\t\treturn a.order < b.order;\n\t}\n};\n\nint calc_cost(vector<Elem> v) { \n\tint r = 0;\n\tint s = 0;\n\tfor (int i = L - 1; i < len(v); i++)\n\t\ts += v[i].r;\n\tfor (int i = 0; i < len(v); i++) {\n\t\tr += v[i].l * (v[i].r + s);\n\t\tif (i + L - 1 < len(v))\n\t\t\ts -= v[i + L - 1].r;\n\t}\n\treturn r;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, L;\n\tv.resize(n);\n\tscan v;\n\tset<Elem> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.insert({v[i], 1, 1, i});\n\tll rez = 0;\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tvector<Elem> t;\n\t\tvector<Elem> buf;\n\t\tint cur = 2e9;\n\t\tfor (auto e : s)\n\t\t\tif (e.value != -1) \n\t\t\t\tcur = min(cur, e.value);\n\t\tfor (auto e : s)\n\t\t\tif (e.value == cur)\n\t\t\t\tt.pb(e);\n\t\tt.pb({(int)-1e9, -1, -1});\n\t\tfor (auto e : t) {\n\t\t\tif (buf.empty() || (--s.find(e)) == s.find(buf.back())) {\n\t\t\t\tbuf.pb(e);\n\t\t\t} else {\n\t\t\t\tvector<Elem> _new(len(buf) / L, {cur + 1, 0, 0, -1});\n\t\t\t\tfor (int i = 0; i < len(_new); i++)\n\t\t\t\t\t_new[i].order = buf[i].order;\n\t\t\t\tif (len(buf) < L) {\n\t\t\t\t\tfor (int i = 0; i < len(buf); i++) {\n\t\t\t\t\t\trez += buf[i].l * buf[i].r;\n\t\t\t\t\t\tif (buf[i].value != -1)\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\tbuf[i].l = buf[i].r = 0;\n\t\t\t\t\t\tbuf[i].value = -1;\n\t\t\t\t\t}\n\t\t\t\t\t_new = buf;\n\t\t\t\t} else {\n\t\t\t\t\tchange = true;\n\t\t\t\t\trez += calc_cost(buf);\t\n\t\t\t\t\tint k = len(buf) % L + 1;\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].l += buf[j].l;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].l += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.l;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].r += buf[j].r;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].r += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.r;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\trez -= calc_cost(_new);\n\t\t\t\t}\n\t\t\t\tfor (auto e : buf)\n\t\t\t\t\ts.erase(e);\n\t\t\t\tfor (auto e : _new)\n\t\t\t\t\ts.insert(e);\n\t\t\t\tbuf.clear();\n\t\t\t\tif (e.value != -1e9)\n\t\t\t\t\tbuf.pb(e);\n\t\t\t}\n\t\t}\n\t\t// for (int i = 0; i < len(s); i++) {\n\t\t// \tprint \"{\", s[i].value, s[i].l, s[i].r, \"}\";\n\t\t// \t// print s[i].value;\n\t\t// \tsmart_io::print_start = \" \";\n\t\t// }\n\t\t// smart_io::print_start = \"\\n\";\n\t\tcur++;\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define st first\n#define nd second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<long long>;\nusing ld = long double;\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int kMaxN = 2e5 + 100;\n\nint n, L;\nint vals[kMaxN];\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> n >> L;\n  for (int i = 0; i < n; ++i) {\n    cin >> vals[i];\n  }\n\n  struct Number {\n    int num;\n    int lends, rends;\n  };\n\n  map<int, Number> nums;\n  for (int i = 0; i < n; ++i) {\n    nums[i] = Number{vals[i], 1, 1};\n  }\n\n  vi order(n);\n  iota(ALL(order), 0);\n  sort(ALL(order), [&](int lhs, int rhs) {\n        return MP(vals[lhs], lhs) < MP(vals[rhs], rhs);\n      });\n\n  ll ans = n;\n  vector<bool> visited(n);\n\n  for (int loc : order) {\n    if (visited[loc]) { continue; }\n    debug(loc);\n    auto iter = nums.find(loc);\n    assert(iter != nums.end());\n    assert(iter->nd.lends == 1 && iter->nd.rends == 1);\n    \n    vi other_locs;\n    auto piter = iter, niter = iter;\n    while (piter != nums.begin() && prev(piter)->nd.num == vals[loc]) { --piter; }\n    while (niter != nums.end() && niter->nd.num == vals[loc]) { ++niter; }\n\n    for (auto it = piter; it != niter; ++it) {\n      other_locs.PB(it->st);\n    }\n\n    const int S = SZ(other_locs);\n\n    if (S >= L) {\n      int rgt = 0;\n      int ways_rgt = 0;\n      int num_good = !visited[other_locs[0]];\n      for (int v : other_locs) { ways_rgt += nums[v].rends; }\n\n      for (int lft = 0; lft + L <= S; ++lft) {\n        while (rgt < S && (rgt-lft < L-1 || !num_good)) {\n          const int v = other_locs[rgt];\n          ways_rgt -= nums[v].rends;\n          ++rgt;\n          if (rgt < S) { num_good += !visited[other_locs[rgt]]; }\n        }\n\n        const int ways_lft = nums[other_locs[lft]].lends ;\n        debug(lft, rgt, ways_rgt);\n\n        ans += (ll)ways_lft * ways_rgt;\n        num_good -= !visited[other_locs[lft]];\n      }\n    }\n\n    for (int v : other_locs) {\n      visited[v] = true;\n    }\n\n    vi lends(S), rends(S);\n    for (int i = 0; i < S; ++i) {\n      lends[i] = nums[other_locs[i]].lends;\n      rends[i] = nums[other_locs[i]].rends;\n    }\n\n    for (int v : other_locs) { nums.erase(v); }\n    const int num_add = S / L;\n    vector<Number> xs(num_add);\n    for (int idx_add = 0; idx_add < num_add; ++idx_add) {\n      xs[idx_add].num = vals[loc] + 1;\n\n      const int lft = (idx_add + 1) * L - 1;\n      const int rgt = min(S, (idx_add + 2) * L - 1);\n      for (int i = lft; i < rgt; ++i) {\n        xs[idx_add].rends += rends[i];\n        xs[num_add - idx_add - 1].lends += lends[S - i - 1];\n      }\n    }\n\n    for (int idx_add = 0; idx_add < num_add; ++idx_add) {\n      debug(idx_add, xs[idx_add].num, xs[idx_add].lends, xs[idx_add].rends);\n      nums.emplace(other_locs[0] + idx_add, xs[idx_add]);\n    }\n  }\n\n  cout << ans << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint L;\n\nvector<int> a;\n\nstruct I {\n\tint amax;\n\tunordered_map<int,int> pref, suff;\n\tbool tot_okay;\n\tint tot_num;\n\tI() {\n\t\tamax = 0;\n\t\tpref[0] = 1; suff[0] = 1;\n\t\ttot_okay = true;\n\t\ttot_num = 0;\n\t}\n};\n\nvoid level_up(I& v, int a){\n\tassert(a >= v.amax);\n\twhile(v.amax < a){\n\t\tv.amax += 1;\n\t\tbool did_something = false;\n\t\tunordered_map<int,int> newpref, newsuff;\n\t\tfor(auto q : v.pref){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewpref[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewpref[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tfor(auto q : v.suff){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewsuff[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewsuff[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tv.pref = newpref;\n\t\tv.suff = newsuff;\n\t\tif(v.tot_okay){\n\t\t\tif(v.tot_num == 0){\n\t\t\t} else if(v.tot_num < L){\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_okay = false;\n\t\t\t\tv.tot_num = 0;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_num /= L;\n\t\t\t}\n\t\t}\n\t\tif(!did_something) break;\n\t}\n\tv.amax = a;\n}\n\nlong long ans = 0;\n\nvector<int> arr(const unordered_map<int, int> f){\n\tvector<int> a(f.size(), -1);\n\tfor(pair<int,int> x : f){\n\t\ta[x.first] = x.second;\n\t}\n\treturn a;\n}\n\nI combine(I& l, int a, I& r){\n\tlevel_up(l, a);\n\tlevel_up(r, a);\n\tassert(a == l.amax);\n\tassert(a == r.amax);\n\tI res;\n\tres.amax = a;\n\tres.pref = res.suff = {};\n\tif(l.tot_okay && r.tot_okay){\n\t\tres.tot_okay = true;\n\t\tres.tot_num = l.tot_num + 1 + r.tot_num;\n\t} else {\n\t\tres.tot_okay = false;\n\t\tres.tot_num = 0;\n\t}\n\tres.pref = move(l.pref);\n\tif(l.tot_okay){\n\t\tfor(auto q : r.pref){\n\t\t\tres.pref[q.first + l.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tres.suff = move(r.suff);\n\tif(r.tot_okay){\n\t\tfor(auto q : l.suff){\n\t\t\tres.suff[q.first + r.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tvector<int> la = arr(l.suff);\n\tvector<int> ra = arr(r.pref);\n\tlong long cur = 0;\n\tcur += 1;\n\tlong long tot = 0;\n\tint j = (int)ra.size();\n\tfor(int i = 0; i < (int)la.size(); i++){\n\t\twhile(j > 0 && (j-1) + 1 + i >= L){\n\t\t\tj -= 1;\n\t\t\ttot += ra[j];\n\t\t}\n\t\tcur += la[i] * tot;\n\t}\n\tans += cur;\n\treturn res;\n}\n\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n >> L;\n\ta.resize(n);\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\n\tvector<int> b(n+2);\n\tvector<int> f(n+2);\n\tfor(int i = 0; i <= n+1; i++){\n\t\tb[i] = i-1;\n\t\tf[i] = i+1;\n\t}\n\tvector<I> data(n+2);\n\tmt19937 mt(48);\n\tvector<pair<long long, int> > apos;\n\tfor(int i = 0; i < n; i++){\n\t\tapos.push_back({1ll * a[i] * (1e8) + mt() % 100000, i+1});\n\t}\n\tsort(apos.begin(), apos.end());\n\tfor(auto _x : apos){\n\t\tint x = _x.second;\n\t\tf[b[x]] = f[x];\n\t\tb[f[x]] = b[x];\n\t\tdata[b[x]] = combine(data[b[x]], a[x-1], data[x]);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[200005],cur,is[200005],pw[200005],fa[200005];\nint *pre[200005],*suf[200005],cnt[200005],nwa[200005];\nll ans;\nint dp[400005],*f=dp+400000;\nint w[25000005],*at=w;\npii b[200005];\nint *newI(int n){\n\tat+=n;\n\treturn at-n;\n}\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nint nex[200005],stk[400005],tp,ist[200005];\nvoid add(int x,int y){\n//\twrite(x,'-',y,'\\n');\n\tist[y]=-1;if(!ist[x])ist[x]=1;\t\n\tstk[++tp]=x;\n\tstk[++tp]=y;\n\tnex[x]=y;\n}\nvoid put(int x){\n\tis[x]=1;\n\tnwa[x]=a[x];\n\tcnt[x]=1;\n\tpre[x]=newI(1);pre[x][0]=1;suf[x]=newI(1);suf[x][0]=1;\n\tfa[x]=x;\n\tif(is[x-1]){add(find(x-1),x);}\n\tif(is[x+1]){add(x,find(x+1));}\n}\nint id[200005],m,n,l;\nvoid solve(){\n\tint cc=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(nwa[id[i]]!=cur){\n\t\t\tint S=pw[min(cur-nwa[id[i]],n)];\n//\t\t\twrite(id[i],' ',cnt[id[i]],' ',nwa[id[i]],' ',S,'\\n');\n\t\t\tint *p=pre[id[i]],*s=suf[id[i]];\n\t\t\tfor(int j=1;j<=cnt[id[i]];++j){\n\t\t\t\tint w=p[j-1];\n\t\t\t\tp[j-1]=0;\n\t\t\t\tif(j>=S)p[j/S-1]+=w;\n\t\t\t\tw=s[j-1];\n\t\t\t\ts[j-1]=0;\n\t\t\t\tif(j>=S)s[j/S-1]+=w;\n\t\t\t}\n\t\t\tcnt[id[i]]/=S;\n\t\t\tnwa[id[i]]=cur;\n\t\t}\n\t\tcc+=cnt[id[i]];\n\t}\t\n\n/*\twrite(m,'\\n');\n\tfor(int i=1;i<=m;++i){\n\t\twrite(cnt[id[i]],':');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('|');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('\\n');\n\t}*/\n\tint *np=newI(cc),*ns=newI(cc);\n\tint t=0;\n\tfor(int i=1;i<=m;++i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tnp[t]=pre[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tt=0;\n\tfor(int i=m;i;--i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tns[t]=suf[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tfor(int i=m;i;--i){\n\t\tfor(int j=1;j<=cnt[id[i]];++j)ans+=(ll)suf[id[i]][j-1]*f[max(1,l-j)];\n\t\tfor(int j=cnt[id[i]];j;--j){f[0]=f[1]+pre[id[i]][j-1];--f;}\n\t}\n\tfor(int i=1;i<=cc;++i)*(++f)=0;\n\t/*write(ans,'\\n');\n\twrite(cc,'|',id[1],'\\n');*/\n\tcnt[id[1]]=cc;\n\tpre[id[1]]=np;\n\tsuf[id[1]]=ns;\n}\nvoid work(){\n\tfor(;tp;--tp){\n\t\tif(ist[stk[tp]]<=0){ist[stk[tp]]=0;continue;}\n\t\tist[stk[tp]]=0;\n\t\tint at=stk[tp];\n\t\tm=0;\n\t\twhile(at){\n//\t\t\twrite(at,'(');\n\t\t\tid[++m]=at;\n\t\t\tfa[at]=stk[tp];\n\t\t\tint nx=nex[at];\n\t\t\tnex[at]=0;\n\t\t\tat=nx;\n\t\t}\n\t\tsolve();\n\t}\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tread(n,l);\n\tpw[0]=1;\n\tint iee=n/l+1;\n\tfor(int i=1;i<=n;++i)pw[i]=min(pw[i-1],iee)*l;\n\tfor(int i=1;i<=n;++i){read(a[i]);b[i]=make_pair(a[i],i);}\n\tsort(b+1,b+n+1);\n\tfor(int i=1,j=1;i<=n;i=j){\n\t\tcur=b[i].x;\n\t\twhile(b[i].x==b[j].x){put(b[j].y);++j;}\n\t\twork();\n\t}\n\twrite(ans+n,'\\n');\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<iostream>\nusing namespace std;\n#define mp make_pair\n#define fi first\n#define se second\nconst int MAXN = 200000;\ntypedef pair<int, int> pii;\ntypedef long long ll;\npriority_queue<pii, vector<pii>, greater<pii> >que;\nint lst[MAXN + 5], nxt[MAXN + 5], N, L;\nvoid link(int x, int y) {lst[y] = x, nxt[x] = y;}\nbool check(int x, int y) {return nxt[x] == y;}\nll lf[MAXN + 5], rf[MAXN + 5], f1[MAXN + 5], f2[MAXN + 5];\nvector<int>v1, v2;\nll solve(int x) {\n\tll ret = 0, tmp = 0;\n\tint lt = v2.size(), lb = lst[v2[0]], rb = nxt[v2[lt-1]];\n\tfor(int i=0;i<lt;i++) {\n\t\tif( i - L + 1 >= 0 ) tmp += lf[v2[i-L+1]];\n\t\tret += tmp * rf[v2[i]];\n\t}\n\tfor(int i=0;i<lt;i++)\n\t\tf1[v2[i]] = lf[v2[i]], f2[v2[i]] = rf[v2[i]], lf[v2[i]] = rf[v2[i]] = 0;\n\tint c = lt / L;\n\tif( c ) {\n\t\tfor(int i=L-1;i<lt;i++) {\n\t\t\tint t = (i + 1)/L - 1;\n\t\t\trf[v2[t]] += f2[v2[i]];\n\t\t}\n\t\tfor(int i=lt-L;i>=0;i--) {\n\t\t\tint t = c - (lt - i)/L;\n\t\t\tlf[v2[t]] += f1[v2[i]];\n\t\t}\n\t\tfor(int i=1;i<c;i++)\n\t\t\tlink(v2[i-1], v2[i]);\n\t\tlink(lb, v2[0]), link(v2[c-1], rb);\n\t\tfor(int i=0;i<c;i++)\n\t\t\tque.push(mp(x + 1, v2[i]));\n\t\ttmp = 0;\n\t\tfor(int i=0;i<c;i++) {\n\t\t\tif( i - L + 1 >= 0 ) tmp += lf[v2[i-L+1]];\n\t\t\tret -= tmp * rf[v2[i]];\n\t\t}\n\t}\n\telse nxt[lb] = N + 1, lst[rb] = 0;\n\tv2.clear();\n\treturn ret;\n}\nint main() {\n\tscanf(\"%d%d\", &N, &L);\n\tfor(int i=1;i<=N;i++) {\n\t\tint x; scanf(\"%d\", &x);\n\t\tque.push(mp(x, i)), link(i, i + 1);\n\t\tlf[i] = rf[i] = 1;\n\t}\n\tll ans = 0; link(0, 1);\n\twhile( !que.empty() ) {\n\t\tint x = que.top().fi; v1.clear();\n\t\twhile( !que.empty() && que.top().fi == x )\n\t\t\tv1.push_back(que.top().se), que.pop();\n\t\tv2.clear(); v2.push_back(v1[0]);\n\t\tfor(int i=1;i<v1.size();i++) {\n\t\t\tif( !check(v1[i-1], v1[i]) )\n\t\t\t\tans += solve(x);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\tans += solve(x);\n\t}\n\tprintf(\"%lld\\n\", ans + N);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,L;\nll ans;\nstruct Inter{\n\tint pos,val,l,r;\n\tInter(int _p=0,int _v=0,int _l=0,int _r=0){pos=_p,val=_v,l=_l,r=_r;}\n};\nstruct cmp1{\n\tbool operator ()(const Inter a,const Inter b)const{\n\t\treturn a.pos<b.pos;\n\t}\n};\nstruct cmp2{\n\tbool operator ()(const Inter a,const Inter b)const{\n\t\treturn a.val==b.val?a.pos<b.pos:a.val<b.val;\n\t}\n};\nset<Inter,cmp1> p;\nset<Inter,cmp2> s;\ninline ll calc(vector<Inter> &v){\n\tll tot=0,sum=0;\n\tfor(int i=0;i+L-1<(int)v.size();++i){\n\t\tsum+=v[i].l;\n\t\ttot+=sum*v[i+L-1].r;\n\t}\n\treturn tot;\n}\nint main(){\n\tn=read(),L=read();\n\tfor(int i=1;i<=n;++i){\n\t\tint x=read();\n\t\tInter zyk(i,x,1,1);\n\t\tp.insert(zyk),s.insert(zyk);\n\t}\n\twhile(!s.empty()){\n\t\tint w=s.begin()->val;\n\t\tvector<Inter> t;\n\t\twhile(s.begin()->val==w){\n\t\t\tt.push_back(*s.begin());\n\t\t\ts.erase(s.begin());\n\t\t}\n\t\tfor(int l=0,r=1;l<(int)t.size();l=r++){\n\t\t\twhile(r<(int)t.size()&&(--p.find(t[r]))==p.find(t[r-1]))++r;\n\t\t\tint len=r-l,cnt=len/L;\n\t\t\tif(!cnt)continue;\n\t\t\tvector<Inter> myh,zyy;\n\t\t\tmyh.insert(myh.begin(),t.begin()+l,t.begin()+r);\n\t\t\tfor(auto x:myh){\n\t\t\t\tp.erase(x);\n\t\t\t}\n\t\t\tans+=calc(myh);\n\t\t\tfor(int i=0;i<cnt;++i){\n\t\t\t\tzyy.push_back(Inter(myh[0].pos+i,w+1,0,0));\n\t\t\t}\n\t\t\tfor(int i=0;i+L-1<(int)myh.size();++i){\n\t\t\t\tzyy[cnt-((int)myh.size()-i)/L].l+=myh[i].l;\n\t\t\t}\n\t\t\tfor(int i=L-1;i<(int)myh.size();++i){\n\t\t\t\tzyy[(i-L+1)/L].r+=myh[i].r;\n\t\t\t}\n\t\t\tans-=calc(zyy);\n\t\t\tfor(auto x:zyy){\n\t\t\t\tp.insert(x),s.insert(x);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define ll long long\nusing namespace std;\nint n,k,tot,pre[400005],nxt[400005],a[400005],l[400005],r[400005],sl[400005],sr[400005];\nll ans;\nbool flag[400005];\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\ttot=n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tpre[i]=i-1,nxt[i]=i+1;\n\t\tq.push(make_pair(a[i],i));\n\t\tl[i]=r[i]=1;\n\t}\n\tnxt[n]=0;\n\twhile(!q.empty())\n\t{\n\t\tint node=q.top().second;\n\t\tq.pop();\n\t\tif(flag[node])continue;\n\t\tint L=node,R=node,len=1;\n\t\twhile(a[pre[L]]==a[node])L=pre[L],len++;\n\t\twhile(a[nxt[R]]==a[node])R=nxt[R],len++;\n\t\tint last=0;\n\t\tfor(int i=L,j=1;i!=nxt[R];i=nxt[i],j++)\n\t\t{\n\t\t\tsl[j]=sl[j-1]+l[i];\n\t\t\tsr[j]=sr[j-1]+r[i];\n\t\t\tif(i<=n)last=j;\n\t\t\tif(last&&j>=k)ans+=1ll*sl[min(j-k+1,last)]*r[i];\n\t\t\tflag[i]=1;\n\t\t}\n\t\tif(len<k)\n\t\t{\n\t\t\tnxt[pre[L]]=pre[nxt[R]]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<=len/k;i++)\n\t\t{\n\t\t\tr[tot+i]=sr[min(len,(i+1)*k-1)]-sr[i*k-1];\n\t\t\tl[tot+i]=sl[len-(len/k-i+1)*k+1]-sl[max(0,len-(len/k-i+2)*k+1)];\n\t\t}\n\t\tnxt[pre[L]]=tot+1,pre[tot+1]=pre[L];\n\t\tpre[nxt[R]]=tot+len/k,nxt[tot+len/k]=nxt[R];\n\t\tfor(int i=1;i<len/k;i++)\n\t\t{\n\t\t\tnxt[tot+i]=tot+i+1;\n\t\t\tpre[tot+i+1]=tot+i;\n\t\t}\n\t\tfor(int i=1;i<=len/k;i++)a[tot+i]=a[L]+1;\n\t\tq.push(make_pair(a[tot+1],tot+1));\n\t\ttot+=len/k;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 2e5+10;\nint n,m,a[N];\nll L[N],R[N],newL[N],newR[N];\n\nint pre[N],nxt[N];\ninline void Del(int x){\n\tpre[nxt[x]]=pre[x],nxt[pre[x]]=nxt[x];\n}\n\nint main(){\n\tn=read(),m=read();\n\tFor(i,1,n) a[i]=read();\n\tset<pa>s;\n\tFor(i,1,n) s.insert(mp(a[i],i)),pre[i]=i-1,nxt[i]=i+1,L[i]=R[i]=1;\n\tll ans=n;\n\twhile (!s.empty()){\n\t\t//for (int i=1;i!=n+1;i=nxt[i]) printf(\"%d \",a[i]);puts(\"\");\n\t\tint u=(*s.begin()).se;s.erase(s.begin());\n\t\tint l=u,r=u;\n\t\twhile (a[pre[l]]==a[l]) l=pre[l];\n\t\twhile (a[nxt[r]]==a[r]) r=nxt[r];\n\t\tpoly v;\n\t\tfor (int i=l;i!=r;i=nxt[i]) v.pb(i); \n\t\tv.pb(r);\n\t\tif (siz(v)<m){\n\t\t\tfor (auto i:v) s.erase(mp(a[i],i)),a[i]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tll S=0;\n\t\tFOR(i,m-1,siz(v)) S+=L[v[i-m+1]],ans+=S*R[v[i]];\n\t\tl=m-1,r=l+m-1;\n\t\tint cnt=siz(v)/m;\n\t\tFor(i,1,cnt){\n\t\t\tnewR[i]=0;\n\t\t\tFor(j,l,min(r,siz(v)-1)) newR[i]+=R[v[j]];\n\t\t\tl+=m,r+=m; \n\t\t}\n\t\tr=siz(v)-m,l=r-m+1;\n\t\tDow(i,cnt,1){\n\t\t\tnewL[i]=0;\n\t\t\tFor(j,max(l,0),r) newL[i]+=L[v[j]];\n\t\t\tl-=m,r-=m;\n\t\t}\n\t\tfor (auto i:v) s.erase(mp(a[i],i));\n\t\tFOR(i,0,cnt){\n\t\t\ta[v[i]]++,L[v[i]]=newL[i+1],R[v[i]]=newR[i+1];\n\t\t\ts.insert(mp(a[v[i]],v[i]));\n\t\t}\n\t\tFOR(i,cnt,siz(v)) Del(v[i]);\n\t\tS=0;\n\t\tFOR(i,m-1,cnt) S+=L[v[i-m+1]],ans-=S*R[v[i]];\n\t\ts.insert(mp(a[v[0]],v[0]));\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n/*\n10 2\n1 2 4 1 4 2 1 1 4 2 \n*/"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, L;\nvector<int> v;\n\nstruct Elem {\n\tint value = 0;\n\tint l = 0, r = 0;\n\tint order;\n\n\tfriend bool operator<(Elem a, Elem b) {\n\t\treturn a.order < b.order;\n\t}\n};\n\nint calc_cost(vector<Elem> v) { \n\tint r = 0;\n\tint s = 0;\n\tfor (int i = L - 1; i < len(v); i++)\n\t\ts += v[i].r;\n\tfor (int i = 0; i < len(v); i++) {\n\t\tr += v[i].l * (v[i].r + s);\n\t\tif (i + L - 1 < len(v))\n\t\t\ts -= v[i + L - 1].r;\n\t}\n\treturn r;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, L;\n\tv.resize(n);\n\tscan v;\n\tset<Elem> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.insert({v[i], 1, 1, i});\n\tll rez = 0;\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tvector<Elem> t;\n\t\tvector<Elem> buf;\n\t\tint cur = 2e9;\n\t\tfor (auto e : s)\n\t\t\tif (e.value != -1) \n\t\t\t\tcur = min(cur, e.value);\n\t\tfor (auto e : s)\n\t\t\tif (e.value == cur)\n\t\t\t\tt.pb(e);\n\t\tt.pb({(int)-1e9, -1, -1});\n\t\tfor (auto e : t) {\n\t\t\tif (s.find(e) != s.end() && s.find(e) != s.begin() && (buf.empty() || (--s.find(e)) == s.find(buf.back()))) {\n\t\t\t\tbuf.pb(e);\n\t\t\t} else {\n\t\t\t\tvector<Elem> _new(len(buf) / L, {cur + 1, 0, 0, -1});\n\t\t\t\tfor (int i = 0; i < len(_new); i++)\n\t\t\t\t\t_new[i].order = buf[i].order;\n\t\t\t\tif (len(buf) < L) {\n\t\t\t\t\tfor (int i = 0; i < len(buf); i++) {\n\t\t\t\t\t\trez += buf[i].l * buf[i].r;\n\t\t\t\t\t\tif (buf[i].value != -1)\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\tbuf[i].l = buf[i].r = 0;\n\t\t\t\t\t\tbuf[i].value = -1;\n\t\t\t\t\t}\n\t\t\t\t\t_new = buf;\n\t\t\t\t} else {\n\t\t\t\t\tchange = true;\n\t\t\t\t\trez += calc_cost(buf);\t\n\t\t\t\t\tint k = len(buf) % L + 1;\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].l += buf[j].l;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].l += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.l;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].r += buf[j].r;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].r += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.r;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\trez -= calc_cost(_new);\n\t\t\t\t}\n\t\t\t\tfor (auto e : buf)\n\t\t\t\t\ts.erase(e);\n\t\t\t\tfor (auto e : _new)\n\t\t\t\t\ts.insert(e);\n\t\t\t\tbuf.clear();\n\t\t\t\tif (e.value != -1e9)\n\t\t\t\t\tbuf.pb(e);\n\t\t\t}\n\t\t}\n\t\t// for (int i = 0; i < len(s); i++) {\n\t\t// \tprint \"{\", s[i].value, s[i].l, s[i].r, \"}\";\n\t\t// \t// print s[i].value;\n\t\t// \tsmart_io::print_start = \" \";\n\t\t// }\n\t\t// smart_io::print_start = \"\\n\";\n\t\tcur++;\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst int N=2e5+1;\nint n,z;\npair<int,int>a[N];\nint l[N],r[N];\nint sl[N],sr[N],sx[N];\nint sz=0;\ndeque<int>v[2*N];\nvector<ll>pw;\nll ans=0;\nvoid shrink(int vt,int sf){\n\tint ls=v[vt].size()/sf;\n\tfor(int i=0; i<ls ;i++) v[vt][i]=v[vt][(i+1)*sf-1];\n\tv[vt].resize(ls);\n}\nvoid merge(int ml,int mr){\n\tif(sx[mr]<=sx[ml]){\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=r[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sl[ml],pr=sr[ml];\n\t\tint ql=sl[mr],qr=sr[mr];\n\t\tint dl=l[ml],dr=r[mr];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint nxt=dr+1;\n\t\t\tif(i!=v[ql].size()-1) nxt=v[ql][i+1];\n\t\t\tans+=1LL*(nxt-v[ql][i])*(v[pr][x-1]-dl+1);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++) v[pl].push_back(v[ql][i]);\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--) v[pr].push_front(v[qr][i]);\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dr]=sx[dl];\n\t\tsl[dr]=sl[dl];\n\t\tsr[dr]=sr[dl];\n\t}\n\telse{\n\t\tswap(ml,mr);\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=r[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sr[ml],pr=sl[ml];\n\t\tint ql=sr[mr],qr=sl[mr];\n\t\tint dl=l[mr],dr=r[ml];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint nxt=dl-1;\n\t\t\tif(i!=v[ql].size()-1) nxt=v[ql][i+1];\n\t\t\tans+=1LL*(v[ql][i]-nxt)*(dr-v[pr][x-1]+1);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++) v[pl].push_back(v[ql][i]);\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--) v[pr].push_front(v[qr][i]);\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dl]=sx[dr];\n\t\tsl[dl]=sl[dr];\n\t\tsr[dl]=sr[dr];\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> z;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> a[i].fi;\n\t\ta[i].se=i;\n\t}\n\tpw.push_back(1);\n\twhile(pw.back()*z<=n){\n\t\tpw.push_back(pw.back()*z);\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1; i<=n ;i++){\n\t\tint cl=i,cr=i;\n\t\twhile(cr<n && a[cr+1].fi==a[cl].fi) cr++;\n\t\ti=cr;\n\t\tfor(int j=cl; j<=cr ;j++){\n\t\t\tint x=a[j].se;\n\t\t\tl[x]=r[x]=x;\n\t\t\tsx[x]=a[j].fi;\n\t\t\tsl[x]=++sz;v[sz].push_back(x);\n\t\t\tsr[x]=++sz;v[sz].push_back(x);\n\t\t\tif(r[x-1]!=0) merge(x-1,x);\n\t\t\tif(l[x+1]!=0) merge(x,x+1);\n\t\t}\n\t}\n\tcout << ans+n << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*20;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxn];\nint main()\n{\n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<20;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue;\n\t\t\tll sum=0;\n\t\t\tfor(int j=r;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int i=1;i<=k;++i)\n\t\t\t{\n\t\t\t\ttmp[i].l=tmp[i].r=tmp[i-1].l+1;\n\t\t\t\ttmp[i].L=tmp[i].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tsum=0;\n\t\t\tfor(int j=k;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\twhile(k) rec[i+1].push_back(tmp[k--]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, L;\nvector<int> v;\n\nstruct Elem {\n\tint value = 0;\n\tint l = 0, r = 0;\n};\n\nint calc_cost(vector<Elem> v) { \n\tint r = 0;\n\tint s = 0;\n\tfor (int i = L - 1; i < len(v); i++)\n\t\ts += v[i].r;\n\tfor (int i = 0; i < len(v); i++) {\n\t\tr += v[i].l * (v[i].r + s);\n\t\tif (i + L - 1 < len(v))\n\t\t\ts -= v[i + L - 1].r;\n\t}\n\treturn r;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, L;\n\tv.resize(n);\n\tscan v;\n\tvector<Elem> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.pb({v[i], 1, 1});\n\tll rez = 0;\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tvector<Elem> t;\n\t\tvector<Elem> buf;\n\t\tint cur = 2e9;\n\t\tfor (int i = 0; i < len(s); i++)\n\t\t\tif (s[i].value != -1) {\n\t\t\t\tcur = min(cur, s[i].value);\n\t\t\t}\n\t\ts.pb({(int)-1e9, -1, -1});\n\t\tfor (int i = 0; i < len(s); i++) {\n\t\t\tif (s[i].value == cur) {\n\t\t\t\tbuf.pb(s[i]);\t\n\t\t\t} else {\n\t\t\t\tvector<Elem> _new(len(buf) / L, {cur + 1, 0, 0});\n\t\t\t\tif (len(buf) < L) {\n\t\t\t\t\tfor (int i = 0; i < len(buf); i++) {\n\t\t\t\t\t\trez += buf[i].l * buf[i].r;\n\t\t\t\t\t\tif (buf[i].value != -1)\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\tbuf[i].l = buf[i].r = 0;\n\t\t\t\t\t\tbuf[i].value = -1;\n\t\t\t\t\t}\n\t\t\t\t\t_new = buf;\n\t\t\t\t} else {\n\t\t\t\t\tchange = true;\n\t\t\t\t\trez += calc_cost(buf);\t\n\t\t\t\t\tint k = len(buf) % L + 1;\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].l += buf[j].l;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].l += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.l;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].r += buf[j].r;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].r += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.r;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\trez -= calc_cost(_new);\n\t\t\t\t}\n\t\t\t\tt.insert(t.end(), _new.begin(), _new.end());\n\t\t\t\tif (s[i].value != -1e9)\n\t\t\t\t\tt.pb(s[i]);\n\t\t\t\tbuf.clear();\n\t\t\t}\n\t\t}\n\t\tswap(t, s);\n\t\t// for (int i = 0; i < len(s); i++) {\n\t\t// \tprint \"{\", s[i].value, s[i].l, s[i].r, \"}\";\n\t\t// \t// print s[i].value;\n\t\t// \tsmart_io::print_start = \" \";\n\t\t// }\n\t\t// smart_io::print_start = \"\\n\";\n\t\tcur++;\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 5e6 + 5;\n\ntypedef pair<int,int>   ii;\n\nint a[N], t[N];\nint f1[N], f2[N];\nint s1[N], s2[N];\n\nint pre[N];\nint nxt[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int L;  cin >> L;\n\n    priority_queue<ii,vector<ii>,greater<ii> >  pq;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        cin >> a[i];\n        f1[i] = f2[i] = 1;\n        pre[i] = i - 1;\n        nxt[i] = i + 1;\n\n        pq.push(ii(a[i],i));\n    }\n    nxt[n] = 0;\n\n    int tot = n;\n    ll  ans = 0;\n\n    while (pq.size())   {\n        int p = pq.top().Y;\n        int v = pq.top().X;\n\n        pq.pop();\n\n        if (t[p])   continue;\n\n        int l = p;\n        int r = p;\n\n        while (a[pre[l]] == a[l])   l = pre[l];\n        while (a[nxt[r]] == a[r])   r = nxt[r];\n\n        int cnt = 0;\n        int prv = 0;\n\n        for(int i = l ; i != nxt[r] ; t[i] = 1, i = nxt[i]) {\n            cnt++;\n\n            if (i <= n) prv = cnt;\n\n            s1[cnt] = s1[cnt - 1] + f1[i];\n            s2[cnt] = s2[cnt - 1] + f2[i];\n\n            if (prv && cnt >= L)\n                ans += 1ll * f2[i] * s1[min(prv,cnt - L + 1)];\n        }\n        if (cnt < L)    {\n            nxt[pre[l]] = 0;\n            pre[nxt[r]] = 0;\n            continue;\n        }\n        int S = cnt / L;\n\n        for(int i = 1 ; i < S ; ++i)    {\n            nxt[tot + i] = 1 + tot + i;\n            pre[tot + i + 1] = tot + i;\n        }\n        for(int i = 1 ; i <= S ; ++i)\n            a[tot + i] = a[p] + 1;\n\n        nxt[pre[l]] = tot + 1;  pre[tot + 1] = pre[l];\n        pre[nxt[r]] = tot + S;  nxt[tot + S] = nxt[r];\n\n        for(int i = 1 ; i <= S ; ++i)   {\n            int j = S - i + 1;\n\n            f2[tot + i] = s2[min((i + 1) * L - 1,cnt)] - s2[i * L - 1];\n            f1[tot + i] = s1[cnt - j * L + 1] - s1[max(cnt - j * L - L + 1,0)];\n        }\n        pq.push(ii(a[tot + 1],tot + 1));\n        tot += S;\n    }\n    cout << ans + n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n  int  n;\n  long long count=0;\n  long long cc=0;\n  long long  t=0;\n  cin >>n;\n  vector<int> a(n);\n  vector<int> b(n);\n  for(int i=0;i<n;i++){\n    cin>>a.at(i);\n}\n    for(int i=0;i<n;i++){\n    cin>>b.at(i);\n}\n  \n  \n  for(int i=0;i<n;i++){\n    \n    while(a.at(i)!=b.at(i)){\n      \n      if(i==0){t=a.at(n-1)+a.at(0)+a.at(1);\n               a.at(0)=t;\n               count++;\n              }\n    \n    \t else if(i==n-1){t=a.at(n-1)+a.at(n-2)+a.at(0);\n               a.at(n-1)=t;\n               count++;\n              }\n      \n      else{t=a.at(i-1)+a.at(i)+a.at(i+1);\n               a.at(i)=t;\n               count++;\n          }\n  \t\n  \tif(count>1000000000){\n      cout<<\"-1\"<<endl;\n    \texit(0);\n    }\n    \n    \n    \n    \n    }\n  \n  cc+=count;\n    count=0;\n  }\n  cout<<cc<<endl;\n  \n}\n  \n  \n  \n  \n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define pb push_back\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=2e5+5;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nint n,l,a[N];pi b[N];ll res=0;\nll calc(R vector<pi> &v){\n\tR ll res=0,sum=0;\n\tfor(R int i=0,j=l-1,s=v.size();j<s;++i,++j)\n\t\tsum+=v[i].fi,res+=sum*v[j].se;\n\treturn res;\n}\nvector<pair<pi,pi> >f,g;\nint main(){\n\tscanf(\"%d%d\",&n,&l);\n\tfp(i,1,n)scanf(\"%d\",&a[i]),b[i]=pi(a[i],i);\n\tsort(b+1,b+1+n);\n\tres=n;\n\tfor(R int val=0,pos=1;233;f=g){\n\t\tif(f.empty()){\n\t\t\tif(pos>n)break;\n\t\t\tval=b[pos].fi;\n\t\t}else ++val;\n\t\twhile(val==b[pos].fi)f.pb(make_pair(pi(b[pos].se,b[pos].se),pi(1,1))),++pos;\n\t\tg.clear(),sort(f.begin(),f.end());\n\t\tfor(R int i=0,j=0,s=f.size();i<s;i=++j){\n\t\t\twhile(j+1<s&&f[j+1].fi.fi==f[j].fi.se+1)++j;\n\t\t\tR int len=j-i+1,cnt=len/l;\n\t\t\tif(cnt){\n\t\t\t\tvector<pi>tmp,ff,gg;\n\t\t\t\tfp(k,i,j)tmp.pb(f[k].se);\n\t\t\t\tres+=calc(tmp);\n\t\t\t\tfp(k,1,cnt){\n\t\t\t\t\tff.pb(pi(f[i].fi.fi+k-1,(k==cnt)?f[j].fi.se:f[i].fi.fi+k-1));\n\t\t\t\t\tgg.pb(pi(0,0));\n\t\t\t\t}\n\t\t\t\tfp(k,i,j){\n\t\t\t\t\tR int tl=k-i+1,tr=j-k+1;\n\t\t\t\t\tif(tl>=l)gg[tl/l-1].se+=f[k].se.se;\n\t\t\t\t\tif(tr>=l)gg[cnt-tr/l].fi+=f[k].se.fi;\n\t\t\t\t}\n\t\t\t\tres-=calc(gg);\n\t\t\t\tfor(R int k=0;k<cnt;++k)g.pb(make_pair(ff[k],gg[k]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 200100;\n\nint N, L;\nint arr[MAXN];\nbool on[MAXN];\nint lo[MAXN], hi[MAXN];\n\npair <int, int> ord[MAXN];\npair <int, vector <int> > lmap[MAXN], hmap[MAXN]; // maps from the top and bottom\nint ftot[MAXN];\n\npair <int, vector <int> > dv (int nv)\n{\n    pair <int, vector <int> > res;\n    res.first = nv;\n    res.second.push_back(0);\n    return res;\n}\n\npair <int, vector <int> > gv (pair <int, vector <int> > cv, int nv)\n{\n    ll cdiv = 1;\n    for (int i = cv.first; i < nv; i++)\n    {\n        cdiv *= L;\n        if (cdiv > 1e9)\n        {\n            cdiv = 1e9;\n            break;\n        }\n    }\n    pair <int, vector <int> > res;\n    res.first = nv;\n\n    for (int i = 0; i < cv.second.size(); i++)\n    {\n        int fv = cv.second[i];\n        if (fv == 0 || fv >= cdiv)\n        {\n            res.second.push_back(fv/cdiv);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    \n    cin >> N >> L;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> arr[i];\n        ord[i] = make_pair (arr[i], i);\n        on[i] = false;\n    }\n\n    sort (ord, ord + N);\n\n    ll ans = 0;\n    for (int i = 0; i < N; i++)\n    {\n        int cloc = ord[i].second;\n        on[cloc] = true;\n\n        int nlo = cloc;\n        if (cloc > 0 && on[cloc-1])\n            nlo = lo[cloc-1];\n        int nhi = cloc;\n        if (cloc < N - 1 && on[cloc+1])\n            nhi = hi[cloc+1];\n        hi[nlo] = nhi;\n        lo[nhi] = nlo;\n\n        pair <int, vector <int> > lf, lb, rf, rb;\n        lf = dv (arr[cloc]);\n        lb = dv (arr[cloc]);\n        rf = dv (arr[cloc]);\n        rb = dv (arr[cloc]);\n        if (nlo < cloc)\n        {\n            lf = gv (lmap[nlo], arr[cloc]);\n            lb = gv (hmap[cloc-1], arr[cloc]);\n        }\n        if (nhi > cloc)\n        {\n            rf = gv (lmap[cloc+1], arr[cloc]);\n            rb = gv (hmap[nhi], arr[cloc]);\n        }\n\n        for (int x : lb.second)\n        {\n            int ncnt = rf.second.end() - lower_bound(rf.second.begin(), rf.second.end(), L - 1 - x);\n            ans += ncnt;\n        }\n\n        //cout << lf.second.size() << \"\\n\";\n        int nadd = 1 + lf.second.back();\n        for (int x : rf.second)\n            lf.second.push_back(x + nadd);\n        nadd = 1 + rb.second.back();\n        for (int x : lb.second)\n            rb.second.push_back(x + nadd);\n        lmap[nlo] = lf;\n        hmap[nhi] = rb;\n        /*cout << cloc << \"\\n\";\n        for (int x : lmap[nlo].second)\n            cout << x << \" \";\n        cout << \"\\n\";\n        for (int x : hmap[nhi].second)\n            cout << x << \" \";\n        cout << \"\\n\";*/\n    }\n    cout << N + ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\nconst int N=200005;\nint n,l;\nint a[N];\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;\nint pre[N],nxt[N];\nlong long lf[N],rf[N];\nvector<int>now;\nlong long solve(int x)\n{\n\tlong long res=0,sum=0;\n\tint len=now.size();\n\tint ppre=pre[now.front()],nnxt=nxt[now.back()];\n\tfor(int i=0;i<len;i++)\n\t{\n\t\tif(i-l+1>=0) sum+=lf[now[i-l+1]];\n\t\tres+=sum*rf[now[i]];\n\t}\n\tstatic long long tlf[N],trf[N];\n\tfor(int i=0;i<len;i++)\n\t\ttlf[now[i]]=lf[now[i]],trf[now[i]]=rf[now[i]],lf[now[i]]=rf[now[i]]=0;\n\tif(len<l)\n\t{\n\t\tnxt[ppre]=n+1,pre[nnxt]=0;\n\t\treturn res;\n\t}\n\tint num=len/l;\n\tfor(int i=l-1;i<len;i++)\n\t{\n\t\tint p=(i+1)/l-1;\n\t\trf[now[p]]+=trf[now[i]];\n\t}\n\tfor(int i=len-l;i>=0;i--)\n\t{\n\t\tint p=num-(len-i)/l;\n\t\tlf[now[p]]+=tlf[now[i]];\n\t}\n\tnow.resize(num);\n\tfor(int i=1;i<num;i++)\n\t\tpre[now[i]]=now[i-1],nxt[now[i-1]]=now[i];\n\tpre[now.front()]=ppre,nxt[ppre]=now.front();\n\tpre[nnxt]=now.back(),nxt[now.back()]=nnxt;\n\tfor(int p:now)\n\t\tq.push(make_pair(x+1,p));\n\tsum=0;\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tif(i-l+1>=0) sum+=lf[now[i-l+1]];\n\t\tres-=sum*rf[now[i]];\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tq.push(make_pair(a[i],i));\n\t\tpre[i]=i-1,nxt[i]=i+1;\n\t\tlf[i]=rf[i]=1;\n\t}\n\tvector<int>pos;\n\tlong long ans=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top().first;\n\t\tpos.push_back(q.top().second);\n\t\tq.pop();\n\t\twhile(!q.empty()&&q.top().first==x) pos.push_back(q.top().second),q.pop();\n\t\tnow.push_back(pos.front());\n\t\tfor(int i=1;i<pos.size();i++)\n\t\t{\n\t\t\tif(nxt[pos[i-1]]!=pos[i]) ans+=solve(x),now.clear();\n\t\t\tnow.push_back(pos[i]);\n\t\t}\n\t\tans+=solve(x);\n\t\tnow.clear();\n\t\tpos.clear();\n\t}\n\tprintf(\"%lld\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef pair<int,int> pii;\ntypedef long double louble;\n\n#define so(x) ((int)((x).size()))\n#define fi first\n#define se second\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 200007;\n\nint n,lim,val[_];\npii bas[_];\n\ninline lint finder(vector<pii> &v)\n{\n\tlint ans=0,sum=0;\n\tfor(int i=0,j=lim-1;j<so(v);i++,j++)sum+=v[i].fi,ans+=sum*v[j].se;\n\treturn ans;\n}\n\nvector<pair<pii,pii>> f,g;\n// <interval_L, interval_R>, <cntBeingL, cntBeingR>\n\nint main()\n{\n\tn=ty(),lim=ty();\n\tfor(int i=1;i<=n;i++)val[i]=ty(),bas[i]=pii(val[i],i);\n\n\tsort(bas+1,bas+n+1);\n\n\tlint ans=n;\n\tint now=0,pos=1;\n\t\n\twhile(\"pick the smallest values first\")\n\t{\n\t\tif(f.empty()){if(pos>n)break;else now=bas[pos].fi;}\n\t\telse now++;\n\n\t\twhile(pos<=n && bas[pos].fi==now)\n\t\t\tf.emplace_back(pii(bas[pos].se,bas[pos].se),pii(1,1)),pos++;\n\t\tsort(f.begin(),f.end());\n\t\tg.clear();\n\t\t\n\t\tfor(int l=0,r=0;l<so(f);l=r+1)\n\t\t{\n\t\t\tr=l;\n\t\t\twhile(r+1<so(f) && f[r].fi.se+1==f[r+1].fi.fi)r++;\n\t\t\tint len=r-l+1,llen=len/lim;\n\t\t\tif(llen<=0)continue;\n\n\t\t\tvector<pii> temp(len),temp1(llen),temp2(llen,pii(0,0));\n\t\t\tfor(int i=0;i<llen;i++)\n\t\t\t\ttemp1[i]=pii(f[l].fi.fi+i*lim,(i==llen-1)?f[r].fi.se:(f[l].fi.fi+i*lim+lim-1));\n\t\t\tfor(int i=l,ll=1,rr=len;i<=r;i++,ll++,rr--)\n\t\t\t{\n\t\t\t\ttemp[i-l]=f[i].se;\n\t\t\t\tif(ll>=lim)temp2[ll/lim-1].se+=f[i].se.se;\n\t\t\t\tif(rr>=lim)temp2[llen-rr/lim].fi+=f[i].se.fi;\n\t\t\t}\n\t\t\tans+=finder(temp)-finder(temp2);\n\t\t\tfor(int i=0;i<llen;i++)g.emplace_back(temp1[i],temp2[i]);\n\t\t}\n\n\t\tf.swap(g);\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tchar ch=getchar();int f=0;x=0;\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=200005,inf=1e9+99;\nstruct node{\n\tint level,mx;\n\tvi pre,suf;\n\tnode(int _x=inf){\n\t\tlevel=_x,mx=1;\n\t\tif(_x>=0)pre=suf={1};\n\t}\n}stk[N],emp;\nint a[N],n,L,top;\nll ans;\n\nnode merge(node a[],int n){\n\tstatic int sum[N],tot[N];\n\trep(i,1,n)sum[i]=sum[i-1]+a[i].mx;\n\tif(sum[n]<L)return emp;\n\ttot[n+1]=0;\n\tper(i,n,1)tot[i]=tot[i+1]+a[i].pre[0];\n\tfor(int l=1,r=1,q=1;r<=n;l++)\n\t\tper(i,a[l].mx,1){\n\t\t\twhile(l==r)r++,q=1;\n\t\t\twhile(r<=n&&i+sum[r-1]-sum[l]+q<L){\n\t\t\t\tq++;\n\t\t\t\tif(q<=a[r].mx)continue;\n\t\t\t\tr++,q=1;\n\t\t\t}\n\t\t\tif(r<=n){\n\t\t\t\tint A=a[l].suf[i-1]-(i<a[l].mx?a[l].suf[i]:0);\n\t\t\t\tint B=a[r].pre[q-1]+tot[r+1];\n\t\t\t\tans+=(ll)A*B;\n\t\t\t}\n\t\t}\n\tnode res(-1);\n\tres.level=a[1].level+1;\n\tres.mx=sum[n]/L;\n\tres.pre.resize(res.mx);\n\tres.suf.resize(res.mx);\n\tfor(int i=1,cnt=0;i<=n;i++)\n\t\trep(j,1,a[i].mx)\n\t\t\tif(++cnt>=L){\n\t\t\t\tint tmp=a[i].pre[j-1]-(j<a[i].mx?a[i].pre[j]:0);\n\t\t\t\tres.pre[cnt/L-1]+=tmp;\n\t\t\t}\n\tfor(int i=n,cnt=0;i>=1;i--)\n\t\trep(j,1,a[i].mx)\n\t\t\tif(++cnt>=L){\n\t\t\t\tint tmp=a[i].suf[j-1]-(j<a[i].mx?a[i].suf[j]:0);\n\t\t\t\tres.suf[cnt/L-1]+=tmp;\n\t\t\t}\n\tper(i,res.mx-1,1){\n\t\tres.pre[i-1]+=res.pre[i];\n\t\tres.suf[i-1]+=res.suf[i];\n\t}\n\treturn res;\n}\n\nint main(){\n\tread(n),read(L),ans=n;\n\trep(i,1,n)read(a[i]);\n\ta[n+1]=inf;\n\trep(i,1,n){\n\t\tstk[++top]=node(a[i]);\n\t\tint flag=0;\n\t\twhile(flag&&stk[top].level<inf||stk[top].level<a[i+1]){\n\t\t\tint cur=top;\n\t\t\twhile(cur&&stk[cur].level==stk[top].level)\n\t\t\t\tcur--;\n\t\t\tstk[cur+1]=merge(stk+cur,top-cur);\n\t\t\ttop=cur+1;\n\t\t\tif(stk[top].level==inf)flag=1,top--;\n\t\t}\n\t\tif(flag)stk[++top].level=inf;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<set>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=200200;\nint n,L,a[N],pr[N],nx[N],l[N],r[N];\nint vi[N],tl[N],tr[N],p[N];\nll ans;\nstruct cmp{\n\tbool operator()(int x,int y)\n\t\t{return a[x]!=a[y]?a[x]<a[y]:x<y;}\n};\nset<int,cmp>q;\nll calc(int m){\n\tll ret=0,S=0;\n\tFOR(i,1,m){\n\t\tif(i>=L) S+=l[p[i-L+1]];\n\t\tret+=1ll*S*r[p[i]];\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&L);ans=n;\n\tFOR(i,1,n) scanf(\"%d\",&a[i]);\n\tFOR(i,1,n){\n\t\tpr[i]=i-1,nx[i]=i==n?0:i+1;\n\t\tl[i]=r[i]=1;q.insert(i);\n\t}\n\twhile(q.size()){\n\t\tint u=*q.begin(),v,m,t,w=a[u];\n\t\tfor(m=0,v=u;v && a[v]==w;v=nx[v]) \n\t\t\tq.erase(v),p[++m]=v;\n\t\t//FOR(i,1,m) cout<<p[i]<<' ';cout<<'\\n';\n\t\t// FOR(i,1,m) cout<<a[p[i]]<<' ';cout<<'\\n';\n\t\tp[0]=pr[p[1]],p[m+1]=nx[p[m]];\n\t\tans+=calc(m);t=m/L;//cout<<\"ans=\"<<ans<<'\\n';\n\t\tFOR(i,1,t) tl[i]=tr[i]=0;\n\t\tFOR(i,1,m) tr[i/L]+=r[p[i]],tl[t-(m-i+1)/L+1]+=l[p[i]];\n\t\tFOR(i,1,t) p[i]=v=p[(i-1)*L+1],l[v]=tl[i],r[v]=tr[i],a[v]=w+1,q.insert(v);\n\t\tp[t+1]=p[m+1];\n\t\t//FOR(i,1,t) cout<<l[p[i]]<<'-'<<r[p[i]]<<' ';cout<<'\\n';\n\t\tFOR(i,0,t) pr[p[i+1]]=p[i],nx[p[i]]=p[i+1];\n\t\tpr[0]=nx[0]=0;\n\t\tif(!t) nx[p[0]]=pr[p[1]]=0;\n\t\tans-=calc(t);//cout<<\"ans=\"<<ans<<'\\n';\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define pii pair<int,int>\n#define riterator reverse_iterator\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 2e5;\npriority_queue<pii,vector<pii>,greater<pii> > que;\nint nxt[N+3],prv[N+3];\nint a[N+3];\nllong cl[N+3],cr[N+3],cl2[N+3],cr2[N+3];\nvector<int> vec;\nint n,m; llong ans;\n\nvoid solve(int l,int r)\n{\n//\tprintf(\"solve %d %d\\n\",l,r);\n\tllong sum = 0ll;\n\tfor(int i=m-1; i<vec.size(); i++)\n\t{\n\t\tsum += cl[vec[i-m+1]];\n\t\tans += cr[vec[i]]*sum;\n\t}\n\tint cnt = vec.size()/m;\n\tfor(int i=l; i<=l+cnt-1; i++) cl2[i] = cr2[i] = 0ll;\n\tfor(int i=vec.size()-m,j=0,k=l+cnt-1; i>=0; i--)\n\t{\n\t\tcl2[k] += cl[vec[i]];\n\t\tif(j==m-1) {k--,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=m-1,j=0,k=l; i<vec.size(); i++)\n\t{\n\t\tcr2[k] += cr[vec[i]];\n\t\tif(j==m-1) {k++,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=l; i<=l+cnt-1; i++) cl[i] = cl2[i],cr[i] = cr2[i];\n\tsum = 0ll;\n\tfor(int i=l+m-1; i<=l+cnt-1; i++)\n\t{\n\t\tsum += cl[i-m+1];\n\t\tans -= cr[i]*sum;\n\t}\n\tif(cnt==0)\n\t{\n\t\tnxt[prv[l]] = n+1; prv[nxt[r]] = 0;\n\t}\n\telse\n\t{\n\t\tnxt[l+cnt-1] = nxt[r]; prv[nxt[r]] = l+cnt-1;\n\t\tfor(int i=l; i<l+cnt-1; i++) nxt[i] = i+1;\n\t\tfor(int i=l+1; i<=l+cnt-1; i++) prv[i] = i-1;\n\t\tint val = a[l]; for(int i=l; i<=l+cnt-1; i++) a[i] = val+1;\n\t\tfor(int i=l; i<=l+cnt-1; i++) que.push(mkpr(a[i],i));\n\t}\n//\tprintf(\"cnt=%d\\n\",cnt);\n//\tprintf(\"prv: \"); for(int i=1; i<=n+1; i++) printf(\"[%d]%d \",i,prv[i]); puts(\"\");\n//\tprintf(\"nxt: \"); for(int i=0; i<=n; i++) printf(\"[%d]%d \",i,nxt[i]); puts(\"\");\n//\tprintf(\"cl: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cl[i]); puts(\"\");\n//\tprintf(\"cr: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cr[i]); puts(\"\");\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&a[i]),que.push(mkpr(a[i],i)),cl[i] = cr[i] = 1ll,nxt[i] = i+1,prv[i] = i-1;\n\tnxt[0] = 1,prv[n+1] = n;\n\twhile(1)\n\t{\n\t\tint l = que.top().second,r = l; que.pop(); vec.clear(); vec.push_back(l);\n\t\twhile(!que.empty() && que.top().first==a[l] && que.top().second==nxt[r]) {r = nxt[r]; vec.push_back(r); que.pop();}\n\t\tsolve(l,r);\n\t\tif(que.empty()) break;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}\n/*\n4 3\n4 3 4 4\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 400005;\n\nint n, L;\nint tot, a[N], lv[N], rv[N], pr[N], nx[N], vis[N];\nint sl[N], sr[N], ans;\n\nint main() {\n\tread(n), read(L);\n\tstd::priority_queue<std::pair<int, int>> Q;\n\ttot = n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(a[i]);\n\t\tQ.push({-a[i], i});\n\t\tlv[i] = rv[i] = 1;\n\t\tpr[i] = i - 1, nx[i] = i + 1;\n\t\tvis[i] = 0;\n\t}\n\tnx[n] = 0;\n\tlong long ans = 0;\n\twhile (!Q.empty()) {\n\t\tint v = Q.top().second;\n\t\tQ.pop();\n\t\tif (vis[v]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint l = v, r = v, cnt = 1;\n\t\twhile (pr[l] && a[pr[l]] == a[v]) {\n\t\t\tl = pr[l], ++cnt;\n\t\t}\n\t\twhile (nx[r] && a[nx[r]] == a[v]) {\n\t\t\tr = nx[r], ++cnt;\n\t\t}\n\t\tint lst = 0;\n\t\tfor (int i = 1, j = l; i <= cnt; ++i, j = nx[j]) {\n\t\t\tsl[i] = sl[i - 1] + lv[j];\n\t\t\tsr[i] = sr[i - 1] + rv[j];\n\t\t\tif (j <= n) {\n\t\t\t\tlst = i;\n\t\t\t}\n\t\t\tif (lst && i >= L) {\n\t\t\t\tans += 1ll * sl[std::min(i - L + 1, lst)] * rv[j];\n\t\t\t}\n\t\t\tvis[j] = 1;\n\t\t}\n\t\tif (cnt < L) {\n\t\t\tnx[pr[l]] = pr[nx[r]] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint pos = tot + 1;\n\t\tfor (int i = 1; i <= cnt / L; ++i) {\n\t\t\ta[++tot] = a[v] + 1;\n\t\t\trv[tot] = sr[std::min((i + 1) * L - 1, cnt)] - sr[i * L - 1];\n\t\t\tlv[tot] = sl[cnt % L + (i - 1) * L + 1] - sl[std::max(cnt % L + (i - 2) * L + 1, 0)];\n\t\t\tpr[tot] = tot - 1, nx[tot] = tot + 1;\n\t\t}\n\t\tnx[pr[l]] = pos, pr[pos] = pr[l];\n\t\tpr[nx[r]] = tot, nx[tot] = nx[r];\n\t\tQ.push({-a[pos], pos});\n\t}\n\tprint(ans + n);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n  if(abs(a) < eps && abs(b) < eps) return 0;\n  else if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n  if(a < b) return -1;\n  return 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n  if(a < b) return -1;\n  if(a == b) return 0;\n  return 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n  if(na == 0) return 0;\n  int be = 0, en = na - 1;\n  if(*a <= *(a + na - 1)){\n    if(f_lb == 0) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != 1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != -1) en = mid;\n      else be = mid + 1;\n    }\n    if(f_small && jud(*(a + be), val) == 1) be--;\n    if(!f_small && jud(*(a + be), val) == -1) be++;\n  } else {\n    if(f_lb) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != -1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != 1) en = mid;\n      else be = mid + 1;\n    }\n    if(!f_small && jud(*(a + be), val) == -1) be--;\n    if(f_small && jud(*(a + be), val) == 1) be++;\n  }\n  return be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n  if(m < 0) return 0;\n  long long ans = 1;\n  long long k = n;\n  while(m){\n    if(m & 1) {\n      ans *= k;\n      if(mod) ans %= mod;\n    }\n    k *= k;\n    if(mod) k %= mod;\n    m >>= 1;\n  }\n  return ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n  if(mod == -1) mod = MOD;\n  a += b;\n  while(a >= mod) a -= mod;\n  while(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    cerr << arr[i] << ' ';\n  cerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    output1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 200100;\nint n, l;\nint orig[maxn];\nstruct Range {\n  int from, to;\n  vi align_to[2];\n  bool operator < (const Range& other) const {\n    if (from == other.from) {\n      return to < other.to;\n    }\n    return from < other.from;\n  }\n} buf[maxn * 3];\nint lbuf;\nmap<int, vector<int>> all_range;\nint temp[2][maxn], ltemp;\n\n\nint main() {\n  //............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！........................................\n  ios_base::sync_with_stdio(0);\n  #ifdef DEBUG //......................................................................................................\n  freopen(\"input.txt\", \"r\", stdin);\n  #endif //...........................................................................................................\n\n  scanf(\"%d%d\", &n, &l);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", orig + i);\n    buf[lbuf].from = i;\n    buf[lbuf].to = i + 1;\n    buf[lbuf].align_to[0].push_back(0);\n    buf[lbuf].align_to[1].push_back(0);\n    buf[lbuf].align_to[0].push_back(1);\n    buf[lbuf].align_to[1].push_back(1);\n    all_range[orig[i]].push_back(lbuf++);\n  }\n\n  ll ans = 0;\n  for (auto& it : all_range) {\n    vi& all_r = it.second;\n    sort(all_r.begin(), all_r.end(), [&](const int& a, const int& b) {\n      return buf[a] < buf[b];\n    });\n    for (int i = 0, nxt_i = 0; i < (int)all_r.size(); i = nxt_i) {\n      while (nxt_i < (int)all_r.size() - 1 &&\n          buf[all_r[nxt_i + 1]].from == buf[all_r[nxt_i]].to) {\n        nxt_i++;\n      }\n      nxt_i++;\n      ltemp = 1;\n      temp[0][0] = temp[1][0] = 0;\n      for (int j = i; j < nxt_i; j++) {\n        int no = all_r[j];\n        auto rbuf = buf[no];\n        ltemp--;\n        for (int k = 0, rsum = 0; k < (int)rbuf.align_to[0].size(); k++) {\n          temp[0][ltemp] += rbuf.align_to[0][k];\n          temp[1][ltemp++] += rbuf.align_to[1][rbuf.align_to[0].size() - k - 1];\n          if (k >= l) {\n            rsum += rbuf.align_to[1][rbuf.align_to[0].size() - k - 1 + l];\n          }\n          temp[0][ltemp] = temp[1][ltemp] = 0;\n          ans -= 1ll * rbuf.align_to[0][k] * rsum;\n        }\n      }\n      for (int j = l, sum = 0; j < ltemp; j++) {\n        sum += temp[1][j - l];\n        ans += 1ll * temp[0][j] * sum;\n      }\n\n      if (ltemp >= l) {\n        buf[lbuf].from = buf[all_r[i]].from;\n        buf[lbuf].to = buf[all_r[nxt_i - 1]].to;\n        buf[lbuf].align_to[0].push_back(0);\n        buf[lbuf].align_to[1].push_back(0);\n        for (int j = l; j < ltemp; j++) {\n          if (j % l == 0) {\n            buf[lbuf].align_to[0].push_back(0);\n            buf[lbuf].align_to[1].push_back(0);\n          }\n          buf[lbuf].align_to[0].back() += temp[0][j];\n          buf[lbuf].align_to[1].back() += temp[1][ltemp - j - 1];\n        }\n        all_range[it.first + 1].push_back(lbuf++);\n      }\n    }\n  }\n\n  cout << ans + n << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\nint a[1000010];\nstruct Val{\n\tint pos,val;\n\tVal(int a=0,int b=0)\n\t{\n\t\tpos=a;\n\t\tval=b;\n\t}\n};\nbool operator <(const Val& a,const Val& b)\n{\n\treturn a.val>b.val;\n}\npriority_queue<Val>q;\nint pre[2000010],nxt[2000010];\nint f[2000010],g[2000010];\nint sum1[2000010];\nint sum2[2000010];\nbool vis[2000010];\nint main()\n{\n\tlong long ans=0;\n\tint n,L;\n\tscanf(\"%d %d\",&n,&L);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tf[i]=g[i]=1;\n\t\tpre[i]=i-1;\n\t\tnxt[i]=i+1;\n\t\tq.push(Val(i,a[i]));\n\t}\n\tnxt[0]=1;\n\tnxt[n]=0;\n\tint tot=n;\n\twhile(!q.empty())\n\t{\n\t\tint pos=q.top().pos;\n\t\tq.pop();\n\t\tif(vis[pos])continue;\n\t\tint lpos=pos,rpos=pos;\n\t\twhile(a[pre[lpos]]==a[pos])lpos=pre[lpos];\n\t\twhile(a[nxt[rpos]]==a[pos])rpos=nxt[rpos];\n\t\tint cnt=0;\n\t\tint lst=0;\n\t\tfor(int i=lpos;a[i]==a[pos];i=nxt[i])\n\t\t{\n\t\t\tcnt++;\n\t\t\tif(i<=n)lst=i;\n\t\t\tsum1[cnt]=sum1[cnt-1]+f[i];\n\t\t\tsum2[cnt]=sum2[cnt-1]+g[i];\n\t\t\tvis[i]=true;\n\t\t\tif(cnt>=L)\n\t\t\t\tans+=(long long)g[i]*sum1[min(lst,cnt-L+1)];\n\t\t}\n\t\tif(cnt<L){\n\t\t\tnxt[pre[lpos]]=pre[nxt[rpos]]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<cnt/L;i++)\n\t\t{\n\t\t\tnxt[tot+i]=tot+i+1;\n\t\t\tpre[tot+i+1]=tot+i;\n\t\t}\n\t\tfor(int i=1;i<=cnt/L;i++)\n\t\t\ta[tot+i]=a[pos]+1;\n\t\tnxt[pre[lpos]]=tot+1;pre[tot+1]=pre[lpos];\n\t\tpre[nxt[rpos]]=tot+cnt/L;nxt[tot+cnt/L]=nxt[rpos];\n\t\tfor(int i=1;i<=cnt/L;i++)\n\t\t{\n\t\t\tg[tot+i]=sum2[min((i+1)*L-1,cnt)]-sum2[i*L-1];\n\t\t\tint ii=cnt/L-i+1;\n\t\t\tf[tot+i]=sum2[cnt-ii*L+1]-sum2[max(cnt-(ii+1)*L+1,0)];\n\t\t}\n\t\tq.push(Val(tot+1,a[tot+1]));\n\t\ttot+=cnt/L;\n\t\t/*\n\t\tprintf(\"current ans=%lld\\n\",ans);\n\t\tprintf(\"a:\");\n\t\tfor(int i=nxt[0];i;i=nxt[i])\n\t\t\tprintf(\" %d\",a[i]);\n\t\tprintf(\"\\nf:\");\n\t\tfor(int i=nxt[0];i;i=nxt[i])\n\t\t\tprintf(\" %d\",f[i]);\n\t\tprintf(\"\\ng:\");\n\t\tfor(int i=nxt[0];i;i=nxt[i])\n\t\t\tprintf(\" %d\",g[i]);\n\t\tprintf(\"\\n\\n\");\n\t\t*/\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, l, x[MAXN];\npair <int, int> y[MAXN];\nll calc(vector <pair <int, int>> &a) {\n\tll ans = 0, sum = 0;\n\tfor (unsigned i = l - 1, j = 0; i < a.size(); i++, j++) {\n\t\tsum += a[j].first;\n\t\tans += a[i].second * sum;\n\t}\n\treturn ans;\n}\nint main() {\n\tread(n), read(l);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(x[i]);\n\t\ty[i] = make_pair(x[i], i);\n\t}\n\tsort(y + 1, y + n + 1); ll ans = n; int val = 0, pos = 1;\n\tvector <pair <pair <int, int>, pair <int, int>>> a, b;\n\twhile (true) {\n\t\tif (a.empty()) {\n\t\t\tif (pos > n) break;\n\t\t\telse val = y[pos].first;\n\t\t} else val++;\n\t\twhile (val == y[pos].first) a.emplace_back(make_pair(y[pos].second, y[pos].second), make_pair(1, 1)), pos++;\n\t\tb.clear(), sort(a.begin(), a.end());\n\t\tfor (unsigned i = 0, j; i < a.size(); i = j + 1) {\n\t\t\tj = i; while (j + 1 < a.size() && a[j + 1].first.first == a[j].first.second + 1) j++;\n\t\t\tint len = j - i + 1, cnt = len / l;\n\t\t\tif (cnt != 0) {\n\t\t\t\tvector <pair <int, int>> cur, where, value;\n\t\t\t\tfor (unsigned k = i; k <= j; k++)\n\t\t\t\t\tcur.push_back(a[k].second);\n\t\t\t\tans += calc(cur);\n\t\t\t\tfor (int k = 1; k <= cnt; k++) {\n\t\t\t\t\twhere.emplace_back(a[i].first.first + k - 1, (k == cnt) ? a[j].first.second : a[i].first.first + k - 1);\n\t\t\t\t\tvalue.emplace_back(0, 0);\n\t\t\t\t}\n\t\t\t\tfor (unsigned k = i; k <= j; k++) {\n\t\t\t\t\tint tl = k - i + 1, tr = j - k + 1;\n\t\t\t\t\tif (tl >= l) value[tl / l - 1].second += a[k].second.second;\n\t\t\t\t\tif (tr >= l) value[cnt - tr / l].first += a[k].second.first;\n\t\t\t\t}\n\t\t\t\tans -= calc(value);\n\t\t\t\tfor (unsigned k = 0; k < where.size(); k++)\n\t\t\t\t\tb.emplace_back(where[k], value[k]);\n\t\t\t} \n\t\t}\n\t\ta = b;\n\t}\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=2e5+20;\n\n#define pii pair<int,int>\n\nint nxt[maxn],lst[maxn];\n\nint val[maxn],lf[maxn],rf[maxn],vis[maxn],L,tag[maxn];\nint n;\n\npriority_queue<pii,vector<pii>,greater<pii> >q;\n\ninline void init()\n{\n\tn=read();L=read();\n\tREP(i,1,n)val[i]=read();\n\tREP(i,1,n+1)lst[i]=i-1,nxt[i-1]=i,lf[i]=rf[i]=1;\n\tREP(i,1,n)q.push(mkr(val[i],i));\n}\n\nll ans;\n\ninline void doing()\n{\n\twhile(!q.empty())\n\t{\n\t\tstatic int st[maxn],top; top=0;\n\t\tstatic int Lf[maxn],Rf[maxn];\n\t\tint u=q.top().se,VAL=val[u];\n\t\tfor(int i=u;i<=n && val[i]==val[u];i=nxt[i])\n\t\t\tst[++top]=i,tag[i]=1;\n\t\twhile(!q.empty() && tag[q.top().se])q.pop();\n\t\tll sumlf=0;\n\t\tint j=1,Lst=0;\n\t\tREP(i,1,top)if(!vis[st[i]])ans++;\n\t\tREP(i,1,top)\n\t\t{\n\t\t\tif(!vis[st[i]])Lst=i;\n\t\t\twhile(j<=Lst && j<=i-L+1)\n\t\t\t\tsumlf+=lf[st[j++]];\n\t\t\tans+=sumlf*rf[st[i]];\n\t\t}\n\t\tint num=top/L;\n\t\tif(num)\n\t\t{\n\t\t\tREP(i,1,num)\n\t\t\t{\n\t\t\t\tRf[i]=0;\n\t\t\t\tREP(j,L*i,min(L*i+L-1,top))Rf[i]+=rf[st[j]];\n\t\t\t}\n\t\t\tREP(i,1,num)\n\t\t\t{\n\t\t\t\tLf[num-i+1]=0;\n\t\t\t\tDREP(j,top-L*i+1,max(top-L*i-L+2,1))Lf[num-i+1]+=lf[st[j]];\n\t\t\t}\n\t\t\tnxt[st[num]]=nxt[st[top]];\n\t\t\tlst[nxt[st[top]]]=st[num];\n\t\t\tREP(j,1,num)tag[st[j]]=0,vis[st[j]]=1,val[st[j]]=VAL+1,lf[st[j]]=Lf[j],rf[st[j]]=Rf[j],q.push(mkr(VAL+1,st[j]));\n\t\t}else nxt[lst[st[1]]]=n+1;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define last last2\n\nusing namespace std;\n\ntypedef long long ll;\n\nint num[200005],n,L;\nll ans;\n\nnamespace SGT {\n\nint maxv[800000];\n\nvoid build(int l,int r,int o) {\n  if (l==r) maxv[o]=l;\n  else {\n  \tint m=((l+r)>>1);\n    build(l,m,o*2);\n    build(m+1,r,o*2+1);\n    maxv[o]=((num[maxv[o*2]]>=num[maxv[o*2+1]])?maxv[o*2]:maxv[o*2+1]);\n  }\n}\n\nint query(int l,int r,int o,int lx,int rx) {\n  if (l>=lx&&r<=rx) return maxv[o];\n  else {\n  \tint m=((l+r)>>1);\n  \tif (m>=rx) return query(l,m,o*2,lx,rx);\n  \tif (m<lx) return query(m+1,r,o*2+1,lx,rx);\n  \tint a=query(l,m,o*2,lx,rx),b=query(m+1,r,o*2+1,lx,rx);\n  \treturn (num[a]>=num[b])?a:b;\n  }\n}\n\n}\n\nint nxt[200005],powd[200005];\nmap <int,int> last;\n\nvoid pre() {\n  static int last[200005];\n  powd[0]=1;\n  for(int i=1;i<=n;i++) powd[i]=min((ll)powd[i-1]*L,n+1LL);\n  for(int i=n;i>0;i--) {\n  \tnxt[i]=((last[num[i]])?last[num[i]]:n+1);\n  \tlast[num[i]]=i;\n  } \n}\n\nvector <int> suml[200005],sumr[200005];\nvector <int> pos[200005],son[200005];\nint size[200005],lsize[200005],rsize[200005];\nint val[200005],tot;\n\nvoid calc(int o,int d) {\n  static int sum[200005];\n  if (d>n||powd[d]>n) {\n  \tsize[o]=-1;\n  \tsuml[o].resize(1);sumr[o].resize(1);\n  \tlsize[o]=rsize[o]=0;\n  \treturn;\n  }\n  size[o]=((size[o]>=powd[d])?size[o]/powd[d]:-1);\n  if (lsize[o]) {\n  \tfor(int i=1;i<=lsize[o];i++) sum[i]=0;\n    int cnt=0,maxn=0;\n    for(int i=powd[d];i<=lsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=suml[o][i];\n    }\n    lsize[o]=maxn;\n    suml[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) suml[o][i]=sum[i];\n  }\n  if (rsize[o]) {\n  \tfor(int i=1;i<=rsize[o];i++) sum[i]=0;\n    int cnt=0,maxn=0;\n    for(int i=powd[d];i<=rsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=sumr[o][i];\n    }\n    rsize[o]=maxn;\n    sumr[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) sumr[o][i]=sum[i];\n  }\n}\n\nint solve(int l,int r) {\n  static int q[200005];\n  int o=++tot;\n  for(int i=SGT::query(1,n,1,l,r);i<=r;i=nxt[i]) \n    pos[o].push_back(i);\n  val[o]=num[pos[o][0]];\n  son[o].resize(pos[o].size()+1);\n  if (pos[o][0]>l) son[o][0]=solve(l,pos[o][0]-1);\n  for(int i=1;i<pos[o].size();i++)\n    if (pos[o][i]>pos[o][i-1]+1) son[o][i]=solve(pos[o][i-1]+1,pos[o][i]-1);\n  if (pos[o][pos[o].size()-1]<r) son[o][son[o].size()-1]=solve(pos[o][pos[o].size()-1]+1,r);\n  for(int i=0;i<son[o].size();i++)\n    if (son[o][i]) calc(son[o][i],val[o]-val[son[o][i]]);\n  int rx=0,lx=0;\n  for(int i=rsize[son[o][0]];i>0;i--) q[++rx]=sumr[son[o][0]][i];\n  int s=0;\n  for(int i=0;i<pos[o].size();i++) {\n  \tq[++rx]=1;\n  \twhile (lx<rx&&rx-lx>=L) s+=q[++lx];\n  \tans+=s;\n  \tif (son[o][i+1]) {\n  \t\tint u=son[o][i+1];\n  \t\tfor(int j=1;j<=lsize[u];j++) {\n  \t\t\twhile (lx<rx&&rx-lx+j>=L) s+=q[++lx];\n  \t\t\tans+=(ll)s*suml[u][j];\n\t\t  }\n\t\tif (size[u]==-1) lx=rx,s=0;\n\t\tfor(int j=rsize[u];j>0;j--) q[++rx]=sumr[u][j];\n\t  }\n  }\n  bool v=1;\n  int sz=pos[o].size();\n  for(int i=0;i<son[o].size();i++)\n    if (size[son[o][i]]==-1) v=0; else sz+=size[son[o][i]];\n  size[o]=((v)?sz:-1);\n  suml[o].resize(1);\n  for(int i=0;i<son[o].size();i++) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=lsize[u];j++) suml[o].push_back(suml[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i+1<son[o].size()) suml[o].push_back(1);\n  }\n  lsize[o]=suml[o].size()-1;\n  sumr[o].resize(1);\n  for(int i=son[o].size()-1;i>=0;i--) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=rsize[u];j++) sumr[o].push_back(sumr[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i) sumr[o].push_back(1);\n  }\n  rsize[o]=sumr[o].size()-1;\n  return o;\n}\n\nint main() {\n  scanf(\"%d%d\",&n,&L);\n  for(int i=1;i<=n;i++) scanf(\"%d\",&num[i]);\n  pre();\n  SGT::build(1,n,1);\n  solve(1,n);\n  printf(\"%lld\\n\",ans+n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 200005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\ntypedef pair <P,P> PP;\n\nint A[SIZE];\n\nll solve(vector <P> vec,int L)\n{\n\tint n=vec.size();\n\tll ret=0,sum=0;\n\tfor(int i=L-1;i<n;i++)\n\t{\n\t\tsum+=vec[i-L+1].first;\n\t\tret+=sum*vec[i].second;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint n,L;\n\tscanf(\"%d %d\",&n,&L);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&A[i]);\n\tif(L==1)\n\t{\n\t\tprintf(\"%lld\\n\",(ll) n*(ll) (n+1)/2);\n\t\treturn 0;\n\t}\n\tvector <P> all;\n\tfor(int i=0;i<n;i++) all.push_back(P(A[i],i));\n\tsort(all.begin(),all.end());\n\tint now=-1,pos=0;\n\tvector <PP> vec;\n\tll ret=n;\n\twhile(1)\n\t{\n\t\tif(vec.empty())\n\t\t{\n\t\t\tif(pos==all.size()) break;\n\t\t\tnow=all[pos].first;\n\t\t}\n\t\twhile(pos<all.size()&&all[pos].first==now)\n\t\t{\n\t\t\tint v=all[pos++].second;\n\t\t\tvec.push_back(PP(P(v,v),P(1,1)));\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\t//printf(\"%d : \",now);\n\t\t//for(int i=0;i<vec.size();i++) printf(\"[%d %d : %d %d] \",vec[i].first.first,vec[i].first.second,vec[i].second.first,vec[i].second.second);puts(\"\");\n\t\tvector <PP> nxt;\n\t\tfor(int i=0;i<vec.size();)\n\t\t{\n\t\t\tint f=i++;\n\t\t\tfor(;i<vec.size()&&vec[i].first.first==vec[i-1].first.second+1;i++);\n\t\t\tvector <P> now;\n\t\t\tfor(int j=f;j<i;j++) now.push_back(vec[j].second);\n\t\t\tif(now.size()>=L)\n\t\t\t{\n\t\t\t\tret+=solve(now,L);\n\t\t\t\tint c=now.size()/L;\n\t\t\t\tvector <P> v1,v2;\n\t\t\t\tfor(int j=0;j<c;j++)\n\t\t\t\t{\n\t\t\t\t\tint s=vec[f].first.first+j,t=s;\n\t\t\t\t\tif(j==c-1) t=vec[i-1].first.second;\n\t\t\t\t\tv1.push_back(P(s,t));\n\t\t\t\t\tv2.push_back(P(0,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=f;j<i;j++)\n\t\t\t\t{\n\t\t\t\t\tint l=j-f+1,r=i-j;\n\t\t\t\t\tif(l>=L)\n\t\t\t\t\t{\n\t\t\t\t\t\tv2[l/L-1].second+=vec[j].second.second;\n\t\t\t\t\t}\n\t\t\t\t\tif(r>=L)\n\t\t\t\t\t{\n\t\t\t\t\t\tv2[c-r/L].first+=vec[j].second.first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret-=solve(v2,L);\n\t\t\t\tfor(int j=0;j<c;j++) nxt.push_back(PP(v1[j],v2[j]));\n\t\t\t}\n\t\t}\n\t\tvec=nxt;\n\t\tnow++;\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 17.08.2019 16:20:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    // don't forget to set default value (used for leaves)\n    // not necessarily neutral element!\n    int sum = 0;\n\n    void apply(int l, int r, int v, bool SET = false) {\n      if (SET) {\n        sum = v;\n      } else {\n        sum += v;\n      }\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.sum = a.sum + b.sum;\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> vals;\n  for (int i = 0; i < n; i++) {\n    vals.push_back(a[i]);\n  }\n  sort(vals.begin(), vals.end());\n  vals.resize(unique(vals.begin(), vals.end()) - vals.begin());\n  segtree segt((int) vals.size());\n  auto Modify = [&](int at, int delta, bool SET = false) {\n    auto it = lower_bound(vals.begin(), vals.end(), at);\n    assert(it != vals.end() && *it == at);\n    int pos = (int) (it - vals.begin());\n    segt.modify(pos, pos, delta, SET);\n  };\n  vector<int> st;\n  vector<int> ends;\n  vector<int> good;\n  long long ans = 0;\n  map<int, int> how_many;\n  map<int, set<int>> at;\n  set<pair<int, int>> segs;\n  for (int itt = 0; itt < n; itt++) {\n    int x = a[itt];\n    while (!st.empty() && x > st.back()) {\n      int val = st.back();\n      int cnt = 0;\n      for (int j = (int) st.size() - 1; j >= 0; j--) {\n        if (st[j] != val) {\n          break;\n        }\n        ++cnt;\n      }\n      if (cnt < k) {\n        for (int y : st) {\n          Modify(y, 0, true);\n        }\n        st.clear();\n        ends.clear();\n        good.clear();\n        how_many.clear();\n        at.clear();\n        break;\n      }\n      for (int i = 0; i < k - 1; i++) {\n        if (good.back()) {\n          Modify(st.back(), -ends.back());\n        }\n        st.pop_back();\n        ends.pop_back();\n        good.pop_back();\n        --cnt;\n      }\n      vector<int> to_push;\n      while (cnt > 0) {\n        int sum = 0;\n        for (int i = 0; i < k && cnt > 0; i++) {\n          sum += ends.back();\n          if (good.back()) {\n            Modify(st.back(), -ends.back());\n          }\n          st.pop_back();\n          ends.pop_back();\n          good.pop_back();\n          --cnt;\n        }\n        to_push.push_back(sum);\n      }\n      while (!to_push.empty()) {\n        st.push_back(val + 1);\n        ends.push_back(to_push.back());\n        good.push_back(0);\n        at[st.back()].insert((int) st.size() - 1);\n        to_push.pop_back();\n      }\n      at[val].clear();\n      assert(how_many[val] >= k);\n      how_many.erase(val);\n      auto it = segs.lower_bound({val + 1, -1});\n      assert(it != segs.begin());\n      --it;\n      auto p = *it;\n      assert(p.first <= val && val <= p.second);\n      segs.erase(it);\n      if (p.first < val) {\n        segs.emplace(p.first, val - 1);\n      }\n      if (val < p.second) {\n        segs.emplace(val + 1, p.second);\n      }\n    }\n    while ((int) at[x].size() >= k) {\n      int pos = *at[x].begin();\n      at[x].erase(at[x].begin());\n      Modify(x, ends[pos]);\n      good[pos] = 1;\n    }\n    st.push_back(x);\n    ends.push_back(1);\n    good.push_back(0);\n    at[st.back()].insert((int) st.size() - 1);\n    int ptr = x;\n    while (true) {\n      int u = ++how_many[ptr];\n      if (u == k) {\n        int val = ptr;\n        int L = val;\n        int R = val;\n        auto it = segs.lower_bound({val + 1, -1});\n        if (it != segs.end() && it->first == val + 1) {\n          R = it->second;\n          it = segs.erase(it);\n        }\n        if (it != segs.begin() && prev(it)->second == val - 1) {\n          L = prev(it)->first;\n          segs.erase(prev(it));\n        }\n        segs.emplace(L, R);\n      }\n      if (u >= k) {\n        if (!at[ptr].empty()) {\n          int pos = *at[ptr].begin();\n          at[ptr].erase(at[ptr].begin());\n          Modify(ptr, ends[pos]);\n          good[pos] = 1;\n        }\n      }\n      if (u % k == 0) {\n        ++ptr;\n      } else {\n        break;\n      }\n    }\n    int val = x;\n    auto it = segs.lower_bound({val + 1, -1});\n    int up_to = x;\n    if (it != segs.begin()) {\n      --it;\n      auto p = *it;\n      if (p.first <= val && val <= p.second) {\n        up_to = p.second + 1;\n      }\n    }\n    int z = (int) (lower_bound(vals.begin(), vals.end(), up_to + 1) - vals.begin());\n    long long real_total = (z == 0 ? 0 : segt.get(0, z - 1).sum);\n    ans += real_total + 1;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,l,a[200005];\nvector<int>za;\nvector<int>pos[200005];\n\nbool in[200005];\nint par[200005][2],ran[200005];\nvoid init(){ for(int i=0;i<200005;i++) par[i][0] = par[i][1] = i; }\nint find(int x,int a){\n\tif(x == par[x][a]) return x;\n\telse return par[x][a] = find(par[x][a],a); \n}\nvoid unite(int x,int y){\n\tx = find(x,0); y = find(y,0);\n\tif(x != y){\n\t\tif(x < y) par[y][0] = x;\n\t\telse par[x][0] = y;\n\t}\n\tx = find(x,1); y = find(y,1);\n\tif(x != y){\n\t\tif(x > y) par[y][1] = x;\n\t\telse par[x][1] = y;\n\t}\n}\n\nmap<P,vector<P>>dp;\nmap<P,int>mx;\nvector<P>query[200005];\nll ans;\npair<pair<vector<int>,vector<int>>,int>rec(int L,int R){\n\tif(L > R){\n\t\tvector<int>vi; vi.pb(1);\n\t\treturn mp(mp(vi,vi),-100);\n\t}\n\tvector<pair<pair<vector<int>,vector<int>>,int>>ret;\n\tvector<vector<int>>ruirui;\n\n\tSORT(dp[mp(L,R)]);\n\tvector<int>rui,rui2;\n\tint cur_v = 0, cur_v2 = 0;\n\tvector<int>forbid;\n\tfor(auto x:dp[mp(L,R)]){\n\t\tret.pb(rec(x.fi,x.sc));\n\t\tint dif = mx[mp(L,R)]-ret.back().sc;\n\t\tll dv = 1;\n\t\trep(q,dif) { dv = dv*l; if(dv >= mod) { dv = mod; break; }}\n\t\tint DV = (int)(dv);\n\t\tcur_v += (ret.back().fi.fi.size()-1) / dv + 1;\n\t\tvector<int>hoge; int sum = 0;\n\t\tfor(int i=0;i<ret.back().fi.fi.size();i++){\n\t\t\tsum += ret.back().fi.fi[i];\n\t\t\thoge.pb(sum);\n\t\t}\n\t\tfor(int i=0;i<ret.back().fi.fi.size();i++){\n\t\t\tif(i && i<dv) continue;\n\t\t\tif(i==0 && ret.size() >= 2) continue;\n\t\t\tcur_v2 += ret.back().fi.fi[i];\n\t\t}\n\t\tif(ret.back().fi.fi.size() >= 2 && ret.back().fi.fi.size() <= dv && ret.size() >= 2) forbid.pb(ret.size()-2);\n\t\tcur_v2 ++;\n\t\trui.pb(cur_v);\n\t\trui2.pb(cur_v2);\n\t\t//cout << cur_v2 << ret.size() << L << R << endl;\n\t\truirui.pb(hoge);\n\t}\n\t//if(L == 1 && R == 8) cout << ret.size() << \" \" << rui.size() << \" \" << rui2.size() << \" \" << ruirui.size() << endl;\n\tassert(rui.size() >= 1 && rui2.size() >= 1);\n\trui.back()--; rui2.back()--;\n\tint nxt = 0;\n\tfor(int i=0;i<ret.size();i++){\n\t\tint dif = mx[mp(L,R)]-ret[i].sc;\n\t\tll dv = 1;\n\t\trep(q,dif) { dv = dv*l; if(dv >= mod) { dv = mod; break; }}\n\t\tint DV = (int)(dv); //if(L==1&&R==8) cout << DV << endl;\n\t\tnxt = max(nxt,i);\n\t\tassert(ret[i].fi.sc.size());\n\t\tfor(int j=ret[i].fi.sc.size()-1;j>=0;j--){\n\t\t\tif(j && j<dv) continue;\n\t\t\tll coef = ret[i].fi.sc[j];\n\t\t\tint num = j/dv+1;\n\t\t\twhile(nxt < rui.size() && rui[nxt]-rui[i]+num < l) nxt++;\n\t\t\tif(nxt == rui.size()) break;\n\t\t\tif(nxt == i){\n\t\t\t\tint a = POSL(forbid,i);\n\t\t\t\tint x = rui2.size()-1;\n\t\t\t\tif(a < forbid.size()) x = forbid[a];\n\t\t\t\tans += 1LL * coef * (rui2[x]-rui2[i]+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint a = POSL(forbid,i);\n\t\t\t\tint x = rui2.size()-1;\n\t\t\t\tif(a < forbid.size()) x = forbid[a];\n\t\t\t\t//cout << L << R << x << nxt << endl;\n\t\t\t\tif(x >= nxt) ans += 1LL * coef * (rui2[x]-rui2[nxt]+1);\n\t\t\t\t//cout<<ans<<endl;\n\t\t\t\tint cur = rui[nxt-1]-rui[i]+num; assert(l > cur);\n\t\t\t\tint need = l-cur;\n\t\t\t\tll beg = min(1LL*mod,1LL*need*dv);\n\t\t\t\tif(beg < ret[nxt].fi.fi.size()) ans += 1LL * coef * (ruirui[nxt][ret[nxt].fi.fi.size()-1] - ruirui[nxt][beg-1]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>le,ri;\n\tfor(int i=0;i<ret.size();i++){\n\t\tint dif = mx[mp(L,R)]-ret[i].sc;\n\t\tll dv = 1;\n\t\trep(q,dif) { dv = dv*l; if(dv >= mod) { dv = mod; break; }}\n\t\tint DV = (int)(dv);\n\t\tassert(ret[i].fi.fi.size());\n\t\tint num = (ret[i].fi.fi.size()-1) / dv;\n\t\tif(num == 0){\n\t\t\tle.pb(1);\n\t\t\tif(ret[i].fi.fi.size() >= 2) break;\n\t\t}\n\t\telse{\n\t\t\tle.pb(1);\n\t\t\tint cnt = 0;\n\t\t\tfor(int ii=dv;ii<ret[i].fi.fi.size();ii++){\n\t\t\t\tcnt += ret[i].fi.fi[ii];\n\t\t\t\tif(ii%dv == dv-1 || ii+1 == ret[i].fi.fi.size()){\n\t\t\t\t\tle.pb(cnt); cnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=ret.size()-1;i>=0;i--){\n\t\tint dif = mx[mp(L,R)]-ret[i].sc;\n\t\tll dv = 1;\n\t\trep(q,dif) { dv = dv*l; if(dv >= mod) { dv = mod; break; }}\n\t\tint DV = (int)(dv);\n\t\tint num = (ret[i].fi.sc.size()-1) / dv;\n\t\tassert(ret[i].fi.sc.size());\n\t\tif(num == 0){\n\t\t\tri.pb(1);\n\t\t\tif(ret[i].fi.sc.size() >= 2) break;\n\t\t}\n\t\telse{\n\t\t\tri.pb(1);\n\t\t\tint cnt = 0;\n\t\t\tfor(int ii=dv;ii<ret[i].fi.sc.size();ii++){\n\t\t\t\tcnt += ret[i].fi.sc[ii];\n\t\t\t\tif(ii%dv == dv-1 || ii+1 == ret[i].fi.sc.size()){\n\t\t\t\t\tri.pb(cnt); cnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*cout << L << \" \" << R << endl;\n\tcout << \"=======\" << endl;\n\trep(i,le.size()) cout << le[i] << \" i \" << endl;\n\tcout << \"=======\" << endl;\n\trep(i,ri.size()) cout << ri[i] << \" j \" << endl;\n\tcout << \"=======\" << endl;*/\n\t//cout << L << \"  \" << R << \" \" << ans << endl;\n\treturn mp(mp(le,ri),mx[mp(L,R)]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tza.pb(a[i]);\n\t}\n\tinit();\n\tSORT(za); ERASE(za);\n\tfor(int i=1;i<=n;i++){\n\t\tint x = POSL(za,a[i]);\n\t\tpos[x].pb(i);\n\t}\n\tfor(int i=0;i<za.size();i++){\n\t\tfor(int j=0;j<pos[i].size();j++){\n\t\t\tin[pos[i][j]] = 1;\n\t\t}\n\t\tfor(int j=0;j<pos[i].size();j++){\n\t\t\tint x = pos[i][j];\n\t\t\tif(in[x-1]) unite(x-1,x);\n\t\t\tif(in[x+1]) unite(x,x+1);\n\t\t}\n\t\tset<int>S;\n\t\tfor(int j=0;j<pos[i].size();j++){\n\t\t\tint hoge = find(pos[i][j],0);\n\t\t\tint hoge2 = find(pos[i][j],1);\n\t\t\tquery[hoge].pb(mp(pos[i][j],hoge2));\n\t\t\tS.insert(hoge);\n\t\t}\n\t\tfor(auto le:S){\n\t\t\tint pre = -1;\n\t\t\trep(x,query[le].size()){\n\t\t\t\tif(pre == -1) pre = query[le][x].sc;\n\t\t\t\telse assert(pre == query[le][x].sc);\n\t\t\t}\n\t\t\tint ri = pre;\n\t\t\tassert(le <= ri);\n\t\t\tmx[mp(le,ri)] = za[i];\n\t\t\tdp[mp(le,ri)].pb(mp(query[le].back().fi+1,ri));\n\t\t\tfor(int x=query[le].size()-1;x>=0;x--){\n\t\t\t\tint R = query[le][x].fi-1;\n\t\t\t\tint L = (x?query[le][x-1].fi+1:le);\n\t\t\t\tdp[mp(le,ri)].pb(mp(L,R));\n\t\t\t}\n\t\t}\n\t\tfor(auto le:S) query[le].clear();\n\t}\n\trec(1,n);\n\tcout << ans+n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define last last2\n\nusing namespace std;\n\ntypedef long long ll;\n\nint num[200005],n,L;\nll ans;\n\nnamespace SGT {\n\nint maxv[800000];\n\nvoid build(int l,int r,int o) {\n  if (l==r) maxv[o]=l;\n  else {\n  \tint m=((l+r)>>1);\n    build(l,m,o*2);\n    build(m+1,r,o*2+1);\n    maxv[o]=((num[maxv[o*2]]>=num[maxv[o*2+1]])?maxv[o*2]:maxv[o*2+1]);\n  }\n}\n\nint query(int l,int r,int o,int lx,int rx) {\n  if (l>=lx&&r<=rx) return maxv[o];\n  else {\n  \tint m=((l+r)>>1);\n  \tif (m>=rx) return query(l,m,o*2,lx,rx);\n  \tif (m<lx) return query(m+1,r,o*2+1,lx,rx);\n  \tint a=query(l,m,o*2,lx,rx),b=query(m+1,r,o*2+1,lx,rx);\n  \treturn (num[a]>=num[b])?a:b;\n  }\n}\n\n}\n\nint nxt[200005],powd[200005];\n\nvoid pre() {\n  static int last[200005];\n  powd[0]=1;\n  for(int i=1;i<=n;i++) powd[i]=min((ll)powd[i-1]*L,n+1LL);\n  for(int i=n;i>0;i--) {\n  \tnxt[i]=((last[num[i]])?last[num[i]]:n+1);\n  \tlast[num[i]]=i;\n  } \n}\n\nvector <int> suml[200005],sumr[200005];\nvector <int> pos[200005],son[200005];\nint size[200005],lsize[200005],rsize[200005];\nint val[200005],tot;\n\nvoid calc(int o,int d) {\n  static int sum[200005];\n  size[o]=((size[o]>=powd[d])?size[o]/powd[d]:-1);\n  if (lsize[o]) {\n  \tfor(int i=1;i<=lsize[o];i++) sum[i]=0;\n    int cnt=0,maxn=0;\n    for(int i=powd[d];i<=lsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=suml[o][i];\n    }\n    lsize[o]=maxn;\n    suml[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) suml[o][i]=sum[i];\n  }\n  if (rsize[o]) {\n  \tfor(int i=1;i<=rsize[o];i++) sum[i]=0;\n    int cnt=0,maxn=0;\n    for(int i=powd[d];i<=rsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=sumr[o][i];\n    }\n    rsize[o]=maxn;\n    sumr[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) sumr[o][i]=sum[i];\n  }\n}\n\nint solve(int l,int r) {\n  static int q[200005];\n  int o=++tot;\n  for(int i=SGT::query(1,n,1,l,r);i<=r;i=nxt[i]) \n    pos[o].push_back(i);\n  val[o]=num[pos[o][0]];\n  son[o].resize(pos[o].size()+1);\n  if (pos[o][0]>l) son[o][0]=solve(l,pos[o][0]-1);\n  for(int i=1;i<pos[o].size();i++)\n    if (pos[o][i]>pos[o][i-1]+1) son[o][i]=solve(pos[o][i-1]+1,pos[o][i]-1);\n  if (pos[o][pos[o].size()-1]<r) son[o][son[o].size()-1]=solve(pos[o][pos[o].size()-1]+1,r);\n  for(int i=0;i<son[o].size();i++)\n    if (son[o][i]) calc(son[o][i],val[o]-val[son[o][i]]);\n  /*int rx=0,lx=0;\n  for(int i=rsize[son[o][0]];i>0;i--) q[++rx]=sumr[son[o][0]][i];\n  int s=0;\n  for(int i=0;i<pos[o].size();i++) {\n  \tq[++rx]=1;\n  \twhile (lx<rx&&rx-lx>=L) s+=q[++lx];\n  \tans+=s;\n  \tif (son[o][i+1]) {\n  \t\tint u=son[o][i+1];\n  \t\tfor(int j=1;j<=lsize[u];j++) {\n  \t\t\twhile (lx<rx&&rx-lx+j>=L) s+=q[++lx];\n  \t\t\tans+=(ll)s*suml[u][j];\n\t\t  }\n\t\tif (size[u]==-1) lx=rx,s=0;\n\t\tfor(int j=rsize[u];j>0;j--) q[++rx]=sumr[u][j];\n\t  }\n  }*/\n  bool v=1;\n  int sz=pos[o].size();\n  for(int i=0;i<son[o].size();i++)\n    if (size[son[o][i]]==-1) v=0; else sz+=size[son[o][i]];\n  size[o]=((v)?sz:-1);\n  suml[o].resize(1);\n  for(int i=0;i<son[o].size();i++) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=lsize[u];j++) suml[o].push_back(suml[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i+1<son[o].size()) suml[o].push_back(1);\n  }\n  lsize[o]=suml[o].size()-1;\n  sumr[o].resize(1);\n  for(int i=son[o].size()-1;i>=0;i--) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=rsize[u];j++) sumr[o].push_back(sumr[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i) sumr[o].push_back(1);\n  }\n  rsize[o]=sumr[o].size()-1;\n  return o;\n}\n\nint main() {\n  scanf(\"%d%d\",&n,&L);\n  for(int i=1;i<=n;i++) scanf(\"%d\",&num[i]);\n  pre();\n  SGT::build(1,n,1);\n  solve(1,n);\n  printf(\"%lld\\n\",ans+n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tchar ch=getchar();int f=0;x=0;\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=200005,inf=1e9+99;\nstruct node{\n\tint level,mx;\n\tvi pre,suf;\t\t\t//pre[i] 前缀至少有 i + 1 个的右端点数量\n\tnode(int _x=inf){\n\t\tlevel=_x,mx=1;\n\t\tif(_x>=0)pre=suf={1};\n\t}\n\tvoid Assert(){\n\t\tassert(pre.size()==mx&&pre[mx-1]);\n\t\tassert(suf.size()==mx&&suf[mx-1]);\n\t}\n}stk[N],emp;\nint a[N],n,L,top;\nll ans;\n\nnode merge(node a[],int n){\n/*\n\tputs(\"==================\\nmerge: \");\n\trep(i,1,n){\n\t\tprintf(\"a[%d] = {%d, %d, { \",i,a[i].level,a[i].mx);\n\t\tfor(auto x:a[i].pre)printf(\"%d \",x);\n\t\tprintf(\"}, { \");\n\t\tfor(auto x:a[i].suf)printf(\"%d \",x);\n\t\tputs(\"}}\");\n\t}\n\tll las=ans;\n*/\n\tstatic int sum[N],tot[N];\n\trep(i,1,n)sum[i]=sum[i-1]+a[i].mx;\n\tif(sum[n]<L)return emp;\n\ttot[n+1]=0;\n\tper(i,n,1)tot[i]=tot[i+1]+a[i].pre[0];\n\tfor(int l=1,r=1,q=1;r<=n;l++)\n\t\tper(i,a[l].mx,1){\n\t\t\twhile(l==r)r++,q=1;\n\t\t\twhile(r<=n&&i+sum[r-1]-sum[l]+q<L){\n\t\t\t\tq++;\n\t\t\t\tif(q<=a[r].mx)continue;\n\t\t\t\tr++,q=1;\n\t\t\t}\n\t\t\tif(r<=n){\n\t\t\t\tint A=a[l].suf[i-1]-(i<a[l].mx?a[l].suf[i]:0);\n\t\t\t\tint B=a[r].pre[q-1]+tot[r+1];\n//\t\t\t\tprintf(\"# %d %d   %d %d   %d\\n\",l,r,i,q,A*B);\n\t\t\t\tans+=(ll)A*B;\n\t\t\t}\n\t\t}\n\tnode res(-1);\n\tres.level=a[1].level+1;\n\tres.mx=sum[n]/L;\n\tres.pre.resize(res.mx);\n\tres.suf.resize(res.mx);\n\tfor(int i=1,cnt=0;i<=n;i++)\n\t\trep(j,1,a[i].mx)\n\t\t\tif(++cnt>=L){\n\t\t\t\tint tmp=a[i].pre[j-1]-(j<a[i].mx?a[i].pre[j]:0);\n\t\t\t\tres.pre[cnt/L-1]+=tmp;\n\t\t\t}\n\tfor(int i=n,cnt=0;i>=1;i--)\n\t\trep(j,1,a[i].mx)\n\t\t\tif(++cnt>=L){\n\t\t\t\tint tmp=a[i].suf[j-1]-(j<a[i].mx?a[i].suf[j]:0);\n\t\t\t\tres.suf[cnt/L-1]+=tmp;\n\t\t\t}\n\tper(i,res.mx-1,1){\n\t\tres.pre[i-1]+=res.pre[i];\n\t\tres.suf[i-1]+=res.suf[i];\n\t}\n/*\n\tll now=ans;\n\tprintf(\"res = %lld\\n\",now-las);\n\tprintf(\"ret = {%d, %d, { \",res.level,res.mx);\n\tfor(auto x:res.pre)printf(\"%d \",x);\n\tprintf(\"}, { \");\n\tfor(auto x:res.suf)printf(\"%d \",x);\n\tputs(\"}}\");\n*/\n\treturn res;\n}\n\nint main(){\n\tread(n),read(L),ans=n;\n\trep(i,1,n)read(a[i]);\n\ta[n+1]=inf;\n\trep(i,1,n){\n\t\tstk[++top]=node(a[i]);\n\t\tint flag=0;\n\t\twhile(flag&&stk[top].level<inf||stk[top].level<a[i+1]){\n\t\t\tint cur=top;\n\t\t\twhile(cur&&stk[cur].level==stk[top].level)\n\t\t\t\tcur--;\n\t\t\tstk[cur+1]=merge(stk+cur,top-cur);\n\t\t\ttop=cur+1;\n\t\t\tstk[top].Assert();\n\t\t\tif(stk[top].level==inf)flag=1,top--;\n\t\t}\n\t\tif(flag)stk[++top].level=inf;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 12/11/2019, 4:20:39 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/optional.hpp> // for C++14\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\nconstexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nstruct Element\n{\n  ll left, right;\n  boost::optional<ll> value; // for C++14\n};\n\nclass Solve\n{\n  ll N;\n  ll L;\n  vector<Element> A;\n\npublic:\n  Solve(ll N, ll L, vector<ll> input) : N{N}, L{L}, A(N)\n  {\n    for (auto i = 0; i < N; i++)\n    {\n      A[i].value = input[i];\n      A[i].left = 1;\n      A[i].right = 1;\n    }\n  }\n\n  ll count()\n  {\n    ll ans{N};\n    while (true)\n    {\n      boost::optional<ll> M{min_value()};\n      if (!M)\n      {\n        break;\n      }\n      vector<Element> T;\n      vector<Element> tmp;\n      for (auto &&e : A)\n      {\n        if (e.value == M)\n        {\n          tmp.push_back(move(e));\n        }\n        else if (!tmp.empty())\n        {\n          update(ans, T, move(tmp));\n          T.push_back(move(e));\n        }\n        else\n        {\n          T.push_back(move(e));\n        }\n      }\n      if (!tmp.empty())\n      {\n        update(ans, T, move(tmp));\n      }\n      swap(A, T);\n    }\n    return ans;\n  }\n\nprivate:\n  boost::optional<ll> min_value()\n  {\n    boost::optional<ll> ans;\n    for (auto const &e : A)\n    {\n      if (e.value)\n      {\n        if (ans)\n        {\n          ch_min(*ans, *e.value);\n        }\n        else\n        {\n          ans = e.value;\n        }\n      }\n    }\n    return ans;\n  }\n\n  void update(ll &ans, vector<Element> &T, vector<Element> &&tmp)\n  {\n    ans += calc(tmp);\n    tmp = press(move(tmp));\n    ans -= calc(tmp);\n    copy(move(tmp).begin(), move(tmp).end(), back_inserter(T));\n    tmp.clear();\n  }\n\n  ll calc(vector<Element> const &X)\n  {\n    ll ans{0};\n    ll sum_right{0};\n    int S{static_cast<int>(X.size())};\n    for (auto i = L - 1; i < S; i++)\n    {\n      sum_right += X[i].right;\n    }\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans += X[i].left * sum_right;\n      sum_right -= X[i + L - 1].right;\n    }\n    assert(sum_right == 0);\n    return ans;\n  }\n\n  vector<Element> press(vector<Element> &&V)\n  {\n    ll S{static_cast<ll>(V.size())};\n    if (S < L)\n    {\n      return {{0, 0, boost::none}};\n    }\n    ll K{*V[0].value + 1};\n    vector<Element> ans(S / L);\n    for (auto &e : ans)\n    {\n      e.value = K;\n    }\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].right += V[i].right;\n    }\n    reverse(V.begin(), V.end());\n    reverse(ans.begin(), ans.end());\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].left += V[i].left;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans;\n  }\n\n  void delete_none()\n  {\n    vector<Element> T;\n    int S{static_cast<int>(A.size())};\n    for (auto i = 0; i < S; i++)\n    {\n      if (i < S - 1 && !A[i].value && !A[i + 1].value)\n      {\n        continue;\n      }\n      T.push_back(move(A[i]));\n    }\n    swap(A, T);\n  }\n};\n\nint main()\n{\n  ll N, L;\n  cin >> N >> L;\n  vector<ll> A(N);\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> A[i];\n  }\n  Solve solve(N, L, move(A));\n  cout << solve.count() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxp];\nint main()\n{\n\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout); \n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<25;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue; assert(H[i+1]==H[i]+1);\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int j=1;j<=k;++j)\n\t\t\t{\n\t\t\t\ttmp[j].l=tmp[j].r=tmp[j-1].l+1;\n\t\t\t\ttmp[j].L=tmp[j].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tfor(int j=l;j<=r;++j)\n\t\t\t{\n\t\t\t\tint x=j-l+1,y=r-j+1;\n\t\t\t\tif(x>=L) tmp[x/L].R+=rec[i][j].R;\n\t\t\t\tif(y>=L) tmp[k-y/L+1].L+=rec[i][j].L;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\tfor(int j=1;j<=k;++j) rec[i+1].push_back(tmp[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nstd::priority_queue<std::pair<int,int>,std::vector<std::pair<int,int> >,std::greater<std::pair<int,int> > >Q;\nint cntl[200002],cntr[200002],v[200002],tmp1[200002],tmp2[200002],tmp3[200002],r[200002],pool[200002],n,m;\nlong long ans;\nlong long calc(int n,int l[],int r[],int t[]){\n\tstatic std::queue<std::pair<int,int> >Q;\n\twhile(!Q.empty())Q.pop();\n\tstatic int tmp1[200002],tmp2[200002];\n\tlong long ans=0,cnt=0;int g=n/m;\n\tfor(int i=1;i<=n;i++){\n\t\tQ.push(std::make_pair(t[i],l[i]));\n\t\twhile(Q.size()>=m&&Q.front().first!=t[i])cnt+=Q.front().second,Q.pop();\n\t\tans+=cnt*r[i];tmp1[i]=tmp2[i]=0;\n\t}for(int i=m;i<=n;i++)tmp2[i/m]+=r[i];\n\tfor(int i=n-m+1;i>=1;i--)tmp1[g+1-(n+1-i)/m]+=l[i];\n\tfor(int i=1;i<=g;i++)l[i]=tmp1[i],r[i]=tmp2[i];\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);r[0]=1;ans=n;\n\tfor(int i=1;i<=n;i++){\n\t\tint hdhdAKIOI;scanf(\"%d\",&hdhdAKIOI);Q.push(std::make_pair(hdhdAKIOI,i));\n\t\tr[i]=i+1;v[i]=i;cntl[i]=cntr[i]=1;\n\t}while(!Q.empty()){\n\t\tint V=Q.top().first,tp=0;\n\t\twhile(!Q.empty()&Q.top().first==V){\n\t\t\tpool[++tp]=Q.top().second;Q.pop();\n\t\t}tmp1[1]=cntl[pool[1]];tmp2[1]=cntr[pool[1]];tmp3[1]=v[pool[1]];\n\t\tfor(int i=2,j=1;i<=tp;i++){\n\t\t\tif(r[pool[i-1]]==pool[i]){\n\t\t\t\tj++;tmp1[j]=cntl[pool[i]];tmp2[j]=cntr[pool[i]];tmp3[j]=v[pool[i]];\n\t\t\t}else{\n\t\t\t\tif(j>=m){\n\t\t\t\t\tans+=calc(j,tmp1,tmp2,tmp3);\n\t\t\t\t\tint s=pool[i-j],c=j/m;\n\t\t\t\t\tfor(int p=s;p<s+c-1;p++)r[p]=p+1;r[s+c-1]=r[pool[i-1]];\n\t\t\t\t\tfor(int p=s;p<s+c;p++)cntl[p]=tmp1[p-s+1],cntr[p]=tmp2[p-s+1],v[p]=s,Q.push(std::make_pair(V+1,p));\n\t\t\t\t}j=1;tmp1[1]=cntl[pool[i]];tmp2[1]=cntr[pool[i]];tmp3[1]=v[pool[i]];\n\t\t\t}if(i==tp&&j>=m){\n\t\t\t\tans+=calc(j,tmp1,tmp2,tmp3);\n\t\t\t\tint s=pool[i-j+1],c=j/m;\n\t\t\t\tfor(int p=s;p<s+c-1;p++)r[p]=p+1;r[s+c-1]=r[pool[i]];\n\t\t\t\tfor(int p=s;p<s+c;p++)cntl[p]=tmp1[p-s+1],cntr[p]=tmp2[p-s+1],v[p]=s,Q.push(std::make_pair(V+1,p));\n\t\t\t}\n\t\t}\n\t}printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MaxN=200010;\nint N,L,A[MaxN],ch[MaxN][2],stk[MaxN];\nstruct List{\n\tint*s,*t,*a,*b,n,sum,sumL;\n\tvoid reb(){\n\t\tif(!n)n++;\n\t\tint*ns=new int[n*3+1];\n\t\tif(s)for(int i=1;i<=n;i++)ns[n+i]=a[i];\n\t\ta=ns+n;t=a+n*2;b=a+(s?n:--n);s=ns;\n\t}\n\tint get(int i){return i>0&&i<=b-a?a[i]:0;}\n\tvoid pb(int x){\n\t\tif(!s||b==t)reb();*++b=x;\n\t\tif(++n>=L-1)sumL+=x;sum+=x;\n\t}\n\tvoid pf(int x){\n\t\tif(!s||a==s)reb();*a--=x;\n\t\t++n;sum+=x;sumL+=get(L-1);\n\t}\n}V[MaxN][2];\nbool fail[MaxN][2];\nList mer(List l1,List l2,bool ty=0){\n\tif(l1.n>l2.n)return mer(l2,l1,1);\n\tty?l2.pb(1):l2.pf(1);\n\tif(ty)for(int i=1;i<=l1.n;i++)l2.pb(l1.a[i]);\n\telse for(int i=l1.n;i;i--)l2.pf(l1.a[i]);\n\treturn l2;\n}\nList cont(List l,int d){\n\twhile(d--&&l.n){\n\t\tList nl=(List){0,0,0,0,0,0,0};\n\t\tfor(int i=L;i<=l.n;i+=L){\n\t\t\tint x=0;\n\t\t\tfor(int j=0;j<L;j++)x+=l.get(i+j);\n\t\t\tnl.pb(x);\n\t\t}\n\t\tl=nl;\n\t}\n\treturn l;\n}\nlong long qry(List&l1,List&l2){\n\tif(l1.n>l2.n)return qry(l2,l1);\n\tlong long s=0;\n\tint tmp=l2.sumL;\n\tfor(int i=1;i<=l1.n&&i<L-1;i++)s+=1ll*l1.get(i)*(tmp+=l2.get(L-i-1));\n\treturn s+1ll*l1.sumL*l2.sum;\n}\nlong long dfs(int o){\n\tlong long s=1;\n\tfor(int c=0,x;c<2;c++)if(x=ch[o][c]){\n\t\ts+=dfs(x);\n\t\tfor(int t=0;t<2;t++)V[x][t]=cont(V[x][t],A[o]-A[x]);\n\t\ts+=V[x][!c].sumL;\n\t}\n\ts+=qry(V[ch[o][0]][1],V[ch[o][1]][0]);\n\tfor(int c=0,x,y;c<2;c++){\n\t\tif((x=ch[o][c])&&!V[x][c].n||fail[x][c])fail[o][c]=1,V[o][c]=V[x][c];\n\t\telse y=ch[o][!c],fail[o][c]=y&&!V[y][c].n||fail[y][c],V[o][c]=mer(V[x][c],V[y][c]);\n\t}\n\treturn s;\n}\nint main(){\n\tscanf(\"%d%d\",&N,&L);\n\tint*top=stk;\n\tfor(int i=1;i<=N;i++){\n\t\tscanf(\"%d\",A+i);\n\t\tfor(;top>stk&&A[*top]<A[i];top--)\n\t\t\tch[i][0]=ch[top[-1]][1]=*top;\n\t\t*++top=i;\n\t}\n\tfor(;top>stk;top--)ch[top[-1]][1]=*top;\n\tprintf(\"%lld\\n\",dfs(stk[1]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 200233, inf = 1000000007;\nint n, L, a[N], lf[N], rf[N], lp[N], rp[N];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> s;\nll ans = 0;\n\nint main() {\n  scanf(\"%d%d\", &n, &L);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    lf[i] = rf[i] = 1;\n    lp[i] = i - 1;\n    rp[i] = i + 1;\n    s.push(make_pair(a[i], i));\n  }\n  rf[0] = 1;\n  lf[n + 1] = n;\n  while (1) {\n    int x = s.top().second;\n    s.pop();\n    if (a[x] == inf) break;\n    int y = x, cnt = 1;\n    vector<int> v(1, x);\n    while (a[rp[y]] == a[y]) {\n      cnt++;\n      y = rp[y];\n      v.push_back(y);\n      s.pop();\n    }\n    for (int i = 0, sum = 0; i < cnt; i++) {\n      ans += (ll) lf[v[i]] * rf[v[i]];\n      if (i - L + 1 >= 0) {\n        sum += lf[v[i - L + 1]];\n      }\n      ans += (ll) sum * rf[v[i]];\n    }\n    int lt = lp[x], rt = rp[y];\n    if (lt == 0 && rt == n + 1) {\n      break;\n    }\n    int cnt2 = cnt / L;\n    vector<int> nlf(cnt2, 0), nrf(cnt2, 0);\n    for (int i = 0; i < cnt; i++) {\n      if (cnt - i >= L) {\n        nlf[cnt2 - 1 - (cnt - i - L) / L] += lf[v[i]];\n      }\n      if (i + 1 >= L) {\n        nrf[(i + 1 - L) / L] += rf[v[i]];\n      }\n    }\n    for (int i = 0, sum = 0; i < cnt2; i++) {\n      ans -= (ll) nlf[i] * nrf[i];\n      if (i - L + 1 >= 0) {\n        sum += nlf[i - L + 1];\n      }\n      ans -= (ll) sum * nrf[i];\n    }\n    if (!cnt2) {\n      ++cnt2;\n      a[v[0]] = inf - 1;\n      nlf[0] = nrf[0] = 0;\n    }\n    for (int i = 0; i < cnt2; i++) {\n      a[v[i]]++;\n      s.push(make_pair(a[v[i]], v[i]));\n      lf[v[i]] = nlf[i];\n      rf[v[i]] = nrf[i];\n    }\n    lp[v[0]] = lt;\n    rp[v[cnt2 - 1]] = rt;\n    rp[lt] = v[0];\n    lp[rt] = v[cnt2 - 1];\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 400005\n#define ll long long\nint n, l, tot;\nint A[N], now[N], nnow[N], pre[N];\nint val[N], vl[N], vr[N], suml[N], sumr[N];\nll ans;\nstruct cmp\n{\n\tbool operator ()(const int &a,const int &b)\n\t{\n\t\tif (val[a] != val[b])\n\t\t\treturn val[a] < val[b];\n\t\treturn vl[a] < vl[b];\n\t}\n};\nset<int, cmp>s;\nint main()\n{\n\tscanf(\"%d%d\", &n, &l);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i]);\n\t\t++tot;\n\t\tvl[tot] = vr[tot] = i;\n\t\tval[tot] = A[i];\n\t\tsuml[tot] = sumr[tot] = 1;\n\t\ts.insert(tot);\n\t}\n\twhile (!s.empty())\n\t{\n\t\tint len = 0;\n\t\tnow[++len] = *s.begin();\n\t\ts.erase(s.begin());\n\t\twhile (!s.empty() && val[*s.begin()] == val[now[1]] && vl[*s.begin()] == vr[now[len]] + 1)\n\t\t{\n\t\t\tnow[++len] = *s.begin();\n\t\t\ts.erase(s.begin());\n\t\t}\n\t\tpre[0] = 0;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tpre[i] = pre[i - 1] + suml[now[i]];\n\t\tfor (int i = 1; i <= len; i++)\n\t\t{\n\t\t\tans += (ll)suml[now[i]] * sumr[now[i]]; \n\t\t\tif (i - l + 1 >= 1)\n\t\t\t\tans += (ll)sumr[now[i]] * pre[i - l + 1];\n\t\t}\n\t\tint nlen = 0, last = 0;\n\t\tfor (int i = 1; i <= len / l; i++)\n\t\t{\n\t\t\tint tmpl = (i - 1) * l + 1, tmpr = i * l;\n\t\t\tif (i == len / l)\n\t\t\t\ttmpr = len;\n\t\t\ttot++;\n\t\t\tvl[tot] = vl[now[tmpl]];\n\t\t\tvr[tot] = vr[now[tmpr]];\n\t\t\tval[tot] = val[now[1]] + 1;\n\t\t\tfor (int j = i * l; j <= (i + 1) * l - 1 && j <= len; j++)\n\t\t\t\tsumr[tot] += sumr[now[j]];\n\t\t\tsuml[tot] = pre[len % l + 1 + (i - 1) * l] - pre[last];\n\t\t\tlast = len % l + 1 + (i - 1) * l;\n\t\t\ts.insert(tot);\n\t\t\tnnow[++nlen] = tot;\n\t\t}\n\t\tpre[0] = 0;\n\t\tfor (int i = 1; i <= nlen; i++)\n\t\t\tpre[i] = pre[i - 1] + suml[nnow[i]];\n\t\tfor (int i = 1; i <= nlen; i++)\n\t\t{\n\t\t\tans -= (ll)suml[nnow[i]]*sumr[nnow[i]];\n\t\t\tif (i - l + 1 >= 1)\n\t\t\t\tans -= (ll)sumr[nnow[i]] * pre[i - l + 1];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=200005;\nint n,L;\nint a[N];\nint rp[N];\nvector <int> vl[N],vr[N];\nmap <int,vector <int> > pos;\nset <int> S;\nvector <int> v,v2,tl,tr;\nint vis[N];\nint main(){\n\tn=read(),L=read();\n\tFor(i,1,n){\n\t\ta[i]=read();\n\t\tpos[a[i]].pb(i);\n\t\tS.insert(a[i]);\n\t}\n\tLL ans=n;\n\tint k=0;\n\twhile (!S.empty()){\n\t\tk++;\n\n//\touttag();outval(k);\n\t\tif (k==*S.begin())\n\t\t\tS.erase(S.begin());\n\t\tfor (auto i : pos[k]){\n\t\t\trp[i]=i;\n\t\t\tvl[i].pb(1),vr[i].pb(1);\n\t\t\tv.pb(i);\n\n//\tprintf(\"new[%d]: pos = [%d..%d]\\n\",i,i,rp[i]);outarr(vl[i],0,(int)vl[i].size()-1);outarr(vr[i],0,(int)vr[i].size()-1);\n\t\t}\n\t\tif (v.empty()){\n\t\t\tassert(!S.empty());\n\t\t\tk=*S.begin()-1;\n\t\t\tcontinue;\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint las=v[0];\n\t\tv2.clear();\n\t\ttl.clear(),tr.clear();\n\t\ttr.pb(0);\n\t\t#define tls (int)tl.size()\n\t\t#define trs (int)tr.size()\n\t\tFor(_,0,(int)v.size()-1){\n\t\t\tint i=v[_];\n\t\t\tvl[i].pb(0);\n\t\t\tFor(j,0,(int)vl[i].size()-2){\n\t\t\t\tvl[i][j]-=vl[i][j+1];\n\t\t\t\tans+=(LL)vl[i][j]*tr[max(trs-max(L-(j+1),1),0)];\n\t\t\t\ttl.pb(vl[i][j]);\n\t\t\t}\n\n//\tprintf(\"i = %d, ans = %lld\\n\",i,ans);\n\t\t\tint tmp=tr.back();\n\t\t\tFod(j,(int)vr[i].size()-1,0)\n\t\t\t\ttr.pb(vr[i][j]+tmp);\n\t\t\tif (_==(int)v.size()-1||v[_+1]!=rp[i]+1){\n\t\t\t\trp[las]=rp[i];\n\n//\toutarr(tl,0,tls-1);\toutarr(tr,0,trs-1);\n\t\t\t\tFod(i,trs-1,1)\n\t\t\t\t\ttr[i]-=tr[i-1];\n\t\t\t\tvl[las]=tl;\n\t\t\t\tvr[las].clear();\n\t\t\t\tFod(i,trs-1,1)\n\t\t\t\t\tvr[las].pb(tr[i]);\n\n//\toutarr(vl[las],0,(int)vl[las].size()-1);outarr(vr[las],0,(int)vr[las].size()-1);\n\t\t\t\tFor(i,0,(int)vl[las].size()-1){\n\t\t\t\t\tint tmp=vl[las][i];\n\t\t\t\t\tvl[las][i]=0;\n\t\t\t\t\tvl[las][(i+1)/L]+=tmp;\n\t\t\t\t}\n\t\t\t\tvl[las][0]=0;\n\t\t\t\tFor(i,0,(int)vl[las].size()-2)\n\t\t\t\t\tvl[las][i]=vl[las][i+1],vl[las][i+1]=0;\n\t\t\t\twhile (!vl[las].empty()&&!vl[las].back())\n\t\t\t\t\tvl[las].pop_back();\n\t\t\t\tFod(i,(int)vl[las].size()-1,1)\n\t\t\t\t\tvl[las][i-1]+=vl[las][i];\n\t\t\t\tFor(i,0,(int)vr[las].size()-1){\n\t\t\t\t\tint tmp=vr[las][i];\n\t\t\t\t\tvr[las][i]=0;\n\t\t\t\t\tvr[las][(i+1)/L]+=tmp;\n\t\t\t\t}\n\t\t\t\tvr[las][0]=0;\n\t\t\t\tFor(i,0,(int)vr[las].size()-2)\n\t\t\t\t\tvr[las][i]=vr[las][i+1],vr[las][i+1]=0;\n\t\t\t\twhile (!vr[las].empty()&&!vr[las].back())\n\t\t\t\t\tvr[las].pop_back();\n\t\t\t\tFod(i,(int)vr[las].size()-1,1)\n\t\t\t\t\tvr[las][i-1]+=vr[las][i];\n\n//\tprintf(\"new[%d]: pos = [%d..%d]\\n\",las,las,rp[las]);outarr(vl[las],0,(int)vl[las].size()-1);outarr(vr[las],0,(int)vr[las].size()-1);\n\t\t\t\tif (!vl[las].empty())\n\t\t\t\t\tv2.pb(las);\n\t\t\t\tif (_!=(int)v.size()-1){\n\t\t\t\t\tlas=v[_+1];\n\t\t\t\t\ttl.clear(),tr.clear();\n\t\t\t\t\ttr.pb(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv=v2;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n/*\n\n5 2\n3 2 2 2 2 \n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int Maxn = 2e5;\n\nint N, L;\nint A[Maxn + 5];\n\nint tot;\nint val[Maxn * 4 + 5], vl[Maxn * 4 + 5], vr[Maxn * 4 + 5];\nint s1[Maxn * 4 + 5], s2[Maxn * 4 + 5], sum[Maxn * 4 + 5];\nint now[Maxn * 4 + 5], newnow[Maxn * 4 + 5];\n\nstruct cmp {\n\tbool operator () (const int &lhs, const int &rhs) {\n\t\treturn val[lhs] == val[rhs] ? vl[lhs] > vl[rhs] : val[lhs] > val[rhs];\n\t}\n};\npriority_queue<int, vector<int>, cmp> q;\n\nint main() {\n#ifdef LOACL\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d %d\", &N, &L);\n\tfor(int i = 1; i <= N; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\t++tot;\n\t\tval[tot] = A[i], vl[tot] = vr[tot] = i;\n\t\ts1[tot] = s2[tot] = 1;\n\t\tq.push(tot);\n\t}\n\tll ans = 0;\n\twhile(!q.empty()) {\n\t\tint len = 0;\n\t\tnow[++len] = q.top();\n\t\tq.pop();\n\t\twhile(!q.empty() && val[q.top()] == val[now[1]] && vl[q.top()] == vr[now[len]] + 1)\n\t\t\tnow[++len] = q.top(), q.pop();\n\t\tsum[0] = 0;\n\t\tfor(int i = 1; i <= len; i++)\n\t\t\tsum[i] = sum[i - 1] + s1[now[i]];\n\t\tfor(int i = 1; i <= len; i++) {\n\t\t\tans += 1LL * s1[now[i]] * s2[now[i]];\n\t\t\tif(i - L + 1 >= 1) ans += 1LL * s2[now[i]] * sum[i - L + 1];\n\t\t}\n\t\tint newlen = 0, last = 0;\n\t\tfor(int i = 1; i <= len / L; i++) {\n\t\t\tint tmpl = (i - 1) * L + 1, tmpr = i * L;\n\t\t\tif(i == len / L) tmpr = len;\n\t\t\t++tot;\n\t\t\tvl[tot] = vl[now[tmpl]], vr[tot] = vr[now[tmpr]];\n\t\t\tval[tot] = val[now[1]] + 1;\n\t\t\tfor(int j = i * L; j <= (i + 1) * L - 1 && j <= len; j++)\n\t\t\t\ts2[tot] += s2[now[j]];\n\t\t\ts1[tot] = sum[len % L + 1 + (i - 1) * L] - sum[last];\n\t\t\tlast = len % L + 1 + (i - 1) * L;\n\t\t\tq.push(tot);\n\t\t\tnewnow[++newlen] = tot;\n\t\t}\n\t\tsum[0] = 0;\n\t\tfor(int i = 1; i <= newlen; i++)\n\t\t\tsum[i] = sum[i - 1] + s1[newnow[i]];\n\t\tfor(int i = 1; i <= newlen; i++) {\n\t\t\tans -= 1LL * s1[newnow[i]] * s2[newnow[i]];\n\t\t\tif(i - L + 1 >= 1) ans -= 1LL * s2[newnow[i]] * sum[i - L + 1];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[200005];\nint s[200005],cnt[200005],las[200005],ok[200005],preok[200005],t;\nint n,l;\nbool push(int x){\n\tif(!t){s[++t]=x;cnt[t]=1;las[t]=x;ok[t]=preok[t]=1;return 1;}\n\twhile(t>1 && s[t]<x){\n\t\tif(!ok[t])return 0;\n\t\tlas[t-1]=las[t];\n\t\t--t;\n\t}\n\tif(s[t]<x)return 0;\n\tif(s[t]>x){\n\t\ts[++t]=x;cnt[t]=1;las[t]=x;ok[t]=las[t-1]<=x;\n\t}\n\telse{\n\t\t++cnt[t];\t\n\t\tlas[t]=x;\n\t\twhile(cnt[t]==l){\n\t\t\tint w=s[t]+1;\n\t\t\t--t;\n\t\t\tif(!t || s[t]!=w){\n\t\t\t\ts[++t]=w;cnt[t]=1;las[t]=x;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++cnt[t];las[t]=x;\t\t\n\t\t\t}\n\t\t}\n\t\tok[t]=(t==1&&cnt[t]==1)||(t>1 && las[t-1]<=s[t]);\n\t}\n\tpreok[t]=ok[t]&&preok[t-1];\n\treturn 1;\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tread(n,l);\n\tfor(int i=1;i<=n;++i)read(a[i]);\n\tint ans=0;\n\tpreok[0]=1;\n\tfor(int i=n;i;--i){\n\t\tt=0;\n\t\tfor(int j=i;j<=n;++j){\n\t\t\tif(!push(a[j]))break;\n//\t\t\tif(preok[t])write(i,' ',j,'\\n');\n\t\t\tans+=preok[t];\n\t\t}\n\t}\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define N 200002\nusing namespace std;\nint a[N],b[N],c[N],d[N],e[N],f[N],i,j,k,m,n,o[N],p[N],q,w;long long x;bool g[N];\ninline bool cmp(int u,int v){return c[u]<c[v];}\ninline void solve(int u,int v)\n{\n    for(;c[a[u]]==c[u];g[u=a[u]]=true);\n    for(;c[b[v]]==c[v];g[v=b[v]]=true);\n    for(j=v,q=0;u<=j;j=a[j])o[++q]=e[j];\n    for(j=u,q=0;j<=v;j=b[j])p[++q]=f[j];\n    for(j=q,o[q+1]=p[q+1]=0;j;j--)o[j]+=o[j+1],p[j]+=p[j+1];\n    for(j=0;j<=q-m;j++)x+=(long long)(o[q-j]-o[q-j+1])*p[m+j];\n    for(w=c[u];w!=c[a[u]]&&w!=c[b[v]]&&m<=q;q=j,w++)for(j=k=0;(k+=m)<=q;)o[++j]=o[k],p[j]=p[k];\n    if(w!=c[a[u]]&&w!=c[b[v]])b[a[u]]=b[v],a[b[v]]=a[u];\n    else\n    {\n        for(j=o[q+1]=p[q+1]=0;j<=q-m;j++)x-=(long long)(o[q-j]-o[q-j+1])*p[m+j];\n        for(j=1,o[q+1]=p[q+1]=0;j<=q;j++)o[j]-=o[j+1],p[j]-=p[j+1];\n        for(j=u,k=0;k<q;j=b[j])c[j]=w,e[j]=o[q-k],f[j]=p[++k];\n        a[b[v]]=a[j],b[a[j]]=b[v];\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m),x=n;\n    for(i=1;i<=n;i++)scanf(\"%d\",c+i),d[i]=i,e[i]=f[i]=1,a[i]=i-1,b[i]=i+1;\n    for(sort(d+1,d+n+1,cmp),i=1;i<=n;i++)if(!g[d[i]])solve(d[i],d[i]);\n    return 0&printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define last last2\n\nusing namespace std;\n\ntypedef long long ll;\n\nint num[200005],n,L;\nll ans;\n\nnamespace SGT {\n\nint maxv[800000];\n\nvoid build(int l,int r,int o) {\n  if (l==r) maxv[o]=l;\n  else {\n  \tint m=((l+r)>>1);\n    build(l,m,o*2);\n    build(m+1,r,o*2+1);\n    maxv[o]=((num[maxv[o*2]]>=num[maxv[o*2+1]])?maxv[o*2]:maxv[o*2+1]);\n  }\n}\n\nint query(int l,int r,int o,int lx,int rx) {\n  if (l>=lx&&r<=rx) return maxv[o];\n  else {\n  \tint m=((l+r)>>1);\n  \tif (m>=rx) return query(l,m,o*2,lx,rx);\n  \tif (m<lx) return query(m+1,r,o*2+1,lx,rx);\n  \tint a=query(l,m,o*2,lx,rx),b=query(m+1,r,o*2+1,lx,rx);\n  \treturn (num[a]>=num[b])?a:b;\n  }\n}\n\n}\n\nint nxt[200005],powd[200005];\nmap <int,int> last;\n\nvoid pre() {\n  powd[0]=1;\n  for(int i=1;i<=n;i++) powd[i]=min((ll)powd[i-1]*L,n+1LL);\n  for(int i=n;i>0;i--) {\n  \tnxt[i]=((last[num[i]])?last[num[i]]:n+1);\n  \tlast[num[i]]=i;\n  } \n}\n\nvector <int> suml[200005],sumr[200005];\nvector <int> pos[200005],son[200005];\nint size[200005],lsize[200005],rsize[200005];\nint val[200005],tot;\n\nvoid calc(int o,int d) {\n  static int sum[200005];\n  if (d>n||powd[d]>n) {\n  \tsize[o]=-1;\n  \tsuml[o].resize(1);sumr[o].resize(1);\n  \tlsize[o]=rsize[o]=0;\n  \treturn;\n  }\n  size[o]=((size[o]>=powd[d])?size[o]/powd[d]:-1);\n  if (lsize[o]) {\n  \tfor(int i=1;i<=lsize[o];i++) sum[i]=0;\n    int maxn=0;\n    for(int i=powd[d];i<=lsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=suml[o][i];\n    }\n    lsize[o]=maxn;\n    suml[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) suml[o][i]=sum[i];\n  }\n  if (rsize[o]) {\n  \tfor(int i=1;i<=rsize[o];i++) sum[i]=0;\n    int maxn=0;\n    for(int i=powd[d];i<=rsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=sumr[o][i];\n    }\n    rsize[o]=maxn;\n    sumr[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) sumr[o][i]=sum[i];\n  }\n}\n\nint solve(int l,int r) {\n  static int q[200005];\n  int o=++tot;\n  for(int i=SGT::query(1,n,1,l,r);i<=r;i=nxt[i]) \n    pos[o].push_back(i);\n  val[o]=num[pos[o][0]];\n  son[o].resize(pos[o].size()+1);\n  if (pos[o][0]>l) son[o][0]=solve(l,pos[o][0]-1);\n  for(int i=1;i<pos[o].size();i++)\n    if (pos[o][i]>pos[o][i-1]+1) son[o][i]=solve(pos[o][i-1]+1,pos[o][i]-1);\n  if (pos[o][pos[o].size()-1]<r) son[o][son[o].size()-1]=solve(pos[o][pos[o].size()-1]+1,r);\n  for(int i=0;i<son[o].size();i++)\n    if (son[o][i]) calc(son[o][i],val[o]-val[son[o][i]]);\n  int rx=0,lx=0;\n  for(int i=rsize[son[o][0]];i>0;i--) q[++rx]=sumr[son[o][0]][i];\n  int s=0;\n  for(int i=0;i<pos[o].size();i++) {\n  \tq[++rx]=1;\n  \twhile (lx<rx&&rx-lx>=L) s+=q[++lx];\n  \tans+=s;\n  \tif (son[o][i+1]) {\n  \t\tint u=son[o][i+1];\n  \t\tfor(int j=1;j<=lsize[u];j++) {\n  \t\t\twhile (lx<rx&&rx-lx+j>=L) s+=q[++lx];\n  \t\t\tans+=(ll)s*suml[u][j];\n\t\t  }\n\t\tif (size[u]==-1) lx=rx,s=0;\n\t\tfor(int j=rsize[u];j>0;j--) q[++rx]=sumr[u][j];\n\t  }\n  }\n  bool v=1;\n  int sz=pos[o].size();\n  for(int i=0;i<son[o].size();i++)\n    if (size[son[o][i]]==-1) v=0; else sz+=size[son[o][i]];\n  size[o]=((v)?sz:-1);\n  suml[o].resize(1);\n  for(int i=0;i<son[o].size();i++) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=lsize[u];j++) suml[o].push_back(suml[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i+1<son[o].size()) suml[o].push_back(1);\n  }\n  lsize[o]=suml[o].size()-1;\n  sumr[o].resize(1);\n  for(int i=son[o].size()-1;i>=0;i--) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=rsize[u];j++) sumr[o].push_back(sumr[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i) sumr[o].push_back(1);\n  }\n  rsize[o]=sumr[o].size()-1;\n  return o;\n}\n\nint main() {\n  scanf(\"%d%d\",&n,&L);\n  for(int i=1;i<=n;i++) scanf(\"%d\",&num[i]);\n  pre();\n  SGT::build(1,n,1);\n  solve(1,n);\n  printf(\"%lld\\n\",ans+n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint left[262144],right[262144];\nint num=0;\nint val[262144];\nlong long ans=0;\nint n,l;\nint sl[262144],sr[262144];\nvoid dec()\n{\n\tint now;\n\tfor(now=num-1;now>0;now--)\n\t{\n\t\tif(val[now]!=val[now-1])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tint d=num-now;\n\tint v=val[now];\n\tlong long s=0;\n\tfor(int i=now;i<num;i++)\n\t{\n\t\tans+=(long long)left[i]*right[i];\n\t\tif(i-l+1>=now)\n\t\t{\n\t\t\ts+=left[i-l+1];\n\t\t}\n\t\tans+=s*right[i];\n\t}\n\tif(d<l)\n\t{\n\t\tnum=now;\n\t\twhile(num)\n\t\t{\n\t\t\tdec();\n\t\t}\n\t\treturn;\n\t}\n\tint dd=d/l;\n\tfor(int i=0;i<=dd;i++)\n\t{\n\t\tsl[i]=0;\n\t\tsr[i]=0;\n\t}\n\tfor(int i=now;i<num;i++)\n\t{\n\t\tsl[(i-now+1)/l]+=right[i];\n\t\tsr[(num-i)/l]+=left[i];\n\t}\n\tnum=now+dd;\n\tfor(int i=1;i<=dd;i++)\n\t{\n\t\tright[now+i-1]=sl[i];\n\t\tleft[num-i]=sr[i];\n\t}\n\ts=0;\n\tfor(int i=now;i<num;i++)\n\t{\n\t\tval[i]=v+1;\n\t\tans-=(long long)left[i]*right[i];\n\t\tif(i-l+1>=now)\n\t\t{\n\t\t\ts+=left[i-l+1];\n\t\t}\n\t\tans-=s*right[i];\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\twhile(n--)\n\t{\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\twhile(num>0)\n\t\t{\n\t\t\tif(val[num-1]>=a)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdec();\n\t\t}\n\t\tleft[num]=1;\n\t\tright[num]=1;\n\t\tval[num]=a;\n\t\tnum++;\n\t}\n\twhile(num)\n\t{\n\t\tdec();\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "."
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=4e5+10;\nstruct node{int x,L,R,l,r;};\nbool operator < (node a,node b){\n\tif (a.x==b.x)return a.l<b.l;\n\treturn a.x<b.x;\n}\nset<node> s,s1;\nvector<node> d;\nint n,L;\nll ans;\nint al[N],ar[N],q[N],pl[N],pr[N];\nvoid calc(int x){\n\tll cnt=0;\n\tfor (int i=0;i<d.size();i++){\n\t\tif (i>=L-1)cnt+=d[i-L+1].L;\n\t\tans+=cnt*d[i].R;\n\t}\n\tint c1=1,t=0,t1,L1=0;\n\tL1=d[0].l;\n\tfor (int i=0;i<d.size();i++){\n\t\tif (c1==L){\n\t\t\tar[++t]=0;\n\t\t\tpl[t]=1e9;\n\t\t\tpr[t]=0;\n\t\t\tc1=0;\n\t\t}\n\t\tar[t]+=d[i].R;\n\t\tpl[t]=min(pl[t],d[i].l);\n\t\tpr[t]=max(pr[t],d[i].r);\n\t\tc1++;\n\t}t1=t;\n\tc1=1,t++;\n\tfor (int i=d.size()-1;i>=0;i--){\n\t\tif (c1==L){\n\t\t\tal[--t]=0;\n//\t\t\tpl[t]=1e9;\n//\t\t\tpr[t]=0;\n\t\t\tc1=0;\n\t\t}\n\t\tal[t]+=d[i].L;\n\t\tc1++;\n\t}\n\td.clear();\n\tpl[1]=L1;\n\tfor (int i=1;i<=t1;i++){\n\t\td.push_back((node){x+1,al[i],ar[i],pl[i],pr[i]});\n\t}\n\tcnt=0;\n\tfor (int i=0;i<d.size();i++){\n\t\tif (i>=L-1)cnt+=d[i-L+1].L;\n\t\tans-=cnt*d[i].R;\n\t}\n}\nint main(){\n\tcin>>n>>L;\n\tfor (int i=1;i<=n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ts.insert((node){x,1,1,i,i});\n\t}\n\twhile (s.size()){\n\t\ts1.clear();\n\t\tint v=s.begin()->x;\n\t\tfor (auto i:s){\n\t\t\tif (!d.empty()){\n\t\t\t\tif (d.back().r+1<i.l||i.x!=v){\n\t\t\t\t\tfor (auto x:d)s.erase(x);\n\t\t\t\t\tif (d.size()<L){\n\t\t\t\t\t\td.clear();\n\t\t\t\t\t}\n\t\t\t\t\telse calc(v);\n\t\t\t\t\tfor (auto x:d)s.insert(x);\n\t\t\t\t\td.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i.x!=v)break;\n\t\t\td.push_back(i);\n\t\t}\n\t\tif (d.size()>=L){\n\t\t\tcalc(v);\n\t\t}\n\t\tif (d.size())break;\n\t}\n\tcout<<ans+n<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint L;\n\nvector<int> a;\n\nstruct I {\n\tint amax;\n\tunordered_map<int,int> pref, suff;\n\tbool tot_okay;\n\tint tot_num;\n\tI() {\n\t\tamax = 0;\n\t\tpref[0] = 1; suff[0] = 1;\n\t\ttot_okay = true;\n\t\ttot_num = 0;\n\t}\n};\n\nvoid level_up(I& v, int a){\n\tassert(a >= v.amax);\n\twhile(v.amax < a){\n\t\tv.amax += 1;\n\t\tbool did_something = false;\n\t\tunordered_map<int,int> newpref, newsuff;\n\t\tfor(auto q : v.pref){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewpref[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewpref[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tfor(auto q : v.suff){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewsuff[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewsuff[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tv.pref = newpref;\n\t\tv.suff = newsuff;\n\t\tif(v.tot_okay){\n\t\t\tif(v.tot_num == 0){\n\t\t\t} else if(v.tot_num < L){\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_okay = false;\n\t\t\t\tv.tot_num = 0;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_num /= L;\n\t\t\t}\n\t\t}\n\t\tif(!did_something) break;\n\t}\n\tv.amax = a;\n}\n\nlong long ans = 0;\n\nvector<int> arr(const unordered_map<int, int> f){\n\tvector<int> a(f.size(), -1);\n\tfor(pair<int,int> x : f){\n\t\ta[x.first] = x.second;\n\t}\n\treturn a;\n}\n\nI combine(I l, int a, I r){\n\tlevel_up(l, a);\n\tlevel_up(r, a);\n\tassert(a == l.amax);\n\tassert(a == r.amax);\n\tI res;\n\tres.amax = a;\n\tres.pref = res.suff = {};\n\tif(l.tot_okay && r.tot_okay){\n\t\tres.tot_okay = true;\n\t\tres.tot_num = l.tot_num + 1 + r.tot_num;\n\t} else {\n\t\tres.tot_okay = false;\n\t\tres.tot_num = 0;\n\t}\n\tres.pref = move(l.pref);\n\tif(l.tot_okay){\n\t\tfor(auto q : r.pref){\n\t\t\tres.pref[q.first + l.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tres.suff = move(r.suff);\n\tif(r.tot_okay){\n\t\tfor(auto q : l.suff){\n\t\t\tres.suff[q.first + r.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tvector<int> la = arr(l.suff);\n\tvector<int> ra = arr(r.pref);\n\tlong long cur = 0;\n\tcur += 1;\n\tlong long tot = 0;\n\tint j = (int)ra.size();\n\tfor(int i = 0; i < (int)la.size(); i++){\n\t\twhile(j > 0 && (j-1) + 1 + i >= L){\n\t\t\tj -= 1;\n\t\t\ttot += ra[j];\n\t\t}\n\t\tcur += la[i] * tot;\n\t}\n\tans += cur;\n\treturn res;\n}\n\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n >> L;\n\ta.resize(n);\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\n\tvector<int> b(n+2);\n\tvector<int> f(n+2);\n\tfor(int i = 0; i <= n+1; i++){\n\t\tb[i] = i-1;\n\t\tf[i] = i+1;\n\t}\n\tvector<I> data(n+2);\n\tvector<pair<int,int> > apos;\n\tfor(int i = 0; i < n; i++){\n\t\tapos.push_back({a[i], i+1});\n\t}\n\tsort(apos.begin(), apos.end());\n\tfor(auto _x : apos){\n\t\tint x = _x.second;\n\t\tf[b[x]] = f[x];\n\t\tb[f[x]] = b[x];\n\t\tdata[b[x]] = combine(data[b[x]], a[x-1], data[x]);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[200005],cur,is[200005],pw[200005],fa[200005];\nint *pre[200005],*suf[200005],cnt[200005],nwa[200005];\nll ans;\nint dp[400005],*f=dp+400000;\nint w[25000005],*at=w;\npii b[200005];\nint *newI(int n){\n\tat+=n;\n\treturn at-n;\n}\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nint nex[200005],stk[400005],tp,ist[200005];\nvoid add(int x,int y){\n//\twrite(x,'-',y,'\\n');\n\tist[y]=-1;if(!ist[x])ist[x]=1;\t\n\tstk[++tp]=x;\n\tstk[++tp]=y;\n\tnex[x]=y;\n}\nvoid put(int x){\n\tis[x]=1;\n\tnwa[x]=a[x];\n\tcnt[x]=1;\n\tpre[x]=newI(1);pre[x][0]=1;suf[x]=newI(1);suf[x][0]=1;\n\tfa[x]=x;\n\tif(is[x-1]){add(find(x-1),x);}\n\tif(is[x+1]){add(x,find(x+1));}\n}\nint id[200005],m,n,l;\nvoid solve(){\n\tint cc=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(nwa[id[i]]!=cur){\n\t\t\tint S=pw[min(cur-nwa[id[i]],n)];\n//\t\t\twrite(id[i],' ',cnt[id[i]],' ',nwa[id[i]],' ',S,'\\n');\n\t\t\tint *p=pre[id[i]],*s=suf[id[i]];\n\t\t\tfor(int j=1;j<=cnt[id[i]];++j){\n\t\t\t\tint w=p[j-1];\n\t\t\t\tp[j-1]=0;\n\t\t\t\tif(j>=S)p[j/S-1]+=w;\n\t\t\t\tw=s[j-1];\n\t\t\t\ts[j-1]=0;\n\t\t\t\tif(j>=S)s[j/S-1]+=w;\n\t\t\t}\n\t\t\tcnt[id[i]]/=S;\n\t\t}\n\t\tcc+=cnt[id[i]];\n\t}\t\n\n/*\twrite(m,'\\n');\n\tfor(int i=1;i<=m;++i){\n\t\twrite(cnt[id[i]],':');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('|');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('\\n');\n\t}*/\n\tint *np=newI(cc),*ns=newI(cc);\n\tint t=0;\n\tfor(int i=1;i<=m;++i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tnp[t]=pre[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tt=0;\n\tfor(int i=m;i;--i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tns[t]=suf[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tfor(int i=m;i;--i){\n\t\tfor(int j=1;j<=cnt[id[i]];++j)ans+=(ll)suf[id[i]][j-1]*f[max(1,l-j)];\n\t\tfor(int j=cnt[id[i]];j;--j){f[0]=f[1]+pre[id[i]][j-1];--f;}\n\t}\n\tfor(int i=1;i<=cc;++i)*(++f)=0;\n\t/*write(ans,'\\n');\n\twrite(cc,'|',id[1],'\\n');*/\n\tcnt[id[1]]=cc;\n\tpre[id[1]]=np;\n\tsuf[id[1]]=ns;\n}\nvoid work(){\n\tfor(;tp;--tp){\n\t\tif(ist[stk[tp]]<=0){ist[stk[tp]]=0;continue;}\n\t\tist[stk[tp]]=0;\n\t\tint at=stk[tp];\n\t\tm=0;\n\t\twhile(at){\n//\t\t\twrite(at,'(');\n\t\t\tid[++m]=at;\n\t\t\tfa[at]=stk[tp];\n\t\t\tint nx=nex[at];\n\t\t\tnex[at]=0;\n\t\t\tat=nx;\n\t\t}\n\t\tsolve();\n\t}\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tread(n,l);\n\tpw[0]=1;\n\tint iee=n/l+1;\n\tfor(int i=1;i<=n;++i)pw[i]=min(pw[i-1],iee)*l;\n\tfor(int i=1;i<=n;++i){read(a[i]);b[i]=make_pair(a[i],i);}\n\tsort(b+1,b+n+1);\n\tfor(int i=1,j=1;i<=n;i=j){\n\t\tcur=b[i].x;\n\t\twhile(b[i].x==b[j].x){put(b[j].y);++j;}\n\t\twork();\n\t}\n\twrite(ans+n,'\\n');\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst int N=2e5+1;\nint n,z;\npair<int,int>a[N];\nint l[N],r[N];\nint sl[N],sr[N],sx[N];\nint sz=0;\ndeque<int>v[2*N];\nvector<ll>pw;\nll ans=0;\nvoid shrink(int vt,int sf){\n\tint ls=v[vt].size()/sf;\n\tfor(int i=0; i<ls ;i++) v[vt][i]=v[vt][(i+1)*sf-1];\n\tv[vt].resize(ls);\n}\nvoid merge(int ml,int mr){\n\tif(sx[mr]<=sx[ml]){\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=r[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sl[ml],pr=sr[ml];\n\t\tint ql=sl[mr],qr=sr[mr];\n\t\tint dl=l[ml],dr=r[mr];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint nxt=dr+1;\n\t\t\tif(i!=v[ql].size()-1) nxt=v[ql][i+1];\n\t\t\tans+=1LL*(nxt-v[ql][i])*(v[pr][x-1]-dl+1);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++) v[pl].push_back(v[ql][i]);\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--) v[pr].push_front(v[qr][i]);\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dr]=sx[dl];\n\t\tsl[dr]=sl[dl];\n\t\tsr[dr]=sr[dl];\n\t}\n\telse{\n\t\tswap(ml,mr);\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=r[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sr[ml],pr=sl[ml];\n\t\tint ql=sr[mr],qr=sl[mr];\n\t\tint dl=l[mr],dr=r[ml];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint nxt=dl-1;\n\t\t\tif(i!=v[ql].size()-1) nxt=v[ql][i+1];\n\t\t\tans+=1LL*(v[ql][i]-nxt)*(dr-v[pr][x-1]+1);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++) v[pl].push_back(v[ql][i]);\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--) v[pr].push_front(v[qr][i]);\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dl]=sx[dr];\n\t\tsl[dl]=sl[dr];\n\t\tsr[dl]=sr[dr];\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> z;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> a[i].fi;\n\t\ta[i].se=i;\n\t}\n\tpw.push_back(1);\n\twhile(pw.back()*z<=n){\n\t\tpw.push_back(pw.back()*z);\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1; i<=n ;i++){\n\t\tint cl=i,cr=i;\n\t\twhile(cr<n && a[cr+1].fi==a[cl].fi) cr++;\n\t\ti=cr;\n\t\tfor(int j=cl; j<=cr ;j++){\n\t\t\tint x=a[j].se;\n\t\t\tl[x]=r[x]=x;\n\t\t\tsx[x]=a[j].fi;\n\t\t\tsl[x]=++sz;v[sz].push_back(x);\n\t\t\tsr[x]=++sz;v[sz].push_back(x);\n\t\t\tif(r[x-1]!=0) merge(x-1,x);\n\t\t\tif(l[x+1]!=0) merge(x,x+1);\n\t\t}\n\t}\n\tcout << ans+n << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (200010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\n#define int long long\n#define fi first\n#define se second\n#define mkp make_pair\nint n,m,now,a[N]; pair<int,int> pos[N];\nLL ans; vector<pair<pair<int,int>,pair<int,int> > >t,tmp;\nvector<pair<int,int> > wk,pp;\nint calc(vector<pair<int,int> > &a){\n\tLL sum=0,ans=0;\n\tfor(int i=0,j=m-1;j<a.size();i++,j++)\n\tsum+=a[i].fi,ans+=sum*a[j].se;\n\treturn ans;\n}\nsigned main(){\n\tread(n),read(m),ans=n;\n\tfor(int i=1;i<=n;i++)read(a[i]),pos[i]=mkp(a[i],i);\n\tsort(pos+1,pos+n+1);\n\tfor(int p=1,val=0;p<=n||!t.empty();){\n\t\tif(t.empty())val=pos[p].fi;else val++;\n\t\tfor(;pos[p].fi==val;p++)t.emplace_back(mkp(pos[p].se,pos[p].se),mkp(1,1));\n\t\ttmp.clear(),sort(t.begin(),t.end());\n\t\tfor(int i=0,j=0;i<t.size();i=j+1){\n\t\t\tfor(j=i;j+1<t.size()&&t[j+1].fi.fi==t[j].fi.se+1;j++);\n\t\t\tint len=j-i+1,cnt=len/m;\n\t\t\tif(cnt){\n\t\t\t\twk.clear();\n\t\t\t\tfor(int k=i;k<=j;k++)wk.push_back(t[k].se);\n\t\t\t\tans+=calc(wk),wk.clear(),wk.resize(cnt),pp.clear();\n\t\t\t\tfor(int k=1;k<=cnt;k++)\n\t\t\t\tpp.emplace_back(t[i].fi.fi+k-1,(k==cnt)?t[j].fi.se:t[i].fi.fi+k-1);\n\t\t\t\tfor(int k=i;k<=j;k++){\n\t\t\t\t\tint l=k-i+1,r=j-k+1;\n\t\t\t\t\tif(l>=m)wk[l/m-1].se+=t[k].se.se;\n\t\t\t\t\tif(r>=m)wk[cnt-r/m].fi+=t[k].se.fi;\n\t\t\t\t}\n\t\t\t\tans-=calc(wk);\n\t\t\t\tfor(int k=0;k<pp.size();k++)tmp.emplace_back(pp[k],wk[k]);\n\t\t\t}\n\t\t}\n\t\tt=tmp;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst int N=2e5+1;\nint n,z;\npair<int,int>a[N];\nint l[N],r[N];\nint sl[N],sr[N],sx[N];\nint sz=0;\ndeque<pair<int,int> >v[2*N];\ndeque<int>gg[2*N];\nll hh[2*N];\nvector<ll>pw;\nll ans=0;\nvoid shrink(int vt,int sf){\n\tint ls=v[vt].size()/sf;\n\tif(ls==0){\n\t\tv[vt].clear();return;\n\t}\n\tint gd=v[vt].back().se;\n\tfor(int i=0; i<ls ;i++){\n\t\tv[vt][i].fi=v[vt][(i+1)*sf-1].fi;\n\t\tif(i!=ls-1) v[vt][i].se=v[vt][(i+2)*sf-2].se;\n\t}\n\tv[vt][ls-1].se=gd;\n\tv[vt].resize(ls);\n\thh[vt]=0;\n\tgg[vt].resize(ls);\n\tll mz=0;\n\tfor(int i=0; i<ls ;i++){\n\t\tmz+=max(v[vt][i].se,v[vt][i].fi)-min(v[vt][i].se,v[vt][i].fi)+1;\n\t\tgg[vt][i]=mz;\n\t}\n}\nvoid merge(int ml,int mr){\n\t//cout << \"merge \" << ml << ' ' << mr << endl;\n\tif(sx[mr]<=sx[ml]){\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();gg[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();gg[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=r[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sl[ml],pr=sr[ml];\n\t\tint ql=sl[mr],qr=sr[mr];\n\t\tint dl=l[ml],dr=r[mr];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint bona=v[ql][i].se-v[ql][i].fi+1;\n\t\t\tll bruh=hh[pr];\n\t\t\tif(x>=2) bruh=gg[pr][x-2];\n\t\t\tans+=1LL*bona*(gg[pr].back()-bruh);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tv[pl].push_back(v[ql][i]);\n\t\t\tgg[pl].push_back(gg[pl].back()+v[ql][i].se-v[ql][i].fi+1);\n\t\t}\n\t\tll mz=hh[pr];\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--){\n\t\t\tv[pr].push_front(v[qr][i]);\n\t\t\tgg[pr].push_front(mz);\n\t\t\tmz-=v[qr][i].fi-v[qr][i].se+1;\n\t\t}\n\t\thh[pr]=mz;\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dr]=sx[dl];\n\t\tsl[dr]=sl[dl];\n\t\tsr[dr]=sr[dl];\n\t}\n\telse{\n\t\tswap(ml,mr);\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();gg[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();gg[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=l[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sr[ml],pr=sl[ml];\n\t\tint ql=sr[mr],qr=sl[mr];\n\t\tint dl=l[mr],dr=r[ml];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint bona=v[ql][i].fi-v[ql][i].se+1;\n\t\t\tll bruh=hh[pr];\n\t\t\tif(x>=2) bruh=gg[pr][x-2];\n\t\t\tans+=1LL*bona*(gg[pr].back()-bruh);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tv[pl].push_back(v[ql][i]);\n\t\t\tgg[pl].push_back(gg[pl].back()+v[ql][i].fi-v[ql][i].se+1);\n\t\t}\n\t\tll mz=hh[pr];\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--){\n\t\t\tv[pr].push_front(v[qr][i]);\n\t\t\tgg[pr].push_front(mz);\n\t\t\tmz-=v[qr][i].se-v[qr][i].fi+1;\n\t\t}\n\t\thh[pr]=mz;\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dl]=sx[dr];\n\t\tsl[dl]=sl[dr];\n\t\tsr[dl]=sr[dr];\n\t}\n\t//cout << ans << endl;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> z;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> a[i].fi;\n\t\ta[i].se=i;\n\t}\n\tpw.push_back(1);\n\twhile(pw.back()*z<=n){\n\t\tpw.push_back(pw.back()*z);\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1; i<=n ;i++){\n\t\tint cl=i,cr=i;\n\t\twhile(cr<n && a[cr+1].fi==a[cl].fi) cr++;\n\t\ti=cr;\n\t\tfor(int j=cl; j<=cr ;j++){\n\t\t\tint x=a[j].se;\n\t\t\tl[x]=r[x]=x;\n\t\t\tsx[x]=a[j].fi;\n\t\t\tsl[x]=++sz;v[sz].push_back({x,x});gg[sz].push_back(1);\n\t\t\tsr[x]=++sz;v[sz].push_back({x,x});gg[sz].push_back(1);\n\t\t\tif(r[x-1]!=0) merge(x-1,x);\n\t\t\tif(l[x+1]!=0) merge(x,x+1);\n\t\t}\n\t}\n\tcout << ans+n << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define N 200127\n#define INF 0x3f3f3f3f\nint n,m,a[N],mi=INF,L[N],R[N],vl[N],vr[N],v1[N],v2[N];\nstruct Point{\n\tint x,v;\n\tinline bool operator<(const Point &b)const{return (v>b.v)||((v==b.v)&&(x>b.x));}\n};\npriority_queue<Point>q;\nint b[N],cn=0;long long ans=0;\nint main(){\n\tscanf(\"%d%d\",&n,&m);ans=n;int i,j,k,v,l,r,p,sum;for(i=1;i<=n;i++)scanf(\"%d\",&a[i]),L[i]=i-1,R[i]=i+1,vl[i]=vr[i]=1,q.push((Point){i,a[i]});\n\twhile(!q.empty())\n\t{\n\t\tcn=0;v=q.top().v;while((!q.empty())&&(v==q.top().v))b[++cn]=q.top().x,q.pop();\n\t\tfor(i=1;i<=cn;i=r+1)\n\t\t{\n\t\t\tl=r=i;while((r<cn)&&(R[b[r]]==b[r+1]))++r;\n\t\t\tsum=0;for(i=l;i<=r;i++){if(i-m+1>=l)sum+=vl[b[i-m+1]];ans+=1ll*sum*vr[b[i]];}\n\t\t\tif(r-l+1<m){R[L[b[l]]]=n+1;L[R[b[r]]]=0;continue;}p=(r-l+1)/m;\n\t\t\tfor(i=l;i<=r;i++)k=b[i],v1[k]=vl[k],v2[k]=vr[k],vl[k]=vr[k]=0;\n\t\t\tfor(i=r-m+1,k=p;i>=l;i-=m,--k)for(j=i;(j>=l)&&(j>=i-m+1);j--)vl[b[l+k-1]]+=v1[b[j]];\n\t\t\tfor(i=l+m-1,k=1;i<=r;i+=m,++k)for(j=i;(j<=r)&&(j<=i+m-1);j++)vr[b[l+k-1]]+=v2[b[j]];\n\t\t\tfor(i=l;i<=l+p-1;i++)++a[b[i]],q.push((Point){b[i],a[b[i]]});L[R[b[r]]]=b[l+p-1];R[b[l+p-1]]=R[b[r]];\n\t\t\tsum=0;for(i=l;i<=l+p-1;i++){if(i-m+1>=l)sum+=vl[b[i-m+1]];ans-=1ll*sum*vr[b[i]];}\n\t\t}\n\t}printf(\"%lld\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 2.1e5;\nint N, L;\nint A[MAXN];\n\nconst int S = 1 << 18;\nint seg[2 * S];\nunordered_map<int, vector<int>> vals;\n\nvoid precomp() {\n\tmemset(seg, -1, sizeof(seg));\n\tfor (int i = 0; i < N; i++) {\n\t\tseg[S + i] = A[i];\n\t\tvals[A[i]].push_back(i);\n\t}\n\tfor (int i = S-1; i > 0; i--) {\n\t\tseg[i] = max(seg[2 * i], seg[2 * i + 1]);\n\t}\n}\n\nint query_max(int a, int b) {\n\tint res = -1;\n\tfor (int l = a+S, r = b+S; l < r; l /= 2, r /= 2) {\n\t\tif (l & 1) {\n\t\t\tres = max(res, seg[l]);\n\t\t\t++l;\n\t\t}\n\t\tif (r & 1) {\n\t\t\t--r;\n\t\t\tres = max(res, seg[r]);\n\t\t}\n\t}\n\treturn res;\n}\n\nll ans = 0;\n\nstruct rangeData {\n\tint k = -1;\n\tint wholeValue = -1;\n\tvector<int> lPts = vector<int>({1}); // number of pts of each size\n\tvector<int> rPts = vector<int>({1}); // number of pts of each size\n};\n\nvector<int> upCast(vector<int> v) {\n\tassert(!v.empty());\n\tassert(v[0] == 1);\n\tvector<int> res((v.size() - 1) / L + 1);\n\tres[0] = v[0];\n\tfor (int i = L; i < int(v.size()); i++) {\n\t\tres[i / L] += v[i];\n\t}\n\treturn res;\n}\n\nrangeData upCast(rangeData r, int v) {\n\tassert(r.k < v);\n\twhile (r.k < v) {\n\t\tif (r.lPts.size() == 1 && r.rPts.size() == 1) {\n\t\t\tassert(r.wholeValue == 0 || r.wholeValue == -1);\n\t\t\t// no more shrinking is possible;\n\t\t\tr.k = v;\n\t\t\tbreak;\n\t\t}\n\t\tassert(r.wholeValue != 0);\n\t\tif (r.wholeValue >= L) {\n\t\t\tr.wholeValue /= L;\n\t\t} else {\n\t\t\tr.wholeValue = -1;\n\t\t}\n\t\tr.lPts = upCast(std::move(r.lPts));\n\t\tr.rPts = upCast(std::move(r.rPts));\n\t\tr.k ++;\n\t}\n\treturn r;\n}\n\nrangeData dfs(int l, int r) {\n\tif (l == r) {\n\t\t// wholeValue = 0 means it's empty\n\t\treturn rangeData {-1, 0, vector<int>({1}), vector<int>({1})};\n\t}\n\n\tassert(l < r);\n\tint k = query_max(l, r);\n\tvector<int> locs;\n\tlocs.push_back(l-1);\n\t{\n\t\tconst vector<int>& v = vals[k];\n\t\tlocs.insert(locs.end(), lower_bound(v.begin(), v.end(), l), lower_bound(v.begin(), v.end(), r));\n\t}\n\tlocs.push_back(r);\n\tint M = int(locs.size()) - 1;\n\tvector<rangeData> ranges;\n\tfor (int i = 0; i < M; i++) {\n\t\tranges.emplace_back(upCast(dfs(locs[i]+1, locs[i+1]), k));\n\t}\n\n\tvector<int> rCnt({0});\n\tfor (int i = 0; i < M; i++) {\n\t\tconst rangeData& d = ranges[i];\n\t\tassert(d.k == k);\n\t\tfor (int z = 0; z < int(d.lPts.size()); z++) {\n\t\t\t//cerr << z << ' ' << d.lPts[z] << ' ' << getNumLeft(offset - (L - min(z+1, L))) << '\\n';\n\t\t\tans += 1ll * d.lPts[z] * rCnt[max(0, int(rCnt.size()) - 1 - max(0, L - (z+1)))];\n\t\t}\n\t\tif (d.wholeValue == -1) {\n\t\t\trCnt = vector<int>({0});\n\t\t}\n\t\tfor (int z = int(d.rPts.size()) - 1; z >= 0; z--) {\n\t\t\trCnt.push_back(rCnt.back() + d.rPts[z]);\n\t\t}\n\t}\n\n\trangeData res{k, M-1, vector<int>({}), vector<int>({})};\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ranges[i].wholeValue == -1) {\n\t\t\tres.wholeValue = -1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tres.wholeValue += ranges[i].wholeValue;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tconst rangeData& d = ranges[i];\n\t\tres.lPts.insert(res.lPts.end(), d.lPts.begin(), d.lPts.end());\n\t\tif (d.wholeValue == -1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = M-1; i >= 0; i--) {\n\t\tconst rangeData& d = ranges[i];\n\t\tres.rPts.insert(res.rPts.end(), d.rPts.begin(), d.rPts.end());\n\t\tif (d.wholeValue == -1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\tcerr << \"return \" << l << ' ' << r << '\\n';\n\tcerr << res.k << ' ' << res.wholeValue << '\\n';\n\tfor (auto c : res.lPts) { cerr << c << ' '; } cerr << '\\n';\n\tfor (auto c : res.rPts) { cerr << c << ' '; } cerr << '\\n';\n\tfor (int i = 0; i < M; i++) {\n\t\tcerr << \"range\" << '\\n';\n\t\tcerr << ranges[i].k << ' ' << ranges[i].wholeValue << '\\n';\n\t\tfor (auto c : ranges[i].lPts) { cerr << c << ' '; } cerr << '\\n';\n\t\tfor (auto c : ranges[i].rPts) { cerr << c << ' '; } cerr << '\\n';\n\t}\n\t*/\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> L;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t}\n\tprecomp();\n\tdfs(0, N);\n\tans += N;\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,L;\nll ans;\nstruct Inter{\n\tint pos,val,l,r;\n\tInter(int _p=0,int _v=0,int _l=0,int _r=0){pos=_p,val=_v,l=_l,r=_r;}\n};\nstruct cmp1{\n\tbool operator ()(const Inter a,const Inter b)const{\n\t\treturn a.pos<b.pos;\n\t}\n};\nstruct cmp2{\n\tbool operator ()(const Inter a,const Inter b)const{\n\t\treturn a.val==b.val?a.pos<b.pos:a.val<b.val;\n\t}\n};\nset<Inter,cmp1> p;\nset<Inter,cmp2> s;\ninline int calc(vector<Inter> &v){\n\tll tot=0,sum=0;\n\tfor(int i=0;i+L-1<(int)v.size();++i){\n\t\tsum+=v[i].l;\n\t\ttot+=sum*v[i+L-1].r;\n\t}\n\treturn tot;\n}\nint main(){\n\tn=read(),L=read();\n\tfor(int i=1;i<=n;++i){\n\t\tint x=read();\n\t\tInter zyk(i,x,1,1);\n\t\tp.insert(zyk),s.insert(zyk);\n\t}\n\twhile(!s.empty()){\n\t\tint w=s.begin()->val;\n\t\tvector<Inter> t;\n\t\twhile(s.begin()->val==w){\n\t\t\tt.push_back(*s.begin());\n\t\t\ts.erase(s.begin());\n\t\t}\n\t\tfor(int l=0,r=1;l<(int)t.size();l=r++){\n\t\t\twhile(r<(int)t.size()&&(--p.find(t[r]))==p.find(t[r-1]))++r;\n\t\t\tint len=r-l,cnt=len/L;\n\t\t\tif(!cnt)continue;\n\t\t\tvector<Inter> myh,zyy;\n\t\t\tmyh.insert(myh.begin(),t.begin()+l,t.begin()+r);\n\t\t\tfor(auto x:myh){\n\t\t\t\tp.erase(x);\n\t\t\t}\n\t\t\tans+=calc(myh);\n\t\t\tfor(int i=0;i<cnt;++i){\n\t\t\t\tzyy.push_back(Inter(myh[0].pos+i,w+1,0,0));\n\t\t\t}\n\t\t\tfor(int i=0;i+L-1<(int)myh.size();++i){\n\t\t\t\tzyy[cnt-((int)myh.size()-i)/L].l+=myh[i].l;\n\t\t\t}\n\t\t\tfor(int i=L-1;i<(int)myh.size();++i){\n\t\t\t\tzyy[(i-L+1)/L].r+=myh[i].r;\n\t\t\t}\n\t\t\tans-=calc(zyy);\n\t\t\tfor(auto x:zyy){\n\t\t\t\tp.insert(x),s.insert(x);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long li;\ntypedef unsigned long long lu;\nconst int inf = ~0U >> 2;\nconst li infl = ~0LLU >> 2;\n\ntemplate <class T> inline void Min(T &x, T y) { if (y < x) x = y; }\ntemplate <class T> inline void Max(T &x, T y) { if (y > x) x = y; }\n\nconst int mod = 1e9 + 7;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\nint Pow(int x, int y) { int z = 1;                                      \\\n  for (; y; y >>= 1, x = Mul(x, x)) { if (y & 1) z = Mul(z, x); } return z; }\ninline int Inv(int x) { return Pow(x, mod - 2); }\ninline int Fix(li x) { x %= mod; if (x < 0) x += mod; return (int)x; }\ninline int Fix(int x) { x %= mod; if (x < 0) x += mod; return x; }\n\n// ----------------------------------------\n\nconst int maxn = 2e5;\n\nint n, lim;\nint st[maxn], top;\nint L[maxn], R[maxn];\nli ans;\n\nli Ways(int l, int r) {\n  li sum = 0, tot = 0;\n  for (int i = r - 1; i >= l + lim - 1; --i) {\n    sum += R[i];\n    tot += (li)L[i - lim + 1] * sum;\n  }\n  for (int i = l; i < r; ++i) {\n    tot += (li)L[i] * R[i];\n  }\n  return tot;\n}\n\nvoid Merge(void) {\n  int val = st[top - 1];\n  int begin = top - 1;\n  while (begin > 0 && st[begin - 1] == st[begin]) {\n    --begin;\n  }\n  int end = top;\n  ans += Ways(begin, end);\n\n  if (end - begin < lim) {\n    top = begin;\n    return;\n  }\n  int len = (end - begin) / lim;\n\n  static int cntP[maxn + 1], cntS[maxn + 1];\n  FILL(cntP, len + 1, 0);\n  FILL(cntS, len + 1, 0);\n  for (int i = begin; i < end; ++i) {\n    int c = i - begin + 1;\n    if (c >= lim) {\n      cntP[c / lim] += R[i];\n    }\n    c = end - i;\n    if (c >= lim) {\n      cntS[c / lim] += L[i];\n    }\n  }\n  top = begin + len;\n  for (int i = 0; i < len; ++i) {\n    st[begin + i] = val + 1;\n    L[begin + i] = cntS[len - i];\n    R[begin + i] = cntP[i + 1];\n  }\n\n  ans -= Ways(begin, top);\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &lim);\n  top = 0;\n  ans = 0;\n  for (int i = 0; i < n; ++i) {\n    int now;\n    scanf(\"%d\", &now);\n    while (top > 0 && st[top - 1] < now) {\n      Merge();\n    }\n    L[top] = R[top] = 1;\n    st[top++] = now;\n  }\n  while (top > 0) {\n    Merge();\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\ntypedef pair<int,int> pr;\nll ans;\nint n,L;\npr p[201000];\nll calc(vector<pair<pr,pr> > v){\n\tll now=0;\n//\tfor(auto&x:v) now+=x.second.first*x.second.second;\n\tll s=0;\n\tfor(int i=0,j=L-1;j<v.size();i++,j++)\n\t\ts+=v[i].second.first,now+=v[j].second.second*s;\n\treturn now;\n}\nvector<pair<pr,pr> > merge(vector<pair<pr,pr> > v){\n\tvector<pair<pr,pr> > res;\n\tif(v.size()<L) return res;\n\tint cnt=v.size()/L;\n\tfor(int i=0;i<cnt;i++)\n\t\tres.emplace_back(pr{v[i*L].first.first,i==cnt-1?v.back().first.second:v[i*L+L-1].first.second},pr{0,0});\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i+1>=L) res[(i+1)/L-1].second.second+=v[i].second.second;\n\t\tif(v.size()-i>=L) res[cnt-(v.size()-i)/L].second.first+=v[i].second.first;\n\t}\n\tans-=calc(res);\n\treturn res;\n}\nint main(){\n\tread(n);read(L);\n\tfor(int i=1;i<=n;i++){\n\t\tint x;read(x);\n\t\tp[i]=pr{x,i};\n\t}\n\tsort(p+1,p+n+1);\n\tint now=1,k;ans=n;\n\tvector<pair<pr,pr> > v;\n\twhile(!v.empty()||now<=n){\n\t\tif(v.empty()) k=p[now].first;\n\t\telse k++;\n\t\twhile(now<=n&&k==p[now].first) v.emplace_back(pr{p[now].second,p[now].second},pr{1,1}),now++;\n\t\tsort(v.begin(),v.end());\n\t\tvector<pair<pr,pr> > nxt;\n\t\tfor(int i=0,j=0;i<v.size();i=++j){\n\t\t\tvector<pair<pr,pr> > res;\n\t\t\tres.push_back(v[i]);\n\t\t\twhile(j+1<v.size()&&v[j+1].first.first==v[j].first.second+1) res.push_back(v[++j]);\n\t\t\tans+=calc(res);\n\t\t\tfor(auto&x:merge(res)) nxt.push_back(x);\n\t\t}\n\t\tv=nxt;\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\nconst int N = 2e5 + 5;\n\n#define pii pair<int, int>\n#define ll long long\n\ntypedef class Segment {\n\tpublic:\n\t\tint l, r, x, y;\n\n\t\tSegment() {\t}\n\t\tSegment(int l, int r, int x, int y) : l(l), r(r), x(x), y(y) {\t}\n\n\t\tboolean operator < (Segment b) const {\n\t\t\treturn l < b.l;\n\t\t}\n} Segment;\n\nint n, L;\nint a[N];\npii b[N];\n\nll calc(vector<pii>& a) {\n\tll ret = 0, sum = 0;\n\tfor (int l = 0, r = L - 1; r < (signed) a.size(); l++, r++) {\n\t\tret += (sum += a[l].first) * a[r].second;\n\t}\n\treturn ret;\n}\n\nll ans = 0;\nint main() {\n\tscanf(\"%d%d\", &n, &L);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", a + i);\n\t\tb[i] = pii(a[i], i);\n\t}\n\tans = n;\n\tsort(b + 1, b + n + 1);\n\tint pos = 1, val;\n\tvector<Segment> vcur, vnxt, vadd;\n\twhile (true) {\n\t\tif (!vcur.size()) {\n\t\t\tif (pos > n) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tval = b[pos].first;\n\t\t\t}\n\t\t} else {\n\t\t\tval++;\n\t\t}\n//\t\tcerr << pos << \" \" << val << '\\n';\n\t\tvadd.clear();\n\t\twhile (pos <= n && b[pos].first == val)\n\t\t\tvadd.emplace_back(b[pos].second, b[pos].second, 1, 1), pos++;\n\t\tvnxt.resize(vcur.size() + vadd.size());\n\t\tmerge(vcur.begin(), vcur.end(), vadd.begin(), vadd.end(), vnxt.begin());\n\t\tswap(vcur, vnxt);\n\t\tvnxt.clear();\n\t\tint num = vcur.size();\n\t\tfor (int i = 0, j = 0; i < num; i = ++j) {\n\t\t\twhile (j < num - 1 && vcur[j].r + 1 == vcur[j + 1].l)\n\t\t\t\tj++;\n\t\t\tint len = j - i + 1, cnt = len / L;\n\t\t\tif (cnt) {\n\t\t\t\tvector<pii> tmp;\n\t\t\t\tfor (int k = i; k <= j; k++)\n\t\t\t\t\ttmp.emplace_back(vcur[k].x, vcur[k].y);\n\t\t\t\tans += calc(tmp);\n\t\t\t\ttmp.clear();\n\t\t\t\ttmp.resize(cnt, pii(0, 0));\n\t\t\t\tfor (int k = L - 1; k < len; k++) {\n\t\t\t\t\ttmp[cnt - (k - L + 1) / L - 1].first += vcur[j - k].x;\n\t\t\t\t}\n\t\t\t\tfor (int k = L - 1; k < len; k++) {\n\t\t\t\t\ttmp[(k - L + 1) / L].second += vcur[i + k].y;\n\t\t\t\t}\n\t\t\t\tans -= calc(tmp);\n\t\t\t\tfor (int k = 0; k < cnt; k++)\n\t\t\t\t\tvnxt.emplace_back(vcur[i].l + k, vcur[i].l + k, tmp[k].first, tmp[k].second);\n\t\t\t\tvnxt.back().r = vcur[j].r;\n\t\t\t}\n\t\t}\n\t\tswap(vcur, vnxt);\n\t\tvnxt.clear();\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define pii pair<int,int>\n#define riterator reverse_iterator\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 2e5;\npriority_queue<pii,vector<pii>,greater<pii> > que;\nint nxt[N+3],prv[N+3];\nint a[N+3];\nllong cl[N+3],cr[N+3],cl2[N+3],cr2[N+3];\nvector<int> vec;\nint n,m; llong ans;\n\nvoid solve(int l,int r)\n{\n\tprintf(\"solve %d %d\\n\",l,r);\n\tllong sum = 0ll;\n\tfor(int i=m-1; i<vec.size(); i++)\n\t{\n\t\tsum += cl[vec[i-m+1]];\n\t\tans += cr[vec[i]]*sum;\n\t}\n\tint cnt = vec.size()/m;\n\tfor(int i=l; i<=l+cnt-1; i++) cl2[i] = cr2[i] = 0ll;\n\tfor(int i=vec.size()-m,j=0,k=l+cnt-1; i>=0; i--)\n\t{\n\t\tcl2[k] += cl[vec[i]];\n\t\tif(j==m-1) {k--,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=m-1,j=0,k=l; i<vec.size(); i++)\n\t{\n\t\tcr2[k] += cr[vec[i]];\n\t\tif(j==m-1) {k++,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=l; i<=l+cnt-1; i++) cl[i] = cl2[i],cr[i] = cr2[i];\n\tsum = 0ll;\n\tfor(int i=l+m-1; i<=l+cnt-1; i++)\n\t{\n\t\tsum += cl[i-m+1];\n\t\tans -= cr[i]*sum;\n\t}\n\tif(cnt==0)\n\t{\n\t\tnxt[prv[l]] = nxt[r]; prv[nxt[r]] = prv[l];\n\t}\n\telse\n\t{\n\t\tnxt[l+cnt-1] = nxt[r]; prv[nxt[r]] = l+cnt-1;\n\t\tfor(int i=l; i<l+cnt-1; i++) nxt[i] = i+1;\n\t\tfor(int i=l+1; i<=l+cnt-1; i++) prv[i] = i-1;\n\t\tint val = a[l]; for(int i=l; i<=l+cnt-1; i++) a[i] = val+1;\n\t\tfor(int i=l; i<=l+cnt-1; i++) que.push(mkpr(a[i],i));\n\t}\n//\tprintf(\"cnt=%d\\n\",cnt);\n//\tprintf(\"prv: \"); for(int i=1; i<=n+1; i++) printf(\"[%d]%d \",i,prv[i]); puts(\"\");\n//\tprintf(\"nxt: \"); for(int i=0; i<=n; i++) printf(\"[%d]%d \",i,nxt[i]); puts(\"\");\n//\tprintf(\"cl: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cl[i]); puts(\"\");\n//\tprintf(\"cr: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cr[i]); puts(\"\");\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&a[i]),que.push(mkpr(a[i],i)),cl[i] = cr[i] = 1ll,nxt[i] = i+1,prv[i] = i-1;\n\tnxt[0] = 1,prv[n+1] = n;\n\twhile(1)\n\t{\n\t\tint l = que.top().second,r = l; que.pop(); vec.clear(); vec.push_back(l);\n\t\twhile(!que.empty() && que.top().first==a[l] && que.top().second==nxt[r]) {r = nxt[r]; vec.push_back(r); que.pop();}\n\t\tsolve(l,r);\n\t\tif(nxt[0]==n+1) break;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\n#define G getchar()\ninline int read()\n{\n\tint x=0; bool flg=false; char ch=G;\n\tfor (;!isdigit(ch);ch=G) if (ch=='-') flg=true;\n\tfor (;isdigit(ch);ch=G) x=(x<<3)+(x<<1)+(ch^48);\n\treturn flg?-x:x;\n}\n#undef G\ntypedef long long ll;\n\nint n,K;\nint a[200010];\nint p[200010];\nbool cmp(int x,int y){\n\tif (a[x]^a[y]) return a[x]<a[y];\n\treturn x<y;\n}\nstruct Rec{\n\tint l,r,L,R;\n}A[200010],B[200010]; int Atot,Btot;\nll ans;\nint main()\n{\n\t//freopen(\"data.in\",\"r\",stdin);\n\t//freopen(\"A.out\",\"w\",stdout);\n\n\tn=read(),K=read(); ans=n;\n\tfor (int i=1;i<=n;i++) a[i]=read(),p[i]=i;\n\tsort(p+1,p+n+1,cmp);\n\tint pos=1,T;  //next considered; cur val\n\twhile (1){\n\t\tif (!Atot){\n\t\t\tif (pos>n) break;\n\t\t\tT=a[p[pos]];\n\t\t}\n\t\tBtot=0;\n\t\tfor (int i=1;i<=Atot;i++){\n\t\t\twhile (pos<=n&&a[p[pos]]==T&&p[pos]<A[i].l)\n\t\t\t\tB[++Btot]=(Rec){p[pos],p[pos],1,1},pos++;\n\t\t\tB[++Btot]=A[i];\n\t\t}\n\t\twhile (pos<=n&&a[p[pos]]==T)\n\t\t\tB[++Btot]=(Rec){p[pos],p[pos],1,1},pos++;\n\t\tAtot=Btot; for (int i=1;i<=Atot;i++) A[i]=B[i];\n\t\tfor (int i=1,lst=-1,Ltot=0;i<=Atot;i++){\n\t\t\tif (i==1||A[i].l-1!=A[i-1].r) lst=i,Ltot=0;\n\t\t\tif (i-lst+1>=K) Ltot+=A[i-K+1].L;\n\t\t\tans+=1LL*Ltot*A[i].R;\n\t\t}\n\t\tBtot=0;\n\t\tfor (int i=1,j;i<=Atot;i=j+1){\n\t\t\tfor (j=i;j+1<=Atot&&A[j].r+1==A[j+1].l;j++);\n\t\t\tif (j-i+1<K) continue;\n\t\t\tint t=(j-i+1)/K;\n\t\t\tfor (int s=1,cur=K;s<=t;s++){\n\t\t\t\tB[++Btot]=(Rec){A[i].l+s-1,A[i].l+s-1,0,0};\n\t\t\t\twhile (cur<=j-i+1&&cur/K==s){\n\t\t\t\t\tB[Btot].R+=A[i+cur-1].R;\n\t\t\t\t\tB[Btot].L+=A[j-cur+1].L;\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int a=Btot-t+1,b=Btot;a<b;swap(B[a++].L,B[b--].L));\n\t\t\tB[Btot].r=A[j].r;\n\t\t}\n\t\tAtot=Btot; for (int i=1;i<=Atot;i++) A[i]=B[i];\n\t\tfor (int i=1,lst=-1,Ltot=0;i<=Atot;i++){\n\t\t\tif (i==1||A[i].l-1!=A[i-1].r) lst=i,Ltot=0;\n\t\t\tif (i-lst+1>=K) Ltot+=A[i-K+1].L;\n\t\t\tans-=1LL*Ltot*A[i].R;\n\t\t}\n\t\tT++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxp];\nint main()\n{\n//\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout); \n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<25;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue; assert(H[i+1]==H[i]+1);\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int j=1;j<=k;++j)\n\t\t\t{\n\t\t\t\ttmp[j].l=tmp[j].r=tmp[j-1].l+1;\n\t\t\t\ttmp[j].L=tmp[j].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tfor(int j=l;j<=r;++j)\n\t\t\t{\n\t\t\t\tint x=j-l+1,y=r-j+1;\n\t\t\t\tif(x>=L) tmp[x/L].R+=rec[i][j].R;\n\t\t\t\tif(y>=L) tmp[k-y/L+1].L+=rec[i][j].L;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\tfor(int j=1;j<=k;++j) rec[i+1].push_back(tmp[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long li;\ntypedef unsigned long long lu;\nconst int inf = ~0U >> 2;\nconst li infl = ~0LLU >> 2;\n\ntemplate <class T> inline void Min(T &x, T y) { if (y < x) x = y; }\ntemplate <class T> inline void Max(T &x, T y) { if (y > x) x = y; }\n\nconst int mod = 1e9 + 7;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\nint Pow(int x, int y) { int z = 1;                                      \\\n  for (; y; y >>= 1, x = Mul(x, x)) { if (y & 1) z = Mul(z, x); } return z; }\ninline int Inv(int x) { return Pow(x, mod - 2); }\ninline int Fix(li x) { x %= mod; if (x < 0) x += mod; return (int)x; }\ninline int Fix(int x) { x %= mod; if (x < 0) x += mod; return x; }\n\n// ----------------------------------------\n\nconst int maxn = 2e5;\n\nint n, lim;\nint st[maxn], top;\nint L[maxn], R[maxn];\nint ans;\n\nint Ways(int l, int r) {\n  int sum = 0, tot = 0;\n  for (int i = r - 1; i >= l + lim - 1; --i) {\n    Add(sum, R[i]);\n    Add(tot, Mul(L[i - lim + 1], sum));\n  }\n  for (int i = l; i < r; ++i) {\n    Add(tot, Mul(L[i], R[i]));\n  }\n  return tot;\n}\n\nvoid Merge(void) {\n  int val = st[top - 1];\n  int begin = top - 1;\n  while (begin > 0 && st[begin - 1] == st[begin]) {\n    --begin;\n  }\n  int end = top;\n  Add(ans, Ways(begin, end));\n\n  if (end - begin < lim) {\n    top = begin;\n    return;\n  }\n  int len = (end - begin) / lim;\n\n  static int cntP[maxn + 1], cntS[maxn + 1];\n  FILL(cntP, len + 1, 0);\n  FILL(cntS, len + 1, 0);\n  for (int i = begin; i < end; ++i) {\n    int c = i - begin + 1;\n    if (c >= lim) {\n      cntP[c / lim] += R[i];\n    }\n    c = end - i;\n    if (c >= lim) {\n      cntS[c / lim] += L[i];\n    }\n  }\n  top = begin + len;\n  for (int i = 0; i < len; ++i) {\n    st[begin + i] = val + 1;\n    L[begin + i] = cntS[len - i];\n    R[begin + i] = cntP[i + 1];\n  }\n\n  Sub(ans, Ways(begin, top));\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &lim);\n  top = 0;\n  ans = 0;\n  for (int i = 0; i < n; ++i) {\n    int now;\n    scanf(\"%d\", &now);\n    while (top > 0 && st[top - 1] < now) {\n      Merge();\n    }\n    L[top] = R[top] = 1;\n    st[top++] = now;\n  }\n  while (top > 0) {\n    Merge();\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 12/11/2019, 4:20:39 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/optional.hpp> // for C++14\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\nconstexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nstruct Element\n{\n  ll left, right;\n  boost::optional<ll> value; // for C++14\n};\n\nclass Solve\n{\n  ll N;\n  ll L;\n  vector<Element> A;\n\npublic:\n  Solve(ll N, ll L, vector<ll> input) : N{N}, L{L}, A(N)\n  {\n    for (auto i = 0; i < N; i++)\n    {\n      A[i].value = input[i];\n      A[i].left = 1;\n      A[i].right = 1;\n    }\n  }\n\n  ll count()\n  {\n    ll ans{N};\n    while (true)\n    {\n#if DEBUG == 1\n      cerr << \"A = {\";\n      for (auto const &e : A)\n      {\n        if (e.value)\n        {\n          cerr << *e.value << \", \";\n        }\n        else\n        {\n          cerr << \"n, \";\n        }\n      }\n      cerr << \"}\" << endl;\n      cerr << \"L = {\";\n      for (auto const &e : A)\n      {\n        cerr << e.left << \", \";\n      }\n      cerr << \"}\" << endl;\n      cerr << \"R = {\";\n      for (auto const &e : A)\n      {\n        cerr << e.right << \", \";\n      }\n      cerr << \"}\" << endl;\n#endif\n      boost::optional<ll> M{min_value()};\n      if (!M)\n      {\n        break;\n      }\n      vector<Element> T;\n      vector<Element> tmp;\n      for (auto const &e : A)\n      {\n        if (e.value == M)\n        {\n          tmp.push_back(e);\n        }\n        else if (!tmp.empty())\n        {\n          update(ans, T, tmp);\n          T.push_back(e);\n        }\n        else\n        {\n          T.push_back(e);\n        }\n      }\n      if (!tmp.empty())\n      {\n        update(ans, T, tmp);\n      }\n      swap(A, T);\n      // delete_none();\n    }\n    return ans;\n  }\n\nprivate:\n  boost::optional<ll> min_value()\n  {\n    boost::optional<ll> ans;\n    for (auto const &e : A)\n    {\n      if (e.value)\n      {\n        if (ans)\n        {\n          ch_min(*ans, *e.value);\n        }\n        else\n        {\n          ans = e.value;\n        }\n      }\n    }\n    return ans;\n  }\n\n  void update(ll &ans, vector<Element> &T, vector<Element> &tmp)\n  {\n    ans += calc(tmp);\n    tmp = press(tmp);\n    ans -= calc(tmp);\n    copy(tmp.begin(), tmp.end(), back_inserter(T));\n    tmp.clear();\n  }\n\n  ll calc(vector<Element> const &X)\n  {\n    ll ans{0};\n    ll sum_right{0};\n    int S{static_cast<int>(X.size())};\n    for (auto i = L - 1; i < S; i++)\n    {\n      sum_right += X[i].right;\n    }\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans += X[i].left * sum_right;\n      sum_right -= X[i + L - 1].right;\n    }\n    assert(sum_right == 0);\n    return ans;\n  }\n\n  vector<Element> press(vector<Element> &V)\n  {\n    ll S{static_cast<ll>(V.size())};\n    if (S < L)\n    {\n      return {{0, 0, boost::none}};\n    }\n    ll K{*V[0].value + 1};\n    vector<Element> ans(S / L);\n    for (auto &e : ans)\n    {\n      e.value = K;\n    }\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].right += V[i].right;\n    }\n    reverse(V.begin(), V.end());\n    reverse(ans.begin(), ans.end());\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].left += V[i].left;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans;\n  }\n\n  void delete_none()\n  {\n    vector<Element> T;\n    int S{static_cast<int>(A.size())};\n    for (auto i = 0; i < S; i++)\n    {\n      if (i < S - 1 && !A[i].value && !A[i + 1].value)\n      {\n        continue;\n      }\n      T.push_back(move(A[i]));\n    }\n    swap(A, T);\n  }\n};\n\nint main()\n{\n  ll N, L;\n  cin >> N >> L;\n  vector<ll> A(N);\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> A[i];\n  }\n  Solve solve(N, L, move(A));\n  cout << solve.count() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define st first\n#define nd second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<long long>;\nusing ld = long double;\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int kMaxN = 2e5 + 100;\n\nint n, L;\nint vals[kMaxN];\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> n >> L;\n  for (int i = 0; i < n; ++i) {\n    cin >> vals[i];\n  }\n\n  struct Number {\n    int num;\n    int lends, rends;\n  };\n\n  map<int, Number> nums;\n  for (int i = 0; i < n; ++i) {\n    nums[i] = Number{vals[i], 1, 1};\n  }\n\n  vi order(n);\n  iota(ALL(order), 0);\n  sort(ALL(order), [&](int lhs, int rhs) {\n        return MP(vals[lhs], lhs) < MP(vals[rhs], rhs);\n      });\n\n  ll ans = n;\n  vector<bool> visited(n);\n  map<int, vi> MX;\n\n  for (int lcx : order) {\n    if (visited[lcx]) { continue; }\n    debug(lcx);\n    function<void(int,int)> Consider = [&](int loc, int valval) {\n      debug(\"!\", loc, valval);\n      auto iter = nums.find(loc);\n      if (iter == nums.end()) { return; }\n      if (iter->nd.num != valval) { return; }\n      //assert(iter->nd.lends == 1 && iter->nd.rends == 1);\n      \n      vi other_locs;\n      auto piter = iter, niter = iter;\n      while (piter != nums.begin() && prev(piter)->nd.num == valval) { --piter; }\n      while (niter != nums.end() && niter->nd.num == valval) { ++niter; }\n\n      for (auto it = piter; it != niter; ++it) {\n        other_locs.PB(it->st);\n      }\n\n      const int S = SZ(other_locs);\n      debug(other_locs);\n\n      if (S >= L) {\n\n        int rgt = 0;\n        int ways_rgt = 0;\n        int num_good = !visited[other_locs[0]];\n        for (int v : other_locs) { ways_rgt += nums[v].rends; }\n\n        for (int lft = 0; lft + L <= S; ++lft) {\n          while (rgt < S && (rgt-lft < L-1 || !num_good)) {\n            const int v = other_locs[rgt];\n            ways_rgt -= nums[v].rends;\n            ++rgt;\n            if (rgt < S) { num_good += !visited[other_locs[rgt]]; }\n          }\n          if (rgt == S) { break; }\n\n          const int ways_lft = nums[other_locs[lft]].lends ;\n          debug(lft, rgt, ways_rgt);\n\n          ans += (ll)ways_lft * ways_rgt;\n          num_good -= !visited[other_locs[lft]];\n        }\n      }\n\n      for (int v : other_locs) {\n        visited[v] = true;\n      }\n\n      vi lends(S), rends(S);\n      for (int i = 0; i < S; ++i) {\n        lends[i] = nums[other_locs[i]].lends;\n        rends[i] = nums[other_locs[i]].rends;\n      }\n\n      for (int v : other_locs) { nums.erase(v); }\n      const int num_add = S / L;\n      vector<Number> xs(num_add);\n      for (int idx_add = 0; idx_add < num_add; ++idx_add) {\n        xs[idx_add].num = valval + 1;\n\n        const int lft = (idx_add + 1) * L - 1;\n        const int rgt = min(S, (idx_add + 2) * L - 1);\n        for (int i = lft; i < rgt; ++i) {\n          xs[idx_add].rends += rends[i];\n          xs[num_add - idx_add - 1].lends += lends[S - i - 1];\n        }\n      }\n\n\n      for (int idx_add = 0; idx_add < num_add; ++idx_add) {\n        debug(idx_add, xs[idx_add].num, xs[idx_add].lends, xs[idx_add].rends);\n        nums.emplace(other_locs[0] + idx_add, xs[idx_add]);\n      }\n\n      if (num_add == 0) {\n        Number dummy{(int)2e9, 0, 0};\n        nums[other_locs[0]] = dummy;\n      } else {\n        debug(other_locs[0], num_add);\n        MX[xs[0].num].push_back(other_locs[0]);\n      }\n    };\n\n    while (!MX.empty() && MX.begin()->st < vals[lcx]) {\n      auto v = MX.begin()->nd;\n      int t = MX.begin()->st;\n      MX.erase(MX.begin());\n      for (int loc : v) { Consider(loc, t); }\n    }\n    Consider(lcx, vals[lcx]);\n  }\n\n  cout << ans << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxp];\nint main()\n{\n\tfreopen(\"1.in\",\"r\",stdin);\n\tfreopen(\"1.out\",\"w\",stdout); \n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<25;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue; assert(H[i+1]==H[i]+1);\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; \n\t\t\tvector<node> tmp(k+1,0); tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int j=1;j<=k;++j)\n\t\t\t{\n\t\t\t\ttmp[j].l=tmp[j].r=tmp[j-1].l+1;\n\t\t\t\ttmp[j].L=tmp[j].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\tfor(int j=1;j<=k;++j) rec[i+1].push_back(tmp[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,l,a[200010],p[200020];\nlong long ans;\nstruct data\n{\n\tint l,r,wl,wr;\n};\nlong long calc(vector<pair<int,int> >&w)\n{\n//\tfor(int i=0;i<w.size();++i)printf(\"%d %d\\n\",w[i].first,w[i].second);\n\tint sum=0;\n\tlong long res=0;\n\tfor(int i=0;i<w.size();++i)\n\t{\n\t\tif(i>=l-1)sum+=w[i-l+1].first;\n\t\tres+=sum*w[i].second;\n\t}\n//\tprintf(\"%lld\\n\",res);\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&l);ans=n;\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&a[i]),p[i]=i;\n\tsort(p+1,p+1+n,[](int &x,int &y){return a[x]<a[y];});\n\tint last=1,val=0;\n\tvector<data>A,B;\n\twhile(last<=n||A.size())\n\t{\n\t\tif(A.empty())val=a[p[last]];\n\t\telse ++val;\n\t\twhile(a[p[last]]==val)A.push_back(data{p[last],p[last],1,1}),++last;\n\t\tB.clear();\n\t\tsort(A.begin(),A.end(),[](data &x,data &y){return x.l<y.l;});\n\t\tfor(int i=0;i<A.size();++i)\n\t\t{\n\t\t\tvector<pair<int,int> >cur,nxt;\n\t\t\tint r=i;cur.push_back(make_pair(A[i].wl,A[i].wr));\n\t\t\twhile(r+1<A.size()&&A[r+1].l==A[r].r+1)++r,cur.push_back(make_pair(A[r].wl,A[r].wr));\n\t\t\tans+=calc(cur);\n\t\t\tint len=r-i+1,cnt=(r-i+1)/l;\n\t\t\tnxt.resize(cnt);\n\t\t\tfor(int j=0;j<cnt;++j)nxt[j].first=nxt[j].second=0;\n\t\t\tfor(int j=0;j<len;++j)\n\t\t\t{\n\t\t\t\tif(j+1>=l)nxt[(j+1)/l-1].second+=A[i+j].wr;\n\t\t\t\tif(len-j>=l)nxt[cnt-(len-j)/l].first+=A[i+j].wl;\n\t\t\t}\n\t\t\tans-=calc(nxt);\n\t\t\tfor(int j=0;j<cnt;++j)B.push_back(data{A[i+j*l].l,A[j==cnt-1?r:i+j*l+l-1].r,nxt[j].first,nxt[j].second});\n\t\t\ti=r;\n\t\t}\n\t\tA=B;\n\t//\tfor(int i=0;i<A.size();++i)printf(\"%d %d %d %d\\n\",A[i].l,A[i].r,A[i].wl,A[i].wr);\n\t//\tprintf(\"\\n\");\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define db double \n#define maxn 200005 \n#define mod 998244353\n#define vi vector<double>\n#define pb push_back\n#define ll long long\n#define iter set<th>::iterator\nusing namespace std;\nll ksm(ll a, ll b) {\n\tif (!b) return 1;\n\tll ns = ksm(a, b >> 1);\n\tns = ns * ns % mod;\n\tif (b & 1) ns = ns * a % mod;\n\treturn ns;\n}\ninline int add(int a, int b) {\n\ta += b;\n\treturn (a < mod) ? a : (a - mod);\n}\ninline int sub(int a, int b) {\n\ta -= b;\n\treturn (a < 0) ? a + mod : a;\n}\ninline int mul(int a, int b) {\n\treturn (ll)a * b % mod;\n}\n// head\nstruct th{\n\tint tp, pl, num, l, r;\n\tth(){\n\t}\n\tth(int u, int a, int b) {\n\t\ttp = u, pl = a, num = b;\n\t\tl = r = 1;\n\t}\n\tbool operator < (const th &b)const {\n\t\tif (tp == 0) return pl < b.pl;\n\t\telse  {\n\t\t\tif (num != b.num) return num < b.num;\n\t\t\treturn pl < b.pl;\n\t\t}\n\t}\n}; \nint n, l;\nll ans = 0;\nset<th> ps, qs;\nll cal(vector<th> u) {\n\tint n = u.size();\n\tvi sm(n);\n\tsm[0] = u[0].r;\n\tfor (int i = 1; i < n; i++)\n\t\tsm[i] = sm[i - 1] + u[i].r;\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint nx = i + l - 1;\n\t\tint ns = sm[n - 1];\n\t\tnx--;\n\t\tif (nx >= 0) ns -= sm[min(nx, n - 1)];\n\t\tans += 1ll * u[i].l * ns;\n\t}\n\treturn  ans;\n}\nvoid otp(set<th> r) {\n\tcout << \"QQQ\" << endl;\n\titer q = r.begin();\n\twhile (q != r.end()) {\n\t\tcout << (*q).pl << \" \" << (*q).num << endl;\n\t\tq++;\n\t}\n}\nint sum[maxn];\nint main() {\n\tcin >> n >> l;\n\tint inf = 2e9;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tps.insert(th(0, i, a)), \n\t\tqs.insert(th(1, i, a));\n\t}\n\tans = n;\n\twhile(1) {\n\t\tth u1 = *qs.begin();\n\t\tif (u1.num >= inf) break;\n\t\titer it = ps.find(th(0, u1.pl, u1.num)), ft = it;\n\t\tvector<th> ns;\n\t\twhile (it != ps.end() && (*it).num == u1.num)\n\t\t\tns.pb(*it), it++;\n\t\tint cnt = ns.size();\n\t\tfor (int i = 0; i < cnt; i++)\n\t\t\tps.erase(ns[i]), \n\t\t\tqs.erase(th(1, ns[i].pl, ns[i].num));\n\t\tif (cnt < l) {\n\t\t//\tans += cnt;\n\t\t\tps.insert(th(0, u1.pl, inf)), \n\t\t\tqs.insert(th(1, u1.pl, inf));\n\t\t}\n\t\telse {\n\t\t\tvector<th> gr(cnt / l);\n\t\t\tans += cal(ns);\n\t\t\tint pl = 0;\n\t\t\tfor (int i = 0; i < cnt / l; i++) {\n\t\t\t\tgr[i] = th(1, ns[pl].pl, ns[pl].num + 1);\n\t\t\t\tgr[i].l = gr[i].r = 0;\n\t\t\t\tfor (int j = pl + l - 1; j < min(pl + 2 * l - 1, cnt); j++)\t\n\t\t\t\t\tgr[i].r += ns[j].r;\n\t\t\t\tpl += l;\n\t\t\t}\n\t\t\tpl = cnt - 1;\n\t\t\tfor (int i = cnt / l - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = pl - l + 1; j >= max(0, pl - 2 * l + 2); j--)\n\t\t\t\t\tgr[i].l += ns[j].l; \n\t\t\t\tpl -= l;\n\t\t\t}\n\t\t\tans -= cal(gr);\n\t\t\tfor (int i = 0; i < cnt / l; i++) {\n\t\t\t\tqs.insert(gr[i]);\n\t\t\t\tgr[i].tp = 0, ps.insert(gr[i]);\n\t\t\t}\n\t\t}\n\t\n\t//\totp(ps);\n\t\t//otp(qs);\n\t//\tcout << ans << endl;\n\t////\tsystem(\"pause\");\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 12/11/2019, 4:20:39 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/optional.hpp> // for C++14\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\n// constexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nstruct Element\n{\n  int ind;\n  ll left, right;\n  boost::optional<int> value; // for C++14\n  bool operator<(Element const &rhs) const\n  {\n    return ind < rhs.ind;\n  }\n  bool operator==(Element const &rhs) const\n  {\n    return ind == rhs.ind;\n  }\n};\n\nElement make_element(int ind) // helper function avoiding contaminating the default constructor.\n{\n  return Element{ind, 0, 0, boost::none};\n}\n\nclass Solve\n{\n  int N, L;\n  set<Element> A;\n  map<int, vector<int>> indexes; // value -> inds\n\npublic:\n  Solve(int N, int L, vector<int> input) : N{N}, L{L}\n  {\n    for (auto i = 0; i < N; i++)\n    {\n      A.insert({i, 1, 1, input[i]});\n      indexes[input[i]];\n      indexes[input[i]].push_back(i);\n    }\n  }\n\n  ll count();\n\nprivate:\n  void update(ll &ans, vector<Element> &tmp)\n  {\n    ans += calc(tmp);\n    tmp = press(tmp);\n    ans -= calc(tmp);\n    for (auto e : tmp)\n    {\n      A.insert(e);\n    }\n    tmp.clear();\n  }\n\n  ll calc(vector<Element> const &X)\n  {\n    ll ans{0};\n    ll sum_right{0};\n    int S{static_cast<int>(X.size())};\n    for (auto i = L - 1; i < S; i++)\n    {\n      sum_right += X[i].right;\n    }\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans += X[i].left * sum_right;\n      sum_right -= X[i + L - 1].right;\n    }\n    assert(sum_right == 0);\n    return ans;\n  }\n\n  vector<Element> press(vector<Element> const &V)\n  {\n    assert(!V.empty());\n    int S{static_cast<int>(V.size())};\n    if (S < L)\n    {\n      return {{V[0].ind, 0, 0, boost::none}};\n    }\n    int index{V[0].ind};\n    int K{*V[0].value + 1};\n    vector<Element> ans(S / L);\n    for (auto &e : ans)\n    {\n      e.ind = index;\n      e.value = K;\n      indexes[K];\n      indexes[K].push_back(index);\n      ++index;\n    }\n    for (auto i = L - 1; i < S; i++)\n    {\n      ans[(i - L + 1) / L].right += V[i].right;\n    }\n    int mod{S % L};\n    for (auto i = 0; i < S - L + 1; i++)\n    {\n      ans[(i + L - mod - 1) / L].left += V[i].left;\n    }\n    return ans;\n  }\n};\n\nll Solve::count()\n{\n  ll ans{N};\n  while (!indexes.empty())\n  {\n    vector<Element> tmp;\n    auto &vec{indexes.begin()->second};\n    sort(vec.begin(), vec.end());\n    int min_value{indexes.begin()->first};\n    for (auto ind : indexes[min_value]) // in order not to touch all elements of A.\n    {\n      auto it{A.find(make_element(ind))};\n      assert(it != A.end()); // it must be found.\n      tmp.push_back(*it);\n      it = A.erase(it); // We must erase elements before inserting pressed elements. Fortunately `erase` returns the next iterator.\n      if (it == A.end() || it->value != min_value)\n      {\n        update(ans, tmp);\n      }\n    }\n    if (!tmp.empty())\n    {\n      update(ans, tmp);\n    }\n    indexes.erase(indexes.begin());\n  }\n  return ans;\n}\n\nint main()\n{\n  int N, L;\n  cin >> N >> L;\n  vector<int> A(N);\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> A[i];\n  }\n  Solve solve(N, L, A);\n  cout << solve.count() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bo[400010];\nint n,L,sum[400010],a[400010],tot,q[400010],l,r,fl[400010],fr[400010],pre[400010],suf[400010],t[400010],tn,Q[400010],Qn,x,nxt[400010];\npair<int,int> val[200010];\nlong long ans;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&L),a[0]=a[n+1]=-1;\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]),val[i]=make_pair(a[i],i),fl[i]=fr[i]=1;\n\tsort(val+1,val+1+n),l=200000,r=l-1,suf[0]=1,pre[n+1]=n,tot=n+1,ans=n;\n\tfor (int i=1; i<=n; i++) q[++r]=val[i].second,pre[i]=i-1,suf[i]=i+1;\n\twhile (l<=r)\n\t{\n\t\tint R=l;\n\t\twhile (R<r&&a[q[R+1]]==a[q[l]]) R++;\n\t\tfor (int i=l; i<=R; i++) if (!bo[q[i]])\n\t\t{\n\t\t\tx=q[i];\n\t\t\twhile (a[pre[x]]==a[x]) x=pre[x];\n\t\t\tt[tn=1]=x,bo[x]=1;\n\t\t\twhile (a[suf[x]]==a[x]) x=suf[x],t[++tn]=x,bo[x]=1;\n\t\t\tnxt[tn+1]=tn+1;\n\t\t\tfor (int j=tn; j; j--) if (t[j]<=n) nxt[j]=j; else nxt[j]=nxt[j+1];\n\t\t\tsum[tn+1]=0;\n\t\t\tfor (int j=tn; j; j--) sum[j]=sum[j+1]+fr[t[j]];\n\t\t\tfor (int j=1; j<=tn; j++) ans+=1ll*fl[t[j]]*sum[min(max(j+L-1,nxt[j]),tn+1)];\n\t\t\tif (tn>=L) for (int j=1; j<=tn; j++) pre[suf[t[j]]]=pre[t[j]],suf[pre[t[j]]]=suf[t[j]];\n\t\t\tint pr=pre[t[1]],sf=suf[t[tn]],cnt=tn/L;\n\t\t\tfor (int j=1; j<=cnt; j++) suf[pr]=(++tot),a[tot]=a[t[1]]+1,pre[sf]=tot,pre[tot]=pr,suf[tot]=sf,pr=tot,Q[++Qn]=tot;\n\t\t\tfor (int j=1; j<=cnt; j++)\n\t\t\t{\n\t\t\t\tfr[tot-cnt+j]=0;\n\t\t\t\tfor (int k=j*L; k<(j+1)*L&&k<=tn; k++) fr[tot-cnt+j]+=fr[t[k]];\n\t\t\t}\n\t\t\tfor (int j=cnt; j; j--)\n\t\t\t{\n\t\t\t\tfl[tot-cnt+j]=0;\n\t\t\t\tfor (int k=tn-(cnt-j+1)*L+1; k>tn-(cnt-j+2)*L+1&&k; k--) fl[tot-cnt+j]+=fl[t[k]];\n\t\t\t}\n\t\t}\n\t\tl=R+1;\n\t\tfor (int i=1; i<=Qn; i++) q[--l]=Q[i];\n\t\tQn=0;\n\t}\n\treturn printf(\"%lld\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst int N=2e5+1;\nint n,z;\npair<int,int>a[N];\nint l[N],r[N];\nint sl[N],sr[N],sx[N];\nint sz=0;\ndeque<int>v[2*N];\nvector<ll>pw;\nll ans=0;\nvoid shrink(int vt,int sf){\n\tint ls=v[vt].size()/sf;\n\tfor(int i=0; i<ls ;i++) v[vt][i]=v[vt][(i+1)*sf-1];\n\tv[vt].resize(ls);\n}\nvoid merge(int ml,int mr){\n\tif(r[ml]!=ml || l[mr]!=mr) while(true);\n\tif(sx[mr]<=sx[ml]){\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=r[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sl[ml],pr=sr[ml];\n\t\tint ql=sl[mr],qr=sr[mr];\n\t\tint dl=l[ml],dr=r[mr];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint nxt=dr+1;\n\t\t\tif(i!=v[ql].size()-1) nxt=v[ql][i+1];\n\t\t\tans+=1LL*(nxt-v[ql][i])*(v[pr][x-1]-dl+1);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++) v[pl].push_back(v[ql][i]);\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--) v[pr].push_front(v[qr][i]);\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dr]=sx[dl];\n\t\tsl[dr]=sl[dl];\n\t\tsr[dr]=sr[dl];\n\t}\n\telse{\n\t\tswap(ml,mr);\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=l[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sr[ml],pr=sl[ml];\n\t\tint ql=sr[mr],qr=sl[mr];\n\t\tint dl=l[mr],dr=r[ml];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint nxt=dl-1;\n\t\t\tif(i!=v[ql].size()-1) nxt=v[ql][i+1];\n\t\t\tans+=1LL*(v[ql][i]-nxt)*(dr-v[pr][x-1]+1);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++) v[pl].push_back(v[ql][i]);\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--) v[pr].push_front(v[qr][i]);\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dl]=sx[dr];\n\t\tsl[dl]=sl[dr];\n\t\tsr[dl]=sr[dr];\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> z;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> a[i].fi;\n\t\ta[i].se=i;\n\t}\n\tpw.push_back(1);\n\twhile(pw.back()*z<=n){\n\t\tpw.push_back(pw.back()*z);\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1; i<=n ;i++){\n\t\tint cl=i,cr=i;\n\t\twhile(cr<n && a[cr+1].fi==a[cl].fi) cr++;\n\t\ti=cr;\n\t\tfor(int j=cl; j<=cr ;j++){\n\t\t\tint x=a[j].se;\n\t\t\tl[x]=r[x]=x;\n\t\t\tsx[x]=a[j].fi;\n\t\t\tsl[x]=++sz;v[sz].push_back(x);\n\t\t\tsr[x]=++sz;v[sz].push_back(x);\n\t\t\tif(r[x-1]!=0) merge(x-1,x);\n\t\t\tif(l[x+1]!=0) merge(x,x+1);\n\t\t}\n\t}\n\tcout << ans+n << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define N 200127\n#define INF 0x3f3f3f3f\nint n,m,a[N],mi=INF,L[N],R[N],vl[N],vr[N],v1[N],v2[N];\nstruct Point{\n\tint x,v;\n\tinline bool operator<(const Point &b)const{return (v>b.v)||((v==b.v)&&(x>b.x));}\n};\npriority_queue<Point>q;\nint b[N],cn=0;long long ans=0;\nint main(){\n\tscanf(\"%d%d\",&n,&m);ans=n;int i,j,k,v,l,r,p,sum;for(i=1;i<=n;i++)scanf(\"%d\",&a[i]),L[i]=i-1,R[i]=i+1,vl[i]=vr[i]=1,q.push((Point){i,a[i]});\n\twhile(!q.empty())\n\t{\n\t\tcn=0;v=q.top().v;while((!q.empty())&&(v==q.top().v))b[++cn]=q.top().x,q.pop();\n\t\tfor(i=1;i<=cn;i=r+1)\n\t\t{\n\t\t\tl=r=i;while((r<cn)&&(R[b[r]]==b[r+1]))++r;\n\t\t\tsum=0;for(i=l;i<=r;i++){if(i-m+1>=l)sum+=vl[b[i-m+1]];ans+=1ll*sum*vr[b[i]];}\n\t\t\tif(r-l+1<m){R[L[b[l]]]=R[b[r]];L[R[b[r]]]=L[b[l]];continue;}p=(r-l+1)/m;\n\t\t\tfor(i=l;i<=r;i++)k=b[i],v1[k]=vl[k],v2[k]=vr[k],vl[k]=vr[k]=0;\n\t\t\tfor(i=r-m+1,k=p;i>=l;i-=m,--k)for(j=i;(j>=l)&&(j>=i-m+1);j--)vl[b[l+k-1]]+=v1[b[j]];\n\t\t\tfor(i=l+m-1,k=1;i<=r;i+=m,++k)for(j=i;(j<=r)&&(j<=i+m-1);j++)vr[b[l+k-1]]+=v2[b[j]];\n\t\t\tfor(i=l;i<=l+p-1;i++)++a[b[i]],q.push((Point){b[i],a[b[i]]});L[R[b[r]]]=b[l]+p-1;R[b[l]+p-1]=R[b[r]];\n\t\t\tsum=0;for(i=l;i<=l+p-1;i++){if(i-m+1>=l)sum+=vl[b[i]-m+1];ans-=1ll*sum*vr[b[i]];}\n\t\t}\n\t}printf(\"%lld\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace io{\n\tconst int l=1<<20;\n\tchar buf[l],*s,*t,c;\n\tinline void gc(){\n\t\tif(s==t){\n\t\t\tt=(s=buf)+fread(buf,1,l,stdin);\n\t\t\tc=s==t?EOF:*s++;\n\t\t}else c=*s++;\n\t}\n\ttemplate<class IT>inline void gi(IT &x){\n\t\tx=0;gc();while(c<'0'||c>'9')gc();\n\t\twhile('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^48);gc();}\n\t}\n\tchar buf0[20];int a;\n\ttemplate<class IT>inline void pi(IT x){\n\t\tif(x<0){putchar('-');x=-x;}\n\t\tdo buf0[++a]=x%10+48;while(x/=10);\n\t\twhile(a)putchar(buf0[a--]);\n\t\tputchar('\\n');\n\t}\n};\nusing io::gi;\nusing io::pi;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=200005;\nstruct node{\n\tint a,L,R,l,r;\n\tinline bool operator<(const node &x)const{\n\t\treturn a<x.a||(a==x.a&&L<x.L);\n\t}\n}z[N],x[N],y[N];ll ans,ant;\ninline void calcs(int i,int j,int r){\n\tll t=0ll;\n\tfor(;j<=r;++i,++j)ans+=(t+=x[i].l)*x[j].r;\n}\ninline void calct(int i,int j,int r){\n\tll t=0ll;\n\tfor(;j<=r;++i,++j)ant+=(t+=z[i].l)*z[j].r;\n}\ninline void dbg(int X){\n\tint i;\n\trep(i,1,X)printf(\"a=%d L=%d R=%d l=%d r=%d\\n\",x[i].a,x[i].L,x[i].R,x[i].l,x[i].r);puts(\"X\");\n}\nint main(){\n//\tfreopen(\"f.in\",\"r\",stdin);\n\tint n,m,mn,X=0,Y=1,Z,T,i,j,k,l,c;\n\tscanf(\"%d%d\",&n,&m);ans=n;\n\trep(i,1,n){\n\t\tscanf(\"%d\",&y[i].a);\n\t\ty[i].L=y[i].R=i;\n\t\ty[i].l=y[i].r=1;\n\t}\n\tsort(y+1,y+n+1);\n\twhile(Y<=n){\n\t\tmn=y[Y].a;\n\t\tif(X)cmin(mn,x[X].a);\n\t\twhile(y[Y].a==mn)x[++X]=y[Y++];\n\t\tsort(x+1,x+X+1);\n//\t\tdbg(X);\n\t\tx[X+1].L=0;\n\t\tZ=0;\n\t\tfor(i=j=1;i<=X;i=++j){\n\t\t\tfor(;x[j+1].L==x[j].R+1;++j);\n\t\t\tc=(l=j+1-i)/m;\n//\t\t\tprintf(\"i=%d j=%d\\n\",i,j);\n\t\t\tif(c){\n\t\t\t\tT=Z;\n\t\t\t\tREP(k,0,c){\n\t\t\t\t\t++T;\n\t\t\t\t\tz[T].a=mn+1;\n\t\t\t\t\tz[T].L=x[i+k*m    ].L;\n\t\t\t\t\tz[T].R=x[i+k*m+m-1].R;\n\t\t\t\t\tz[T].l=z[T].r=0;\n\t\t\t\t}\n\t\t\t\tz[T++].R=x[j].R;\n\t\t\t\tcalcs(i,i+m-1,  j);\n\t\t\t\trep(k,i+m-1,j)z[Z+(k-i+1)/m].r+=x[k].r;\n\t\t\t\tper(k,j-m+1,i)z[T-(j-k+1)/m].l+=x[k].l;\n\t\t\t\tcalct(Z,Z+m-1,--T);\n\t\t\t\tZ=T;\n\t\t\t}\n\t\t}\n\t\tX=Z;\n\t\trep(i,1,X)x[i]=z[i];\n//\t\tdbg(X);\n\t}\n\tprintf(\"%lld\",ans-ant);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int N = 2e5 + 7;\nint n, l, s[N], t, f[N], g[N], sf[N], sg[N];\nll ans;\n\ninline void pop() {\n\tint k = 1, x = s[t];\n\twhile (s[t-1] == x) --t, ++k;\n\t--t;\n\tif (k < l) {\n\t\twhile (t) pop();\n\t\treturn;\n\t}\n\tint w = k / l;\n\tfor (int i = 1; i <= k; i++)\n\t\tsf[i] = sf[i-1] + f[i+t], sg[i] = sg[i-1] + g[i+t];\n\tfor (int i = l; i <= k; i++)\n\t\tans += 1ll * sf[i-l+1] * g[i+t];\n\tfor (int i = 1; i <= w; i++)\n\t\tf[t+i] = sf[k-l*(w-i+1)+1] - sf[max(k-l*(w-i+2)+1,0)],\n\t\tg[t+i] = sg[min(l*(i+1)-1,k)] - sg[l*i-1];\n\tfor (int i = l, s = 0; i <= w; i++)\n\t\tans -= 1ll * (s += f[t+i-l+1]) * g[t+i];\n\tfor (int i = 1; i <= w; i++)\n\t\ts[++t] = x + 1;\n}\n\nint main() {\n\trd(n, l), ans = n;\n\tfor (int i = 1, x; i <= n; i++) {\n\t\trd(x);\n\t\twhile (t && s[t] < x) pop();\n\t\ts[++t] = x, f[t] = g[t] = 1;\n\t}\n\twhile (t) pop();\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nstruct Vertex{int l; int r; int pr; int sz; int value; ll suf; ll pref; int minimum;};\nvector<Vertex> decart;\npair<int, int> SP = make_pair(-1, -1);\nint create_vertex(int value, ll pref, ll suf){\n\tdecart.push_back({-1, -1, rand()%1000000000, 1, value, suf, pref, value});\n\treturn decart.size() - 1;\n}\nvoid update(int vertex){\n    if (vertex == -1) return;\n    int sz = 1, minimum = decart[vertex].value;\n    if (decart[vertex].l != -1){\n        sz += decart[decart[vertex].l].sz;\n        minimum = min(minimum, decart[decart[vertex].l].minimum);\n    }\n    if (decart[vertex].r != -1){\n        sz += decart[decart[vertex].r].sz;\n        minimum = min(minimum, decart[decart[vertex].r].minimum);\n    }\n    decart[vertex].sz = sz;\n    decart[vertex].minimum = minimum;\n}\npair<int, int> split(int father, int number){\n    if (father == -1) return SP;\n    int l = 1;\n    if (decart[father].l != -1){\n        l += decart[decart[father].l].sz;\n    }\n    if (l <= number){\n        pair<int, int> p = split(decart[father].r, number - l);\n        decart[father].r = p.first;\n        p.first = father;\n        update(father);\n        return p;\n    }\n    pair<int, int> p = split(decart[father].l, number);\n    decart[father].l = p.second;\n    p.second = father;\n    update(father);\n    return p;\n}\nint merg(int first, int second){\n    if (first == -1) return second;\n    if (second == -1) return first;\n    if (decart[first].pr >= decart[second].pr){\n        int v = merg(decart[first].r, second);\n        decart[first].r = v;\n        update(first);\n        return first;\n    }\n    int v = merg(first, decart[second].l);\n    decart[second].l = v;\n    update(second);\n    return second;\n}\n\nint n, l;\n\nll ans = 0;\n\nconst int INF = 2e9;\n\nint get_minimum(int base){\n\tint L = decart[base].l, R = decart[base].r;\n\tint a, b, c;\n\tif (L==-1) a = INF;\n\telse a = decart[L].minimum;\n\tb = decart[base].value;\n\tif (R==-1)c=INF;\n\telse c = decart[R].minimum;\n\tint sz = 0;\n\tif (L!=-1) sz = decart[L].sz;\n\tif (a <= b && a <= c) return get_minimum(L);\n\tif (b <= c) return sz;\n\treturn get_minimum(R)+sz+1;\n}\n\nint get_left(int base){\n\tif (base==-1) return -1;\n\tif (decart[base].l == -1) return decart[base].value;\n\treturn get_left(decart[base].l);\n}\n\nvector<pair<ll, ll> > values;\nvector<pair<ll, ll> > new_values;\n\nvoid dfs(int base){\n\tif (base==-1) return;\n\tdfs(decart[base].l);\n\tvalues.push_back({decart[base].pref, decart[base].suf});\n\tdfs(decart[base].r);\n}\n\nvoid add(vector<pair<ll, ll> > values, ll kf){\n\tll sum = 0;\n\tfor (int i=values.size() - 1; i >= 0; i--){\n\t\tint index = i+l-1;\n\t\tif (index < values.size()) sum += values[index].first;\n\t\tans += kf*sum*values[i].second;\n\t}\n}\n\nvoid solve(int base){\n\tif (base == -1) return;\n\tint less = get_minimum(base);\n\tpair<int, int> T = split(base, less);\n\tint left = T.first, middle = -1, right = T.second;\n\tint mx = decart[right].minimum;\n\twhile (true){\n\t\tint val = get_left(right);\n\t\tif (val == mx){\n\t\t\tpair<int, int> Q = split(right, 1);\n\t\t\tright = Q.second;\n\t\t\tmiddle = merg(middle, Q.first);\n\t\t}\n\t\telse break;\n\t}\n\tif (decart[middle].sz < l){\n\t\tsolve(left);\n\t\tsolve(right);\n\t\treturn;\n\t}\n\tvalues.clear();\n\tdfs(middle);\n\tadd(values, 1);\n\t//cout << ans << endl;\n\tint S = values.size();\n\tnew_values.assign(S/l, {0, 0});\n\tint F = new_values.size();\n\tfor (int i=values.size()-1; i >= 0; i--){\n\t\tint index = (values.size() - i)/l;\n\t\tif (index != 0) new_values[F-(index-1) - 1].second += values[i].second;\n\t\tindex = (i+1)/l;\n\t\tif (index != 0) new_values[index-1].first += values[i].first;\n\t} \n\tadd(new_values, -1);\n\tint B = -1;\n\tfor (int i=0;i<new_values.size(); ++i){\n\t\tint I = create_vertex(mx+1, new_values[i].first, new_values[i].second);\n\t\tB = merg(B, I);\n\t}\n\tB = merg(left, B);\n\tB = merg(B, right);\n\tsolve(B);\n}\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"H_input.txt\", \"r\", stdin);\n\t//freopen(\"A_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> l;\n\tvector<int> v(n);\n\tfor (int i=0;i<n;++i) cin >> v[i];\n\tint base = -1;\n\tfor (int i=0;i<n;++i){\n\t\tint I = create_vertex(v[i], 1, 1);\n\t\tbase = merg(base, I);\n\t}\n\tsolve(base);\n\tcout << ans+n;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxp];\nint main()\n{\n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<25;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue;\n\t\t\tll sum=0;\n\t\t\tfor(int j=r;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int j=1;j<=k;++j)\n\t\t\t{\n\t\t\t\ttmp[j].l=tmp[j].r=tmp[j-1].l+1;\n\t\t\t\ttmp[j].L=tmp[j].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tsum=0;\n\t\t\tfor(int j=k;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\twhile(k) rec[i+1].push_back(tmp[k--]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace io{\n\tconst int l=1<<20;\n\tchar buf[l],*s,*t,c;\n\tinline void gc(){\n\t\tif(s==t){\n\t\t\tt=(s=buf)+fread(buf,1,l,stdin);\n\t\t\tc=s==t?EOF:*s++;\n\t\t}else c=*s++;\n\t}\n\ttemplate<class IT>inline void gi(IT &x){\n\t\tx=0;gc();while(c<'0'||c>'9')gc();\n\t\twhile('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^48);gc();}\n\t}\n\tchar buf0[20];int a;\n\ttemplate<class IT>inline void pi(IT x){\n\t\tif(x<0){putchar('-');x=-x;}\n\t\tdo buf0[++a]=x%10+48;while(x/=10);\n\t\twhile(a)putchar(buf0[a--]);\n\t\tputchar('\\n');\n\t}\n};\nusing io::gi;\nusing io::pi;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=200005;\nstruct node{\n\tint a,L,R,l,r;\n\tinline bool operator<(const node &x)const{\n\t\treturn a<x.a||(a==x.a&&L<x.L);\n\t}\n}z[N],x[N],y[N];ll ans,ant;\ninline void calcs(int i,int j,int r){\n\tll t=0ll;\n\tfor(;j<=r;++i,++j)ans+=(t+=x[i].l)*x[j].r;\n//\tprintf(\"i=%d j=%d r=%d ans=%lld\\n\",i,j,r,ans);\n}\ninline void calct(int i,int j,int r){\n\tll t=0ll;\n\tfor(;j<=r;++i,++j)ant+=(t+=z[i].l)*z[j].r;\n//\tprintf(\"i=%d j=%d r=%d ant=%lld\\n\",i,j,r,ant);\n}\ninline void dbg(int X){\n\tint i;\n\trep(i,1,X)printf(\"a=%d L=%d R=%d l=%d r=%d\\n\",x[i].a,x[i].L,x[i].R,x[i].l,x[i].r);puts(\"X\");\n}\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tint n,m,mn,X=0,Y=1,Z,T,i,j,k,l,c;\n\tscanf(\"%d%d\",&n,&m);ans=n;\n\trep(i,1,n){\n\t\tscanf(\"%d\",&y[i].a);\n\t\ty[i].L=y[i].R=i;\n\t\ty[i].l=y[i].r=1;\n\t}\n\tsort(y+1,y+n+1);\n\twhile(X||Y<=n){\n\t\tif(Y<=n){\n\t\t\tmn=y[Y].a;\n\t\t\tif(X)cmin(mn,x[X].a);\n\t\t\twhile(y[Y].a==mn)x[++X]=y[Y++];\n\t\t}else mn=x[X].a;\n\t\tsort(x+1,x+X+1);\n//\t\tdbg(X);\n\t\tx[X+1].L=0;\n\t\tZ=0;\n//\t\tprintf(\"===X=%d\\n\",X);\n\t\tfor(i=j=1;i<=X;i=++j){\n\t\t\tfor(;x[j+1].L==x[j].R+1;++j);\n\t\t\tc=(l=j+1-i)/m;\n//\t\t\tprintf(\"i=%d j=%d\\n\",i,j);\n\t\t\tif(c){\n\t\t\t\tT=Z;\n\t\t\t\tREP(k,0,c){\n\t\t\t\t\t++T;\n\t\t\t\t\tz[T].a=mn+1;\n\t\t\t\t\tz[T].L=x[i+k*m    ].L;\n\t\t\t\t\tz[T].R=x[i+k*m+m-1].R;\n\t\t\t\t\tz[T].l=z[T].r=0;\n\t\t\t\t}\n\t\t\t\tz[T++].R=x[j].R;\n\t\t\t\tcalcs(i  ,i+m-1,  j);\n\t\t\t\trep(k,i+m-1,j)z[Z+(k-i+1)/m].r+=x[k].r;\n\t\t\t\tper(k,j-m+1,i)z[T-(j-k+1)/m].l+=x[k].l;\n\t\t\t\tcalct(Z+1,Z+m  ,--T);\n\t\t\t\tZ=T;\n\t\t\t}\n\t\t}\n\t\tX=Z;\n\t\trep(i,1,X)x[i]=z[i];\n//\t\tdbg(X);\n\t}\n\tprintf(\"%lld\",ans-ant);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define N 400600\nmap<int,int> tp1;\nset<int> tp3;\nstruct sth{int l,r,lb,rb;friend bool operator <(sth a,sth b){return a.l<b.l;}};\nvector<sth> v[N];\nint su[N][2],vl[N][2],tp[N][2],ct,n,k,s[N],cnt;\nlong long as;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&s[i]);\n\t\ttp3.insert(s[i]);if(!tp1[s[i]])tp1[s[i]]=++cnt;\n\t\tv[tp1[s[i]]].push_back((sth){i,i,1,1});\n\t}\n\tint lb=*tp3.lower_bound(1);\n\twhile(1)\n\t{\n\t\tint st=tp1[lb];\n\t\tsort(v[st].begin(),v[st].end());\n\t\tint sz=v[st].size(),las=v[st][0].l;\n\t\tfor(int i=0;i<sz;i++)\n\t\t{\n\t\t\tif(ct&&v[st][i].l!=v[st][i-1].r+1)\n\t\t\t{\n\t\t\t\tsu[ct+1][0]=su[ct+1][1]=0;\n\t\t\t\tint s1=ct/k;\n\t\t\t\tif(s1)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=1;j<=ct;j++){int r1=j+k-1;if(r1<=ct)as+=1ll*vl[j][1]*(su[ct][0]-su[r1-1][0]);}\n\t\t\t\t\tfor(int j=1;j<s1;j++)tp[j][0]=su[(j+1)*k-1][0]-su[j*k-1][0];\n\t\t\t\t\ttp[s1][0]=su[ct][0]-su[s1*k-1][0];\n\t\t\t\t\tfor(int j=1;j<s1;j++)tp[s1-j+1][1]=-su[ct-(j+1)*k+1][1]+su[ct-j*k+1][1];\n\t\t\t\t\ttp[1][1]=su[ct-s1*k+1][1];\n\t\t\t\t\tif(!tp1[lb+1])tp1[lb+1]=++cnt,tp3.insert(lb+1);\n\t\t\t\t\tfor(int j=1;j<=s1;j++)v[tp1[lb+1]].push_back((sth){las+j-1,j==s1?v[st][i-1].r:las+j-1,tp[j][0],tp[j][1]});\n\t\t\t\t\tfor(int j=1;j<=s1;j++)vl[j][0]=tp[j][0],vl[j][1]=tp[j][1],su[j][0]=su[j-1][0]+vl[j][0];\n\t\t\t\t\tfor(int j=1;j<=s1;j++){int r1=j+k-1;if(r1<=s1)as-=1ll*vl[j][1]*(su[s1][0]-su[r1-1][0]);}\n\t\t\t\t}\n\t\t\t\tct=0;las=v[st][i].l;\n\t\t\t}\n\t\t\tvl[++ct][0]=v[st][i].lb;vl[ct][1]=v[st][i].rb;\n\t\t\tsu[ct][0]=su[ct-1][0]+vl[ct][0];su[ct][1]=su[ct-1][1]+vl[ct][1];\n\t\t}\n\t\tsu[ct+1][0]=su[ct+1][1]=0;\n\t\tint s1=ct/k;\n\t\tif(s1)\n\t\t{\n\t\t\tfor(int j=1;j<=ct;j++){int r1=j+k-1;if(r1<=ct)as+=1ll*vl[j][1]*(su[ct][0]-su[r1-1][0]);}\n\t\t\tfor(int j=1;j<s1;j++)tp[j][0]=su[(j+1)*k-1][0]-su[j*k-1][0];\n\t\t\ttp[s1][0]=su[ct][0]-su[s1*k-1][0];\n\t\t\tfor(int j=1;j<s1;j++)tp[s1-j+1][1]=-su[ct-(j+1)*k+1][1]+su[ct-j*k+1][1];\n\t\t\ttp[1][1]=su[ct-s1*k+1][1];\n\t\t\tif(!tp1[lb+1])tp1[lb+1]=++cnt,tp3.insert(lb+1);\n\t\t\tfor(int j=1;j<=s1;j++)v[tp1[lb+1]].push_back((sth){las+j-1,j==s1?v[st][sz-1].r:las+j-1,tp[j][0],tp[j][1]});\n\t\t\tfor(int j=1;j<=s1;j++)vl[j][0]=tp[j][0],vl[j][1]=tp[j][1],su[j][0]=su[j-1][0]+vl[j][0];\n\t\t\tfor(int j=1;j<=s1;j++){int r1=j+k-1;if(r1<=s1)as-=1ll*vl[j][1]*(su[s1][0]-su[r1-1][0]);}\n\t\t}\n\t\tct=0;\n\t\tset<int>::iterator it=tp3.lower_bound(lb+1);\n\t\tif(it==tp3.end())break;\n\t\tlb=*it;\n\t}\n\tprintf(\"%lld\\n\",as+n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nint A[202020];\nint L[202020];\nint R[202020];\nset<int> S;\nset<pair<int,int>> cand;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tA[0]=1LL<<30;\n\tA[N+1]=1LL<<30;\n\t\n\tS.insert(0);\n\tS.insert(N+1);\n\tcand.insert({1<<30,0});\n\tfor(i=1;i<=N;i++) {\n\t\tcin>>A[i];\n\t\tL[i]=R[i]=1;\n\t\tS.insert(i);\n\t\tcand.insert({A[i],i});\n\t}\n\t\n\tll ret=N;\n\twhile(1) {\n\t\tauto c=*cand.begin();\n\t\t/*\n\t\tFORR(a,cand) cout<<a.first<<\":\"<<a.second<<\" \";\n\t\tcout<<ret<<endl;\n\t\t*/\n\t\t\n\t\tif(c.first>=1<<30) break;\n\t\tx=y=c.second;\n\t\t\n\t\tvector<vector<int>> V;\n\t\twhile(1) {\n\t\t\t//cout<<\"take\"<<y<<endl;\n\t\t\tV.push_back({y,L[y],R[y]});\n\t\t\tS.erase(y);\n\t\t\tcand.erase({A[y],y});\n\t\t\ty=*S.lower_bound(y+1);\n\t\t\tif(A[y]!=A[x]) break;\n\t\t}\n\t\t\n\t\t/*\n\t\tcout<<\"!\";\n\t\tFORR(v,V) cout<<v[0]<<\":\"<<v[1]<<\":\"<<v[2]<<\"  \";\n\t\tcout<<endl;\n\t\t*/\n\t\t\n\t\tint nl=V.size();\n\t\tint ns=nl/M;\n\t\tif(ns==0) {\n\t\t\tA[x]=1<<30;\n\t\t\tS.insert(x);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint RT=0;\n\t\tfor(i=M-1;i<V.size();i++) RT+=V[i][2];\n\t\tFOR(i,V.size()-M+1) {\n\t\t\t//cout<<\"ok\"<<V[i][1]<<\" \"<<RT<<endl;\n\t\t\tret+=1LL*V[i][1]*RT;\n\t\t\tRT-=V[i+M-1][2];\n\t\t}\n\t\tFOR(i,ns) L[x+i]=R[x+i]=0;\n\t\tFOR(i,V.size()) {\n\t\t\tif(i>=M-1) R[x+(i+1)/M-1]+=V[i][2];\n\t\t\tj=V.size()-1-i;\n\t\t\tif(j>=M-1) {\n\t\t\t\tj=(j+1)/M-1;\n\t\t\t\tL[x+ns-1-j]+=V[i][1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tRT=0;\n\t\tfor(i=M-1;i<ns;i++) RT+=R[x+i];\n\t\tFOR(i,ns-M+1) {\n\t\t\tret-=1LL*L[x+i]*RT;\n\t\t\tRT-=R[x+i+M-1];\n\t\t}\n\t\t\n\t\tA[x]++;\n\t\tFOR(i,ns) {\n\t\t\tA[x+i]=A[x];\n\t\t\tcand.insert({A[x+i],x+i});\n\t\t\tS.insert(x+i);\n\t\t}\n\t\t\n\t}\n\t\n\tcout<<ret<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//copy from https://atcoder.jp/contests/agc037/submissions/7059910\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn = 2e5+233;\nint n,l,a[maxn];\npii b[maxn];\nvector<pair<pii,pii> > f,g;\nll calc(vector<pii> &v){\n\tll res = 0 ,sum = 0;\n\tfor(unsigned i=0,j=l-1;j<v.size();++i,++j)\n\t\tsum+=v[i].fi,res+=sum*v[j].se;\n\treturn res;\n}\nint main(){\n\tn = read(),l = read();\n\tRep(i,1,n){\n\t\ta[i] = read();\n\t\tb[i] = make_pair(a[i],i);\n\t}sort(b+1,b+1+n);\n\tint pos = 0;\n\tll res = n,val = 0;\n\tfor(;;){\n//\t\tprintf(\"val = %d\\n\",val);\n\t\tif(f.empty()){\n\t\t\tif(pos > n) break;\n\t\t\tval = b[pos].fi;\n\t\t} else ++val;\n\t\twhile(val == b[pos].fi){f.push_back({{b[pos].se,b[pos].se},{1,1}});pos++;}\n\t\tg.clear();sort(f.begin(),f.end());\n\t\tfor(unsigned i=0,j=i;i<f.size();i=++j){\n\t\t\twhile(j+1<f.size()&&f[j+1].fi.fi==f[j].fi.se+1)++j;\n\t\t\tint len=j-i+1,cnt=len/l;\n\t\t\tif(cnt){\n\t\t\t\tvector<pii> tmp,ff,gg;\n\t\t\t\tRep(k,i,j) tmp.push_back(f[k].se);\n\t\t\t\tres += calc(tmp);\n\t\t\t\tRep(k,1,cnt){\n\t\t\t\t\tff.push_back({f[i].fi.fi+k-1,(k==cnt)?f[j].fi.se:f[i].fi.fi+k-1});\n\t\t\t\t\tgg.push_back({0,0});\n\t\t\t\t}\n\t\t\t\tRep(k,i,j){\n\t\t\t\t\tint tl=k-i+1,tr=j-k+1;\n\t\t\t\t\tif(tl>=l) gg[tl/l-1].se += f[k].se.se;\n\t\t\t\t\tif(tr>=l) gg[cnt-tr/l].fi += f[k].se.fi;\n\t\t\t\t}\n\t\t\t\tres -= calc(gg);\n\t\t\t\trep(k,0,cnt) g.push_back({ff[k],gg[k]});\n\t\t\t}\n\t\t}f = g;\n\t}\n\twriteln(res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, l, x[MAXN];\npair <int, int> y[MAXN];\nll calc(vector <pair <int, int>> &a) {\n\tll ans = 0, sum = 0;\n\tfor (unsigned i = l - 1, j = 0; i < a.size(); i++, j++) {\n\t\tsum += a[j].first;\n\t\tans += a[i].second * sum;\n\t}\n\treturn ans;\n}\nint main() {\n\tread(n), read(l);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(x[i]);\n\t\ty[i] = make_pair(x[i], i);\n\t}\n\tsort(y + 1, y + n + 1); ll ans = n;\n\tvector <pair <pair <int, int>, pair <int, int>>> a, b;\n\tfor (int val = 1, pos = 1; val <= n + 64; val++) {\n\t\twhile (val == y[pos].first) a.emplace_back(make_pair(y[pos].second, y[pos].second), make_pair(1, 1)), pos++;\n\t\tb.clear(), sort(a.begin(), a.end());\n\t\tfor (unsigned i = 0, j; i < a.size(); i = j + 1) {\n\t\t\tj = i; while (j + 1 < a.size() && a[j + 1].first.first == a[j].first.second + 1) j++;\n\t\t\tint len = j - i + 1, cnt = len / l;\n\t\t\tif (cnt != 0) {\n\t\t\t\tvector <pair <int, int>> cur, where, value;\n\t\t\t\tfor (unsigned k = i; k <= j; k++)\n\t\t\t\t\tcur.push_back(a[k].second);\n\t\t\t\tans += calc(cur);\n\t\t\t\tfor (int k = 1; k <= cnt; k++) {\n\t\t\t\t\twhere.emplace_back(a[i].first.first + k - 1, (k == cnt) ? a[j].first.second : a[i].first.first + k - 1);\n\t\t\t\t\tvalue.emplace_back(0, 0);\n\t\t\t\t}\n\t\t\t\tfor (unsigned k = i; k <= j; k++) {\n\t\t\t\t\tint tl = k - i + 1, tr = j - k + 1;\n\t\t\t\t\tif (tl >= l) value[tl / l - 1].second += a[k].second.second;\n\t\t\t\t\tif (tr >= l) value[cnt - tr / l].first += a[k].second.first;\n\t\t\t\t}\n\t\t\t\tans -= calc(value);\n\t\t\t\tfor (unsigned k = 0; k < where.size(); k++)\n\t\t\t\t\tb.emplace_back(where[k], value[k]);\n\t\t\t} \n\t\t}\n\t\ta = b;\n\t}\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=200000;\nstruct Block { int l,r,val; int mid; vector<int> pref,suff; };\n\nint n,need;\nint a[MAXN];\n\nint ufpar[MAXN],ufsz[MAXN];\nBlock block[MAXN];\npair<int,int> o[MAXN];\n\nint uffind(int x) { if(ufpar[x]==x) return x; return ufpar[x]=uffind(ufpar[x]); }\nvoid ufunite(int a,int b) { a=uffind(a),b=uffind(b); if(a==b) return; if(ufsz[a]<ufsz[b]) swap(a,b); ufpar[b]=a,ufsz[a]+=ufsz[b]; }\n\nvoid levelup(Block &b) {\n\tvector<int> npref(SZ(b.pref)/need,0); FORSZ(i,need-1,b.pref) npref[(i+1)/need-1]+=b.pref[i]; b.pref=npref;\n\tvector<int> nsuff(SZ(b.suff)/need,0); FORSZ(i,need-1,b.suff) nsuff[(i+1)/need-1]+=b.suff[i]; b.suff=nsuff;\n\tb.mid/=need; if(b.mid>0) ++b.val; else b.val=-1;\n}\nBlock merge(const Block &a,const Block &b,ll &ans) {\n\tassert(a.r+1==b.l); assert(a.val==b.val);\n\tBlock ret; ret.l=a.l; ret.r=b.r; ret.val=a.val; ret.mid=a.mid+b.mid;\n\tvector<int> npref=a.pref; REPSZ(i,b.pref) { int x=a.mid+i; while(x>=SZ(npref)) npref.PB(0); npref[x]+=b.pref[i]; } ret.pref=npref;\n\tvector<int> nsuff=b.suff; REPSZ(i,a.suff) { int x=b.mid+i; while(x>=SZ(nsuff)) nsuff.PB(0); nsuff[x]+=a.suff[i]; } ret.suff=nsuff;\n\tint sum=0,at=0; REPSZ(i,b.pref) sum+=b.pref[i]; for(int i=SZ(a.suff)-1;i>=0;--i) { while(i+1+at+1<need) sum-=b.pref[at],++at; ans+=(ll)a.suff[i]*sum; }\n\t//printf(\"merged: [%d..%d] val=%d mid=%d pref=\",ret.l,ret.r,ret.val,ret.mid); REPSZ(i,ret.pref) { if(i!=0) printf(\",\"); printf(\"%d\",ret.pref[i]); } printf(\" suff=\"); REPSZ(i,ret.suff) { if(i!=0) printf(\",\"); printf(\"%d\",ret.suff[i]); } puts(\"\");\n\treturn ret;\n}\nBlock merge(const vector<Block> &blocks,ll &ans) {\n\tFORSZ(i,1,blocks) assert(blocks[i-1].r+1==blocks[i].l),assert(blocks[i-1].val==blocks[i].val);\n\tBlock ret; ret.l=blocks[0].l,ret.r=blocks[SZ(blocks)-1].r,ret.val=blocks[0].val,ret.mid=0; REPSZ(i,blocks) ret.mid+=blocks[i].mid;\n\t{ vector<int> npref; int off=0; REPSZ(i,blocks) { REPSZ(j,blocks[i].pref) { int x=off+j; while(x>=SZ(npref)) npref.PB(0); npref[x]+=blocks[i].pref[j]; } off+=blocks[i].mid; } ret.pref=npref; }\n\t{ vector<int> nsuff; int off=0; for(int i=SZ(blocks)-1;i>=0;--i) { REPSZ(j,blocks[i].suff) { int x=off+j; while(x>=SZ(nsuff)) nsuff.PB(0); nsuff[x]+=blocks[i].suff[j]; } off+=blocks[i].mid; } ret.suff=nsuff; }\n\t{\n\t\tint sum=0; REPSZ(i,blocks) REPSZ(j,blocks[i].pref) sum+=blocks[i].pref[j];\n\t\tint ii=0,jj=0,off=0;\n\t\tREPSZ(i,blocks) { \n\t\t\toff-=blocks[i].mid;\n\t\t\tfor(int j=SZ(blocks[i].suff)-1;j>=0;--j) { \n\t\t\t\twhile(ii<=i||ii<SZ(blocks)&&j+1+jj+1+off<need) { sum-=blocks[ii].pref[jj]; ++jj; if(jj==SZ(blocks[ii].pref)) off+=blocks[ii].mid,++ii,jj=0; }\n\t\t\t\tans+=(ll)blocks[i].suff[j]*sum;\n\t\t\t}\n\t\t} \n\t}\n\t//printf(\"merged: [%d..%d] val=%d mid=%d pref=\",ret.l,ret.r,ret.val,ret.mid); REPSZ(i,ret.pref) { if(i!=0) printf(\",\"); printf(\"%d\",ret.pref[i]); } printf(\" suff=\"); REPSZ(i,ret.suff) { if(i!=0) printf(\",\"); printf(\"%d\",ret.suff[i]); } puts(\"\");\n\treturn ret;\n}\n\n\n\nll solve() {\n\tREP(i,n) ufpar[i]=i,ufsz[i]=1;\n\tREP(i,n) { block[i].l=block[i].r=i,block[i].val=a[i],block[i].mid=1; block[i].pref=block[i].suff=vector<int>(1,1); }\n\tREP(i,n) o[i]=MP(a[i],i);\n\tsort(o,o+n);\n\tll ret=n;\n\tfor(int l=0,r=l;l<n;l=r) {\n\t\tint val=o[l].first;\n\t\twhile(r<n&&o[r].first==val) ++r;\n\t\tvector<int> cur;\n\t\tcur.PB(-1);\n\t\tFOR(i,l,r) {\n\t\t\tint at=o[i].second,prv=-1,nxt=-1;\n\t\t\tif(at-1>=0&&a[at-1]<=val) { int x=uffind(at-1); while(block[x].val!=-1&&block[x].val<val) levelup(block[x]); if(block[x].val!=-1) prv=x; }\n\t\t\tif(at+1 <n&&a[at+1]<=val) { int x=uffind(at+1); while(block[x].val!=-1&&block[x].val<val) levelup(block[x]); if(block[x].val!=-1) nxt=x; }\n\t\t\tif((SZ(cur)<1||cur[SZ(cur)-1]!=prv)&&(SZ(cur)<2||cur[SZ(cur)-2]!=prv)) cur.PB(prv);\n\t\t\tif(SZ(cur)<1||cur[SZ(cur)-1]!=at) cur.PB(at);\n\t\t\tcur.PB(nxt);\n\t\t}\n\t\tcur.PB(-1);\n\t\t//printf(\"cur:\"); REPSZ(i,cur) printf(\" %d\",cur[i]); puts(\"\");\n\t\tREPSZ(i,cur) if(cur[i]!=-1&&cur[i-1]==-1) {\n\t\t\tint j=i; while(cur[j+1]!=-1) ++j;\n\t\t\tvector<Block> blocks; FORE(k,i,j) blocks.PB(block[cur[k]]);\n\t\t\t//Block me=blocks[0]; FORSZ(k,1,blocks) me=merge(me,blocks[k],ret);\n\t\t\tBlock me=merge(blocks,ret);\n\t\t\tFORE(k,i+1,j) ufunite(cur[i],cur[k]);\n\t\t\tblock[uffind(cur[i])]=me;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&need);\n\tREP(i,n) scanf(\"%d\",&a[i]);\n\tprintf(\"%lld\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define N 400600\nmap<int,int> tp1;\nset<int> tp3;\nstruct sth{int l,r,lb,rb;friend bool operator <(sth a,sth b){return a.l<b.l;}};\nvector<sth> v[N];\nint su[N][2],vl[N][2],tp[N][2],ct,n,k,s[N],cnt;\nlong long as;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&s[i]);\n\t\ttp3.insert(s[i]);if(!tp1[s[i]])tp1[s[i]]=++cnt;\n\t\tv[tp1[s[i]]].push_back((sth){i,i,1,1});\n\t}\n\tint lb=*tp3.lower_bound(1);\n\twhile(1)\n\t{\n\t\tint st=tp1[lb];\n\t\tsort(v[st].begin(),v[st].end());\n\t\tint sz=v[st].size(),las=v[st][0].l;\n\t\tfor(int i=0;i<sz;i++)\n\t\t{\n\t\t\tif(ct&&v[st][i].l!=v[st][i-1].r+1)\n\t\t\t{\n\t\t\t\tsu[ct+1][0]=su[ct+1][1]=0;\n\t\t\t\tint s1=ct/k;\n\t\t\t\tif(s1)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=1;j<=ct;j++){int r1=j+k-1;if(r1<=ct)as+=1ll*vl[j][1]*(su[ct][0]-su[r1-1][0]);}\n\t\t\t\t\tfor(int j=1;j<s1;j++)tp[j][0]=su[(j+1)*k-1][0]-su[j*k-1][0];\n\t\t\t\t\ttp[s1][0]=su[ct][0]-su[s1*k-1][0];\n\t\t\t\t\tfor(int j=1;j<s1;j++)tp[s1-j+1][1]=-su[ct-(j+1)*k+1][1]+su[ct-j*k+1][1];\n\t\t\t\t\ttp[1][1]=su[ct-s1*k+1][1];\n\t\t\t\t\tif(!tp1[lb+1])tp1[lb+1]=++cnt,tp3.insert(lb+1);\n\t\t\t\t\tfor(int j=1;j<=s1;j++)v[tp1[lb+1]].push_back((sth){las+j-1,j==s1?v[st][i-1].r:las+j-1,tp[j][0],tp[j][1]});\n\t\t\t\t\tfor(int j=1;j<=s1;j++)vl[j][0]=tp[j][0],vl[j][1]=tp[j][1],su[j][0]=su[j-1][0]+vl[j][0];\n\t\t\t\t\tfor(int j=1;j<=s1;j++){int r1=j+k-1;if(r1<=s1)as-=1ll*vl[j][1]*(su[s1][0]-su[r1-1][0]);}\n\t\t\t\t}\n\t\t\t\tct=0;las=v[st][i].l;\n\t\t\t}\n\t\t\tvl[++ct][0]=v[st][i].lb;vl[ct][1]=v[st][i].rb;\n\t\t\tsu[ct][0]=su[ct-1][0]+vl[ct][0];su[ct][1]=su[ct-1][1]+vl[ct][1];\n\t\t}\n\t\tsu[ct+1][0]=su[ct+1][1]=0;\n\t\tint s1=ct/k;\n\t\tif(s1)\n\t\t{\n\t\t\tfor(int j=1;j<=ct;j++){int r1=j+k-1;if(r1<=ct)as+=1ll*vl[j][1]*(su[ct][0]-su[r1-1][0]);}\n\t\t\tfor(int j=1;j<s1;j++)tp[j][0]=su[(j+1)*k-1][0]-su[j*k-1][0];\n\t\t\ttp[s1][0]=su[ct][0]-su[s1*k-1][0];\n\t\t\tfor(int j=1;j<s1;j++)tp[s1-j+1][1]=-su[ct-(j+1)*k+1][1]+su[ct-j*k+1][1];\n\t\t\ttp[1][1]=su[ct-s1*k+1][1];\n\t\t\tif(!tp1[lb+1])tp1[lb+1]=++cnt,tp3.insert(lb+1);\n\t\t\tfor(int j=1;j<=s1;j++)v[tp1[lb+1]].push_back((sth){las+j-1,j==s1?v[st][sz-1].r:las+j-1,tp[j][0],tp[j][1]});\n\t\t\tfor(int j=1;j<=s1;j++)vl[j][0]=tp[j][0],vl[j][1]=tp[j][1],su[j][0]=su[j-1][0]+vl[j][0];\n\t\t\tfor(int j=1;j<=s1;j++){int r1=j+k-1;if(r1<=s1)as-=1ll*vl[j][1]*(su[s1][0]-su[r1-1][0]);}\n\t\t}\n\t\tct=0;\n\t\tset<int>::iterator it=tp3.lower_bound(lb+1);\n\t\tif(it==tp3.end())break;\n\t\tlb=*it;\n\t}\n\tprintf(\"%lld\\n\",as+n);\n}//"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst int N=2e5+1;\nint n,z;\npair<int,int>a[N];\nint l[N],r[N];\nint sl[N],sr[N],sx[N];\nint sz=0;\ndeque<int>v[2*N];\nvector<ll>pw;\nll ans=0;\nvoid shrink(int vt,int sf){\n\tint ls=v[vt].size()/sf;\n\tfor(int i=0; i<ls ;i++) v[vt][i]=v[vt][(i+1)*sf-1];\n\tv[vt].resize(ls);\n}\nvoid merge(int ml,int mr){\n\tif(sx[mr]<=sx[ml]){\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=r[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sl[ml],pr=sr[ml];\n\t\tint ql=sl[mr],qr=sr[mr];\n\t\tint dl=l[ml],dr=r[mr];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint nxt=dr+1;\n\t\t\tif(i!=v[ql].size()-1) nxt=v[ql][i+1];\n\t\t\tans+=1LL*(nxt-v[ql][i])*(v[pr][x-1]-dl+1);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++) v[pl].push_back(v[ql][i]);\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--) v[pr].push_front(v[qr][i]);\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dr]=sx[dl];\n\t\tsl[dr]=sl[dl];\n\t\tsr[dr]=sr[dl];\n\t}\n\telse{\n\t\tswap(ml,mr);\n\t\tint jp=sx[ml]-sx[mr];\n\t\tsx[mr]=sx[ml];\n\t\tif(pw.size()<=jp){\n\t\t\tv[sl[mr]].clear();\n\t\t\tv[sr[mr]].clear();\n\t\t}\n\t\telse{\n\t\t\tshrink(sl[mr],pw[jp]);\n\t\t\tshrink(sr[mr],pw[jp]);\n\t\t}\n\t\tif(v[sl[mr]].empty()){\n\t\t\tint y=l[mr];\n\t\t\tl[y]=r[y]=l[mr]=r[mr]=0;\n\t\t\treturn;\n\t\t}\n\t\tint pl=sr[ml],pr=sl[ml];\n\t\tint ql=sr[mr],qr=sl[mr];\n\t\tint dl=l[mr],dr=r[ml];\n\t\tfor(int i=0; i<v[ql].size() ;i++){\n\t\t\tint x=max(1,z-i-1);\n\t\t\tif(x>v[pr].size()) continue;\n\t\t\tint nxt=dl-1;\n\t\t\tif(i!=v[ql].size()-1) nxt=v[ql][i+1];\n\t\t\tans+=1LL*(v[ql][i]-nxt)*(dr-v[pr][x-1]+1);\n\t\t}\n\t\tfor(int i=0; i<v[ql].size() ;i++) v[pl].push_back(v[ql][i]);\n\t\tfor(int i=v[qr].size()-1; i>=0 ;i--) v[pr].push_front(v[qr][i]);\n\t\tv[ql].clear();v[qr].clear();\n\t\tr[dl]=dr;l[dr]=dl;\n\t\tsx[dl]=sx[dr];\n\t\tsl[dl]=sl[dr];\n\t\tsr[dl]=sr[dr];\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> z;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> a[i].fi;\n\t\ta[i].se=i;\n\t}\n\tpw.push_back(1);\n\twhile(pw.back()*z<=n){\n\t\tpw.push_back(pw.back()*z);\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1; i<=n ;i++){\n\t\tint cl=i,cr=i;\n\t\twhile(cr<n && a[cr+1].fi==a[cl].fi) cr++;\n\t\ti=cr;\n\t\tfor(int j=cl; j<=cr ;j++){\n\t\t\tint x=a[j].se;\n\t\t\tl[x]=r[x]=x;\n\t\t\tsx[x]=a[j].fi;\n\t\t\tsl[x]=++sz;v[sz].push_back(x);\n\t\t\tsr[x]=++sz;v[sz].push_back(x);\n\t\t\tif(r[x-1]!=0) merge(x-1,x);\n\t\t\tif(l[x+1]!=0) merge(x,x+1);\n\t\t}\n\t}\n\tcout << ans+n << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, L;\nvector<int> v;\n\nstruct Elem {\n\tint value = 0;\n\tint l = 0, r = 0;\n};\n\nint calc_cost(vector<Elem> v) { \n\tint r = 0;\n\tfor (int i = 0; i < len(v); i++) {\n\t\tr += v[i].l * v[i].r;\n\t\tfor (int j = i + L - 1; j < len(v); j++) {\n\t\t\tr += v[i].l * v[j].r;\n\t\t}\n\t}\n\treturn r;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, L;\n\tv.resize(n);\n\tscan v;\n\tvector<Elem> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.pb({v[i], 1, 1});\n\tll rez = 0;\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tvector<Elem> t;\n\t\tvector<Elem> buf;\n\t\tint cur = 2e9;\n\t\tfor (int i = 0; i < len(s); i++)\n\t\t\tif (s[i].value != -1) {\n\t\t\t\tcur = min(cur, s[i].value);\n\t\t\t}\n\t\ts.pb({(int)-1e9, -1, -1});\n\t\tfor (int i = 0; i < len(s); i++) {\n\t\t\tif (s[i].value == cur) {\n\t\t\t\tbuf.pb(s[i]);\t\n\t\t\t} else {\n\t\t\t\tvector<Elem> _new(len(buf) / L, {cur + 1, 0, 0});\n\t\t\t\tif (len(buf) < L) {\n\t\t\t\t\tfor (int i = 0; i < len(buf); i++) {\n\t\t\t\t\t\trez += buf[i].l * buf[i].r;\n\t\t\t\t\t\tif (buf[i].value != -1)\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\tbuf[i].l = buf[i].r = 0;\n\t\t\t\t\t\tbuf[i].value = -1;\n\t\t\t\t\t}\n\t\t\t\t\t_new = buf;\n\t\t\t\t} else {\n\t\t\t\t\tchange = true;\n\t\t\t\t\trez += calc_cost(buf);\t\n\t\t\t\t\tint k = len(buf) % L + 1;\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].l += buf[j].l;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].l += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.l;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].r += buf[j].r;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].r += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.r;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\trez -= calc_cost(_new);\n\t\t\t\t}\n\t\t\t\tt.insert(t.end(), _new.begin(), _new.end());\n\t\t\t\tif (s[i].value != -1e9)\n\t\t\t\t\tt.pb(s[i]);\n\t\t\t\tbuf.clear();\n\t\t\t}\n\t\t}\n\t\tswap(t, s);\n\t\t// for (int i = 0; i < len(s); i++) {\n\t\t// \tprint \"{\", s[i].value, s[i].l, s[i].r, \"}\";\n\t\t// \t// print s[i].value;\n\t\t// \tsmart_io::print_start = \" \";\n\t\t// }\n\t\t// smart_io::print_start = \"\\n\";\n\t\tcur++;\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace::std;\n//struct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n__attribute__((constructor))\nvoid init(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(15);\n}\n// random_device rd;\n// mt19937 mt(rd());\n// #include <boost/numeric/interval.hpp>\n// #include <boost/numeric/interval/io.hpp>\n// #include <boost/intrusive/rbtree.hpp>\n// #include <boost/dynamic_bitset.hpp>\n// #include <boost/geometry.hpp>\n// #include <boost/geometry/geometries/linestring.hpp>\n// #include <boost/geometry/geometries/polygon.hpp>\n// #include <boost/geometry/geometries/point_xy.hpp>\n// #include <boost/math/tools/minima.hpp>\n// using boost::math::tools::brent_find_minima;\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<256>> cdouble;\n// typedef mp::cpp_int cint;\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T=long long>using pbds=tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pbds_map=tree<T,T,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pqueue =__gnu_pbds::priority_queue<T, less<T>,rc_binomial_heap_tag>;\ntypedef long long lint;\ntypedef long long ll;\ntypedef long double ldouble;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<double> dvec;\ntypedef vector<vector<double>> dmat;\ntypedef vector<vector<vector<double>>> dmat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntypedef vector<vector<vector<string>>> smat3;\ntypedef vector<pair<lint,lint>> pvec;\ntypedef vector<vector<pair<lint,lint>>> pmat;\ntypedef vector<vector<vector<pair<lint,lint>>>> pmat3;\n#define rep(i, n) for(lint i = 0; i < (lint)(n); i++)\n#define irep(i) for(lint i = 0;; i++)\n#define irep1(i) for(lint i = 1;; i++)\n#define irep2(i) for(lint i = 2;; i++)\n#define rrep(i, n) for(lint i = (lint)(n-1); i >-1; i--)\n#define rrepi(i,a,b) for(lint i = (lint)(b-1); i >a-1; i--)\n#define repi(i,a,b) for(lint i=lint(a);i<lint(b);i++)\n#define rep2(i,a,b,c) for(lint i=lint(a);i>lint(b);i+=c)\n#define all(x) (x).begin(),(x).end()\n#define PI 3.141592653589793\n#define dist(x1,y1,x2,y2) (pow(pow(x2-x1,2)+pow(y2-y1,2),0.5))\n#define output(v) do{bool f=0;for(auto i:v){cout<<(f?\" \":\"\");if(i>INF/2)cout<<\"INF\";else cout<<i;f=1;}cout<<\"\\n\";}while(0);\n#define output2(v) for(auto j:v)output(j);\n#define _output(v) do{bool f=0;rep(i,v.size()){cout<<(f?\" \":\"\");if(v[i]>INF/2)cout<<\"INF\";else cout<<v[i];f=1;}cout<<\"\\n\";}while(0)\n#define _output2(v) rep(j,v.size()){_output(v[j]);}\n#define input(a,n) lint n;cin>>n;vector<lint>a(n);rep(i,n)cin>>a[i];\n#define SUM(v) accumulate(all(v),0LL)\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define LINF 9223372036854775807\n#define MOD 998244353LL\n#define endl \"\\n\"\ntemplate<typename T=lint>T in(){return *istream_iterator<T>(cin);}\ninline lint gcd(lint a,lint b){return b?gcd(b,a%b):a;}\ntemplate<typename T=lint>inline T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<typename T=lint>inline T add(T a,T b){return a+b;}\ntemplate<typename T=lint>inline T minq(T a,T b){return min(a,b);}\ninline bool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\ninline bool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nvector<lint> dx={-1,1,0,0,1,1,-1,-1};\nvector<lint> dy={0,0,-1,1,1,-1,1,-1};\n\n\n\n// template<typename T,typename E>\n// struct RBST{\n// \tstruct node{\n// \t\tint cnt=1,l=-1,r=-1;\n// \t\tT key;E val;\n// \t\tnode(){}\n// \t\tnode(T key,E val):key(key),val(val){}\n// \t};\n// \tvector<node> v;\n// \tRBST(){\n// \t}\n// \tint root=1;\n// \tint count(int idx){return idx==-1?0:v[idx].cnt;}\n// \tint update(int idx){\n// \t\tif(idx!=-1)v[idx].cnt=1+count(v[idx].l)+count(v[idx].r);\n// \t\treturn idx;\n// \t}\n// \tprivate:\n// \tinline int merge(int l,int r){\n//         if(l==-1||r==-1)return l==-1?r:l;\n//         if((unsigned long)count(v[l])>rnd()%(unsigned long)(count(v[l])+count(v[r]))){\n//             v[l].r=merge(v[l].r,r);\n//             return update(l);\n//         }else{\n//             v[r].l=merge(l,v[r].l);\n//             return update(r);\n//         }\n//     }\n// \tinline pair<int,int> split(int t,int k){\n//         if(t==-1)return make_pair(-1,-1);\n//         if(k<=count(v[t].l)){\n//             auto s=split(v[t].l,k);\n//             v[t].l=s.second;\n//             return make_pair(s.first,update(t));\n//         }else{\n//             auto s=split(v[t].r,k-count(v[t].l)-1);\n//             v[t].r=s.first;\n//             return make_pair(update(t),s.second);\n//         }\n//     }\n// \tinline unsigned long rnd() {\n//         static unsigned long x=123456789, y=362436069, z=521288629, w=88675123;\n//         unsigned long t=(x^(x<<11));\n//         x=y; y=z; z=w;\n//         return ( w=(w^(w>>19))^(t^(t>>8)) );\n//     }\n// };\n\n\n\nint main(){\n    lint n,k;\n    cin>>n>>k;\n    string s;\n    cin>>s;\n    set<string>t,next[2];\n    t.insert(s);\n    next[0].insert(s);\n    rep(i,k){\n        next[(i+1)%2].clear();\n        for(string s2:next[i%2]){\n            string u=s2;\n            reverse(all(s2));\n            u+=s2;\n            rep(j,n){\n                auto s3=u.substr(j,n);\n                if(!t.count(s3)){\n                    t.insert(s3);\n                    next[(i+1)%2].insert(s3);\n                }\n            }\n        }\n        if(next[(i+1)%2].empty())break;\n    }\n    cout<<*t.begin();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define prt(args...) fprintf(stderr, args)\nint a[200100],l1[200100],r1[200100],l2[200100],r2[200100],la[200100],nx[200100],fl[200100];\nint aa[400100],q1[200100];\nstd::pair<int,int>q[200100];\ninline bool cmp(std::pair<int,int>A,std::pair<int,int>B){return A>B;}\nint main()\n{\n\tre int n,L,ta=0;\n\tre long long ans=0;\n\tscanf(\"%d%d\",&n,&L);\n\tfor(re int i=1;i<=n;i++)scanf(\"%d\",&a[i]),ans++,fl[i]=i,r1[i]=r2[i]=1,q[ta++]=std::make_pair(a[i],i),la[i]=i-1,nx[i]=i+1;\n\tstd::make_heap(q,q+ta,cmp);\n\twhile(ta)\n\t{\n\t\tre int x=q[0].second,ta1=0,j1=1;\n\t\tstd::pop_heap(q,q+ta,cmp);ta--;//printf(\"*p*%d %d %d\\n\",x,q[ta].first,q[ta].second);\n\t\tif(q[ta].first!=a[x])continue;\n\t\tfor(re int i1=x;i1<=n&&a[i1]==a[x];i1=nx[i1])q1[++ta1]=i1;\n\t\tif(ta1<L)continue;//printf(\"********%d %d %d\\n\",x,ta1,ta);\n\t\tfor(re int i1=1;i1<=ta1;i1++)l1[i1]=l1[i1-1]+r1[q1[i1]];\n\t\tfor(re int i1=ta1;i1;i1--)l2[i1]=l2[i1+1]+r2[q1[i1]];\n\t\tfor(re int i1=1;i1<=ta1;i1++)\n\t\t{\n\t\t\twhile(j1<=ta1&&(j1<i1+L-1||q1[j1]<=fl[q1[i1]]))j1++;\n\t\t\tif(j1>ta1)break;\n\t\t\t//printf(\"**%d %d %d %d %d %d %lld\\n\",i1,q1[i1],j1,q1[j1],r1[q1[i1]],l2[j1],ans);\n\t\t\tans+=(long long)r1[q1[i1]]*l2[j1];\n\t\t}\n\t\tfor(re int i1=1;i1*L<=ta1;i1++)\n\t\t{\n\t\t\tfl[q1[i1]]=q1[ta1],a[q1[i1]]++;\n\t\t\tr1[q1[i1]]=l1[(i1-1)*L+1+ta1%L]-l1[std::max((i1-2)*L+1+ta1%L,0)];\n\t\t\tr2[q1[i1]]=l1[std::min(ta1,(i1+1)*L-1)]-l1[i1*L-1];\n\t\t//\tprintf(\"******%d %d %d %d %d %d\\n\",i1,r1[q1[i1]],r2[q1[i1]],l1[std::min(ta1,(i1+1)*L-1)]-l1[i1*L-1],std::min(ta1,(i1+1)*L-1),i1*L-1);\n\t\t}\n\t\tfor(re int i1=ta1/L+1;i1<=ta1;i1++)a[q1[i1]]++,nx[la[q1[i1]]]=nx[q1[i1]],la[nx[q1[i1]]]=la[q1[i1]];\n\t\tfor(re int i1=1;i1<=ta1;i1++)l1[i1]=l2[i1]=0;\n\t\tif(a[la[q1[1]]]!=a[q1[1]])q[ta++]=std::make_pair(a[q1[1]],q1[1]),std::push_heap(q,q+ta,cmp);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=200005;\npriority_queue<pii,vector<pii>,greater<pii> > Q;\nint pre[N],suf[N],q[N];\nint a[N],l[N],r[N],n,L;\nint Sl[N],Sr[N];\nll ans;\nvoid erase(int x){\n\tsuf[pre[x]]=suf[x];\n\tpre[suf[x]]=pre[x];\n}\nvoid work(){\n\t//printf(\"work %d %d\\n\",*q,ans);\n\t//For(i,1,*q) printf(\"%d %d %d\\n\",q[i],l[i],r[i]); puts(\"\");\n\tint m=*q,pl,pr;\n\tq[0]=pre[q[1]];\n\tq[m+1]=suf[q[m]];\n\tSl[0]=Sr[m+1]=0;\n\tFor(i,1,m+1) Sl[i]=Sl[i-1]+l[q[i]];\n\tRep(i,m,0) Sr[i]=Sr[i+1]+r[q[i]];\n\tFor(i,L,m) ans+=1ll*r[q[i]]*Sl[i-L+1];\n\tpl=m+1,pr=max(1,m-L+2);\n\tRep(i,m/L,1){\n\t\tpl-=L; pr=max(1,pr-L);\n\t\tl[q[i]]=Sl[pl]-Sl[pr-1];\n\t}\n\tpl=0,pr=min(m,L-1);\n\tFor(i,1,m/L){\n\t\tpl+=L; pr=min(m,pr+L);\n\t\tr[q[i]]=Sr[pl]-Sr[pr+1];\n\t}\n\tif (m<L){\n\t\tFor(i,2,m) erase(q[i]);\n\t\ta[q[1]]=1<<30;\n\t\tQ.push(pii(a[q[1]],q[1]));\n\t}\n\telse{\n\t\tFor(i,1,m/L) ++a[q[i]];\n\t\tFor(i,1,m/L) Q.push(pii(a[q[i]],q[i]));\n\t\tFor(i,m/L+1,m) erase(q[i]);\n\t\tFor(i,1,m/L) Sl[i]=Sl[i-1]+l[q[i]];\n\t\tFor(i,L,m/L) ans-=1ll*r[q[i]]*Sl[i-L+1];\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&L);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) l[i]=r[i]=1;\n\tFor(i,1,n) pre[i]=i-1,suf[i]=i+1;\n\tFor(i,1,n) Q.push(pii(a[i],i));\n\twhile (!Q.empty()){\n\t\tq[++*q]=Q.top().se; Q.pop();\n\t\tif (a[q[1]]==1<<30) break;\n\t\tfor (;!Q.empty()&&Q.top().fi==a[q[*q]];){\n\t\t\tint tmp=Q.top().se; Q.pop();\n\t\t\tif (tmp!=suf[q[*q]]) work(),*q=0;\n\t\t\tq[++*q]=tmp;\n\t\t}\n\t\twork(); *q=0;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define fi first\n#define se second\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii; \nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L;\nvector<pii> num;\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[2];\nint main()\n{\n//\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout); \n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x; read(x);\n\t\tnum.push_back(make_pair(x,i));\n\t}\n\tsort(num.begin(),num.end());\n\tll an=n;\n\tint cur=0,now=0,pt=0;\n\twhile(true)\n\t{\n\t\tcur^=1; rec[cur^1].clear();\n\t\tif(rec[cur].size()==0)\n\t\t{\n\t\t\tif(pt<num.size()) now=num[pt].fi;\n\t\t\telse break;\n\t\t}\n\t\telse ++now;\n\t\twhile(pt<num.size()&&num[pt].fi==now) rec[cur].push_back(node(num[pt].se,num[pt].se,1,1)),++pt;\n\t\tsort(rec[cur].begin(),rec[cur].end());\n\t\tfor(int l=0,r;l<rec[cur].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r+1<rec[cur].size()&&rec[cur][r+1].l==rec[cur][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue;\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[cur][j].R;\n\t\t\t\tan+=(ll)rec[cur][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[cur][l].l-1;\n\t\t\tfor(int j=1;j<=k;++j)\n\t\t\t{\n\t\t\t\ttmp[j].l=tmp[j].r=tmp[j-1].l+1;\n\t\t\t\ttmp[j].L=tmp[j].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[cur][r].r;\n\t\t\tfor(int j=l;j<=r;++j)\n\t\t\t{\n\t\t\t\tint x=j-l+1,y=r-j+1;\n\t\t\t\tif(x>=L) tmp[x/L].R+=rec[cur][j].R;\n\t\t\t\tif(y>=L) tmp[k-y/L+1].L+=rec[cur][j].L;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\tfor(int j=1;j<=k;++j) rec[cur^1].push_back(tmp[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n  if(abs(a) < eps && abs(b) < eps) return 0;\n  else if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n  if(a < b) return -1;\n  return 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n  if(a < b) return -1;\n  if(a == b) return 0;\n  return 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n  if(na == 0) return 0;\n  int be = 0, en = na - 1;\n  if(*a <= *(a + na - 1)){\n    if(f_lb == 0) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != 1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != -1) en = mid;\n      else be = mid + 1;\n    }\n    if(f_small && jud(*(a + be), val) == 1) be--;\n    if(!f_small && jud(*(a + be), val) == -1) be++;\n  } else {\n    if(f_lb) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != -1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != 1) en = mid;\n      else be = mid + 1;\n    }\n    if(!f_small && jud(*(a + be), val) == -1) be--;\n    if(f_small && jud(*(a + be), val) == 1) be++;\n  }\n  return be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n  if(m < 0) return 0;\n  long long ans = 1;\n  long long k = n;\n  while(m){\n    if(m & 1) {\n      ans *= k;\n      if(mod) ans %= mod;\n    }\n    k *= k;\n    if(mod) k %= mod;\n    m >>= 1;\n  }\n  return ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n  if(mod == -1) mod = MOD;\n  a += b;\n  while(a >= mod) a -= mod;\n  while(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    cerr << arr[i] << ' ';\n  cerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    output1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 200100;\nint n, l;\nint orig[maxn];\nstruct Range {\n  int from, to;\n  vi align_to[2];\n  bool operator < (const Range& other) const {\n    if (from == other.from) {\n      return to < other.to;\n    }\n    return from < other.from;\n  }\n} buf[maxn * 3];\nint lbuf;\nmap<int, vector<int>> all_range;\nint temp[2][maxn], ltemp;\n\n\nint main() {\n  //............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！........................................\n  ios_base::sync_with_stdio(0);\n  #ifdef DEBUG //......................................................................................................\n  freopen(\"input.txt\", \"r\", stdin);\n  #endif //...........................................................................................................\n\n  scanf(\"%d%d\", &n, &l);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", orig + i);\n    buf[lbuf].from = i;\n    buf[lbuf].to = i + 1;\n    buf[lbuf].align_to[0].push_back(1);\n    buf[lbuf].align_to[1].push_back(1);\n    all_range[orig[i]].push_back(lbuf++);\n  }\n\n  ll ans = 0;\n  for (auto& it : all_range) {\n    vi& all_r = it.second;\n    sort(all_r.begin(), all_r.end(), [&](const int& a, const int& b) {\n      return buf[a] < buf[b];\n    });\n    for (int i = 0, nxt_i = 0; i < (int)all_r.size(); i = nxt_i) {\n      while (nxt_i < (int)all_r.size() - 1 &&\n          buf[all_r[nxt_i + 1]].from == buf[all_r[nxt_i]].to) {\n        nxt_i++;\n      }\n      nxt_i++;\n      ltemp = 0;\n      for (int j = i; j < nxt_i; j++) {\n        int no = all_r[j];\n        auto rbuf = buf[no];\n        for (int k = 0, rsum = 0; k < (int)rbuf.align_to[0].size(); k++) {\n          temp[0][ltemp] = rbuf.align_to[0][k];\n          temp[1][ltemp++] = rbuf.align_to[1][rbuf.align_to[0].size() - k - 1];\n          if (k >= l - 1) rsum += rbuf.align_to[1][rbuf.align_to[0].size() - k - 1 + l - 1];\n          ans -= 1ll * rbuf.align_to[0][k] * rsum;\n        }\n      }\n      for (int j = 0, sum = 0; j < ltemp; j++) {\n        if (j >= l - 1) sum += temp[1][j - l + 1];\n        ans += 1ll * temp[0][j] * sum;\n      }\n\n      if (ltemp >= l) {\n        buf[lbuf].from = buf[all_r[i]].from;\n        buf[lbuf].to = buf[all_r[nxt_i - 1]].to;\n\n        for (int j = l - 1; j < ltemp; j++) {\n          if (j % l == l - 1) {\n            buf[lbuf].align_to[0].push_back(0);\n            buf[lbuf].align_to[1].push_back(0);\n          }\n          buf[lbuf].align_to[0].back() += temp[0][j];\n          buf[lbuf].align_to[1].back() += temp[0][ltemp - 1 - j];\n        }\n        all_range[it.first + 1].push_back(lbuf++);\n      }\n    }\n  }\n\n  cout << ans + n << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 200233, inf = 1100000007;\nint n, L, a[N], lf[N], rf[N], lp[N], rp[N];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> s;\nll ans = 0;\n\nint main() {\n  scanf(\"%d%d\", &n, &L);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    lf[i] = rf[i] = 1;\n    lp[i] = i - 1;\n    rp[i] = i + 1;\n    s.push(make_pair(a[i], i));\n  }\n  rf[0] = 1;\n  lf[n + 1] = n;\n  while (1) {\n    int x = s.top().second;\n    s.pop();\n    if (a[x] == inf) break;\n    int y = x, cnt = 1;\n    vector<int> v(1, x);\n    while (a[rp[y]] == a[y]) {\n      cnt++;\n      y = rp[y];\n      v.push_back(y);\n      s.pop();\n    }\n    for (int i = 0, sum = 0; i < cnt; i++) {\n      ans += (ll) lf[v[i]] * rf[v[i]];\n      if (i - L + 1 >= 0) {\n        sum += lf[v[i - L + 1]];\n      }\n      ans += (ll) sum * rf[v[i]];\n    }\n    int lt = lp[x], rt = rp[y];\n    if (lt == 0 && rt == n + 1) {\n      break;\n    }\n    int cnt2 = cnt / L;\n    vector<int> nlf(cnt2, 0), nrf(cnt2, 0);\n    for (int i = 0; i < cnt; i++) {\n      if (cnt - i >= L) {\n        nlf[cnt2 - 1 - (cnt - i - L) / L] += lf[v[i]];\n      }\n      if (i + 1 >= L) {\n        nrf[(i + 1 - L) / L] += rf[v[i]];\n      }\n    }\n    for (int i = 0, sum = 0; i < cnt2; i++) {\n      ans -= (ll) nlf[i] * nrf[i];\n      if (i - L + 1 >= 0) {\n        sum += nlf[i - L + 1];\n      }\n      ans -= (ll) sum * nrf[i];\n    }\n    if (!cnt2) {\n      ++cnt2;\n      a[v[0]] = inf - 1;\n      nlf.assign(1, 0);\n      nrf.assign(1, 0);\n    }\n    for (int i = 0; i < cnt2; i++) {\n      a[v[i]]++;\n      s.push(make_pair(a[v[i]], v[i]));\n      lf[v[i]] = nlf[i];\n      rf[v[i]] = nrf[i];\n    }\n    lp[v[0]] = lt;\n    rp[v[cnt2 - 1]] = rt;\n    rp[lt] = v[0];\n    lp[rt] = v[cnt2 - 1];\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n\n#define long long long int\n\nusing namespace std;\n\n// @author: pashka\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n, l;\n    cin >> n >> l;\n\n    vector<pair<int, vector<int>>> st;\n\n    st.push_back({2000000000, {}});\n\n    long res = 0;\n\n    for (int ii = 0; ii < n; ii++) {\n        int x;\n        cin >> x;\n        while (st.back().first < x) {\n            auto r = st.back().first;\n            auto p = st.back().second;\n            st.pop_back();\n            int c = p.size();\n            if (c < l) {\n                while (st.size() > 1) {\n                    st.pop_back();\n                }\n                break;\n            }\n            vector<int> cc;\n            for (int q = c / l; q > 0; q--) {\n                cc.push_back(p[p.size() - q * l]);\n            }\n            if (st.back().first == r + 1) {\n                int xx = st.back().second.back();\n                for (int t : cc) {\n                    st.back().second.push_back(\n                            xx + t\n                    );\n                }\n            } else {\n//                for (int i = 1; i < cc.size(); i++) {\n//                    cc[i] += cc[i - 1];\n//                }\n                st.push_back({r + 1, cc});\n            }\n        }\n        if (st.back().first == x) {\n            st.back().second.push_back(\n                    st.back().second.back() + 1\n            );\n        } else {\n            st.push_back({x, {1}});\n        }\n        res += 1;\n        if (st.back().second.size() >= l) {\n            res += st.back().second[st.back().second.size() - l];\n        }\n        int r = st.back().first;\n        int c = st.back().second.size();\n//        for (auto p: st) {\n//            cout << p.first << \": \";\n//            for (auto x : p.second) {\n//                cout << x << \" \";\n//            }\n//            cout << \"\\n\";\n//        }\n        for (int i = (int)st.size() - 2; i >= 0; i--) {\n            while (st[i].first != r) {\n                r++;\n                c /= l;\n                if (c == 0) break;\n            }\n            if (c == 0 || st[i].first != r) break;\n            if (c >= l) {\n                res += st[i].second[st[i].second.size() - 1];\n            } else {\n                if (c + st[i].second.size() < l) {\n                    break;\n                } else {\n                    res += st[i].second[st[i].second.size() - (l - c)];\n                }\n            }\n            c += st[i].second.size();\n        }\n//        cout << \"!!! \" << res << endl;\n    }\n    cout << res;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=s;i<t;i++)\n#define MAXNUM 222222\ntypedef long long ll;\nstruct node{\n    int posl,posr,lnum,rnum;\n    bool operator<(const node &nn)\n    {\n        return posl<nn.posl;\n    }\n};\nint k,n;\nll cal(vector<node> &tmp)\n{\n    ll sum=0,res=0;\n    for(int i=k-1,j=0;i<tmp.size();i++,j++)\n    {\n        sum+=tmp[j].lnum;\n        res+=sum*tmp[i].rnum;\n    }\n    return res;\n}\nint allx[MAXNUM],xsize,num[MAXNUM];\nvector<node> pos[MAXNUM];\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    rep(i,1,n+1)scanf(\"%d\",&num[i]),allx[++xsize]=num[i];\n    sort(allx+1,allx+xsize+1);\n    xsize=unique(allx+1,allx+xsize+1)-allx-1;\n    rep(i,1,n+1)pos[lower_bound(allx+1,allx+xsize+1,num[i])-allx].push_back({i,i,1,1});\n    int nowx=1,nownum=allx[1];\n    vector<node> vnow,vx;\n    ll res=0;\n    while(1)\n    {\n        if(nowx>xsize&&vnow.empty())break;\n        if(vnow.empty())nownum=allx[nowx];\n        if(nowx<=xsize&&nownum==allx[nowx])\n        {\n            vx.clear();vx.resize(vnow.size()+pos[nowx].size());\n            merge(vnow.begin(),vnow.end(),pos[nowx].begin(),pos[nowx].end(),vx.begin());\n            nowx++;\n        }\n        else vx=vnow;\n        vnow.clear();\n        vector<node> vv,vv2;\n        rep(i,0,vx.size())\n        {\n            vv.push_back(vx[i]);\n            if(i==vx.size()-1||vx[i].posr!=vx[i+1].posl-1)\n            {\n                vv2.clear();\n                res+=cal(vv);\n                int kk=vv.size()/k;\n                vv2.resize(kk,{n+2,-1,0,0});int minpos=n+2,maxpos=-1;\n                rep(i,0,vv.size())\n                {\n                    int rpos=(i+1)/k,lpos=kk-(vv.size()-i)/k;\n                    if(rpos)vv2[rpos-1].rnum+=vv[i].rnum;\n                    if(lpos!=kk)vv2[lpos].lnum+=vv[i].lnum;\n                    minpos=min(minpos,vv[i].posl),maxpos=max(maxpos,vv[i].posr);\n                }\n                rep(i,0,kk)vv2[i].posl=vv2[i].posr=minpos+i;\n                if(kk)vv2[kk-1].posr=maxpos;\n                res-=cal(vv2);\n                for(node &nn:vv2)vnow.push_back(nn);\n                vv.clear();\n            }\n        }\n        nownum++;\n    }\n    printf(\"%lld\\n\",res+n);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, L;\nvector<int> v;\n\nstruct Elem {\n\tint value = 0;\n\tint l = 0, r = 0;\n\tint order;\n\n\tfriend bool operator<(Elem a, Elem b) {\n\t\treturn a.order < b.order;\n\t}\n};\n\nint calc_cost(vector<Elem> v) { \n\tint r = 0;\n\tint s = 0;\n\tfor (int i = L - 1; i < len(v); i++)\n\t\ts += v[i].r;\n\tfor (int i = 0; i < len(v); i++) {\n\t\tr += v[i].l * (v[i].r + s);\n\t\tif (i + L - 1 < len(v))\n\t\t\ts -= v[i + L - 1].r;\n\t}\n\treturn r;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, L;\n\tv.resize(n);\n\tscan v;\n\tset<Elem> s;\n\tset<pair<int, Elem>> _min;\n\tfor (int i = 0; i < n; i++) {\n\t\ts.insert({v[i], 1, 1, i});\n\t\t_min.emplace(v[i], Elem{v[i], 1, 1, i});\n\t}\n\tll rez = 0;\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tvector<Elem> t;\n\t\tvector<Elem> buf;\n\t\tif (_min.empty()) break;\n\t\tint cur = _min.begin()->x;\n\t\tfor (auto e : _min) {\n\t\t\tif (cur != e.x) break;\n\t\t\tt.pb(e.y);\n\t\t}\n\t\tsort(t.begin(), t.end());\n\t\tt.pb({(int)-1e9, -1, -1});\n\t\tfor (auto e : t) {\n\t\t\tif (s.find(e) != s.end() && s.find(e) != s.begin() && (buf.empty() || (--s.find(e)) == s.find(buf.back()))) {\n\t\t\t\tbuf.pb(e);\n\t\t\t} else {\n\t\t\t\tvector<Elem> _new(len(buf) / L, {cur + 1, 0, 0, -1});\n\t\t\t\tfor (int i = 0; i < len(_new); i++)\n\t\t\t\t\t_new[i].order = buf[i].order;\n\t\t\t\tif (len(buf) < L) {\n\t\t\t\t\t_new = buf;\n\t\t\t\t\tfor (int i = 0; i < len(buf); i++) {\n\t\t\t\t\t\trez += buf[i].l * buf[i].r;\n\t\t\t\t\t\tif (buf[i].value != -1)\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t// buf[i].l = buf[i].r = 0;\n\t\t\t\t\t\t// buf[i].value = -1;\n\t\t\t\t\t\t_new[i].l = _new[i].r = 0;\n\t\t\t\t\t\t_new[i].value = -1;\n\t\t\t\t\t}\n\t\t\t\t\t// _new = buf;\n\t\t\t\t} else {\n\t\t\t\t\tchange = true;\n\t\t\t\t\trez += calc_cost(buf);\t\n\t\t\t\t\tint k = len(buf) % L + 1;\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].l += buf[j].l;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].l += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.l;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].r += buf[j].r;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].r += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.r;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\trez -= calc_cost(_new);\n\t\t\t\t}\n\t\t\t\tfor (auto e : buf) {\n\t\t\t\t\ts.erase(e);\n\t\t\t\t\tif (e.value != -1)\n\t\t\t\t\t\t_min.erase(mp(e.value, e));\n\t\t\t\t}\n\t\t\t\tfor (auto e : _new) {\n\t\t\t\t\ts.insert(e);\n\t\t\t\t\tif (e.value != -1)\n\t\t\t\t\t\t_min.emplace(e.value, e);\n\t\t\t\t}\n\t\t\t\tbuf.clear();\n\t\t\t\tif (e.value != -1e9)\n\t\t\t\t\tbuf.pb(e);\n\t\t\t}\n\t\t}\n\t\t// for (int i = 0; i < len(s); i++) {\n\t\t// \tprint \"{\", s[i].value, s[i].l, s[i].r, \"}\";\n\t\t// \t// print s[i].value;\n\t\t// \tsmart_io::print_start = \" \";\n\t\t// }\n\t\t// smart_io::print_start = \"\\n\";\n\t\tcur++;\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*20;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxn];\nint main()\n{\n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<20;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue;\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int i=1;i<=k;++i)\n\t\t\t{\n\t\t\t\ttmp[i].l=tmp[i].r=tmp[i-1].l+1;\n\t\t\t\ttmp[i].L=tmp[i].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\twhile(k) rec[i+1].push_back(tmp[k--]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint L;\n\nvector<int> a;\n\nstruct I {\n\tint amax;\n\tunordered_map<int,int> pref, suff;\n\tbool tot_okay;\n\tint tot_num;\n\tI() {\n\t\tamax = 0;\n\t\tpref[0] = 1; suff[0] = 1;\n\t\ttot_okay = true;\n\t\ttot_num = 0;\n\t}\n};\n\nvoid level_up(I& v, int a){\n\tassert(a >= v.amax);\n\twhile(v.amax < a){\n\t\tv.amax += 1;\n\t\tbool did_something = false;\n\t\tunordered_map<int,int> newpref, newsuff;\n\t\tfor(auto q : v.pref){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewpref[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewpref[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tfor(auto q : v.suff){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewsuff[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewsuff[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tv.pref = newpref;\n\t\tv.suff = newsuff;\n\t\tif(v.tot_okay){\n\t\t\tif(v.tot_num == 0){\n\t\t\t} else if(v.tot_num < L){\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_okay = false;\n\t\t\t\tv.tot_num = 0;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_num /= L;\n\t\t\t}\n\t\t}\n\t\tif(!did_something) break;\n\t}\n\tv.amax = a;\n}\n\nlong long ans = 0;\n\nvector<int> arr(const unordered_map<int, int> f){\n\tvector<int> a(f.size(), -1);\n\tfor(pair<int,int> x : f){\n\t\ta[x.first] = x.second;\n\t}\n\treturn a;\n}\n\nI combine(I& l, int a, I& r){\n\tlevel_up(l, a);\n\tlevel_up(r, a);\n\tassert(a == l.amax);\n\tassert(a == r.amax);\n\tI res;\n\tres.amax = a;\n\tres.pref = res.suff = {};\n\tif(l.tot_okay && r.tot_okay){\n\t\tres.tot_okay = true;\n\t\tres.tot_num = l.tot_num + 1 + r.tot_num;\n\t} else {\n\t\tres.tot_okay = false;\n\t\tres.tot_num = 0;\n\t}\n\tres.pref = move(l.pref);\n\tif(l.tot_okay){\n\t\tfor(auto q : r.pref){\n\t\t\tres.pref[q.first + l.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tres.suff = move(r.suff);\n\tif(r.tot_okay){\n\t\tfor(auto q : l.suff){\n\t\t\tres.suff[q.first + r.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tvector<int> la = arr(l.suff);\n\tvector<int> ra = arr(r.pref);\n\tlong long cur = 0;\n\tcur += 1;\n\tlong long tot = 0;\n\tint j = (int)ra.size();\n\tfor(int i = 0; i < (int)la.size(); i++){\n\t\twhile(j > 0 && (j-1) + 1 + i >= L){\n\t\t\tj -= 1;\n\t\t\ttot += ra[j];\n\t\t}\n\t\tcur += la[i] * tot;\n\t}\n\tans += cur;\n\treturn res;\n}\n\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n >> L;\n\ta.resize(n);\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\n\tvector<int> b(n+2);\n\tvector<int> f(n+2);\n\tfor(int i = 0; i <= n+1; i++){\n\t\tb[i] = i-1;\n\t\tf[i] = i+1;\n\t}\n\tvector<I> data(n+2);\n\tvector<pair<ll, int> > apos;\n\tfor(int i = 0; i < n; i++){\n\t\tapos.push_back({a[i] * (1e9) + rand(), i+1});\n\t}\n\tsort(apos.begin(), apos.end());\n\tfor(auto _x : apos){\n\t\tint x = _x.second;\n\t\tf[b[x]] = f[x];\n\t\tb[f[x]] = b[x];\n\t\tdata[b[x]] = combine(data[b[x]], a[x-1], data[x]);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 2e5+10;\nint n,m,a[N];\nll L[N],R[N],newL[N],newR[N];\n\nint pre[N],nxt[N];\ninline void Del(int x){\n\tpre[nxt[x]]=pre[x],nxt[pre[x]]=nxt[x];\n}\n\nint main(){\n\tn=read(),m=read();\n\tFor(i,1,n) a[i]=read();\n\tset<pa>s;\n\tFor(i,1,n) s.insert(mp(a[i],i)),pre[i]=i-1,nxt[i]=i+1,L[i]=R[i]=1;\n\tll ans=n;\n\twhile (!s.empty()){\n\t\t//for (int i=1;i!=n+1;i=nxt[i]) printf(\"%d %d\\n\",i,a[i]);puts(\"\");\n\t\tint u=(*s.begin()).se;s.erase(s.begin());\n\t\tint l=u,r=u;\n\t\twhile (a[pre[l]]==a[l]) l=pre[l];\n\t\twhile (a[nxt[r]]==a[r]) r=nxt[r];\n\t\tpoly v;\n\t\tfor (int i=l;i!=r;i=nxt[i]) v.pb(i); \n\t\tv.pb(r);\n\t\tif (siz(v)<m){\n\t\t\tfor (auto i:v) s.erase(mp(a[i],i)),Del(i);\n\t\t\tcontinue;\n\t\t}\n\t\tll S=0;\n\t\tFOR(i,m-1,siz(v)) S+=L[v[i-m+1]],ans+=S*R[v[i]];\n\t\tl=m-1,r=l+m-1;\n\t\tint cnt=siz(v)/m;\n\t\tFor(i,1,cnt){\n\t\t\tnewR[i]=0;\n\t\t\tFor(j,l,min(r,siz(v)-1)) newR[i]+=R[v[j]];\n\t\t\tl+=m,r+=m; \n\t\t}\n\t\tr=siz(v)-m,l=r-m+1;\n\t\tDow(i,cnt,1){\n\t\t\tnewL[i]=0;\n\t\t\tFor(j,max(l,0),r) newL[i]+=L[v[j]];\n\t\t\tl-=m,r-=m;\n\t\t}\n\t\tfor (auto i:v) s.erase(mp(a[i],i));\n\t\tFOR(i,0,cnt){\n\t\t\ta[v[i]]++,L[v[i]]=newL[i+1],R[v[i]]=newR[i+1];\n\t\t\ts.insert(mp(a[v[i]],v[i]));\n\t\t}\n\t\tFOR(i,cnt,siz(v)) Del(v[i]);\n\t\tS=0;\n\t\tFOR(i,m-1,cnt) S+=L[v[i-m+1]],ans-=S*R[v[i]];\n\t\ts.insert(mp(a[v[0]],v[0]));\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 200000\n#define MX 4000000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nstruct Data\n{\n    int l,r,x;\n    vector<int> sl,sr;\n};\nvector<Data> s[MX+5];\nint n,K,a[MN+5],c[MX+5],num,f[MN+5];\nlong long ans;\nbool cmp(const Data&x,const Data&y){return x.l<y.l;}\nint main()\n{\n    ans=n=read();K=read();\n    for(int i=1;i<=n;++i)\n    {\n        a[i]=read();\n        for(int t=n,j=0;t;t/=K,++j) c[++num]=a[i]+j;\n    }\n    sort(c+1,c+num+1);\n    num=unique(c+1,c+num+1)-c-1;\n    for(int i=1,j;i<=n;i=j+1)\n    {\n        int v=lower_bound(c+1,c+num+1,a[i])-c;\n        for(j=i;j<n&&a[j+1]==a[j];++j);\n        Data nx;nx.x=1;\n        nx.sl.push_back(0);\n        nx.sr.push_back(0);\n        for(int k=i;k<=j;++k) \n        {\n            nx.l=nx.r=k;\n            nx.sl[0]=nx.sr[0]=k;\n            s[v].push_back(nx);\n        }\n    }\n    for(int k=1;k<=num;++k) if(s[k].size())\n    {\n        sort(s[k].begin(),s[k].end(),cmp);\n        int N=s[k].size();\n   /*   cout<<\"BeginSolve\"<<c[k]<<endl;\n        for(int i=0;i<s[k].size();++i)\n        {\n            cout<<\"----\"<<endl;\n            printf(\"%d %d %d\\n\",s[k][i].l,s[k][i].r,s[k][i].x);\n            for(int j=0;j<s[k][i].x;++j) printf(\"** %d **\\n\",s[k][i].sl[j]);\n            cout<<\" --- \"<<endl;\n            for(int j=0;j<s[k][i].x;++j) printf(\"** %d **\\n\",s[k][i].sr[j]);\n            cout<<\"---\"<<endl;\n        }*/\n        for(int i=0,j;i<N;i=j+1)\n        {\n            int tot=s[k][i].x,cnt=0,last=0;\n            for(j=i;j+1<N&&s[k][j+1].l==s[k][j].r+1;) ++j,tot+=s[k][j].x;\n            if(tot<K) continue;\n            for(int l=i;l<=j;++l) for(int g=s[k][l].x-1;~g;--g)\n                ++cnt,f[cnt]=f[cnt-1]+s[k][l].sr[g]-(g+1<s[k][l].x?s[k][l].sr[g+1]:(l==i?s[k][l].l-1:s[k][l-1].sr[0]));//cout<<cnt<<\"  =  \"<<s[k][l].sr[g]<<\" \"<<f[cnt]<<endl;\n            cnt=0;\n            for(int l=i;l<=j;++l) for(int g=0;g<s[k][l].x;++g)\n            {\n                ++cnt;if(s[k][l].l==s[k][l].r) last=cnt;\n               // cout<<\"Checkans\"<<(s[k][l].sl[g]-(g?s[k][l].sl[g-1]:(s[k][l].l-1)))<<\" \"<<f[min(last,cnt-K+1)]<<endl;\n                if(cnt>=K) ans+=1LL*((g+1<s[k][l].x?s[k][l].sl[g+1]:(s[k][l].r+1))-s[k][l].sl[g])*f[min(last,cnt-K+1)];\n            }\n            Data nx;nx.l=s[k][i].l,nx.r=s[k][j].r;nx.x=tot/K;\n            cnt=0;\n            for(int l=i;l<=j;++l) for(int g=0;g<s[k][l].x;++g)\n            {\n                ++cnt;\n                if(cnt%K==0) nx.sl.push_back(s[k][l].sl[g]);\n            }\n            cnt=0;\n            for(int l=j;l>=i;--l) for(int g=0;g<s[k][l].x;++g)\n            {\n                ++cnt;\n                if(cnt%K==0) nx.sr.push_back(s[k][l].sr[g]);\n            }\n            s[k+1].push_back(nx);\n        }\n      //  cout<<k<<\" \"<<c[k]<<\" finish \"<<ans<<\" \"<<endl;\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, L;\nvector<int> v;\n\nstruct Elem {\n\tint value;\n\tint l, r;\n};\n\nint calc_cost(vector<Elem> v) { \n\tint r = 0;\n\tfor (int i = 0; i < len(v); i++) {\n\t\tr += v[i].l * v[i].r;\n\t\tfor (int j = i + L - 1; j < len(v); j++) {\n\t\t\tr += v[i].l * v[j].r;\n\t\t}\n\t}\n\treturn r;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, L;\n\tv.resize(n);\n\tscan v;\n\tvector<Elem> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.pb({v[i], 1, 1});\n\tll rez = 0;\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tvector<Elem> t;\n\t\tvector<Elem> buf;\n\t\tint cur = 2e9;\n\t\tfor (int i = 0; i < len(s); i++)\n\t\t\tif (s[i].value != -1) {\n\t\t\t\tcur = min(cur, s[i].value);\n\t\t\t}\n\t\ts.pb({(int)-1e9, -1, -1});\n\t\tfor (int i = 0; i < len(s); i++) {\n\t\t\tif (s[i].value == cur) {\n\t\t\t\tbuf.pb(s[i]);\t\n\t\t\t} else {\n\t\t\t\tvector<Elem> _new(len(buf) / L, {cur + 1, 0, 0});\n\t\t\t\tif (len(buf) < L) {\n\t\t\t\t\tfor (int i = 0; i < len(buf); i++) {\n\t\t\t\t\t\trez += buf[i].l * buf[i].r;\n\t\t\t\t\t\tif (buf[i].value != -1)\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\tbuf[i].l = buf[i].r = 0;\n\t\t\t\t\t\tbuf[i].value = -1;\n\t\t\t\t\t}\n\t\t\t\t\t_new = buf;\n\t\t\t\t} else {\n\t\t\t\t\tchange = true;\n\t\t\t\t\trez += calc_cost(buf);\t\n\t\t\t\t\tint k = len(buf) % L + 1;\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].l += s[j].l;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].l += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.l;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\t\t_new[0].r += s[j].r;\n\t\t\t\t\tfor (int j = 1; j < len(_new); j++)\n\t\t\t\t\t\t_new[j].r += accumulate(buf.begin() + k + (j - 1) * L, buf.begin() + k + j * L, 0, [](int value, Elem e) {\n\t\t\t\t\t\t\treturn value + e.r;\n\t\t\t\t\t\t});\n\t\t\t\t\treverse(_new.begin(), _new.end());\n\t\t\t\t\treverse(buf.begin(), buf.end());\n\t\t\t\t\trez -= calc_cost(_new);\n\t\t\t\t}\n\t\t\t\tt.insert(t.end(), _new.begin(), _new.end());\n\t\t\t\tif (s[i].value != -1e9)\n\t\t\t\t\tt.pb(s[i]);\n\t\t\t\tbuf.clear();\n\t\t\t}\n\t\t}\n\t\tswap(t, s);\n\t\t// for (int i = 0; i < len(s); i++) {\n\t\t// \tprint \"{\", s[i].value, s[i].l, s[i].r, \"}\";\n\t\t// \tsmart_io::print_start = \" \";\n\t\t// }\n\t\t// smart_io::print_start = \"\\n\";\n\t\tcur++;\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=5e3+20;\n\nint n,k;\nchar str[maxn];\nchar mn;\nint len;\n\ninline string solve(int l,int r)\n{\n\tstring s;\n\tint len=r-l+1;\n\tREP(i,1,len<<k-1)s+=mn;\n\tREP(i,r+1,n)if(SZ(s)<n)s+=str[i];\n\tDREP(i,n,1)if(SZ(s)<n)s+=str[i];\n\treturn s;\n}\n\ninline string solve1(int l,int r)\n{\n\tstring s;\n\tint len=r-l+1;\n\tREP(i,1,len<<k)s+=mn;\n\tDREP(i,l-1,1)if(SZ(s)<n)s+=str[i];\n\treturn s;\n}\n\ninline void init()\n{\n\tn=read();k=read();\n\tscanf(\"%s\",str+1);\n\tmn='z'+1; REP(i,1,n)chkmin(mn,str[i]);\n\tif(k>20){ REP(i,1,n)putchar(mn);exit(0);}\n\tint slen=0,lstlen=0;\n\tREP(i,1,n)\n\t{\n\t\tif(i==n || str[i]!=mn)\n\t\t{\n\t\t \tchkmax(len,slen);\n\t\t \tslen=0;\n\t\t}else slen++;\n\t}\n\twhile(lstlen<n && str[n-lstlen]==mn)++lstlen;\n\tif(slen<<k-1 >= n) { REP(i,1,n)putchar(mn);exit(0); }\n\tif(lstlen<<k >= n) { REP(i,1,n)putchar(mn);exit(0); }\n\tstring s;\n\n\tslen=0;\n\tREP(i,1,n)\n\t{\n\t\tif(i==n || str[i]!=mn)\n\t\t{\n\t\t \t//chkmax(len,slen);\n\t\t\tif(slen==len)\n\t\t\t{\n\t\t \t \tstring up=solve(i-len,i-1);\n\t\t\t \tif(s.empty() || s>up)s=up;\n\t\t\t}\n\t\t\tslen=0;\n\t\t}else slen++;\n\t}\n\tif(lstlen>0)\n\t{\n\t\tstring up=solve1(n-lstlen+1,n);\n\t\tif(s.empty() || s>up)s=up;\n\t}\n\tcout<<s<<endl;\n}\n\ninline void doing()\n{\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int LOG = 18;\nconst int NN = 200200;\npii sparse[LOG][NN];\nint p2[NN];\nint n;\nll ans = 0;\n\npii getMax(int l, int r) {\n\tint k = p2[r - l];\n\treturn max(sparse[k][l], sparse[k][r - (1 << k)]);\n}\n\nint L;\n\nstruct Item {\n\tint K;\n\tvector<int> toL, toR;\n\tbool full;\n\n\tItem() : K(0), toL(), toR(), full(false) {}\n\n\tItem toUpper() {\n\t\tItem I = Item();\n\t\tI.K = K + 1;\n\t\tI.full = full;\n\t\tfor (int i = 0; i < (int)toL.size(); i++) {\n\t\t\tif ((i + 1) % L == 0)\n\t\t\t\tI.toL.push_back(0);\n\t\t\tif (!I.toL.empty())\n\t\t\t\tI.toL.back() += toL[i];\n\t\t}\n\t\tfor (int i = 0; i < (int)toR.size(); i++) {\n\t\t\tif ((i + 1) % L == 0)\n\t\t\t\tI.toR.push_back(0);\n\t\t\tif (!I.toR.empty())\n\t\t\t\tI.toR.back() += toR[i];\n\t\t}\n\t\tif (I.toL.empty() || I.toR.empty()) I.full = false;\n\t\treturn I;\n\t}\n\n\tvoid eprint() {\n\t\treturn;\n\t\teprintf(\"Item\\n\");\n\t\teprintf(\"K = %d\\n\", K);\n\t\tfor (int x : toL)\n\t\t\teprintf(\"%d \", x);\n\t\teprintf(\"\\n\");\n\t\tfor (int x : toR)\n\t\t\teprintf(\"%d \", x);\n\t\teprintf(\"\\n\");\n\t\teprintf(\"full = %d\\n\", (int)full);\n\t\teprintf(\"--------\\n\");\n\t}\n};\nstruct Fenv {\n\tint n;\n\tvector<ll> fenv;\n\n\tFenv() : n(), fenv() {}\n\tFenv(int _n) {\n\t\tn = _n;\n\t\tfenv = vector<ll>(n, 0);\n\t}\n\n\tvoid add(int p, ll x) {\n\t\tfor(; p < n; p |= p + 1)\n\t\t\tfenv[p] += x;\n\t}\n\tll get(int r) {\n\t\tll res = 0;\n\t\tfor(; r >= 0; r = (r & (r + 1)) - 1)\n\t\t\tres += fenv[r];\n\t\treturn res;\n\t}\n\tll getSum(int l, int r) {\n\t\treturn get(r - 1) - get(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfenv[i] = 0;\n\t}\n};\n\nItem solve(int l, int r) {\n\teprintf(\"solve %d %d\\n\", l, r);\n\tint m = getMax(l, r).first;\n\tvector<Item> items;\n\twhile(l < r) {\n\t\tpii t = getMax(l, r);\n\t\tif (t.first != m) {\n\t\t\tItem I = solve(l, r);\n\t\t\twhile(I.K < m && (!I.toL.empty() || !I.toR.empty()))\n\t\t\t\tI = I.toUpper();\n\t\t\tif (I.K != m) I.K = m;\n\t\t\titems.push_back(I);\n\t\t\tbreak;\n\t\t}\n\t\tif (t.second + 1 != r) {\n\t\t\tItem I = solve(t.second + 1, r);\n\t\t\teprintf(\"HERE 1\\n\");\n\t\t\twhile(I.K < m && (!I.toL.empty() || !I.toR.empty()))\n\t\t\t\tI = I.toUpper();\n\t\t\teprintf(\"HERE 2\\n\");\n\t\t\tif (I.K != m) I.K = m;\n\t\t\titems.push_back(I);\t\n\t\t}\n\t\tItem I = Item();\n\t\tI.K = m;\n\t\tI.toL.push_back(1);\n\t\tI.toR.push_back(1);\n\t\tI.full = true;\n\t\titems.push_back(I);\n\t\tr = t.second;\n\t}\n\treverse(items.begin(), items.end());\n\tfor (Item I : items)\n\t\tI.eprint();\n\tint tot = 0;\n\tfor (Item I : items)\n\t\ttot += max((int)I.toL.size(), (int)I.toR.size());\n\tFenv F = Fenv(tot + 2);\n\ttot = 0;\n\tfor (Item I : items) {\n\t\tfor (int i = 0; i < (int)I.toL.size(); i++) {\n\t\t\tans += F.getSum(0, tot + i + 2 - L) * I.toL[i];\n\t\t}\n\t\tif (!I.full) {\n\t\t\ttot = 0;\n\t\t\tF.clear(); // slow\n\t\t}\n\t\ttot += (int)I.toR.size();\n\t\tfor (int i = 0; i < (int)I.toR.size(); i++) {\n\t\t\tF.add(tot - i - 1, I.toR[i]);\n\t\t}\n\t}\n\teprintf(\"ans = %lld\\n\", ans);\n\tItem N = Item();\n\tN.K = m;\n\tN.full = true;\n\tfor (Item I : items) {\n\t\tfor (int x : I.toL)\n\t\t\tN.toL.push_back(x);\n\t\tif (!I.full) {\n\t\t\tN.full = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treverse(items.begin(), items.end());\n\tfor (Item I : items) {\n\t\tfor (int x : I.toR)\n\t\t\tN.toR.push_back(x);\n\t\tif (!I.full) {\n\t\t\tN.full = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\teprintf(\"at the end\\n\");\n\treturn N;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tfor (int i = 2; i < NN; i++)\n\t\tp2[i] = p2[i / 2] + 1;\n\n\tscanf(\"%d%d\", &n, &L);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &sparse[0][i].first);\n\t\tsparse[0][i].second = i;\n\t}\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int i = 0; i + (1 << (k + 1)) <= n; i++)\n\t\t\tsparse[k + 1][i] = max(sparse[k][i], sparse[k][i + (1 << k)]);\n\tans = n;\n\tsolve(0, n);\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-11;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tinline long long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nint p[210000];\nset<pair<int,int> > S;\nset<pair<int,int> > T;\nint L[210000];\nint R[210000];\nint C[210000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tL[i]=R[i]=1;\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tS.insert(make_pair(i,p[i]));\n\t\tT.insert(make_pair(p[i],i));\n\t}\n\tlong long ret=0;\n\twhile(1){\n\t\tpair<int,int> d=*(T.begin());\n\t\tif(d.first>=mod)break;\n\t\tvector<int>v;\n\t\tset<pair<int,int> >::iterator it=S.lower_bound(make_pair(d.second,d.first));\n\t\twhile(it!=S.end()&&it->second==d.first){\n\t\t\tv.push_back(it->first);\n\t\t\tit++;\n\t\t}\n\t\tint cur=0;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tret+=(long long)L[v[i]]*R[v[i]];\n\t\t\tif(i-b+1>=0){\n\t\t\t\tcur+=L[v[i-b+1]];\n\t\t\t}\n\t\t\tret+=(long long)cur*R[v[i]];\n\t\t}\n\t\tvector<pair<pair<int,int>,pair<int,int> > >ad;\n\t\tif(v.size()<b){\n\t\t\tad.push_back(make_pair(make_pair(d.second,mod),make_pair(0,0)));\n\t\t}else{\n\t\t\tfor(int i=0;i<v.size()/b;i++){\n\t\t\t\tad.push_back(make_pair(make_pair(d.second+i,d.first+1),make_pair(0,0)));\n\t\t\t}\n\t\t\tint s=v.size();\n\n\t\t\tfor(int i=0;i<v.size();i++){\n\t\t\t\tint lv=L[v[i]];\n\t\t\t\tint rv=R[v[i]];\n\t\t\t\tif(v.size()/b-(v.size()-i)/b<ad.size())ad[v.size()/b-(v.size()-i)/b].second.first+=lv;\n\t\t\t\tif(i>=b-1)ad[(i-b+1)/b].second.second+=rv;\n\t\t\t}\n\t\t\tcur=0;\n\t\t\tfor(int i=0;i<ad.size();i++){\n\t\t\t\tret-=(long long)ad[i].second.first*ad[i].second.second;\n\t\t\t\tif(i-b+1>=0){\n\t\t\t\t\tcur+=ad[i-b+1].second.first;\n\t\t\t\t}\n\t\t\t\tret-=(long long)cur*ad[i].second.second;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tS.erase(make_pair(v[i],d.first));\n\t\t\tT.erase(make_pair(d.first,v[i]));\n\t\t}\n\t\tfor(int i=0;i<ad.size();i++){\n\t\t\tS.insert(ad[i].first);\n\t\t\tT.insert(make_pair(ad[i].first.second,ad[i].first.first));\n\t\t\tL[ad[i].first.first]=ad[i].second.first;\n\t\t\tR[ad[i].first.first]=ad[i].second.second;\n\t\t}\n\t\t// printf(\"%d %d: %lld\\n\",d.first,d.second,ret);\n\t\t// for(set<pair<int,int> >::iterator it=S.begin();it!=S.end();it++){\n\t\t\t// printf(\"%d %d %d %d\\n\",it->first,it->second,L[it->first],R[it->first]);\n\t\t// }\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=200000;\n\nint n,m,a[N+9];\n\nvoid into(){\n  scanf(\"%d%d\",&n,&m);\n  for (int i=1;i<=n;++i)\n\tscanf(\"%d\",&a[i]);\n}\n\nint sta[N+9],cst;\nint pre[N+9],suf[N+9],spre[N+9],ssuf[N+9];\nLL ans;\n\nvoid Get_ans0(){\n  int now=sta[cst],cnt=0;\n  for (;cst&&sta[cst]==now;--cst) ++cnt;\n  if (cnt<m){\n\tfor (;cst;) Get_ans0();\n\treturn;\n  }\n  int c=cnt/m;\n  for (int i=1;i<=cnt;++i) spre[i]=spre[i-1]+pre[i+cst],ssuf[i]=ssuf[i-1]+suf[i+cst];\n  for (int i=m;i<=cnt;++i) ans+=(LL)spre[i-m+1]*suf[i+cst];\n  for (int i=1;i<=c;++i){\n\tpre[i+cst]=spre[cnt-m*(c-i+1)+1]-spre[max(cnt-m*(c-i+2)+1,0)];\n\tsuf[i+cst]=ssuf[min(m*(i+1)-1,cnt)]-ssuf[m*i-1];\n  }\n  for (int i=m,s=0;i<=c;++i) ans-=(LL)(s+=pre[cst+i-m+1])*suf[i+cst];\n  for (int i=1;i<=c;++i) sta[++cst]=now+1;\n}\n\nvoid Get_ans(){\n  for (int i=1;i<=n;++i){\n\tfor (;cst&&sta[cst]<a[i];) Get_ans0();\n\tsta[++cst]=a[i];\n\tpre[cst]=suf[cst]=1;\n  }\n  for (;cst;) Get_ans0();\n}\n\nvoid work(){\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%lld\\n\",ans+n);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define pii pair<int,int>\n#define riterator reverse_iterator\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 2e5;\npriority_queue<pii,vector<pii>,greater<pii> > que;\nint nxt[N+3],prv[N+3];\nint a[N+3];\nllong cl[N+3],cr[N+3],cl2[N+3],cr2[N+3];\nvector<int> vec;\nint n,m; llong ans;\n\nvoid solve(int l,int r)\n{\n//\tprintf(\"solve %d %d\\n\",l,r);\n\tllong sum = 0ll;\n\tfor(int i=m-1; i<vec.size(); i++)\n\t{\n\t\tsum += cl[vec[i-m+1]];\n\t\tans += cr[vec[i]]*sum;\n\t}\n\tint cnt = vec.size()/m;\n\tfor(int i=l; i<=l+cnt-1; i++) cl2[i] = cr2[i] = 0ll;\n\tfor(int i=vec.size()-m,j=0,k=l+cnt-1; i>=0; i--)\n\t{\n\t\tcl2[k] += cl[vec[i]];\n\t\tif(j==m-1) {k--,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=m-1,j=0,k=l; i<vec.size(); i++)\n\t{\n\t\tcr2[k] += cr[vec[i]];\n\t\tif(j==m-1) {k++,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=l; i<=l+cnt-1; i++) cl[i] = cl2[i],cr[i] = cr2[i];\n\tsum = 0ll;\n\tfor(int i=l+m-1; i<=l+cnt-1; i++)\n\t{\n\t\tsum += cl[i-m+1];\n\t\tans -= cr[i]*sum;\n\t}\n\tif(cnt==0)\n\t{\n\t\tnxt[prv[l]] = nxt[r]; prv[nxt[r]] = prv[l];\n\t}\n\telse\n\t{\n\t\tnxt[l+cnt-1] = nxt[r]; prv[nxt[r]] = l+cnt-1;\n\t\tfor(int i=l; i<l+cnt-1; i++) nxt[i] = i+1;\n\t\tfor(int i=l+1; i<=l+cnt-1; i++) prv[i] = i-1;\n\t\tint val = a[l]; for(int i=l; i<=l+cnt-1; i++) a[i] = val+1;\n\t}\n\tfor(int i=l; i<=l+cnt-1; i++) que.push(mkpr(a[i],i));\n//\tprintf(\"cnt=%d\\n\",cnt);\n//\tprintf(\"prv: \"); for(int i=1; i<=n; i++) printf(\"[%d]%d \",i,prv[i]); puts(\"\");\n//\tprintf(\"nxt: \"); for(int i=1; i<=n; i++) printf(\"[%d]%d \",i,nxt[i]); puts(\"\");\n//\tprintf(\"cl: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cl[i]); puts(\"\");\n//\tprintf(\"cr: \"); for(int i=1; i<=n; i++) printf(\"[%d]%lld \",i,cr[i]); puts(\"\");\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&a[i]),que.push(mkpr(a[i],i)),cl[i] = cr[i] = 1ll,nxt[i] = i+1,prv[i] = i-1;\n\twhile(1)\n\t{\n\t\tint l = que.top().second,r = l; que.pop(); vec.clear(); vec.push_back(l);\n\t\twhile(!que.empty() && que.top().first==a[l] && que.top().second==nxt[r]) {r = nxt[r]; vec.push_back(r); que.pop();}\n\t\tsolve(l,r);\n\t\tif(prv[l]==0&&nxt[r]==n+1) break;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}\n/*\n23 3\n3 2 2 2 3 4 8 2 2 2 2 2 2 2 8 9 7 3 1 1 1 1 4\n*/"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[200005],cur,is[200005],pw[200005],fa[200005];\nint *pre[200005],*suf[200005],cnt[200005],nwa[200005];\nll ans;\nint dp[400005],*f=dp+400000;\nint w[25000005],*at=w;\npii b[200005];\nint *newI(int n){\n\tat+=n;\n\treturn at-n;\n}\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nint nex[200005],stk[200005],tp,ist[200005];\nvoid add(int x,int y){\n//\twrite(x,'-',y,'\\n');\n\tist[y]=-1;if(!ist[x])ist[x]=1;\t\n\tstk[++tp]=x;\n\tnex[x]=y;\n}\nvoid put(int x){\n\tis[x]=1;\n\tnwa[x]=a[x];\n\tcnt[x]=1;\n\tpre[x]=newI(1);pre[x][0]=1;suf[x]=newI(1);suf[x][0]=1;\n\tfa[x]=x;\n\tif(is[x-1]){add(find(x-1),x);}\n\tif(is[x+1]){add(x,find(x+1));}\n}\nint id[200005],m,n,l;\nvoid solve(){\n\tint cc=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(nwa[id[i]]!=cur){\n\t\t\tint S=pw[min(cur-nwa[id[i]],n)];\n//\t\t\twrite(id[i],' ',cnt[id[i]],' ',nwa[id[i]],' ',S,'\\n');\n\t\t\tint *p=pre[id[i]],*s=suf[id[i]];\n\t\t\tfor(int j=1;j<=cnt[id[i]];++j){\n\t\t\t\tint w=p[j-1];\n\t\t\t\tp[j-1]=0;\n\t\t\t\tif(j>=S)p[j/S-1]+=w;\n\t\t\t\tw=s[j-1];\n\t\t\t\ts[j-1]=0;\n\t\t\t\tif(j>=S)s[j/S-1]+=w;\n\t\t\t}\n\t\t\tcnt[id[i]]/=S;\n\t\t}\n\t\tcc+=cnt[id[i]];\n\t}\t\n\n/*\twrite(m,'\\n');\n\tfor(int i=1;i<=m;++i){\n\t\twrite(cnt[id[i]],':');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('|');\n\t\tfor(int j=0;j<cnt[id[i]];++j)write(pre[id[i]][j],' ');\n\t\twrite('\\n');\n\t}*/\n\tint *np=newI(cc),*ns=newI(cc);\n\tint t=0;\n\tfor(int i=1;i<=m;++i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tnp[t]=pre[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tt=0;\n\tfor(int i=m;i;--i){\n\t\tfor (int j=0;j<cnt[id[i]];++j){\n\t\t\tns[t]=suf[id[i]][j];\n\t\t\t++t;\n\t\t}\n\t}\n\tfor(int i=m;i;--i){\n\t\tfor(int j=1;j<=cnt[id[i]];++j)ans+=suf[id[i]][j-1]*f[max(1,l-j)];\n\t\tfor(int j=cnt[id[i]];j;--j){f[0]=f[1]+pre[id[i]][j-1];--f;}\n\t}\n\tfor(int i=1;i<=cc;++i)*(++f)=0;\n\t/*write(ans,'\\n');\n\twrite(cc,'|',id[1],'\\n');*/\n\tcnt[id[1]]=cc;\n\tpre[id[1]]=np;\n\tsuf[id[1]]=ns;\n}\nvoid work(){\n\tfor(;tp;--tp){\n\t\tif(ist[stk[tp]]<=0){ist[stk[tp]]=0;continue;}\n\t\tist[stk[tp]]=0;\n\t\tint at=stk[tp];\n\t\tm=0;\n\t\twhile(at){\n//\t\t\twrite(at,'(');\n\t\t\tid[++m]=at;\n\t\t\tfa[at]=stk[tp];\n\t\t\tint nx=nex[at];\n\t\t\tnex[at]=0;\n\t\t\tat=nx;\n\t\t}\n\t\tsolve();\n\t}\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tread(n,l);\n\tpw[0]=1;\n\tint iee=n/l+1;\n\tfor(int i=1;i<=n;++i)pw[i]=min(pw[i-1],iee)*l;\n\tfor(int i=1;i<=n;++i){read(a[i]);b[i]=make_pair(a[i],i);}\n\tsort(b+1,b+n+1);\n\tfor(int i=1,j=1;i<=n;i=j){\n\t\tcur=b[i].x;\n\t\twhile(b[i].x==b[j].x){put(b[j].y);++j;}\n\t\twork();\n\t}\n\twrite(ans+n,'\\n');\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*25;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxp];\nint main()\n{\n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<25;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue; assert(H[i+1]==H[i]+1);\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int j=1;j<=k;++j)\n\t\t\t{\n\t\t\t\ttmp[j].l=tmp[j].r=tmp[j-1].l+1;\n\t\t\t\ttmp[j].L=tmp[j].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\twhile(k) rec[i+1].push_back(tmp[k--]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);template <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);template <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);string to_string(const string& s) {  return '\"' + s + '\"';}string to_string(const char* s) {  return to_string((string) s);}string to_string(bool b) {  return (b ? \"true\" : \"false\");}string to_string(vector<bool> v) {  bool first = true;  string res = \"{\";  for (int i = 0; i < static_cast<int>(v.size()); i++) {    if (!first) {      res += \", \";    }    first = false;    res += to_string(v[i]);  }  res += \"}\";  return res;}template <size_t N>string to_string(bitset<N> v) {  string res = \"\";  for (size_t i = 0; i < N; i++) {    res += static_cast<char>('0' + v[i]);  }  return res;}template <typename A>string to_string(A v) {  bool first = true;  string res = \"{\";  for (const auto &x : v) {    if (!first) {      res += \", \";    }    first = false;    res += to_string(x);  }  res += \"}\";  return res;}template <typename A, typename B>string to_string(pair<A, B> p) {  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";}template <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p) {  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {  cerr << \" \" << to_string(H);  debug_out(T...);}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define set0(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define PB push_back\n#define MP make_pair\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntemplate<typename T> void read(T &x){\n    x = 0;char ch = getchar();ll f = 1;\n    while(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n    while(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\ntemplate<typename T, typename... Args> void read(T &first, Args& ... args) {\n    read(first);\n    read(args...);\n}\n\nint n,k,cc;\nll ans = 0;\ntemplate<class T>\nstruct RMQ {\n    vector<vector<T>> jmp;\n    RMQ(const vector<T>& V) : jmp(1, V) {\n        for (int pw = 1, k = 1; pw * 2 <= sz(V); pw *= 2, ++k) {\n            jmp.emplace_back(sz(V) - pw * 2 + 1);\n            rep(j,0,sz(jmp[k]))\n            jmp[k][j] = max(jmp[k - 1][j], jmp[k - 1][j + pw]);\n        }\n    }\n    T query(int a, int b) {\n        assert(a < b); // or return inf if a == b\n        int dep = 31 - __builtin_clz(b - a);\n        return max(jmp[dep][a], jmp[dep][b - (1 << dep)]);\n    }\n};\nset<pii> S;\n#define CAT(A,B)  A.insert(A.end(),all(B))\nstruct ret{\n    vll val,L,R;\n    void absorb(ret rhs){\n        CAT(val,rhs.val);\n        CAT(L,rhs.L);\n        CAT(R,rhs.R);\n    }\n};\nvector<int> A(1,0);\nRMQ<int> Q(A);\nll calc(ret &C){\n    ll cr = 0;\n    int c = 0;\n    while(c<C.val.size()){\n        int d = c,cu = 0;\n        while(d<C.val.size() && C.val[d]!=-1){\n            if(d>c+k-2)cu+=C.R[d];\n            d++;\n        }\n        for(int i=c;i<d;i++){\n            cr = cr+C.L[i]*C.R[i];\n            cr = cr+1ll*cu*C.L[i];\n            if(i+k-1<d){\n                cu-=C.R[i+k-1];\n            }\n        }\n        c = d+1;\n    }\n    return cr;\n}\nret solve(int l,int r,int ep){\n    if(l>r)return ret();\n    int p = l,cmx = Q.query(l,r+1);\n    ret C,I;I.val.PB(cmx);I.R.PB(1);I.L.PB(1);\n    while(p<=r){\n        int nxt = S.lower_bound(MP(cmx,p))->second;\n        if(nxt>r){\n            C.absorb(solve(p,r,cmx));\n            break;\n        }else{\n            C.absorb(solve(p,nxt-1,cmx));\n            C.absorb(I);\n            p = nxt+1;\n        }\n    }\n    /*\n    cout<<\"[\"<<l<<' '<<r<<' '<<cmx<<\"]\"<<endl;\n    debug(C.val);\n    debug(C.L);\n    debug(C.R);*/\n    ans+=calc(C);\n    if(ep-cmx>25 || pow(1.0*k,ep-cmx)>2*(r-l+1) || pow(k,ep-cmx)>C.val.size()){\n        I.val[0] = -1;\n        return I;\n    }\n    int req = 1;for(int i=0;i<ep-cmx;i++)req*=k;\n    int cnt = 0;\n    for(auto ct:C.val)if(ct == -1)cnt+=1;\n    ret CR;\n    if(cnt){\n        vll L,R;\n        for(int i=0;C.val[i] == cmx;i++){\n            if((i+1)/req!=0){\n                int cp = (i+1)/req-1;\n                if(R.size()<cp+1)R.PB(0);\n                R[cp]+=C.R[i];\n            }\n        }\n        for(int i=0;C.val[C.val.size()-1-i] == cmx;i++){\n            if((i+1)/req!=0){\n                int cp = (i+1)/req-1;\n                if(L.size()<cp+1)L.PB(0);\n                L[cp]+=C.L[C.L.size()-1-i];\n            }\n        }\n        for(int i=0;i<R.size();i++){\n            CR.R.PB(R[i]);\n            CR.L.PB(0);\n            CR.val.PB(ep);\n        }\n        CR.R.PB(0);\n        CR.L.PB(0);\n        CR.val.PB(-1);\n        for(int i=0;i<L.size();i++){\n            CR.R.PB(0);\n            CR.L.PB(L[L.size()-1-i]);\n            CR.val.PB(ep);\n        }\n    }else{\n        int cul = C.val.size()/req;\n        CR.val = vll(cul,ep);\n        CR.L = vll(cul,0);\n        CR.R = vll(cul,0);\n        for(int i=req;i<=C.val.size();i++){\n            CR.R[i/req-1]+=C.R[i-1];\n            CR.L[cul-i/req]+=C.L[C.val.size()-i];\n        }\n    }\n    ans-=calc(CR);\n    /*\n    cout<<\"[\"<<l<<' '<<r<<' '<<ep<<\"]\"<<endl;\n    debug(CR.val);\n    debug(CR.L);\n    debug(CR.R);*/\n    return CR;\n}\nint main() {\n    read(n,k);\n    for(int i=1;i<=n;i++){\n        read(cc);\n        A.PB(cc);\n        S.insert(MP(cc,i));\n        S.insert(MP(cc,1e9));\n    }\n    Q = RMQ<int>(A);\n    solve(1,n,1e9+1);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sz(a) int(a.size())\n#define pb push_back\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nstruct dat {\n\tint p,v,l,r;\n};\n\nint n,l;\nll ans=0;\n\nstruct cmp1 {\n\tbool operator()(const dat &A,const dat &B) {\n\t\treturn A.p<B.p;\n\t}\n};\n\nstruct cmp2 {\n\tbool operator()(const dat &A,const dat &B) {\n\t\treturn make_pair(A.v,A.p)<make_pair(B.v,B.p);\n\t}\n};\n\nset<dat,cmp1> s1;\nset<dat,cmp2> s2;\n\nll cal(const vector<dat> &v) {\n\tll ret=0,sum=0;\n\tfor(int i=0;i+l-1<sz(v);i++) sum+=v[i].l,ret+=sum*v[i+l-1].r;\n\treturn ret;\n}\n\nint main() {\n\tcin>>n>>l;\n\tfor(int i=1;i<=n;i++) {\n\t\tdat a=(dat){i,gi(),1,1};\n\t\ts1.insert(a);s2.insert(a);\n\t}\n\twhile(!s2.empty()) {\n\t\tint mn=s2.begin()->v;\n\t\tvector<dat> vec;\n\t\twhile(!s2.empty()&&s2.begin()->v==mn) vec.pb(*s2.begin()),s2.erase(s2.begin());\n\t\tfor(int i=0,j;i<sz(vec);i=j) {\n\t\t\tj=i+1;\n\t\t\twhile(j<sz(vec)&&++s1.find(vec[j-1])==s1.find(vec[j])) ++j;\n\t\t\tvector<dat> tmp(vec.begin()+i,vec.begin()+j);\n\t\t\tint len=j-i,cnt=len/l;\n\t\t\tif(cnt) {\n\t\t\t\tfor(auto x:tmp) s1.erase(x);\n\t\t\t\tans+=cal(tmp);\n\t\t\t\tvector<dat> now;\n\t\t\t\tfor(int k=0;k<cnt;k++) now.pb((dat){tmp[0].p+k,mn+1,0,0});\n\t\t\t\tfor(int k=0;k<sz(tmp)-l+1;k++) now[cnt-(sz(tmp)-k)/l].l+=tmp[k].l;\n\t\t\t\tfor(int k=l-1;k<sz(tmp);k++) now[(k+1)/l-1].r+=tmp[k].r;\n\t\t\t\tans-=cal(now);\n\t\t\t\tfor(auto x:now) s1.insert(x),s2.insert(x);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans+n;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1000100;\nint n,k,a[maxn],lv[maxn],rv[maxn],suml[maxn],sumr[maxn],nxt[maxn],pre[maxn],tot,flag[maxn];\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > Q;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",a+i),Q.push(make_pair(a[i],i));\n\tfor(int i=1;i<=n;i++) nxt[i]=i+1,pre[i]=i-1,lv[i]=rv[i]=1;tot=n;nxt[n]=0;\n\tlong long ans=0;\n\twhile(Q.size())\n\t{\n\t\tint v=Q.top().second;Q.pop();\n\t\tif(flag[v]) continue;\n\t\tint l=v,r=v,cnt=1,lst=0;\n\t\twhile(a[pre[l]]==a[v]) l=pre[l],cnt++;\n\t\twhile(a[nxt[r]]==a[r]) r=nxt[r],cnt++;\n\t\tfor(int i=l,j=1;;i=nxt[i],j++)\n\t\t{\n\t\t\tsuml[j]=suml[j-1]+lv[i];sumr[j]=sumr[j-1]+rv[i];\n\t\t\tif(i<=n) lst=j;\n\t\t\tif(lst&&j>=k) ans+=1ll*suml[min(j-k+1,lst)]*rv[i];\n\t\t\tflag[i]=1;if(i==r) break;\n\t\t}\n\t\tif(cnt<k) {nxt[pre[l]]=pre[nxt[r]]=0;continue;}\n\t\tint stpos=tot+1;\n\t\tfor(int i=1;i<=cnt/k;i++)\n\t\t{\n\t\t\trv[++tot]=sumr[min(cnt,(i+1)*k-1)]-sumr[i*k-1];a[tot]=a[l]+1;\n\t\t\tlv[tot]=suml[cnt-(cnt/k-i+1)*k+1]-suml[max(0,cnt-(cnt/k-i+2)*k+1)];\n\t\t}\n\t\tnxt[pre[l]]=stpos;pre[stpos]=pre[l];\n\t\tpre[nxt[r]]=tot;nxt[tot]=nxt[r];\n\t\tfor(int i=stpos;i<tot;i++) nxt[i]=i+1,pre[i+1]=i;\n\t\tQ.push(make_pair(a[stpos],stpos));\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=200005;\nint n,l,tot;\nint a[maxn],now[maxn*2],nnow[maxn*2],pre[maxn*2];\nint val[maxn*2],vl[maxn*2],vr[maxn*2],suml[maxn*2],sumr[maxn*2];\nll ans;\nclass Cmp{\npublic:\n\tbool operator ()(const int &a,const int &b){\n\t\tif(val[a]!=val[b])return val[a]<val[b];\n\t\treturn vl[a]<vl[b];\n\t}\n};\nset<int,Cmp>s;\n\nint main(){\n\tscanf(\"%d%d\",&n,&l);\n\tREP(i,n){\n\t\tscanf(\"%d\",&a[i]);\n\t\ttot++;\n\t\tvl[tot]=vr[tot]=i;\n\t\tval[tot]=a[i];\n\t\tsuml[tot]=sumr[tot]=1;\n\t\ts.insert(tot);\n\t}\n\twhile(!s.empty()){\n\t\tint len=0;\n\t\tnow[++len]=*s.begin();\n\t\ts.erase(s.begin());\n\t\twhile(!s.empty()&&val[*s.begin()]==val[now[1]]&&vl[*s.begin()]==vr[now[len]]+1){\n\t\t\tnow[++len]=*s.begin();\n\t\t\ts.erase(s.begin());\n\t\t}\n\t\tpre[0]=0;\n\t\tREP(i,len)pre[i]=pre[i-1]+suml[now[i]];\n\t\tREP(i,len){\n\t\t\tans+=1LL*suml[now[i]]*sumr[now[i]];\n\t\t\tif(i-l+1>=1)ans+=1LL*sumr[now[i]]*pre[i-l+1];\n\t\t}\n\t\tint nlen=0,last=0;\n\t\tREP(i,len/l){\n\t\t\tint tmpl=(i-1)*l+1,tmpr=i*l;\n\t\t\tif(i==len/l)tmpr=len;\n\t\t\ttot++;\n\t\t\tvl[tot]=vl[now[tmpl]];vr[tot]=vr[now[tmpr]];\n\t\t\tval[tot]=val[now[1]]+1;\n\t\t\tfor(int j=i*l;j<=(i+1)*l-1&&j<=len;j++)sumr[tot]+=sumr[now[j]];\n\t\t\tsuml[tot]=pre[len%l+1+(i-1)*l]-pre[last];\n\t\t\tlast=len%l+1+(i-1)*l;\n\t\t\ts.insert(tot);\n\t\t\tnnow[++nlen]=tot;\n\t\t}\n\t\tpre[0]=0;\n\t\tREP(i,nlen)pre[i]=pre[i-1]+suml[nnow[i]];\n\t\tREP(i,nlen){\n\t\t\tans-=1LL*suml[nnow[i]]*sumr[nnow[i]];\n\t\t\tif(i-l+1>=1)ans-=1LL*sumr[nnow[i]]*pre[i-l+1];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,l,a[200010],p[200020];\nlong long ans;\nstruct data\n{\n\tint l,r,wl,wr;\n};\nlong long calc(vector<pair<int,int> >&w)\n{\n//\tfor(int i=0;i<w.size();++i)printf(\"%d %d\\n\",w[i].first,w[i].second);\n\tint sum=0;\n\tlong long res=0;\n\tfor(int i=0;i<w.size();++i)\n\t{\n\t\tif(i>=l-1)sum+=w[i-l+1].first;\n\t\tres+=sum*w[i].second;\n\t}\n//\tprintf(\"%lld\\n\",res);\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&l);ans=n;\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&a[i]),p[i]=i;\n\tsort(p+1,p+1+n,[](int &x,int &y){return a[x]<a[y];});\n\tint last=1,val=0;\n\tvector<data>A,B;\n\twhile(last<=n||A.size())\n\t{\n\t\tif(A.empty())val=a[p[last]];\n\t\telse ++val;\n\t\twhile(a[p[last]]==val)A.push_back(data{p[last],p[last],1,1}),++last;\n\t\tB.clear();\n\t\tsort(A.begin(),A.end(),[](data &x,data &y){return x.l<y.l;});\n\t\tfor(int i=0;i<A.size();++i)\n\t\t{\n\t\t\tvector<pair<int,int> >cur,nxt;\n\t\t\tint r=i;cur.push_back(make_pair(A[i].wl,A[i].wr));\n\t\t\twhile(r+1<A.size()&&A[r+1].l==A[r].r+1)++r,cur.push_back(make_pair(A[r].wl,A[r].wr));\n\t\t\tans+=calc(cur);\n\t\t\tint len=r-i+1,cnt=(r-i+1)/l;\n\t\t\tnxt.resize(cnt);\n\t\t\tfor(int j=0;j<cnt;++j)nxt[j].first=nxt[j].second=0;\n\t\t\tfor(int j=0;j<len;++j)\n\t\t\t{\n\t\t\t\tif(j+1>=l)nxt[(j+1)/l-1].second+=A[i+j].wr;\n\t\t\t\tif(len-j>=l)nxt[cnt-(len-j)/l].first+=A[i+j].wl;\n\t\t\t}\n\t\t\tans-=calc(nxt);\n\t\t\tfor(int j=0;j<cnt;++j)B.push_back(data{A[i+j*l].l,A[j==cnt-1?r:i+j*l+l-1].r,nxt[j].first,nxt[j].second});\n\t\t\ti=r;\n\t\t}\n\t\tA=B;\n\t//\tfor(int i=0;i<A.size();++i)printf(\"%d %d %d %d\\n\",A[i].l,A[i].r,A[i].wl,A[i].wr);\n\t//\tprintf(\"\\n\");\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e5 + 5;\n\ntypedef pair<int,int>   ii;\n\nint a[N], t[N];\nint f1[N], f2[N];\nint s1[N], s2[N];\n\nint pre[N];\nint nxt[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int L;  cin >> L;\n\n    priority_queue<ii,vector<ii>,greater<ii> >  pq;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        cin >> a[i];\n        f1[i] = f2[i] = 1;\n        pre[i] = i - 1;\n        nxt[i] = i + 1;\n\n        pq.push(ii(a[i],i));\n    }\n    nxt[n] = 0;\n\n    int tot = n;\n    ll  ans = 0;\n\n    while (pq.size())   {\n        int p = pq.top().Y;\n        int v = pq.top().X;\n\n        pq.pop();\n\n        if (t[p])   continue;\n\n        int l = p;\n        int r = p;\n\n        while (a[pre[l]] == a[l])   l = pre[l];\n        while (a[nxt[r]] == a[r])   r = nxt[r];\n\n        int cnt = 0;\n        int prv = 0;\n\n        for(int i = l ; i != nxt[r] ; t[i] = 1, i = nxt[i]) {\n            cnt++;\n\n            if (i <= n) prv = cnt;\n\n            s1[cnt] = s1[cnt - 1] + f1[i];\n            s2[cnt] = s2[cnt - 1] + f2[i];\n\n            if (prv && cnt >= L)\n                ans += 1ll * f2[i] * s1[min(prv,cnt - L + 1)];\n        }\n        if (cnt < L)    {\n            nxt[pre[l]] = 0;\n            pre[nxt[r]] = 0;\n            continue;\n        }\n        int S = cnt / L;\n\n        for(int i = 1 ; i < S ; ++i)    {\n            nxt[tot + i] = 1 + tot + i;\n            pre[tot + i + 1] = tot + i;\n        }\n        for(int i = 1 ; i <= S ; ++i)\n            a[tot + i] = a[p] + 1;\n\n        nxt[pre[l]] = tot + 1;  pre[tot + 1] = pre[l];\n        pre[nxt[r]] = tot + S;  nxt[tot + S] = nxt[r];\n\n        for(int i = 1 ; i <= S ; ++i)   {\n            int j = S - i + 1;\n\n            f2[tot + i] = s2[min((i + 1) * L - 1,cnt)] - s2[i * L - 1];\n            f1[tot + i] = s1[cnt - j * L + 1] - s1[max(cnt - j * L - L + 1,0)];\n        }\n        pq.push(ii(a[tot + 1],tot + 1));\n        tot += S;\n    }\n    cout << ans + n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=2e5+50;\nconst int maxp=maxn*20;\nint n,L,a[maxn];\nint p,H[maxp];\nstruct node\n{\n\tint l,r,L,R;\n\tnode(int l=0,int r=0,int L=0,int R=0):l(l),r(r),L(L),R(R){}\n\tinline bool operator <(const node &other) const\n\t{\n\t\treturn l<other.l;\n\t}\n};\nvector<node> rec[maxp];\nint main()\n{\n\tread(n), read(L);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tfor(int j=0;j<20;++j) H[++p]=a[i]+j;\n\t}\n\tsort(H+1,H+p+1),p=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t\trec[a[i]].push_back(node(i,i,1,1));\n\t}\n\tll an=n;\n\tfor(int i=1;i<=p;++i) if(rec[i].size())\n\t{\n\t\tsort(rec[i].begin(),rec[i].end());\n\t\tfor(int l=0,r;l<rec[i].size();l=r+1)\n\t\t{\n\t\t\tstatic node tmp[maxn]; \n\t\t\tr=l; while(r<rec[i].size()&&rec[i][r+1].l==rec[i][r].r+1) ++r;\n\t\t\tif(r-l+1<L) continue;\n\t\t\tfor(int j=r,sum=0;j>=l+L-1;--j) \n\t\t\t{\n\t\t\t\tsum+=rec[i][j].R;\n\t\t\t\tan+=(ll)rec[i][j-L+1].L*sum;\n\t\t\t}\n\t\t\tint k=(r-l+1)/L; tmp[0].l=rec[i][l].l-1;\n\t\t\tfor(int i=1;i<=k;++i)\n\t\t\t{\n\t\t\t\ttmp[i].l=tmp[i].r=tmp[i-1].l+1;\n\t\t\t\ttmp[i].L=tmp[i].R=0;\n\t\t\t}\n\t\t\ttmp[k].r=rec[i][r].r;\n\t\t\tint t=r-L*k+1;\n\t\t\tfor(int j=l;j<=t;++j) tmp[1].L+=rec[i][j].L;\n\t\t\tfor(int j=2,now=t;j<=k;++j,now+=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].L+=rec[i][now+h].L;\n\t\t\t}\n\t\t\tt=l+L*k-1;\n\t\t\tfor(int j=r;j>=t;--j) tmp[k].R+=rec[i][j].R;\n\t\t\tfor(int j=k-1,now=t;j>=1;--j,now-=L)\n\t\t\t{\n\t\t\t\tfor(int h=1;h<=L;++h) tmp[j].R+=rec[i][now-h].R;\n\t\t\t}\n\t\t\tfor(int j=k,sum=0;j>=L;--j)\n\t\t\t{\n\t\t\t\tsum+=tmp[j].R;\n\t\t\t\tan-=(ll)tmp[j-L+1].L*sum;\n\t\t\t}\n\t\t\twhile(k) rec[i+1].push_back(tmp[k--]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 200233, inf = 1100000007;\nint n, L, a[N], lf[N], rf[N], lp[N], rp[N];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> s;\nll ans = 0;\n\nint main() {\n  scanf(\"%d%d\", &n, &L);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    lf[i] = rf[i] = 1;\n    lp[i] = i - 1;\n    rp[i] = i + 1;\n    s.push(make_pair(a[i], i));\n  }\n  rf[0] = 1;\n  lf[n + 1] = n;\n  while (1) {\n    int x = s.top().second;\n    s.pop();\n    if (a[x] == inf) break;\n    int y = x, cnt = 1;\n    vector<int> v(1, x);\n    while (a[rp[y]] == a[y]) {\n      cnt++;\n      y = rp[y];\n      v.push_back(y);\n      s.pop();\n    }\n    for (int i = 0, sum = 0; i < cnt; i++) {\n      ans += (ll) lf[v[i]] * rf[v[i]];\n      if (i - L + 1 >= 0) {\n        sum += lf[v[i - L + 1]];\n      }\n      ans += (ll) sum * rf[v[i]];\n    }\n    int lt = lp[x], rt = rp[y];\n    if (lt == 0 && rt == n + 1) {\n      break;\n    }\n    int cnt2 = cnt / L;\n    vector<int> nlf(cnt2, 0), nrf(cnt2, 0);\n    for (int i = 0; i < cnt; i++) {\n      if (cnt - i >= L) {\n        nlf[cnt2 - 1 - (cnt - i - L) / L] += lf[v[i]];\n      }\n      if (i + 1 >= L) {\n        nrf[(i + 1 - L) / L] += rf[v[i]];\n      }\n    }\n    for (int i = 0, sum = 0; i < cnt2; i++) {\n      ans -= (ll) nlf[i] * nrf[i];\n      if (i - L + 1 >= 0) {\n        sum += nlf[i - L + 1];\n      }\n      ans -= (ll) sum * nrf[i];\n    }\n    if (!cnt2) {\n      ++cnt2;\n      a[v[0]] = inf - 1;\n      nlf.assign(1, 0);\n      nrf.assign(1, 0);\n    }\n    for (int i = 0; i < cnt2; i++) {\n      a[v[i]]++;\n      s.push(make_pair(a[v[i]], v[i]));\n      lf[v[i]] = nlf[i];\n      rf[v[i]] = nrf[i];\n    }\n    lp[v[0]] = lt;\n    rp[v[cnt2 - 1]] = rt;\n    rp[lt] = v[0];\n    lp[rt] = v[cnt2 - 1];\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int, int> pi;\n\n#define fi first\n#define se second\n\nint read() {\n  int res = 0, w = 1; char c = getchar();\n  while (!isdigit(c) && c != '-') c = getchar();\n  if (c == '-') c = getchar(), w = -1;\n  while (isdigit(c)) res = (res << 1) + (res << 3) + c - '0', c = getchar();\n  return res * w;\n}\n\nconst int N = 2e5 + 10;\n\nint n, L, x[N];\npi y[N];\nvector <pair<pi, pi> > a, b;\n\nll calc(vector<pi> & s) {\n  ll ans = 0, sum = 0;\n  for (int i = L - 1, j = 0; i < (signed) s.size(); i++, j++) {\n    sum += s[j].first;\n    ans += s[i].second * sum;\n  }\n  return ans;\n}\n\nint main() {\n#ifdef dream_maker\n//  freopen(\"tst.in\", \"r\", stdin);\n#else\n  //freopen(\".in\", \"r\", stdin);\n  //freopen(\".out\", \"w\", stdout);\n#endif\n  n = read(), L = read();\n  for (int i = 1; i <= n; i++) {\n    x[i] = read();\n    y[i] = make_pair(x[i], i);\n  }\n  sort(y + 1, y + n + 1);\n  ll ans = n;\n  int val = 0, cur = 1;\n  while (1) {\n    if (a.empty()) {\n      if (cur > n) break;\n      else val = y[cur].first;\n    } else {\n      ++val;\n    }\n    while (val == y[cur].first) {\n      a.emplace_back(pi(y[cur].second, y[cur].second), pi(1, 1));\n      cur++;\n    }\n    b.clear();\n    sort(a.begin(), a.end());\n    for (int l = 0, r; l < (signed) a.size(); l = r + 1) {\n      r = l;\n      while (r + 1 < (signed) a.size() && a[r + 1].first.first == a[r].first.second + 1) r++;\n      int len = r - l + 1, cnt = len / L;\n      if (cnt) {\n        vector<pi> now, pos, val;\n        for (int k = l; k <= r; k++) now.push_back(a[k].second);\n        ans += calc(now);\n        for (int k = 0; k < cnt; k++) {\n          pos.emplace_back(a[l].first.first + k, (k == cnt - 1) ? a[r].first.second : a[l].first.first + k);\n          val.emplace_back(0, 0);\n        }\n        for (int k = l; k <= r; k++) {\n          int tl = k - l + 1, tr = r - k + 1;\n          if (tl >= L) val[tl / L - 1].second += a[k].second.second;\n          if (tr >= L) val[cnt - tr / L].first += a[k].second.first;\n        }\n        ans -= calc(val);\n        for (int k = 0; k < cnt; k++) b.emplace_back(pos[k], val[k]);\n      }\n    }\n    a = b;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=200000;\nstruct Block { int l,r,val; int mid; vector<int> pref,suff; };\n\nint n,need;\nint a[MAXN];\n\nint ufpar[MAXN],ufsz[MAXN];\nBlock block[MAXN];\npair<int,int> o[MAXN];\n\nint uffind(int x) { if(ufpar[x]==x) return x; return ufpar[x]=uffind(ufpar[x]); }\nvoid ufunite(int a,int b) { a=uffind(a),b=uffind(b); if(a==b) return; if(ufsz[a]<ufsz[b]) swap(a,b); ufpar[b]=a,ufsz[a]+=ufsz[b]; }\n\nvoid levelup(Block &b) {\n\tvector<int> npref(SZ(b.pref)/need,0); FORSZ(i,need-1,b.pref) npref[(i+1)/need-1]+=b.pref[i]; b.pref=npref;\n\tvector<int> nsuff(SZ(b.suff)/need,0); FORSZ(i,need-1,b.suff) nsuff[(i+1)/need-1]+=b.suff[i]; b.suff=nsuff;\n\tb.mid/=need; if(b.mid>0) ++b.val; else b.val=-1;\n}\nBlock merge(const Block &a,const Block &b,ll &ans) {\n\tassert(a.r+1==b.l); assert(a.val==b.val);\n\tBlock ret; ret.l=a.l; ret.r=b.r; ret.val=a.val; ret.mid=a.mid+b.mid;\n\tvector<int> npref=a.pref; REPSZ(i,b.pref) { int x=a.mid+i; while(x>=SZ(npref)) npref.PB(0); npref[x]+=b.pref[i]; } ret.pref=npref;\n\tvector<int> nsuff=b.suff; REPSZ(i,a.suff) { int x=b.mid+i; while(x>=SZ(nsuff)) nsuff.PB(0); nsuff[x]+=a.suff[i]; } ret.suff=nsuff;\n\tint sum=0,at=0; REPSZ(i,b.pref) sum+=b.pref[i]; for(int i=SZ(a.suff)-1;i>=0;--i) { while(i+1+at+1<need) sum-=b.pref[at],++at; ans+=(ll)a.suff[i]*sum; }\n\t//printf(\"merged: [%d..%d] val=%d mid=%d pref=\",ret.l,ret.r,ret.val,ret.mid); REPSZ(i,ret.pref) { if(i!=0) printf(\",\"); printf(\"%d\",ret.pref[i]); } printf(\" suff=\"); REPSZ(i,ret.suff) { if(i!=0) printf(\",\"); printf(\"%d\",ret.suff[i]); } puts(\"\");\n\treturn ret;\n}\nBlock merge(const vector<Block> &blocks,ll &ans) {\n\tFORSZ(i,1,blocks) assert(blocks[i-1].r+1==blocks[i].l),assert(blocks[i-1].val==blocks[i].val);\n\tBlock ret; ret.l=blocks[0].l,ret.r=blocks[SZ(blocks)-1].r,ret.val=blocks[0].val,ret.mid=0; REPSZ(i,blocks) ret.mid+=blocks[i].mid;\n\t{ vector<int> npref; int off=0; REPSZ(i,blocks) { REPSZ(j,blocks[i].pref) { int x=off+j; while(x>=SZ(npref)) npref.PB(0); npref[x]+=blocks[i].pref[j]; } off+=blocks[i].mid; } ret.pref=npref; }\n\t{ vector<int> nsuff; int off=0; for(int i=SZ(blocks)-1;i>=0;--i) { REPSZ(j,blocks[i].suff) { int x=off+j; while(x>=SZ(nsuff)) nsuff.PB(0); nsuff[x]+=blocks[i].suff[j]; } off+=blocks[i].mid; } ret.suff=nsuff; }\n\t{\n\t\tint sum=0; REPSZ(i,blocks) REPSZ(j,blocks[i].pref) sum+=blocks[i].pref[j];\n\t\tint ii=0,jj=0,off=0;\n\t\tREPSZ(i,blocks) { \n\t\t\toff-=blocks[i].mid;\n\t\t\tfor(int j=SZ(blocks[i].suff)-1;j>=0;--j) { \n\t\t\t\twhile(ii<=i||ii<SZ(blocks)&&j+1+jj+1+off<need) { sum-=blocks[ii].pref[jj]; ++jj; if(jj==SZ(blocks[ii].pref)) off+=blocks[ii].mid,++ii,jj=0; }\n\t\t\t\tans+=(ll)blocks[i].suff[j]*sum;\n\t\t\t}\n\t\t} \n\t}\n\t//printf(\"merged: [%d..%d] val=%d mid=%d pref=\",ret.l,ret.r,ret.val,ret.mid); REPSZ(i,ret.pref) { if(i!=0) printf(\",\"); printf(\"%d\",ret.pref[i]); } printf(\" suff=\"); REPSZ(i,ret.suff) { if(i!=0) printf(\",\"); printf(\"%d\",ret.suff[i]); } puts(\"\");\n\treturn ret;\n}\n\n\n\nll solve() {\n\tREP(i,n) ufpar[i]=i,ufsz[i]=1;\n\tREP(i,n) { block[i].l=block[i].r=i,block[i].val=a[i],block[i].mid=1; block[i].pref=block[i].suff=vector<int>(1,1); }\n\tREP(i,n) o[i]=MP(a[i],i);\n\tsort(o,o+n);\n\tll ret=n;\n\tfor(int l=0,r=l;l<n;l=r) {\n\t\tint val=o[l].first;\n\t\twhile(r<n&&o[r].first==val) ++r;\n\t\tvector<int> cur;\n\t\tcur.PB(-1);\n\t\tFOR(i,l,r) {\n\t\t\tint at=o[i].second,prv=-1,nxt=-1;\n\t\t\tif(at-1>=0&&a[at-1]<=val) { int x=uffind(at-1); while(block[x].val!=-1&&block[x].val<val) levelup(block[x]); if(block[x].val!=-1) prv=x; }\n\t\t\tif(at+1 <n&&a[at+1]<=val) { int x=uffind(at+1); while(block[x].val!=-1&&block[x].val<val) levelup(block[x]); if(block[x].val!=-1) nxt=x; }\n\t\t\tif((SZ(cur)<1||cur[SZ(cur)-1]!=prv)&&(SZ(cur)<2||cur[SZ(cur)-2]!=prv)) { cur.PB(-1); cur.PB(prv); }\n\t\t\tif(SZ(cur)<1||cur[SZ(cur)-1]!=at) cur.PB(at);\n\t\t\tcur.PB(nxt);\n\t\t}\n\t\tcur.PB(-1);\n\t\t//printf(\"cur:\"); REPSZ(i,cur) printf(\" %d\",cur[i]); puts(\"\");\n\t\tREPSZ(i,cur) if(cur[i]!=-1&&cur[i-1]==-1) {\n\t\t\tint j=i; while(cur[j+1]!=-1) ++j;\n\t\t\tvector<Block> blocks; FORE(k,i,j) blocks.PB(block[cur[k]]);\n\t\t\t//Block me=blocks[0]; FORSZ(k,1,blocks) me=merge(me,blocks[k],ret);\n\t\t\tBlock me=merge(blocks,ret);\n\t\t\tFORE(k,i+1,j) ufunite(cur[i],cur[k]);\n\t\t\tblock[uffind(cur[i])]=me;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&need);\n\tREP(i,n) scanf(\"%d\",&a[i]);\n\tprintf(\"%lld\\n\",solve());\n}\n\nvoid stress() {\n\tREP(rep,10000) {\n\t\tn=100; need=2; REP(i,n) a[i]=rand()%4+1;\n\t\t//printf(\"%d %d\\n\",n,need); REP(i,n) { if(i!=0) printf(\" \"); printf(\"%d\",a[i]); } puts(\"\");\n\t\tsolve();\n\t\tprintf(\".\");\n\t}\n}\n\nint main() {\n\trun();\n\t//stress();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define N 400600\nmap<int,int> tp1;\nset<int> tp3;\nstruct sth{int l,r,lb,rb;friend bool operator <(sth a,sth b){return a.l<b.l;}};\nvector<sth> v[N];\nint su[N][2],vl[N][2],tp[N][2],ct,n,k,s[N],cnt;\nlong long as;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&s[i]);\n\t\ttp3.insert(s[i]);if(!tp1[s[i]])tp1[s[i]]=++cnt;\n\t\tv[tp1[s[i]]].push_back((sth){i,i,1,1});\n\t}\n\tint lb=*tp3.lower_bound(1);\n\twhile(1)\n\t{\n\t\tint st=tp1[lb];\n\t\tsort(v[st].begin(),v[st].end());\n\t\tint sz=v[st].size(),las=v[st][0].l;\n\t\tfor(int i=0;i<sz;i++)\n\t\t{\n\t\t\tif(ct&&v[st][i].l!=v[st][i-1].r+1)\n\t\t\t{\n\t\t\t\tsu[ct+1][0]=su[ct+1][1]=0;\n\t\t\t\tint s1=ct/k;\n\t\t\t\tif(s1)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=1;j<=ct;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long r1=j+k-1,r2=j+1ll*k*k-2;\n\t\t\t\t\t\tif(r1<=ct&&r2>ct)as+=1ll*vl[j][1]*(su[ct][0]-su[r1-1][0]);\n\t\t\t\t\t\telse if(r1<=ct)as+=1ll*vl[j][1]*(su[r2][0]-su[r1-1][0]);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=1;j<s1;j++)tp[j][0]=su[(j+1)*k-1][0]-su[j*k-1][0];\n\t\t\t\t\ttp[s1][0]=su[ct][0]-su[s1*k-1][0];\n\t\t\t\t\tfor(int j=1;j<s1;j++)tp[s1-j+1][1]=-su[ct-(j+1)*k+1][1]+su[ct-j*k+1][1];\n\t\t\t\t\ttp[1][1]=su[ct-s1*k+1][1];\n\t\t\t\t\tif(!tp1[lb+1])tp1[lb+1]=++ct,tp3.insert(lb+1);\n\t\t\t\t\tfor(int j=1;j<=s1;j++)v[tp1[lb+1]].push_back((sth){las+j-1,j==s1?v[st][i-1].r:las+j-1,tp[j][0],tp[j][1]});\n\t\t\t\t}\n\t\t\t\tct=0;las=v[st][i].l;\n\t\t\t}\n\t\t\tvl[++ct][0]=v[st][i].lb;vl[ct][1]=v[st][i].rb;\n\t\t\tsu[ct][0]=su[ct-1][0]+vl[ct][0];su[ct][1]=su[ct-1][1]+vl[ct][1];\n\t\t}\n\t\tsu[ct+1][0]=su[ct+1][1]=0;\n\t\tint s1=ct/k;\n\t\tif(s1)\n\t\t{\n\t\t\tfor(int j=1;j<=ct;j++)\n\t\t\t{\n\t\t\t\tlong long r1=j+k-1,r2=j+1ll*k*k-2;\n\t\t\t\tif(r1<=ct&&r2>ct)as+=1ll*vl[j][1]*(su[ct][0]-su[r1-1][0]);\n\t\t\t\telse if(r1<=ct)as+=1ll*vl[j][1]*(su[r2][0]-su[r1-1][0]);\n\t\t\t}\n\t\t\tfor(int j=1;j<s1;j++)tp[j][0]=su[(j+1)*k-1][0]-su[j*k-1][0];\n\t\t\ttp[s1][0]=su[ct][0]-su[s1*k-1][0];\n\t\t\tfor(int j=1;j<s1;j++)tp[s1-j+1][1]=-su[ct-(j+1)*k+1][1]+su[ct-j*k+1][1];\n\t\t\ttp[1][1]=su[ct-s1*k+1][1];\n\t\t\tif(!tp1[lb+1])tp1[lb+1]=++cnt,tp3.insert(lb+1);\n\t\t\tfor(int j=1;j<=s1;j++)v[tp1[lb+1]].push_back((sth){las+j-1,j==s1?v[st][sz-1].r:las+j-1,tp[j][0],tp[j][1]});\n\t\t}\n\t\tct=0;\n\t\tset<int>::iterator it=tp3.lower_bound(lb+1);\n\t\tif(it==tp3.end())break;\n\t\tlb=*it;\n\t}\n\tprintf(\"%lld\\n\",as+n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005;\nint Left[N],Right[N],num,x,val[N],n,l,sl[N],sr[N];\nll ans;\nvoid dec(){\n\tint now;\n\tfor (now=num-1;now>0;now--)\n\t\tif (val[now]!=val[now-1])break;\n\tint d=num-now,v=val[now];\n\tll s=0;\n\tfor (int i=now;i<num;i++){\n\t\tans+=(ll)Left[i]*Right[i];\n\t\tif (i-l+1>=now)s+=Left[i-l+1];\n\t\tans+=s*Right[i];\n\t}\n\tif (d<l){\n\t\tnum=now;\n\t\twhile (num)dec();\n\t\treturn;\n\t}\n\tint dd=d/l;\n\tfor (int i=0;i<=dd;i++)sl[i]=sr[i]=0;\n\tfor (int i=now;i<num;i++){\n\t\tsl[(i-now+1)/l]+=Right[i];\n\t\tsr[(num-i)/l]+=Left[i];\n\t}\n\tnum=now+dd;\n\tfor (int i=1;i<=dd;i++){\n\t\tRight[now+i-1]=sl[i];\n\t\tLeft[num-i]=sr[i];\n\t}\n\ts=0;\n\tfor (int i=now;i<num;i++){\n\t\tval[i]=v+1;\n\t\tans-=(ll)Left[i]*Right[i];\n\t\tif (i-l+1>=now)s+=Left[i-l+1];\n\t\tans-=s*Right[i];\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&l);\n\twhile (n--){\n\t\tscanf(\"%d\",&x);\n\t\twhile (num>0){\n\t\t\tif (val[num-1]>=x)break;\n\t\t\tdec();\n\t\t}\n\t\tLeft[num]=Right[num]=1;\n\t\tval[num]=x;\n\t\tnum++;\n\t}\n\twhile (num)dec();\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint L;\n\nvector<int> a;\n\nstruct I {\n\tint amax;\n\tunordered_map<int,int> pref, suff;\n\tbool tot_okay;\n\tint tot_num;\n\tI() {\n\t\tamax = 0;\n\t\tpref[0] = 1; suff[0] = 1;\n\t\ttot_okay = true;\n\t\ttot_num = 0;\n\t}\n};\n\nvoid level_up(I& v, int a){\n\tassert(a >= v.amax);\n\twhile(v.amax < a){\n\t\tv.amax += 1;\n\t\tbool did_something = false;\n\t\tunordered_map<int,int> newpref, newsuff;\n\t\tfor(auto q : v.pref){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewpref[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewpref[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tfor(auto q : v.suff){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewsuff[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewsuff[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tv.pref = newpref;\n\t\tv.suff = newsuff;\n\t\tif(v.tot_okay){\n\t\t\tif(v.tot_num == 0){\n\t\t\t} else if(v.tot_num < L){\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_okay = false;\n\t\t\t\tv.tot_num = 0;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_num /= L;\n\t\t\t}\n\t\t}\n\t\tif(!did_something) break;\n\t}\n\tv.amax = a;\n}\n\nlong long ans = 0;\n\nvector<int> arr(const unordered_map<int, int> f){\n\tvector<int> a(f.size(), -1);\n\tfor(pair<int,int> x : f){\n\t\ta[x.first] = x.second;\n\t}\n\treturn a;\n}\n\nI combine(I& l, int a, I& r){\n\tlevel_up(l, a);\n\tlevel_up(r, a);\n\tassert(a == l.amax);\n\tassert(a == r.amax);\n\tI res;\n\tres.amax = a;\n\tres.pref = res.suff = {};\n\tif(l.tot_okay && r.tot_okay){\n\t\tres.tot_okay = true;\n\t\tres.tot_num = l.tot_num + 1 + r.tot_num;\n\t} else {\n\t\tres.tot_okay = false;\n\t\tres.tot_num = 0;\n\t}\n\tres.pref = move(l.pref);\n\tif(l.tot_okay){\n\t\tfor(auto q : r.pref){\n\t\t\tres.pref[q.first + l.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tres.suff = move(r.suff);\n\tif(r.tot_okay){\n\t\tfor(auto q : l.suff){\n\t\t\tres.suff[q.first + r.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tvector<int> la = arr(l.suff);\n\tvector<int> ra = arr(r.pref);\n\tlong long cur = 0;\n\tcur += 1;\n\tlong long tot = 0;\n\tint j = (int)ra.size();\n\tfor(int i = 0; i < (int)la.size(); i++){\n\t\twhile(j > 0 && (j-1) + 1 + i >= L){\n\t\t\tj -= 1;\n\t\t\ttot += ra[j];\n\t\t}\n\t\tcur += la[i] * tot;\n\t}\n\tans += cur;\n\treturn res;\n}\n\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n >> L;\n\ta.resize(n);\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\n\tvector<int> b(n+2);\n\tvector<int> f(n+2);\n\tfor(int i = 0; i <= n+1; i++){\n\t\tb[i] = i-1;\n\t\tf[i] = i+1;\n\t}\n\tvector<I> data(n+2);\n\tvector<pair<int,int> > apos;\n\tfor(int i = 0; i < n; i++){\n\t\tapos.push_back({a[i], i+1});\n\t}\n\tsort(apos.begin(), apos.end());\n\tfor(auto _x : apos){\n\t\tint x = _x.second;\n\t\tf[b[x]] = f[x];\n\t\tb[f[x]] = b[x];\n\t\tdata[b[x]] = combine(data[b[x]], a[x-1], data[x]);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>V;\ntypedef long long ll;\nconst int N=2e5+5;\nlong long ans;\nint n,L,a[N],i,j,x,aa[N];\nint g[N];\nV lv[N],rv[N];int mx[N];\nint gfa(int x){return g[x]==x?x:g[x]=gfa(g[x]);}\ninline bool cmp(int x,int y){return a[x]==a[y]?x<y:a[x]<a[y];}\nlong long mi;\nstruct atom{\n\tV l,r;int mx;bool full;\n\tinline void set(const atom&a,int mx2){\n\t\tll z=1;int zz=max(a.l.empty()?0:a.l.back(),a.r.empty()?0:a.r[0]);\n\t\tfull=0;l.clear();r.clear();\n\t\tfor(mx=a.mx;mx<mx2 && z<=zz;z*=L,++mx);\n\t\tif(zz<z){mx=mx2;return;}\n\t\tfull=a.full;\n\t\tfor(int x:a.l)if(x>=z)l.push_back(x/z);\n\t\tfor(int x:a.r)if(x>=z)r.push_back(x/z);\n\t}\n}b[N],v[N];int xb;\nint w,l,s,st[N];bool bb[N];\ninline void uni(atom&zz){\n\tw=s=0;l=1;\n\tzz.full=1;zz.mx=b[1].mx;\n\tfor(int i=1;i<=xb;++i){\n\t\tzz.full&=b[i].full;\n\t\tif(!b[i].full)w=s=0,l=1;\n\t\tfor(int x:b[i].l){\n\t\t\tfor(;l<=w && st[l]+s+x>=L;++l)if(l<w && bb[l+1])s-=st[l+1];\n\t\t\tans+=l-1;\n\t\t}\n\t\tif(!b[i].r.empty()){\n\t\t\tif(l<=w)s+=b[i].r[0];int ow=w;\n\t\t\tfor(int x:b[i].r)st[++w]=x,bb[w]=0;bb[ow+1]=1;\n\t\t}\n\t}\n\tzz.r.resize(w);s=0;for(int i=w;i;--i)zz.r[i-1]=st[i]+s,s+=bb[i]?st[i]:0;\n\tw=0;\n\tfor(int i=xb;i;--i){\n\t\tif(!b[i].full)w=0;\n\t\tif(!b[i].l.empty()){\n\t\t\tint ow=w;reverse(b[i].l.begin(),b[i].l.end());\n\t\t\tfor(int x:b[i].l)st[++w]=x,bb[w]=0;bb[ow+1]=1;\n\t\t}\n\t}\n\tzz.l.resize(w);s=0;for(int i=w;i;--i)zz.l[w-i]=st[i]+s,s+=bb[i]?st[i]:0;\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>L;for(i=1;i<=n;++i)cin>>a[i],aa[i]=i,g[i]=i,v[i].l=v[i].r={1},v[i].mx=a[i],v[i].full=1;\n\tstd::sort(aa+1,aa+n+1,cmp);\n\tfor(i=1;i<=n;i=j){\n\t\txb=0;\n\t\tif(aa[i]>1 && a[aa[i]-1]<a[aa[i]])b[++xb].set(v[aa[i]-1],a[aa[i]]),g[aa[i]-1]=aa[i];\n\t\tfor(j=i+1,b[++xb]=v[aa[i]];j<=n && a[aa[j]]==a[aa[i]] && gfa(aa[j-1]+1)>=aa[j]-1\n\t\t\t && a[aa[j-1]+1]<=a[aa[i]];++j){\n\t\t\tif(aa[j-1]+1<aa[j])b[++xb].set(v[aa[j]-1],a[aa[i]]),g[aa[j]-1]=aa[j];\n\t\t\tb[++xb]=v[aa[j]];g[aa[j-1]]=aa[j-1]+1;\n\t\t}\n\t\tif(aa[j-1]<n && a[aa[j-1]]>a[aa[j-1]+1])b[++xb].set(v[gfa(aa[j-1]+1)],a[aa[i]]),g[aa[j-1]]=aa[j-1]+1;\nif(a[aa[i]]==99)\n++i,--i;\n\t\tuni(v[gfa(aa[i])]);\n\t}\n\tcout<<ans+n<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,L;\nll ans;\nstruct Inter{\n\tint pos,val,l,r;\n\tInter(int _p=0,int _v=0,int _l=0,int _r=0){pos=_p,val=_v,l=_l,r=_r;}\n};\nstruct cmp1{\n\tbool operator ()(const Inter a,const Inter b)const{\n\t\treturn a.pos<b.pos;\n\t}\n};\nstruct cmp2{\n\tbool operator ()(const Inter a,const Inter b)const{\n\t\treturn a.val==b.val?a.pos<b.pos:a.val<b.val;\n\t}\n};\nset<Inter,cmp1> p;\nset<Inter,cmp2> s;\ninline ll calc(vector<Inter> &v){\n\tll tot=0,sum=0;\n\tfor(int i=0;i+L-1<(int)v.size();++i){\n\t\tsum+=v[i].l;\n\t\ttot+=sum*v[i+L-1].r;\n\t}\n\treturn tot;\n}\nint main(){\n\tn=read(),L=read();\n\tfor(int i=1;i<=n;++i){\n\t\tint x=read();\n\t\tInter zyk(i,x,1,1);\n\t\tp.insert(zyk),s.insert(zyk);\n\t}\n\twhile(!s.empty()){\n\t\tint w=s.begin()->val;\n\t\tvector<Inter> t;\n\t\twhile(s.begin()->val==w){\n\t\t\tt.push_back(*s.begin());\n\t\t\ts.erase(s.begin());\n\t\t}\n\t\tfor(int l=0,r=1;l<(int)t.size();l=r++){\n\t\t\twhile(r<(int)t.size()&&(--p.find(t[r]))==p.find(t[r-1]))++r;\n\t\t\tint len=r-l,cnt=len/L;\n\t\t\tif(!cnt)continue;\n\t\t\tvector<Inter> myh,zyy;\n\t\t\tmyh.insert(myh.begin(),t.begin()+l,t.begin()+r);\n\t\t\tfor(auto x:myh){\n\t\t\t\tp.erase(x);\n\t\t\t}\n\t\t\tans+=calc(myh);\n\t\t\tfor(int i=0;i<cnt;++i){\n\t\t\t\tzyy.push_back(Inter(myh[0].pos+i,w+1,0,0));\n\t\t\t}\n\t\t\tfor(int i=0;i+L-1<(int)myh.size();++i){\n\t\t\t\tzyy[cnt-((int)myh.size()-i)/L].l+=myh[i].l;\n\t\t\t}\n\t\t\tfor(int i=L-1;i<(int)myh.size();++i){\n\t\t\t\tzyy[(i-L+1)/L].r+=myh[i].r;\n\t\t\t}\n\t\t\tans-=calc(zyy);\n\t\t\tfor(auto x:zyy){\n\t\t\t\tp.insert(x),s.insert(x);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,L;\n#define Maxn 200010\nll Ans=0;\nstruct data{\n    int val,pos;\n    bool operator <(const data &z)const{return val==z.val?pos<z.pos:val<z.val;}\n}seq[Maxn];\nstruct Data{\n    int l,r;\n\tint x,y;\n\tbool operator <(const Data &z)const{return l<z.l;}\n};\nvector<Data> A,B,vec2;\nvector<pair<int,int> > vec1;\nint num[Maxn];\n\ninline ll calc(vector< pair<int,int> > &a){\n\tll res=0,sum=0;\n\tfor(int i=L-1,j=0;i<a.size();i++,j++){\n\t\tsum+=a[j].first;\n\t\tres+=a[i].second*sum;\n\t}\n\treturn res;\n}\n\ninline void rd(int &x){\n\tx=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9')ch=getchar();\n\twhile(ch>='0'&&ch<='9'){\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t} \n}\n\nint main(){\n\trd(n);rd(L);\n\tfor(register int i=1;i<=n;++i){\n\t\trd(num[i]);\n\t\tseq[i]=(data){num[i],i};\n\t}\n\tsort(seq+1,seq+n+1);\n\tll Ans=n;\n\tint at=1,tmp;\n\twhile(true){\n\t\tif(A.empty()){\n\t\t\tif(at>n)break;\n\t\t\telse tmp=seq[at].val;\n\t\t}else tmp++;\n\t\twhile(tmp==seq[at].val)A.push_back((Data){seq[at].pos,seq[at].pos,1,1}),at++;\n\t\tB.clear();sort(A.begin(),A.end());\n\t\tfor(int i=0,j;i<A.size();i=j+1){\n\t\t\tj=i;\n\t\t\twhile(j+1<A.size()&&A[j+1].l==A[j].r+1)j++;\n\t\t\tint len=j-i+1,cnt=len/L;\n\t\t\tif(cnt){\n\t\t\t\tvec1.clear();\n\t\t\t\tvec2.clear();\n\t\t\t\tfor(register int k=i;k<=j;++k)vec1.push_back(make_pair(A[k].x,A[k].y));\n\t\t\t\tAns+=calc(vec1);\n\t\t\t\tfor(register int k=1;k<=cnt;++k)\n\t\t\t\t\tvec2.push_back((Data){A[i].l+k-1,(k==cnt)?A[j].r:A[i].l+k-1,0,0});\n\t\t\t\tfor(register int k=i;k<=j;++k){\n\t\t\t\t\tint tl=k-i+1,tr=j-k+1;\n\t\t\t\t\tif(tl>=L)vec2[tl/L-1].y+=A[k].y;\n\t\t\t\t\tif(tr>=L)vec2[cnt-tr/L].x+=A[k].x;\n\t\t\t\t}\n\t\t\t\tvec1.clear();\n\t\t\t    for(register int k=0;k<cnt;++k)vec1.push_back(make_pair(vec2[k].x,vec2[k].y));\n\t\t\t\tAns-=calc(vec1);\n\t\t\t\tfor(register int k=0;k<cnt;++k)B.push_back(vec2[k]);\n\t\t\t}\n\t\t}\n\t\tA.clear();\n\t\tfor(int i=0;i<B.size();++i)A.push_back(B[i]);\n\t}\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2019.8.23 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define unl __int128\n#define eps 5.6e-8\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define ull unsigned LL\n#define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG unl x){\n//    if(x>10)write(x/10);\n//    putchar(int(x%10)+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//clock_t start=clock();\n//inline void ck(){\n//    if(1.0*(clock()-start)/CLOCKS_PER_SEC>0.1)exit(0);\n//}\nconst int N=2e5+10;\nnamespace MAIN{\n    int n,l;\n    int a[N];\n    Pair b[N];\n    LL ans;\n    typedef pair<Pair,Pair> pii;\n    vector<pii> f,g;\n    vector<Pair> tmp,F,G;\n    inline LL calc(const RG vector<Pair> &A){\n        RG LL ret=0,sum=0;\n        for(res i=0,j=l-1,sz=int(A.size()-1);j<=sz;i++,j++)sum+=A[i].fi,ret+=sum*A[j].se;\n        return ret;\n    }\n    inline void MAIN(){\n        n=read(),l=read();\n        for(res i=1;i<=n;i++)a[i]=read(),b[i]=mp(a[i],i);\n        sort(b+1,b+1+n),ans=n;\n        res pos=1,val=0;\n        while(233){\n//            res val=0;\n//            printf(\"%d\\n\",int(f.size()));\n            if(!f.size()){\n//                puts(\"OK\");\n                if(pos>n)break;\n                val=b[pos].fi;\n            }\n            else val++;\n            while(val==b[pos].fi)f.pb(mp(mp(b[pos].se,b[pos].se),mp(1,1))),pos++;\n//            printf(\"%d\\n\",pos);\n            g.clear(),sort(f.begin(),f.end());\n            for(res i=0,sz=int(f.size()-1);i<=sz;){\n//                printf(\"%d\\n\",i);\n                res j=i;\n                while(j+1<=sz&&f[j+1].fi.fi==f[j].fi.se+1)j++;\n//                printf(\"%d %d\\n\",i,j);\n                res len=j-i+1,cnt=len/l;\n//                printf(\"%d\\n\",cnt);\n                if(cnt){\n                    tmp.clear(),F.clear(),G.clear();\n                    for(res k=i;k<=j;k++)tmp.pb(f[k].se);\n//                    printf(\"%d\\n\",ans);\n                    ans+=calc(tmp);\n                    for(res k=1;k<=cnt;k++)F.pb(mp(f[i].fi.fi+k-1,(k==cnt)?f[j].fi.se:f[i].fi.fi+k-1)),G.pb(mp(0,0));\n                    for(res k=i;k<=j;k++){\n                        res tl=k-i+1,tr=j-k+1;\n                        if(tl>=l)G[tl/l-1].se+=f[k].se.se;\n                        if(tr>=l)G[cnt-tr/l].fi+=f[k].se.fi;\n                    }\n                    ans-=calc(G);\n                    for(res k=0;k<cnt;k++)g.pb(mp(F[k],G[k]));\n                }\n//                printf(\"QAQ%d %d\\n\",i,j);\n                i=j+1;\n\n            }\n            f=g;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main(){\n//    srand(19260817);\n//    freopen(\"signin.in\",\"r\",stdin);\n//    freopen(\"signin.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint L;\n\nvector<int> a;\n\nstruct I {\n\tint amax;\n\tunordered_map<int,int> pref, suff;\n\tbool tot_okay;\n\tint tot_num;\n\tI() {\n\t\tamax = 0;\n\t\tpref[0] = 1; suff[0] = 1;\n\t\ttot_okay = true;\n\t\ttot_num = 0;\n\t}\n};\n\nvoid level_up(I& v, int a){\n\tassert(a >= v.amax);\n\twhile(v.amax < a){\n\t\tv.amax += 1;\n\t\tbool did_something = false;\n\t\tunordered_map<int,int> newpref, newsuff;\n\t\tfor(auto q : v.pref){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewpref[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewpref[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tfor(auto q : v.suff){\n\t\t\tif(q.first == 0){\n\t\t\t\tnewsuff[0] += q.second;\n\t\t\t} else if(q.first < L){\n\t\t\t\tdid_something = true;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tnewsuff[q.first / L] += q.second;\n\t\t\t}\n\t\t}\n\t\tv.pref = newpref;\n\t\tv.suff = newsuff;\n\t\tif(v.tot_okay){\n\t\t\tif(v.tot_num == 0){\n\t\t\t} else if(v.tot_num < L){\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_okay = false;\n\t\t\t\tv.tot_num = 0;\n\t\t\t} else {\n\t\t\t\tdid_something = true;\n\t\t\t\tv.tot_num /= L;\n\t\t\t}\n\t\t}\n\t\tif(!did_something) break;\n\t}\n\tv.amax = a;\n}\n\nlong long ans = 0;\n\nvector<int> arr(const unordered_map<int, int> f){\n\tvector<int> a(f.size(), -1);\n\tfor(pair<int,int> x : f){\n\t\ta[x.first] = x.second;\n\t}\n\treturn a;\n}\n\nI combine(I& l, int a, I& r){\n\tlevel_up(l, a);\n\tlevel_up(r, a);\n\tassert(a == l.amax);\n\tassert(a == r.amax);\n\tI res;\n\tres.amax = a;\n\tres.pref = res.suff = {};\n\tif(l.tot_okay && r.tot_okay){\n\t\tres.tot_okay = true;\n\t\tres.tot_num = l.tot_num + 1 + r.tot_num;\n\t} else {\n\t\tres.tot_okay = false;\n\t\tres.tot_num = 0;\n\t}\n\tres.pref = move(l.pref);\n\tif(l.tot_okay){\n\t\tfor(auto q : r.pref){\n\t\t\tres.pref[q.first + l.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tres.suff = move(r.suff);\n\tif(r.tot_okay){\n\t\tfor(auto q : l.suff){\n\t\t\tres.suff[q.first + r.tot_num + 1] += q.second;\n\t\t}\n\t}\n\tvector<int> la = arr(l.suff);\n\tvector<int> ra = arr(r.pref);\n\tlong long cur = 0;\n\tcur += 1;\n\tlong long tot = 0;\n\tint j = (int)ra.size();\n\tfor(int i = 0; i < (int)la.size(); i++){\n\t\twhile(j > 0 && (j-1) + 1 + i >= L){\n\t\t\tj -= 1;\n\t\t\ttot += ra[j];\n\t\t}\n\t\tcur += la[i] * tot;\n\t}\n\tans += cur;\n\treturn res;\n}\n\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n >> L;\n\ta.resize(n);\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\n\tvector<int> b(n+2);\n\tvector<int> f(n+2);\n\tfor(int i = 0; i <= n+1; i++){\n\t\tb[i] = i-1;\n\t\tf[i] = i+1;\n\t}\n\tvector<I> data(n+2);\n\tvector<pair<long long, int> > apos;\n\tfor(int i = 0; i < n; i++){\n\t\tapos.push_back({1ll * a[i] * (1e9) + rand(), i+1});\n\t}\n\tsort(apos.begin(), apos.end());\n\tfor(auto _x : apos){\n\t\tint x = _x.second;\n\t\tf[b[x]] = f[x];\n\t\tb[f[x]] = b[x];\n\t\tdata[b[x]] = combine(data[b[x]], a[x-1], data[x]);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (100010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\n#define fi first\n#define se second\n#define mkp make_pair\nint n,m,now,a[N]; pair<int,int> pos[N];\nLL ans; vector<pair<pair<int,int>,pair<int,int> > >t,tmp;\nvector<pair<int,int> > wk,pp;\n//当前位置,当前 \nint calc(vector<pair<int,int> > &a){\n\tLL sum=0,ans=0;\n\tfor(int i=0,j=m-1;j<a.size();i++,j++)\n\tsum+=a[i].fi,ans+=sum*a[j].se;\n\treturn ans;\n}\nint main(){\n\tread(n),read(m),ans=n;\n\tfor(int i=1;i<=n;i++)read(a[i]),pos[i]=mkp(a[i],i);\n\tsort(pos+1,pos+n+1);\n\tfor(int p=1,val=0;p<=n||!t.empty();){\n\t\tcout<<p<<endl;\n\t\tif(t.empty())val=pos[p].fi;else val++;\n\t\tfor(;pos[p].fi==val;p++)t.emplace_back(mkp(pos[p].se,pos[p].se),mkp(1,1));\n\t\ttmp.clear(),sort(t.begin(),t.end());\n//\t\tputs(\"faq\");\n\t\tfor(int i=0,j=0;i<t.size();i=j+1){\n\t\t\tfor(j=i;j+1<t.size()&&t[j+1].fi.fi==t[j].fi.se+1;j++);\n//\t\t\tcout<<t.size()<<\" \"<<i<<\" \"<<j<<endl;\n\t\t\tint len=j-i+1,cnt=len/m;\n\t\t\tif(cnt){\n//\t\t\t\tputs(\"faq2\");\n\t\t\t\twk.clear();\n\t\t\t\tfor(int k=i;k<=j;k++)wk.push_back(t[k].se);\n\t\t\t\tans+=calc(wk),wk.clear(),wk.resize(cnt),pp.clear();\n\t\t\t\tfor(int k=1;k<=cnt;k++)\n\t\t\t\tpp.emplace_back(t[i].fi.fi+k-1,(k==cnt)?t[j].fi.se:t[i].fi.fi+k-1);\n\t\t\t\tfor(int k=i;k<=j;k++){\n\t\t\t\t\tint l=k-i+1,r=j-k+1;\n\t\t\t\t\tif(l>=m)wk[l/m-1].se+=t[k].se.se;\n\t\t\t\t\tif(r>=m)wk[cnt-r/m].fi+=t[k].se.fi;\n\t\t\t\t}\n//\t\t\t\tputs(\"faq3\");\n//\t\t\t\tcout<<cnt<<\" faq \"<<wk.size()<<\" \"<<val<<endl;\n\t\t\t\tans-=calc(wk);\n\t\t\t\tfor(int k=0;k<pp.size();k++)tmp.emplace_back(pp[k],wk[k]);\n//\t\t\t\tcout<<tmp[k].fi.fi<<\" \"<<tmp[k].fi.se<<\" \"<<tmp[k].se.fi<<\" \"<<tmp[k].se.se<<endl;\n\t\t\t}\n\t\t}\n\t\tt=tmp;\n//\t\tcout<<t.size()<<\" faq4\\n\";\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define pii pair<int,int>\n#define riterator reverse_iterator\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 2e5;\npriority_queue<pii,vector<pii>,greater<pii> > que;\nint nxt[N+3],prv[N+3];\nint a[N+3];\nllong cl[N+3],cr[N+3],cl2[N+3],cr2[N+3];\nvector<int> vec;\nint n,m; llong ans;\n\nvoid solve(int l,int r)\n{\n//\tprintf(\"solve %d %d\\n\",l,r);\n\tllong sum = 0ll;\n\tfor(int i=m-1; i<vec.size(); i++)\n\t{\n\t\tsum += cl[vec[i-m+1]];\n\t\tans += cr[vec[i]]*sum;\n\t}\n\tint cnt = (r-l+1)/m;\n\tfor(int i=l; i<=l+cnt-1; i++) cl2[i] = cr2[i] = 0ll;\n\tfor(int i=vec.size()-m,j=0,k=l+cnt-1; i>=0; i--)\n\t{\n\t\tcl2[k] += cl[vec[i]];\n\t\tif(j==m-1) {k--,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=m-1,j=0,k=l; i<vec.size(); i++)\n\t{\n\t\tcr2[k] += cr[vec[i]];\n\t\tif(j==m-1) {k++,j=0;}\n\t\telse {j++;}\n\t}\n\tfor(int i=l; i<=l+cnt-1; i++) cl[i] = cl2[i],cr[i] = cr2[i];\n\tsum = 0ll;\n\tfor(int i=l+m-1; i<=l+cnt-1; i++)\n\t{\n\t\tsum += cl[i-m+1];\n\t\tans -= cr[i]*sum;\n\t}\n\tnxt[l+cnt-1] = nxt[r]; prv[nxt[r]] = l+cnt-1;\n\tfor(int i=l; i<l+cnt-1; i++) nxt[i] = i+1;\n\tfor(int i=l+1; i<=l+cnt-1; i++) prv[i] = i-1;\n\tint val = a[l]; for(int i=l; i<=l+cnt-1; i++) a[i] = val+1;\n\tfor(int i=l; i<=l+cnt-1; i++) que.push(mkpr(a[i],i));\n//\tprintf(\"cnt=%d\\n\",cnt);\n//\tprintf(\"prv: \"); for(int i=1; i<=n; i++) printf(\"%d \",prv[i]); puts(\"\");\n//\tprintf(\"nxt: \"); for(int i=1; i<=n; i++) printf(\"%d \",nxt[i]); puts(\"\");\n//\tprintf(\"cl: \"); for(int i=1; i<=n; i++) printf(\"%lld \",cl[i]); puts(\"\");\n//\tprintf(\"cr: \"); for(int i=1; i<=n; i++) printf(\"%lld \",cr[i]); puts(\"\");\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&a[i]),que.push(mkpr(a[i],i)),cl[i] = cr[i] = 1ll,nxt[i] = i+1,prv[i] = i-1;\n\twhile(1)\n\t{\n\t\tint l = que.top().second,r = l; que.pop(); vec.clear(); vec.push_back(l);\n\t\twhile(!que.empty() && que.top().first==a[l] && que.top().second==nxt[r]) {r = nxt[r]; vec.push_back(r); que.pop();}\n\t\tsolve(l,r);\n\t\tif(prv[l]==0&&nxt[r]==n+1) break;\n\t}\n\tprintf(\"%lld\\n\",ans+n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define last last2\n\nusing namespace std;\n\ntypedef long long ll;\n\nint num[200005],n,L;\nll ans;\n\nnamespace SGT {\n\nint maxv[800000];\n\nvoid build(int l,int r,int o) {\n  if (l==r) maxv[o]=l;\n  else {\n  \tint m=((l+r)>>1);\n    build(l,m,o*2);\n    build(m+1,r,o*2+1);\n    maxv[o]=((num[maxv[o*2]]>=num[maxv[o*2+1]])?maxv[o*2]:maxv[o*2+1]);\n  }\n}\n\nint query(int l,int r,int o,int lx,int rx) {\n  if (l>=lx&&r<=rx) return maxv[o];\n  else {\n  \tint m=((l+r)>>1);\n  \tif (m>=rx) return query(l,m,o*2,lx,rx);\n  \tif (m<lx) return query(m+1,r,o*2+1,lx,rx);\n  \tint a=query(l,m,o*2,lx,rx),b=query(m+1,r,o*2+1,lx,rx);\n  \treturn (num[a]>=num[b])?a:b;\n  }\n}\n\n}\n\nint nxt[200005],powd[200005];\n\nvoid pre() {\n  static int last[200005];\n  powd[0]=1;\n  for(int i=1;i<=n;i++) powd[i]=min((ll)powd[i-1]*L,n+1LL);\n  for(int i=n;i>0;i--) {\n  \tnxt[i]=((last[num[i]])?last[num[i]]:n+1);\n  \tlast[num[i]]=i;\n  } \n}\n\nvector <int> suml[200005],sumr[200005];\nvector <int> pos[200005],son[200005];\nint size[200005],lsize[200005],rsize[200005];\nint val[200005],tot;\n\nvoid calc(int o,int d) {\n  static int sum[200005];\n  size[o]=((size[o]>=powd[d])?size[o]/powd[d]:-1);\n  if (lsize[o]) {\n  \tfor(int i=1;i<=lsize[o];i++) sum[i]=0;\n    int cnt=0,maxn=0;\n    for(int i=powd[d];i<=lsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=suml[o][i];\n    }\n    lsize[o]=maxn;\n    suml[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) suml[o][i]=sum[i];\n  }\n  if (rsize[o]) {\n  \tfor(int i=1;i<=rsize[o];i++) sum[i]=0;\n    int cnt=0,maxn=0;\n    for(int i=powd[d];i<=rsize[o];i++) {\n      maxn=i/powd[d];\n\t  sum[maxn]+=sumr[o][i];\n    }\n    rsize[o]=maxn;\n    sumr[o].resize(maxn+1);\n    for(int i=1;i<=maxn;i++) sumr[o][i]=sum[i];\n  }\n}\n\nint solve(int l,int r) {\n  static int q[200005];\n  int o=++tot;\n  for(int i=SGT::query(1,n,1,l,r);i<=r;i=nxt[i]) \n    pos[o].push_back(i);\n  val[o]=num[pos[o][0]];\n  son[o].resize(pos[o].size()+1);\n  if (pos[o][0]>l) son[o][0]=solve(l,pos[o][0]-1);\n  for(int i=1;i<pos[o].size();i++)\n    if (pos[o][i]>pos[o][i-1]+1) son[o][i]=solve(pos[o][i-1]+1,pos[o][i]-1);\n  if (pos[o][pos[o].size()-1]<r) son[o][son[o].size()-1]=solve(pos[o][pos[o].size()-1]+1,r);\n  for(int i=0;i<son[o].size();i++)\n    if (son[o][i]) calc(son[o][i],val[o]-val[son[o][i]]);\n  int rx=0,lx=0;\n  for(int i=rsize[son[o][0]];i>0;i--) q[++rx]=sumr[son[o][0]][i];\n  int s=0;\n  for(int i=0;i<pos[o].size();i++) {\n  \tq[++rx]=1;\n  \twhile (lx<rx&&rx-lx>=L) s+=q[++lx];\n  \tans+=s;\n  \tif (son[o][i+1]) {\n  \t\tint u=son[o][i+1];\n  \t\tfor(int j=1;j<=lsize[u];j++) {\n  \t\t\twhile (lx<rx&&rx-lx+j>=L) s+=q[++lx];\n  \t\t\tans+=(ll)s*suml[u][j];\n\t\t  }\n\t\tif (size[u]==-1) lx=rx,s=0;\n\t\tfor(int j=rsize[u];j>0;j--) q[++rx]=sumr[u][j];\n\t  }\n  }\n  bool v=1;\n  int sz=pos[o].size();\n  for(int i=0;i<son[o].size();i++)\n    if (size[son[o][i]]==-1) v=0; else sz+=size[son[o][i]];\n  size[o]=((v)?sz:-1);\n  suml[o].resize(1);\n  for(int i=0;i<son[o].size();i++) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=lsize[u];j++) suml[o].push_back(suml[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i+1<son[o].size()) suml[o].push_back(1);\n  }\n  lsize[o]=suml[o].size()-1;\n  sumr[o].resize(1);\n  for(int i=son[o].size()-1;i>=0;i--) {\n  \tint u=son[o][i];\n  \tfor(int j=1;j<=rsize[u];j++) sumr[o].push_back(sumr[u][j]);\n  \tif (size[u]==-1) break;\n  \tif (i) sumr[o].push_back(1);\n  }\n  rsize[o]=sumr[o].size()-1;\n  return o;\n}\n\nint main() {\n  scanf(\"%d%d\",&n,&L);\n  for(int i=1;i<=n;i++) scanf(\"%d\",&num[i]);\n  pre();\n  SGT::build(1,n,1);\n  solve(1,n);\n  printf(\"%lld\\n\",ans+n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 200100;\nint n,l;\n\nint nast[MAX];\nint pop[MAX];\nvector<int> pref[MAX];\nvector<int> suf[MAX];\nint val[MAX];\nint kr[MAX];\nset<PII> secik;\nint res = 0;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> l;\n  res = 0;\n  R(i,n){\n    nast[i] = i + 1;\n    pop[i] = i - 1;\n    cin >> val[i];\n    pref[i] = {1};\n    suf[i] = {1};\n    kr[i] = 1;\n    secik.insert({val[i],i});\n  }\n  while(SZ(secik)){\n    int id = secik.begin()->SE;\n    secik.erase(secik.begin());\n    if(val[id] == -1)continue;\n    int va = val[id];\n    vector<int> gd;\n    int ak = id;\n    while(ak != n && val[ak] == va){\n      gd.PB(ak);\n      val[ak] = -1;\n      ak = nast[ak];\n    }\n    int m = SZ(gd);\n    {\n      int i = 0;\n      int ii = SZ(suf[gd[i]]);\n      int wcze = 0;\n      int mam = 0;\n      for(int j = 1; j < m; j++){\n        R(jj,SZ(pref[gd[j]])){\n          while(i != j && ii + jj + mam + 1 >= l){\n            ii--;\n            wcze += suf[gd[i]][ii];\n            if(ii == 0){\n              i++;\n              mam -= kr[gd[i]];\n              ii = SZ(suf[gd[i]]);\n            }\n          }\n          res += pref[gd[j]][jj] * wcze;\n//           debug(res,wcze,j,jj,i,ii,mam,pref[gd[j]][jj]);\n        }\n        mam += kr[gd[j]];\n      }\n    }\n    R(i,m){\n      debug(val[gd[i]],kr[gd[i]],pref[gd[i]],suf[gd[i]]);\n    }\n    debug(res);\n    \n    \n    vector<int> preff;\n    int all = 0;\n    R(i,m){\n      R(ii,SZ(pref[gd[i]])){\n        all ++;\n        if(all % l == 0)\n          preff.PB(0);\n        if(SZ(preff))\n          preff.back() += pref[gd[i]][ii];\n      }\n    }\n    debug(preff);\n    \n    \n    if(nast[gd.back()] != n){\n      pop[nast[id]] = id;\n    }\n    nast[id] = nast[gd.back()];\n    \n    if(SZ(preff)){\n      pref[id] = preff;\n      kr[id] = SZ(preff);\n      \n      vector<int> suff;\n      all = 0;\n      for(int i = m - 1; i >= 0; i--){\n        R(ii,SZ(suf[gd[i]])){\n          all ++;\n          if(all % l == 0)\n            suff.PB(0);\n          if(SZ(suff))\n            suff.back() += suf[gd[i]][ii];\n        }\n      }\n      \n      val[id] = va + 1;\n      suf[id] = suff;\n      secik.insert({val[id],id});\n    }\n  }\n  cout << res + n << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<set>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=200200;\nint n,L,a[N],pr[N],nx[N],l[N],r[N];\nint vi[N],tl[N],tr[N],p[N];\nll ans;\nstruct cmp{\n\tbool operator()(int x,int y)\n\t\t{return a[x]!=a[y]?a[x]<a[y]:x<y;}\n};\nset<int,cmp>q;\nll calc(int m){\n\tll ret=0,S=0;\n\tFOR(i,1,m){\n\t\tif(i>=L) S+=l[p[i-L+1]];\n\t\tret+=1ll*S*r[p[i]];\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin); \n\tscanf(\"%d%d\",&n,&L);ans=n;\n\tFOR(i,1,n) scanf(\"%d\",&a[i]);\n\tFOR(i,1,n){\n\t\tpr[i]=i-1,nx[i]=i==n?0:i+1;\n\t\tl[i]=r[i]=1;q.insert(i);\n\t}\n\twhile(q.size()){\n\t\tint u=*q.begin(),v,m,t,w=a[u];\n\t\tfor(m=0,v=u;v && a[v]==w;v=nx[v]) \n\t\t\tq.erase(v),p[++m]=v;\n\t\t//FOR(i,1,m) cout<<p[i]<<' ';cout<<'\\n';\n\t\t//FOR(i,1,m) cout<<a[p[i]]<<' ';cout<<'\\n'; \n\t\tp[0]=pr[p[1]],p[m+1]=nx[p[m]];\n\t\tans+=calc(m);t=m/L;//cout<<\"ans=\"<<ans<<'\\n';\n\t\tFOR(i,1,t) tl[i]=tr[i]=0;\n\t\tFOR(i,1,m) tr[i/L]+=r[p[i]],tl[t-(m-i+1)/L+1]+=l[p[i]];\n\t\tFOR(i,1,t) p[i]=v=p[(i-1)*L+1],l[v]=tl[i],r[v]=tr[i],a[v]=w+1,q.insert(v);\n\t\tp[t+1]=p[m+1];\n\t\t//FOR(i,1,t) cout<<l[p[i]]<<'-'<<r[p[i]]<<' ';cout<<'\\n';\n\t\tFOR(i,0,t) pr[p[i+1]]=p[i],nx[p[i]]=p[i+1];\n\t\tpr[0]=nx[0]=0;\n\t\tans-=calc(t);//cout<<\"ans=\"<<ans<<'\\n';\n\t}\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NavigableSet;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int INF = (int) 2e9;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int l = in.nextInt();\n            TreeSet<TaskF.Item> itemsByPos = new TreeSet<>(new Comparator<TaskF.Item>() {\n\n                public int compare(TaskF.Item o1, TaskF.Item o2) {\n                    return o1.pos - o2.pos;\n                }\n            });\n            TreeSet<TaskF.Item> itemsByVal = new TreeSet<>(new Comparator<TaskF.Item>() {\n\n                public int compare(TaskF.Item o1, TaskF.Item o2) {\n                    int z = o1.value - o2.value;\n                    if (z == 0) z = o1.pos - o2.pos;\n                    return z;\n                }\n            });\n            for (int i = 0; i < n; ++i) {\n                TaskF.Item item = new TaskF.Item();\n                item.pos = i;\n                item.value = in.nextInt();\n                item.choicesIfFirst = 1;\n                item.choicesIfLast = 1;\n                itemsByPos.add(item);\n                itemsByVal.add(item);\n            }\n            long res = n;\n            TaskF.Item[] segment = new TaskF.Item[n + 1];\n            int[] sumStarts = new int[n + 1];\n            TaskF.Item[] newItems = new TaskF.Item[n + 1];\n\n            while (!itemsByVal.isEmpty()) {\n                int segmentSize = 0;\n                TaskF.Item left = itemsByVal.first();\n                NavigableSet<TaskF.Item> after = itemsByPos.tailSet(left, true);\n                for (TaskF.Item item : after) {\n                    if (item.value != left.value) {\n                        break;\n                    }\n                    segment[segmentSize++] = item;\n                }\n                for (int i = 0; i < segmentSize; ++i) {\n                    TaskF.Item s = segment[i];\n                    if (!itemsByVal.remove(s)) throw new RuntimeException();\n                    if (!itemsByPos.remove(s)) throw new RuntimeException();\n                }\n                if (segmentSize < l) {\n                    TaskF.Item sentinel = new TaskF.Item();\n                    sentinel.pos = left.pos;\n                    sentinel.value = INF;\n                    itemsByPos.add(sentinel);\n                    continue;\n                }\n                sumStarts[0] = 0;\n                for (int i = 0; i < segmentSize; ++i) {\n                    sumStarts[i + 1] = sumStarts[i] + segment[i].choicesIfFirst;\n                }\n                for (int i = l - 1; i < segmentSize; ++i) {\n                    long ways = segment[i].choicesIfLast * (long) sumStarts[i + 2 - l];\n                    res += ways;\n                }\n                int newCount = segmentSize / l;\n                for (int i = 0; i < newCount; ++i) {\n                    newItems[i] = new TaskF.Item();\n                    newItems[i].value = left.value + 1;\n                    newItems[i].pos = left.pos + i;\n                }\n                for (int i = 0; i + l <= segmentSize; ++i) {\n                    int got = (segmentSize - i) / l;\n                    newItems[newCount - got].choicesIfFirst += segment[i].choicesIfFirst;\n                }\n                for (int i = l - 1; i < segmentSize; ++i) {\n                    int got = (i + 1) / l;\n                    newItems[got - 1].choicesIfLast += segment[i].choicesIfLast;\n                }\n                sumStarts[0] = 0;\n                for (int i = 0; i < newCount; ++i) {\n                    sumStarts[i + 1] = sumStarts[i] + newItems[i].choicesIfFirst;\n                }\n                for (int i = l - 1; i < newCount; ++i) {\n                    long ways = newItems[i].choicesIfLast * (long) sumStarts[i + 2 - l];\n                    res -= ways;\n                }\n                for (int i = 0; i < newCount; ++i) {\n                    itemsByVal.add(newItems[i]);\n                    itemsByPos.add(newItems[i]);\n                }\n            }\n            out.println(res);\n        }\n\n        static class Item {\n            int pos;\n            int value;\n            int choicesIfFirst;\n            int choicesIfLast;\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import itertools\n\n\nN, L = list(map(int,input().strip().split()))\nalist = list(map(int,input().strip().split()))\n\ncount = N \t# 1 factor array must satisfy the condition\nfor x in itertools.combinations(range(N), 2):\n\ti, j = x[0], x[1]\n\t# print(i,j)\n\n# for x in range(1):\n# \ti, j = 1,8\n\n\ttarget_list = alist[i:j+1]\n\tmaximum = max(target_list)\n\tk = maximum+1 # level\n\tneeded_length = L**(k-2)\n\tlength = 0\n\tcondition = True\n\tcount1 = 0\n\tbelowlevel = 0\n\n\tfor index in range(len(target_list)):\n\t\tif target_list[index]==1:\n\t\t\tcount1 = count1+1\n\n\t\t\tif index==len(target_list)-1:\n\t\t\t\tcluster_num = int(count1/L)\n\t\t\t\tif cluster_num==0:\n\t\t\t\t\tcondition = False\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tlength = length+cluster_num\n\t\t\t\t\tcount1 = 0\n\t\t\telif target_list[index+1]!=1:\n\t\t\t\tcluster_num = int(count1/L)\n\t\t\t\tif cluster_num==0:\n\t\t\t\t\tcondition = False\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tlength = length+cluster_num\n\t\t\t\t\tcount1 = 0\n\t\telif target_list[index]==maximum:\n\t\t\tbelowlevel= belowlevel+1+int(length/(needed_length/L))\n\t\t\tlength = 0\n\t\telse:\n\t\t\tlength = length+L**(target_list[index]-2)\n\n\tbelowlevel = belowlevel+int(length/(needed_length/L))\n\n\tif (length!=0) and (length<needed_length/L):\n\t\tcondition = False\n\n\tif (condition==True) and belowlevel>=3:\n\t\tcount = count+1\n\t\t# print(i,j)\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "import itertools\n\n\nN, L = list(map(int,input().strip().split()))\nalist = list(map(int,input().strip().split()))\n\ncount = N \t# 1 factor array must satisfy the condition\nfor x in itertools.combinations(range(N), 2):\n\ti, j = x[0], x[1]\n\n# for x in range(1):\n# \ti, j = 0,3\n\n\ttarget_list = alist[i:j+1]\n\tmaximum = max(target_list)\n\tk = maximum+1 # level\n\tneeded_length = L**(k-2)\n\tlength = 0\n\tcondition = True\n\tcount1 = 0\n\tbelowlevel = 0\n\n\tfor index in range(len(target_list)):\n\t\tif target_list[index]==1:\n\t\t\tcount1 = count1+1\n\n\t\t\tif index==len(target_list)-1:\n\t\t\t\tcluster_num = int(count1/L)\n\t\t\t\tif cluster_num==0:\n\t\t\t\t\tcondition = False\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tlength = length+cluster_num\n\t\t\t\t\tcount1 = 0\n\t\t\telif target_list[index+1]!=1:\n\t\t\t\tcluster_num = int(count1/L)\n\t\t\t\tif cluster_num==0:\n\t\t\t\t\tcondition = False\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tlength = length+cluster_num\n\t\t\t\t\tcount1 = 0\n\t\telif target_list[index]==maximum:\n\t\t\tbelowlevel= belowlevel+1+int(length/(needed_length/L))\n\t\t\tlength = 0\n\t\telse:\n\t\t\tlength = length+L**(target_list[index]-2)\n\n\tbelowlevel = belowlevel+int(length/(needed_length/L))\n\n\tif (length!=0) and (length<needed_length/L):\n\t\tcondition = False\n\n\tif (condition==True) and belowlevel>=L:\n\t\tcount = count+1\n\t\t# print(i,j)\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport numpy as np\nimport sys\n\ndef main():\n\tinput = sys.stdin.readline\n\n\tN, L = list(map(int,input().strip().split()))\n\talist = list(map(int,input().strip().split()))\n\n\tcount = N \t# 1 factor array must satisfy the condition\n\tfor x in itertools.combinations(range(N), 2):\n\t\ti, j = x[0], x[1]\n\n\t# for x in range(1):\n\t\t# i, j = 0,8\n\n\t\ttarget_list = alist[i:j+1]\n\t\tmaximum = max(target_list)\n\t\tlevel_count = np.zeros(maximum, 'int64')\n\t\tpre_num = maximum\n\t\tcondition = True\n\n\t\tfor index in range(len(target_list)):\n\t\t\ttarget = target_list[index]\n\t\t\tlevel_count[target-1] = level_count[target-1]+1\n\n\t\t\tif target>pre_num:\n\t\t\t\tfor ti in range(target-1):\n\t\t\t\t\tif level_count[ti]!=0:\n\t\t\t\t\t\tmoveup = int(level_count[ti]/L)\n\t\t\t\t\t\tif moveup==0:\n\t\t\t\t\t\t\tcondition = False\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tlevel_count[ti+1] = level_count[ti+1]+moveup\n\t\t\t\t\t\t\tlevel_count[ti] = 0\n\n\t\t\tif condition==False:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tpre_num = target\n\n\t\tif condition==True:\n\t\t\tfor ti in range(maximum-1):\n\t\t\t\tif level_count[ti]!=0:\n\t\t\t\t\tmoveup = int(level_count[ti]/L)\n\t\t\t\t\tif moveup==0:\n\t\t\t\t\t\tcondition = False\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tlevel_count[ti+1] = level_count[ti+1]+moveup\n\t\t\t\t\t\tlevel_count[ti] = 0\n\n\t\t\tif (condition==True) and (level_count[-1]>=L):\n\t\t\t\tcount = count+1\n\t\t\t\t# print(i,j)\n\n\tprint(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport numpy as np\nimport sys\n\ndef resolve():\n\tinput = sys.stdin.readline\n\n\tN, L = list(map(int,input().strip().split()))\n\talist = list(map(int,input().strip().split()))\n\n\t# print(alist)\n\n\tcount = N \t# 1 factor array must satisfy the condition\n\tfor x in itertools.combinations(range(N), 2):\n\t\ti, j = x[0], x[1]\n\n\t# for x in range(1):\n\t\t# i, j = 0,8\n\n\t\ttarget_list = alist[i:j+1]\n\t\tmaximum = max(target_list)\n\t\tlevel_count = np.zeros(maximum, 'int64')\n\t\tpre_num = maximum\n\t\tcondition = True\n\n\t\tfor index in range(len(target_list)):\n\t\t\ttarget = target_list[index]\n\t\t\tlevel_count[target-1] = level_count[target-1]+1\n\n\t\t\tif target>pre_num:\n\t\t\t\tfor ti in range(target-1):\n\t\t\t\t\tif level_count[ti]!=0:\n\t\t\t\t\t\tmoveup = int(level_count[ti]/L)\n\t\t\t\t\t\tif moveup==0:\n\t\t\t\t\t\t\tcondition = False\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tlevel_count[ti+1] = level_count[ti+1]+moveup\n\t\t\t\t\t\t\tlevel_count[ti] = 0\n\n\t\t\tif condition==False:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tpre_num = target\n\n\t\tif condition==True:\n\t\t\tfor ti in range(maximum-1):\n\t\t\t\tif level_count[ti]!=0:\n\t\t\t\t\tmoveup = int(level_count[ti]/L)\n\t\t\t\t\tif moveup==0:\n\t\t\t\t\t\tcondition = False\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tlevel_count[ti+1] = level_count[ti+1]+moveup\n\t\t\t\t\t\tlevel_count[ti] = 0\n\n\t\t\tif (condition==True) and (level_count[-1]>=L):\n\t\t\t\tcount = count+1\n\t\t\t\t# print(i,j)\n\n\tprint(count)\n\nif __name__ == \"__main__\":\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport numpy as np\nimport sys\n\ndef main():\n\n\tinput = sys.stdin.readline\n\n\tN, L = list(map(int,input().strip().split()))\n\talist = list(map(int,input().strip().split()))\n\n\tcount = N \t# 1 factor array must satisfy the condition\n\tfor x in itertools.combinations(range(N), 2):\n\t\ti, j = x[0], x[1]\n\n\t# for x in range(1):\n\t\t# i, j = 0,8\n\n\t\ttarget_list = alist[i:j+1]\n\t\tmaximum = max(target_list)\n\t\tlevel_count = np.zeros(maximum, 'int64')\n\t\tpre_num = maximum\n\t\tcondition = True\n\n\t\tfor index in range(len(target_list)):\n\t\t\ttarget = target_list[index]\n\t\t\tlevel_count[target-1] = level_count[target-1]+1\n\n\t\t\tif target>pre_num:\n\t\t\t\tfor i in range(target-1):\n\t\t\t\t\tif level_count[i]!=0:\n\t\t\t\t\t\tmoveup = int(level_count[i]/L)\n\t\t\t\t\t\tif moveup==0:\n\t\t\t\t\t\t\tcondition = False\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tlevel_count[i+1] = level_count[i+1]+moveup\n\t\t\t\t\t\t\tlevel_count[i] = 0\n\n\t\t\tif condition==False:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tpre_num = target\n\n\t\tif condition==True:\n\t\t\tfor i in range(maximum-1):\n\t\t\t\tif level_count[i]!=0:\n\t\t\t\t\tmoveup = int(level_count[i]/L)\n\t\t\t\t\tif moveup==0:\n\t\t\t\t\t\tcondition = False\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tlevel_count[i+1] = level_count[i+1]+moveup\n\t\t\t\t\t\tlevel_count[i] = 0\n\n\t\t\tif (condition==True) and (level_count[-1]>=L):\n\t\t\t\tcount = count+1\n\t\t\t\t# print(i,j)\n\n\tprint(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport numpy as np\nimport sys\n\ndef resolve():\n\tinput = sys.stdin.readline\n\n\tN, L = list(map(int,input().strip().split()))\n\talist = list(map(int,input().strip().split()))\n\n\t# print(alist)\n\n\tcount = N \t# 1 factor array must satisfy the condition\n\tfor x in itertools.combinations(range(N), 2):\n\t\ti, j = x[0], x[1]\n\n\t# for x in range(1):\n\t\t# i, j = 0,8\n\n\t\ttarget_list = alist[i:j+1]\n\t\tmaximum = max(target_list)\n\t\tlevel_count = np.zeros(maximum, 'int64')\n\t\tpre_num = maximum\n\t\tcondition = True\n\n\t\tfor index in range(len(target_list)):\n\t\t\ttarget = target_list[index]\n\t\t\tlevel_count[target-1] = level_count[target-1]+1\n\n\t\t\tif target>pre_num:\n\t\t\t\tfor ti in range(target-1):\n\t\t\t\t\tif level_count[ti]!=0:\n\t\t\t\t\t\tmoveup = int(level_count[ti]/L)\n\t\t\t\t\t\tif moveup==0:\n\t\t\t\t\t\t\tcondition = False\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tlevel_count[ti+1] = level_count[ti+1]+moveup\n\t\t\t\t\t\t\tlevel_count[ti] = 0\n\n\t\t\tif condition==False:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tpre_num = target\n\n\t\tif condition==True:\n\t\t\tfor ti in range(maximum-1):\n\t\t\t\tif level_count[ti]!=0:\n\t\t\t\t\tmoveup = int(level_count[ti]/L)\n\t\t\t\t\tif moveup==0:\n\t\t\t\t\t\tcondition = False\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tlevel_count[ti+1] = level_count[ti+1]+moveup\n\t\t\t\t\t\tlevel_count[ti] = 0\n\n\t\t\tif (condition==True) and (level_count[-1]>=L):\n\t\t\t\tcount = count+1\n\t\t\t\t# print(i,j)\n\n\tprint(count)\n\nif __name__ == \"__main__\":\n    resolve()\n"
  }
]