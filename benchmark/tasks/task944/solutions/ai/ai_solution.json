[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_PACKAGES 100\n\ntypedef struct {\n    int a_grams;\n    int b_grams;\n    int price;\n} Package;\n\nint solve(Package packages[], int n, int target_a, int target_b, int ma, int mb) {\n    int min_cost = INT_MAX;\n    \n    for (int mask = 1; mask < (1 << n); mask++) {\n        int total_a = 0, total_b = 0, total_cost = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                total_a += packages[i].a_grams;\n                total_b += packages[i].b_grams;\n                total_cost += packages[i].price;\n            }\n        }\n        \n        if (ma * total_b == mb * total_a && total_a >= target_a && total_b >= target_b) {\n            min_cost = (total_cost < min_cost) ? total_cost : min_cost;\n        }\n    }\n    \n    return (min_cost == INT_MAX) ? -1 : min_cost;\n}\n\nint main() {\n    int n, ma, mb, target_a, target_b;\n    Package packages[MAX_PACKAGES];\n    \n    scanf(\"%d %d %d %d %d\", &n, &ma, &mb, &target_a, &target_b);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &packages[i].a_grams, &packages[i].b_grams, &packages[i].price);\n    }\n    \n    int result = solve(packages, n, target_a, target_b, ma, mb);\n    \n    if (result == -1) {\n        printf(\"Impossible\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:25:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\ntypedef struct {\n    int a;\n    int b;\n    int price;\n} Package;\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    int Ma, Mb;\n    scanf(\"%d %d\", &Ma, &Mb);\n    \n    int N;\n    scanf(\"%d\", &N);\n    \n    Package packages[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &packages[i].a, &packages[i].b, &packages[i].price);\n    }\n    \n    int min_cost = INT_MAX;\n    int found = 0;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            int total_a = packages[i].a + packages[j].a;\n            int total_b = packages[i].b + packages[j].b;\n            \n            if (total_a == 0 || total_b == 0) continue;\n            \n            int common_divisor = gcd(total_a, total_b);\n            int reduced_a = total_a / common_divisor;\n            int reduced_b = total_b / common_divisor;\n            \n            if (reduced_a == Ma && reduced_b == Mb) {\n                int total_price = packages[i].price + packages[j].price;\n                if (total_price < min_cost) {\n                    min_cost = total_price;\n                    found = 1;\n                }\n            }\n        }\n    }\n    \n    if (found) {\n        printf(\"%d\\n\", min_cost);\n    } else {\n        printf(\"-1\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:25:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Package {\n    int a;\n    int b;\n    int price;\n};\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    int N, Ma, Mb;\n    cin >> N >> Ma >> Mb;\n\n    vector<Package> packages(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> packages[i].a >> packages[i].b >> packages[i].price;\n    }\n\n    int max_a = 0, max_b = 0;\n    for (const auto& pkg : packages) {\n        max_a += pkg.a;\n        max_b += pkg.b;\n    }\n\n    int max_total = max(max_a, max_b) + 1;\n    vector<vector<int>> dp(max_total, vector<int>(max_total, INT_MAX));\n    dp[0][0] = 0;\n\n    for (const auto& pkg : packages) {\n        for (int a = max_total - 1; a >= pkg.a; --a) {\n            for (int b = max_total - 1; b >= pkg.b; --b) {\n                if (dp[a - pkg.a][b - pkg.b] != INT_MAX) {\n                    dp[a][b] = min(dp[a][b], dp[a - pkg.a][b - pkg.b] + pkg.price);\n                }\n            }\n        }\n    }\n\n    int min_cost = INT_MAX;\n    for (int a = 1; a < max_total; ++a) {\n        for (int b = 1; b < max_total; ++b) {\n            if (a * Mb == b * Ma) {\n                if (dp[a][b] < min_cost) {\n                    min_cost = dp[a][b];\n                }\n            }\n        }\n    }\n\n    if (min_cost != INT_MAX) {\n        cout << min_cost << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class ChemicalMixture {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int Ma = scanner.nextInt();\n        int Mb = scanner.nextInt();\n        \n        int[] a = new int[N];\n        int[] b = new int[N];\n        int[] c = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            a[i] = scanner.nextInt();\n            b[i] = scanner.nextInt();\n            c[i] = scanner.nextInt();\n        }\n        \n        int maxA = 400;\n        int maxB = 400;\n        int INF = Integer.MAX_VALUE / 2;\n        int[][][] dp = new int[N + 1][maxA + 1][maxB + 1];\n        \n        for (int i = 0; i <= N; i++) {\n            for (int j = 0; j <= maxA; j++) {\n                for (int k = 0; k <= maxB; k++) {\n                    dp[i][j][k] = INF;\n                }\n            }\n        }\n        dp[0][0][0] = 0;\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j <= maxA; j++) {\n                for (int k = 0; k <= maxB; k++) {\n                    if (dp[i][j][k] == INF) continue;\n                    dp[i + 1][j][k] = Math.min(dp[i + 1][j][k], dp[i][j][k]);\n                    if (j + a[i] <= maxA && k + b[i] <= maxB) {\n                        dp[i + 1][j + a[i]][k + b[i]] = Math.min(dp[i + 1][j + a[i]][k + b[i]], dp[i][j][k] + c[i]);\n                    }\n                }\n            }\n        }\n        \n        int minCost = INF;\n        for (int j = 1; j <= maxA; j++) {\n            for (int k = 1; k <= maxB; k++) {\n                if (j * Mb == k * Ma) {\n                    minCost = Math.min(minCost, dp[N][j][k]);\n                }\n            }\n        }\n        \n        if (minCost != INF) {\n            System.out.println(minCost);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:26:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ChemicalMixture {\n    public static void solve(int M_a, int M_b, int[] quantityA, int[] quantityB, int[] prices) {\n        int n = quantityA.length;\n        int minCost = Integer.MAX_VALUE;\n        boolean possible = false;\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            int totalA = 0, totalB = 0, totalCost = 0;\n\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    totalA += quantityA[i];\n                    totalB += quantityB[i];\n                    totalCost += prices[i];\n                }\n            }\n\n            if (totalA * M_b == totalB * M_a) {\n                minCost = Math.min(minCost, totalCost);\n                possible = true;\n            }\n        }\n\n        if (possible) {\n            System.out.println(minCost);\n        } else {\n            System.out.println(\"impossible\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int M_a = scanner.nextInt();\n        int M_b = scanner.nextInt();\n        int n = scanner.nextInt();\n\n        int[] quantityA = new int[n];\n        int[] quantityB = new int[n];\n        int[] prices = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            quantityA[i] = scanner.nextInt();\n            quantityB[i] = scanner.nextInt();\n            prices[i] = scanner.nextInt();\n        }\n\n        solve(M_a, M_b, quantityA, quantityB, prices);\n    }\n}",
    "timestamp": "2025-08-05 23:26:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, Ma, Mb;\n    cin >> N >> Ma >> Mb;\n\n    vector<tuple<int, int, int>> packages(N);\n    for (int i = 0; i < N; i++) {\n        int a, b, price;\n        cin >> a >> b >> price;\n        packages[i] = {a, b, price};\n    }\n\n    vector<vector<int>> dp(4001, vector<int>(4001, INT_MAX));\n    dp[0][0] = 0;\n\n    for (auto [a, b, price] : packages) {\n        for (int x = 4000; x >= 0; x--) {\n            for (int y = 4000; y >= 0; y--) {\n                if (dp[x][y] == INT_MAX) continue;\n                \n                dp[x + a][y + b] = min(dp[x + a][y + b], dp[x][y] + price);\n            }\n        }\n    }\n\n    int result = INT_MAX;\n    for (int x = 1; x <= 4000; x++) {\n        for (int y = 1; y <= 4000; y++) {\n            if (x * Mb == y * Ma && dp[x][y] != INT_MAX) {\n                result = min(result, dp[x][y]);\n            }\n        }\n    }\n\n    if (result == INT_MAX) {\n        cout << -1 << endl;\n    } else {\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\n\ndef min_cost_for_chemical(substance, ratio_a, ratio_b):\n    num_packages = len(substance)\n    best_cost = float('inf')\n    found = False\n\n    for r in range(1, num_packages + 1):\n        for packages in combinations(substance, r):\n            total_A = sum(p[0] for p in packages)\n            total_B = sum(p[1] for p in packages)\n\n            # Check if the ratio matches\n            if total_A * ratio_b == total_B * ratio_a:\n                total_cost = sum(p[2] for p in packages)\n                best_cost = min(best_cost, total_cost)\n                found = True\n\n    return best_cost if found else \"Not possible\"\n\n# Example of how to call the function with substance list\n# substance = [(grams_A, grams_B, cost), (grams_A, grams_B, cost), ...]\n# ratio_a: amount of A needed\n# ratio_b: amount of B needed\n\nsubstance = [(3, 5, 400), (2, 3, 300), (5, 8, 600)]\nratio_a = 2\nratio_b = 3\n\nprint(min_cost_for_chemical(substance, ratio_a, ratio_b))",
    "timestamp": "2025-08-13 15:19:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ChemicalMixture {\n    public static class Package {\n        int gramsA, gramsB, price;\n\n        public Package(int gramsA, int gramsB, int price) {\n            this.gramsA = gramsA;\n            this.gramsB = gramsB;\n            this.price = price;\n        }\n    }\n\n    public static int minimumPrice(List<Package> packages, int Ma, int Mb) {\n        int n = packages.size();\n        Map<String, Integer> dp = new HashMap<>();\n        dp.put(\"0,0\", 0);\n\n        for (Package pkg : packages) {\n            Map<String, Integer> current = new HashMap<>(dp);\n\n            for (String key : dp.keySet()) {\n                String[] split = key.split(\",\");\n                int gramsA = Integer.parseInt(split[0]);\n                int gramsB = Integer.parseInt(split[1]);\n                int totalPrice = dp.get(key);\n\n                int newGramsA = gramsA + pkg.gramsA;\n                int newGramsB = gramsB + pkg.gramsB;\n                int newPrice = totalPrice + pkg.price;\n\n                String newKey = newGramsA + \",\" + newGramsB;\n                current.put(newKey, Math.min(current.getOrDefault(newKey, Integer.MAX_VALUE), newPrice));\n            }\n            \n            dp = current;\n        }\n\n        int minPrice = Integer.MAX_VALUE;\n        for (String key : dp.keySet()) {\n            String[] split = key.split(\",\");\n            int gramsA = Integer.parseInt(split[0]);\n            int gramsB = Integer.parseInt(split[1]);\n\n            if (gramsA * Mb == gramsB * Ma) {\n                minPrice = Math.min(minPrice, dp.get(key));\n            }\n        }\n\n        return minPrice == Integer.MAX_VALUE ? -1 : minPrice;\n    }\n\n    public static void main(String[] args) {\n        List<Package> packages = Arrays.asList(\n            new Package(3, 5, 10),\n            new Package(8, 5, 20),\n            new Package(1, 2, 5)\n        );\n\n        int Ma = 1, Mb = 1;\n        int result = minimumPrice(packages, Ma, Mb);\n\n        if (result == -1) {\n            System.out.println(\"It's not possible to generate substance C.\");\n        } else {\n            System.out.println(\"Minimum price: \" + result + \" yen\");\n        }\n    }\n}",
    "timestamp": "2025-08-13 15:19:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int a, b, price;\n} Package;\n\n// Helper function to compare packages based on price\nint comparePackages(const void *p1, const void *p2) {\n    return ((Package *)p1)->price - ((Package *)p2)->price;\n}\n\n// Function to check if a ratio can be achieved\nint canAchieveRatio(int total_a, int total_b, int M_a, int M_b) {\n    return total_a * M_b == total_b * M_a;\n}\n\n// Function to find the minimum cost to achieve required ratio\nint findMinCostToAchieveRatio(Package *packages, int n, int M_a, int M_b) {\n    qsort(packages, n, sizeof(Package), comparePackages);\n    int min_cost = INT_MAX;\n\n    for (int i = 0; i < (1 << n); i++) {\n        int total_a = 0, total_b = 0, total_price = 0;\n\n        for (int j = 0; j < n; j++) {\n            if (i & (1 << j)) {\n                total_a += packages[j].a;\n                total_b += packages[j].b;\n                total_price += packages[j].price;\n            }\n        }\n  \n        if (total_a > 0 && total_b > 0 && canAchieveRatio(total_a, total_b, M_a, M_b)) {\n            if (total_price < min_cost) {\n                min_cost = total_price;\n            }\n        }\n    }\n\n    return min_cost == INT_MAX ? -1 : min_cost;\n}\n\nint main() {\n    int n, M_a, M_b;\n    scanf(\"%d %d %d\", &n, &M_a, &M_b);\n\n    Package packages[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &packages[i].a, &packages[i].b, &packages[i].price);\n    }\n\n    int result = findMinCostToAchieveRatio(packages, n, M_a, M_b);\n    if (result == -1) {\n        printf(\"Not possible\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:19:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconst int INF = 1e9;\n\nstruct Package {\n    int a, b, cost;\n};\n\nint gcd(int a, int b) {\n    while (b) {\n        int t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\nint main() {\n    int N, Ma, Mb;\n    std::cin >> N >> Ma >> Mb;\n    \n    std::vector<Package> packages(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> packages[i].a >> packages[i].b >> packages[i].cost;\n    }\n\n    int maxSumA = 0, maxSumB = 0;\n    for (const auto& pkg : packages) {\n        maxSumA += pkg.a;\n        maxSumB += pkg.b;\n    }\n\n    int d = gcd(Ma, Mb);\n    Ma /= d;\n    Mb /= d;\n\n    std::vector<std::vector<int>> dp(maxSumA + 1, std::vector<int>(maxSumB + 1, INF));\n    dp[0][0] = 0;\n\n    for (const auto& pkg : packages) {\n        for (int i = maxSumA - pkg.a; i >= 0; --i) {\n            for (int j = maxSumB - pkg.b; j >= 0; --j) {\n                if (dp[i][j] != INF) {\n                    dp[i + pkg.a][j + pkg.b] = std::min(dp[i + pkg.a][j + pkg.b], dp[i][j] + pkg.cost);\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int a = Ma, b = Mb; a <= maxSumA && b <= maxSumB; a += Ma, b += Mb) {\n        ans = std::min(ans, dp[a][b]);\n    }\n\n    if (ans == INF) {\n        std::cout << -1 << std::endl;\n    } else {\n        std::cout << ans << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:20:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_minimum_cost(M_a, M_b, packages, C):\n    n = len(packages)\n    min_cost = float('inf')\n    possible = False\n\n    def backtrack(index, total_a, total_b, current_cost):\n        nonlocal min_cost, possible\n\n        if total_a * M_b == total_b * M_a and total_a + total_b >= C:\n            min_cost = min(min_cost, current_cost)\n            possible = True\n            return\n\n        if index == n or total_a * M_b > total_b * M_a or current_cost >= min_cost:\n            return\n\n        package = packages[index]\n        \n        # Include current package\n        backtrack(index + 1, total_a + package[0], total_b + package[1], \n                  current_cost + package[2])\n        \n        # Skip current package\n        backtrack(index + 1, total_a, total_b, current_cost)\n\n    backtrack(0, 0, 0, 0)\n\n    return min_cost if possible else -1\n\n# Example usage\n# packages format: [(grams_A, grams_B, price), ...]\n# M_a, M_b are ratio of A and B\n# C is total grams needed",
    "timestamp": "2025-08-13 15:20:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef solve():\n    N, Ma, Mb = map(int, input().split())\n    packages = []\n    for _ in range(N):\n        a, b, cost = map(int, input().split())\n        packages.append((a, b, cost))\n    \n    INF = float('inf')\n    max_a = 40 * 10\n    max_b = 40 * 10\n    dp = [[INF] * (max_b + 1) for _ in range(max_a + 1)]\n    dp[0][0] = 0\n    \n    for a, b, cost in packages:\n        for i in range(max_a, -1, -1):\n            for j in range(max_b, -1, -1):\n                if dp[i][j] != INF:\n                    ni = i + a\n                    nj = j + b\n                    if ni <= max_a and nj <= max_b:\n                        if dp[ni][nj] > dp[i][j] + cost:\n                            dp[ni][nj] = dp[i][j] + cost\n    \n    min_cost = INF\n    for i in range(1, max_a + 1):\n        for j in range(1, max_b + 1):\n            if i * Mb == j * Ma:\n                if dp[i][j] < min_cost:\n                    min_cost = dp[i][j]\n    \n    if min_cost != INF:\n        print(min_cost)\n    else:\n        print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 15:20:20"
  }
]