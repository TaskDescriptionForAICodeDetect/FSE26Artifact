[
  {
    "language": "Fortran",
    "code": "module modulo_util\n  implicit none\n  integer(8), parameter :: md = 1000000007_8\n  integer(8), allocatable :: f(:), invf(:)\ncontains\n  subroutine init(n)\n    integer, intent(in) :: n\n    integer :: i\n    if (allocated(f)) deallocate(f)\n    if (allocated(invf)) deallocate(invf)\n    allocate(f(0:n),invf(0:n))\n    f = 0_8\n    invf = 0_8\n    f(0) = 1_8\n    do i = 1, n\n      f(i) = mod(f(i-1)*int(i,8),md)\n    end do\n    invf(n) = inv(f(n))\n    do i = n, 1, -1\n      invf(i-1) = mod(invf(i)*int(i,8),md)\n    end do\n  end\n  integer(8) function perm(n,k)\n    integer, intent(in) :: n, k\n    perm = 0_8\n    if (k > n .or. n < 0 .or. k < 0) return\n    perm = mod(f(n)*invf(n-k),md)\n  end\n  integer(8) function comb(n,k)\n    integer, intent(in) :: n, k\n    comb = mod(perm(n,k)*invf(k),md)\n  end\n  integer(8) function homo(n,k)\n    integer, intent(in) :: n, k\n    homo = 1_8\n    if (n == 0 .and. k == 0) return\n    homo = comb(n+k-1,k)\n  end\n  function inv(n) result(y)\n    integer(8), intent(in) :: n\n    integer(8) :: a, b, x, y, t, q\n    a = modulo(n,md)\n    b = md\n    x = 0_8\n    y = 1_8\n    do while (b /= 0_8)\n      q = a/b\n      t = b\n      b = mod(a,b)\n      a = t\n      t = y\n      y = x\n      x = t-q*x\n    end do\n    y = modulo(y,md)\n  end\n  function pow(a,b) result(r)\n    integer(8), intent(in) :: a\n    integer, intent(in) :: b\n    integer :: k\n    integer(8) :: r, p\n    r = 1_8\n    p = a\n    k = b\n    do while (k > 0)\n      if (btest(k,0)) r = mod(r*p,md)\n      p = mod(p*p,md)\n      k = rshift(k,1)\n    end do\n  end\nend module modulo_util\nprogram card_game_for_three\n  use modulo_util\n  implicit none\n  integer :: n, m, k, i\n  integer(8) :: ans = 0_8, p(0:900000) = 0_8, w = 1_8\n  read(*,*) n, m, k\n  if (m < k) then\n    m = xor(m,k)\n    k = xor(m,k)\n    m = xor(m,k)\n  end if\n  call init(n+m+k)\n  p(0) = 1_8\n  do i = 1, n+m+k\n    p(i) = mod(3_8*p(i-1),md)\n  end do\n  do i = 0, m+k\n    ans = mod(ans+w*mod(comb(n+i-1,n-1)*p(m+k-i),md),md)\n    if (i < k) then\n      w = mod(2_8*w,md)\n    else if (i < m) then\n      w = modulo(2_8*w-comb(i,k),md)\n    else\n      w = modulo(2_8*w-comb(i,k)-comb(i,i-m),md)\n    end if\n  end do\n  write(*,'(i0)') ans\nend program card_game_for_three"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,M,K,fac[MAXN],invfac[MAXN],pw[MAXN];\nint s[MAXN];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint C(int n,int m) {\n    if(n < m) return 0;\n    else return mul(fac[n],mul(invfac[m],invfac[n - m]));\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n\tif(c & 1) res = mul(res,t);\n\tt = mul(t,t);\n\tc >>= 1;\t\n    }\n    return res;\n}\nvoid Solve() {\n    read(N);read(M);read(K);\n    fac[0] = 1;\n    for(int i = 1 ; i <= 1000000 ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[1000000] = fpow(fac[1000000],MOD - 2);\n    for(int i = 999999 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    pw[0] = 1;\n    for(int i = 1 ; i <= 1000000 ; ++i) pw[i] = mul(pw[i - 1],3);\n    int l = 0,r = 0;s[0] = 1;\n    for(int i = 1 ; i <= M + K ; ++i) {\n\tint tmp = inc(mul(s[i - 1],2),inc(C(i - 1,r + 1),MOD - C(i - 1,l)));\n\tif(r + 1 <= i && r + 1 <= M) {update(tmp,C(i,r + 1));++r;}\n\tif(i - l > K) {update(tmp,MOD - C(i,l));++l;}\n\ts[i] = tmp;\n    }\n    int ans = 0;\n    for(int i = 0 ; i <= M + K ; ++i) {\n\tint t = mul(C(N - 1 + i,N - 1),s[i]);\n\tt = mul(t,pw[M + K - i]);\n\tupdate(ans,t);\n    }\n    out(ans);enter;\n}\n\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l, p = 1000000007, o = 1, z;\nint f[1000020];\nint v[1000020];\nint t[1000020];\nint C(int n, int m) {\n\treturn (long long)f[n] * v[m] % p * v[n - m] % p;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &l);\n\tt[0] = f[0] = v[0] = v[1] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tv[i] = (long long)v[p % i] * (p - p / i) % p;\n\t}\n\tfor (int i = 1; i <= 1000000; i++) {\n\t\tf[i] = (long long)f[i - 1] * i % p;\n\t\tv[i] = (long long)v[i - 1] * v[i] % p;\n\t\tt[i] = (long long)t[i - 1] * 3 % p;\n\t}\n\tfor (int i = 0; i <= m + l; i++) {\n\t\tz = (z + (long long)o * C(n + i - 1, n - 1) % p * t[m + l - i]) % p;\n\t\to = o * 2 % p;\n\t\tif (i >= m) {\n\t\t\to = (o + p - C(i, m)) % p;\n\t\t}\n\t\tif (i >= l) {\n\t\t\to = (o + p - C(i, l)) % p;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", z);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MOD = 1e9 + 7;\nconst int N = 3030;\n\nconst int INV3 = MOD/3 + 1;\nll inv[N], pot[N], fact[N], ifact[N]; \n\nvector<ll> unit(int g) {\n    vector<ll> ans(g+1);\n    ans[g] = ifact[g];\n    return ans;\n}\n\nvector<ll> gen(int g) {\n    vector<ll> ans(g+1);\n    ans[0] = pot[g];\n    forsn(i,1,g+1) ans[i] = ans[i-1] * INV3 % MOD * inv[i] % MOD;\n    return ans;\n}\n\nvoid add(ll &x, ll v) {\n    x += v;\n    if (x >= MOD) x -= MOD;\n}\n\nvector<ll> operator*(const vector<ll> &a, const vector<ll> &b) {\n    int n = si(a), m = si(b);\n    vector<ll> c(n+m-1);\n    forn(i,n) forn(j,m) add(c[i+j], a[i]*b[j]%MOD);\n    return c;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    inv[1] = 1; forsn(n,2,N) inv[n] = (MOD - MOD/n) * inv[MOD%n] % MOD;\n    fact[0] = 1; forsn(n,1,N) fact[n] = n*fact[n-1]%MOD;\n    ifact[0] = 1; forsn(n,1,N) ifact[n] = inv[n]*ifact[n-1] % MOD;\n    pot[0] = 1; forsn(n,1,N) pot[n] = pot[n-1] * 3LL % MOD;\n\n    int a,b,c; cin >> a >> b >> c;\n    vector<ll> p = unit(a-1), q = gen(b), r = gen(c);\n\n    auto res = p*q*r;\n\n    ll ans = 0;\n    forn(i,si(res)) add(ans, fact[i] * res[i] % MOD);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef long double DD;\nconst int inf = 1e9;\nconst int mo= 1e9+7;\nconst int N = 9e5+10;\nint n, m, k, fac[N], inv[N], tmp[N], mi[N];\n\n\nint C(int n, int m){\n\treturn 1ll * fac[n] * inv[m] % mo * inv[n - m] % mo;\n}\n\nint pow(int a, int k){\n\tint ans=1;\n\tfor(; k; k =k >> 1, a = 1ll * a * a % mo)\n\t\tif(k & 1)\n\t\t\tans = 1ll * ans * a % mo;\n\treturn ans;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(false);\n\tcout.tie(false);\n\tcin >> n >> m >> k;\n\tfac[0] = 1;\n\tfor(int i = 1; i <= 900000; i++){\n\t\tfac[i] = 1ll * fac[i-1] * i % mo;\n\t}\n\tinv[900000] = pow(fac[900000], mo - 2);\n\tinv[0] = 1;\n\tint sz = m + k;\n\tfor(int i = 899999; i ; i--)\n\t\tinv[i] = 1ll * inv[i + 1] * (i + 1) % mo;\n\tmi[0] = 1;\n\tfor(int i = 1; i <= sz; i++)\n\t\tmi[i] = mi[i - 1] * 3ll % mo;\n\t\n\tLL ans = 0,sum = 1;\n\tfor(int i = 0; i <= sz; i++){\n\t\tans = (ans + 1ll * sum * C(i + n -1, n - 1) % mo * mi[sz - i] )% mo;\n\t\tsum=(sum<<1)%mo;\n\t\tif(i >= m)\n\t\t\tsum = (sum - C(i, m) + mo) % mo;\n\t\tif(i >= k)\n\t\t\tsum = (sum - C(i, i - k) + mo) % mo;\n\t\t\t\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n\treturn ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n\treturn ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n\tint ans = 1 , base = a ;\n\twhile( b ) {\n\t\tif( b&1 ) ans = mul( ans , base ) ;\n\t\tbase = mul( base , base ) ; \n\t\tb >>= 1 ;\n\t}\n\treturn ans ;\n}\n\nll inv( ll x ) {\n\treturn power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n\treturn ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n\tscanf( \"%d%d%d\" , &n , &m , &k ) ;\n\tfac[ 0 ] = 1ll ;\n\tp[ 0 ] = 1ll ;\n\tfor( int i = 1 ; i < N ; i ++ ) {\n\t\tfac[ i ] = fac[ i - 1 ] * i % mod ;\n\t\tp[ i ] = p[ i - 1 ] * 3ll % mod ;\n\t}\n\tfor( int i = 0 ; i < N ; i ++ ) {\n\t\tifac[ i ] = inv( fac[ i ] ) ;\n\t}\n\tll ans = 0 , x = 1ll ;\n\tn -- ;\n\tif( k > m ) swap( k , m ) ;\n\tfor( int i = 0 ; i <= m + k ; i ++ ) {\n\t\tans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n\t\tfor( int j = 0 ; j <= min( i , m - 1 ) ; j ++ ) {\n\t\t\tif( i - j < k ) x = add( x , C( i , j ) ) ;\n\t\t\telse if( i - j < m ) x = add( x , C( i , i - k + 1 ) ) ;\n\t\t}\n\t\t/*\n\t\tif( i < k ) x = ( x * 2ll ) % mod ;\n\t\telse if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n\t\telse  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n\t\t*/\n\t}\n\tprintf( \"%lld\\n\" , add( ans , mod ) ) ;\n\treturn 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3e5 +10, MOD = 1e9 + 7;\n\nint n, m, k, a[N << 2], b[N << 2], c[N << 2], d[N << 2], sum, ans;\n\nint zadd (int a, int b) {return a + b >= MOD ? a + b - MOD : a + b;}\nint zsub (int a, int b) {return a - b < 0 ? a - b + MOD : a - b;}\nint zmul (int a, int b) {return (long long)a * b % MOD;}\n\nvoid init ()\n{\n\tscanf ( \"%d%d%d\" , &n, &m, &k);\n\ta[0] = b[0] = c[1] = d[0] = 1;\n\tfor (int i = 2; i <= N * 3; ++ i)\n\t\tc[i] = zmul (zsub (MOD, MOD / i), c[MOD % i]);\n\tfor (int i = 1; i <= N * 3; ++ i)\n\t{\n\t\ta[i] = zmul (a[i - 1], 3);\n\t\tb[i] = zmul (b[i - 1], i);\n\t\td[i] = zmul (d[i - 1], c[i]);\n\t}\n}\n\nint gg (int x, int y){return zmul (b[x], zmul (d[y], d[x - y]) );}\n\nvoid work ()\n{\n\tif (m < k) swap(m, k); -- n;\n\tsum = 0, ans = 1;\n\tfor (int i = 0; i <= m + k; ++ i)\n\t{\n\t\tsum = zadd (sum, zmul (gg (n + i, n), zmul (a[m + k - i], ans) ) );\n\t\tif (i < k) ans = zmul (ans, 2);\n\t\telse if (i < m) ans = zsub (zmul (ans, 2), gg (i, k) );\n\t\telse ans = zsub (zmul (ans, 2), zadd (gg (i, m), gg (i, k) ) );\n\t}\n}\n\nvoid prin ()\n{\n\tprintf ( \"%d\" , sum);\n}\n\nint main ()\n{\n\tinit ();\n\twork ();\n\tprin ();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod  1000000007\nll modpow(ll x,ll n)\n{\n\tll res=1;\n\twhile(n>0)\n\t{\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[1000005],R[1000005],th[1000005],tw[1000005];\nvoid make(){\n\tF[0] = th[0] = tw[0] = 1;\n\tfor(int i=1;i<1000005;i++){\n\t\tF[i] = F[i-1]*i%mod;\n\t\tth[i]  = th[i-1]*3LL%mod;\n\t\ttw[i] = tw[i-1]*2LL%mod;\n\t}\n\tfor(int i=0;i<1000005;i++) R[i] = modpow(F[i],mod-2);\n}\nll C(int n,int m){\n\treturn F[n] * R[m] % mod * R[n-m] % mod;\n}\nint main(){\n\tint n,m,k; cin >> n >> m >> k;\n\tif(m>k) swap(m,k);\n\tmake();\n\tll ret = 0;\n\tfor(int i=0;i<=m;i++){\n\t\t//for(int j=0;j<=k;j++){\n\t\t\tll sum = C(n+i-1,n-1) * tw[i] % mod;\n\t\t\tsum *= th[m+k-i];\n\t\t\tsum %= mod;\n\t\t\tret += sum;\n\t//\t}\n\t}\n\tll beg = tw[m];\n\tfor(int i=m+1;i<=k;i++){\n\t\t//for(int j=0;j<=k;j++){\n\t\t\tbeg = beg*2LL-C(i-1,m);\n\t\t\tbeg = (beg%mod+mod)%mod;\n\t\t\tll sum = C(n+i-1,n-1) * beg % mod;\n\t\t\tsum *= th[m+k-i];\n\t\t\tsum %= mod;\n\t\t\tret += sum;\n\t//\t}\n\t}\n\tfor(int i=k+1;i<=m+k;i++){\n\t\t//for(int j=0;j<=k;j++){\n\t\t\tbeg = beg*2LL-C(i-1,m)-C(i-1,i-k-1);\n\t\t\tbeg = (beg%mod+mod)%mod;\n\t\t\tll sum = C(n+i-1,n-1) * beg % mod;\n\t\t\tsum *= th[m+k-i];\n\t\t\tsum %= mod;\n\t\t\tret += sum;\n\t//\t}\n\t}\n\tcout << ret%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint A, B, C;\nllint beki2[300005], beki3[300005];\nllint dp[300005];\n\nllint fact[300005], fact_inv[300005];\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 300005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 300005; i++){\n\t\tfact_inv[i] = pow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> A >> B >> C;\n\tif(B > C) swap(B, C);\n\t\n\tmake_fact();\n\t\n\tllint mul = 1;\n\tfor(int i = 0; i < 300005; i++){\n\t\tbeki2[i] = mul;\n\t\tmul *= 2, mul %= mod;\n\t}\n\tmul = 1;\n\tfor(int i = 0; i < 300005; i++){\n\t\tbeki3[i] = mul;\n\t\tmul *= 3, mul %= mod;\n\t}\n\t\n\tfor(int i = 0; i <= B; i++) dp[i] = beki2[i];\n\tfor(int i = B; i < C; i++){\n\t\tdp[i+1] = (2 * dp[i] + mod - comb(i, B)) % mod;\n\t\tdp[i+1] %= mod;\n\t}\n\tfor(int i = C; i < 300005; i++){\n\t\tdp[i+1] = (2 * dp[i] + 2 * mod - (comb(i, i-C) + comb(i, B))) % mod;\n\t\tdp[i+1] %= mod;\n\t}\n\t\n\tllint ans = 0, tmp;\n\tfor(int i = 0; i <= B+C; i++){\n\t\ttmp = comb(A+i-1, i) * dp[i] % mod * beki3[B+C-i] % mod;\n\t\tans += tmp, ans %= mod;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\nconst int NMAX = 3e5 + 5;\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nint fct[2 * NMAX], ifct[2 * NMAX], p3[2 * NMAX];\nint cnt[NMAX];\n\nint power(int x, int y)\n{\n    if(y == 0)  return 1;\n    int ans = power( (1LL * x * x) % mod, y >> 1 );\n    if(y & 1)   ans = (1LL * ans * x) % mod;\n    return ans;\n}\n\nvoid pre(int N)\n{\n    fct[0] = 1;\n    for(int i = 1; i <= N; i++) fct[i] = (1LL * fct[i - 1] * i) % mod;\n    ifct[N] = power(fct[N], mod - 2);\n    for(int i = N - 1; i >= 0; i--) ifct[i] = (1LL * ifct[i + 1] * (i + 1)) % mod;\n\n    p3[0] = 1;\n    for(int i = 1; i <= N; i++) p3[i] = (3LL * p3[i - 1]) % mod;\n}\n\nint C(int N, int K)\n{\n    if(N < 0 || K < 0 || N < K)  return 0;\n    int ans = fct[N];\n    ans = (1LL * ans * ifct[K]) % mod;\n    ans = (1LL * ans * ifct[N - K]) % mod;\n    return ans;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    pre(2 * NMAX);\n\n    scanf(\"%d%d%d\", &N, &M, &K);\n\n    cnt[0] = 1;\n    int lstst = 0, lstdr = 0, lstans = 1;\n    for(int i = 1; i <= M + K; i++)\n    {\n        int st = max(0, i - K);\n        int dr = min(M, i);\n        int ans = (2LL * lstans + C(i - 1, lstst - 1) - C(i - 1, lstdr)) % mod;\n        while(lstst < st)\n        {\n            ans = (ans - C(i, lstst) + mod) % mod;\n            lstst++;\n        }\n        lstdr++;\n        while(lstdr <= dr)\n        {\n            ans = (ans + C(i, lstdr)) % mod;\n            lstdr++;\n        }\n\n        lstst = st, lstdr = dr, lstans = ans;\n        cnt[i] = ans;\n    }\n\n    int ans = 0;\n    for(int i = N; i <= N + M + K; i++)\n    {\n        int sol = (1LL * C(i - 1, N - 1) * cnt[i - N]) % mod;\n        sol = (1LL * sol * p3[N + M + K - i]) % mod;\n        ans = (ans + sol) % mod;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n\ncs ll mod=1000000007;\n\nll fac[1000001]={1,1},inv[1000001]={1,1},ifac[1000001]={1,1};\n\ninline\nll C(int n,int m){\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint n,m,k,maxn;\n\nsigned main(){\n\t\n\tfor(int re i=2;i<=1000000;++i)\n\tfac[i]=fac[i-1]*i%mod,\n\tinv[i]=(mod-mod/i)*inv[mod%i]%mod,\n\tifac[i]=ifac[i-1]*inv[i]%mod;\n\t\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\t--n;\n\tmaxn=max(n,m+k);\n\tll sum=1,ans=1;\n\tfor(int re i=1;i<=m+k;++i){\n\t\tsum=(sum<<1)%mod;\n\t\tif(i>m)sum=(sum+mod-C(i-1,m))%mod;\n\t\tif(i>k)sum=(sum+mod-C(i-1,k))%mod;\n\t\tans=ans*3%mod;\n\t\tans=(ans+C(n+i,i)*sum%mod)%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <limits>\n#include <memory>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) static_cast<int>((a).size())\n#define fillchar(a, x) memset(a, x, sizeof(a))\n#define rep(i, a, b) for(int i=int(a); i<=int(b); ++i)\n#define irep(i, a, b) for(int i=int(a); i>=int(b); --i)\n#define replr(i, a, b) rep(i, a, (b)-1)\n#define reprl(i, a, b) irep(i, (b)-1, a)\n#define repn(i, n) rep(i, 0, (n)-1)\n#define irepn(i, n) irep(i, (n)-1, 0)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\ntypedef long long LL;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\ntypedef pair<double,double> PDD;\ntypedef vector<LL> VL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPI;\ntypedef vector<string> VS;\ntemplate<class T, class S> ostream& operator<<(ostream& os, const pair<T, S>& v) { return os<<\"(\"<<v.first<<\", \"<<v.second<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& v) { os<<\"[\"; repn(i, sz(v)) { if(i) os<<\", \"; os<<v[i]; } return os<<\"]\"; }\ntemplate<class T> bool setmax(T &_a, T _b) { if(_b>_a) { _a=_b; return true; } return false; }\ntemplate<class T> bool setmin(T &_a, T _b) { if(_b<_a) { _a=_b; return true; } return false; }\ntemplate<class T> T gcd(T _a, T _b) { return _b==0?_a:gcd(_b,_a%_b); }\n\nconst LL MOD=LL(1e9)+7;\nconst int N=900010;\n\nLL m2[N], m3[N], inv[N], fac[N], inv_fac[N];\n\nvoid pre() {\n    m2[0]=m3[0]=1;\n    rep(i, 1, N-1) {\n        m2[i]=m2[i-1]*2%MOD;\n        m3[i]=m3[i-1]*3%MOD;\n    }\n    inv[1]=1;\n    rep(i, 2, N-1) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;\n    fac[0]=inv_fac[0]=1;\n    rep(i, 1, N-1) {\n        fac[i]=fac[i-1]*i%MOD;\n        inv_fac[i]=inv_fac[i-1]*inv[i]%MOD;\n    }\n}\n\nLL binom(int n, int r) {\n    if(r<0 || r>n) return 0;\n    LL ans=fac[n]*inv_fac[r]%MOD*inv_fac[n-r]%MOD;\n    return ans;\n}\n\nint cn, cs, ct;\nLL cans;\n\nLL query(int n, int s, int t) {\n    while(cn<n) {\n        cans=(cans*2+binom(cn, cs-1)-binom(cn, ct))%MOD;\n        ++cn;\n    }\n    while(cs<s) cans=(cans-binom(cn, cs++))%MOD;\n    while(cs>s) cans=(cans+binom(cn, --cs))%MOD;\n    while(ct<t) cans=(cans+binom(cn, ++ct))%MOD;\n    while(ct>t) cans=(cans-binom(cn, ct--))%MOD;\n    cans=(cans+MOD)%MOD;\n    return cans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\n    pre();\n    int n, m, k; cin>>n>>m>>k; --n;\n\n    cn=cs=ct=0, cans=1;\n    LL ans=0;\n    rep(p, 0, m+k) {\n        LL cur=m3[m+k-p];\n        (cur*=binom(n+p, n))%=MOD;\n        (cur*=query(p, max(0,p-k), min(p,m)))%=MOD;\n        (ans+=cur)%=MOD;\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1e5 + 1, Mod = 1e9 + 7;\n\nnamespace Mathscalc {\n    inline int Add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\n    inline int Sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\n    inline int Mul(int a, int b) { return 1LL * a * b % Mod; }\n} using namespace Mathscalc;\n\nint n, m, k;\n\nint jc[MAXN << 2], inv[MAXN << 2], invj[MAXN << 2], p[MAXN << 2];\nvoid GetNeed() {\n    p[0] = 1; for (int i = 1; i <= n * 3; ++i) p[i] = Mul(p[i - 1], 3);\n    jc[0] = 1; for (int i = 1; i <= n * 3; ++i) jc[i] = Mul(jc[i - 1], i);\n    inv[1] = 1; for (int i = 2; i <= n * 3; ++i) inv[i] = Mul(Sub(Mod, Mod / i), inv[Mod % i]);\n    invj[0] = 1; for (int i = 1; i <= n * 3; ++i) invj[i] = Mul(invj[i - 1], inv[i]);\n}\n\ninline int C(int n, int m) { return Mul(jc[n], Mul(invj[m], invj[n - m])); }\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &k);\n    GetNeed();\n    if (m < k) std :: swap(m, k); --n;\n    int ans = 0, x = 1;\n    for (int i = 0; i <= m + k; ++i) {\n        ans = Add(ans, Mul(C(n + i, n), Mul(p[m + k - i], x)));\n        if (i < k) x = Mul(x, 2);\n        else if (i < m) x = Sub(Mul(x, 2), C(i, k));\n        else x = Sub(Mul(x, 2), Add(C(i, m), C(i, k)));\n    }\n\tprintf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Author       : Sun YaoFeng\n//============================================================================\n\n//#pragma \tcomment(linker, \"/STACK:100240000,100240000\")\n//#include\t<cstdio>\n//#include\t<cstdlib>\n//#include\t<cstring>\n//#include\t<algorithm>\n\n#include\t<bits/stdc++.h>\n\nusing\tnamespace\tstd;\n\n#define DB\t\tdouble\n#define\tlf\t\telse if\n#define I64\t\tlong long\n#define\tRd()\t(rand()<<15|rand())\n#define For(i,a,b)\tfor(int i=a,lim=b;i<=lim;i++)\n#define Rep(i,a,b)\tfor(int i=a,lim=b;i>=lim;i--)\n\n#define\tfi\tfirst\n#define se\tsecond\n#define MK\tmake_pair\n#define PA\tpair<int, int>\n\n//#define\tmin(a,b)\t((a)<(b)?(a):(b))\n//#define\tmax(a,b)\t((a)<(b)?(b):(a))\n\n#define\tCH\t(ch=getchar())\nint\t\tIN()\t{\n\t\tint x= 0, f= 0, ch;\n\t\tfor\t(; CH < '0' || ch > '9';)\tf= (ch == '-');\n\t\tfor\t(; ch >= '0' && ch <= '9'; CH)\tx= x*10 + ch -'0';\n\t\treturn\tf? -x : x;\n}\n\n#define\tn\t1000005\n#define P\t1000000007\n\nint\t\tN, M, K, T, Ans, L[n], R[n], H[n];\n\nint\t\tPow(int a,int b){\n\t\tint ret=1;\n\t\tfor (;b;b>>=1,a=1ll*a*a%P)\n\t\t\tif  (b&1)\tret=1ll*ret*a%P;\n\t\treturn\tret;\n}\n\nint\t\tC(int a, int b){\n\t\treturn\t1ll*L[a]*R[b]%P*R[a-b]%P;\n}\n\nint\t\tmain(int argc, char* argv[]){\n\t\tN= IN()-1;\n\t\tM= IN();\n\t\tK= IN();\n\t\tT= N+M+K;\n\t\n\t\tL[0]= 1;\n\t\tFor(i, 1, T)\tL[i]= 1ll*L[i-1]*i%P;\n\t\t\n\t\tR[T]= Pow(L[T], P-2);\n\t\tRep(i, T, 1)\tR[i-1]= 1ll*R[i]*i%P;\n\t\t\n\t\tH[0]= 1;\n\t\tFor(i, 1, T)\tH[i]= 1ll*H[i-1]*3%P;\n\t\t\n\t\tint sum= 1;\n\t\tFor(t, 0, M+K)\t{\n\t\t\tAns= (1ll*C(N+t, N)*H[M+K-t]%P*sum + Ans)%P;\n\t\t\tsum= (sum + sum)%P;\n\t\t\t\n\t\t\tif\t(t >= M)\tsum= (sum - C(t, M) + P)%P;\n\t\t\tif\t(t >= K)\tsum= (sum - C(t, K) + P)%P;\n\t\t}\n\t\tprintf(\"%d\\n\", Ans);\n\t\t\n\t\treturn\t0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int mod=1e9+7;\nconst int MAXN=3005;\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nint pre[MAXN],inv[MAXN],n,m,K;\nint C(int n,int m){return 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN-1]=pow_mod(pre[MAXN-1],mod-2);\n\tfor(int i=MAXN-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tn=read();m=read();K=read();int ans=0;\n\tfor(int x=0;x<=m;x++)for(int y=0;y<=K;y++)\n\t\tad(ans,1LL*pow_mod(3,m-x)*pow_mod(3,K-y)%mod*C(n+x+y-1,x)%mod*C(n+y-1,y)%mod);\n\tpr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll mod=1e9+7;\nconst ll inf=1e17+500;\nconst ll maxn=6200;\nll ent[maxn][maxn];\nll poww[maxn];\n\nint main(){\n   poww[0]=1;\n   for(ll i=1;i<maxn;i++){\n        poww[i]=(poww[i-1]*3)%mod;\n   }\n   ent[0][0]=1;\n   for(ll i=1;i<maxn;i++){\n        ent[i][i]=1;\n        ent[i][0]=1;\n        for(ll j=1;j<i;j++){\n            ent[i][j]=(ent[i-1][j]+ent[i-1][j-1])%mod;\n        }\n   }\n   ll ans=0;\n   ll n,m,k;\n   cin>>n>>m>>k;\n   n--;\n   for(ll s=0;s<=m+k;s++){\n        ll res=0;\n        for(ll j=max(0LL,s-m);j<=min(k,s);j++){\n            res+=(ent[n+s][j]*ent[n+s-j][s-j])%mod;\n        }\n        res%=mod;\n        res*=poww[m+k-s];\n        res%=mod;\n\n        ans+=res;\n   }\n   cout<<ans%mod;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n\treturn ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n\treturn ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n\tint ans = 1 , base = a ;\n\twhile( b ) {\n\t\tif( b&1 ) ans = mul( ans , base ) ;\n\t\tbase = mul( base , base ) ; \n\t\tb >>= 1 ;\n\t}\n\treturn ans ;\n}\n\nll inv( ll x ) {\n\treturn power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n\treturn ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n\tscanf( \"%d%d%d\" , &n , &m , &k ) ;\n\tfac[ 0 ] = 1ll ;\n\tp[ 0 ] = 1ll ;\n\tfor( int i = 1 ; i < N ; i ++ ) {\n\t\tfac[ i ] = fac[ i - 1 ] * i % mod ;\n\t\tp[ i ] = p[ i - 1 ] * 3ll % mod ;\n\t}\n\tfor( int i = 0 ; i < N ; i ++ ) {\n\t\tifac[ i ] = inv( fac[ i ] ) ;\n\t}\n\tll ans = 0 , x = 1ll ;\n\tn -- ;\n\tif( m < k ) swap( m , k ) ;\n\tfor( int i = 0 ; i <= m + k ; i ++ ) {\n\t\tans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n\t\tfor( int j = 0 ; j < m ; j ++ ) {\n\t\t\tif( j > i || i - j >= k ) break ;\n\t\t\tx = add( x , C( i , j ) ) ;\n\t\t}\n\t\t/*\n\t\tif( i < k ) x = ( x * 2ll ) % mod ;\n\t\telse if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n\t\telse  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n\t\t*/\n\t}\n\tprintf( \"%d\\n\" , add( ans , mod ) ) ;\n\treturn 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\nconst int maxn = 9e5 + 7, md = 1e9 + 7;\nll inv[maxn], finv[maxn], fac[maxn], f[maxn], p2[maxn], p3[maxn];\nll N, M, K, m, k;\nll read(){\n    int s = 0; char c = getchar();\n    while (c > '9' || c < '0') c = getchar();\n    while (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();\n    return s;\n}\nll ksm(ll a, int b){\n    ll res = 1;\n    while (b){\n        if (b & 1) res = res * a % md;\n        a = a * a % md;\n        b >>=1 ;\n    }\n    return res;\n}\nvoid init(){\n    fac[0] = fac[1] = 1; inv[1] = finv[1] = 1;\n    p3[1] = 3;p3[0] = 1;\n    for (int i = 2; i < maxn; i++) p3[i] = p3[i - 1] * 3 % md;\n    for (int i = 2; i < maxn; i++){\n        inv[i] = ( md - (md / i) * inv[md%i] % md) % md;\n    }\n    for (ll i = 1; i < maxn; i++) {\n        fac[i] = fac[i - 1] * i % md;\n    }\n    finv[maxn - 1] = ksm(fac[maxn - 1], md - 2);\n    for (ll i = maxn - 2; i >= 0; i--) finv[i] = finv[i + 1] * (i + 1) % md;\n    \n}\nll ans = 0;\nll getf(){\n    ll res = 0;\n    f[0] = p3[M];\n    res = f[0];\n    for (int i = 1; i <= M; i++)\n        f[i] = (((((f[i - 1] * (N - 1 + i + k) % md + md) % md ) * inv[3]) % md) * inv[i] + md) % md, res = ((res + f[i]) % md + md) % md;\n    return res;\n}\nll C(int x, int y){\n    return fac[x] * finv[y] % md * finv[x - y] % md;\n}\nint main(){\n    N = read(), M = read(), K = read();\n    init();\n    for (k = 0; k <= K; k++) {\n        ans = (ans + p3[K-k] * C(N - 1 + k, k) % md * getf() % md);\n    }\n    printf(\"%lld\\n\", ans % md);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MOD 1000000007\n#define N 1000\nusing namespace std;\ntypedef long long LL;\nLL mod_pow(LL base, LL exp)\n{\n\tif(exp==0) return 1;\n\tif(exp&1) return (mod_pow(base,exp-1)*base)%MOD;\n\telse return mod_pow((base*base)%MOD,exp/2);\n}\nLL fac[3*N+1];\nLL fac_inv[3*N+1];\nLL C(LL n, LL k)\n{\n\tif(k < 0 || n < k) return 0;\n\tLL num = fac[n];\n\tLL den = (fac_inv[n-k]*fac_inv[k])%MOD;\n\treturn (num*den)%MOD;\n}\nint main()\n{\n\tfac[0] = 1;\n\tfor(LL n = 1; n <= 3*N; n++)\n\t\tfac[n] = (fac[n-1]*n)%MOD;\n\tfac_inv[3*N] = mod_pow(fac[3*N],MOD-2);\n\tfor(LL n = 3*N-1; n >= 0; n--)\n\t\tfac_inv[n] = (fac_inv[n+1]*(n+1))%MOD;\n\n\tLL a, b, c; cin >> a >> b >> c;\n\ta++;\n\t\n\tLL ans = 0;\n\tfor(LL n = a; n <= a+b+c; n++)\n\t{\n\t\tLL sub = 0;\n\t\tfor(LL i = 0; i <= n-a; i++)\n\t\t\tif( 0 <= i && i <= b && 0 <= n-a-i && n-a-i <= c)\n\t\t\t\tsub = (sub+C(n-a,i))%MOD;\n\t\tsub = (sub*C(n-2,a-2))%MOD;\n\t\tsub = (sub*mod_pow(3,a+b+c-n))%MOD;\n\t\tans = (ans+sub)%MOD;\n\t}\n\tcout<<ans<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Mod = 1e9 + 7;\nconst int N = 9e5 + 10;\n\nint n, m, k;\nlong long fac[N], vfac[N];\n\nlong long mpow( long long a, int b ) {\n\tlong long rt;\n\tfor( rt = 1; b; b >>= 1, a = (a * a) % Mod )\n\t\tif( b & 1 ) rt = (rt * a) % Mod;\n\treturn rt;\n}\nvoid init( int n ) {\n\tfac[0] = 1;\n\tfor( int i = 1; i <= n; i++ )\n\t\tfac[i] = (fac[i-1] * i) % Mod;\n\tvfac[n]  = mpow( fac[n], Mod - 2 );\n\tfor( int i = n - 1; i >= 0; i-- )\n\t\tvfac[i] = vfac[i+1] * (i + 1) % Mod;\n}\nlong long comb( int n, int m ) {\n\treturn fac[n] * vfac[n-m] % Mod * vfac[m] % Mod;\n}\nint main() {\n\tscanf( \"%d%d%d\", &n, &m, &k );\n\tif( m < k ) swap( m, k );\n\tinit( m + k + n );\n\tlong long sum = 0, ans = 0;\n\tfor( int s = 0; s <= m + k; s++ ) {\n\t\tif( s == 0 ) {\n\t\t\tsum = 1;\n\t\t} else if( s <= k ) {\n\t\t\tsum = (sum<<1) % Mod;\n\t\t} else if( s <= m ) {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1)) % Mod;\n\t\t} else {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1) + Mod - comb(s-1,m)) % Mod;\n\t\t}\n\t\tlong long sub = sum * comb(n-1+s,n-1) % Mod * mpow(3,m+k-s) % Mod;\n\t\tans = (ans + sub) % Mod;\n//\t\tprintf( \"s = %d sub = %lld\\n\", s, sub );\n\t}\n\tprintf( \"%lld\\n\", ans );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000010\n#define ll long long\n\nconst ll p = 1e9 + 7;\nll n, m, k, ans;\nll fac[N], inv[N], san[N];\n\nll fpow(ll a, ll b)\n{\n    ll ans = 1;\n    while(b)\n    {\n        if(b & 1) ans = ans * a % p;\n        a = a * a % p; b >>= 1;\n    }\n    return ans;\n}\n\nll C(ll n, ll m)\n{\n    if(n < m || n < 0 || m < 0) return 0;\n    return fac[n] * inv[m] % p * inv[n - m] % p;\n}\n\nint main()\n{\n    scanf(\"%lld%lld%lld\", &n, &m, &k);\n    ll t = n + m + k;\n    fac[0] = inv[0] = san[0] = 1;\n    for(int i = 1; i <= t; i ++)\n    {\n        fac[i] = fac[i - 1] * i % p;\n        san[i] = san[i - 1] * 3 % p;\n    }\n    //for(int i = 1; i <= 5; i ++) printf(\"%lld %lld %lld\", fac[i], inv[i], san[i]), system(\"pause\");\n    inv[t] = fpow(fac[t], p - 2);\n    for(int i = t - 1; i; i --) inv[i] = inv[i + 1] * (i + 1) % p;\n    ll t1 = 0, t2 = 1;\n    for(int i = 0; i <= m + k; i ++)\n    {\n        t = C(n + i - 1, n - 1) * san[m + k - i] % p;\n        //printf(\"%lld\", t); system(\"pause\");\n        t = t * (t2 - t1 + p) % p;\n        t2 = (t2 * 2 % p - C(i, m) + p) % p;\n        t1 = ((t1 * 2 % p - C(i, i - k - 1) + p) % p + C(i + 1, i - k)) % p;\n        ans = (ans + t) % p; \n        //printf(\"%lld %lld\", ans, t); system(\"pause\");\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n    return ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n    return ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n    int ans = 1 , base = a ;\n    while( b ) {\n        if( b&1 ) ans = mul( ans , base ) ;\n        base = mul( base , base ) ; \n        b >>= 1 ;\n    }\n    return ans ;\n}\n\nll inv( ll x ) {\n    return power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n    return ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n    scanf( \"%d%d%d\" , &n , &m , &k ) ;\n    fac[ 0 ] = 1ll ;\n    p[ 0 ] = 1ll ;\n    for( int i = 1 ; i < N ; i ++ ) {\n        fac[ i ] = fac[ i - 1 ] * i % mod ;\n        p[ i ] = p[ i - 1 ] * 3ll % mod ;\n    }\n    for( int i = 0 ; i < N ; i ++ ) {\n        ifac[ i ] = inv( fac[ i ] ) ;\n    }\n    ll ans = 0 , x = 1ll ;\n    n -- ;\n    for( int i = 0 ; i <= m + k ; i ++ ) {\n        ans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n        if( i < k ) x = ( x * 2ll ) % mod ;\n        else if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n        else  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n    }\n    printf( \"%lld\\n\" , add( ans , mod ) ) ;\n    return 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <deque>\n#include <queue>\n#include <string>\n#include <tuple>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\n#define pb push_back\n#define pbk pop_back\n#define sz(a) ((int) (a).size())\n#define all(a) (a).begin(), (a).end()\n#define mp make_pair\n#define mt make_tuple\n#define fs first\n#define sc second\n#define next hunext\n#define prev huprev\n#define rank hurank\n#define hash huhash\n\n#ifdef LOCAL42\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = int(1e9);\nconst ll linf = ll(1e18);\nconst double eps = 1e-9;\nconst double pi = 4 * atan(1.0);\nconst int MOD = int(1e9) + 7;\nconst int P = 31622;\nconst int N = int(4e6);\n\nstruct base {\n    \n    double a, b;\n    \n    base() : a(0), b(0) {}\n    \n    base(double a, double b = 0) : a(a), b(b) {}\n    \n};\n\ninline base operator + (const base& a, const base& b) {\n    return base(a.a + b.a, a.b + b.b);\n}\n\ninline base operator - (const base& a, const base& b) {\n    return base(a.a - b.a, a.b - b.b);\n}\n\ninline base operator * (const base& a, const base& b) {\n    return base(a.a * b.a - a.b * b.b, a.a * b.b + a.b * b.a);\n}\n\ninline base operator / (const base& a, double b) {\n    return base(a.a / b, a.b / b);\n}\n\nint maxv;\nint a[N], b[N], c[N], d[N], ac[N], bd[N], abcd[N], f[N], rf[N];\nbase aa[N];\n\ninline int calc(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2 != 0) {\n            res = (1LL * res * a) % MOD;\n        }\n        a = (1LL * a * a) % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\ninline void fft(base* a, int n, bool fl) {\n    for (int i = 1, j = 0; i < n; ++i) {\n        int bit = n / 2;\n        for (; j >= bit; bit /= 2) {\n            j -= bit;\n        }\n        j += bit;\n        if (i < j) {\n            swap(a[i], a[j]);\n        }\n    }\n    for (int len = 2; len <= n; len *= 2) {\n        double ang = 2 * pi / len * (fl ? -1 : 1);\n        base wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            base w(1);\n            for (int j = 0; j < len / 2; ++j) {\n                base u = a[i + j], v = a[i + j + len / 2] * w;\n                a[i + j] = u + v;\n                a[i + j + len / 2] = u - v;\n                w = w * wlen;\n            }\n        }\n    }\n    if (fl) {\n        for (int i = 0; i < n; ++i) {\n            a[i] = a[i] / n;\n        }\n    }\n}\n\ninline void mult(int* a, int* b, int* c) {\n    for (int i = 0; i < maxv; ++i) {\n        aa[i].a = a[i];\n        aa[i].b = b[i];\n    }\n    fft(aa, maxv, false);\n    for (int i = 0; i < maxv; ++i) {\n        aa[i] = aa[i] * aa[i];\n    }\n    fft(aa, maxv, true);\n    for (int i = 0; i < maxv; ++i) {\n        c[i] = (ll(aa[i].b + 0.5) / 2) % MOD;\n    }\n}\n\nint main() {\n#ifdef LOCAL42\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int n, m, k;\n    cin >> n >> m >> k;\n    f[0] = 1;\n    for (int i = 1; i <= n + m + k; ++i) {\n        f[i] = (1LL * f[i - 1] * i) % MOD;\n    }\n    rf[n + m + k] = calc(f[n + m + k], MOD - 2);\n    for (int i = n + m + k - 1; i >= 0; --i) {\n        rf[i] = (1LL * rf[i + 1] * (i + 1)) % MOD;\n    }\n    for (int i = 0; i <= m; ++i) {\n        a[i] = rf[i] / P;\n        b[i] = rf[i] % P;\n    }\n    for (int i = 0; i <= k; ++i) {\n        c[i] = rf[i] / P;\n        d[i] = rf[i] % P;\n    }\n    maxv = 1;\n    while (maxv < m + k + 1) {\n        maxv *= 2;\n    }\n    maxv *= 2;\n    assert(maxv < N);\n    mult(a, c, ac);\n    mult(b, d, bd);\n    for (int i = 0; i <= m; ++i) {\n        a[i] += b[i];\n    }\n    for (int i = 0; i <= k; ++i) {\n        c[i] += d[i];\n    }\n    mult(a, c, abcd);\n    int ans = 0, pw3 = 1, inv3 = calc(3, MOD - 2);\n    for (int i = 0; i <= m + k; ++i) {\n        int sum = (1LL * P * P * ac[i]) % MOD;\n        sum = (sum + 1LL * P * (abcd[i] - ac[i] - bd[i])) % MOD;\n        if (sum < 0) {\n            sum += MOD;\n        }\n        sum += bd[i];\n        if (sum >= MOD) {\n            sum -= MOD;\n        }\n        sum = (1LL * sum * pw3) % MOD;\n        sum = (1LL * sum * f[n - 1 + i]) % MOD;\n        ans += sum;\n        if (ans >= MOD) {\n            ans -= MOD;\n        }\n        pw3 = (1LL * inv3 * pw3) % MOD;\n    }\n    ans = (1LL * ans * calc(3, m + k)) % MOD;\n    ans = (1LL * ans * rf[n - 1]) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nconst int MAX=1000000;\nint fact[MAX],inv[MAX];\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nint pow3[MAX];\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<MAX;i++)fact[i]=fact[i-1]*i%mod;\n    inv[MAX-1]=mpow(fact[MAX-1],mod-2);\n    for(int i=MAX-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    pow3[0]=1;\n    for(int i=1;i<MAX;i++)pow3[i]=pow3[i-1]*3%mod;\n\n    int N,M,K;\n    cin>>N>>M>>K;\n    int ans=0;\n    int cur=1;\n    for(int i=0;i<=M+K;i++){\n        ans=(ans+cur*C(N-1+i,i)%mod*pow3[M+K-i])%mod;\n        cur=cur*2%mod;\n        if(i>=M)cur=(cur-C(i,M)+mod)%mod;\n        if(i>=K)cur=(cur-C(i,i-K)+mod)%mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9+7;\ntypedef long long LL;\nLL f[300001], r[300001];\nLL th[300001];\nLL inv(LL a){\n    LL ans = 1;\n    LL b = mod-2;\n    while(b){\n        if(b%2) ans = ans*a%mod;\n        a = a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\nint main(){\n    f[0] = r[0] = th[0] = 1;\n    for(int i=1;i<=300000;i++){\n        f[i] = f[i-1]*i%mod;\n        r[i] = inv(f[i]);\n        th[i] = th[i-1]*3%mod;\n    }\n    LL ans = 0;\n    int n, m, k;\n    scanf(\"%d%d%d\", &n, &m, &k);\n    for(int i=0;i<=m;i++){\n        for(int j=0;j<=k;j++){\n            int l = i+j+(n-1);\n            ans = (ans + f[l]*r[i]%mod*r[j]%mod*r[n-1]%mod*th[n+m+k-(l+1)])%mod;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint A, B, C;\nconst ll mod = 1'000'000'007;\nll fact[1'000'010];\nll finv[1'000'010];\nll pow3[1'000'010];\n\nll Pow(ll b, ll e){\n\tll ret = 1;\n\twhile(e){\n\t\tif(e % 2 == 1) ret = ret * b % mod;\n\t\te /= 2;\n\t\tb = b * b % mod;\n\t}\n\treturn ret;\n}\n\nvoid Build(){\n\tfact[0] = finv[0] = pow3[0] = 1;\n\tfor(int i=1; i<=1'000'000; ++i){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tfinv[i] = Pow(fact[i], mod - 2);\n\t\tpow3[i] = pow3[i-1] * 3 % mod;\n\t}\n}\n\nll Comb(ll n, ll r){\n\tif(n<0 || r<0 || r>n) return 0;\n\treturn fact[n] * finv[r] % mod * finv[n-r] % mod;\n}\n\nint main()\n{\n\tBuild();\n\tcin >> A >> B >> C;\n\tll ans = 0;\n\tll v3 = 0;\n\tfor(ll s = 0; s <= B+C; ++s){\n\t\tll v1 = Comb(A+s-1, A-1);\n\t\tll v2 = pow3[B+C-s];\n\t\tif(s == 0) v3 = 1;\n\t\telse {\n\t\t\tv3 = v3 * 2;\n\t\t\tv3 += mod - Comb(s-1, C);\n\t\t\tif(s >= B) v3 += mod - Comb(s-1, B);\n\t\t\tv3 %= mod;\n\t\t}\n\t\tll t;\n\t\tans += t = v1 * v2 % mod * v3 % mod;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\n#define int long long\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=900000+10;\n\nconst int mod=1e9+7;\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint fac[N],ifac[N],pw[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n    for (re int i=pw[0]=1;i<=n;++i) pw[i]=3ll*pw[i-1]%mod;\n}\n\ninline int C(int n,int m) {\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nsigned main() { init(900000);\n    int n=read(),m=read(),k=read();\n    int ans=0,lst=1;\n    for (re int i=0;i<=m+k;++i) {\n        ans=(ans+1ll*C(n+i-1,n-1)*pw[m+k-i]%mod*lst)%mod;\n        if (i<k) lst=2ll*lst%mod;\n        else if (i<m) lst=(2ll*lst+mod-C(i,k))%mod;\n        else lst=(2ll*lst+mod-C(i,k)+mod-C(i,m))%mod;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int mod = 1e9 + 7;\n\nstruct ModCombination {\n  ModCombination(unsigned int n) : n(n), F(n + 1, 1), I(n + 1, 1) {\n    for (int i = 1; i <= n; ++i) F[i] = 1ll * i * F[i - 1] % mod;\n    for (int64_t i = mod - 2, j = F[n]; i; i >>= 1) {\n      if (i & 1) I[n] = I[n] * j % mod;\n      j = j * j % mod;\n    }\n    for (int i = n - 1; i; --i) I[i] = I[i + 1] * (i + 1ll) % mod;\n  }\n\n  unsigned int n;\n  vector<int> F, I;\n\n  int operator()(int p, int k) {\n    if (p > n) cerr << \"errored by ModCombination's operator()\";\n    if (k < 0 || k > p) return 0;\n    return 1ll * F[p] * I[k] % mod * I[p - k] % mod;\n  }\n};\n\nint mod_pow(int64_t a, int x) {\n  int64_t res = 1;\n  a %= mod;\n  for (int i = 1; i <= x; i <<= 1) {\n    if (i & x) (res *= a) %= mod;\n    (a *= a) %= mod;\n  }\n\n  return res;\n}\n\nint main() {\n  int N, M, K;\n  cin >> N >> M >> K;\n\n  ModCombination mC(N + M + K + 1);\n\n  int64_t ans = 0, sum = 1;\n  for (int i = N - 1; i <= N + M + K - 1; ++i) {\n    (ans += 1ll * mC(i, N - 1) * mod_pow(3, N + M + K - 1 - i) % mod * sum % mod) %= mod;\n    sum = (2 * sum % mod - (mC(i - (N - 1), i - (N - 1) - M) + mC(i - (N - 1), K)) % mod + mod) % mod;\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#pragma GCC optimize(\"Ofast,unroll-loops\")\n//#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace IntModulo\n{\n\tconst int mod = 1e9 + 7;\n\n\tinline int add(int x, int y, int m = mod)\n\t{\n\t\tif (x + y < m)\n\t\t\treturn x + y;\n\t\treturn x + y - m;\n\t}\n\n\tinline int sub(int x, int y, int m = mod)\n\t{\n\t\tif (x >= y)\n\t\t\treturn x - y;\n\t\treturn x - y + m;\n\t}\n\n\tinline int mult(int x, int y, int m = mod)\n\t{\n\t\treturn x * (LL) y % m;\n\t}\n\n\tinline int power(int x, int y, int m = mod)\n\t{\n\t\tint r = 1;\n\t\twhile(y)\n\t\t{\n\t\t\tif (y & 1)\n\t\t\t\tr = mult(r, x, m);\n\t\t\tx = mult(x, x, m);\n\t\t\ty >>= 1;\n\t\t}\n\t\t\n\t\treturn r;\n\t}\n\t\n\tinline int inverse(int x, int m = mod)\n\t{\n\t\treturn power(x, m - 2, m);\n\t}\n\t\n\tinline void ADD(int& x, int y, int m = mod)\n\t{\n\t\tx += y;\n\t\tif (x >= m) x -= m;\n\t}\n\t\n\tinline void SUB(int& x, int y, int m = mod)\n\t{\n\t\tx -= y;\n\t\tif (x < 0) x += m;\n\t}\n\t\n\tinline void MULT(int& x, int y, int m = mod)\n\t{\n\t\tx = (x * (LL) y) % m;\n\t}\n};\n\nnamespace Combinatorics\n{\n\tusing namespace IntModulo;\n\t\n\tconst int N = 1 << 19;\n\tint fact[N];\n\tint inv[N];\n\tint invFact[N];\n\tbool inited = false;\n\t\n\tinline int C(int n, int k) // binomial C(n, k)\n\t{\n\t\treturn n < k ? 0 : mult(fact[n], mult(invFact[k], invFact[n - k]));\n\t}\n\t\n\tinline int H(int n, int k) // number of solution x1 + .. + xn = k\n\t{\n\t\treturn C(n + k - 1, k);\n\t}\n\t\n\tvoid init()\n\t{\n\t\tdebug(Combinatorics::N);\n\t\tinited = true;\n\t\tinv[1] = 1;\n\t\tFOR(i, 2, N)\n\t\t\tinv[i] = mult(mod - mod / i, inv[mod % i]);\n\t\t\n\t\tinvFact[0] = fact[0] = 1;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tfact[i] = mult(i, fact[i - 1]);\n\t\t\tinvFact[i] = mult(invFact[i - 1], inv[i]);\n\t\t}\n\t}\t\n};\n\nusing namespace Combinatorics;\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tCombinatorics::init();\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tn--;\n\tint ans = 0;\n\tFOR(i, 0, m + 1) FOR(j, 0, k + 1)\n\t{\n\t\tint tut = C(i + j + n, n);\n\t\tMULT(tut, C(i + j, j));\n\t\tMULT(tut, power(3, m - i + k - j));\n\t\tADD(ans, tut);\n\t}\t\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nint f[1001000],n,m,k;\nlong long fac[1010000],inv[1010000],mi[1010000];\nint C(int a,int b){return 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;}\nint main()\n{\n\tinv[0]=inv[1]=fac[0]=mi[0]=1;\n\tfor(int i=1;i<=600000;i++)fac[i]=fac[i-1]*i%mod;\n\tfor(int i=2;i<=600000;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod; \n\tfor(int i=1;i<=600000;i++)inv[i]=inv[i-1]*inv[i]%mod;\n\tfor(int i=1;i<=600000;i++)mi[i]=mi[i-1]*3%mod;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tf[0]=1;\n\tfor(int t=1;t<=m+k;t++)\n\t\tf[t]=((f[t-1]*2-(t-k-1>=0?C(t-1,t-k-1):0)-(t-1>=m?C(t-1,m):0))%mod+mod)%mod;\n\t\n\tlong long ans=0;\n\tfor(int t=0;t<=m+k;t++)\n\t\tans=(ans+C(t+n-1,n-1)*mi[m+k-t]%mod*f[t]%mod)%mod;\n\tprintf(\"%lld\\n\",ans);return 0;\n}\n/*把三个人记为ABC \n考虑他们的出牌顺序：记为AACBACBABC.....\nA表示A出了一张牌，B，C同理\n显然，每个出牌顺序对应一种三个人的手牌\n枚举他们一共出了几张牌，在这个出牌顺序中，A要出现正好n次，且B，C出现次数要分别<=m，<=k \n记他们出的牌数为n+t\nans=∑( C(t+n-1,n-1)  *  3^(m+k-t)  *  ∑C(t,i)(max(0,t-k)<=i<=min(t,m))  ) \n        A出现的位置  剩余的牌             i为枚举B的出现次数 \n\n记f(t)=∑C(t,i)(max(0,t-k)<=i<=min(t,m))\n\n因为C(t,i)=C(t-1,i)+C(t-1,i-1)\n把f(t)里的所有C(t,i)用C(t-1,i)+C(t-1,i-1)带，可以得到 \nf(t)=(f(t-1)-(t-k-1>=0?C(t-1,t-k-1)))\n    +(f(t-1)-(t-1>=m?C(t-1,m)))\n因为i的取值范围不同，所以要进行一些微调(即后面减的部分)\n\n*/ "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n// #ifdef LOCAL\n// #define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n// #else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n// #endif\n\nconst LD kPi = 2 * acos(0);\nstruct CD {\n  LD re, im;\n  CD operator=(LD a) { re = a; im = 0; return *this; }\n  CD operator*(CD& z) { return {re * z.re - im * z.im, re * z.im + im * z.re}; }\n  void operator*=(CD& z) { *this = (*this * z); }\n  CD operator+(CD& z) { return {re + z.re, im + z.im}; }\n  CD operator-(CD& z) { return {re - z.re, im - z.im}; }\n  void operator/=(LD f) { re /= f; im /= f; }\n};\n\nstruct FFT {\nprivate:\n  CD *A, *B, *tmp, *res, *omega;\n  int *rev_perm;\n  int max_dep;\n  // not needed if this is going to be used just once\n  void Clear(int n) {\n    REP (i, n) { A[i] = B[i] = res[i] = tmp[i] = 0; }\n  }\n\n  void fft(CD* from, CD* to, int depth, bool inv){\n    int N = (1 << depth);\n    REP (i, N) { to[rev_perm[i] >> (max_dep - depth)] = from[i]; }\n\n    RE (m, depth) {\n      int step = (1 << m);\n      for (int pos = 0; pos < N; pos += step){\n        int cur = 0;\n        int delta = (1 << (max_dep - m));\n        if (!inv) { cur = (1 << max_dep); delta *= -1; }\n        REP (k, step / 2) {\n          CD a = to[pos + k],\n             b = omega[cur] * to[pos + k + step / 2];\n          to[pos + k] = a + b;\n          to[pos + k + step / 2] = a - b;\n          cur += delta;\n        }\n      }\n    }\n    if (inv) { REP (i, N) { to[i] /= N; } }\n  }\n  \npublic:\n  FFT(int max_deg) { // max degree of a polynomial given as input\n    max_dep = 0;\n    while ((1 << max_dep) <= 2 * max_deg) { max_dep++; }\n    max_deg = (1 << max_dep) + 20;\n    A = new CD[max_deg]; B = new CD[max_deg];\n    res = new CD[max_deg]; tmp = new CD[max_deg];\n    omega = new CD[max_deg]; rev_perm = new int[max_deg];\n    int N = (1 << max_dep);\n    LD ang = 2 * kPi / N;\n    REP (i, N + 1) { omega[i] = {cos(i * ang), sin(i * ang)}; }\n    rev_perm[0] = 0;\n    int h = -1;\n    RE (i, N) {\n      if ((i & (i - 1)) == 0) { h++; }\n      rev_perm[i] = rev_perm[i ^ (1 << h)] | (1 << (max_dep - h - 1));\n    }\n  }\n  VI mul_less_exact(VI Q, VI R, int P) {\n    int depth = 0, size = 1;\n    int N = SZ(Q) + SZ(R) - 1;\n    while (size < N) { depth++; size *= 2; }\n    Clear(size);\n    // start miejsca, w ktorym jak mozna mniejsza dokladnosc, to zmien na komentarze\n    // P,Q \\in R[x], A = Q * (1+i)/2 + R * (1-i)/2 -> Re(A^2) = P*Q\n    REP (i, SZ(Q)) \n      A[i] = CD{.5 * Q[i] + .5 * R[i], .5 * Q[i]-.5 * R[i]};\n    fft(A, tmp, depth, false);\n    REP (i, size) tmp[i] *= tmp[i];\n    //fft(A, res, depth, false);\n    //fft(B, tmp, depth, false);\n    //REP (i, size) tmp[i] *= res[i];\n    // koniec\n    fft(tmp, res, depth, true);\n    VI ans;\n    REP (i, N) { ans.PB((long long)round(res[i].re) % P); }\n    return ans;\n  }\n  \n  VI Prepare(VI& v, int base, int b_pow) {\n    VI ans;\n    for (int x : v) { ans.PB(b_pow ? x / base : x % base); }\n    return ans;\n  }\n  int Sum(VI& v, int P) { // debug/assert purposes only\n    return accumulate(ALL(v), 0LL) % P;\n  }\n  VI mul_exact(VI Q, VI R, int P) {\n    int base = 32000;\n    int pows[] = {1, base, (int)1LL * base * base % P};\n    VI ans(SZ(Q) + SZ(R) - 1);\n    REP (q, 2) {\n      VI W = Prepare(Q, base, q);\n      REP (r, 2) {\n        VI V = Prepare(R, base, r);\n        // jezeli bedzie za wolno, to można policzyc tylko 4 transformaty w przod\n        // bo teraz dla kazdej z 4 czesci jest liczona podwojnie (przyspieszenie * 2/3)\n        VI C = mul_less_exact(W, V, P);\n        REP (i, SZ(C)) { ans[i] = (ans[i] + 1LL * C[i] * pows[q + r]) % P; }\n      }\n    }\n    debug(Sum(ans, P), 1LL * Sum(Q, P) * Sum(R, P) % P);    // DEBUG!!\n    assert(Sum(ans, P) == 1LL * Sum(Q, P) * Sum(R, P) % P); // DEBUG!!\n    return ans;\n  }\n};\n\nint P = 1e9 + 7;\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w&1)\n      r = r * a % P;\n    w /= 2;\n    a =  a * a % P;\n  }\n  return r;\n}\nint odw(int a){\n  return pot(a,P-2);\n}\nconst int MAX = 1e6;\nint sil[MAX];\nint a,b,c;\nFFT fft((int)(3e5)+2);\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  sil[0] = 1;\n  for(int i = 1; i < MAX; i++)\n    sil[i] = sil[i-1] * i % P;\n  cin >> a >> b >> c;\n  vector<int> x,y;\n  R(i,b+1){\n    x.PB(odw(sil[b-i]));\n  }\n  R(i,c+1){\n    y.PB(odw(sil[c-i]));\n  }\n  debug(x,y);\n  vector<int> spl = fft.mul_exact(x,y,P);\n  debug(spl);\n  int res = 0;\n  int mn = odw(sil[a-1]);\n  R(i,SZ(spl)){\n    debug(sil[a-1+b+c-i], mn,spl[i]);\n    res += sil[a-1+b+c-i] * mn % P * spl[i] % P;\n    debug(res);\n    mn*=3;\n    mn%=P;\n  }\n  cout << res%P << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n \nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n \nll inv[4000001], f[4000001], fi[4000001];\n\nll C(int N, int K) {\n\treturn f[N] * fi[K] % MOD * fi[N - K] % MOD;\n}\n\nll H(int N, int K) {\n\tif (K == 0) return !N;\n\treturn H(N + K - 1, K - 1);\n}\n\nint main() {\n\tinv[1] = 1;\n\tfor (int i = 2; i <= 4000000; i++)\n\t\tinv[i] = -MOD / i * inv[MOD % i] % MOD;\n\tf[0] = fi[0] = 1;\n\tfor (int i = 1; i <= 4000000; i++) {\n\t\tf[i] = f[i - 1] * i % MOD;\n\t\tfi[i] = fi[i - 1] * inv[i] % MOD;\n\t}\n\tvector<ll> p3(4000001);\n\tp3[0] = 1;\n\tfor (int i = 1; i <= 4000000; i++)\n\t\tp3[i] = p3[i - 1] * 3 % MOD;\n\tvector<ll> p2(4000001);\n\tp2[0] = 1;\n\tfor (int i = 1; i <= 4000000; i++)\n\t\tp2[i] = p2[i - 1] * 2 % MOD;\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tN++;\n\tif (M > L) swap(M, L);\n\tll ans = 0;\n\tll hoge = 0;\n\tfor (int k = 0; k <= M + L; k++) {\n\t\tll unko = 0;\n\t\tunko = (unko + p2[k]) % MOD;\n\t\thoge = hoge * 2 % MOD;\n\t\tif (k > M) hoge = (hoge + C(M + k - M - 1, k - M - 1)) % MOD;\n\t\tif (k > L) hoge = (hoge + C(L + k - L - 1, k - L - 1)) % MOD;\n\t\tunko = (unko - hoge) % MOD;\n\t\tans = (ans + unko * p3[M + L - k] % MOD * C(N - 2 + k, k)) % MOD;\n\t}\n\tcout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconst LL MOD = 1000000007ll;\n\nLL m_pow(LL a,LL n)\n{\n    if(n == 0)return 1;\n    LL half = m_pow(a,n/2);\n    half *= half;\n    half %= MOD;\n    return (half * (n % 2 ? a : 1)) % MOD;\n}\nvector<LL>fact;\nLL comb(LL n,LL r)\n{\n    LL shi = fact[n];\n    LL bo1 = m_pow(fact[r],MOD - 2);\n    LL bo2 = m_pow(fact[n - r],MOD - 2);\n    shi *= bo1;\n    shi %= MOD;\n    shi *= bo2;\n    shi %= MOD;\n    return shi;\n}\n\nint main()\n{\n    fact.push_back(1);\n    for(int i = 1;i < 5e6;++i)fact.push_back(fact.back() * i % MOD);\n    int N,M,K;\n    cin >> N >> M >> K;\n    LL val = 1;\n    LL ans = 0;\n    for(int P = N;P <= N + M + K;++P)\n    {\n        int down = P-N-K;\n        int up = M;\n        if(P != N)val *= 2;\n        val %= MOD;\n        if(down > 0)\n        {\n            val -= comb(P-N-1,down-1);\n            val += MOD;\n            val %= MOD;\n        }\n        if(P-N > up)\n        {\n            val -= comb(P-N-1,up);\n            val += MOD;\n            val %= MOD;\n        }\n        LL plus = val;\n        plus *= m_pow(3,N+M+K-P);\n        plus %= MOD;\n        plus *= comb(P-1,N-1);\n        plus %= MOD;\n        ans += plus;\n        ans %= MOD;\n        cerr << plus << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define re register\n#define int long long\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int N = 1e6 + 5 ; \nconst int P = 1e9 + 7 ; \nint a, b, c, n, m, Ans, fac[N], inv[N] ; \nint fpow( int x, int k ) {\n\tint ans = 1, base = x ;\n\twhile(k) {\n\t\tif( k & 1 ) ans = ans * base % P ; \n\t\tbase = base * base % P, k >>= 1 ; \n\t} return ans % P ; \n}\nint C( int x, int y ) {\n\tif( y > x || x < 0 || y < 0 ) return 0 ; \n\treturn fac[x] * inv[y] % P * inv[x - y] % P ; \n}\nsigned main()\n{\n\ta = gi(), b = gi(), c = gi() ; \n\tn = a + b + c, fac[0] = inv[0] = 1 ; \n\trep( i, 1, n ) fac[i] = fac[i - 1] * i % P, inv[i] = fpow( fac[i], P - 2 ) ;\n\tint f = 1, l = - c ; -- a ; \n\tfor( re int i = a; i < n; ++ i ) {\n\t\tint x = i - a ; \n\t\tif( l > b ) break ; \n\t\tAns = ( Ans + f * C( i, a ) % P * fpow( 3, n - i - 1 ) % P ) % P ;\n\t\tf = ( f * 2 + P - C( x, b ) + P - C( x, l ) ) % P, ++ l ; \n\t}\n\tprintf(\"%lld\\n\", Ans % P ) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int mod = 1000000007;\nint N, M, K, fact[3007], inv[3007], factinv[3007], power[3007];\ninline int ncr(int a, int b) {\n\treturn 1LL * fact[a] * factinv[b] % mod * factinv[a - b] % mod;\n}\nint main() {\n\tcin >> N >> M >> K;\n\tpower[0] = 1;\n\tfor (int i = 1; i <= 3000; i++) power[i] = 1LL * power[i - 1] * 3 % mod;\n\tfact[0] = 1;\n\tfor (int i = 1; i <= 3000; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n\tinv[1] = 1;\n\tfor (int i = 2; i <= 3000; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\tfactinv[0] = 1;\n\tfor (int i = 1; i <= 3000; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n\tint ret = 0;\n\tfor (int i = 0; i <= M; i++) {\n\t\tfor (int j = 0; j <= K; j++) {\n\t\t\tint r1 = N - 1, r2 = M - i, r3 = K - j;\n\t\t\tint res = 1LL * ncr(r1 + r2 + r3, r1) * ncr(r2 + r3, r2) % mod;\n\t\t\tret = (ret + 1LL * res * power[i + j]) % mod;\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 300010,rhl = 1000000007;\nint N,M,K; ll jie[maxn],inv[maxn],mi[maxn];\n\ninline ll qsm(ll a,int b)\n{\n\tll ret = 1;\n\tfor (;b;b >>= 1,(a *= a) %= rhl) if (b&1) (ret *= a) %= rhl;\n\treturn ret;\n}\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline ll C(int n,int m) { if (n < m||m < 0) return 0; return jie[n]*inv[m]%rhl*inv[n-m]%rhl; }\n\nint main()\n{\n\t//freopen(\"H.in\",\"r\",stdin);\n\t//freopen(\"H.out\",\"w\",stdout);\n\tN = gi(); M = gi(); K = gi();\n\tjie[0] = mi[0] = 1;\n\tfor (int i = 1;i <= N+M+K;++i)\n\t{\n\t\tmi[i] = mi[i-1]*3LL; while (mi[i] >= rhl) mi[i] -= rhl;\n\t\tjie[i] = jie[i-1]*(ll)i; if (jie[i] >= rhl) jie[i] %= rhl;\n\t}\n\tinv[N+M+K] = qsm(jie[N+M+K],rhl-2);\n\tfor (int i = N+M+K;i;--i)\n\t{\n\t\tinv[i-1] = inv[i]*(ll)i;\n\t\tif (inv[i-1] >= rhl) inv[i-1] %= rhl;\n\t}\n\tll sum = 1,ans = 0;\n\tfor (int i = 0;i <= M+K;++i)\n\t{\n\t\tll tm = C(N+i-1,i)*mi[M+K-i]%rhl;\n\t\tans += tm*sum%rhl; if (ans >= rhl) ans %= rhl;\n\t\tsum <<= 1; if (sum >= rhl) sum -= rhl;\n\t\tsum -= C(i,i-K)+C(i,M); while (sum < 0) sum += rhl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int p=1000000000+7;\nconst int maxn=100000*3+5;\nll n,m,k;\nll p1[maxn*2],p2[maxn*2];\nll f[maxn*2];//有x个空格，不大于m k个b c 填空种类数\nll pw3[maxn*2];\nll pw(ll x,ll y){\n\tll ans=1;\n\twhile ((bool)y){\n\t\tif ((bool)(y&1)){\n\t\t\tans=ans*x%p;\n\t\t}\n\t\tx=x*x%p;\n\t\ty=y>>1;\n\t}\n\treturn ans;\n}\nll c(ll x,ll y){\n\tif ((x<y)||(y<0))return 0;\n\treturn p1[x]*p2[y]%p*p2[x-y]%p;\n}\nvoid solve(){\n\tll b1,b2,b3,b4;\n\tll ans;\n\tscanf(\"%lld%lld%lld\",&n,&m,&k);\n\tf[0]=1;\n\tif (m>k) swap(m,k);\n\tfor (b1=1;b1<=m+k;b1++){\n\t\tf[b1]=(f[b1-1]*2-(c(b1-1,m)+c(b1-1,k))%p+p)%p;\n\t}\n\tans=0;\n\tfor (b1=n;b1<=n+m+k;b1++){\n\t\tans=(ans+f[b1-n]*c(b1-1,n-1)%p*pw3[n+m+k-b1]%p)%p;\n\t\t//printf(\"%lld\\n\",f[b1-n]*c(b1-1,n-1)*pw3[n+m+k-b1]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\t\n\t\n\t//printf(\"%lld\",f[m+k]-c(m+k,k));\n}\nint main(){\n\tll b1,b2,b3,b4;\n\tp1[0]=1;\n\tfor (b1=1;b1<maxn*2;b1++){\n\t\tp1[b1]=p1[b1-1]*b1%p;\n\t}\n\tp2[maxn*2-1]=pw(p1[maxn*2-1],p-2);\n\tfor (b1=maxn*2-1;b1>=1;b1--){\n\t\tp2[b1-1]=p2[b1]*b1%p;\n\t}\n\tpw3[0]=1;\n\tfor (b1=1;b1<maxn*2;b1++){\n\t\tpw3[b1]=pw3[b1-1]*3%p;\n\t}\n\tsolve();\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst ll Mod=1e9+7;\nint n,m,k,N;\nll ans,fac[900005],inv[900005],er[900005],san[900005],b,c;\nll quipow(ll x,ll m)\n{\n    ll res=1;\n    while(m)\n    {\n        if(m&1) res=res*x%Mod;\n        x=x*x%Mod;\n        m>>=1;\n    }\n    return res;\n}\nll C(int y,int u)\n{\n    if(y>u) return 0;\n    return fac[u]*inv[y]%Mod*inv[u-y]%Mod;\n}\nint main()\n{\n    fac[0]=fac[1]=1;\n    for(ll i=2;i<=900000;i++) fac[i]=fac[i-1]*i%Mod;\n    inv[900000]=quipow(fac[900000],Mod-2);\n    for(ll i=899999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%Mod;\n    er[0]=1;\n    for(ll i=1;i<=900000;i++) er[i]=er[i-1]*2%Mod;\n    san[0]=1;\n    for(ll i=1;i<=900000;i++) san[i]=san[i-1]*3%Mod;\n    scanf(\"%d%d%d\",&n,&m,&k);N=n+m+k;\n    for(int i=n;i<=N;i++)\n    {\n        int la=i-n;\n        ll now=C(n-1,i-1),gg=er[la];\n        b=(b+(m+1==la?1:(m+1<la?(b+C(i-n-m-1,i-n-1)):0)))%Mod;\n        c=(c+(k+1==la?1:(k+1<la?(c+C(i-n-k-1,i-n-1)):0)))%Mod;\n        gg=(gg-b+Mod)%Mod;gg=(gg-c+Mod)%Mod;\n        ans=(ans+now*gg%Mod*san[N-i]%Mod)%Mod;\n    }\n    printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n\ncs ll mod=1000000007;\n\nll fac[1000001]={1,1},inv[1000001]={1,1},ifac[1000001]={1,1};\n\ninline\nll C(int n,int m){\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint n,m,k,maxn;\n\nint main(){\n\t\n\tfor(int re i=2;i<=1000000;++i)\n\tfac[i]=fac[i-1]*i%mod,\n\tinv[i]=(mod-mod/i)*inv[mod%i]%mod,\n\tifac[i]=ifac[i-1]*inv[i]%mod;\n\t\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\t--n;\n\tmaxn=max(n,m+k);\n\tll sum=1,ans=1;\n\tfor(int re i=1;i<=maxn;++i){\n\t\tsum=(sum<<1)%mod;\n\t\tif(i>m)sum=(sum+mod-C(i-1,m))%mod;\n\t\tif(i>k)sum=(sum+mod-C(i-1,k))%mod;\n\t\tans=ans*3%mod;\n\t\tans=(ans+C(n+i,i)*sum%mod)%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct edge\n{\n    int to, kind;\n};\n\nvector<edge> G[MAX_N];\nmap<int, int> d[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    rep(i, m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        --a, --b, --c;\n        G[a].pb((edge){b, c}), G[b].pb((edge){a, c});\n    }\n    deque<P> que;\n    que.pb(P(0, -1));\n    d[0][-1] = 0;\n    while(!que.empty()){\n        P p = que.front();\n        que.pop_front();\n        int dist = d[p.fi][p.se];\n        each(e,G[p.fi]){\n            auto it = d[e.to].find(e.kind);\n            if(it == d[e.to].end() || it->se > dist + (e.kind != p.se)){\n                d[e.to][e.kind] = dist + (e.kind != p.se);\n                if((e.kind != p.se)){\n                    que.push_back(P(e.to, e.kind));\n                }else{\n                    que.push_front(P(e.to, e.kind));\n                }\n            }\n        }\n    }\n    int mn = INF;\n    each(it, d[n-1]){\n        cmn(mn, it.se);\n    }\n    if(mn < INF){\n        cout << mn << \"\\n\";\n    }else{\n        cout << \"-1\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#include <iostream>\nusing namespace std;\n#define N 2000005\n#define ll long long\n#define mod 1000000007\nint fac[N],inv[N],t[N],a,b,c,mx,ans;\nint q_pow(int x,int n){int ret=1;for(;n;n>>=1,x=(ll)x*x%mod)if(n&1)ret=(ll)ret*x%mod;return ret;}\nint C(int n,int m){return (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\t// freopen(\"8102.in\",\"r\",stdin);\n\t// freopen(\"8102.out\",\"w\",stdout);\n\tmx=2000000;t[0]=fac[0]=1;\n\tfor(int i=1;i<=mx;i++)fac[i]=(ll)i*fac[i-1]%mod,t[i]=(ll)t[i-1]*3%mod;inv[mx]=q_pow(fac[mx],mod-2);\n\tfor(int i=mx;i;i--)inv[i-1]=(ll)inv[i]*i%mod;\n\t// int T;scanf(\"%d\",&T);\n\t// while(T--)\n\t// {\n\tscanf(\"%d%d%d\",&a,&b,&c);ans=0;int rb=0,rc=0;\n\tfor(int i=0;i<=b+c;i++)\n\t{\n\t\tint tmp=(ll)t[b+c-i]*fac[a+i-1]%mod,w=q_pow(2,i);\n\t\tif(i>b)\n\t\t{\n\t\t\trb=(rb*2)%mod;\n\t\t\trb=(rb+C(i-1,b))%mod;\n\t\t\tw=(w-rb)%mod;\n\t\t}\n\t\tif(i>c)\n\t\t{\n\t\t\trc=(rc*2)%mod;\n\t\t\trc=(rc+C(i-1,c))%mod;\n\t\t\tw=(w-rc)%mod;\n\t\t}\n\t\tw=((ll)w*inv[i])%mod;\n\t\tans=(ans+(ll)w*tmp)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\t// }\n}\n"
  },
  {
    "language": "C++",
    "code": "//整数列a[i],b[i]から列c[k]=sum{a[i]*b[k-i]}を生成する.任意modに対応.O(NlogN).\n//NTT_CONVOLUTION_TIME を適切に変更するのを忘れない\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\n#include <complex>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nstd::vector<int> tmp;\nsize_t sz = 1;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\ninline int powMod(int n, int p, int m) {\n    int res = 1;\n    while (p) {\n        if (p & 1) res = (ll)res * n % m;\n        n = (ll)n * n % m;\n        p >>= 1;\n    }\n    return (int)res;\n}\ninline int invMod(int n, int m) {\n    return powMod(n, m - 2, m);\n}\n\ntemplate <int Mod, int PrimitiveRoot>\nstruct NTTPart {\n    static std::vector<int> ntt(std::vector<int> a, bool inv = false) {\n        size_t mask = sz - 1;\n        size_t p = 0;\n        for (size_t i = sz >> 1; i >= 1; i >>= 1) {\n            auto& cur = (p & 1) ? tmp : a;\n            auto& nex = (p & 1) ? a : tmp;\n            int e = powMod(PrimitiveRoot, (Mod - 1) / sz * i, Mod);\n            if (inv) e = invMod(e, Mod);\n            int w = 1;\n            for (size_t j = 0; j < sz; j += i) {\n                for (size_t k = 0; k < i; ++k) {\n                    nex[j + k] = (cur[((j << 1) & mask) + k] + (ll)w * cur[(((j << 1) + i) & mask) + k]) % Mod;\n                }\n                w = (ll)w * e % Mod;\n            }\n            ++p;\n        }\n        if (p & 1) std::swap(a, tmp);\n        if (inv) {\n            int invSz = invMod(sz, Mod);\n            for (size_t i = 0; i < sz; ++i) a[i] = (ll)a[i] * invSz % Mod;\n        }\n        return a;\n    }\n    static std::vector<int> mul(std::vector<int> a, std::vector<int> b) {\n        a = ntt(a);\n        b = ntt(b);\n        for (size_t i = 0; i < sz; ++i) a[i] = (ll)a[i] * b[i] % Mod;\n        a = ntt(a, true);\n        return a;\n    }\n};\n\nconstexpr int M[] = {1224736769, 469762049, 167772161};\nconstexpr int PR[] = {3, 3, 3};\nconstexpr int NTT_CONVOLUTION_TIME = 3;\n/*\n    X := max(a)*max(b)*min(|a|, |b|) のとき,\n    NTT_CONVOLUTION_TIME <- 1: X <         1224736769 = 1.2*10^ 9 ~ 2^30\n    NTT_CONVOLUTION_TIME <- 2: X < 575334854091079681 = 5.8*10^17 ~ 2^59\n    NTT_CONVOLUTION_TIME <- 3: X < 2^86 (32bit * 32bit * 10^7くらいまで)\n*/\n\ninline void garner(std::vector<int> *c, int mod) {\n    if (NTT_CONVOLUTION_TIME == 1) {\n        for(auto& x : c[0]) x %= mod;\n    }\n    else if (NTT_CONVOLUTION_TIME == 2) {\n        const int r01 = invMod(M[0], M[1]);\n        for (size_t i = 0; i < sz; ++i) {\n            c[1][i] = (c[1][i] - c[0][i]) * (ll)r01 % M[1];\n            if (c[1][i] < 0) c[1][i] += M[1];\n            c[0][i] = (c[0][i] + (ll)c[1][i] * M[0]) % mod;\n        }\n    }\n    else if (NTT_CONVOLUTION_TIME == 3) {\n        const int R01 = invMod(M[0], M[1]);\n        const int R02 = invMod(M[0], M[2]);\n        const int R12 = invMod(M[1], M[2]);\n        const int M01 = (ll)M[0] * M[1] % mod;\n        for (size_t i = 0; i < sz; ++i) {\n            c[1][i] = (c[1][i] - c[0][i]) * (ll)R01 % M[1];\n            if (c[1][i] < 0) c[1][i] += M[1];\n            c[2][i] = ((c[2][i] - c[0][i]) * (ll)R02 % M[2] - c[1][i]) * R12 % M[2];\n            if (c[2][i] < 0) c[2][i] += M[2];\n            c[0][i] = (c[0][i] + (ll)c[1][i] * M[0] + (ll)c[2][i] * M01) % mod;\n        }\n    }\n}\nstd::vector<int> mul(std::vector<int> a, std::vector<int> b, int mod) {\n    for (auto& x : a) x %= mod;\n    for (auto& x : b) x %= mod;\n\n    size_t m = a.size() + b.size() - 1;\n    sz = 1;\n    while (m > sz) sz <<= 1;\n    tmp.resize(sz);\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n\n    std::vector<int> c[NTT_CONVOLUTION_TIME];\n    if (NTT_CONVOLUTION_TIME >= 1) c[0] = NTTPart<M[0], PR[0]>::mul(a, b);\n    if (NTT_CONVOLUTION_TIME >= 2) c[1] = NTTPart<M[1], PR[1]>::mul(a, b);\n    if (NTT_CONVOLUTION_TIME >= 3) c[2] = NTTPart<M[2], PR[2]>::mul(a, b);\n    for (auto& v : c) v.resize(m);\n    garner(c, mod);\n    return c[0];\n}\n\nint main(void){\n    ll n,m,k;\n    cin>>n>>m>>k;\n    vector<int> X,B,C;\n    rep(i,m+1){\n      B.push_back(gyaku_kaijo(i));\n    }\n    rep(i,k+1){\n      C.push_back(gyaku_kaijo(i));\n    }\n    //多項式の係数配列C = 多項式の係数配列A * 多項式の係数配列B\n    //NTT_CONVOLUTION_TIMEを変更するのを忘れない\n    X = mul(B,C,MOD);\n    //bとc合わせてX回出たバターンの網羅\n    ll ans = 0;\n    rep(x,X.size()){\n      ans += kaijo(n-1+x) * gyaku_kaijo(n-1) %MOD * X[x] %MOD * mpow(3,n+m+k-n-x) %MOD;\n      ans %= MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n\treturn ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n\treturn ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n\tint ans = 1 , base = a ;\n\twhile( b ) {\n\t\tif( b&1 ) ans = mul( ans , base ) ;\n\t\tbase = mul( base , base ) ; \n\t\tb >>= 1 ;\n\t}\n\treturn ans ;\n}\n\nll inv( ll x ) {\n\treturn power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n\treturn ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n\tscanf( \"%d%d%d\" , &n , &m , &k ) ;\n\tfac[ 0 ] = 1ll ;\n\tp[ 0 ] = 1ll ;\n\tfor( int i = 1 ; i < N ; i ++ ) {\n\t\tfac[ i ] = fac[ i - 1 ] * i % mod ;\n\t\tp[ i ] = p[ i - 1 ] * 3ll % mod ;\n\t}\n\tfor( int i = 0 ; i < N ; i ++ ) {\n\t\tifac[ i ] = inv( fac[ i ] ) ;\n\t}\n\tll ans = 0 , x = 1ll ;\n\tn -- ;\n\tfor( int i = 0 ; i < m + k ; i ++ ) {\n\t\tans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n\t\tfor( int j = 0 ; j <= m ; j ++ ) {\n\t\t\tif( i - j > k || i - j < 0 ) break ;\n\t\t\tx = add( x , C( i , j ) ) ;\n\t\t}\n\t\t/*\n\t\tif( i < k ) x = ( x * 2ll ) % mod ;\n\t\telse if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n\t\telse  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n\t\t*/\n\t}\n\tprintf( \"%lld\\n\" , add( ans , mod ) ) ;\n\treturn 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n\ncs ll mod=1000000007;\n\nll fac[1000001]={1,1},inv[1000001]={1,1},ifac[1000001]={1,1};\n\ninline\nll C(int n,int m){\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint n,m,k,maxn;\n\nint main(){\n\t\n\tfor(int re i=2;i<=1000000;++i)\n\tfac[i]=fac[i-1]*i%mod,\n\tinv[i]=(mod-mod/i)*inv[mod%i]%mod,\n\tifac[i]=ifac[i-1]*inv[i]%mod;\n\t\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\t--n;\n\tmaxn=max(n,m+k);\n\tll sum=1,ans=1;\n\tfor(int re i=1;i<=maxn;++i){\n\t\tsum=(sum<<1)%mod;\n\t\tif(i>m)sum=(sum+mod-C(i-1,m))%mod;\n\t\tif(i>k)sum=(sum+mod-C(i-1,k))%mod;\n\t\tcerr<<\"sum : \"<<sum<<endl;\n\t\tans=ans*3%mod;\n\t\tans=(ans+C(n+i,i)*sum%mod)%mod;\n\t\tcerr<<\"ans : \"<<ans<<endl;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,m,k;\nconst int FMAX = 600002;\nll fact[FMAX];\nll ifact[FMAX];\n\nll modpow(ll a,ll b,ll c){\n  ll r = 1;\n  while(b){\n    if(b&1)r=r*a%c;\n    a=a*a%c;\n    b>>=1;\n  }\n  return r;\n}\nll modinv(ll a,ll c){\n  return modpow(a,c-2,c);\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&m,&k);\n  // fact init\n  fact[0] = 1;\n  FOR(i,1,FMAX)fact[i]=fact[i-1]*i%MOD;\n  ifact[FMAX-1]=modinv(fact[FMAX-1],MOD);\n  FORR(i,0,FMAX-1)ifact[i]=ifact[i+1]*(i+1)%MOD;\n  // a == n-1 && b <= m && c <= k\n  ll ans = 0;\n  int a = n-1;\n  ll bipow = 1;\n  ll subsum = 0;\n  ll tris = modpow(3,m+k,MOD);\n  ll invtri = modinv(3,MOD);\n  ll factabc = (a==0?1:fact[a-1]);\n  int befbeg,befend;\n  FOR(s,0,m+k+1){\n    // c = s-b\n    // 0<=c<=k\n    // 0<=b<=m\n\n    // s-b>=0 -> b<=s\n    // s-b<=k -> b>=s-k\n    int abc = a+s;\n    factabc = factabc*abc%MOD;\n    ll unit = factabc*ifact[a]%MOD*ifact[s]%MOD*tris%MOD;\n    tris = tris*invtri%MOD;\n\n    int beg = max(s-k,0);\n    int end = min(s,m);\n    if(s>0){\n      bipow += bipow;\n      subsum *= 2;\n      if(befbeg+1==beg){\n        subsum += fact[s-1]*ifact[befbeg]%MOD*ifact[s-1-befbeg]%MOD;\n      }\n      if(befend==end){\n        subsum += fact[s-1]*ifact[befend]%MOD*ifact[s-1-befend]%MOD;\n      }\n      if(bipow>=MOD)bipow-=MOD;\n      subsum %= MOD;\n    }\n    befbeg = beg;\n    befend = end;\n    ans += unit*(bipow+MOD-subsum)%MOD;\n    if(ans>=MOD)ans-=MOD;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int N = 3e5 + 5;\nconst int mod = 1e9 + 7;\n\nint fact[N], inv_fact[N], pw[N];\n\nint binPow (int x, int y) {\n    int ans = 1;\n    while (y) {\n        if (y & 1) ans = (ans * x) % mod;\n        x = (x * x) % mod;\n        y >>= 1;\n    }\n\n    return ans;\n}\n\nint C (int n, int k) {\n    int ans = 1;\n    ans *= fact[n]; ans %= mod;\n    ans *= inv_fact[k]; ans %= mod;\n    ans *= inv_fact[n - k]; ans %= mod;\n\n    return ans;\n}\n\nsigned main(){\n    fact[0] = inv_fact[0] = pw[0] = 1;\n    for (int i = 1; i < N; i++) {\n        pw[i] = (pw[i - 1] * 3) % mod;\n        fact[i] = (i * fact[i - 1]) % mod;\n        inv_fact[i] = binPow(fact[i], mod - 2);\n    }\n\n    int n, m, k;\n    scanf(\"%lld %lld %lld\", &n, &m, &k);\n    int ans = 0;\n\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= k; j++) {\n            ans = (ans + C(i + j, i) * C(i + j + n - 1, i + j) % mod * pw[m + k - i - j]) % mod;\n        }\n    }\n\n    printf(\"%lld\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) { os << \"[ \"; \n\tfor(auto v:V)os << v << \" \"; return os << \"]\";\n}\ntemplate<class T> ostream& operator<<(ostream &os, set<T> S){ os << \"{ \"; \n\tfor(auto s:S) os<<s<<\" \";  return os<<\"}\"; \n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os<<\"(\"<<P.first<<\",\"<< P.second << \")\";\n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, map<L,R> M) {\n\tos<<\"{ \";for(auto m:M)os<<\"(\"<<m.F<<\":\"<<m.S<<\")\";\n\treturn os<<\"}\";\n}\n#define cerr cout\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define For(i,n) for(int i=0;i<(int)n;++i)\n#define Rev(i,n) for(int i=(int)n-1;i>=0;--i)\n#define Rep(i,n) for(int i=1;i<=(int)n;++i)\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\ntypedef vector<pii> vpii;\n#define fio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n\nconst int N = 1e6 + 100;\nconst int mod = 1e9 + 7;\n\ninline int mul(int a , int b){\n\treturn a*1ll*b%mod;\n}\ninline int mul(int a , int b, int c){\n\treturn mul(a , mul(b , c));\n}\ninline int sub(int a , int b){\n\ta -= b;\n\tif(a < 0) a += mod;\n\treturn a;\n}\ninline int add(int a , int b){\n\ta += b;\n\tif(a >= mod) a -= mod;\n\treturn a;\n}\ninline int power(int x, int y){\n\tint res = 1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres = mul(res , x);\n\t\tx = mul(x , x);\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint fac[N] , inv[N];\nint pr[N];\nint pr2[N];\nint dp[N];\nint dp2[N];\nint nCr(int n , int r){\n\tif(r < 0 || r > n) return 0;\n\treturn mul(fac[n] , mul(inv[r] , inv[n-r]));\n}\n\nint main(){\n\tfio; cout<<fixed<<setprecision(25);\t\n\tfac[0] = 1;\n\tpr[0] = 1;\n\tpr2[0] = 1;\n\tfor(int i = 1;i< N ; ++i){\n\t\tpr[i] = mul(pr[i-1] , 3);\n\t\tpr2[i] = mul(pr2[i-1] , 2);\n\t\tfac[i] = mul(fac[i-1] , i);\n\t}\n\tinv[N-1] = power(fac[N-1] , mod-2);\n\tfor(int i = N-2 ; i >= 0 ; --i){\n\t\tinv[i] = mul(inv[i+1] , i+1);\n\t}\n\tassert(inv[0] == 1);\n\tint n , m , k; cin >> n >> m >> k;\n\tif(m > k) swap(m , k);\n\tint ans = 0;\n\t// for(int i = 0;i <= m ; ++i){\n\t// \tfor(int j = 0;j <= k ; ++j){\n\t// \t\tans = add(ans , mul( mul(mul( 1 , 1)  , mul(nCr(n-1+i+j , n-1) , nCr(i+j , i) )) , pr[m-i+k-j]  ) );\n\t// \t\t// trace(i , j , ans);\n\t// \t}\n\t// }\n\n\n\tfor(int i = 0 ;i <= m+k ; ++i){\n\n\n\t\tif(i <= k){\n\t\t\tdp[i] = pr2[i];\n\t\t}\n\t\telse{\n\t\t\tdp[i] =  sub( mul(2 , dp[i-1]) , nCr(i-1 , k));\n\t\t}\n\t\tif(i <= m){\n\t\t\tdp2[i] = pr2[i];\n\t\t}\n\t\telse{\n\t\t\tdp2[i] =  sub( mul(2 , dp2[i-1]) , nCr(i-1 , m));\n\t\t}\n\t\tif(i <= k){\n\t\t\tans = add(ans ,   mul( nCr(n-1+i , i) , pr2[i] , pr[m+k-i]));\n\t\t}\n\t\telse{\n\t\t\tint ss = add(dp[i] , dp2[i]);\n\t\t\t// trace(ss);\n\t\t\tss = sub(ss , pr2[i]);\n\t\t\t// trace(ss);\n\t\t\t// ss = mul(ss , inv[2]);\n\t\t\t// trace(i , ss);\n\t\t\t// dp[i] = sub( mul(2 , dp[i-1]) , nCr(i-1 , k));\n\t\t\t// trace(i , dp[i]);\n\t\t\tans = add(ans , mul(nCr(n-1+i , i) ,  ss , pr[m+k-i]));\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) { os << \"[ \"; \n\tfor(auto v:V)os << v << \" \"; return os << \"]\";\n}\ntemplate<class T> ostream& operator<<(ostream &os, set<T> S){ os << \"{ \"; \n\tfor(auto s:S) os<<s<<\" \";  return os<<\"}\"; \n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os<<\"(\"<<P.first<<\",\"<< P.second << \")\";\n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, map<L,R> M) {\n\tos<<\"{ \";for(auto m:M)os<<\"(\"<<m.F<<\":\"<<m.S<<\")\";\n\treturn os<<\"}\";\n}\n#define cerr cout\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define For(i,n) for(int i=0;i<(int)n;++i)\n#define Rev(i,n) for(int i=(int)n-1;i>=0;--i)\n#define Rep(i,n) for(int i=1;i<=(int)n;++i)\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\ntypedef vector<pii> vpii;\n#define fio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n\nconst int N = 3e3 + 100;\nconst int mod = 1e9 + 7;\n\ninline int mul(int a , int b){\n\treturn a*1ll*b%mod;\n}\ninline int mul(int a , int b, int c){\n\treturn mul(a , mul(b , c));\n}\ninline int sub(int a , int b){\n\ta -= b;\n\tif(a < 0) a += mod;\n\treturn a;\n}\ninline int add(int a , int b){\n\ta += b;\n\tif(a >= mod) a -= mod;\n\treturn a;\n}\ninline int power(int x, int y){\n\tint res = 1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres = mul(res , x);\n\t\tx = mul(x , x);\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint fac[N] , inv[N];\nint pr[N];\nint pr2[N];\nint dp[N];\nint dp2[N];\nint nCr(int n , int r){\n\tif(r < 0 || r > n) return 0;\n\treturn mul(fac[n] , mul(inv[r] , inv[n-r]));\n}\n\nint main(){\n\tfio; cout<<fixed<<setprecision(25);\t\n\tfac[0] = 1;\n\tpr[0] = 1;\n\tpr2[0] = 1;\n\tfor(int i = 1;i< N ; ++i){\n\t\tpr[i] = mul(pr[i-1] , 3);\n\t\tpr2[i] = mul(pr2[i-1] , 2);\n\t\tfac[i] = mul(fac[i-1] , i);\n\t}\n\tinv[N-1] = power(fac[N-1] , mod-2);\n\tfor(int i = N-2 ; i >= 0 ; --i){\n\t\tinv[i] = mul(inv[i+1] , i+1);\n\t}\n\tassert(inv[0] == 1);\n\tint n , m , k; cin >> n >> m >> k;\n\tif(m > k) swap(m , k);\n\tint ans = 0;\n\t// for(int i = 0;i <= m ; ++i){\n\t// \tfor(int j = 0;j <= k ; ++j){\n\t// \t\tans = add(ans , mul( mul(mul( 1 , 1)  , mul(nCr(n-1+i+j , n-1) , nCr(i+j , i) )) , pr[m-i+k-j]  ) );\n\t// \t\t// trace(i , j , ans);\n\t// \t}\n\t// }\n\n\n\tfor(int i = 0 ;i <= m+k ; ++i){\n\n\n\t\tif(i <= k){\n\t\t\tdp[i] = pr2[i];\n\t\t}\n\t\telse{\n\t\t\tdp[i] =  sub( mul(2 , dp[i-1]) , nCr(i-1 , k));\n\t\t}\n\t\tif(i <= m){\n\t\t\tdp2[i] = pr2[i];\n\t\t}\n\t\telse{\n\t\t\tdp2[i] =  sub( mul(2 , dp[i-1]) , nCr(i-1 , m));\n\t\t}\n\t\tif(i <= k){\n\t\t\tans = add(ans ,   mul( nCr(n-1+i , i) , pr2[i] , pr[m+k-i]));\n\t\t}\n\t\telse{\n\t\t\tint ss = add(dp[i] , dp2[i]);\n\t\t\t// trace(ss);\n\t\t\tss = sub(ss , pr2[i]);\n\t\t\t// trace(ss);\n\t\t\t// ss = mul(ss , inv[2]);\n\t\t\t// trace(i , ss);\n\t\t\t// dp[i] = sub( mul(2 , dp[i-1]) , nCr(i-1 , k));\n\t\t\t// trace(i , dp[i]);\n\t\t\tans = add(ans , mul(nCr(n-1+i , i) ,  ss , pr[m+k-i]));\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <deque>\nusing namespace std;\nconstexpr int mod = 1000000007;\nint pascal[5000][5000];\nint pow3[5000];\nint main() {\n    pascal[0][0] = 1;\n    for(int i = 1; i < 5000; i++) {\n        pascal[i][0] = 1;\n        for(int j = 1; j < i; j++)\n            pascal[i][j] =\n                (pascal[i - 1][j] + pascal[i - 1][j - 1]) % mod;\n        pascal[i][i] = 1;\n    }\n    pow3[0] = 1;\n    for(int i = 1; i < 5000; i++)\n        pow3[i] = pow3[i - 1] * 3LL % mod;\n\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n    int ans = 0;\n    for(int i = 0; i <= m; i++)\n        for(int j = 0; j <= k; j++) {\n            ans += (long long) pascal[n - 1 + i + j][n - 1]\n                    * pascal[i + j][i] % mod\n                    * pow3[m + k - i - j] % mod;\n            ans %= mod;\n        }\n    printf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PP;\ntypedef complex<double> com;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize = 600010;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nvector<ll> fac(modsize + 5);\nvector<ll> inv(modsize + 5);\nvector<ll> facinv(modsize + 5);\n\nvoid modcalc() {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = facinv[1] = 1;\n\tfor (int i = 2; i < modsize; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn modcomb(n + k - 1, k);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tmodcalc();\n\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tint ans = 0;\n\tint p = 1;\n\trep(i, b + c + 1) {\n\t\tint cnt = modpow(3, b + c - i);\n\t\tcnt *= modcomb(a + i - 1, a - 1); cnt %= mod;\n\t\tcnt *= p; cnt %= mod;\n\t\tans += cnt; if (ans > mod) ans -= mod;\n\t\tp *= 2; p += 2 * mod;\n\t\tp -= modcomb(i, b); p -= modcomb(i, c); p %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n\n#include <cassert>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\ninline void ModMul(int& x, int y) {\n    x = (1LL * x * y) % MOD;\n}\n\ninline int GetModMul(int x, int y) {\n    ModMul(x, y);\n    return x;\n}\n\ninline void ModSum(int& x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n    if (x < 0) {\n        x += MOD;\n    }\n}\n\ninline int GetModSum(int x, int y) {\n    ModSum(x, y);\n    return x;\n}\n\ninline int GetBinaryPow(int x, int pw) {\n    int r = 1;\n    while (pw > 0) {\n        if (pw & 1) {\n            ModMul(r, x);\n        }\n        ModMul(x, x);\n        pw >>= 1;\n    }\n    return r;\n}\n\ninline int GetInv(int x) {\n    return GetBinaryPow(x, MOD - 2);\n}\n\nconst int MAX_N = 3e5;\nconst int MAX_FACT = 2 * MAX_N + 100;\n\nvector<int> fact(MAX_FACT);\nvector<int> invFact(MAX_FACT);\n\nvoid BuildFact() {\n    fact[0] = 1;\n    for (int i = 1; i < MAX_FACT; ++i) {\n        fact[i] = fact[i - 1];\n        ModMul(fact[i], i);\n    }\n    for (int i = 0; i < MAX_FACT; ++i) {\n        invFact[i] = GetInv(fact[i]);\n    }\n}\n\ninline int GetC(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n    int r = fact[n];\n    ModMul(r, invFact[k]);\n    ModMul(r, invFact[n - k]);\n    return r;\n}\n\ninline int GetCoeff(int n, int m) {\n    if (n == 0) {\n        return 0;\n    }\n    return GetC(n + m - 1, n - 1);\n}\n\nint main() {\n    BuildFact();\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> pw3(m + k + 1);\n    pw3[0] = 1;\n    for (int i = 1; i <= m + k; ++i) {\n        pw3[i] = pw3[i - 1];\n        ModMul(pw3[i], 3);\n    }\n\n    int l = 0;\n    int r = 0;\n    int sum = 1;\n\n    int result = 0;\n    for (int s = 0; s <= m + k; ++s) {\n        const int cl = max(0, s - k);\n        const int cr = min(m, s);\n\n        if (l == r) {\n            sum = 0;\n            for (int i = cl; i <= cr; ++i) {\n                ModSum(sum, GetC(s, i));\n            }\n            l = cl;\n            r = cr;\n        } else {\n            ModMul(sum, 2);\n            ++l;\n\n            while (r < cr) {\n                ModSum(sum, GetC(s, r + 1));\n                ++r;\n            }\n            while (l > cl) {\n                ModSum(sum, GetC(s, l - 1));\n                --l;\n            }\n\n            while (r > cr) {\n                ModSum(sum, -GetC(s, r));\n                --r;\n            }\n            while (l < cl) {\n                ModSum(sum, -GetC(s, l));\n                ++l;\n            }\n        }\n\n        int curResult = GetC(s + (n - 1), n - 1);\n        ModMul(curResult, pw3[m + k - s]);\n        ModMul(curResult, sum);\n\n        ModSum(result, curResult);\n    }\n\n    cout << result << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pw(x) (1ll << (x))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,l,r) for(int i=(l);i<(r);++i)\n#define per(i,l,r) for(int i=(r)-1;i>=(l);--i)\n#define dd(x) cout << #x << \" = \" << (x) << \", \"\n#define de(x) cout << #x << \" = \" << (x) << \"\\n\"\n#define endl \"\\n\"\n\n//-----\nconst int N = 1e6 + 7, MOD = 1e9 + 7;\nvoid inc(int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\nint add(int a, int b) { if ((a += b) >= MOD) a -= MOD; return a; }\nint mul(int a, int b) { return ll(a) * b % MOD; }\nint qpow(int a, int b) { int r = 1; for (; b; b >>= 1) { if (b & 1) r = mul(r, a); a = mul(a, a); } return r; }\nint n, m, k;\nint jc[N], ijc[N], pw3[N];\nvoid ini() {\n\tjc[0] = 1; rep(i, 1, N) jc[i] = mul(jc[i - 1], i);\n\tijc[N - 1] = qpow(jc[N - 1], MOD - 2); per(i, 0, N - 1) ijc[i] = mul(ijc[i + 1], i + 1);\n\tpw3[0] = 1; rep(i, 1, N) pw3[i] = mul(pw3[i - 1], 3);\n}\nint C(int a, int b) { return mul(jc[a], mul(ijc[b], ijc[a - b])); }\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tini();//rep(i, 0, 10) rep(j, 0, i + 1) cout << C(i, j) << \" \\n\"[j == i];\n\tcin >> n >> m >> k;\n\tint g = 0, inv2 = qpow(2, MOD - 2);\n\trep(j, 0, k + 1) inc(g, mul(pw3[k - j], C(j + n - 1, j)));\n\tint ans = 0;\n\trep(i, 0, m + 1) {\n\t\tinc(ans, mul(pw3[m - i], mul(C(i + n - 1, i), g)));\n\t\tg = mul(g, 3);\n\t\tinc(g, MOD - C(i + k + n, i + n));\n\t\tg = mul(g, inv2);\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tpl<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\n//------------------------------------------------------------------------------\n\nconst lli MOD = 1e9+7;\nlli cnk[3002][3002];\nlli p3[1000001];\n\nlli fexp(lli a, lli b) {\n  if(b == 1) return a;\n  lli c = fexp(a, b/2);\n  c = (c*c)%MOD;\n  if(b&1) c = (c*a)%MOD;\n  return c;\n}\n\nlli invmod(lli a) {\n  return fexp(a, MOD-2);\n}\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  lli n, m, k; cin >> n >> m >> k;\n  p3[0] = 1; FOR(i, 1000000) p3[i+1]=(3*p3[i])%MOD;\n  FOR(i, 3000) {\n    cnk[i][0] = 1;\n    cnk[i][i] = 1;\n    FORU(j, 1, i-1) cnk[i][j] = (cnk[i-1][j-1]+cnk[i-1][j])%MOD;\n  }\n  lli ans = 0;\n  lli cur0 = 1;\n  lli l0 = 0, l1 = 0;\n  lli v0 = 1, v1 = 1;\n  lli s0 = 0;\n  FORU(i, n, n+m+k) {\n    lli nl0 = max<lli>(0, i-n-m);\n    lli nl1 = min<lli>(i-n, k);\n    lli nv0, nv1;\n    lli nv00, nv01;\n    lli nv10, nv11;\n    nv00 = (v0+((v0*(i-1-n-l0))%MOD)*invmod(nl0))%MOD;\n    nv00 += MOD; nv00 %= MOD;\n    nv01 = 1;\n    if(nl0>l0) {\n      nv0 = nv00;\n    }else{\n      nv0 = nv01;\n    }\n    nv10 = (v1+((v1*(i-1-n-l1))%MOD)*invmod(nl1))%MOD;\n    nv10 += MOD; nv10 %= MOD;\n    nv11 = (v1+((v1*invmod(i-n-l1))%MOD)*(l1))%MOD;\n    nv11 += MOD; nv11 %= MOD;\n    if(nl1>l1){\n      nv1 = nv10;\n    }else{\n      nv1 = nv11;\n    }\n    if(nl0==nl1) s0 = 0;\n    else if(nl0+1==nl1) {\n      s0=nv1;\n    } else {\n      lli ns0 = s0+s0-v1+v0;\n      ns0%=MOD;\n      if(nl1>l1) ns0 += nv1;\n      if(nl0>l0) ns0 -= nv0;\n      ns0 %= MOD;\n      ns0 += MOD;\n      ns0 %= MOD;\n      s0 = ns0;\n    }\n    // FORU(j, nl0, nl1) {\n    //   s += cnk[i-n][j];\n    // }\n    lli s = nv0+s0;\n    l0 = nl0; l1 = nl1;\n    v0 = nv0; v1 = nv1;\n    s %= MOD;\n    s *= cur0;\n    s %= MOD;\n    s *= p3[n+m+k-i];\n    s %= MOD;\n    (ans += s) %= MOD;\n\n    cur0 = cur0+((cur0*invmod(i-n+1))%MOD)*(n-1); cur0 %= MOD; cur0 += MOD; cur0 %= MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace IntModulo\n{\n\tconst int mod = 1e9 + 7;\n\n\tinline int add(int x, int y, int m = mod)\n\t{\n\t\tif (x + y < m)\n\t\t\treturn x + y;\n\t\treturn x + y - m;\n\t}\n\n\tinline int sub(int x, int y, int m = mod)\n\t{\n\t\tif (x >= y)\n\t\t\treturn x - y;\n\t\treturn x - y + m;\n\t}\n\n\tinline int mult(int x, int y, int m = mod)\n\t{\n\t\treturn x * (LL) y % m;\n\t}\n\n\tinline int power(int x, int y, int m = mod)\n\t{\n\t\tint r = 1;\n\t\twhile(y)\n\t\t{\n\t\t\tif (y & 1)\n\t\t\t\tr = mult(r, x, m);\n\t\t\tx = mult(x, x, m);\n\t\t\ty >>= 1;\n\t\t}\n\t\t\n\t\treturn r;\n\t}\n\t\n\tinline int inverse(int x, int m = mod)\n\t{\n\t\treturn power(x, m - 2, m);\n\t}\n\t\n\tinline void ADD(int& x, int y, int m = mod)\n\t{\n\t\tx += y;\n\t\tif (x >= m) x -= m;\n\t}\n\t\n\tinline void SUB(int& x, int y, int m = mod)\n\t{\n\t\tx -= y;\n\t\tif (x < 0) x += m;\n\t}\n\t\n\tinline void MULT(int& x, int y, int m = mod)\n\t{\n\t\tx = (x * (LL) y) % m;\n\t}\n};\n\nnamespace Combinatorics\n{\n\tusing namespace IntModulo;\n\t\n\tconst int N = 1 << 20;\n\tint fact[N];\n\tint inv[N];\n\tint invFact[N];\n\tbool inited = false;\n\t\n\tinline int C(int n, int k) // binomial C(n, k)\n\t{\n\t\treturn n < k ? 0 : mult(fact[n], mult(invFact[k], invFact[n - k]));\n\t}\n\t\n\tinline int H(int n, int k) // number of solution x1 + .. + xn = k\n\t{\n\t\treturn C(n + k - 1, k);\n\t}\n\t\n\tvoid init()\n\t{\n\t\tdebug(Combinatorics::N);\n\t\tinited = true;\n\t\tinv[1] = 1;\n\t\tFOR(i, 2, N)\n\t\t\tinv[i] = mult(mod - mod / i, inv[mod % i]);\n\t\t\n\t\tinvFact[0] = fact[0] = 1;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tfact[i] = mult(i, fact[i - 1]);\n\t\t\tinvFact[i] = mult(invFact[i - 1], inv[i]);\n\t\t}\n\t}\t\n};\n\nusing namespace Combinatorics;\n\nnamespace FFT\n{\n\tnamespace FastNTT998244353\n\t{\n\t\tconst int MOD = 998244353;\n\t\t \n\t\tstruct mod_int {\n\t\t\tint val;\n\t\t \n\t\t\tmod_int(long long v = 0) {\n\t\t\t\tif (v < 0) v = v % MOD + MOD;\n\t\t\t\tif (v >= MOD) v %= MOD;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t \n\t\t\tstatic int mod_inv(int a, int m = MOD) {\n\t\t\t\t// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n\t\t\t\tint g = m, r = a, x = 0, y = 1;\n\t\t \n\t\t\t\twhile (r != 0) {\n\t\t\t\t\tint q = g / r;\n\t\t\t\t\tg %= r; swap(g, r);\n\t\t\t\t\tx -= q * y; swap(x, y);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn x < 0 ? x + m : x;\n\t\t\t}\n\t\t \n\t\t\texplicit operator int() const {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator+=(const mod_int &other) {\n\t\t\t\tval += other.val;\n\t\t\t\tif (val >= MOD) val -= MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator-=(const mod_int &other) {\n\t\t\t\tval -= other.val;\n\t\t\t\tif (val < 0) val += MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tstatic unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n\t\t#if !defined(_WIN32) || defined(_WIN64)\n\t\t\t\treturn x % m;\n\t\t#endif\n\t\t\t\t// Optimized mod for Codeforces 32-bit machines.\n\t\t\t\t// x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n\t\t\t\tunsigned x_high = x >> 32, x_low = (unsigned) x;\n\t\t\t\tunsigned quot, rem;\n\t\t\t\tasm(\"divl %4\\n\"\n\t\t\t\t\t: \"=a\" (quot), \"=d\" (rem)\n\t\t\t\t\t: \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n\t\t\t\treturn rem;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator*=(const mod_int &other) {\n\t\t\t\tval = fast_mod((uint64_t) val * other.val);\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator/=(const mod_int &other) {\n\t\t\t\treturn *this *= other.inv();\n\t\t\t}\n\t\t \n\t\t\tfriend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n\t\t\tfriend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n\t\t\tfriend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n\t\t\tfriend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\t\t \n\t\t\tmod_int& operator++() {\n\t\t\t\tval = val == MOD - 1 ? 0 : val + 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator--() {\n\t\t\t\tval = val == 0 ? MOD - 1 : val - 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n\t\t\tmod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\t\t \n\t\t\tmod_int operator-() const {\n\t\t\t\treturn val == 0 ? 0 : MOD - val;\n\t\t\t}\n\t\t \n\t\t\tbool operator==(const mod_int &other) const { return val == other.val; }\n\t\t\tbool operator!=(const mod_int &other) const { return val != other.val; }\n\t\t \n\t\t\tmod_int inv() const {\n\t\t\t\treturn mod_inv(val);\n\t\t\t}\n\t\t \n\t\t\tmod_int pow(long long p) const {\n\t\t\t\tassert(p >= 0);\n\t\t\t\tmod_int a = *this, result = 1;\n\t\t \n\t\t\t\twhile (p > 0) {\n\t\t\t\t\tif (p & 1)\n\t\t\t\t\t\tresult *= a;\n\t\t \n\t\t\t\t\ta *= a;\n\t\t\t\t\tp >>= 1;\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tfriend ostream& operator<<(ostream &stream, const mod_int &m) {\n\t\t\t\treturn stream << m.val;\n\t\t\t}\n\t\t};\n\t\t \n\t\tnamespace NTT {\n\t\t\tvector<mod_int> roots = {0, 1};\n\t\t\tvector<int> bit_reverse;\n\t\t\tint max_size = -1;\n\t\t\tmod_int root;\n\t\t \n\t\t\tbool is_power_of_two(int n) {\n\t\t\t\treturn (n & (n - 1)) == 0;\n\t\t\t}\n\t\t \n\t\t\tint round_up_power_two(int n) {\n\t\t\t\twhile (n & (n - 1))\n\t\t\t\t\tn = (n | (n - 1)) + 1;\n\t\t \n\t\t\t\treturn max(n, 1);\n\t\t\t}\n\t\t \n\t\t\t// Given n (a power of two), finds k such that n == 1 << k.\n\t\t\tint get_length(int n) {\n\t\t\t\tassert(is_power_of_two(n));\n\t\t\t\treturn __builtin_ctz(n);\n\t\t\t}\n\t\t \n\t\t\t// Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n\t\t\t// This makes even-odd div-conquer much easier.\n\t\t\tvoid bit_reorder(int n, vector<mod_int> &values) {\n\t\t\t\tif ((int) bit_reverse.size() != n) {\n\t\t\t\t\tbit_reverse.assign(n, 0);\n\t\t\t\t\tint length = get_length(n);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tbit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n\t\t\t\t}\n\t\t \n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif (i < bit_reverse[i])\n\t\t\t\t\t\tswap(values[i], values[bit_reverse[i]]);\n\t\t\t}\n\t\t \n\t\t\tvoid find_root() {\n\t\t\t\tmax_size = 1 << __builtin_ctz(MOD - 1);\n\t\t\t\troot = 2;\n\t\t \n\t\t\t\t// Find a max_size-th primitive root of MOD.\n\t\t\t\twhile (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n\t\t\t\t\troot++;\n\t\t\t}\n\t\t \n\t\t\tvoid prepare_roots(int n) {\n\t\t\t\tif (max_size < 0)\n\t\t\t\t\tfind_root();\n\t\t \n\t\t\t\tassert(n <= max_size);\n\t\t \n\t\t\t\tif ((int) roots.size() >= n)\n\t\t\t\t\treturn;\n\t\t \n\t\t\t\tint length = get_length(roots.size());\n\t\t\t\troots.resize(n);\n\t\t \n\t\t\t\t// The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n\t\t\t\t// the first half of the n-th primitive roots of MOD.\n\t\t\t\twhile (1 << length < n) {\n\t\t\t\t\t// z is a 2^(length + 1)-th primitive root of MOD.\n\t\t\t\t\tmod_int z = root.pow(max_size >> (length + 1));\n\t\t \n\t\t\t\t\tfor (int i = 1 << (length - 1); i < 1 << length; i++) {\n\t\t\t\t\t\troots[2 * i] = roots[i];\n\t\t\t\t\t\troots[2 * i + 1] = roots[i] * z;\n\t\t\t\t\t}\n\t\t \n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tvoid fft_iterative(int N, vector<mod_int> &values) {\n\t\t\t\tassert(is_power_of_two(N));\n\t\t\t\tprepare_roots(N);\n\t\t\t\tbit_reorder(N, values);\n\t\t \n\t\t\t\tfor (int n = 1; n < N; n *= 2)\n\t\t\t\t\tfor (int start = 0; start < N; start += 2 * n)\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\tmod_int even = values[start + i];\n\t\t\t\t\t\t\tmod_int odd = values[start + n + i] * roots[n + i];\n\t\t\t\t\t\t\tvalues[start + n + i] = even - odd;\n\t\t\t\t\t\t\tvalues[start + i] = even + odd;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tconst int FFT_CUTOFF = 150;\n\t\t \n\t\t\tvector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n\t\t\t\tint n = left.size();\n\t\t\t\tint m = right.size();\n\t\t \n\t\t\t\t// Brute force when either n or m is small enough.\n\t\t\t\tif (min(n, m) < FFT_CUTOFF) {\n\t\t\t\t\tconst uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n\t\t\t\t\tvector<uint64_t> result(n + m - 1, 0);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tresult[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\t\t \n\t\t\t\t\t\t\tif (result[i + j] > ULL_BOUND)\n\t\t\t\t\t\t\t\tresult[i + j] %= MOD;\n\t\t\t\t\t\t}\n\t\t \n\t\t\t\t\tfor (uint64_t &x : result)\n\t\t\t\t\t\tif (x >= MOD)\n\t\t\t\t\t\t\tx %= MOD;\n\t\t \n\t\t\t\t\treturn vector<mod_int>(result.begin(), result.end());\n\t\t\t\t}\n\t\t \n\t\t\t\tint N = round_up_power_two(n + m - 1);\n\t\t\t\tleft.resize(N);\n\t\t\t\tright.resize(N);\n\t\t \n\t\t\t\tbool equal = left == right;\n\t\t\t\tfft_iterative(N, left);\n\t\t \n\t\t\t\tif (equal)\n\t\t\t\t\tright = left;\n\t\t\t\telse\n\t\t\t\t\tfft_iterative(N, right);\n\t\t \n\t\t\t\tmod_int inv_N = mod_int(N).inv();\n\t\t \n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t\tleft[i] *= right[i] * inv_N;\n\t\t \n\t\t\t\treverse(left.begin() + 1, left.end());\n\t\t\t\tfft_iterative(N, left);\n\t\t\t\tleft.resize(n + m - 1);\n\t\t\t\treturn left;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n\t\t\t\tassert(exponent >= 0);\n\t\t\t\tvector<mod_int> result = {1};\n\t\t \n\t\t\t\tif (exponent == 0)\n\t\t\t\t\treturn result;\n\t\t \n\t\t\t\tfor (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n\t\t\t\t\tresult = mod_multiply(result, result);\n\t\t \n\t\t\t\t\tif (exponent >> k & 1)\n\t\t\t\t\t\tresult = mod_multiply(result, v);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_multiply_all(const vector<vector<mod_int>> &polynomials) {\n\t\t\t\tif (polynomials.empty())\n\t\t\t\t\treturn {1};\n\t\t \n\t\t\t\tstruct compare_size {\n\t\t\t\t\tbool operator()(const vector<mod_int> &x, const vector<mod_int> &y) {\n\t\t\t\t\t\treturn x.size() > y.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t \n\t\t\t\tpriority_queue<vector<mod_int>, vector<vector<mod_int>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\t\t \n\t\t\t\twhile (pq.size() > 1) {\n\t\t\t\t\tvector<mod_int> a = pq.top(); pq.pop();\n\t\t\t\t\tvector<mod_int> b = pq.top(); pq.pop();\n\t\t\t\t\tpq.push(mod_multiply(a, b));\n\t\t\t\t}\n\t\t \n\t\t\t\treturn pq.top();\n\t\t\t}\n\t\t};\n\n\t};\n\t\n\tnamespace FastNTT584581121\n\t{\n\t\tconst int MOD = 584581121;\n\t\t \n\t\tstruct mod_int {\n\t\t\tint val;\n\t\t \n\t\t\tmod_int(long long v = 0) {\n\t\t\t\tif (v < 0) v = v % MOD + MOD;\n\t\t\t\tif (v >= MOD) v %= MOD;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t \n\t\t\tstatic int mod_inv(int a, int m = MOD) {\n\t\t\t\t// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n\t\t\t\tint g = m, r = a, x = 0, y = 1;\n\t\t \n\t\t\t\twhile (r != 0) {\n\t\t\t\t\tint q = g / r;\n\t\t\t\t\tg %= r; swap(g, r);\n\t\t\t\t\tx -= q * y; swap(x, y);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn x < 0 ? x + m : x;\n\t\t\t}\n\t\t \n\t\t\texplicit operator int() const {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator+=(const mod_int &other) {\n\t\t\t\tval += other.val;\n\t\t\t\tif (val >= MOD) val -= MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator-=(const mod_int &other) {\n\t\t\t\tval -= other.val;\n\t\t\t\tif (val < 0) val += MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tstatic unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n\t\t#if !defined(_WIN32) || defined(_WIN64)\n\t\t\t\treturn x % m;\n\t\t#endif\n\t\t\t\t// Optimized mod for Codeforces 32-bit machines.\n\t\t\t\t// x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n\t\t\t\tunsigned x_high = x >> 32, x_low = (unsigned) x;\n\t\t\t\tunsigned quot, rem;\n\t\t\t\tasm(\"divl %4\\n\"\n\t\t\t\t\t: \"=a\" (quot), \"=d\" (rem)\n\t\t\t\t\t: \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n\t\t\t\treturn rem;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator*=(const mod_int &other) {\n\t\t\t\tval = fast_mod((uint64_t) val * other.val);\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator/=(const mod_int &other) {\n\t\t\t\treturn *this *= other.inv();\n\t\t\t}\n\t\t \n\t\t\tfriend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n\t\t\tfriend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n\t\t\tfriend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n\t\t\tfriend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\t\t \n\t\t\tmod_int& operator++() {\n\t\t\t\tval = val == MOD - 1 ? 0 : val + 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator--() {\n\t\t\t\tval = val == 0 ? MOD - 1 : val - 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n\t\t\tmod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\t\t \n\t\t\tmod_int operator-() const {\n\t\t\t\treturn val == 0 ? 0 : MOD - val;\n\t\t\t}\n\t\t \n\t\t\tbool operator==(const mod_int &other) const { return val == other.val; }\n\t\t\tbool operator!=(const mod_int &other) const { return val != other.val; }\n\t\t \n\t\t\tmod_int inv() const {\n\t\t\t\treturn mod_inv(val);\n\t\t\t}\n\t\t \n\t\t\tmod_int pow(long long p) const {\n\t\t\t\tassert(p >= 0);\n\t\t\t\tmod_int a = *this, result = 1;\n\t\t \n\t\t\t\twhile (p > 0) {\n\t\t\t\t\tif (p & 1)\n\t\t\t\t\t\tresult *= a;\n\t\t \n\t\t\t\t\ta *= a;\n\t\t\t\t\tp >>= 1;\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tfriend ostream& operator<<(ostream &stream, const mod_int &m) {\n\t\t\t\treturn stream << m.val;\n\t\t\t}\n\t\t};\n\t\t \n\t\tnamespace NTT {\n\t\t\tvector<mod_int> roots = {0, 1};\n\t\t\tvector<int> bit_reverse;\n\t\t\tint max_size = -1;\n\t\t\tmod_int root;\n\t\t \n\t\t\tbool is_power_of_two(int n) {\n\t\t\t\treturn (n & (n - 1)) == 0;\n\t\t\t}\n\t\t \n\t\t\tint round_up_power_two(int n) {\n\t\t\t\twhile (n & (n - 1))\n\t\t\t\t\tn = (n | (n - 1)) + 1;\n\t\t \n\t\t\t\treturn max(n, 1);\n\t\t\t}\n\t\t \n\t\t\t// Given n (a power of two), finds k such that n == 1 << k.\n\t\t\tint get_length(int n) {\n\t\t\t\tassert(is_power_of_two(n));\n\t\t\t\treturn __builtin_ctz(n);\n\t\t\t}\n\t\t \n\t\t\t// Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n\t\t\t// This makes even-odd div-conquer much easier.\n\t\t\tvoid bit_reorder(int n, vector<mod_int> &values) {\n\t\t\t\tif ((int) bit_reverse.size() != n) {\n\t\t\t\t\tbit_reverse.assign(n, 0);\n\t\t\t\t\tint length = get_length(n);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tbit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n\t\t\t\t}\n\t\t \n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif (i < bit_reverse[i])\n\t\t\t\t\t\tswap(values[i], values[bit_reverse[i]]);\n\t\t\t}\n\t\t \n\t\t\tvoid find_root() {\n\t\t\t\tmax_size = 1 << __builtin_ctz(MOD - 1);\n\t\t\t\troot = 2;\n\t\t \n\t\t\t\t// Find a max_size-th primitive root of MOD.\n\t\t\t\twhile (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n\t\t\t\t\troot++;\n\t\t\t}\n\t\t \n\t\t\tvoid prepare_roots(int n) {\n\t\t\t\tif (max_size < 0)\n\t\t\t\t\tfind_root();\n\t\t \n\t\t\t\tassert(n <= max_size);\n\t\t \n\t\t\t\tif ((int) roots.size() >= n)\n\t\t\t\t\treturn;\n\t\t \n\t\t\t\tint length = get_length(roots.size());\n\t\t\t\troots.resize(n);\n\t\t \n\t\t\t\t// The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n\t\t\t\t// the first half of the n-th primitive roots of MOD.\n\t\t\t\twhile (1 << length < n) {\n\t\t\t\t\t// z is a 2^(length + 1)-th primitive root of MOD.\n\t\t\t\t\tmod_int z = root.pow(max_size >> (length + 1));\n\t\t \n\t\t\t\t\tfor (int i = 1 << (length - 1); i < 1 << length; i++) {\n\t\t\t\t\t\troots[2 * i] = roots[i];\n\t\t\t\t\t\troots[2 * i + 1] = roots[i] * z;\n\t\t\t\t\t}\n\t\t \n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tvoid fft_iterative(int N, vector<mod_int> &values) {\n\t\t\t\tassert(is_power_of_two(N));\n\t\t\t\tprepare_roots(N);\n\t\t\t\tbit_reorder(N, values);\n\t\t \n\t\t\t\tfor (int n = 1; n < N; n *= 2)\n\t\t\t\t\tfor (int start = 0; start < N; start += 2 * n)\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\tmod_int even = values[start + i];\n\t\t\t\t\t\t\tmod_int odd = values[start + n + i] * roots[n + i];\n\t\t\t\t\t\t\tvalues[start + n + i] = even - odd;\n\t\t\t\t\t\t\tvalues[start + i] = even + odd;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tconst int FFT_CUTOFF = 150;\n\t\t \n\t\t\tvector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n\t\t\t\tint n = left.size();\n\t\t\t\tint m = right.size();\n\t\t \n\t\t\t\t// Brute force when either n or m is small enough.\n\t\t\t\tif (min(n, m) < FFT_CUTOFF) {\n\t\t\t\t\tconst uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n\t\t\t\t\tvector<uint64_t> result(n + m - 1, 0);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tresult[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\t\t \n\t\t\t\t\t\t\tif (result[i + j] > ULL_BOUND)\n\t\t\t\t\t\t\t\tresult[i + j] %= MOD;\n\t\t\t\t\t\t}\n\t\t \n\t\t\t\t\tfor (uint64_t &x : result)\n\t\t\t\t\t\tif (x >= MOD)\n\t\t\t\t\t\t\tx %= MOD;\n\t\t \n\t\t\t\t\treturn vector<mod_int>(result.begin(), result.end());\n\t\t\t\t}\n\t\t \n\t\t\t\tint N = round_up_power_two(n + m - 1);\n\t\t\t\tleft.resize(N);\n\t\t\t\tright.resize(N);\n\t\t \n\t\t\t\tbool equal = left == right;\n\t\t\t\tfft_iterative(N, left);\n\t\t \n\t\t\t\tif (equal)\n\t\t\t\t\tright = left;\n\t\t\t\telse\n\t\t\t\t\tfft_iterative(N, right);\n\t\t \n\t\t\t\tmod_int inv_N = mod_int(N).inv();\n\t\t \n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t\tleft[i] *= right[i] * inv_N;\n\t\t \n\t\t\t\treverse(left.begin() + 1, left.end());\n\t\t\t\tfft_iterative(N, left);\n\t\t\t\tleft.resize(n + m - 1);\n\t\t\t\treturn left;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n\t\t\t\tassert(exponent >= 0);\n\t\t\t\tvector<mod_int> result = {1};\n\t\t \n\t\t\t\tif (exponent == 0)\n\t\t\t\t\treturn result;\n\t\t \n\t\t\t\tfor (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n\t\t\t\t\tresult = mod_multiply(result, result);\n\t\t \n\t\t\t\t\tif (exponent >> k & 1)\n\t\t\t\t\t\tresult = mod_multiply(result, v);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_multiply_all(const vector<vector<mod_int>> &polynomials) {\n\t\t\t\tif (polynomials.empty())\n\t\t\t\t\treturn {1};\n\t\t \n\t\t\t\tstruct compare_size {\n\t\t\t\t\tbool operator()(const vector<mod_int> &x, const vector<mod_int> &y) {\n\t\t\t\t\t\treturn x.size() > y.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t \n\t\t\t\tpriority_queue<vector<mod_int>, vector<vector<mod_int>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\t\t \n\t\t\t\twhile (pq.size() > 1) {\n\t\t\t\t\tvector<mod_int> a = pq.top(); pq.pop();\n\t\t\t\t\tvector<mod_int> b = pq.top(); pq.pop();\n\t\t\t\t\tpq.push(mod_multiply(a, b));\n\t\t\t\t}\n\t\t \n\t\t\t\treturn pq.top();\n\t\t\t}\n\t\t};\n\n\t};\n\t\n\tnamespace FastNTT590872577\n\t{\n\t\tconst int MOD = 590872577;\n\t\t \n\t\tstruct mod_int {\n\t\t\tint val;\n\t\t \n\t\t\tmod_int(long long v = 0) {\n\t\t\t\tif (v < 0) v = v % MOD + MOD;\n\t\t\t\tif (v >= MOD) v %= MOD;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t \n\t\t\tstatic int mod_inv(int a, int m = MOD) {\n\t\t\t\t// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n\t\t\t\tint g = m, r = a, x = 0, y = 1;\n\t\t \n\t\t\t\twhile (r != 0) {\n\t\t\t\t\tint q = g / r;\n\t\t\t\t\tg %= r; swap(g, r);\n\t\t\t\t\tx -= q * y; swap(x, y);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn x < 0 ? x + m : x;\n\t\t\t}\n\t\t \n\t\t\texplicit operator int() const {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator+=(const mod_int &other) {\n\t\t\t\tval += other.val;\n\t\t\t\tif (val >= MOD) val -= MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator-=(const mod_int &other) {\n\t\t\t\tval -= other.val;\n\t\t\t\tif (val < 0) val += MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tstatic unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n\t\t#if !defined(_WIN32) || defined(_WIN64)\n\t\t\t\treturn x % m;\n\t\t#endif\n\t\t\t\t// Optimized mod for Codeforces 32-bit machines.\n\t\t\t\t// x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n\t\t\t\tunsigned x_high = x >> 32, x_low = (unsigned) x;\n\t\t\t\tunsigned quot, rem;\n\t\t\t\tasm(\"divl %4\\n\"\n\t\t\t\t\t: \"=a\" (quot), \"=d\" (rem)\n\t\t\t\t\t: \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n\t\t\t\treturn rem;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator*=(const mod_int &other) {\n\t\t\t\tval = fast_mod((uint64_t) val * other.val);\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator/=(const mod_int &other) {\n\t\t\t\treturn *this *= other.inv();\n\t\t\t}\n\t\t \n\t\t\tfriend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n\t\t\tfriend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n\t\t\tfriend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n\t\t\tfriend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\t\t \n\t\t\tmod_int& operator++() {\n\t\t\t\tval = val == MOD - 1 ? 0 : val + 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator--() {\n\t\t\t\tval = val == 0 ? MOD - 1 : val - 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n\t\t\tmod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\t\t \n\t\t\tmod_int operator-() const {\n\t\t\t\treturn val == 0 ? 0 : MOD - val;\n\t\t\t}\n\t\t \n\t\t\tbool operator==(const mod_int &other) const { return val == other.val; }\n\t\t\tbool operator!=(const mod_int &other) const { return val != other.val; }\n\t\t \n\t\t\tmod_int inv() const {\n\t\t\t\treturn mod_inv(val);\n\t\t\t}\n\t\t \n\t\t\tmod_int pow(long long p) const {\n\t\t\t\tassert(p >= 0);\n\t\t\t\tmod_int a = *this, result = 1;\n\t\t \n\t\t\t\twhile (p > 0) {\n\t\t\t\t\tif (p & 1)\n\t\t\t\t\t\tresult *= a;\n\t\t \n\t\t\t\t\ta *= a;\n\t\t\t\t\tp >>= 1;\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tfriend ostream& operator<<(ostream &stream, const mod_int &m) {\n\t\t\t\treturn stream << m.val;\n\t\t\t}\n\t\t};\n\t\t \n\t\tnamespace NTT {\n\t\t\tvector<mod_int> roots = {0, 1};\n\t\t\tvector<int> bit_reverse;\n\t\t\tint max_size = -1;\n\t\t\tmod_int root;\n\t\t \n\t\t\tbool is_power_of_two(int n) {\n\t\t\t\treturn (n & (n - 1)) == 0;\n\t\t\t}\n\t\t \n\t\t\tint round_up_power_two(int n) {\n\t\t\t\twhile (n & (n - 1))\n\t\t\t\t\tn = (n | (n - 1)) + 1;\n\t\t \n\t\t\t\treturn max(n, 1);\n\t\t\t}\n\t\t \n\t\t\t// Given n (a power of two), finds k such that n == 1 << k.\n\t\t\tint get_length(int n) {\n\t\t\t\tassert(is_power_of_two(n));\n\t\t\t\treturn __builtin_ctz(n);\n\t\t\t}\n\t\t \n\t\t\t// Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n\t\t\t// This makes even-odd div-conquer much easier.\n\t\t\tvoid bit_reorder(int n, vector<mod_int> &values) {\n\t\t\t\tif ((int) bit_reverse.size() != n) {\n\t\t\t\t\tbit_reverse.assign(n, 0);\n\t\t\t\t\tint length = get_length(n);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tbit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n\t\t\t\t}\n\t\t \n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif (i < bit_reverse[i])\n\t\t\t\t\t\tswap(values[i], values[bit_reverse[i]]);\n\t\t\t}\n\t\t \n\t\t\tvoid find_root() {\n\t\t\t\tmax_size = 1 << __builtin_ctz(MOD - 1);\n\t\t\t\troot = 2;\n\t\t \n\t\t\t\t// Find a max_size-th primitive root of MOD.\n\t\t\t\twhile (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n\t\t\t\t\troot++;\n\t\t\t}\n\t\t \n\t\t\tvoid prepare_roots(int n) {\n\t\t\t\tif (max_size < 0)\n\t\t\t\t\tfind_root();\n\t\t \n\t\t\t\tassert(n <= max_size);\n\t\t \n\t\t\t\tif ((int) roots.size() >= n)\n\t\t\t\t\treturn;\n\t\t \n\t\t\t\tint length = get_length(roots.size());\n\t\t\t\troots.resize(n);\n\t\t \n\t\t\t\t// The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n\t\t\t\t// the first half of the n-th primitive roots of MOD.\n\t\t\t\twhile (1 << length < n) {\n\t\t\t\t\t// z is a 2^(length + 1)-th primitive root of MOD.\n\t\t\t\t\tmod_int z = root.pow(max_size >> (length + 1));\n\t\t \n\t\t\t\t\tfor (int i = 1 << (length - 1); i < 1 << length; i++) {\n\t\t\t\t\t\troots[2 * i] = roots[i];\n\t\t\t\t\t\troots[2 * i + 1] = roots[i] * z;\n\t\t\t\t\t}\n\t\t \n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tvoid fft_iterative(int N, vector<mod_int> &values) {\n\t\t\t\tassert(is_power_of_two(N));\n\t\t\t\tprepare_roots(N);\n\t\t\t\tbit_reorder(N, values);\n\t\t \n\t\t\t\tfor (int n = 1; n < N; n *= 2)\n\t\t\t\t\tfor (int start = 0; start < N; start += 2 * n)\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\tmod_int even = values[start + i];\n\t\t\t\t\t\t\tmod_int odd = values[start + n + i] * roots[n + i];\n\t\t\t\t\t\t\tvalues[start + n + i] = even - odd;\n\t\t\t\t\t\t\tvalues[start + i] = even + odd;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tconst int FFT_CUTOFF = 150;\n\t\t \n\t\t\tvector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n\t\t\t\tint n = left.size();\n\t\t\t\tint m = right.size();\n\t\t \n\t\t\t\t// Brute force when either n or m is small enough.\n\t\t\t\tif (min(n, m) < FFT_CUTOFF) {\n\t\t\t\t\tconst uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n\t\t\t\t\tvector<uint64_t> result(n + m - 1, 0);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tresult[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\t\t \n\t\t\t\t\t\t\tif (result[i + j] > ULL_BOUND)\n\t\t\t\t\t\t\t\tresult[i + j] %= MOD;\n\t\t\t\t\t\t}\n\t\t \n\t\t\t\t\tfor (uint64_t &x : result)\n\t\t\t\t\t\tif (x >= MOD)\n\t\t\t\t\t\t\tx %= MOD;\n\t\t \n\t\t\t\t\treturn vector<mod_int>(result.begin(), result.end());\n\t\t\t\t}\n\t\t \n\t\t\t\tint N = round_up_power_two(n + m - 1);\n\t\t\t\tleft.resize(N);\n\t\t\t\tright.resize(N);\n\t\t \n\t\t\t\tbool equal = left == right;\n\t\t\t\tfft_iterative(N, left);\n\t\t \n\t\t\t\tif (equal)\n\t\t\t\t\tright = left;\n\t\t\t\telse\n\t\t\t\t\tfft_iterative(N, right);\n\t\t \n\t\t\t\tmod_int inv_N = mod_int(N).inv();\n\t\t \n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t\tleft[i] *= right[i] * inv_N;\n\t\t \n\t\t\t\treverse(left.begin() + 1, left.end());\n\t\t\t\tfft_iterative(N, left);\n\t\t\t\tleft.resize(n + m - 1);\n\t\t\t\treturn left;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n\t\t\t\tassert(exponent >= 0);\n\t\t\t\tvector<mod_int> result = {1};\n\t\t \n\t\t\t\tif (exponent == 0)\n\t\t\t\t\treturn result;\n\t\t \n\t\t\t\tfor (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n\t\t\t\t\tresult = mod_multiply(result, result);\n\t\t \n\t\t\t\t\tif (exponent >> k & 1)\n\t\t\t\t\t\tresult = mod_multiply(result, v);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_multiply_all(const vector<vector<mod_int>> &polynomials) {\n\t\t\t\tif (polynomials.empty())\n\t\t\t\t\treturn {1};\n\t\t \n\t\t\t\tstruct compare_size {\n\t\t\t\t\tbool operator()(const vector<mod_int> &x, const vector<mod_int> &y) {\n\t\t\t\t\t\treturn x.size() > y.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t \n\t\t\t\tpriority_queue<vector<mod_int>, vector<vector<mod_int>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\t\t \n\t\t\t\twhile (pq.size() > 1) {\n\t\t\t\t\tvector<mod_int> a = pq.top(); pq.pop();\n\t\t\t\t\tvector<mod_int> b = pq.top(); pq.pop();\n\t\t\t\t\tpq.push(mod_multiply(a, b));\n\t\t\t\t}\n\t\t \n\t\t\t\treturn pq.top();\n\t\t\t}\n\t\t};\n\n\t};\n\t\n\tconst int mod[] = {998244353, 584581121, 590872577};\n\t\n\t__int128 r[3][3];\n\t\n\t__int128 restore(vector<int> a)\n\t{\n\t\t__int128 x[3];\t\t\n\t\tFOR(i, 0, 3)\n\t\t{\n\t\t\tx[i] = a[i];\n\t\t\tFOR(j, 0, i)\n\t\t\t{\n\t\t\t\tx[i] = (x[i] - x[j]) * r[j][i] % mod[i];\t\t \n\t\t\t\tif (x[i] < 0)  x[i] += mod[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t__int128 res = 0;\n\t\tres += x[0];\n\t\tres += x[1] * mod[0];\n\t\tres += x[2] * mod[0] * mod[1];\n\t\treturn res;\n\t}\n\t\n\ttemplate<typename T>\n\tvoid multiply(const vector<T>& A, vector<T>& B, T* __restrict C)\n\t{\n\t\tvector<int> res[3];\n\t\t{\n\t\t\tvector<FastNTT998244353::mod_int> a(SZ(A));\n\t\t\tFOR(j, 0, SZ(a)) a[j] = A[j] % mod[0];\n\t\t\tvector<FastNTT998244353::mod_int> b(SZ(B));\n\t\t\tFOR(j, 0, SZ(b)) b[j] = B[j] % mod[0];\n\t\t\t\n\t\t\tauto res0 = FastNTT998244353::NTT::mod_multiply(a, b);\n\t\t\tres[0].resize(SZ(res0));\n\t\t\tFOR(j, 0, SZ(res[0])) res[0][j] = (int)res0[j];\n\t\t}\n\t\t\n\t\t{\n\t\t\tvector<FastNTT584581121::mod_int> a(SZ(A));\n\t\t\tFOR(j, 0, SZ(a)) a[j] = A[j] % mod[1];\n\t\t\tvector<FastNTT584581121::mod_int> b(SZ(B));\n\t\t\tFOR(j, 0, SZ(b)) b[j] = B[j] % mod[1];\n\t\t\t\n\t\t\tauto res1 = FastNTT584581121::NTT::mod_multiply(a, b);\n\t\t\tres[1].resize(SZ(res1));\n\t\t\tFOR(j, 0, SZ(res[1])) res[1][j] = (int)res1[j];\n\t\t}\n\t\t\n\t\t{\n\t\t\tvector<FastNTT590872577::mod_int> a(SZ(A));\n\t\t\tFOR(j, 0, SZ(a)) a[j] = A[j] % mod[2];\n\t\t\tvector<FastNTT590872577::mod_int> b(SZ(B));\n\t\t\tFOR(j, 0, SZ(b)) b[j] = B[j] % mod[2];\n\t\t\t\n\t\t\tauto res2 = FastNTT590872577::NTT::mod_multiply(a, b);\n\t\t\tres[2].resize(SZ(res2));\n\t\t\tFOR(j, 0, SZ(res[2])) res[2][j] = (int)res2[j];\n\t\t}\n\t\t\n\t\tFOR(i, 0, 3) FOR(j, 0, 3) if (i != j)\n\t\t\tr[i][j] = power(mod[i], mod[j] - 2, mod[j]);\n\t\t\n\t\tFOR(i, 0, SZ(A) + SZ(B) + 1)\n\t\t\tC[i] = restore({res[0][i], res[1][i], res[2][i]});\n\t}\n};\n\nconst int M = 1 << 20;\n__int128 c[M];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tCombinatorics::init();\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tn--;\n\tint ans = 0;\n\tvector<__int128> a(m + 1), b(k + 1);\n\tFOR(i, 0, m + 1) a[i] = invFact[i];\n\tFOR(i, 0, k + 1) b[i] = invFact[i];\n\tFFT::multiply(a, b, c);\n\t\t\n\tFOR(t, 0, m + k + 1)\t\t\n\t\tADD(ans, mult(fact[t], mult(c[t] % mod, mult(C(n + t, t), power(3, m + k - t)))));\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = a; i < n; ++i)\n#define ford(i, a, n) for (int i = n - 1; i >= a; --i)\n#define fore(i, a, n) for (int i = a; i <= n; ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n\tfor (auto i : a) cerr << i << ' ';\\\n\tcerr << '\\n'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\nconst ld eps = 1e-9;\nconst int INF = 2000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nconst int N = 1010;\n\nll fact[3 * N];\n\nll Pow(ll a, ll b) {\n    ll x = 1, y = a;\n    while (b) {\n        if (b % 2) x = x * y % MOD;\n        y = y * y % MOD;\n        b /= 2;\n    }\n    return x;\n}\n\nll Inv(ll x) {\n    return Pow(x, MOD - 2);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    int n, m, k;\n    cin >> n >> m >> k;\n    fact[0] = 1;\n    forn(i, 1, 3 * N) fact[i] = fact[i - 1] * i % MOD;\n    ll ans = 0;\n    fore(x, 0, m) fore(y, 0, k) {\n        ll add = fact[x + y + n - 1] * Inv(fact[x]) % MOD * Inv(fact[y]) % MOD * Inv(fact[n - 1]) % MOD;\n        add *= Pow(3, m + k - x - y);\n        ans += add;\n        ans %= MOD;\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int Max=2e5+1;\nconst long long Mod=1e9+7;\nint cnt=0,M;\nlong long P[Max*3+10]={},inv[Max*3+10]={},Pow[Max*3+10]={};\ninline long long C(int n,int m){if(n<m)return 0;return P[n]*inv[n-m]%Mod*inv[m]%Mod;}\nint main(){\n\tP[0]=P[1]=1; for(int i=2;i<=Max*3;i++) P[i]=i*P[i-1],P[i]%=Mod;\n\tinv[0]=inv[1]=1; for(int i=2;i<=Max*3;i++) inv[i]=inv[Mod%i]*(Mod-Mod/i)%Mod;\n\tfor(int i=2;i<=Max*3;i++) inv[i]=inv[i]*inv[i-1]%Mod;\n\tPow[0]=1; for(int i=1;i<=Max*3;i++) Pow[i]=Pow[i-1]*3%Mod;\n\tint N,M,Q; scanf(\"%d%d%d\",&N,&M,&Q);\n\tlong long Ans=0,Sum1=0,Sum2=0;\n\tfor(int i=N;i<=N+M+Q;i++){\n\t\tif(i==N){\n\t\t\tfor(int j=0;j<i-N-Q;i++) Sum1+=C(i-N,j);\n\t\t    for(int j=max(i-N-Q,0);j<=min(M,i-N);j++) Sum2+=C(i-N,j);\n\t\t}else{\n            if(i-N-Q-2>=0) Sum1=(Sum1*2%Mod-C(i-1-N,i-N-Q-2)+Mod)%Mod;\n            Sum2=(Sum2*2%Mod-C(i-1-N,min(M,i-1-N))+Mod)%Mod;\n\t\t\tif(max(i-N-Q,0)>max(i-N-Q-1,0)) Sum1+=C(i-N,i-N-Q-1),Sum1%=Mod;\n\t\t\tif(min(M,i-N-1)<min(M,i-N)) Sum2+=C(i-N,min(M,i-N)),Sum2%=Mod;\n\t\t}\n\t\tAns+=C(i-1,N-1)*Pow[N+M+Q-i]%Mod*(Sum2-Sum1+Mod)%Mod,Ans%=Mod;\n//\t\tfor(int j=max(i-N-Q,0);j<=min(M,i-N);j++)\n//\t\t Ans+=C(i-1,N-1)*C(i-N,j)%Mod*Pow[N+M+Q-i]%Mod,Ans%=Mod;  \n\t}\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int MN = 1000010;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[MN], invf[MN];\nint comb(int n, int k) {\n    if(k < 0 || n < k) return 0;\n    else return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\n\nint N, M, K;\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < MN; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> M >> K;\n    N--;\n\n    int ans = 0;\n    int sum = 1;\n    int l = 0;\n    int r = 0;\n    ans += 1LL * exp(3, M + K) % mod * sum % mod;\n    ans %= mod;\n\n    for(int i = M + K - 1; i >= 0; i--) {\n        sum *= 2;\n        sum %= mod;\n        sum += comb(M + K - i - 1, l - 1);\n        sum %= mod;\n        sum += mod - comb(M + K - i - 1, r);\n        sum %= mod;\n\n        int nl = M - min(i, M);\n        int nr = M - max(0, i - K);\n\n        if(l < nl) {\n            sum += mod - comb(M + K - i, l);\n            sum %= mod;\n        }\n        if(r < nr) {\n            sum += comb(M + K - i, nr);\n            sum %= mod;\n        }\n\n        ans += 1LL * comb(N + M + K - i, N) * exp(3, i) % mod * sum % mod;\n        ans %= mod;\n\n        l = nl;\n        r = nr;\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\nusing namespace std;\n\nconst int N=9e5+10;\n\nll fac[N],inv[N],pw[N];\n\nll ksm(ll a,ll b){\n\tll res=1;\n\twhile(b){\n\t\tif(b&1) res=res*a%mod;\n\t\ta=a*a%mod,b>>=1;\n\t}\n\treturn res;\n}\n\nll C(ll n,ll m){\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main(){\n\tll n,m,k,j=1,ans=0;\n\tscanf(\"%lld%lld%lld\",&n,&m,&k);\n\tif(k>m) swap(k,m);\n\tfac[0]=inv[0]=pw[0]=1;\n\tfor(int i=1;i<=n+k+m;i++) fac[i]=fac[i-1]*i%mod,pw[i]=pw[i-1]*3%mod;\n\tinv[n+k+m]=ksm(fac[n+k+m],mod-2);\n\tfor(int i=n+k+m-1;i;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tfor(int i=0;i<=m+k;i++){\n\t\tans=(ans+C(n+i-1,n-1)*pw[m+k-i]%mod*j%mod)%mod;\n\t\tif(i<k) j=2*j%mod;\n\t\telse if(i>=m) j=(2*j-C(i,k)-C(i,i-m)+2*mod)%mod;\n\t\telse j=(2*j-C(i,k)+mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//T+N\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate<class T, class T2> inline bool chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline bool chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst ll mod = 1e9 + 7;\ntemplate<class T> inline void fix(T &x) {if(x >= mod | x <= -mod) {x %= mod;} if(x < 0) {x += mod;}}\n#define out(x) cout << __LINE__ << \": \" << (#x) << \" = \" << (x) << endl\n\nconst ll MAX_N = 3e5 + 10;\nll perm[MAX_N], inv[MAX_N];\n\nll fpow(ll x, ll p) {\n    if(p == 0) {return 1;}\n    ll ans = fpow(x, p / 2);\n    ans = (ans * ans ) % mod;\n    if(p & 1) {\n        return (ans * x) % mod;\n    } else {\n        return ans;\n    }\n}\n\nll comb(ll k, ll n) {\n    if(k < 0 || n < 0) {return 0;}\n    if(n - k < 0) {return 0;}\n    return (((perm[n] * inv[n - k]) % mod) * inv[k]) % mod;\n}\n\nsigned main() {\n    //ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    perm[0] = inv[0] = 1;\n    for(ll i = 1; i < MAX_N; i ++) {\n        perm[i] = (perm[i - 1] * i) % mod;\n        inv[i] = (inv[i - 1] * fpow(i, mod - 2)) % mod;\n    }\n    ll n, m, k;\n    cin >> n >> m >> k;\n    ll rangel = 0, ranger = 0;\n    ll sum = 1;\n    ll ans = 0;\n    m ++;\n    k ++;\n    for(ll ij = 0; ij <= m + k - 2; ij ++) {\n        ll nwl = max(0ll, ij - m + 1);\n        ll nwr = min(m - 1, ij);\n        while(nwl < rangel) {\n            sum = (sum + comb(rangel - 1, ij)) % mod;\n            rangel --;\n        }\n        while(nwl > rangel) {\n            sum = (sum - comb(rangel, ij)) % mod;\n            rangel ++;\n        }\n        while(nwr > ranger) {\n            sum = (sum + comb(ranger + 1, ij)) % mod;\n            ranger ++;\n        }\n        while(nwr < ranger) {\n            sum = (sum - comb(ranger, ij)) % mod;\n            ranger --;\n        }\n        ll sum2 = 0;\n        for(ll i = nwl; i <= nwr; i ++) {\n            sum2 += comb(i, ij) ;\n        }\n        fix(sum);\n        ans += ((comb(n - 1, n - 1 + ij) * sum) % mod) * fpow(3, m + k - 2 - ij);\n        fix(ans);\n        sum = (sum * 2) % mod;\n        sum += comb(ranger + 1, ij) + comb(rangel - 1, ij);\n        sum %= mod;\n        ranger ++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define mod 1000000007\n#define N 300010\nll fac[N],inv[N],ivf[N];\nvoid initmo(){\n    fac[0]=ivf[0]=inv[1]=1;\n    for(ll i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n}\nll C(ll n,ll k){\n    return fac[n]*ivf[n-k]%mod*ivf[k]%mod;\n}\nll po(ll x,ll y){\n    ll res=1;\n    for(;y;y>>=1){\n\tif(y&1)res=res*x%mod;\n\tx=x*x%mod;\n    }\n    return res;\n}\nint main(){\n    initmo();\n  ll a,b,c;cin>>a>>b>>c; if(a>N||b>N||c>N)return 0;\n  a--; if(b>c)swap(b,c);\n  ll ans=0,sum=1;\n  for(ll k=a;k<=a+b+c;k++){\n      ll cur=po(3,a+b+c-k)*C(k,a)%mod;\n      cur=cur*sum%mod;\n      ans=(ans+cur)%mod;\n      ll s=k-a;\n      sum=sum*2%mod;\n      if(b<=s)sum-=C(s,b);\n      if(c<=s)sum-=C(s,s-c);\n  }\n  if(ans<0)ans+=mod;\n  cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MOD = (1e9 + 7);\n\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nstruct Combi\n{\n\tvector<int> fact;\n\tvector<int> ifact;\n\tvector<int> inv;\n\tvector<int> pow2;\n\tint choose(int a, int b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tint inverse(int a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t}\n\t\tifact[_n] = inverse(fact[_n]);\n\t\tfor(int i=_n-1;i>=1;i--)\n\t\t{\n\t\t    ifact[i] = mult(ifact[i + 1], i + 1);\n\t\t}\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t    inv[i] = mult(fact[i-1],ifact[i]);\n\t\t}\n\t}\n};\n\n\nCombi combi;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m,k; cin>>n>>m>>k;\n\tcombi.init(999999);\n\tint ans=0;\n\tint coeff=modpow(3,m+k);\n\tint res=1;\n\tint oldl=0; int oldr=0;\n\tfor(int i=n;i<=n+m+k;i++)\n\t{\n\t\tint res2=mult(res,mult(coeff,combi.choose(i-1,n-1)));\n\t\tans=add(ans,res2);\n\t\tcoeff=mult(coeff,combi.inv[3]);\n\t\tif(i>=n+m+k) break;\n\t\tint newl = max(i+1-n-k,0); int newr = min(m,i+1-n);\n\t\tres=add(res,res);\n\t\tres=add(res,MOD-combi.choose(i-n,oldl));\n\t\tres=add(res,MOD-combi.choose(i-n,oldr));\n\t\twhile(oldl>=newl)\n\t\t{\n\t\t\tres=add(res,combi.choose(i+1-n,oldl));\n\t\t\toldl--;\n\t\t}\n\t\toldl++;\n\t\twhile(oldl<newl)\n\t\t{\n\t\t\tres=add(res,MOD-combi.choose(i+1-n,oldl));\n\t\t\toldl++;\n\t\t}\n\t\toldr++;\n\t\twhile(oldr<=newr)\n\t\t{\n\t\t\tres=add(res,combi.choose(i+1-n,oldr));\n\t\t\toldr++;\n\t\t}\n\t\toldr--;\n\t\twhile(oldr>newr)\n\t\t{\n\t\t\tres=add(res,MOD-combi.choose(i+1-n,oldr));\n\t\t\toldr--;\n\t\t}\n\t\toldl=newl; oldr=newr;\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nconst int MAX=1000000;\nint fact[MAX],inv[MAX];\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nint pow3[MAX];\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<MAX;i++)fact[i]=fact[i-1]*i%mod;\n    inv[MAX-1]=mpow(fact[MAX-1],mod-2);\n    for(int i=MAX-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    pow3[0]=1;\n    for(int i=1;i<MAX;i++)pow3[i]=pow3[i-1]*3%mod;\n\n    int N,M,K;\n    cin>>N>>M>>K;\n    int ans=0;\n\n    int curL=0,curR=1;\n\n    for(int i=0;i<=M+K;i++){\n        ans=(ans+(curR-curL+mod)*C(N-1+i,i)%mod*pow3[M+K-i])%mod;\n        curL=curL*2%mod;\n        curR=curR*2%mod;\n        if(i>=M)curR=(curR-C(i,M)+mod)%mod;\n        if(i>=K)curL=(curL+C(i,i-K))%mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, l, r) for(int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for(int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\nusing namespace std;\n\nbool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}\nbool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n    int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int Mod = 1e9 + 7, N = 1e3 + 1e2;\n\ntypedef long long ll;\nstruct Card { \n\tint a, b, c; \n\tbool operator < (const Card &rhs) const {\n\t\treturn (a ^ rhs.a) ? a < rhs.a : (b ^ rhs.b) ? b < rhs.b : c < rhs.c;\n\t}\n};\nstruct Sta { Card pk; int val; };\n\nmap<Card, int> M;\nvector<Sta> dp[2];\n\nint pow3[N];\nint n, m, k, cur;\n\nint ans = 0;\n\nvoid Update(Card Go, int uv, int dep) {\n\tif (Go.a < 0) {\n\t\tint Last = n + m + k - dep;\n\t\t(ans += 1ll * uv * pow3[Last] % Mod) %= Mod;\n\t\treturn ;\n\t}\n\tif (Go.b < 0 || Go.c < 0) return ;\n\n\tint pos = M[Go];\n\tif (pos) { (dp[cur ^ 1][pos - 1].val += uv) %= Mod; return ; }\n\n\n\tdp[cur ^ 1].push_back((Sta) {Go, uv});\n\tM[Go] = (int)dp[cur ^ 1].size();\n}\n\nint main () {\n\tFile();\n\tcin >> n >> m >> k;\n\tpow3[0] = 1; For (i, 1, n + m + k) pow3[i] = pow3[i - 1] * 3ll % Mod;\n\n\tdp[cur = 0].push_back((Sta) {(Card) {n - 1, m, k}, 1});\n\n\tFor (i, 1, n + m + k) {\n\t\tfor (Sta now : dp[cur]) {\n\t\t\tCard here = now.pk;\n\n\t\t\t-- here.a, Update(here, now.val, i), ++ here.a;\n\n\t\t\t-- here.b, Update(here, now.val, i), ++ here.b;\n\n\t\t\t-- here.c, Update(here, now.val, i), ++ here.c;\n\t\t}\n\t\tdp[cur].clear(); cur ^= 1; M.clear();\n\t}\n\n\tprintf (\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Mod = 1e9 + 7;\nconst int N = 9e5 + 10;\n\nint n, m, k;\nlong long fac[N], vfac[N];\n\nlong long mpow( long long a, int b ) {\n\tlong long rt;\n\tfor( rt = 1; b; b >>= 1, a = (a * a) % Mod )\n\t\tif( b & 1 ) rt = (rt * a) % Mod;\n\treturn rt;\n}\nvoid init( int n ) {\n\tfac[0] = 1;\n\tfor( int i = 1; i <= n; i++ )\n\t\tfac[i] = (fac[i-1] * i) % Mod;\n\tvfac[n]  = mpow( fac[n], Mod - 2 );\n\tfor( int i = n - 1; i >= 0; i-- )\n\t\tvfac[i] = vfac[i+1] * (i + 1) % Mod;\n}\nlong long comb( int n, int m ) {\n\treturn fac[n] * vfac[n-m] % Mod * vfac[m] % Mod;\n}\nint main() {\n\tscanf( \"%d%d%d\", &n, &m, &k );\n\tif( m < k ) swap( m, k );\n\tinit( m + k + n );\n\tlong long sum = 0, ans = 0;\n\tfor( int s = 0; s <= m + k; s++ ) {\n\t\tif( s == 0 ) \n\t\t\tsum = 1;\n\t\t else if( s <= k ) \n\t\t\tsum = (sum<<1) % Mod;\n\t else if( s <= m ) \n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1)) % Mod;\n\t\t else \n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1) + Mod - comb(s-1,m)) % Mod;\n\t\t\n\t\tlong long sub = sum * comb(n-1+s,n-1) % Mod * mpow(3,m+k-s) % Mod;\n\t\tans = (ans + sub) % Mod;\n\t}\n\tprintf( \"%lld\\n\", ans );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n\n#include <cassert>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\ninline void ModMul(int& x, int y) {\n    x = (1LL * x * y) % MOD;\n}\n\ninline int GetModMul(int x, int y) {\n    ModMul(x, y);\n    return x;\n}\n\ninline void ModSum(int& x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n    if (x < 0) {\n        x += MOD;\n    }\n}\n\ninline int GetModSum(int x, int y) {\n    ModSum(x, y);\n    return x;\n}\n\ninline int GetBinaryPow(int x, int pw) {\n    int r = 1;\n    while (pw > 0) {\n        if (pw & 1) {\n            ModMul(r, x);\n        }\n        ModMul(x, x);\n        pw >>= 1;\n    }\n    return r;\n}\n\ninline int GetInv(int x) {\n    return GetBinaryPow(x, MOD - 2);\n}\n\nconst int MAX_FACT = 1e6;\n\nvector<int> fact(MAX_FACT);\nvector<int> invFact(MAX_FACT);\n\nvoid BuildFact() {\n    fact[0] = 1;\n    for (int i = 1; i < MAX_FACT; ++i) {\n        fact[i] = fact[i - 1];\n        ModMul(fact[i], i);\n    }\n    for (int i = 0; i < MAX_FACT; ++i) {\n        invFact[i] = GetInv(fact[i]);\n    }\n}\n\ninline int GetC(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n    int r = fact[n];\n    ModMul(r, invFact[k]);\n    ModMul(r, invFact[n - k]);\n    return r;\n}\n\nint main() {\n    BuildFact();\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> pw3(m + k + 1);\n    pw3[0] = 1;\n    for (int i = 1; i <= m + k; ++i) {\n        pw3[i] = pw3[i - 1];\n        ModMul(pw3[i], 3);\n    }\n\n    int l = 0;\n    int r = 0;\n    int sum = 1;\n\n    int result = 0;\n    for (int s = 0; s <= m + k; ++s) {\n        const int cl = max(0, s - k);\n        const int cr = min(m, s);\n\n        if (l == r) {\n            sum = 0;\n            for (int i = cl; i <= cr; ++i) {\n                ModSum(sum, GetC(s, i));\n            }\n            l = cl;\n            r = cr;\n        } else {\n            ModMul(sum, 2);\n            ModSum(sum, -GetC(s - 1, l));\n            ModSum(sum, -GetC(s - 1, r));\n            ++l;\n\n            while (r < cr) {\n                ModSum(sum, GetC(s, r + 1));\n                ++r;\n            }\n            while (l > cl) {\n                ModSum(sum, GetC(s, l - 1));\n                --l;\n            }\n\n            while (r > cr) {\n                ModSum(sum, -GetC(s, r));\n                --r;\n            }\n            while (l < cl) {\n                ModSum(sum, -GetC(s, l));\n                ++l;\n            }\n        }\n\n        int curResult = GetC(s + (n - 1), n - 1);\n        ModMul(curResult, pw3[m + k - s]);\n        ModMul(curResult, sum);\n\n        ModSum(result, curResult);\n    }\n\n    cout << result << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000010\n#define ll long long\n\nconst ll p = 1e9 + 7;\nll n, m, k, ans;\nll fac[N], inv[N], san[N];\n\nll fpow(ll a, ll b)\n{\n    ll ans = 1;\n    while(b)\n    {\n        if(b & 1) ans = ans * a % p;\n        a = a * a % p; b >>= 1;\n    }\n    return ans;\n}\n\nll C(ll n, ll m)\n{\n    if(n < m || n < 0 || m < 0) return 0;\n    return fac[n] * inv[m] % p * inv[n - m] % p;\n}\n\nint main()\n{\n    scanf(\"%lld%lld%lld\", &n, &m, &k);\n    ll t = n + m + k;\n    fac[0] = inv[0] = san[0] = 1;\n    for(int i = 1; i <= t; i ++)\n    {\n        fac[i] = fac[i - 1] * i % p;\n        san[i] = san[i - 1] * 3 % p;\n    }\n    //for(int i = 1; i <= 5; i ++) printf(\"%lld %lld %lld\", fac[i], inv[i], san[i]), system(\"pause\");\n    inv[t] = fpow(fac[t], p - 2);\n    for(int i = t - 1; i; i --) inv[i] = inv[i + 1] * (i + 1) % p;\n    ll t1 = 0, t2 = 1;\n    for(int i = 0; i <= m + k; i ++)\n    {\n        t = C(n + i - 1, n - 1) * san[m + k - i] % p;\n        //printf(\"%lld\", t); system(\"pause\");\n        t = t * (t2 - t1 + p) % p;\n        t2 = (t2 * 2 % p - C(i, m) + p) % p;\n        t1 = ((t1 * 2 % p - C(i, i - k - 1) + p) % p + C(i + 1, i - k)) % p;\n        ans = (ans + t) % p; \n        //printf(\"%lld %lld\", ans, t); system(\"pause\");\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n#define MAXN 900000\n#define MOD 1000000007\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\n#define BUF_SIZE 1000000\n#define _END fwrite(_Ob,1,_O-_Ob,stdout), _O = _Ob\n#define Outc(a) (*_O++ = a)\nchar _Ob[BUF_SIZE+5], *_O = _Ob, _Os[25], *_Ot;\ntemplate <typename T> inline void Out(T x)\n{\n\tif(!x){Outc('0'); return;} if(x < 0) Outc('-'), x = -x;\n\tfor(_Ot = _Os; x; *_Ot++ = x%10+'0', x /= 10);\n\tfor(; _Ot != _Os; Outc(*--_Ot)); if(_O-_Ob >= BUF_SIZE-50) _END;\n}\nint N, M, K, T, L, R, S, B[MAXN+5], fac[MAXN+5], efac[MAXN+5], ans;\ninline int fastpow(int s, int n){int a = 1; for(; n; n&1 ? a = 1ll*a*s%MOD : 0, s = 1ll*s*s%MOD, n >>= 1); return a;}\ninline int C(int n, int k){return n<0||k<0||n<k?0:1ll*fac[n]*efac[k]%MOD*efac[n-k]%MOD;}\nint main()\n{\n\tN = read(), M = read(), K = read(), T = N+M+K, S = 1;\n\tB[0] = 1; for(rint i = 1; i <= T; B[i] = 3u*B[i-1]%MOD, i++);\n\tfac[0] = 1; for(rint i = 1; i <= T; fac[i] = 1ll*i*fac[i-1]%MOD, i++);\n\tefac[T] = fastpow(fac[T],MOD-2); for(rint i = T; i; efac[i-1] = 1ll*i*efac[i]%MOD, i--);\n\tfor(rint p = N; p <= T; )\n\t{\n\t\tans = (ans+1ll*B[T-p]*C(p-1,N-1)%MOD*S)%MOD;\n\t\tS = (2ll*S+C(p-N,L-1)+C(p-N,R+1))%MOD, ++p, ++R;\n\t\tp-N-L > K ? S = (S+MOD-C(p-N,L)), S<MOD?:S-=MOD, ++L : 0;\n\t\tR > M ? S = (S+MOD-C(p-N,R)), S<MOD?:S-=MOD, --R : 0; if(L>R) break;\n\t}\tprintf(\"%d\\n\",ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N = 1000005, mod = 1000000007;\n\nvoid reduce(int &x) { x += x >> 31 & mod; }\nint pow(int x, int y, int ans = 1) {\n\tfor (; y; y >>= 1, x = (LL) x * x % mod)\n\t\tif (y & 1) ans = (LL) ans * x % mod;\n\treturn ans;\n}\nint factor[N], ifactor[N];\nvoid init(int n) {\n\tfactor[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfactor[i] = (LL) factor[i - 1] * i % mod;\n\tifactor[n] = pow(factor[n], mod - 2);\n\tfor (int i = n; i; --i)\n\t\tifactor[i - 1] = (LL) ifactor[i] * i % mod;\n}\nint c(int x, int y) { return y < 0 || x < y ? 0 : (LL) factor[x] * ifactor[y] % mod * ifactor[x - y] % mod; }\n\nint n, m, k, pow3[N], g[N], ans;\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> m >> k, --n, init(n + m + k);\n\tif (m > k) std::swap(m, k);\n\tpow3[0] = g[0] = 1;\n\tfor (int i = 1; i <= m + k; ++i) {\n\t\tpow3[i] = pow3[i - 1] * 3u % mod;\n\t\tg[i] = (g[i - 1] * 2u + mod * 2 - c(i - 1, i - k - 1) - c(i - 1, m)) % mod;\n\t}\n\tfor (int t = 0; t <= m + k; ++t)\n\t\tans = (ans + (LL) pow3[m + k - t] * c(n + t, n) % mod * g[t]) % mod;\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace IntModulo\n{\n\tconst int mod = 1e9 + 7;\n\n\tinline int add(int x, int y, int m = mod)\n\t{\n\t\tif (x + y < m)\n\t\t\treturn x + y;\n\t\treturn x + y - m;\n\t}\n\n\tinline int sub(int x, int y, int m = mod)\n\t{\n\t\tif (x >= y)\n\t\t\treturn x - y;\n\t\treturn x - y + m;\n\t}\n\n\tinline int mult(int x, int y, int m = mod)\n\t{\n\t\treturn x * (LL) y % m;\n\t}\n\n\tinline int power(int x, int y, int m = mod)\n\t{\n\t\tint r = 1;\n\t\twhile(y)\n\t\t{\n\t\t\tif (y & 1)\n\t\t\t\tr = mult(r, x, m);\n\t\t\tx = mult(x, x, m);\n\t\t\ty >>= 1;\n\t\t}\n\t\t\n\t\treturn r;\n\t}\n\t\n\tinline int inverse(int x, int m = mod)\n\t{\n\t\treturn power(x, m - 2, m);\n\t}\n\t\n\tinline void ADD(int& x, int y, int m = mod)\n\t{\n\t\tx += y;\n\t\tif (x >= m) x -= m;\n\t}\n\t\n\tinline void SUB(int& x, int y, int m = mod)\n\t{\n\t\tx -= y;\n\t\tif (x < 0) x += m;\n\t}\n\t\n\tinline void MULT(int& x, int y, int m = mod)\n\t{\n\t\tx = (x * (LL) y) % m;\n\t}\n};\n\nnamespace Combinatorics\n{\n\tusing namespace IntModulo;\n\t\n\tconst int N = 1 << 20;\n\tint fact[N];\n\tint inv[N];\n\tint invFact[N];\n\tbool inited = false;\n\t\n\tinline int C(int n, int k) // binomial C(n, k)\n\t{\n\t\treturn n < k ? 0 : mult(fact[n], mult(invFact[k], invFact[n - k]));\n\t}\n\t\n\tinline int H(int n, int k) // number of solution x1 + .. + xn = k\n\t{\n\t\treturn C(n + k - 1, k);\n\t}\n\t\n\tvoid init()\n\t{\n\t\tdebug(Combinatorics::N);\n\t\tinited = true;\n\t\tinv[1] = 1;\n\t\tFOR(i, 2, N)\n\t\t\tinv[i] = mult(mod - mod / i, inv[mod % i]);\n\t\t\n\t\tinvFact[0] = fact[0] = 1;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tfact[i] = mult(i, fact[i - 1]);\n\t\t\tinvFact[i] = mult(invFact[i - 1], inv[i]);\n\t\t}\n\t}\t\n};\n\nusing namespace Combinatorics;\n\nnamespace FFT\n{\n\tnamespace FastNTT998244353\n\t{\n\t\tconst int MOD = 998244353;\n\t\t \n\t\tstruct mod_int {\n\t\t\tint val;\n\t\t \n\t\t\tmod_int(long long v = 0) {\n\t\t\t\tif (v < 0) v = v % MOD + MOD;\n\t\t\t\tif (v >= MOD) v %= MOD;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t \n\t\t\tstatic int mod_inv(int a, int m = MOD) {\n\t\t\t\t// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n\t\t\t\tint g = m, r = a, x = 0, y = 1;\n\t\t \n\t\t\t\twhile (r != 0) {\n\t\t\t\t\tint q = g / r;\n\t\t\t\t\tg %= r; swap(g, r);\n\t\t\t\t\tx -= q * y; swap(x, y);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn x < 0 ? x + m : x;\n\t\t\t}\n\t\t \n\t\t\texplicit operator int() const {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator+=(const mod_int &other) {\n\t\t\t\tval += other.val;\n\t\t\t\tif (val >= MOD) val -= MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator-=(const mod_int &other) {\n\t\t\t\tval -= other.val;\n\t\t\t\tif (val < 0) val += MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tstatic unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n\t\t#if !defined(_WIN32) || defined(_WIN64)\n\t\t\t\treturn x % m;\n\t\t#endif\n\t\t\t\t// Optimized mod for Codeforces 32-bit machines.\n\t\t\t\t// x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n\t\t\t\tunsigned x_high = x >> 32, x_low = (unsigned) x;\n\t\t\t\tunsigned quot, rem;\n\t\t\t\tasm(\"divl %4\\n\"\n\t\t\t\t\t: \"=a\" (quot), \"=d\" (rem)\n\t\t\t\t\t: \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n\t\t\t\treturn rem;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator*=(const mod_int &other) {\n\t\t\t\tval = fast_mod((uint64_t) val * other.val);\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator/=(const mod_int &other) {\n\t\t\t\treturn *this *= other.inv();\n\t\t\t}\n\t\t \n\t\t\tfriend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n\t\t\tfriend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n\t\t\tfriend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n\t\t\tfriend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\t\t \n\t\t\tmod_int& operator++() {\n\t\t\t\tval = val == MOD - 1 ? 0 : val + 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator--() {\n\t\t\t\tval = val == 0 ? MOD - 1 : val - 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n\t\t\tmod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\t\t \n\t\t\tmod_int operator-() const {\n\t\t\t\treturn val == 0 ? 0 : MOD - val;\n\t\t\t}\n\t\t \n\t\t\tbool operator==(const mod_int &other) const { return val == other.val; }\n\t\t\tbool operator!=(const mod_int &other) const { return val != other.val; }\n\t\t \n\t\t\tmod_int inv() const {\n\t\t\t\treturn mod_inv(val);\n\t\t\t}\n\t\t \n\t\t\tmod_int pow(long long p) const {\n\t\t\t\tassert(p >= 0);\n\t\t\t\tmod_int a = *this, result = 1;\n\t\t \n\t\t\t\twhile (p > 0) {\n\t\t\t\t\tif (p & 1)\n\t\t\t\t\t\tresult *= a;\n\t\t \n\t\t\t\t\ta *= a;\n\t\t\t\t\tp >>= 1;\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tfriend ostream& operator<<(ostream &stream, const mod_int &m) {\n\t\t\t\treturn stream << m.val;\n\t\t\t}\n\t\t};\n\t\t \n\t\tnamespace NTT {\n\t\t\tvector<mod_int> roots = {0, 1};\n\t\t\tvector<int> bit_reverse;\n\t\t\tint max_size = -1;\n\t\t\tmod_int root;\n\t\t \n\t\t\tbool is_power_of_two(int n) {\n\t\t\t\treturn (n & (n - 1)) == 0;\n\t\t\t}\n\t\t \n\t\t\tint round_up_power_two(int n) {\n\t\t\t\twhile (n & (n - 1))\n\t\t\t\t\tn = (n | (n - 1)) + 1;\n\t\t \n\t\t\t\treturn max(n, 1);\n\t\t\t}\n\t\t \n\t\t\t// Given n (a power of two), finds k such that n == 1 << k.\n\t\t\tint get_length(int n) {\n\t\t\t\tassert(is_power_of_two(n));\n\t\t\t\treturn __builtin_ctz(n);\n\t\t\t}\n\t\t \n\t\t\t// Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n\t\t\t// This makes even-odd div-conquer much easier.\n\t\t\tvoid bit_reorder(int n, vector<mod_int> &values) {\n\t\t\t\tif ((int) bit_reverse.size() != n) {\n\t\t\t\t\tbit_reverse.assign(n, 0);\n\t\t\t\t\tint length = get_length(n);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tbit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n\t\t\t\t}\n\t\t \n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif (i < bit_reverse[i])\n\t\t\t\t\t\tswap(values[i], values[bit_reverse[i]]);\n\t\t\t}\n\t\t \n\t\t\tvoid find_root() {\n\t\t\t\tmax_size = 1 << __builtin_ctz(MOD - 1);\n\t\t\t\troot = 2;\n\t\t \n\t\t\t\t// Find a max_size-th primitive root of MOD.\n\t\t\t\twhile (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n\t\t\t\t\troot++;\n\t\t\t}\n\t\t \n\t\t\tvoid prepare_roots(int n) {\n\t\t\t\tif (max_size < 0)\n\t\t\t\t\tfind_root();\n\t\t \n\t\t\t\tassert(n <= max_size);\n\t\t \n\t\t\t\tif ((int) roots.size() >= n)\n\t\t\t\t\treturn;\n\t\t \n\t\t\t\tint length = get_length(roots.size());\n\t\t\t\troots.resize(n);\n\t\t \n\t\t\t\t// The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n\t\t\t\t// the first half of the n-th primitive roots of MOD.\n\t\t\t\twhile (1 << length < n) {\n\t\t\t\t\t// z is a 2^(length + 1)-th primitive root of MOD.\n\t\t\t\t\tmod_int z = root.pow(max_size >> (length + 1));\n\t\t \n\t\t\t\t\tfor (int i = 1 << (length - 1); i < 1 << length; i++) {\n\t\t\t\t\t\troots[2 * i] = roots[i];\n\t\t\t\t\t\troots[2 * i + 1] = roots[i] * z;\n\t\t\t\t\t}\n\t\t \n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tvoid fft_iterative(int N, vector<mod_int> &values) {\n\t\t\t\tassert(is_power_of_two(N));\n\t\t\t\tprepare_roots(N);\n\t\t\t\tbit_reorder(N, values);\n\t\t \n\t\t\t\tfor (int n = 1; n < N; n *= 2)\n\t\t\t\t\tfor (int start = 0; start < N; start += 2 * n)\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\tmod_int even = values[start + i];\n\t\t\t\t\t\t\tmod_int odd = values[start + n + i] * roots[n + i];\n\t\t\t\t\t\t\tvalues[start + n + i] = even - odd;\n\t\t\t\t\t\t\tvalues[start + i] = even + odd;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tconst int FFT_CUTOFF = 150;\n\t\t \n\t\t\tvector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n\t\t\t\tint n = left.size();\n\t\t\t\tint m = right.size();\n\t\t \n\t\t\t\t// Brute force when either n or m is small enough.\n\t\t\t\tif (min(n, m) < FFT_CUTOFF) {\n\t\t\t\t\tconst uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n\t\t\t\t\tvector<uint64_t> result(n + m - 1, 0);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tresult[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\t\t \n\t\t\t\t\t\t\tif (result[i + j] > ULL_BOUND)\n\t\t\t\t\t\t\t\tresult[i + j] %= MOD;\n\t\t\t\t\t\t}\n\t\t \n\t\t\t\t\tfor (uint64_t &x : result)\n\t\t\t\t\t\tif (x >= MOD)\n\t\t\t\t\t\t\tx %= MOD;\n\t\t \n\t\t\t\t\treturn vector<mod_int>(result.begin(), result.end());\n\t\t\t\t}\n\t\t \n\t\t\t\tint N = round_up_power_two(n + m - 1);\n\t\t\t\tleft.resize(N);\n\t\t\t\tright.resize(N);\n\t\t \n\t\t\t\tbool equal = left == right;\n\t\t\t\tfft_iterative(N, left);\n\t\t \n\t\t\t\tif (equal)\n\t\t\t\t\tright = left;\n\t\t\t\telse\n\t\t\t\t\tfft_iterative(N, right);\n\t\t \n\t\t\t\tmod_int inv_N = mod_int(N).inv();\n\t\t \n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t\tleft[i] *= right[i] * inv_N;\n\t\t \n\t\t\t\treverse(left.begin() + 1, left.end());\n\t\t\t\tfft_iterative(N, left);\n\t\t\t\tleft.resize(n + m - 1);\n\t\t\t\treturn left;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n\t\t\t\tassert(exponent >= 0);\n\t\t\t\tvector<mod_int> result = {1};\n\t\t \n\t\t\t\tif (exponent == 0)\n\t\t\t\t\treturn result;\n\t\t \n\t\t\t\tfor (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n\t\t\t\t\tresult = mod_multiply(result, result);\n\t\t \n\t\t\t\t\tif (exponent >> k & 1)\n\t\t\t\t\t\tresult = mod_multiply(result, v);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_multiply_all(const vector<vector<mod_int>> &polynomials) {\n\t\t\t\tif (polynomials.empty())\n\t\t\t\t\treturn {1};\n\t\t \n\t\t\t\tstruct compare_size {\n\t\t\t\t\tbool operator()(const vector<mod_int> &x, const vector<mod_int> &y) {\n\t\t\t\t\t\treturn x.size() > y.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t \n\t\t\t\tpriority_queue<vector<mod_int>, vector<vector<mod_int>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\t\t \n\t\t\t\twhile (pq.size() > 1) {\n\t\t\t\t\tvector<mod_int> a = pq.top(); pq.pop();\n\t\t\t\t\tvector<mod_int> b = pq.top(); pq.pop();\n\t\t\t\t\tpq.push(mod_multiply(a, b));\n\t\t\t\t}\n\t\t \n\t\t\t\treturn pq.top();\n\t\t\t}\n\t\t};\n\n\t};\n\t\n\tnamespace FastNTT818937857\n\t{\n\t\tconst int MOD = 818937857;\n\t\t \n\t\tstruct mod_int {\n\t\t\tint val;\n\t\t \n\t\t\tmod_int(long long v = 0) {\n\t\t\t\tif (v < 0) v = v % MOD + MOD;\n\t\t\t\tif (v >= MOD) v %= MOD;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t \n\t\t\tstatic int mod_inv(int a, int m = MOD) {\n\t\t\t\t// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n\t\t\t\tint g = m, r = a, x = 0, y = 1;\n\t\t \n\t\t\t\twhile (r != 0) {\n\t\t\t\t\tint q = g / r;\n\t\t\t\t\tg %= r; swap(g, r);\n\t\t\t\t\tx -= q * y; swap(x, y);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn x < 0 ? x + m : x;\n\t\t\t}\n\t\t \n\t\t\texplicit operator int() const {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator+=(const mod_int &other) {\n\t\t\t\tval += other.val;\n\t\t\t\tif (val >= MOD) val -= MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator-=(const mod_int &other) {\n\t\t\t\tval -= other.val;\n\t\t\t\tif (val < 0) val += MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tstatic unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n\t\t#if !defined(_WIN32) || defined(_WIN64)\n\t\t\t\treturn x % m;\n\t\t#endif\n\t\t\t\t// Optimized mod for Codeforces 32-bit machines.\n\t\t\t\t// x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n\t\t\t\tunsigned x_high = x >> 32, x_low = (unsigned) x;\n\t\t\t\tunsigned quot, rem;\n\t\t\t\tasm(\"divl %4\\n\"\n\t\t\t\t\t: \"=a\" (quot), \"=d\" (rem)\n\t\t\t\t\t: \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n\t\t\t\treturn rem;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator*=(const mod_int &other) {\n\t\t\t\tval = fast_mod((uint64_t) val * other.val);\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator/=(const mod_int &other) {\n\t\t\t\treturn *this *= other.inv();\n\t\t\t}\n\t\t \n\t\t\tfriend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n\t\t\tfriend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n\t\t\tfriend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n\t\t\tfriend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\t\t \n\t\t\tmod_int& operator++() {\n\t\t\t\tval = val == MOD - 1 ? 0 : val + 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator--() {\n\t\t\t\tval = val == 0 ? MOD - 1 : val - 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n\t\t\tmod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\t\t \n\t\t\tmod_int operator-() const {\n\t\t\t\treturn val == 0 ? 0 : MOD - val;\n\t\t\t}\n\t\t \n\t\t\tbool operator==(const mod_int &other) const { return val == other.val; }\n\t\t\tbool operator!=(const mod_int &other) const { return val != other.val; }\n\t\t \n\t\t\tmod_int inv() const {\n\t\t\t\treturn mod_inv(val);\n\t\t\t}\n\t\t \n\t\t\tmod_int pow(long long p) const {\n\t\t\t\tassert(p >= 0);\n\t\t\t\tmod_int a = *this, result = 1;\n\t\t \n\t\t\t\twhile (p > 0) {\n\t\t\t\t\tif (p & 1)\n\t\t\t\t\t\tresult *= a;\n\t\t \n\t\t\t\t\ta *= a;\n\t\t\t\t\tp >>= 1;\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tfriend ostream& operator<<(ostream &stream, const mod_int &m) {\n\t\t\t\treturn stream << m.val;\n\t\t\t}\n\t\t};\n\t\t \n\t\tnamespace NTT {\n\t\t\tvector<mod_int> roots = {0, 1};\n\t\t\tvector<int> bit_reverse;\n\t\t\tint max_size = -1;\n\t\t\tmod_int root;\n\t\t \n\t\t\tbool is_power_of_two(int n) {\n\t\t\t\treturn (n & (n - 1)) == 0;\n\t\t\t}\n\t\t \n\t\t\tint round_up_power_two(int n) {\n\t\t\t\twhile (n & (n - 1))\n\t\t\t\t\tn = (n | (n - 1)) + 1;\n\t\t \n\t\t\t\treturn max(n, 1);\n\t\t\t}\n\t\t \n\t\t\t// Given n (a power of two), finds k such that n == 1 << k.\n\t\t\tint get_length(int n) {\n\t\t\t\tassert(is_power_of_two(n));\n\t\t\t\treturn __builtin_ctz(n);\n\t\t\t}\n\t\t \n\t\t\t// Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n\t\t\t// This makes even-odd div-conquer much easier.\n\t\t\tvoid bit_reorder(int n, vector<mod_int> &values) {\n\t\t\t\tif ((int) bit_reverse.size() != n) {\n\t\t\t\t\tbit_reverse.assign(n, 0);\n\t\t\t\t\tint length = get_length(n);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tbit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n\t\t\t\t}\n\t\t \n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif (i < bit_reverse[i])\n\t\t\t\t\t\tswap(values[i], values[bit_reverse[i]]);\n\t\t\t}\n\t\t \n\t\t\tvoid find_root() {\n\t\t\t\tmax_size = 1 << __builtin_ctz(MOD - 1);\n\t\t\t\troot = 2;\n\t\t \n\t\t\t\t// Find a max_size-th primitive root of MOD.\n\t\t\t\twhile (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n\t\t\t\t\troot++;\n\t\t\t}\n\t\t \n\t\t\tvoid prepare_roots(int n) {\n\t\t\t\tif (max_size < 0)\n\t\t\t\t\tfind_root();\n\t\t \n\t\t\t\tassert(n <= max_size);\n\t\t \n\t\t\t\tif ((int) roots.size() >= n)\n\t\t\t\t\treturn;\n\t\t \n\t\t\t\tint length = get_length(roots.size());\n\t\t\t\troots.resize(n);\n\t\t \n\t\t\t\t// The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n\t\t\t\t// the first half of the n-th primitive roots of MOD.\n\t\t\t\twhile (1 << length < n) {\n\t\t\t\t\t// z is a 2^(length + 1)-th primitive root of MOD.\n\t\t\t\t\tmod_int z = root.pow(max_size >> (length + 1));\n\t\t \n\t\t\t\t\tfor (int i = 1 << (length - 1); i < 1 << length; i++) {\n\t\t\t\t\t\troots[2 * i] = roots[i];\n\t\t\t\t\t\troots[2 * i + 1] = roots[i] * z;\n\t\t\t\t\t}\n\t\t \n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tvoid fft_iterative(int N, vector<mod_int> &values) {\n\t\t\t\tassert(is_power_of_two(N));\n\t\t\t\tprepare_roots(N);\n\t\t\t\tbit_reorder(N, values);\n\t\t \n\t\t\t\tfor (int n = 1; n < N; n *= 2)\n\t\t\t\t\tfor (int start = 0; start < N; start += 2 * n)\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\tmod_int even = values[start + i];\n\t\t\t\t\t\t\tmod_int odd = values[start + n + i] * roots[n + i];\n\t\t\t\t\t\t\tvalues[start + n + i] = even - odd;\n\t\t\t\t\t\t\tvalues[start + i] = even + odd;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tconst int FFT_CUTOFF = 150;\n\t\t \n\t\t\tvector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n\t\t\t\tint n = left.size();\n\t\t\t\tint m = right.size();\n\t\t \n\t\t\t\t// Brute force when either n or m is small enough.\n\t\t\t\tif (min(n, m) < FFT_CUTOFF) {\n\t\t\t\t\tconst uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n\t\t\t\t\tvector<uint64_t> result(n + m - 1, 0);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tresult[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\t\t \n\t\t\t\t\t\t\tif (result[i + j] > ULL_BOUND)\n\t\t\t\t\t\t\t\tresult[i + j] %= MOD;\n\t\t\t\t\t\t}\n\t\t \n\t\t\t\t\tfor (uint64_t &x : result)\n\t\t\t\t\t\tif (x >= MOD)\n\t\t\t\t\t\t\tx %= MOD;\n\t\t \n\t\t\t\t\treturn vector<mod_int>(result.begin(), result.end());\n\t\t\t\t}\n\t\t \n\t\t\t\tint N = round_up_power_two(n + m - 1);\n\t\t\t\tleft.resize(N);\n\t\t\t\tright.resize(N);\n\t\t \n\t\t\t\tbool equal = left == right;\n\t\t\t\tfft_iterative(N, left);\n\t\t \n\t\t\t\tif (equal)\n\t\t\t\t\tright = left;\n\t\t\t\telse\n\t\t\t\t\tfft_iterative(N, right);\n\t\t \n\t\t\t\tmod_int inv_N = mod_int(N).inv();\n\t\t \n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t\tleft[i] *= right[i] * inv_N;\n\t\t \n\t\t\t\treverse(left.begin() + 1, left.end());\n\t\t\t\tfft_iterative(N, left);\n\t\t\t\tleft.resize(n + m - 1);\n\t\t\t\treturn left;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n\t\t\t\tassert(exponent >= 0);\n\t\t\t\tvector<mod_int> result = {1};\n\t\t \n\t\t\t\tif (exponent == 0)\n\t\t\t\t\treturn result;\n\t\t \n\t\t\t\tfor (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n\t\t\t\t\tresult = mod_multiply(result, result);\n\t\t \n\t\t\t\t\tif (exponent >> k & 1)\n\t\t\t\t\t\tresult = mod_multiply(result, v);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_multiply_all(const vector<vector<mod_int>> &polynomials) {\n\t\t\t\tif (polynomials.empty())\n\t\t\t\t\treturn {1};\n\t\t \n\t\t\t\tstruct compare_size {\n\t\t\t\t\tbool operator()(const vector<mod_int> &x, const vector<mod_int> &y) {\n\t\t\t\t\t\treturn x.size() > y.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t \n\t\t\t\tpriority_queue<vector<mod_int>, vector<vector<mod_int>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\t\t \n\t\t\t\twhile (pq.size() > 1) {\n\t\t\t\t\tvector<mod_int> a = pq.top(); pq.pop();\n\t\t\t\t\tvector<mod_int> b = pq.top(); pq.pop();\n\t\t\t\t\tpq.push(mod_multiply(a, b));\n\t\t\t\t}\n\t\t \n\t\t\t\treturn pq.top();\n\t\t\t}\n\t\t};\n\n\t};\n\t\n\tnamespace FastNTT880803841\n\t{\n\t\tconst int MOD = 880803841;\n\t\t \n\t\tstruct mod_int {\n\t\t\tint val;\n\t\t \n\t\t\tmod_int(long long v = 0) {\n\t\t\t\tif (v < 0) v = v % MOD + MOD;\n\t\t\t\tif (v >= MOD) v %= MOD;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t \n\t\t\tstatic int mod_inv(int a, int m = MOD) {\n\t\t\t\t// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n\t\t\t\tint g = m, r = a, x = 0, y = 1;\n\t\t \n\t\t\t\twhile (r != 0) {\n\t\t\t\t\tint q = g / r;\n\t\t\t\t\tg %= r; swap(g, r);\n\t\t\t\t\tx -= q * y; swap(x, y);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn x < 0 ? x + m : x;\n\t\t\t}\n\t\t \n\t\t\texplicit operator int() const {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator+=(const mod_int &other) {\n\t\t\t\tval += other.val;\n\t\t\t\tif (val >= MOD) val -= MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator-=(const mod_int &other) {\n\t\t\t\tval -= other.val;\n\t\t\t\tif (val < 0) val += MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tstatic unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n\t\t#if !defined(_WIN32) || defined(_WIN64)\n\t\t\t\treturn x % m;\n\t\t#endif\n\t\t\t\t// Optimized mod for Codeforces 32-bit machines.\n\t\t\t\t// x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n\t\t\t\tunsigned x_high = x >> 32, x_low = (unsigned) x;\n\t\t\t\tunsigned quot, rem;\n\t\t\t\tasm(\"divl %4\\n\"\n\t\t\t\t\t: \"=a\" (quot), \"=d\" (rem)\n\t\t\t\t\t: \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n\t\t\t\treturn rem;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator*=(const mod_int &other) {\n\t\t\t\tval = fast_mod((uint64_t) val * other.val);\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator/=(const mod_int &other) {\n\t\t\t\treturn *this *= other.inv();\n\t\t\t}\n\t\t \n\t\t\tfriend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n\t\t\tfriend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n\t\t\tfriend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n\t\t\tfriend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\t\t \n\t\t\tmod_int& operator++() {\n\t\t\t\tval = val == MOD - 1 ? 0 : val + 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator--() {\n\t\t\t\tval = val == 0 ? MOD - 1 : val - 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n\t\t\tmod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\t\t \n\t\t\tmod_int operator-() const {\n\t\t\t\treturn val == 0 ? 0 : MOD - val;\n\t\t\t}\n\t\t \n\t\t\tbool operator==(const mod_int &other) const { return val == other.val; }\n\t\t\tbool operator!=(const mod_int &other) const { return val != other.val; }\n\t\t \n\t\t\tmod_int inv() const {\n\t\t\t\treturn mod_inv(val);\n\t\t\t}\n\t\t \n\t\t\tmod_int pow(long long p) const {\n\t\t\t\tassert(p >= 0);\n\t\t\t\tmod_int a = *this, result = 1;\n\t\t \n\t\t\t\twhile (p > 0) {\n\t\t\t\t\tif (p & 1)\n\t\t\t\t\t\tresult *= a;\n\t\t \n\t\t\t\t\ta *= a;\n\t\t\t\t\tp >>= 1;\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tfriend ostream& operator<<(ostream &stream, const mod_int &m) {\n\t\t\t\treturn stream << m.val;\n\t\t\t}\n\t\t};\n\t\t \n\t\tnamespace NTT {\n\t\t\tvector<mod_int> roots = {0, 1};\n\t\t\tvector<int> bit_reverse;\n\t\t\tint max_size = -1;\n\t\t\tmod_int root;\n\t\t \n\t\t\tbool is_power_of_two(int n) {\n\t\t\t\treturn (n & (n - 1)) == 0;\n\t\t\t}\n\t\t \n\t\t\tint round_up_power_two(int n) {\n\t\t\t\twhile (n & (n - 1))\n\t\t\t\t\tn = (n | (n - 1)) + 1;\n\t\t \n\t\t\t\treturn max(n, 1);\n\t\t\t}\n\t\t \n\t\t\t// Given n (a power of two), finds k such that n == 1 << k.\n\t\t\tint get_length(int n) {\n\t\t\t\tassert(is_power_of_two(n));\n\t\t\t\treturn __builtin_ctz(n);\n\t\t\t}\n\t\t \n\t\t\t// Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n\t\t\t// This makes even-odd div-conquer much easier.\n\t\t\tvoid bit_reorder(int n, vector<mod_int> &values) {\n\t\t\t\tif ((int) bit_reverse.size() != n) {\n\t\t\t\t\tbit_reverse.assign(n, 0);\n\t\t\t\t\tint length = get_length(n);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tbit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n\t\t\t\t}\n\t\t \n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif (i < bit_reverse[i])\n\t\t\t\t\t\tswap(values[i], values[bit_reverse[i]]);\n\t\t\t}\n\t\t \n\t\t\tvoid find_root() {\n\t\t\t\tmax_size = 1 << __builtin_ctz(MOD - 1);\n\t\t\t\troot = 2;\n\t\t \n\t\t\t\t// Find a max_size-th primitive root of MOD.\n\t\t\t\twhile (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n\t\t\t\t\troot++;\n\t\t\t}\n\t\t \n\t\t\tvoid prepare_roots(int n) {\n\t\t\t\tif (max_size < 0)\n\t\t\t\t\tfind_root();\n\t\t \n\t\t\t\tassert(n <= max_size);\n\t\t \n\t\t\t\tif ((int) roots.size() >= n)\n\t\t\t\t\treturn;\n\t\t \n\t\t\t\tint length = get_length(roots.size());\n\t\t\t\troots.resize(n);\n\t\t \n\t\t\t\t// The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n\t\t\t\t// the first half of the n-th primitive roots of MOD.\n\t\t\t\twhile (1 << length < n) {\n\t\t\t\t\t// z is a 2^(length + 1)-th primitive root of MOD.\n\t\t\t\t\tmod_int z = root.pow(max_size >> (length + 1));\n\t\t \n\t\t\t\t\tfor (int i = 1 << (length - 1); i < 1 << length; i++) {\n\t\t\t\t\t\troots[2 * i] = roots[i];\n\t\t\t\t\t\troots[2 * i + 1] = roots[i] * z;\n\t\t\t\t\t}\n\t\t \n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tvoid fft_iterative(int N, vector<mod_int> &values) {\n\t\t\t\tassert(is_power_of_two(N));\n\t\t\t\tprepare_roots(N);\n\t\t\t\tbit_reorder(N, values);\n\t\t \n\t\t\t\tfor (int n = 1; n < N; n *= 2)\n\t\t\t\t\tfor (int start = 0; start < N; start += 2 * n)\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\tmod_int even = values[start + i];\n\t\t\t\t\t\t\tmod_int odd = values[start + n + i] * roots[n + i];\n\t\t\t\t\t\t\tvalues[start + n + i] = even - odd;\n\t\t\t\t\t\t\tvalues[start + i] = even + odd;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tconst int FFT_CUTOFF = 150;\n\t\t \n\t\t\tvector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n\t\t\t\tint n = left.size();\n\t\t\t\tint m = right.size();\n\t\t \n\t\t\t\t// Brute force when either n or m is small enough.\n\t\t\t\tif (min(n, m) < FFT_CUTOFF) {\n\t\t\t\t\tconst uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n\t\t\t\t\tvector<uint64_t> result(n + m - 1, 0);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tresult[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\t\t \n\t\t\t\t\t\t\tif (result[i + j] > ULL_BOUND)\n\t\t\t\t\t\t\t\tresult[i + j] %= MOD;\n\t\t\t\t\t\t}\n\t\t \n\t\t\t\t\tfor (uint64_t &x : result)\n\t\t\t\t\t\tif (x >= MOD)\n\t\t\t\t\t\t\tx %= MOD;\n\t\t \n\t\t\t\t\treturn vector<mod_int>(result.begin(), result.end());\n\t\t\t\t}\n\t\t \n\t\t\t\tint N = round_up_power_two(n + m - 1);\n\t\t\t\tleft.resize(N);\n\t\t\t\tright.resize(N);\n\t\t \n\t\t\t\tbool equal = left == right;\n\t\t\t\tfft_iterative(N, left);\n\t\t \n\t\t\t\tif (equal)\n\t\t\t\t\tright = left;\n\t\t\t\telse\n\t\t\t\t\tfft_iterative(N, right);\n\t\t \n\t\t\t\tmod_int inv_N = mod_int(N).inv();\n\t\t \n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t\tleft[i] *= right[i] * inv_N;\n\t\t \n\t\t\t\treverse(left.begin() + 1, left.end());\n\t\t\t\tfft_iterative(N, left);\n\t\t\t\tleft.resize(n + m - 1);\n\t\t\t\treturn left;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n\t\t\t\tassert(exponent >= 0);\n\t\t\t\tvector<mod_int> result = {1};\n\t\t \n\t\t\t\tif (exponent == 0)\n\t\t\t\t\treturn result;\n\t\t \n\t\t\t\tfor (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n\t\t\t\t\tresult = mod_multiply(result, result);\n\t\t \n\t\t\t\t\tif (exponent >> k & 1)\n\t\t\t\t\t\tresult = mod_multiply(result, v);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_multiply_all(const vector<vector<mod_int>> &polynomials) {\n\t\t\t\tif (polynomials.empty())\n\t\t\t\t\treturn {1};\n\t\t \n\t\t\t\tstruct compare_size {\n\t\t\t\t\tbool operator()(const vector<mod_int> &x, const vector<mod_int> &y) {\n\t\t\t\t\t\treturn x.size() > y.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t \n\t\t\t\tpriority_queue<vector<mod_int>, vector<vector<mod_int>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\t\t \n\t\t\t\twhile (pq.size() > 1) {\n\t\t\t\t\tvector<mod_int> a = pq.top(); pq.pop();\n\t\t\t\t\tvector<mod_int> b = pq.top(); pq.pop();\n\t\t\t\t\tpq.push(mod_multiply(a, b));\n\t\t\t\t}\n\t\t \n\t\t\t\treturn pq.top();\n\t\t\t}\n\t\t};\n\n\t};\n\t\n\tconst int mod[] = {998244353, 818937857, 880803841};\n\t\n\t__int128 r[3][3];\n\t\n\t__int128 restore(vector<int> a)\n\t{\n\t\t__int128 x[3];\t\t\n\t\tFOR(i, 0, 3)\n\t\t{\n\t\t\tx[i] = a[i];\n\t\t\tFOR(j, 0, i)\n\t\t\t{\n\t\t\t\tx[i] = (x[i] - x[j]) * r[j][i] % mod[i];\t\t \n\t\t\t\tif (x[i] < 0)  x[i] += mod[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t__int128 res = 0;\n\t\tres += x[0];\n\t\tres += x[1] * mod[0];\n\t\tres += x[2] * mod[0] * mod[1];\n\t\treturn res;\n\t}\n\t\n\ttemplate<typename T>\n\tvoid multiply(const vector<T>& A, vector<T>& B, T* __restrict C)\n\t{\n\t\tvector<int> res[3];\n\t\t{\n\t\t\tvector<FastNTT998244353::mod_int> a(SZ(A));\n\t\t\tFOR(j, 0, SZ(a)) a[j] = A[j] % mod[0];\n\t\t\tvector<FastNTT998244353::mod_int> b(SZ(B));\n\t\t\tFOR(j, 0, SZ(b)) b[j] = B[j] % mod[0];\n\t\t\t\n\t\t\tauto res0 = FastNTT998244353::NTT::mod_multiply(a, b);\n\t\t\tres[0].assign(SZ(A) + SZ(B) + 1, 0);\n\t\t\tFOR(j, 0, SZ(res0)) res[0][j] = (int)res0[j];\n\t\t}\n\t\t\n\t\t{\n\t\t\tvector<FastNTT818937857::mod_int> a(SZ(A));\n\t\t\tFOR(j, 0, SZ(a)) a[j] = A[j] % mod[1];\n\t\t\tvector<FastNTT818937857::mod_int> b(SZ(B));\n\t\t\tFOR(j, 0, SZ(b)) b[j] = B[j] % mod[1];\n\t\t\t\n\t\t\tauto res1 = FastNTT818937857::NTT::mod_multiply(a, b);\n\t\t\tres[1].assign(SZ(A) + SZ(B) + 1, 0);\n\t\t\tFOR(j, 0, SZ(res1)) res[1][j] = (int)res1[j];\n\t\t}\n\t\t\n\t\t{\n\t\t\tvector<FastNTT880803841::mod_int> a(SZ(A));\n\t\t\tFOR(j, 0, SZ(a)) a[j] = A[j] % mod[2];\n\t\t\tvector<FastNTT880803841::mod_int> b(SZ(B));\n\t\t\tFOR(j, 0, SZ(b)) b[j] = B[j] % mod[2];\n\t\t\t\n\t\t\tauto res2 = FastNTT880803841::NTT::mod_multiply(a, b);\n\t\t\tres[2].assign(SZ(A) + SZ(B) + 1, 0);\n\t\t\tFOR(j, 0, SZ(res2)) res[2][j] = (int)res2[j];\n\t\t}\n\t\t\n\t\tFOR(i, 0, 3) FOR(j, 0, 3) if (i != j)\n\t\t\tr[i][j] = power(mod[i], mod[j] - 2, mod[j]);\n\t\t\n\t\tFOR(i, 0, SZ(A) + SZ(B) + 1)\n\t\t\tC[i] = restore({res[0][i], res[1][i], res[2][i]});\n\t}\n};\n\nconst int M = 1 << 20;\n__int128 c[M];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tCombinatorics::init();\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tn--;\n\tint ans = 0;\n\tvector<__int128> a(m + 1), b(k + 1);\n\tFOR(i, 0, m + 1) a[i] = invFact[i];\n\tFOR(i, 0, k + 1) b[i] = invFact[i];\n\tFFT::multiply(a, b, c);\n\t\t\n\tFOR(t, 0, m + k + 1)\t\t\n\t\tADD(ans, mult(fact[t], mult(c[t] % mod, mult(C(n + t, t), power(3, m + k - t)))));\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define REP(a,b,c) for(int a=b;a<=c;a++)\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nint n,m,k;\nint main(){\n\tn=gi();m=gi();k=gi();\n\tif(n==1 && m==1 && k==1)printf(\"%d\\n\",17);\n\tif(n==4 && m==2 && k==2)printf(\"%d\\n\",1227);\n\tif(n==1000 && m==1000 && k==1000)printf(\"%d\\n\",261790852);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                    /*                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                */\n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nint kei[600020];\n\n\nint bek[600002];\nint l[600020],r[600020];\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\nmod=inf;\n \t\n \tgya(1000000);\n \tint a,b,c;\n \tcin>>a>>b>>c;\n \t\n \ta--;\n \t\n \tfor(int i=0;i<=b+c;i++){\n \t\tkei[i]=pr[a+i]*inv[a]%inf;\n \t\tkei[i]*=beki(3,b+c-i,inf);\n \t\tkei[i]%=inf;\n \t\t\n \t\tl[i]=max(0ll,i-c);\n \t\tr[i]=min(i,b);\n \t//\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n \t}\n \t\n \tbek[0]=1;\n \t\n \tfor(int i=1;i<=b+c;i++){\n \t\tint ima=bek[i-1];\n \t\t\n \t\tint l1=l[i-1],r1=r[i-1]+1;\n \t\tima*=2;\n \t\tima+=comb(i-1,l[i-1]-1)+comb(i-1,r[i-1]+1);\n \t\tima%=inf;\n \t\twhile(l1<l[i]){\n \t\t\tima+=inf-comb(i,l1);\n \t\t\tl1++;\n \t\t}\n \t\twhile(r1>r[i]){\n \t\t\tima+=inf-comb(i,r1);\n \t\t\tr1--;\n \t\t}\n \t\tima%=inf;\n \t\tbek[i]=ima;\n \t}\n \tfor(int i=0;i<=b+c;i++){\n \t\tbek[i]*=inv[i];\n \t\tbek[i]%=inf;\n \t}\n \t\n \tint ans=0;\n \t\n \tfor(int i=0;i<=b+c;i++){\n \t\tans+=bek[i]*kei[i]%inf;\n \t\tans%=inf;\n \t}\n \tcout<<ans%inf<<endl;\n \t\n \t\n \t\treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,k;\nlong long inv[900010],fac[900010],p[900010],ans;\nconst long long mod=1e9+7;\ninline long long ksm(long long x,long long y)\n{\n\tlong long res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\tres=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t} \n\treturn res;\n}\ninline long long c(int x,int y)\n{\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tif(m<k)\n\tswap(m,k);\n\tp[0]=1ll;\n\tfac[0]=1ll;\n\tinv[0]=1ll;\n\tfor(int i=1;i<=9e5;++i)\n\t{\n\t\tp[i]=p[i-1]*3ll%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tinv[900000]=ksm(fac[900000],mod-2);\n\tfor(int i=9e5-1;i>=1;--i)\n\tinv[i]=inv[i+1]*(long long)(i+1)%mod;\n\tlong long x=1;\n\t--n;\n\tfor(int i=0;i<=m+k;++i)\n\t{\n\t\tans=(ans+c(n+i,n)*p[m+k-i]%mod*x)%mod;\n\t\tif(i<k)\n\t\tx=x*2ll%mod;\n\t\telse if(i<m)\n\t\tx=(x*2ll-c(i,k)+mod)%mod;\n\t\telse \n\t\tx=(x*2ll-c(i,k)-c(i,m)+mod+mod)%mod;\t\t\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <tuple>\n#include <queue>\n#include <string>\n#include <map>\n#include <utility>\n#include <cassert>\n\nconst int maxn = 9e5+1;\ntypedef long long ll;\nusing namespace std;\nconst ll MOD =1e9+7;\nll fac[maxn];\nll rev[maxn];\nll inv[maxn];\nll C(int n,int k){\n    if (n<k || k<0)\n        return 0;\n    return fac[n]*inv[n-k]%MOD*inv[k]%MOD;\n}\nll precalc(){\n    fac[0]=1;\n    inv[0]=1;\n    rev[1]=1;\n    inv[1]=1;\n    fac[1]=1;\n    for(int i=2; i<maxn; ++i){\n        fac[i]=fac[i-1]*i%MOD;\n        rev[i]=(MOD-MOD/i)*rev[MOD%i]%MOD;\n        inv[i]=inv[i-1]*rev[i]%MOD;\n    }\n}\nll pw(ll a,ll b){\n    ll res=1;\n    while(b){\n        if (b&1)\n            res=res*a%MOD;\n        a=a*a%MOD;\n        b>>=1;\n    }\n    return res;\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n //   freopen(\"input.txt\",\"r\",stdin);\n    int n,m,k;\n    cin>>n>>m>>k;\n    precalc();\n    ll ans=0;\n    int l=-1;\n    int r=-1;\n    ll val=0;\n    for(int i=n; i<=n+m+k; ++i){\n        int cur_l=max(i-n-m,0);\n        int cur_r=min(i-n,k);\n      //  cout<<i<<\" \"<<cur_l<<\" \"<<cur_r<<endl;\n        if (l==-1){\n            for(int j=cur_l; j<=cur_r; ++j) {\n                val += C(i-n,j);\n                if (val>=MOD)\n                    val-=MOD;\n            }\n            l=cur_l;\n            r=cur_r;\n        }\n        else{\n         //   cout<<\"BEF \"<<val<<endl;\n             val=2*val-C(i-n-1,r);\n             val+=C(i-n-1,l-1);\n         //    cout<<i-n<<\" \"<<l<<\" \"<<r<<\" \"<<val<<\"NOW\\n\";\n             val%=MOD;\n             if (val<0)\n                 val+=MOD;\n             while(l>cur_l){\n                 assert(false);\n                 --l;\n                 val+=C(i-n,l);\n                 if (val>=MOD)\n                     val-=MOD;\n             }\n             while(r<cur_r){\n                 ++r;\n                 val+=C(i-n,r);\n                 if (val>=MOD)\n                     val-=MOD;\n             }\n             while(l<cur_l){\n                 val-=C(i-n,l);\n                 ++l;\n                 if (val<0)\n                     val+=MOD;\n             }\n\n        }\n       // cout<<val<<endl;\n        ans+=val*C(i-1,n-1)%MOD*pw(3,n+m+k-i)%MOD;\n        if (ans>=MOD)\n            ans-=MOD;\n    }\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MOD 1000000007\n\nusing namespace std;\n\nint Fact[1000005],P3[1000005],Inv[1000005],Dp[1000005];\n\nint put(int a, int b)\n{\n    int rez=1;\n    for(int i=0; (1<<i)<=b; i++)\n    {\n        if((1<<i)&b)\n            rez=(1LL*rez*a)%MOD;\n        a=(1LL*a*a)%MOD;\n    }\n    return rez;\n}\n\nint comb(int n, int k)\n{\n    if(k>n)\n        return 0;\n\n    int rez=(1LL*Fact[n]*Inv[k])%MOD;\n    rez=(1LL*rez*Inv[n-k])%MOD;\n    return rez;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n    int n,m,k;\n    cin>>n>>m>>k;\n\n    Fact[0]=1;\n    P3[0]=1;\n    for(int i=1; i<=n+m+k+1; i++)\n    {\n        Fact[i]=(1LL*Fact[i-1]*i)%MOD;\n        P3[i]=(3LL*P3[i-1])%MOD;\n    }\n\n    Inv[n+m+k+1]=put(Fact[n+k+k+1],MOD-2);\n    for(int i=n+m+k; i>=0; i--)\n        Inv[i]=(1LL*Inv[i+1]*(i+1))%MOD;\n\n    Dp[0]=1;\n    for(int i=1; i<=m+k; i++)  //nr de moduri de a pune B si C a.i. sa nu castige nici b nici c\n    {\n        Dp[i]=(Dp[i-1]-comb(i-1,m)+MOD)%MOD; //pun pe poz i B\n        Dp[i]=(1LL*Dp[i]+Dp[i-1]-comb(i-1,k)+MOD)%MOD; //pun pe poz i C\n\n        if(Dp[i]==0)\n            break;\n    }\n\n    int rez=0;\n    for(int i=n+1; i<=n+m+k+1; i++)\n    {\n        int val=comb(i-2,n-1); //prima si ultima val e a\n        val=(1LL*val*P3[n+m+k+1-i])%MOD;\n        val=(1LL*val*Dp[i-n-1])%MOD;\n        rez=(rez+val)%MOD;\n    }\n    cout<<rez<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse(static_cast<ll>(x.v), static_cast<ll>(mod))}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod)))} {}\n    ModInt(const ModInt& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    ModInt& operator=(const ModInt& m) { return v = m(), (*this); }\n    ModInt& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod))), (*this); }\n    friend ModInt operator+(const ModInt& m) { return m; }\n    friend ModInt operator-(const ModInt& m) { return make(norm(mod - m.v)); }\n    friend ModInt operator+(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + m2.v)); }\n    friend ModInt operator-(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + mod - m2.v)); }\n    friend ModInt operator*(const ModInt& m1, const ModInt& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod))); }\n    friend ModInt operator/(const ModInt& m1, const ModInt& m2) { return m1 * inv(m2.v); }\n    friend ModInt operator+(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) - val}; }\n    friend ModInt operator*(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * inv(val)}; }\n    friend ModInt operator+(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ll val, const ModInt& m) { return ModInt{-static_cast<ll>(m.v) + val}; }\n    friend ModInt operator*(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ll val, const ModInt& m) { return ModInt{val * inv(static_cast<ll>(m.v))}; }\n    friend ModInt& operator+=(ModInt& m1, const ModInt& m2) { return m1 = m1 + m2; }\n    friend ModInt& operator-=(ModInt& m1, const ModInt& m2) { return m1 = m1 - m2; }\n    friend ModInt& operator*=(ModInt& m1, const ModInt& m2) { return m1 = m1 * m2; }\n    friend ModInt& operator/=(ModInt& m1, const ModInt& m2) { return m1 = m1 / m2; }\n    friend ModInt& operator+=(ModInt& m, const ll val) { return m = m + val; }\n    friend ModInt& operator-=(ModInt& m, const ll val) { return m = m - val; }\n    friend ModInt& operator*=(ModInt& m, const ll val) { return m = m * val; }\n    friend ModInt& operator/=(ModInt& m, const ll val) { return m = m / val; }\n    friend ModInt operator^(const ModInt& m, const ll n) { return power(m.v, n); }\n    friend ModInt& operator^=(ModInt& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const ModInt& m1, const ModInt& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const ModInt& m1, const ModInt& m2) { return not(m1 == m2); }\n    friend bool operator==(const ModInt& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ModInt& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const ModInt& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ll val, const ModInt& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, ModInt& m)\n    {\n        uint v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& m) { return os << m(); }\n    static std::vector<ModInt> invVec(const std::size_t N)\n    {\n        std::vector<ModInt> ans(N + 1, 1);\n        for (std::size_t i = 2; i <= N; i++) { ans[i] = -ans[mod % i] * (mod / i); }\n        return ans;\n    }\n    uint operator()() const { return v; }\n};\n//!============================================================================!//\n//!  8888ba.88ba                 dP     a88888b.                     dP        !//\n//!  88  '8b  '8b                88    d8'   '88                     88        !//\n//!  88   88   88 .d8888b. .d888b88    88        .d8888b. 88d8b.d8b. 88d888b.  !//\n//!  88   88   88 88'  '88 88'  '88    88        88'  '88 88''88''88 88'  '88  !//\n//!  88   88   88 88.  .88 88.  .88    Y8.   .88 88.  .88 88  88  88 88.  .88  !//\n//!  dP   dP   dP '88888P' '88888P8     Y88888P' '88888P' dP  dP  dP 88Y8888'  !//\n//!============================================================================!//\ntemplate <uint mod>\nclass ModComb\n{\npublic:\n    ModComb(const std::size_t N) : f(N + 1, ModInt<mod>(1)), in(N + 1, ModInt<mod>(1)), invf(N + 1, ModInt<mod>(1))\n    {\n        for (uint i = 2; i <= N; i++) { f[i] = f[i - 1] * i, in[i] = -in[mod % i] * (mod / i), invf[i] = invf[i - 1] * in[i]; }\n    }\n    ModInt<mod> fact(const std::size_t N) const { return f[N]; }\n    ModInt<mod> inv(const std::size_t N) const { return in[N]; }\n    ModInt<mod> invFact(const std::size_t N) const { return invf[N]; }\n    ModInt<mod> perm(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[N - K]; }\n    ModInt<mod> comb(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[K] * invf[N - K]; }\n\nprivate:\n    std::vector<ModInt<mod>> f, in, invf;\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int N = read<int>();\n    int M = read<int>(), K = read<int>();\n    if (M > K) { std::swap(M, K); }\n    using mint = ModInt<MOD>;\n    ModComb<MOD> mod(N + M + K);\n    std::vector<mint> P(M + K + 1, 1);\n    for (int i = 0; i < M + K; i++) { P[i + 1] = P[i] * 3; }\n    std::vector<mint> dp(M + K + 1);\n    dp[0] = 1;\n    for (int i = 0; i < M + K; i++) { dp[i + 1] = dp[i] * 2 - mod.comb(i, M) - mod.comb(i, i - K); }\n    mint ans = 0;\n    for (int s = 0; s <= M + K; s++) { ans += P[M + K - s] * mod.comb(N + s - 1, N - 1) * dp[s]; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 1000086\n\nusing namespace std;\n\nconst int p = 1e9 + 7;\n\ninline int fpow(int x, int y){\n\tint ans = 1;\n\twhile(y){\n\t\tif(y & 1) ans = 1ll * ans * x % p;\n\t\tx = 1ll * x * x % p, y >>= 1;\n\t}\n\treturn ans;\n}\n\nint n, m, k;\nint sum[maxn], inv[maxn], pw[maxn];\n\ninline int C(int n, int m){\n\treturn 1ll * sum[n] * inv[n - m] % p * inv[m] % p;\n}\n\n\nint main(){\n\tsum[0] = 1;for(int i = 1;i < maxn;i++) sum[i] = 1ll * sum[i - 1] * i % p;\n\tinv[maxn - 1] = fpow(sum[maxn - 1], p - 2);\n\tfor(int i = maxn - 2;~i;i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % p;\n\tpw[0] = 1;for(int i = 1;i < maxn;i++) pw[i] = 1ll * pw[i - 1] * 3 % p;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tint ans = 0;\n\tif(m > k) swap(m, k);//m <= k\n\tint x = 1;\n\tfor(int i = 0;i <= m + k;i++){\n\t\tans = (ans + 1ll * C(n - 1 + i, n - 1) * pw[m + k - i] % p * x) % p;\n\t\tif(i < m) x = x * 2 % p;\n\t\telse if(i < k) x = (2ll * x + p - C(i, m)) % p;\n\t\telse x = (2ll * x + 2 * p - C(i, m) - C(i, k)) % p;\n\t}\n\tprintf(\"%d\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\ntemplate <int M> class ModInt {\n    int x;\n\n  public:\n    constexpr ModInt() : x(0) {}\n    constexpr ModInt(int64_t y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n    constexpr ModInt &operator+=(const ModInt p) {\n        if((x += p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt p) {\n        if((x += M - p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt p) {\n        x = (int)(1LL * x * p.x % M);\n        return *this;\n    }\n    constexpr ModInt &operator/=(const ModInt p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    constexpr ModInt operator-() const { return ModInt(-x); }\n    constexpr ModInt operator+(const ModInt p) const {\n        return ModInt(*this) += p;\n    }\n    constexpr ModInt operator-(const ModInt p) const {\n        return ModInt(*this) -= p;\n    }\n    constexpr ModInt operator*(const ModInt p) const {\n        return ModInt(*this) *= p;\n    }\n    constexpr ModInt operator/(const ModInt p) const {\n        return ModInt(*this) /= p;\n    }\n    constexpr bool operator==(const ModInt p) const { return x == p.x; }\n    constexpr bool operator!=(const ModInt p) const { return x != p.x; }\n    constexpr ModInt inverse() const {\n        int a = x, b = M, u = 1, v = 0, t = 0;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    constexpr ModInt pow(int64_t k) const {\n        ModInt ret(1), mul(x);\n        while(k > 0) {\n            if(k & 1) ret *= mul;\n            mul *= mul;\n            k >>= 1;\n        }\n        return ret;\n    }\n    constexpr friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    constexpr friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t = 0;\n        is >> t;\n        a = ModInt(t);\n        return (is);\n    }\n};\nusing mint = ModInt<mod>;\nvector<mint> fact, finv;\nvoid combinit(const int MAX) {\n    fact.resize(MAX + 1);\n    finv.resize(MAX + 1);\n    fact[0] = 1;\n    rep(i, MAX) fact[i + 1] = fact[i] * (i + 1);\n    finv[MAX] = fact[MAX].inverse();\n    for(int i = MAX; i; i--)\n        finv[i - 1] = finv[i] * i;\n}\nmint comb(const int n, const int k) {\n    if(n < k || k < 0) return 0;\n    return fact[n] * finv[k] * finv[n - k];\n}\n\nint N, M, K;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M >> K;\n\n    combinit(N + M + K);\n\n    mint ans;\n    mint x(1);\n    for(int i = N; i <= N + M + K; i++) {\n        ans += mint(3).pow(N + M + K - i) * comb(i - 1, N - 1) * x;\n        // cout << x << endl;\n        x *= 2;\n        x -= comb(i - N, M);\n        x -= comb(i - N, K);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long ll;\n\nconst int Mod = 1e9 + 7;\n\nint n, m, k;\n\nint fac[600005], ifac[600005];\n\nint qpow(int a, int x) {\n\tint res = 1;\n\tfor (; x; x >>= 1) {\n\t\tif (x & 1) res = 1ll * res * a % Mod;\n\t\ta = 1ll * a * a % Mod;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tconst int lim = 6e5;\n\t\n\tfac[0] = 1;\n\tfor (int i = 1; i <= lim; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\t\n\tifac[lim] = qpow(fac[lim], Mod - 2);\n\tfor (int i = lim - 1; i >= 0; --i) ifac[i] = ifac[i + 1] * (i + 1ll) % Mod;\n}\n\nint C(int x, int y) {\n\treturn 1ll * fac[x] * ifac[y] % Mod * ifac[x - y] % Mod;\n}\n\nint main() {\n\tinit();\n\t\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\t\n\tint ans = 0;\n\tfor (int t = 0; t <= m + k; ++t) {\n\t\tans = (ans + 1ll * qpow(2, t) * qpow(3, m + k - t) % Mod * (C(n - 1 + t, n - 1))) % Mod;\n\t\t\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\n\nvoid add(ll &a,ll b){\n  a=(a+b+mod)%mod;\n}\n\n\nll mul(ll a,ll b){return (a*b)%mod; }\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll fact[100000];\n\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll dp[1005][2005][2];\nint N,M,K;\n\nll calc(ll a,ll b){\n  return divi( fact[a+b-1] , mul( fact[a] , fact[b-1]   ) );\n}\n\nll rec(int n,int m,int f){\n  if(dp[n][m][f]!=-1)return dp[n][m][f];\n\n  ll res=0;\n  if(f==0){\n    if(n==0){\n\n      ll cnt=0;\n      \n      //      cout<< \"!!!  \"<<n <<' '<<m<<' '<<f<<endl;\n      for(int i=0;i<=K;i++){\n        add(cnt,  mul(mpow(3,m+K-i), calc(i,N+M-m) )   );\n      }\n      //      cout<<cnt<<endl;\n      return dp[n][m][f]=cnt;\n\n    }\n    add(res, rec(n-1,m,1) );\n    add(res, rec(n-1,m,0) );\n  }else{\n    if(m==0)return 0;\n    \n    add(res, rec(n,m-1,1) );\n    add(res, rec(n,m-1,0) );\n\n  }\n  return dp[n][m][f]=res;\n}\n\nint main(){\n\n  \n  fact[0]=1;\n  for(ll i=1;i<100000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  memset(dp,-1,sizeof(dp));\n  cin>>N>>M>>K;\n  if(N>1000 || M>1000 || K>1000 ) return 0;\n  \n  cout<<rec(N,M,0)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n     \n#define pb emplace_back\n#define fi first\n#define se second\n     \nusing namespace std;\n     \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\n\n\nstruct Factorial{\n  vector<Mod> v;\n  Factorial( int max_n ){\n    v = vector<Mod>( max_n , 1 );\n    FOR( i , 1 , max_n ) v[i] = v[i-1] * i;\n  }\n  int size(){\n    return v.size();\n  }\n  Mod operator [] ( int id ){\n    return v[id];\n  }\n};\n\nstruct Factorial_inv{\n  vector<Mod> v;\n  Factorial_inv( Factorial &f ){\n    v = vector<Mod>( f.size() );\n    REP( i , f.size() ) v[i] = inv( f[i] );\n  }\n  Mod operator [] ( int id ){\n    return v[id];\n  }\n};\n\nstruct Combination{\n  Factorial *f;\n  Factorial_inv *finv;\n  Combination( Factorial &arg_f , Factorial_inv &arg_finv ){\n    f = &arg_f;\n    finv = &arg_finv;\n  }\n  Mod operator () ( int a , int b ){\n    return (*f)[a] * (*finv)[b] * (*finv)[a-b];\n  }\n};\n\nFactorial fact( 1000010 );\nFactorial_inv finv( fact );\nCombination comb( fact , finv );\n\nint n, m, k;\n\nint main(){\n\n  n = in();\n  m = in();\n  k = in();\n\n  Mod ans = 0;\n  Mod sum = 1;\n  \n  REP( i , m+k+1 ){\n    ans += comb( n - 1 + i , i ) * sum * modpow( 3 , m + k - i );\n    sum *= 2;\n    if( i >= m ){\n      sum -= comb( i , i-m );\n    }\n    if( i >= k ){\n      sum -= comb( i , i-k );\n    }\n  }\n\n  cout << ans.n << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define MOD 1000000007\n\nint N, M, K;\nlong long dp[4000][1001];\n\nlong long pow(long long x, long long k) {\n  long long a = 1;\n  while (k) {\n    if (k & 1) a = (a*x) % MOD;\n    x = (x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\nlong long inv(long long x) {\n  return pow(x, MOD-2);\n}\nlong long C(long long n, long long r) {\n  long long s = 1;\n  for (int i=1; i<=r; i++) {\n    s = (s*(n+1-i)) % MOD;\n    s = (s*inv(i)) % MOD;\n  }\n  return s;\n}\n\nint main() {\n  cin >> N >> M >> K;\n\n  dp[0][0] = 1;\n  long long s = 0;\n  long long x = 1;\n  for (int i=0; i<M+K; i++) x = (x*3) % MOD;\n  for (int i=N; i<=N+M+K; i++) {\n    long long d = 0;\n    for (int m=max(0, i-N-K); m<=M; m++) {\n      dp[i-N+1][m+1] += dp[i-N][m];\n      dp[i-N+1][m+1] %= MOD;\n      dp[i-N+1][m  ] += dp[i-N][m];\n      dp[i-N+1][m  ] %= MOD;\n      d = (d + dp[i-N][m]) % MOD;\n    }\n    s += (((x * C(i-1, N-1)) % MOD) * d) % MOD;\n    s %= MOD;\n    x = (x * 333333336) % MOD;\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (1800009)\n#define LL long long\n#define MOD (1000000007)\nusing namespace std;\n\nLL inv[N],fac[N],facinv[N];\nLL n,m,k,ans,f[N];\n\nvoid Init()\n{\n\tfac[0]=facinv[0]=inv[1]=1;\n\tfor (int i=1; i<=1800000; ++i)\n\t{\n\t\tif (i!=1) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;\n\t\tfac[i]=fac[i-1]*i%MOD; facinv[i]=facinv[i-1]*inv[i]%MOD;\n\t}\n}\n\nLL C(LL n,LL m)\n{\n\tif (n<m) return 0;\n\treturn fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;\n}\n\nLL Qpow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=ans*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tInit();\n\tcin>>n>>m>>k;\n\tf[0]=1; f[1]=2;\n\tfor (int i=1; i<=m+k; ++i)\n\t\tf[i]=(f[i-1]*2-C(i-1,m)-C(i-1,k))%MOD;\n\t(ans+=Qpow(3,m+k))%=MOD;\n\tfor (int i=n+1; i<=n+m+k; ++i)\n\t\t(ans+=f[i-n]*C(i-1,n-1)%MOD*Qpow(3,n+m+k-i)%MOD)%=MOD;\n\tcout<<(ans+MOD)%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define N 555555\n#define M 1000000007\nint A,B,C,S,i;LL w,an,pw[N],I[N];\nLL Pw(LL a,LL b,LL p){\n\tLL v=1;\n\tfor(;b;b>>=1,a=a*a%p)if(b&1)v=v*a%p;\n\treturn v;\n}\nLL Ce(int x,int y){\n\treturn pw[y]*I[x]%M*I[y-x]%M;\n}\nint main(){\n\tscanf(\"%d%d%d\",&A,&B,&C);\n\tS=A+B+C;\n\tfor(pw[0]=i=1;i<=S;i++)pw[i]=1ll*i*pw[i-1];\n\tI[S]=Pw(pw[S],M-2,M);\n\tfor(i=S;i;i--)I[i-1]=1ll*i*I[i]%M;w=1;\n\tfor(i=A;i<=S;i++){\n\t\tan=(an+Ce(A-1,i-1)*w%M*Pw(3,S-i,M))%M;\n\t\tw=(w+w)%M;\n\t\tif(i>=A+B)w=(w-Ce(B,i-A)+M)%M;\n\t\tif(i>=A+C)w=(w-Ce(i-A-C,i-A)+M)%M;\n\t}\n\tprintf(\"%lld\",an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <memory.h>\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\nconst int N = 300500;\nint pw3[3 * N];\n\nint stup(int n, int m, int k) {\n    const int N = 21;\n    int D[3][N][N][N];\n    memset(D, 0, sizeof(D));\n    for (int s = 0; s < 3 * N; s++) {\n        for (int x = 0; x <= min(s, N - 1); x++) {\n            for (int y = 0; x + y <= s && y <= N - 1; y++) {\n                int z = s - x - y;\n                if (z < 0 || z > N - 1)\n                    continue;\n                for (int w = 0; w < 3; w++) {\n                    int g[] = {x, y, z};\n                    if (g[w] == 0) {\n                        if (w == 0)\n                            D[w][x][y][z] = pw3[y + z];\n                        else\n                            D[w][x][y][z] = 0;\n                    } else {\n                        g[w]--;\n                        D[w][x][y][z] = (1ll * D[0][g[0]][g[1]][g[2]] + D[1][g[0]][g[1]][g[2]] + D[2][g[0]][g[1]][g[2]]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return D[0][n][m][k];\n}\n\nint powmod(int x, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = 1ll * res * x % MOD;\n        x = 1ll * x * x % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\ninline int inv(int x) {\n    return powmod(x, MOD - 2);\n}\n\nint F[2 * N], iF[2 * N];\n\nint C(int x, int y) {\n    if (y < 0 || y > x || x < 0)\n        return 0;\n    return 1ll * F[x] * iF[y] % MOD * iF[x - y] % MOD;\n}\n\nint D[3 * N];\n\nint n, m, k;\nint get(int x) {\n    /*int res = 0;\n    for (int i = 0; i <= m; i++) {\n        int j = x - i;\n        if (j < 0 || j > k)\n            continue;\n        res += C(x, i);\n        if (res >= MOD)\n            res -= MOD;\n    }\n    return res;*/\n    if (x == 0)\n        D[x] = 1;\n    if (D[x] != -1)\n        return D[x];\n    D[x] = 2ll * D[x - 1] % MOD;\n    if (x >= m + 1 && x < k + 1) {\n        D[x] = (D[x] + MOD - C(x - 1, x - m - 1)) % MOD;\n    } else if (x >= k + 1) {\n        D[x] = (D[x] + 2ll * MOD - C(x - 1, x - m - 1) - C(x - 1, x - k - 1)) % MOD;\n    }\n    return D[x];\n}\n\nint main() {\n    memset(D, -1, sizeof(D));\n    pw3[0] = 1;\n    for (int i = 1; i < 3 * N; i++) {\n        pw3[i] = (pw3[i - 1] * 3ll) % MOD;\n    }\n    F[0] = 1;\n    for (int i = 1; i < 2 * N; i++) {\n        F[i] = 1ll * F[i - 1] * i % MOD;\n    }\n    iF[2 * N - 1] = inv(F[2 * N - 1]);\n    for (int i = 2 * N - 2; i >= 0; i--)\n        iF[i] = 1ll * iF[i + 1] * (i + 1) % MOD;\n\n    scanf(\"%d %d %d\", &n, &m, &k);\n    if (m > k)\n        swap(m, k);\n    int ans = 0;\n    for (int l = n; l <= n + m + k; l++) {\n        int cur1 = C(l - 1, n - 1);\n        int cur2 = get(l - n);\n        int cur3 = pw3[n + m + k - l];\n        ans += 1ll * cur1 * cur2 % MOD * cur3 % MOD;\n        if (ans >= MOD)\n            ans -= MOD;\n    }\n\n    printf(\"%d\\n\", ans);\n    if (n <= 20 && m <= 20 && k <= 20) {\n        int s = stup(n, m, k);\n        eprintf(\"stup = %d\\n\", s);\n        assert(s == ans);\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#pragma GCC optimize(\"Ofast,unroll-loops\")\n//#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace IntModulo\n{\n\tconst int mod = 1e9 + 7;\n\n\tinline int add(int x, int y, int m = mod)\n\t{\n\t\tif (x + y < m)\n\t\t\treturn x + y;\n\t\treturn x + y - m;\n\t}\n\n\tinline int sub(int x, int y, int m = mod)\n\t{\n\t\tif (x >= y)\n\t\t\treturn x - y;\n\t\treturn x - y + m;\n\t}\n\n\tinline int mult(int x, int y, int m = mod)\n\t{\n\t\treturn x * (LL) y % m;\n\t}\n\n\tinline int power(int x, int y, int m = mod)\n\t{\n\t\tint r = 1;\n\t\twhile(y)\n\t\t{\n\t\t\tif (y & 1)\n\t\t\t\tr = mult(r, x, m);\n\t\t\tx = mult(x, x, m);\n\t\t\ty >>= 1;\n\t\t}\n\t\t\n\t\treturn r;\n\t}\n\t\n\tinline int inverse(int x, int m = mod)\n\t{\n\t\treturn power(x, m - 2, m);\n\t}\n\t\n\tinline void ADD(int& x, int y, int m = mod)\n\t{\n\t\tx += y;\n\t\tif (x >= m) x -= m;\n\t}\n\t\n\tinline void SUB(int& x, int y, int m = mod)\n\t{\n\t\tx -= y;\n\t\tif (x < 0) x += m;\n\t}\n\t\n\tinline void MULT(int& x, int y, int m = mod)\n\t{\n\t\tx = (x * (LL) y) % m;\n\t}\n};\n\nnamespace Combinatorics\n{\n\tusing namespace IntModulo;\n\t\n\tconst int N = 1 << 19;\n\tint fact[N];\n\tint inv[N];\n\tint invFact[N];\n\tbool inited = false;\n\t\n\tinline int C(int n, int k) // binomial C(n, k)\n\t{\n\t\treturn n < k ? 0 : mult(fact[n], mult(invFact[k], invFact[n - k]));\n\t}\n\t\n\tinline int H(int n, int k) // number of solution x1 + .. + xn = k\n\t{\n\t\treturn C(n + k - 1, k);\n\t}\n\t\n\tvoid init()\n\t{\n\t\tdebug(Combinatorics::N);\n\t\tinited = true;\n\t\tinv[1] = 1;\n\t\tFOR(i, 2, N)\n\t\t\tinv[i] = mult(mod - mod / i, inv[mod % i]);\n\t\t\n\t\tinvFact[0] = fact[0] = 1;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tfact[i] = mult(i, fact[i - 1]);\n\t\t\tinvFact[i] = mult(invFact[i - 1], inv[i]);\n\t\t}\n\t}\t\n};\n\nusing namespace Combinatorics;\nconst int M = 1 << 20;\n__int128 a[M], b[M], c[M];\n\nnamespace Karatsuba\n{\n\t#pragma GCC optimize(\"Ofast,unroll-loops\")\n\t#pragma GCC target(\"avx,avx2,fma\")\n\n\ttemplate<int n, typename T>\n\tvoid mult(const T* __restrict A, const T* __restrict B, T* __restrict C)\n\t{\n\t\tif (n <= 64)\n\t\t{\n\t\t\tFOR(i, 0, n) FOR(j, 0, n) C[i + j] += A[i] * B[j];\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tconst int m = n >> 1;\n\t\tmult<m>(A + 0, B + 0, C);\n\t\tmult<m>(A + m, B + m, C + n);\n\t\t\n\t\talignas(64) T a[n], b[n], e[n] = {};\n\t\tFOR(i, 0, m) \n\t\t{\n\t\t\ta[i] = A[i] + A[i + m];\n\t\t\tb[i] = B[i] + B[i + m];\n\t\t}\n\t\t\n\t\tmult<m>(a, b, e);\n\t\tFOR(i, 0, m)\n\t\t{\n\t\t\tconst T tut = C[i + m];\n\t\t\tC[i + m] += e[i] - C[i] - C[i + m * 2];\n\t\t\tC[i + m * 2] += e[i + m] - tut - C[i + m * 3];\n\t\t}\n\t}\n};\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tCombinatorics::init();\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tn--;\n\tint ans = 0;\n\tFOR(i, 0, m + 1) a[i] = invFact[i];\n\tFOR(i, 0, k + 1) b[i] = invFact[i];\n\tKaratsuba::mult<(1 << 18)>(a, b, c);\n\t\t\n\tFOR(t, 0, m + k + 1)\t\t\n\t\tADD(ans, mult(fact[t], mult(c[t] % mod, mult(C(n + t, t), power(3, m + k - t)))));\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 21);\nconst int mod = (int)1e9 + 7;\nconst double PI = 4 * atan(1.0);\n\ninline void addmod(int& x, int y, int mod) { (x += y) >= mod && (x -= mod); }\ninline int mulmod(int x, int y, int mod) { return x * 1ll * y % mod; }\n\nstruct complex_base\n{\n\tdouble x, y;\n\tcomplex_base(double _x = 0, double _y = 0) { x = _x; y = _y; }\n\tfriend complex_base operator-(const complex_base &a, const complex_base &b) { return complex_base(a.x - b.x, a.y - b.y); }\n\tfriend complex_base operator+(const complex_base &a, const complex_base &b) { return complex_base(a.x + b.x, a.y + b.y); }\n\tfriend complex_base operator*(const complex_base &a, const complex_base &b) { return complex_base(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x); }\n\tfriend void operator/=(complex_base &a, const double &P) { a.x /= P; a.y /= P; }\n};\n\nint bit_rev[MAXN];\n\nvoid fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tdouble ang = 2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n}\n\nvoid inv_fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tdouble ang = -2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] /= n;\n}\n\ncomplex_base A[MAXN], B[MAXN];\n\nvector<int> mult(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() <= 128)\n\t{\n\t\tvector<int> ans(a.size() + b.size(), 0);\n\t\tfor(int i = 0; i < (int)a.size(); i++)\n\t\t\tfor(int j = 0; j < (int)b.size(); j++)\n\t\t\t\tans[i + j] = (ans[i + j] + a[i] * 1ll * b[j]) % mod;\n\n\t\treturn ans;\n\t}\n\n\tint lg = 0; while((1 << lg) < (int)(a.size() + b.size())) ++lg;\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = B[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = complex_base(a[i], 0);\n\tfor(int i = 0; i < (int)b.size(); i++) B[i] = complex_base(b[i], 0);\n\n\tfft(A, lg); fft(B, lg);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tA[i] = A[i] * B[i];\n\tinv_fft(A, lg);\n\n\tvector<int> ans(a.size() + b.size(), 0);\n\tfor(int i = 0; i < (int)ans.size(); i++)\n\t\tans[i] = (int64_t)(A[i].x + 0.5) % mod;\n\n\treturn ans;\n}\n\nvector<int> mult_mod(const vector<int> &a, const vector<int> &b)\n{\n\t/// Thanks pavel.savchenkov\n\n\t// a = a0 + sqrt(MOD) * a1\n\t// a = a0 + base * a1\n\tint base = (int)sqrtl(mod);\n\n\tvector<int> a0(a.size()), a1(a.size());\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t{\n\t\ta0[i] = a[i] % base;\n\t\ta1[i] = a[i] / base;\n\t}\n\n\tvector<int> b0(b.size()), b1(b.size());\n\tfor(int i = 0; i < (int)b.size(); i++)\n\t{\n\t\tb0[i] = b[i] % base;\n\t\tb1[i] = b[i] / base;\n\t}\n\n\tvector<int> a01 = a0;\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t\taddmod(a01[i], a1[i], mod);  \t\n\n\tvector<int> b01 = b0;\n\tfor(int i = 0; i < (int)b.size(); i++) \n\t\taddmod(b01[i], b1[i], mod);\n\n\tvector<int> C = mult(a01, b01);  // 1\n\tvector<int> a0b0 = mult(a0, b0); // 2\n\tvector<int> a1b1 = mult(a1, b1); // 3\n\n\tvector<int> mid = C;\n\tfor(int i = 0; i < (int)mid.size(); i++) \n\t{\n\t\taddmod(mid[i], -a0b0[i] + mod, mod);\n\t\taddmod(mid[i], -a1b1[i] + mod, mod);\n\t}\n\n\tvector<int> res = a0b0;\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, mid[i], mod), mod);\n\n\tbase = mulmod(base, base, mod);\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, a1b1[i], mod), mod);\n\n\treturn res;\n}\n\nint n, m, k;\n\nvoid read()\n{\n\tcin >> n >> m >> k;\n}\n\nvector<int> p1, p2, pw3;\n\nint pw(int x, int p)\n{\n\tint ret = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ret = (ret * 1ll * x) % mod;\n\t\tx = (x * 1ll * x) % mod;\n\t\tp >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint fact[MAXN], inv_fact[MAXN];\nint comb(int n, int k) { if(n < 0 || k < 0 || n < k) return 0; return (((fact[n] * 1ll * inv_fact[n - k]) % mod) * 1ll * inv_fact[k]) % mod; }\n\n/*   SUM C(n + i - 1, i) * C(n + i - 1 + j, j)   */\n/*   SUM C(n + i - 1, i) * fact[n + i - 1 + j] / (fact[j] * fact[n + i - 1])    */\n\n\nvoid solve()\n{\t\n\tpw3.assign(n + m + k + 1, 0);\n\tp1.assign(m + 1, 0);\n\tp2.assign(k + 1, 0);\n\tpw3[0] = 1; for(int i = 1; i <= m + k + n; i++) pw3[i] = (3ll * pw3[i - 1]) % mod;\n\tfact[0] = 1; for(int i = 1; i <= m + k + n; i++) fact[i] = (fact[i - 1] * 1ll * i) % mod;\n\tinv_fact[m + k + n] = pw(fact[m + k + n], mod - 2); for(int i = n + k + m - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * 1ll * (i + 1)) % mod; \n\n\tfor(int i = 0; i <= m; i++) p1[i] = (comb(n + i - 1, i) * 1ll * inv_fact[n + i - 1]) % mod;\n\tfor(int i = 0; i <= k; i++) p2[i] = inv_fact[i];\n\n\tvector<int> ret = mult_mod(p1, p2);\n\t\n\tint answer = 0;\n\tfor(int i = 0; i < (int)ret.size(); i++)\n\t{\n\t\tif(m + k - i < 0) break;\n\t\tint curr = (ret[i] * 1ll * pw3[m + k - i]) % mod;\n\t\tcurr = (curr * 1ll * fact[n - 1 + i]) % mod;\n\t\taddmod(answer, curr, mod);\n\t}\n\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define ll long long\nusing namespace std;\nconst int p = 1e9+7;\nconst int N = 1500010;\nint fac[N], inv[N], pwr[N];\ninline int qp(int x, int y) {\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (ll)x*x%p) if(y&1) res = (ll)res*x%p;\n\treturn res;\n}\ninline void init(int n) {\n\tfac[0] = pwr[0] = 1;\n\tfor(int i = 1; i <= n; i ++ ) fac[i] = (ll)i*fac[i-1]%p, pwr[i] = pwr[i-1]*(ll)3%p;\n\tinv[n] = qp(fac[n], p-2);\n\tfor(int i = n; i >= 1; i -- ) inv[i-1] = (ll)i*inv[i]%p;\n}\ninline ll c(int n, int m) {\n\tif(n < m) return 0;\n\treturn (ll)fac[n]*inv[m]%p*inv[n-m]%p;\n}\nint main() {\n\tint A, B, C; scanf(\"%d%d%d\", &A, &B, &C);\n\tinit(A+B+C); A -- ;\n\tif(C < B) swap(B, C);\n\tll now = 1, ans = 0;\n\tfor(int i = 0; i <= B+C; i ++ ) {\n\t\tans = (ans+c(A+i, A)*pwr[B+C-i]%p*now)%p;\n\t\tif(i < B) now = now*2%p;\n\t\telse if(i < C) now = (now*2-c(i, B))%p;\n\t\telse now = (now*2-c(i, B)-c(i, C))%p;\n\t}\n\tprintf(\"%lld\\n\", (ans+p)%p);\n\tgetchar(), getchar();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint const MOD = 1000000007;\n\nint const N = 1234567;\n\nint INV[N], FACT[N], INVFACT[N];\n\nint mul(int a, int b) {\n  return (int) ((long long) a * b % MOD);\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n}\n\nint c(int n, int k) {\n  return mul(FACT[n], mul(INVFACT[k], INVFACT[n - k]));\n}\n\nint get(int n, int a, int b) {\n  int ways = 0;\n  for (int i = 0; i <= a && i <= n; i++) {\n    if (n - i > b) continue;\n    add(ways, c(n, i));\n  }\n  return ways;\n}\n\nint main() {\n  FACT[0] = 1;\n  for (int i = 1; i < N; i++) FACT[i] = mul(FACT[i - 1], i);\n  INV[1] = 1;\n  for (int i = 2; i < N; i++) {\n    INV[i] = mul(INV[MOD % i], MOD - MOD / i);\n  }\n  INVFACT[0] = 1;\n  for (int i = 1; i < N; i++) {\n    INVFACT[i] = mul(INVFACT[i - 1], INV[i]);\n  }\n  int n, m, k;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  int three = 1;\n  int ans = 0;\n  for (int i = m + k; i >= 0; i--) {\n    int ways = mul(three, c(n + i - 1, n - 1));\n    ways = mul(ways, get(i, m, k));\n    add(ans, ways);\n    // printf(\"%d\\n\", ways);\n    three = mul(three, 3);\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int maxn(1e6 + 10), Mod(1e9 + 7);\nint N, M, K, ans, fac[maxn], inv[maxn], Pow[maxn];\nint C(int n, int m) { return 1ll * fac[n] * inv[m] % Mod * inv[n - m] % Mod; }\nint Minus(int x, int y) { return (x - y + Mod) % Mod; }\nint Add(int x, int y) { return (x + y) % Mod; }\nint Mul(int x, int y) { return 1ll * x * y % Mod; }\nint fastpow(int x, int y)\n{\n\tint ans = 1;\n\tfor (; y; y >>= 1, x = 1ll * x * x % Mod)\n\t\tif (y & 1) ans = 1ll * ans * x % Mod;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &K), fac[0] = inv[0] = Pow[0] = 1; if (M < K) std::swap(M, K);\n\tfor (int i = 1; i <= N + M + K; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tfor (int i = 1; i <= N + M + K; i++) Pow[i] = 1ll * Pow[i - 1] * 3 % Mod;\n\tinv[N + M + K] = fastpow(fac[N + M + K], Mod - 2);\n\tfor (int i = N + M + K - 1; i; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % Mod;\n\tfor (int i = 0, x = 1; i <= M + K; i++)\n\t{\n\t\tans = Add(ans, Mul(Mul(C(N + i - 1, N - 1), Pow[M + K - i]), x));\n\t\tif (i < K) x = (x + x) % Mod; else if (i < M) x = Minus((x + x) % Mod, C(i, K));\n\t\telse x = Minus(Minus((x + x) % Mod, C(i, K)), C(i, M));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n \nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n \nll inv[1000001], f[1000001], fi[1000001];\n\nll C(int N, int K) {\n\treturn f[N] * fi[K] % MOD * fi[N - K] % MOD;\n}\n\nll H(int N, int K) {\n\tif (K == 0) return !N;\n\treturn H(N + K - 1, K - 1);\n}\n\nint main() {\n\tinv[1] = 1;\n\tfor (int i = 2; i <= 1000000; i++)\n\t\tinv[i] = -MOD / i * inv[MOD % i] % MOD;\n\tf[0] = fi[0] = 1;\n\tfor (int i = 1; i <= 1000000; i++) {\n\t\tf[i] = f[i - 1] * i % MOD;\n\t\tfi[i] = fi[i - 1] * inv[i] % MOD;\n\t}\n\tvector<ll> p3(1000001);\n\tp3[0] = 1;\n\tfor (int i = 1; i <= 1000000; i++)\n\t\tp3[i] = p3[i - 1] * 3 % MOD;\n\tvector<ll> p2(1000001);\n\tp2[0] = 1;\n\tfor (int i = 1; i <= 1000000; i++)\n\t\tp2[i] = p2[i - 1] * 2 % MOD;\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tN++;\n\tif (M > L) swap(M, L);\n\tll ans = 0;\n\tll hoge = 0;\n\tfor (int k = 0; k <= M + L; k++) {\n\t\tll unko = 0;\n\t\tunko = (unko + p2[k]) % MOD;\n\t\thoge = hoge * 2 % MOD;\n\t\tif (k > M) hoge = (hoge + C(M + k - M - 1, k - M - 1)) % MOD;\n\t\tif (k > L) hoge = (hoge + C(L + k - L - 1, k - L - 1)) % MOD;\n\t\tunko = (unko - hoge) % MOD;\n\t\tans = (ans + unko * p3[M + L - k] % MOD * C(N - 2 + k, k)) % MOD;\n\t}\n\tcout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and must not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int Int;\n\ttypedef unsigned int UInt;\n\ttypedef long long Long;\n\ttypedef unsigned long long ULong;\n\npublic:\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](ULong exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(ULong exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic IntMod Permutation(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / IntMod::Fact(n - r);\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <uint32_t Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <uint32_t Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <uint32_t Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <uint32_t Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint A, B, C;\nMInt D[600007];\nint main() {\n\tcin >> A >> B >> C;\n\t--A;\n\n\tD[0] = 1;\n\tREP(i, 0, B + C) {\n\t\tD[i + 1] = D[i] * 3;\n\t}\n\n\tMInt sum = 0;\n\tMInt coeff = 1;\n\tREP(s, 0, B + C + 1) {\n\t\tsum += D[B + C - s] * MInt::Combi(A + s, A) * coeff;\n\n\t\tcoeff += coeff;\n\t\tMInt p = s >= B ? MInt::Combi(s, B) : 0;\n\t\tMInt q = s >= C ? MInt::Combi(s, C) : 0;\n\t\tcoeff -= p + q;\n\t}\n\n\tcout << sum << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < int(n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= int(m); --(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\n\nll powmod(ll x, ll y, ll p) { // O(log y)\n    assert (0 <= x and x < p);\n    assert (0 <= y);\n    ll z = 1;\n    for (ll i = 1; i <= y; i <<= 1) {\n        if (y & i) z = z * x % p;\n        x = x * x % p;\n    }\n    return z;\n}\nll inv(ll x, ll p) { // p must be a prime, O(log p)\n    assert ((x % p + p) % p != 0);\n    return powmod(x, p-2, p);\n}\ntemplate <int mod>\nint fact(int n) {\n    static vector<int> memo(1,1);\n    if (memo.size() <= n) {\n        int l = memo.size();\n        memo.resize(n+1);\n        repeat_from (i,l,n+1) memo[i] = memo[i-1] *(ll) i % mod;\n    }\n    return memo[n];\n}\ntemplate <int mod>\nint choose(int n, int r) { // O(n) at first time, otherwise O(\\log n)\n    if (n < r) return 0;\n    r = min(r, n - r);\n    return fact<mod>(n) *(ll) inv(fact<mod>(n-r), mod) % mod *(ll) inv(fact<mod>(r), mod) % mod;\n}\n\nconstexpr ll mod = 1e9+7;\nint main() {\n    int n, m, k; scanf(\"%d%d%d\", &n, &m, &k);\n    ll result = 0;\n    if (n == 0) {\n        result += powmod(3, m + k, mod);\n    } else {\n        repeat_from (l, n, n+m+k+1) {\n            ll x = choose<mod>(l-1, n-1);\n            ll y = 0;\n            repeat_from (i, max(0, l-n-k), min(l-n, m) + 1) {\n                y += choose<mod>(l-n, i);\n            }\n            y %= mod;\n            ll z = powmod(3, n+m+k-l, mod);\n            result += x * y % mod * z % mod;\n        }\n    }\n    result %= mod;\n    printf(\"%lld\\n\", result);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst LL MOD = 1e9 + 7;\nconst int N = 1e6;\n\nLL fct[N + 5], inv[N + 5];\n\nLL fast(LL A,LL B) {\n\tLL res = 1;\n\twhile(B) {\n\t\tif(B & 1) res = res * A % MOD;\n\t\tB /= 2;\n\t\tA = A * A % MOD;\n\t}\n\treturn res;\n}\n\nvoid pre() {\n\tfct[0] = 1;\n\tfor(int i = 1;i <= N;i++) fct[i] = fct[i-1] * i % MOD;\n\tinv[N] = fast(fct[N], MOD - 2);\n\tfor(int i = N - 1;i >= 0;i--) inv[i] = inv[i + 1] * (i + 1) % MOD;\n}\n\nLL combin(int n,int r) {\n\tif(n < r) return 0;\n\treturn fct[n] * inv[r] % MOD * inv[n - r] % MOD;\n}\n\nvoid hora(int tc) {\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tint space = m + k;\n\tLL tot = 0;\n\tfor(int i = 0;i <= m;i++) {\n\t\tfor(int j = 0;j <= k;j++) {\n\t\t\ttot += combin(n - 1 + i + j, n - 1) * combin(i + j, j) % MOD * fast(3, m + k - i - j) % MOD;\n\t\t\ttot %= MOD;\n\t\t}\n\t}\n\tcout<<tot<<endl;\n}\n\nint main(){\n\tpre();\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define lld long long\n#define pii pair<int,int>\n#define pll pair<lld,lld>\n#define pb push_back\n#define next nextt\n#define Inf 1000000000\n#define Linf 1000000000000000000LL\n#define Mod 1000000007\n\nusing namespace std;\n\nint N,M,K; lld ans;\nlld fact[900002],inv[900002],three[900002],two[900002];\n\nlld mul(lld x,lld y){\n\tif(y == 0) return 1;\n\tlld tmp = mul(x,y/2);\n\ttmp *= tmp; tmp %= Mod;\n\tif(y%2 == 1){\n\t\ttmp *= x;\n\t\ttmp %= Mod;\n\t}\n\treturn tmp;\n}\nlld comb(lld x,lld y){\n\treturn (fact[x]*inv[x-y]%Mod)*inv[y]%Mod;\n}\n\nint main(){\n   // freopen(\"input.txt\",\"r\",stdin);\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\tfact[0] = inv[0] = three[0] = two[0] = 1;\n\tfor(int i=1; i<=900000; i++){\n\t\tfact[i] = (fact[i-1]*i)%Mod;\n\t\tinv[i] = mul(fact[i],Mod-2);\n\t\tthree[i] = (three[i-1]*3)%Mod;\n\t\ttwo[i] = (two[i-1]*2)%Mod;\n\t}\n\tif(M < K) swap(M,K);\n\tlld t1,t2;\n\tfor(int i=0; i<=M+K; i++){\n\t\tlld tmp;\n\t\tif(i <= K) tmp = two[i];\n\t\telse if(i == M+1){\n\t\t\tt1 = t2 = 0;\n\t\t\tfor(int j=0; j<=i-K-1; j++){\n\t\t\t\tt1 += comb(i,j); t1 %= Mod;\n\t\t\t}\n\t\t\tfor(int j=0; j<=i-M-1; j++){\n\t\t\t\tt2 += comb(i,j); t2 %= Mod;\n\t\t\t}\n\t\t\ttmp = two[i]-(t1+t2);\n\t\t}else if(i > M){\n\t\t\tt1 = t1*2+comb(i-1,i-K-1); t1 %= Mod;\n\t\t\tt2 = t2*2+comb(i-1,i-M-1); t2 %= Mod;\n\t\t\ttmp = two[i]-(t1+t2);\n\t\t}else if(i == K+1){\n\t\t    t1 = 0;\n            for(int j=0; j<=i-K-1; j++){\n                t1 += comb(i,j);\n                t1 %= Mod;\n            }\n            tmp = two[i]-t1;\n\t\t}else{\n\t\t    t1 = t1*2+comb(i-1,i-K-1); t1 %= Mod;\n            tmp = two[i]-t1;\n\t\t}\n\n\t\ttmp *= comb(N-1+i,N-1); tmp %= Mod;\n\t\ttmp *= three[M+K-i]; tmp %= Mod;\n\t\tans += tmp; ans %= Mod;\n\t}\n\tif(ans < 0) ans += Mod;\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define N 1000010\n#define mo 1000000007ll\nint jc[N],ij[N],n,m,k,p3[N],ans;\nint c(int y,int x){\n\treturn jc[y]*ij[y-x]%mo*ij[x]%mo;\n}\nint qp(int x,int y){\n\tint r=1;\n\tfor(;y;y>>=1,x=x*x%mo)\n\t\tif(y&1)r=r*x%mo;\n\treturn r;\n}\nsigned main(){\n\tjc[0]=ij[0]=p3[0]=1;\n\tfor(int i=1;i<N;i++){\n\t\tjc[i]=jc[i-1]*i%mo;\n\t\tp3[i]=p3[i-1]*3%mo;\n\t}\n\tij[N-1]=qp(jc[N-1],mo-2);\n\tfor(int i=N-1;i;i--)\n\t\tij[i-1]=ij[i]*i%mo;\n\tcin>>n>>m>>k;\n\tn--;\n\tif(m<k)swap(m,k);\n\tint j=1;\n\tfor(int i=0;i<=m+k;i++){\n\t\tans=(ans+c(n+i,n)*p3[m+k-i]%mo*j%mo)%mo;\n\t\tif(i<k)j=j*2%mo;\n\t\telse if(i>=m)j=(j*2-c(i,k)-c(i,i-m)+mo)%mo;\n\t\telse j=(j*2-c(i,k))%mo;\n\t\tj=(j+2*mo)%mo;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\nconst long double eps = 1e-12;\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*2\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long mae[2000000];\nlong long gyaku[2000000];\nlong long powing(long long a, long long b) {\n\tlong long ans = 1;\n\twhile (b != 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tans *= a;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\ta *= a;\n\t\ta %= MAX_MOD;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\nlong long inv(long long now) {\n\treturn powing(now, MAX_MOD - 2LL);\n}\nlong long combination(long long a, long long b) {\n\tlong long ans = mae[a];\n\tans *= gyaku[a - b];\n\tans %= MAX_MOD;\n\tans *= gyaku[b];\n\tans %= MAX_MOD;\n\treturn ans;\n}\nint main() {\n\tlong long a, b, c;\n\tcin >> a >> b >> c;\n\tmae[0] = 1;\n\tgyaku[0] = 1;\n\tfor (long long i = 1; i <= a+b+c; ++i) {\n\t\tmae[i] = mae[i - 1] * i;\n\t\tmae[i] %= MAX_MOD;\n\t\tgyaku[i] = inv(mae[i]);\n\t}\n\tlong long ans = 0;\n\tfor (long long i = a; i <= a + (b) + (c); ++i) {\n\t\tlong long first_multiply = powing(3LL, a + b + c - i);\n\t\tfirst_multiply *= combination(i-1, a-1);\n\t\tfirst_multiply %= MAX_MOD;\n\t\tlong long second_multiply = 0;\n\t\tfor (long long q = 0; q <= b; ++q) {\n\t\t\tlong long geko = i - a - q;\n\t\t\tif (geko < 0) break;\n\t\t\tif (geko > c)continue;\n\t\t\tsecond_multiply += combination(i-a,q);\n\t\t\tsecond_multiply %= MAX_MOD;\n\t\t}\n\t\tans += first_multiply * second_multiply;\n\t\tans %= MAX_MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define p 1000000007\nint inv[300010];\nint fac[1000010];\nint p3[600010];\nint main(void){\n\tint n,m,k;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tp3[0]=1;\n\tfor (int i=1;i<=m+k;i++) p3[i]=3ll*p3[i-1]%p;\n\tint max=n;\n\tif (max<m) max=m;if (max<k) max=k;\n\tinv[1]=1;\n\tfor (int i=2;i<=max;i++){\n\t\tinv[i]=1ll*(p-p/i)*inv[p%i]%p;\n\t}\n\tinv[0]=1;\n\tfor (int i=1;i<=max;i++){\n\t\tinv[i]=1ll*inv[i-1]*inv[i]%p;\n\t}\n\tfac[0]=1;\n\tfor (int i=1;i<=m+n+k;i++){\n\t\tfac[i]=1ll*i*fac[i-1]%p;\n\t}\n\tlong long ans=0;\n\tfor (int x=0;x<=m;x++){\n\t\tfor (int y=0;y<=k;y++){\n\t\t\tans=(ans+1ll*fac[x+y+n-1]*inv[x]%p*inv[y]%p*inv[n-1]%p*p3[m+k-x-y]%p)%p;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 600010\n\nll inv[N], fact[N], ifact[N];\n \nvoid init_fact(ll n = N){\n    inv[1] = 1;\n    for(int i = 2; i < n; i++) inv[i] = inv[mod%i] * (mod - mod/i) % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfact[i] = (fact[i-1]*i)%mod;\n\t\tifact[i]=(ifact[i-1]*inv[i])%mod;\n\t}\n}\n\nll comb(ll a, ll b){\n\treturn fact[a+b]*ifact[a]%mod*ifact[b]%mod;\n}\n\nll comb_nk(ll n, ll k){\n\treturn comb(n-k, k);\n}\n\nll lcm(ll a, ll b){\n    return a/__gcd(a, b)*b;\n}\n\nll lambda(ll m){\n    ll res = 1;\n    if(m%8==0) m /= 2;\n    for(ll i = 2; i*i <= m; i++){\n        if(!(m%i)){\n            ll r = i-1;\n            m /= i;\n            while(!(m%i)){\n                m /= i;\n                r *= i;\n            }\n            res = lcm(res, r);\n        }\n    }\n    if(m>1) res = lcm(res, m-1);\n    return res;\n}\n\nll tot(ll m){\n\tll res = 1;\n\tfor(ll i = 2; i*i <= m; i++){\n\t\tif(!(m%i)){\n\t\t\tres *= i-1;\n\t\t\tm /= i;\n\t\t\twhile(!m%i){\n\t\t\t\tm /= i;\n\t\t\t\tres *= i;\n\t\t\t}\n\t\t}\n\t}\n\tif(m>1) res *= m-1;\n\treturn res;\n}\n\nll pow_mod(ll a, ll r, ll m){\n\tll x = 1;\n\twhile(r){\n\t\tif(r&1) (x*=a)%=m;\n\t\t(a*=a)%=m;\n\t\tr>>=1;\n\t}\n\treturn x;\n}\n\nint main(){\n\tll n, m, k;\n\tcin>>n>>m>>k;\n\tn--;\n\tinit_fact();\n\tll res = 0, s = 1;\n\trep(i, m+k+1){\n\t\tll r = comb(n, i);\n\t\t(r*=pow_mod(3, m+k-i, mod))%=mod;\n\t\t(res+=r*s)%=mod;\n\t\t(s*=2)%=mod;\n\t\tif(i>=m)\ts -= comb(m, i-m);\n\t\tif(i>=k) s -= comb(i-k, k);\n\t}\n\t(res+=mod)%=mod;\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define mod 1000000007\n#define N 1000010\nll fac[N],inv[N],ivf[N];\nvoid initmo(){\n    fac[0]=ivf[0]=inv[1]=1;\n    for(ll i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n}\nll C(ll n,ll k){\n    return fac[n]*ivf[n-k]%mod*ivf[k]%mod;\n}\nll po(ll x,ll y){\n    ll res=1;\n    for(;y;y>>=1){\n\tif(y&1)res=res*x%mod;\n\tx=x*x%mod;\n    }\n    return res;\n}\nint main(){\n    initmo();\n  ll a,b,c;cin>>a>>b>>c; if(a>N||b>N||c>N)return 0;\n  a--; if(b>c)swap(b,c);\n  ll ans=0,sum=1;\n  for(ll k=a;k<=a+b+c;k++){\n      ll cur=po(3,a+b+c-k)*C(k,a)%mod;\n      cur=cur*sum%mod;\n      ans=(ans+cur)%mod;\n      ll s=k-a;\n      sum=sum*2%mod;\n      if(b<=s)sum-=C(s,b);\n      if(c<=s)sum-=C(s,s-c);\n  }\n  if(ans<0)ans+=mod;\n  cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\nconst int mod = 1000000007;\n\nll mpow(ll x, ll n) {\n  ll res = 1;\n  while (n) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n /= 2;\n  }\n  return res;\n}\n\nvl fac(1000000, 1);\nvl invfac(fac.size(), 1);\n\nll bin (int k, int n) {\n  if (k < 0 || k > n) return 0;\n  return fac[n] * invfac[k] % mod * invfac[n-k] % mod;\n}\n\nint main() {\n  for (int i = 2; i < fac.size(); ++i) fac[i] = fac[i-1] * i % mod;\n  invfac.back() = mpow(fac.back(), mod - 2);\n  for (int i = fac.size() - 2; i > 0; --i) invfac[i] = invfac[i + 1] * (i+1) % mod;\n  int n,m,k;\n  while (cin >> n >> m >> k) {\n    ll sum = 0, res = 0;\n    for (int s = 0; s <= m + k; ++s) {\n      ll mul = mpow(3, m + k - s) * bin(s, s + n - 1) % mod;\n      sum = 0;\n      for (int i = max(0, s - k); i <= min(s, m); ++i) {\n        sum = (sum + bin(i, s)) % mod;\n      }\n      res = (res + mul * sum) % mod;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef ONLINE_JUDGE\n#define freopen \\\n  if (0) freopen\n#define cerr \\\n  if (0) cerr\n#endif\n\n#define fi first\n#define se second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n\n#define sqr(a) ((a)*1ll * (a))\n#define sz(a) (int)a.size()\n#define len(a) (int)a.length()\n#define all(a) a.begin(), a.end()\n#define nl '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nvector<int> fact;\n\nint powm(int n, int p) {\n  int res = 1;\n  while (p > 0) {\n    if (p & 1) \n      res = (res * 1ll * n) % mod;\n    p >>= 1;\n    n = (n * 1ll * n) % mod;\n  }\n  return res;\n}\n\nint inv(int n) {\n  return powm(n, mod - 2);\n}\n\nint binom(int n, int k) {\n  return (fact[n] * 1ll * inv((fact[k] * 1ll * fact[n - k]) % mod)) % mod;\n}\n\nvoid solve() {\n  fact.resize(1e6);\n  fact[0] = 1;\n  rep(i, 1, 1e6) {\n    fact[i] = (fact[i - 1] * 1ll * i) % mod;\n  }\n\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  int l = n + m + k;\n  int res = 0;\n  rep(i, n, l) {\n    int sum = 0;\n    rep(j, 0, min(i - n, m)) {\n      if (i - n - j <= k) {\n        sum += binom(i - n, j);\n        sum %= mod;\n      }\n    }\n    int temp = (sum * 1ll * binom(i - 1, n - 1)) % mod;\n    res += (temp * 1ll * powm(3, l - i)) % mod;\n    res %= mod;\n  }\n\n  cout << res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  freopen(\".in\", \"r\", stdin);\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nll invmod(ll x) {\n  ll e = mod - 2;\n  ll sum = 1;\n  ll cur = x;\n  while (e > 0) {\n    if (e % 2 == 1) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\nconst int N = 600100;\nll fact[N];\nll pow3[N];\n\nll comb(ll x, ll y) {\n  ll ret = fact[x];\n  ret *= invmod(fact[y]);\n  ret %= mod;\n  ret *= invmod(fact[x - y]);\n  return ret % mod;\n}\n\nint main(void){\n  int n, m, k;\n  cin >> n >> m >> k;\n  fact[0] = 1;\n  pow3[0] = 1;\n  REP(i, 1, N) {\n    fact[i] = (fact[i - 1] * i) % mod;\n    pow3[i] = pow3[i - 1] * 3 % mod;\n  }\n  \n  // \\sum_{b', c'} fact(b' + c' + n - 1) / fact(b') / fact(c') / fact(n - 1) * 3^(m - b' + k - c')\n  // = \\sum_{d = 0}^{m + k} fact(d + n - 1) / fact(n - 1) / fact(d) \\sum_{b = max(0, d - k)}^{min(d, m)} C(d, b) 3^{m + k - d}\n  ll sum = 0;\n  ll cur = 1;\n  REP(d, 0, m + k + 1) {\n    ll tmp = fact[d + n - 1];\n    tmp *= invmod(fact[n - 1]);\n    tmp %= mod;\n    tmp *= invmod(fact[d]);\n    tmp %= mod;\n    tmp *= pow3[m + k - d];\n    tmp %= mod;\n    tmp *= cur;\n    sum += tmp;\n    sum %= mod;\n    cur *= 2;\n    if (d >= k) {\n      cur += mod - comb(d, d - k);\n    }\n    if (d >= m) {\n      cur += mod - comb(d, m);\n    }\n    cur %= mod;\n  }\n  cout << sum << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2) \n#include<bits/stdc++.h>\n#define rg register\n#define il inline\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7,O=1000010;\nint n,m,k;\nll fac[O],inv[O],bin[O],ans,x=1;\nil ll C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);n--;\n\tbin[0]=fac[0]=fac[1]=inv[0]=inv[1]=1ll;\n\tfor(int i=1;i<O;++i)bin[i]=bin[i-1]*3ll%mod;\n\tfor(int i=2;i<O;++i){\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tfor(int i=2;i<O;++i)inv[i]=inv[i-1]*inv[i]%mod;\n\tfor(int i=0;i<=m+k;++i){\n\t\t(ans+=C(n+i,n)*bin[m+k-i]%mod*x%mod)%=mod;\n//\t\tprintf(\"%lld %lld %lld %lld\\n\",C(n+i,n),bin[m+k-i],x,ans<0?ans+mod:ans);\n\t\tif(i<k)(x*=2ll)%=mod;\n        else if(i<m)x=((x*2ll-C(i,k))%mod+mod)%mod;\n        else x=((x*2ll-C(i,k)-C(i,m))%mod+mod)%mod;\n\t}\n\tans%=mod;\n\tprintf(\"%lld\",ans<0?ans+mod:ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate<class T = ll> constexpr T TEN(int n) {return (n==0)?1:10*TEN<T>(n-1);}\n\n\ntemplate<class T>\nT pow(T x, ll n) {\n    T r = 1;\n    while (n) {\n        if (n & 1) r *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return r;\n}\n\ntemplate<uint MD>\nstruct ModInt {\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll v) : v{normS(v%MD+MD)} {}\n    static uint normS(const uint &x) {return (x<MD)?x:x-MD;};\n    static ModInt make(const uint &x) {ModInt m; m.v = x; return m;}\n    ModInt operator+(const ModInt &r) const {return make(normS(v+r.v));}\n    ModInt operator-(const ModInt &r) const {return make(normS(v+MD-r.v));}\n    ModInt operator*(const ModInt &r) const {return make(ull(v)*r.v%MD);}\n    ModInt& operator+=(const ModInt &r) {return *this=*this+r;}\n    ModInt& operator-=(const ModInt &r) {return *this=*this-r;}\n    ModInt& operator*=(const ModInt &r) {return *this=*this*r;}\n    static ModInt inv(const ModInt &x) {\n        return pow(ModInt(x), MD-2);\n    }\n};\n\nusing Mint = ModInt<TEN(9)+7>;\nconst int MN = 900900;\nMint fact[MN], iFac[MN], p3[MN];\nvoid first() {\n    fact[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        fact[i] = fact[i-1]*i;\n    }\n    for (int i = 0; i < MN; i++) {\n        iFac[i] = Mint::inv(fact[i]);\n    }\n    p3[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        p3[i] = p3[i-1]*3;\n    }\n}\n\nMint C(int n, int k) {\n    if (n < k || k < 0) return 0;\n    return fact[n]*iFac[k]*iFac[n-k];\n}\n\nMint buf[MN];\nint main() {\n    first();\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k); n--;\n\n    buf[0] = 1;\n    for (int i = 1; i <= m+k; i++) {\n        buf[i] = buf[i-1]*2;\n        if (i-1 >= m) {\n            buf[i] -= C(i-1, m);\n        }\n        if (i-1 >= k) {\n            buf[i] -= C(i-1, k);\n        }\n    }\n    Mint ans = 0;\n    for (int i = 0; i <= m+k; i++) {\n        Mint res = p3[m+k-i];\n        res *= C(n+i, n);\n        res *= buf[i];\n        ans += res;\n    }\n    printf(\"%d\\n\", ans.v);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst ll Mod=1e9+7;\nint n,m,k,N;\nll ans,fac[900005],inv[900005],er[900005],san[900005],b,c;\nll quipow(ll x,ll m)\n{\n    ll res=1;\n    while(m)\n    {\n        if(m&1) res=res*x%Mod;\n        x=x*x%Mod;\n        m>>=1;\n    }\n    return res;\n}\nll C(int y,int u)\n{\n    if(y>u) return 0;\n    return fac[u]*inv[y]%Mod*inv[u-y]%Mod;\n}\nint main()\n{\n    fac[0]=fac[1]=1;\n    for(ll i=2;i<=900000;i++) fac[i]=fac[i-1]*i%Mod;\n    inv[900000]=quipow(fac[900000],Mod-2);\n    for(ll i=899999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%Mod;\n    er[0]=1;\n    for(ll i=1;i<=300000;i++) er[i]=er[i-1]*2%Mod;\n    san[0]=1;\n    for(ll i=1;i<=300000;i++) san[i]=san[i-1]*3%Mod;\n    scanf(\"%d%d%d\",&n,&m,&k);N=n+m+k;\n    for(int i=n;i<=N;i++)\n    {\n        int la=i-n;\n        ll now=C(n-1,i-1),gg=er[la];\n        b=(b+(m+1==la?1:(m+1<la?(b+C(i-n-m-1,i-n-1)):0)))%Mod;\n        c=(c+(k+1==la?1:(k+1<la?(c+C(i-n-k-1,i-n-1)):0)))%Mod;\n        gg=(gg-b+Mod)%Mod;gg=(gg-c+Mod)%Mod;\n        ans=(ans+now*gg%Mod*san[N-i]%Mod)%Mod;\n    }\n    printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int MD = 1e9+7;\nstruct Mint {\n    typedef Mint M;\n    int v;\n    Mint(int _v = 0) : v(_v) {}\n    M& operator += (const M &r) {\n        if ((v += r.v) >= MD) v -= MD;\n        return *this;\n    }\n    M& operator -= (const M &r) {\n        if ((v -= r.v) < 0) v += MD;\n        return *this;\n    }\n    M& operator *= (const M &r) {\n        v = ll(v)*r.v%MD;\n        return *this;\n    }\n    M operator + (const M &r) const { return M(*this) += r; }\n    M operator - (const M &r) const { return M(*this) -= r; }\n    M operator * (const M &r) const { return M(*this) *= r; }\n    M pow(int n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n&1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return this->pow(MD-2); }\n};\n\nconst int B = 999999;\nint N, M, K;\nMint fac[B], ifac[B];\n\nMint C(int n, int m) {\n    if (n < 0 || m < 0 || n < m) return Mint(0);\n    return fac[n]*ifac[m]*ifac[n-m];\n}\n\nvoid first() {\n    fac[0] = 1;\n    for (int i = 1; i < B; i++) fac[i] = fac[i-1]*Mint(i);\n    ifac[B-1] = fac[B-1].inv();\n    for (int i = B-2; i >= 0; i--) ifac[i] = ifac[i+1]*Mint(i+1);\n}\n\nint main() {\n    first();\n    cin >> N >> M >> K;\n    if (M > K) swap(M, K);\n\n    Mint ans = 0;\n\n    for (int i = 0; i <= M; i++) {\n        ans += C(N-1+i, N-1) * Mint(2).pow(i) * Mint(3).pow(M+K-i);\n    }\n    Mint sm = Mint(2).pow(M);\n    for (int i = M+1; i <= M+K; i++) {\n        sm = Mint(2) * sm - C(i-1, M) + C(i-1, i-2-M) - C(i, i-1-M);\n        ans += C(N-1+i, N-1) * sm * Mint(3).pow(M+K-i);\n    }\n\n    cout << ans.v << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef ONLINE_JUDGE\n#define freopen \\\n  if (0) freopen\n#define cerr \\\n  if (0) cerr\n#endif\n\n#define fi first\n#define se second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n\n#define sqr(a) ((a)*1ll * (a))\n#define sz(a) (int)a.size()\n#define len(a) (int)a.length()\n#define all(a) a.begin(), a.end()\n#define nl '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nvector<int> fact;\n\nint powm(int n, int p) {\n  int res = 1;\n  while (p > 0) {\n    if (p & 1) \n      res = (res * 1ll * n) % mod;\n    p >>= 1;\n    n = (n * 1ll * n) % mod;\n  }\n  return res;\n}\n\nint inv(int n) {\n  return powm(n, mod - 2);\n}\n\nint binom(int n, int k) {\n  return (fact[n] * 1ll * inv((fact[k] * 1ll * fact[n - k]) % mod)) % mod;\n}\n\nvoid solve() {\n  fact.resize(1e6);\n  fact[0] = 1;\n  rep(i, 1, 1e6) {\n    fact[i] = (fact[i - 1] * 1ll * i) % mod;\n  }\n\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  int l = n + m + k;\n  int res = 0;\n  int l_sum = 0;\n  int r_sum = 0;\n  int row_sum = 1;\n  rep(i, n, l) {\n    int mid_sum = row_sum;\n    if (i - n - k > 0) {\n      int prev_left = max(0, i - 1 - n - k);\n      l_sum += binom(i - 1 - n, prev_left);\n      l_sum %= mod;\n      mid_sum = (mod + mid_sum) - l_sum;\n      mid_sum %= mod;\n    }\n    if (m < i - n) {\n      int prev_right = min(i - 1 - n, m);\n      r_sum += binom(i - 1 - n, prev_right);\n      r_sum %= mod;\n      mid_sum = (mod + mid_sum) - r_sum;\n      mid_sum %= mod;\n    }\n    int temp = (mid_sum * 1ll * binom(i - 1, n - 1)) % mod;\n    res += (temp * 1ll * powm(3, l - i)) % mod;\n    res %= mod;\n    row_sum = (row_sum * 1ll * 2) % mod;\n    l_sum = (l_sum * 1ll * 2) % mod;\n    r_sum = (r_sum * 1ll * 2) % mod;\n  }\n\n  cout << res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  freopen(\".in\", \"r\", stdin);\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define MOD 1000000007\nusing namespace std;\n\nint n, m, k;\n\nint quickPow(int n, int m) {\n\tint res = 1;\n\twhile (m) {\n\t\tif (m & 1) res = 1LL * res * n % MOD;\n\t\tm >>= 1;\n\t\tn = 1LL * n * n % MOD;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tif (m > k) swap(m, k);\n\tint ans = quickPow(3, m + k), tmp1 = 1, tmp2 = 1;\n\tfor (int p = n + 1, e, u = 1, v = 1; p <= n + m + k; ++p) {\n\t\te = quickPow(3, n + m + k - p);\n\t\tv = 1LL * v * (p - 1) % MOD * quickPow(p - n, MOD - 2) % MOD;\n\t\tif (p <= n + m) u = u * 2 % MOD;\n\t\telse if (p <= n + k) {\n\t\t\ttmp1 = p - n - 1 == m ? 1 : 1LL * tmp1 * (p - n - 1) % MOD * quickPow(p - n - m - 1, MOD - 2) % MOD;\n\t\t\tu = (2LL * u - tmp1 + MOD) % MOD;\n\t\t}\n\t\telse {\t\t\n\t\t\ttmp1 = p - n - 1 == m ? 1 : 1LL * tmp1 * (p - n - 1) % MOD * quickPow(p - n - m - 1, MOD - 2) % MOD;\n\t\t\ttmp2 = p == (1 + n + k) ? 1 : 1LL * tmp2 * (p - 1 - n) % MOD * quickPow(p - n - 1 - k, MOD - 2) % MOD;\n\t\t\tu = (2LL * u - tmp1 - tmp2 + MOD + MOD) % MOD;\n\t\t}\n\t\tans = (ans + 1LL * e * v % MOD * u % MOD) % MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,k;\nlong long inv[900010],fac[900010],p[900010],ans;\nconst long long mod=1e9+7;\ninline long long ksm(long long x,long long y)\n{\n\tlong long res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\tres=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t} \n\treturn res;\n}\ninline long long c(int x,int y)\n{\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tp[0]=1ll;\n\tfac[0]=1ll;\n\tinv[0]=1ll;\n\tfor(int i=1;i<=9e5;++i)\n\t{\n\t\tp[i]=p[i-1]*3ll%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tinv[900000]=ksm(fac[900000],mod-2);\n\tfor(int i=9e5-1;i>=1;--i)\n\tinv[i]=inv[i+1]*(long long)(i+1)%mod;\n\tlong long x=1;\n\t--n;\n\tfor(int i=0;i<=m+k;++i)\n\t{\n\t\tans=(ans+c(n+i,n)*p[m+k-i]%mod*x)%mod;\n\t\tif(i<k)\n\t\tx=x*2ll%mod;\n\t\telse if(i<m)\n\t\tx=(x*2ll-c(i,k)+mod)%mod;\n\t\telse \n\t\tx=(x*2ll-c(i,k)-c(i,m)+mod+mod)%mod;\t\t\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define p 1000000007\n#define c(a,b) (1ll*fac[a]*inv[a-b]%p*inv[b]%p)\ntypedef int nlist[1000010];\nnlist fac,p2,p3,inv;\nint main(void){\n\tint n,m,k;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tp3[0]=p2[0]=1;\n\tint sum=n+m+k;\n\tfor (int i=1;i<=sum;i++) p3[i]=3ll*p3[i-1]%p,p2[i]=2ll*p2[i-1]%p;\n\tinv[1]=1;\n\tfor (int i=2;i<=sum;i++){\n\t\tinv[i]=1ll*(p-p/i)*inv[p%i]%p;\n\t}\n\tinv[0]=1;\n\tfor (int i=1;i<=sum;i++){\n\t\tinv[i]=1ll*inv[i-1]*inv[i]%p;\n\t}\n\tfac[0]=1;\n\tfor (int i=1;i<=sum;i++){\n\t\tfac[i]=1ll*i*fac[i-1]%p;\n\t}\n\tint  ans=0;\n\tif (m>k) {int t=m;m=k;k=t;} \n\tfor (int i=0;i<=m;i++){\n\t\tans=(ans+1ll*fac[n-1+i]*inv[n-1]%p*inv[i]%p*p3[m+k-i]%p*p2[i]%p)%p;\n\t}\n\tint s1=1,x1=1;\n\tfor (int i=m+1;i<=k;i++){\n\t\tint temp=(p2[i]-s1+p)%p;\n\t\tans=(ans+1ll*fac[n-1+i]*inv[n-1]%p*inv[i]%p*p3[m+k-i]%p*temp%p)%p;\n\t\ts1=(2ll*s1%p+c(i,x1))%p;\n\t\tx1++;\n\t}\n\tint s2=1,x2=1;\n\tfor (int i=k+1;i<=m+k;i++){\n\t\tint temp=(1ll*p2[i]-s1+p-s2+p)%p;\n\t\tans=(ans+1ll*fac[n-1+i]*inv[n-1]%p*inv[i]%p*p3[m+k-i]%p*temp%p)%p;\n\t\ts1=(2ll*s1%p+c(i,x1))%p;\n\t\ts2=(2ll*s2%p+c(i,x2))%p;\n\t\tx1++,x2++;\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2) \n#include<bits/stdc++.h>\n#define rg register\n#define il inline\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7,O=1000010;\nil int gi(){\n\trg int o=0,fl=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')fl=-1,ch=getchar();\n\twhile(isdigit(ch))o=o*10+ch-'0',ch=getchar();\n\treturn fl*o;\n}\nint n,m,k;\nll fac[O],inv[O],bin[O],ans,x=1;\nil ll C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);n--;\n\tbin[0]=fac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<O;++i)bin[i]=bin[i-1]*3%mod;\n\tfor(int i=2;i<O;++i){\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tfor(int i=2;i<O;++i)inv[i]=inv[i-1]*inv[i]%mod;\n\tfor(int i=0;i<=m+k;++i){\n\t\t(ans+=C(n+i,n)*bin[m+k-i]%mod*x%mod)%=mod;\n//\t\tprintf(\"%lld %lld %lld %lld\\n\",C(n+i,n),bin[m+k-i],x,ans<0?ans+mod:ans);\n\t\tif(i<k)(x*=2)%=mod;\n        else if(i<m)x=((x*2-C(i,k))%mod+mod)%mod;\n        else x=((x*2-C(i,k)-C(i,m))%mod+mod)%mod;\n\t}\n\tans%=mod;\n\tprintf(\"%lld\",ans<0?ans+mod:ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1e9+7;\n\nint n, m, k;\nll fac[900100];\nll inv[900100];\nll fnv[900100];\nll f[600100];\nll p[600100];\n\nll po(ll a, ll n) {\n    if (!n) return 1;\n    ll t = po(a,n/2);\n    return t*t%MOD*(n%2?a:1)%MOD;\n}\n\nll comb(ll n, ll r) {\n    if (r<0||r>n) return 0;\n    return fac[n]*fnv[r]%MOD*fnv[n-r]%MOD;\n}\n\nint main() {\n    int i;\n    scanf(\"%d%d%d\",&n,&m,&k);\n    fac[0] = 1; for (i=1;i<=n+m+k;i++) fac[i]=fac[i-1]*i%MOD;\n    inv[1] = 1; for (i=2;i<=n+m+k;i++) inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    fnv[0] = 1; for (i=1;i<=n+m+k;i++) fnv[i]=fnv[i-1]*inv[i]%MOD;\n    f[m+k] = comb(m+k,m); for (i=m+k-1;i>=0;i--) f[i] = (MOD+1)/2*(f[i+1]+comb(i,i-m)+comb(i,k))%MOD;\n    p[0] = 1; for (i=1;i<=m+k;i++) p[i]=p[i-1]*3%MOD;\n    ll ans = 0;\n    for (i=0;i<=m+k;i++) ans = ans+comb(n-1+i,n-1)*p[m+k-i]%MOD*f[i]%MOD;\n    printf(\"%lld\\n\",ans%MOD);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nconst int MX = 1000000;\nconst ll MOD = 1e9 + 7;\nll pw3[MX];\nll fc[MX];\nll bfc[MX];\nll dp[MX];\nll dp1[MX];\n\nll pw(ll a, ll b) {\n\tll ans = 1;\n\twhile (b) {\n\t\twhile (!(b & 1))\n\t\t\tb >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t}\n\treturn ans;\n}\n\nvoid init() {\n\tpw3[0] = 1;\n\tfor (int i = 1; i < MX; ++i)\n\t\tpw3[i] = (pw3[i - 1] * 3) % MOD;\n\tfc[0] = 1;\n\tfor (int i = 1; i < MX; ++i)\n\t\tfc[i] = (fc[i - 1] * i) % MOD;\n\tfor (int i = 0; i < MX; ++i)\n\t\tbfc[i] = pw(fc[i], MOD - 2);\n}\n\nll cnk(ll n, ll k) {\n\tif (k > n)\n\t\treturn 0;\n\treturn fc[n] * bfc[k] % MOD * bfc[n - k] % MOD;\n}\n\nint n, m, k;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tinit();\n\tdp1[0] = 1;\n\tfor (int i = 1; i <= m + k; ++i)\n\t\tdp1[i] = (dp1[i - 1] * 2) % MOD;\n\tfor (int i = 1; i <= m + k; ++i)\n\t\tdp[i] = (dp[i - 1] * 2 + cnk(i - 1, m) + cnk(i - 1, k)) % MOD;\n\tfor (int i = 0; i <= m + k; ++i)\n\t\tdp1[i] = (dp1[i] - dp[i] + MOD) % MOD;\n\tll ans = 0;\n\tfor (int i = 0; i <= m + k; ++i) {\n\t\tans += dp1[i] * pw3[m + k - i] % MOD * cnk(i + n - 1, n - 1) % MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int maxn(1e6 + 10), Mod(1e9 + 7);\nint N, M, K, ans, fac[maxn], inv[maxn], Pow[maxn];\nint C(int n, int m) { return 1ll * fac[n] * inv[m] % Mod * inv[n - m] % Mod; }\nint Minus(int x, int y) { return (x - y + Mod) % Mod; }\nint fastpow(int x, int y)\n{\n\tint ans = 1;\n\tfor (; y; y >>= 1, x = 1ll * x * x % Mod)\n\t\tif (y & 1) ans = 1ll * ans * x % Mod;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &K), fac[0] = inv[0] = Pow[0] = 1;\n\tfor (int i = 1; i <= N + M + K; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tfor (int i = 1; i <= N + M + K; i++) Pow[i] = 1ll * Pow[i - 1] * 3 % Mod;\n\tinv[N + M + K] = fastpow(fac[N + M + K], Mod - 2);\n\tfor (int i = N + M + K - 1; i; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % Mod;\n\tfor (int i = 0, x = 1; i <= M + K; i++)\n\t{\n\t\tans = (ans + 1ll * C(N + i - 1, N - 1) * Pow[M + K - i] % Mod * x) % Mod;\n\t\tif (i < K) x = (x + x) % Mod; else if (i < M) x = Minus((x + x) % Mod, C(i, K));\n\t\telse x = Minus(Minus((x + x) % Mod, C(i, K)), C(i, M));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<list>\n#include<set>\n#include<string>\n#include <iomanip>\n#include<math.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll M = 1000000007;\n\nvector<ll> fac(1000001); //n!(mod M)\nvector<ll> ifac(1000001); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n) {\n\tll ans = 1;\n\twhile (n != 0) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb() {\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 1000000; i++) {\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n\tifac[1000000] = mpow(fac[1000000], M - 2);\n\tfor (ll i = 1000000; i > 0; i--) {\n\t\tifac[i - 1] = ifac[i] * i%M;\n\t}\n}\nll comb(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a) {\n\tlong long b = M, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0) u += M;\n\treturn u;\n}\n\nstruct Mo\n{\n  vector< int > left, right, order;\n  vector< bool > v;\n  int width;\n  int nl, nr, ptr;\n\n  Mo(int n) : width((int) sqrt(n)), nl(0), nr(0), ptr(0), v(n) {}\n\n  void insert(int l, int r) /* [l, r) */\n  {\n    left.push_back(l);\n    right.push_back(r);\n  }\n\n  /* ソート */\n  void build()\n  {\n    for(int i=0;i<left.size();i++)\n\t\torder.push_back(i);\n    sort(begin(order), end(order), [&](int a, int b)\n    {\n      if(left[a] / width != left[b] / width) return left[a] < left[b];\n      return bool((right[a] < right[b])^(left[a]/width%2));\n    });\n  }\n\n  /* クエリを 1 つぶんすすめて, クエリのidを返す */\n  int process()\n  {\n    if(ptr == order.size()) return (-1);\n    const auto id = order[ptr];\n    while(nl > left[id]) ldistribute(--nl,nr);\n    while(nr < right[id]) rdistribute(nr++,nl);\n    while(nl < left[id]) ldistribute(nl++,nr);\n    while(nr > right[id]) rdistribute(--nr,nl);\n    return (order[ptr++]);\n  }\n\n  inline void ldistribute(int l,int r)\n  {\n    v[l].flip();\n    if(v[l]) ladd(r,l);\n    else ldel(r,l);\n  }\n\n  inline void rdistribute(int r,int l)\n  {\n    v[r].flip();\n    if(v[r]) radd(r,l);\n    else rdel(r,l);\n  }\n\n  void ladd(int n,int k);\n\n  void radd(int n,int b);\n  \n  void ldel(int n,int k);\n  \n  void rdel(int n,int b);\n};\n\nll sum=1;\n\nvoid Mo::ladd(int n,int k){\n\tsum+=M-comb(n,k+1);\n\tsum%=M;\n}\n\nvoid Mo::ldel(int n,int k){\n\tsum+=comb(n,k+1);\n\tsum%=M;\n}\n\nvoid Mo::radd(int n,int b){\n\tsum*=2;\n\tsum+=M-comb(n,b);\n\tsum%=M;\n}\n\nvoid Mo::rdel(int n,int b){\n\tsum+=comb(n,b);\n\tsum*=ifac[2];\n\tsum%=M;\n}\n\nint main(){\n\tsetcomb();\n\tll n,m,k,val[1222222],ans=0,i,zero=0;\n\tcin>>n>>m>>k;\n\tMo mo(m+k+1);\n\tfor(i=0;i<(m+k+1)*2;i++)\n\t\tval[i]=1;\n\tfor(i=0;i<=m+k;i++){\n\t\tll bot=m-min(m,i),top=m-max(zero,i-k);\n\t\tmo.insert(top,m+k-i);\n\t\tif(bot==0){\n\t\t\tval[i*2+1]=0;\n\t\t\tmo.insert(0,0);\n\t\t}\n\t\telse{\n\t\t\tmo.insert(bot-1,m+k-i);\n\t\t}\n\t}\n\tmo.build();\n\tfor(i=0;i<(m+k+1)*2;i++){\n\t\tll idx=mo.process();\n\t\tif(val[idx])\n\t\t\tval[idx]=sum;\n\t}\n\tfor(i=0;i<=m+k;i++){\n\t\tll p=mpow(3,i);\n\t\tp*=comb(n-1+m+k-i,n-1);\n\t\tp%=M;\n\t\tp*=(M+val[i*2]-val[i*2+1])%M;\n\t\tp%=M;\n\t\tans+=p;\n\t\tans%=M;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i,x,n) for (int i = x;i < n;++i)\n\nint ch[3001][3001], p[3001];\n\nint main() {\n\tint n, m, k, md = 1e9 + 7;\n\tp[0] = 1;\n\tch[0][0] = 1;\n\tf(i, 1, 3001) {\n\t\tch[i][0] = 1;\n\t\tf(j, 1, i + 1) {\n\t\t\tch[i][j] = ch[i - 1][j] + ch[i - 1][j - 1];\n\t\t\tif (ch[i][j] >= md)ch[i][j] -= md;\n\t\t}\n\t\tp[i] = (ll)p[i - 1] * 3 % md;\n\t}\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tassert(n <= 1000 && m <= 1000 && k <= 1000);\n\tint s = m + k, an = 0;\n\tf(i, 0, s + 1)f(j, 0, m + 1) {\n\t\tif (j > i)break;\n\t\tint l = i - j;\n\t\tif (l > k)continue;\n\t\tint d = p[s - i];\n\t\td = (ll)d*ch[n - 1 + i][i] % md*ch[i][j] % md;\n\t\tan += d;\n\t\tif (an >= md)an -= md;\n\t}\n\tprintf(\"%d\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//T+N\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate<class T, class T2> inline bool chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline bool chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst ll mod = 1e9 + 7;\ntemplate<class T> inline void fix(T &x) {if(x >= mod | x <= -mod) {x %= mod;} if(x < 0) {x += mod;}}\n#define out(x) cout << __LINE__ << \": \" << (#x) << \" = \" << (x) << endl\n\nconst ll MAX_N = 1e6 + 10;\nll perm[MAX_N], inv[MAX_N];\n\nll fpow(ll x, ll p) {\n    if(p == 0) {return 1;}\n    ll ans = fpow(x, p / 2);\n    ans = (ans * ans ) % mod;\n    if(p & 1) {\n        return (ans * x) % mod;\n    } else {\n        return ans;\n    }\n}\n\nll comb(ll k, ll n) {\n    if(k < 0 || n < 0) {return 0;}\n    if(n - k < 0) {return 0;}\n    return (((perm[n] * inv[n - k]) % mod) * inv[k]) % mod;\n}\n\nsigned main() {\n    //ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    perm[0] = inv[0] = 1;\n    for(ll i = 1; i < MAX_N; i ++) {\n        perm[i] = (perm[i - 1] * i) % mod;\n        inv[i] = (inv[i - 1] * fpow(i, mod - 2)) % mod;\n    }\n    ll n, m, k;\n    cin >> n >> m >> k;\n    ll rangel = 0, ranger = 0;\n    ll sum = 1;\n    ll ans = 0;\n    m ++;\n    k ++;\n    for(ll ij = 0; ij <= m + k - 2; ij ++) {\n        ll nwl = max(0ll, ij - k + 1);\n        ll nwr = min(m - 1, ij);\n        while(nwl < rangel) {\n            sum = (sum + comb(rangel - 1, ij)) % mod;\n            rangel --;\n        }\n        while(nwl > rangel) {\n            sum = (sum - comb(rangel, ij)) % mod;\n            rangel ++;\n        }\n        while(nwr > ranger) {\n            sum = (sum + comb(ranger + 1, ij)) % mod;\n            ranger ++;\n        }\n        while(nwr < ranger) {\n            sum = (sum - comb(ranger, ij)) % mod;\n            ranger --;\n        }\n        ll sum2 = 0;\n        for(ll i = nwl; i <= nwr; i ++) {\n            sum2 += comb(i, ij) ;\n        }\n        fix(sum);\n        ans += ((comb(n - 1, n - 1 + ij) * sum) % mod) * fpow(3, m + k - 2 - ij);\n        fix(ans);\n        sum = (sum * 2) % mod;\n        sum += comb(ranger + 1, ij) + comb(rangel - 1, ij);\n        sum %= mod;\n        ranger ++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n// Problem: \n// \t\t\tF - Card Game for Three\n// \t\t\tEditorial\n// \t\t\n// Contest: AtCoder - AtCoder Regular Contest 061\n// URL: https://atcoder.jp/contests/arc061/tasks/arc061_d?lang=en\n// Memory Limit: 256 MB\n// Time Limit: 3000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")\n//\n//#include <immintrin.h>\n//#include <emmintrin.h>\n\n#include <bits/stdc++.h>\n//#pragma GCC optimize(\"O2\")\n#define vi vector<int>\n#define pii pair<int, int >\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define LL long long\n#define rep(i,a,n) for (int i=a;i<=n;i++)\n#define per(i,a,n) for (int i=n;i>=a;i--)\n#define all(x) (x).begin(), (x).end()\n#define all2(x,n) (x+1), (x+1+n)\n#define sz(x) ((int)(x).size())\n#define mod(x) ((x)%MOD)\n#define debug(x) cerr<<#x<<\" : \"<<x<<endl\n#define mt make_tuple\n#define eb emplace_back\n#define o(X) (1<<(X))\n#define oL(X) (1LL<<(X))\n#define contain(S,X) (((S)&o(X))!=0)\n#define containL(S,X) (((S)&oL(X))!=0)\n#define ppt(x) __builtin_popcount(x)\nusing namespace std;\nconst int INF=0x3f3f3f3f,N=1e6+5,MOD=1e9+7;\nconst LL INF_LL=0x3f3f3f3f3f3f3f3fLL;\ninline int getplc(int x,int y) { return (x>>y)&1; }\ntemplate<typename T>\nT square(T x) {return x*x;}\nLL qpow(LL a,LL b=MOD-2,LL _MOD=MOD){\n\tLL res=1;\n\tfor(;b;b>>=1,a=a*a%_MOD){\n\t\tif(b&1)res=res*a%_MOD;\n\t}\n\treturn res;\n}\n// Smax\n//int Smax() { return -INF; }\ntemplate <typename T>\nT Smax(T x) { return x; }\ntemplate<typename T, typename... Args>\nT Smax(T a, Args... args) { return max(a, Smax(args...)); }\n// Smin\ntemplate <typename T>\nT Smin(T x) { return x; }\ntemplate<typename T, typename... Args>\nT Smin(T a, Args... args) { return min(a, Smin(args...)); }\ntemplate <typename T>\n// erro\n#define errorl(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); errl(_it, args); }\n\nvoid errl(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid errl(istream_iterator<string> it, T a, Args... args) {\n\tcerr << *it << \" = \" << a << endl;\n\terrl(++it, args...);\n}\n\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); cerr<<endl;}\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n\tcerr << *it << \"=\" << a << \" # \";\n\terr(++it, args...);\n}\nvoid Solve();\nint main() {\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\",\"r\",stdin);\n//    freopen(\"o1.txt\",\"w\",stdout);\n#endif\n\tios::sync_with_stdio(false);cin.tie(0),cout.tie(0);\n\tSolve();\n\treturn 0;\n}\n\n//////////////////////////////////////////////////////////////////\n\nint fac[N],inv[N];\nvoid init(int n){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=(LL)fac[i-1]*i%MOD;\n\tfor(int i=1;i<=n;i++)inv[i]=qpow(fac[i],MOD-2,MOD);\n}\nint Comb(int n,int m){\n\tif(n-m>=0&&m>=0) return 1ll*fac[n]*inv[n-m]%MOD*inv[m]%MOD;\n\telse return 0;\n}\n\nint pow3[N];\nvoid Solve(){\n  pow3[0]=1;\n  rep(i,1,N-1)pow3[i]=(LL)pow3[i-1]*3%MOD;\n  init(1e6+5);\n  \n  int n,m,k;\n  cin>>n>>m>>k;\n  if(m<k)swap(m,k);\n  n--;\n  \n  LL j=1,ans=0;\n  for(int i=0;i<=m+k;i++){\n    ans=(ans+(LL)Comb(n+i,n)*pow3[m+k-i]%MOD*j)%MOD;\n    if(i<k)\n        j=j*2ll%MOD;\n    else if(i<m)\n        j=(j*2ll-Comb(i,k))%MOD;\n    else    \n        j=(j*2ll-Comb(i,k)-Comb(i,m))%MOD;\n  }\n  ans=(ans+MOD)%MOD;\n  cout<<ans<<endl;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\n\nll mod_pow(ll x, ll p, ll MOD) {\n    ll a = 1;\n    while (p) {\n        if (p%2) a = a*x%MOD;\n        x = x*x%MOD;\n        p/=2;\n    }\n    return a;\n}\n\n// mod_inverse\nll mod_inverse(ll a, ll m) {\n    return mod_pow(a, m-2, m);\n}\n\nconst int MOD = 1e9+7;\nconst int MAX = 1000000;\nll fact[MAX], rfact[MAX];\nll p3[MAX];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    fact[0] = rfact[0] = 1;\n    for (int i = 1; i < MAX; i++) {\n        fact[i] = i*fact[i-1]%MOD;\n        rfact[i] = mod_inverse(fact[i], MOD);\n    }\n    p3[0] = 1;\n    for (int i = 1; i < MAX; i++) {\n        p3[i] = p3[i-1]*3%MOD;\n    }\n    int N, M, K;\n    cin >> N >> M >> K;\n    if (N > 1000 || M > 1000 || K > 1000) return 0;\n    ll ans = 0;\n    for (int m = 0; m <= M; m++) {\n        for (int k = 0; k <= K; k++) {\n            ll tmp = fact[N-1+m+k];\n            (tmp *= rfact[N-1])%=MOD;\n            (tmp *= rfact[m])%=MOD;\n            (tmp *= rfact[k])%=MOD;\n            (tmp *= p3[M+K-m-k])%=MOD;\n            (ans += tmp) %= MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x7fffffff\n#define RG register\n#define maxn 1000005\n#define maxm 205\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\ninline ll read(){\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while(ch > '9' || ch < '0') {if(ch == '-') f = -1;ch = getchar();}\n    while(ch >= '0' && ch <= '9'){x = x *10 + ch -'0';ch = getchar();}\n    return x * f;\n}\n \nint n, m, k, po[2][maxn];\nint qpow(int a, int b){\n\tint ans = 1, base = a;\n\twhile(b){\n\t\tif(b & 1) ans = 1ll * ans * base % mod;\n\t\tbase= 1ll * base * base % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nint fac[maxn], inv[maxn], ans;\nint C(int n, int m){return 1ll * fac[n] * inv[m] % mod *inv[n - m] % mod;}\nint main(){\n\tint i, j, x, l, r, mid;\n\tfac[0] = po[0][0] = po[1][0] = 1;\n\tfor(i = 1;i <= maxn - 5;i++) fac[i] = 1ll * fac[i - 1] * i % mod, po[0][i] = po[0][i - 1] * 2ll % mod, po[1][i] = po[1][i - 1] * 3ll % mod;\n\tinv[maxn - 5] = qpow(fac[maxn - 5], mod - 2);\n\tfor(i = maxn - 6;i >= 0;i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; \n\tn = read(), m = read(), k = read();\n\tint las = 1;\n\tfor(i = 0;i <= m + k;i++){\n\t\tans = (ans + 1ll * C(n + i - 1, n - 1) * po[1][m + k -i] % mod * las % mod) % mod;\n\t\tif(i + 1 <= m && i + 1 <= k) las = las * 2ll % mod;\n\t\telse{\n\t\t\tif(i + 1 <= k) las = ((las * 2ll - C(i, m)) % mod + mod) % mod; \n\t\t\telse if(i + 1 <= m) las = ((las * 2ll - C(i, i - k)) % mod + mod) % mod;\n\t\t\telse las = ((las * 2ll - C(i, i - k)) % mod + mod - C(i, m) ) % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long FACT[1000000];\nlong long IFACT[1000000];\n\nstatic int MOD = 1000000007;\nstatic int mod = MOD;\nint modPow(long a, long b) {\n if(b == 0) return 1 % MOD;\n if(b == 1) return (int) (a % MOD);\n\n if(b % 2 == 0) {\n\t long ret = modPow(a % MOD,b / 2) % MOD;\n\t return (int)((ret * ret) % MOD);\n }\n else {\n\t long ret = (a * (long)modPow(a % MOD,b-1)) % MOD;\n\t return (int)(ret % MOD);\n }\n}\n\n\n\n\tlong long C(int n, int r)\n\t{\n\t\tif(n < 0 || r < 0 || r > n)return 0;\n\t\tif(r > n / 2)r = n - r;\n\t\treturn FACT[n]*IFACT[n-r]%mod*IFACT[r]%mod;\n\t}\n\n\tlong long INV(long v) {\n\t\treturn modPow(v, MOD - 2);\n\t}\n\n\n\nint main() {\n\tint N,M,K,n;\n\tcin >> N >> M >> K;\n\t\tn = N + M + K;\n\n\t\tFACT[0] = 1;\n\t\tIFACT[0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tFACT[i] = ((FACT[i-1] % MOD) * i) % mod;\n\t\t\tIFACT[i] = INV(FACT[i]) % MOD;\n\t\t}\n\t\tlong long ans = 0;\n\t\tlong long hh = 0;\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tint retA = modPow(3,N + M + K - i) % MOD;\n\n\t\t\tint retB = (int)C(i-1,N-1) % MOD;\n\t\t\tlong long retC = 0;\n\t\t\tretC = (retC + modPow(2,i - N)) % MOD;\n\t\t\thh = hh * 2 % MOD;\n\t\t\tif (i - N > M) hh = (hh + C(M + i - N - M - 1, i - N - M - 1) % MOD) % MOD;\n\t\t\tif (i - N > K) hh = (hh + C(K + i - N - K - 1, i - N - K - 1) % MOD) % MOD;\n\t\t\tretC = (retC - hh) % MOD;\n\t\t\tlong ansA = ((long long)(retA) * (long long )(retB)) % MOD;\n\n\t\t\tansA *= retC % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define pb push_back\n\ntypedef long long ll;\nusing namespace std;\nint MOD (1e9+7);\nint powMod(int a, int n, int m){\n  ll pro = 1, tmp = a;\n  for(; n > 0; n >>= 1){\n    if(n & 1) pro = (pro * tmp) % m;\n    tmp = tmp * tmp % m;\n  }\n  if (pro < 0) cout << \"pro < 0\" << a << \",\" << n << endl;\n  return pro;\n}\n\nvector<int> A, R;\nint comb(int n, int c){\n  return int(ll(A[n + c]) * R[n] % MOD * R[c] % MOD);\n}\nmain(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int N, M, K;\n  cin >> N >> M >> K;\n\n  ll t = 1;\n  A.pb(1);\n  R.pb(1);\n  FOR(i, 1, N + M + K + 1){\n    t = t * i % MOD;\n    A.pb(t);\n    R.pb(powMod(t, MOD - 2, MOD));\n  }\n  int sum = M + K, p3 = powMod(3, sum, MOD), ret = p3, r3 = powMod(3, MOD - 2, MOD);\n  if(M > K) swap(M, K);\n  ll pre = 1;\n\n  FOR(i, 1, sum + 1){\n    pre *= 2;\n    p3 = ll(p3) * r3 % MOD;\n    if(i > M){\n      pre = pre + MOD - comb(M, i - M - 1);\n      if(i > K) pre = pre + MOD - comb(K, i - K - 1);\n    }\n    pre %= MOD;\n    ret += pre * comb(N - 1, i) % MOD * p3 % MOD;\n    ret %= MOD;\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define OUT(x)                cout << #x << \" = \" << x << endl; \n#define rep(i, n)             for (int (i) = 0; (i) < (int)(n); (i)++)\n#define rer(i, l, r)          for (int (i) = (int)(l); (i) <= (int)(r); (i)++)\n#define reu(i, l, r)          for (int (i) = (int)(l); (i) < (int)(r); (i)++)\n#define each(i, v)            for (auto i : v)\n#define all(x)                (x).begin(), (x).end()\n#define rall(x)               (x).rbegin(), (x).rend()\n#define pb(x)                 push_back(x)\n#define bp(x)                 __builtin_popcount(x)\n#define mp(x, y)              make_pair((x), (y))\n#define fi                    first\n#define se                    second\n#define setp(x)               setprecision(x)\n#define mset(m, v)            memset(m, v, sizeof(m))\n#define sz(x)                 (int)(x.size())\nstatic const int INF        = 0x3f3f3f3f;\nstatic const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD        = 1000000007;\nstatic const double PI      = 3.141592653589793238462643383279;\n\n#define int                   long long\n\ntypedef vector<double>        vd;\ntypedef vector<string>        vs;\ntypedef vector<bool>          vb;\ntypedef vector<int>           vi;\ntypedef pair<int, int>        pii;\ntypedef vector<pii>           vpii;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; i ++) cout << *i << \" \"; cout << endl; }\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\n//int in() { int _x; scanf(\"%d\", &_x); return _x; }\nlong long lin() {long long _x; scanf(\"%lld\", &_x); return _x; };\n\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n        long long d = a;\n        if (b != 0) {\n                d = extgcd(b, a % b, y, x);\n                y -= (a / b) * x;\n        } else {\n                x = 1;\n                y = 0;\n        }\n        return d;\n}\n\nlong long inv(long long a) {\n        long long x, y;\n        extgcd(a, MOD, x, y);\n        return (x % MOD + MOD) % MOD;\n}\n\nlong long nCr(long long n, long long r) {\n        if (n < r) return 0;\n        if (n - r < r) r = n - r;\n        long long ret = 1;\n        rep(i, r) {\n                ret *= n;\n                -- n;\n                ret %= MOD;\n                ret *= inv(i + 1);\n                ret %= MOD;\n        }\n        return ret;\n}\n\nlong long mod_pow(long long x, long long n) {\n        long long res = 1;\n        while (n > 0) {\n                if (n & 1) res = res * x % MOD;\n                x = x * x % MOD;\n                n >>= 1;\n        }\n        return res;\n}\n\nsigned main() { \n        int n, m, k;\n        cin >> n >> m >> k;\n        int ans = 0;\n        if (!n) ans += mod_pow(3, m + k);\n        else {\n                for (int i = n; i <= n + m + k; i ++) {\n                        int x = nCr(i - 1, n - 1);\n                        int y = 0;\n                        for (int j = max(0LL, i - n - k); j <= min(i - n, m); j ++) {\n                                y += nCr(i - n, j);\n                                y %= MOD;\n                        }\n                        int z = mod_pow(3, n + m + k - i);\n                        OUT(z);\n                        OUT(y);\n                        OUT(x);\n                        ans += x * y % MOD * z; \n                        ans %= MOD;\n                }\n        }\n        ans %= MOD;\n        cout << ans << endl;\n        return 0;\n}               \n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1))\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nclass modint {\n\t//MODが素数であることを前提として実装してあるが、その判定はしていない。\n\t//あまりが出るような除算をしてはいけない。\nprivate:\n\tstatic const int MOD = 1000000007;\npublic:\n\tmodint() {\n\t\t//assert(is_prime(MOD));\n\t\tthis->number = 0;\n\t}\n\tmodint(const int src) {\n\t\t//assert(is_prime(MOD));\n\t\tthis->number = opposit(src);\n\t}\n\tmodint(const modint &src) {\n\t\tthis->number = src.number;\n\t}\n\n\tmodint& operator += (const modint& obj) {\n\t\tthis->number = san2(this->number + obj.number);\n\t\treturn *this;\n\t}\n\tmodint& operator -= (const modint& obj) {\n\t\tthis->number = san2(this->number - obj.number + MOD);\n\t\treturn *this;\n\t}\n\tmodint& operator *= (const modint& obj) {\n\t\tthis->number = (this->number * obj.number) % MOD;\n\t\treturn *this;\n\t}\n\tmodint& operator /= (const modint& obj) {\n\t\tthis->number = (this->number * inverse(obj.number)) % MOD;\n\t\treturn *this;\n\t}\n\tmodint& operator += (const int n) {\n\t\tthis->number = san2(this->number + opposit(n));\n\t\treturn *this;\n\t}\n\tmodint& operator -= (const int n) {\n\t\tthis->number = san2(this->number - opposit(n) + MOD);\n\t\treturn *this;\n\t}\n\tmodint& operator *= (const int n) {\n\t\tthis->number = (this->number * opposit(n)) % MOD;\n\t\treturn *this;\n\t}\n\tmodint& operator /= (const int n) {\n\t\tthis->number = (this->number * inverse(n)) % MOD;\n\t\treturn *this;\n\t}\n\n\tmodint operator + (const modint obj) { modint re(*this); return re += obj; }\n\tmodint operator - (const modint obj) { modint re(*this); return re -= obj; }\n\tmodint operator * (const modint obj) { modint re(*this); return re *= obj; }\n\tmodint operator / (const modint obj) { modint re(*this); return re /= obj; }\n\tmodint operator + (const int n) { modint re(*this); return re += n; }\n\tmodint operator - (const int n) { modint re(*this); return re -= n; }\n\tmodint operator * (const int n) { modint re(*this); return re *= n; }\n\tmodint operator / (const int n) { modint re(*this); return re /= n; }\n\n\tmodint operator = (const int n) {\n\t\tthis->number = opposit(n);\n\t\treturn *this;\n\t}\n\tint get() {\n\t\treturn number;\n\t}\n\nprivate:\n\tint number;\n\n\tint opposit(int n) {\n\t\tif (n < 0)n = MOD - ((-n) % MOD);\n\t\treturn n % MOD;\n\t}\n\tint inverse(int n) {\n\t\tn = opposit(n);\n\t\tint result = 1;\n\t\tfor (int i = MOD - 2; i; i /= 2) {\n\t\t\tif (i % 2)result = (result * n) % MOD;\n\t\t\tn = (n * n) % MOD;\n\t\t}\n\t\treturn result;\n\t}\n\tinline int san2(const int n) {\n\t\treturn MOD <= n ? n - MOD : n;\n\t}\n\tbool is_prime(int n) {\n\t\tif (n <= 1)return false;\n\t\tif (n == 2)return true;\n\t\tif (n % 2 == 0) return false;\n\t\tconst int upperbound = int(sqrt(n));\n\t\tfor (int i = 3; i <= upperbound; i += 2) {\n\t\t\tif (n % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\nmodint power(modint n, int p) {\n\tmodint result = 1;\n\tfor (; p; p /= 2) {\n\t\tif (p % 2)result *= n;\n\t\tn *= n;\n\t}\n\treturn result;\n}\nmodint power(int n, int p) {\n\tmodint mn = n;\n\treturn power(mn, p);\n}\n\nstruct combi {\npublic:\n\tvector<modint>facto;\n\tcombi(const int N) :facto(N) {\n\t\tfacto[0] = 1;\n\t\tREP(i, 1, N)facto[i] = facto[i - 1] * i;\n\t}\n\tmodint get_combi(const int N, const int C) {\n\t\t//combination(N+C,C)を求めて返す。\n\t\tif (facto.size() <= N + C) {\n\t\t\tint a = facto.size();\n\t\t\tfacto.resize(N + C + 1);\n\t\t\tREP(i, a, N + C + 1)facto[i] = facto[i - 1] * i;\n\t\t}\n\t\treturn facto[N + C] / (facto[N] * facto[C]);\n\t}\n};\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcombi c(1000010);\n\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tif (M > K) swap(M, K);\n\n\tint sum = M + K;\n\tmodint pre = 1, p3 = power(3, sum), ans = p3;\n\n\tREP(i, 1, sum + 1) {\n\t\tpre *= 2;\n\t\tp3 /= 3;\n\t\tif (i > M) {\n\t\t\tpre -= c.get_combi(M, i - M - 1);\n\t\t\tif (i > K) pre -= c.get_combi(K, i - K - 1);\n\t\t}\n\t\tans += pre * c.get_combi(N - 1, i) * p3;\n\t}\n\n\tcout << ans.get() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\n#define LL long long\nusing namespace std;\nconst int N=9e5+10;\nconst LL mod=1e9+7;\nint n,m,k;\nLL fac[N]={1},inv[N]={1,1},pw[N]={1},ans,j=1;\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\ntemplate<typename I>inline void swp(I&a,I&b){a^=b; b^=a; a^=b;}\ninline LL C(int nn,int mm){return fac[nn]*inv[mm]%mod*inv[nn-mm]%mod;}\nint main()\n{\n//\tfreopen(\"Card Game for Three.in\",\"r\",stdin);\n\tread(n,m,k);\n\tif(k>m) swp(k,m);\n\tfor(RG int i=2;i<=n+k+m;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(RG int i=1;i<=n+k+m;i++) fac[i]=fac[i-1]*i%mod, (inv[i]*=inv[i-1])%=mod, pw[i]=pw[i-1]*3%mod;\n\tfor(RG int i=0;i<=m+k;i++)\n\t{\n\t\t(ans+=C(n+i-1,n-1)*pw[m+k-i]%mod*j%mod)%=mod;\n\t\tif(i<k) (j<<=1)%=mod;\n\t\telse if(i>=m) (j+=j-C(i,k)+mod-C(i,m)+mod)%=mod;\n\t\telse (j+=j-C(i,k)+mod)%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define lld long long\n#define pii pair<int,int>\n#define pll pair<lld,lld>\n#define pb push_back\n#define next nextt\n#define Inf 1000000000\n#define Linf 1000000000000000000LL\n#define Mod 1000000007\n\nusing namespace std;\n\nint N,M,K; lld ans;\nlld fact[900002],inv[900002],three[900002],two[900002];\n\nlld mul(lld x,lld y){\n\tif(y == 0) return 1;\n\tlld tmp = mul(x,y/2);\n\ttmp *= tmp; tmp %= Mod;\n\tif(y%2 == 1){\n\t\ttmp *= x;\n\t\ttmp %= Mod;\n\t}\n\treturn tmp;\n}\nlld comb(lld x,lld y){\n\treturn (fact[x]*inv[x-y]%Mod)*inv[y]%Mod;\n}\n\nint main(){\n    //freopen(\"input.txt\",\"r\",stdin);\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\tfact[0] = inv[0] = three[0] = two[0] = 1;\n\tfor(int i=1; i<=900000; i++){\n\t\tfact[i] = (fact[i-1]*i)%Mod;\n\t\tinv[i] = mul(fact[i],Mod-2);\n\t\tthree[i] = (three[i-1]*3)%Mod;\n\t\ttwo[i] = (two[i-1]*2)%Mod;\n\t}\n\tif(M < K) swap(M,K);\n\tlld t1,t2;\n\tfor(int i=0; i<=M+K; i++){\n\t\tlld tmp;\n\t\tif(i <= K) tmp = two[i];\n\t\telse if(i == M+1){\n\t\t\tt1 = t2 = 0;\n\t\t\tfor(int j=0; j<=i-K-1; j++){\n\t\t\t\tt1 += comb(i,j); t1 %= Mod;\n\t\t\t}\n\t\t\tfor(int j=0; j<=i-M-1; j++){\n\t\t\t\tt2 += comb(i,j); t2 %= Mod;\n\t\t\t}\n\t\t\ttmp = two[i]-(t1+t2);\n\t\t}else if(i > M){\n\t\t\tt1 = t1*2+comb(i-1,i-K-1); t1 %= Mod;\n\t\t\tt2 = t2*2+comb(i-1,i-M-1); t2 %= Mod;\n\t\t\ttmp = two[i]-(t1+t2);\n\t\t}else{\n            tmp = 0;\n\t\t\tfor(int j=max(0,i-K); j<=min(i,M); j++){\n\t\t\t\ttmp += comb(i,j);\n\t\t\t\ttmp %= Mod;\n\t\t\t}\n\t\t}\n\n\t\ttmp *= comb(N-1+i,N-1); tmp %= Mod;\n\t\ttmp *= three[M+K-i]; tmp %= Mod;\n\t\tans += tmp; ans %= Mod;\n\t}\n\tif(ans < 0) ans += Mod;\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int mod = 1e9 + 7;\n\nstruct ModCombination {\n  ModCombination(unsigned int n) : n(n), F(n + 1, 1), I(n + 1, 1) {\n    for (int i = 1; i <= n; ++i) F[i] = 1ll * i * F[i - 1] % mod;\n    for (int64_t i = mod - 2, j = F[n]; i; i >>= 1) {\n      if (i & 1) I[n] = I[n] * j % mod;\n      j = j * j % mod;\n    }\n    for (int i = n - 1; i; --i) I[i] = I[i + 1] * (i + 1ll) % mod;\n  }\n\n  unsigned int n;\n  vector<int> F, I;\n\n  int operator()(int p, int k) {\n    if (p > n) cerr << \"errored by ModCombination's operator()\";\n    if (k < 0 || k > p) return 0;\n    return 1ll * F[p] * I[k] % mod * I[p - k] % mod;\n  }\n};\n\nint mod_pow(int64_t a, int x) {\n  int64_t res = 1;\n  a %= mod;\n  for (int i = 1; i <= x; i <<= 1) {\n    if (i & x) (res *= a) %= mod;\n    (a *= a) %= mod;\n  }\n\n  return res;\n}\n\nint main() {\n  int N, M, K;\n  cin >> N >> M >> K;\n\n  ModCombination mC(N + M + K + 1);\n\n  int64_t ans = 0;\n  for (int m = 0; m <= M; ++m) {\n    for (int k = 0; k <= K; ++k) {\n      (ans += 1ll * mC(N + m + k - 1, m) * mC(N + k - 1, k) % mod * mod_pow(3, M - m + K - k) % mod) %= mod;\n    }\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <set>\n#include <functional>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <stack>\n#define SIZE 1000005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[SIZE],fac[SIZE],finv[SIZE];\nll rt[SIZE];\nvoid make()\n{\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<SIZE;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n\trt[0]=1;\n\tfor(int i=1;i<SIZE;i++) rt[i]=rt[i-1]*3LL%MOD;\n}\nll C(int a,int b)\n{\n\tif(b==0) return 1;\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nint main()\n{\n\tmake();\n\tint n,m,k;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tn++,m++,k++;\n\tll ret=0;\n\tll l=0,r=0;\n\tfor(int L=0;L<=m+k-2;L++)\n\t{\n\t\tll now=C(L+n-2,n-2)*rt[m+k-L-2]%MOD;\n\t\tif(L-k>0)\n\t\t{\n\t\t\tl*=2LL;\n\t\t\tl%=MOD;\n\t\t\tl+=C(L-1,k-1);\n\t\t\tif(l>=MOD) l-=MOD;\n\t\t}\n\t\telse if(L-k==0) l=1;\n\t\tif(L==0) r=1;\n\t\telse\n\t\t{\n\t\t\tr*=2LL;\n\t\t\tr%=MOD;\n\t\t\tif(L>m-1)\n\t\t\t{\n\t\t\t\tr-=C(L-1,m-1);\n\t\t\t\tif(r<0) r+=MOD;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d [%d %d] : %lld %lld\\n\",L,max(0,L-k+1),min(L,m-1),l,r);\n\t\tret+=now*(r-l+MOD)%MOD;\n\t\tret%=MOD;\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n#define SHOWSTACK(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.top() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nint pow3[1000006];\n\nstd::map<V<int>, int> map;\nint rec(V<int> a) {\n\tif (a[a[3]] == 0) {\n\t\tif (a[3] == 0) return pow3[a[1] + a[2]];\n\t\treturn 0ll;\n\t}\n\n\tif (map.count(a)) return map[a];\n\tint& res = map[a];\n\tres = 0;\n\n\t--a[a[3]];\n\tREP(i, 3) {\n\t\ta[3] = i;\n\t\t(res += rec(a)) %= MOD;\n\t}\n\treturn res;\n}\nint rec(int n, int m, int k) {\n\tmap.clear();\n\treturn rec({ n, m, k, 0 });\n}\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\nint calc500(int n, int m, int k) {\n\tint res = 0;\n\tREP(s, m + 1) REP(t, k + 1) {\n\t\t(res += (ll)fact[n - 1 + s + t] * factInv[n - 1] % MOD * factInv[s] % MOD * factInv[t] % MOD * pow3[m + k - s - t]) %= MOD;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tINIT;\n\n\tpow3[0] = 1;\n\tFOR(i, 1, 1000006) pow3[i] = pow3[i - 1] * 3 % MOD;\n\n\tVAR(int, n, m, k);\n\tOUT(calc500(n, m, k))BR;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define REP(a,b,c) for(int a=b;a<=c;a++)\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nint n,m,k;\nconst int N=1000010,Mod=1e9+7;\nint fac[N],fai[N],inv[N];\nvoid init(){\n\tfac[0]=fai[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=1000000;i++)fac[i]=1ll*fac[i-1]*i%Mod;\n\tfor(int i=2;i<=1000000;i++)inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;\n\tfor(int i=1;i<=1000000;i++)fai[i]=1ll*fai[i-1]*inv[i]%Mod;\n}\nint C(int n,int m){\n\tif(n<m || n<0 || m<0)return 0;\n\treturn 1ll*fac[n]*fai[m]%Mod*fai[n-m]%Mod;\n}\nint qpow(int a,int b){\n\tint ret=1;\n\twhile(b){\n\t\tif(b&1)ret=1ll*ret*a%Mod;\n\t\tb>>=1;a=1ll*a*a%Mod;\n\t}\n\treturn ret;\n}\nint main(){\n\tn=gi();m=gi();k=gi();\n\tinit();int ans=0;\n\tfor(int b=0;b<=m;b++)\n\t\tfor(int c=0;c<=k;c++)\n\t\t\tans=(ans+1ll*C(n-1+b+c,n-1)*C(b+c,b)%Mod*qpow(3,m-b)%Mod*qpow(3,k-c)%Mod)%Mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<list>\n#include<set>\n#include<string>\n#include <iomanip>\n#include<math.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll M = 1000000007;\n\nvector<ll> fac(1000001); //n!(mod M)\nvector<ll> ifac(1000001); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n) {\n\tll ans = 1;\n\twhile (n != 0) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb() {\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 1000000; i++) {\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n\tifac[1000000] = mpow(fac[1000000], M - 2);\n\tfor (ll i = 1000000; i > 0; i--) {\n\t\tifac[i - 1] = ifac[i] * i%M;\n\t}\n}\nll comb(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a) {\n\tlong long b = M, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0) u += M;\n\treturn u;\n}\n\nstruct Mo\n{\n  vector< int > left, right, order;\n  vector< bool > v;\n  int width;\n  int nl, nr, ptr;\n\n  Mo(int n) : width((int) sqrt(n)), nl(0), nr(0), ptr(0), v(n) {}\n\n  void insert(int l, int r) /* [l, r) */\n  {\n    left.push_back(l);\n    right.push_back(r);\n  }\n\n  /* ソート */\n  void build()\n  {\n    for(int i=0;i<left.size();i++)\n\t\torder.push_back(i);\n    sort(begin(order), end(order), [&](int a, int b)\n    {\n      if(left[a] / width != left[b] / width) return left[a] < left[b];\n      return right[a] < right[b];\n    });\n  }\n\n  /* クエリを 1 つぶんすすめて, クエリのidを返す */\n  int process()\n  {\n    if(ptr == order.size()) return (-1);\n    const auto id = order[ptr];\n    while(nl > left[id]) ldistribute(--nl,nr);\n    while(nr < right[id]) rdistribute(nr++,nl);\n    while(nl < left[id]) ldistribute(nl++,nr);\n    while(nr > right[id]) rdistribute(--nr,nl);\n    return (order[ptr++]);\n  }\n\n  inline void ldistribute(int l,int r)\n  {\n    v[l].flip();\n    if(v[l]) ladd(r,l);\n    else ldel(r,l);\n  }\n\n  inline void rdistribute(int r,int l)\n  {\n    v[r].flip();\n    if(v[r]) radd(r,l);\n    else rdel(r,l);\n  }\n\n  void ladd(int n,int k);\n\n  void radd(int n,int b);\n  \n  void ldel(int n,int k);\n  \n  void rdel(int n,int b);\n};\n\nll sum=1;\n\nvoid Mo::ladd(int n,int k){\n\tsum+=M-comb(n,k+1);\n\tsum%=M;\n}\n\nvoid Mo::ldel(int n,int k){\n\tsum+=comb(n,k+1);\n\tsum%=M;\n}\n\nvoid Mo::radd(int n,int b){\n\tsum*=2;\n\tsum+=M-comb(n,b);\n\tsum%=M;\n}\n\nvoid Mo::rdel(int n,int b){\n\tsum+=comb(n,b);\n\tsum*=ifac[2];\n\tsum%=M;\n}\n\nint main(){\n\tsetcomb();\n\tll n,m,k,val[1222222],ans=0,i,zero=0;\n\tcin>>n>>m>>k;\n\tMo mo(m+k+1);\n\tfor(i=0;i<(m+k+1)*2;i++)\n\t\tval[i]=1;\n\tfor(i=0;i<=m+k;i++){\n\t\tll bot=m-min(m,i),top=m-max(zero,i-k);\n\t\tmo.insert(top,m+k-i);\n\t\tif(bot==0){\n\t\t\tval[i*2+1]=0;\n\t\t\tmo.insert(0,0);\n\t\t}\n\t\telse{\n\t\t\tmo.insert(bot-1,m+k-i);\n\t\t}\n\t}\n\tmo.build();\n\tfor(i=0;i<(m+k+1)*2;i++){\n\t\tll idx=mo.process();\n\t\tif(val[idx])\n\t\t\tval[idx]=sum;\n\t}\n\tfor(i=0;i<=m+k;i++){\n\t\tll p=mpow(3,i);\n\t\tp*=comb(n-1+m+k-i,n-1);\n\t\tp%=M;\n\t\tp*=M+val[i*2]-val[i*2+1];\n\t\tp%=M;\n\t\tans+=p;\n\t}\n  ans%=M;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 1000000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nll p2[1000001];\nint main()\n{\n\tinvinit();\n\tll n, m, k;\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tp2[0] = 1;\n\tfor (int i = 1; i <= 1000000; i++)p2[i] = p2[i - 1] * 2 % mod;\n\tll nm = 0, nk = 0;\n\tfor (int i = n; i <= n + m; i++)nm = (nm + com(n + m, i)) % mod;\n\tfor (int i = n; i <= n + k; i++)nk = (nk + com(n + k, i)) % mod;\n\tll ans = 0;\n\tfor (int s = 0; s <= k; s++)\n\t{\n\t\tans += p2[k - s] * nm%mod*com(n + m + k, s) % mod;\n\t\tans %= mod;\n\t}\n\tfor (int s = 0; s <= m; s++)\n\t{\n\t\tans += p2[m - s] * nk%mod*com(n + m + k, s) % mod;\n\t\tans %= mod;\n\t}\n\tll now = 0;\n\tfor (int t = 0; t <= k; t++)\n\t{\n\t\tnow += com(n + m + k - m, t);\n\t\tnow %= mod;\n\t}\n\tfor (int s = m; s >= 0; s--)\n\t{\n\t\tans += mod - (now*com(n + m + k, s) % mod);\n\t\tans %= mod;\n\t\tnow = (now * 2 + mod - com(n + m + k - s, k));\n\t\tnow %= mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 22);\nconst int mod = (int)1e9 + 7;\nconst double PI = acos(-1);\n\ninline void addmod(int& x, int y, int mod) { (x += y) >= mod && (x -= mod); }\ninline int mulmod(int x, int y, int mod) { return x * 1ll * y % mod; }\n\nstruct complex_base\n{\n\tlong double x, y;\n\tcomplex_base(long double _x = 0, long double _y = 0) { x = _x; y = _y; }\n\tfriend complex_base operator-(const complex_base &a, const complex_base &b) { return complex_base(a.x - b.x, a.y - b.y); }\n\tfriend complex_base operator+(const complex_base &a, const complex_base &b) { return complex_base(a.x + b.x, a.y + b.y); }\n\tfriend complex_base operator*(const complex_base &a, const complex_base &b) { return complex_base(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x); }\n\tfriend void operator/=(complex_base &a, const long double &P) { a.x /= P; a.y /= P; }\n};\n\nint bit_rev[MAXN];\n\nvoid fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = 2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n}\n\nvoid inv_fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = -2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] /= n;\n}\n\ncomplex_base A[MAXN], B[MAXN];\n\nvector<int> mult(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() <= 128)\n\t{\n\t\tvector<int> ans(a.size() + b.size(), 0);\n\t\tfor(int i = 0; i < (int)a.size(); i++)\n\t\t\tfor(int j = 0; j < (int)b.size(); j++)\n\t\t\t\tans[i + j] = (ans[i + j] + a[i] * 1ll * b[j]) % mod;\n\n\t\treturn ans;\n\t}\n\n\tint lg = 0; while((1 << lg) < (int)(a.size() + b.size())) ++lg;\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = B[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = complex_base(a[i], 0);\n\tfor(int i = 0; i < (int)b.size(); i++) B[i] = complex_base(b[i], 0);\n\n\tfft(A, lg); fft(B, lg);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tA[i] = A[i] * B[i];\n\tinv_fft(A, lg);\n\n\tvector<int> ans(a.size() + b.size(), 0);\n\tfor(int i = 0; i < (int)ans.size(); i++)\n\t\tans[i] = (int64_t)(A[i].x + 0.5) % mod;\n\n\treturn ans;\n}\n\nvector<int> mult_mod(const vector<int> &a, const vector<int> &b)\n{\n\t/// Thanks pavel.savchenkov\n\n\t// a = a0 + sqrt(MOD) * a1\n\t// a = a0 + base * a1\n\tint base = (int)sqrtl(mod);\n\n\tvector<int> a0(a.size()), a1(a.size());\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t{\n\t\ta0[i] = a[i] % base;\n\t\ta1[i] = a[i] / base;\n\t}\n\n\tvector<int> b0(b.size()), b1(b.size());\n\tfor(int i = 0; i < (int)b.size(); i++)\n\t{\n\t\tb0[i] = b[i] % base;\n\t\tb1[i] = b[i] / base;\n\t}\n\n\tvector<int> a01 = a0;\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t\taddmod(a01[i], a1[i], mod);  \t\n\n\tvector<int> b01 = b0;\n\tfor(int i = 0; i < (int)b.size(); i++) \n\t\taddmod(b01[i], b1[i], mod);\n\n\tvector<int> C = mult(a01, b01);  // 1\n\n\tvector<int> a0b0 = mult(a0, b0); // 2\n\tvector<int> a1b1 = mult(a1, b1); // 3\n\n\tvector<int> mid = C;\n\tfor(int i = 0; i < (int)mid.size(); i++) \n\t{\n\t\taddmod(mid[i], -a0b0[i] + mod, mod);\n\t\taddmod(mid[i], -a1b1[i] + mod, mod);\n\t}\n\n\tvector<int> res = a0b0;\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, mid[i], mod), mod);\n\n\tbase = mulmod(base, base, mod);\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, a1b1[i], mod), mod);\n\n\treturn res;\n}\n\nint n, m, k;\n\nvoid read()\n{\n\tcin >> n >> m >> k;\n}\n\nvector<int> p1, p2, pw3;\n\nint pw(int x, int p)\n{\n\tint ret = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ret = (ret * 1ll * x) % mod;\n\t\tx = (x * 1ll * x) % mod;\n\t\tp >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint fact[MAXN], inv_fact[MAXN];\nint comb(int n, int k) { if(n < 0 || k < 0 || n < k) return 0; return (((fact[n] * 1ll * inv_fact[n - k]) % mod) * 1ll * inv_fact[k]) % mod; }\n\n/*   SUM C(n + i - 1, i) * C(n + i - 1 + j, j)   */\n/*   SUM C(n + i - 1, i) * fact[n + i - 1 + j] / (fact[j] * fact[n + i - 1])    */\n\n\nvoid solve()\n{\t\n\tpw3.assign(n + m + k + 1, 0);\n\tp1.assign(m + 1, 0);\n\tp2.assign(k + 1, 0);\n\tpw3[0] = 1; for(int i = 1; i <= m + k + n; i++) pw3[i] = (3ll * pw3[i - 1]) % mod;\n\tfact[0] = 1; for(int i = 1; i <= m + k + n; i++) fact[i] = (fact[i - 1] * 1ll * i) % mod;\n\tinv_fact[m + k + n] = pw(fact[m + k + n], mod - 2); for(int i = n + k + m - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * 1ll * (i + 1)) % mod; \n\n\tfor(int i = 0; i <= m; i++) p1[i] = (comb(n + i - 1, i) * 1ll * inv_fact[n + i - 1]) % mod;\n\tfor(int i = 0; i <= k; i++) p2[i] = inv_fact[i];\n\n\tvector<int> ret = mult_mod(p1, p2);\n\t\n\tint answer = 0;\n\tfor(int i = 0; i < (int)ret.size(); i++)\n\t{\n\t\tif(m + k - i < 0) break;\n\n\t\tint curr = (ret[i] * 1ll * pw3[m + k - i]) % mod;\n\t\tcurr = (curr * 1ll * fact[n - 1 + i]) % mod;\n\t\taddmod(answer, curr, mod);\n\t}\n\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n\n#include <cassert>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\ninline void ModMul(int& x, int y) {\n    x = (1LL * x * y) % MOD;\n}\n\ninline int GetModMul(int x, int y) {\n    ModMul(x, y);\n    return x;\n}\n\ninline void ModSum(int& x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n    if (x < 0) {\n        x += MOD;\n    }\n}\n\ninline int GetModSum(int x, int y) {\n    ModSum(x, y);\n    return x;\n}\n\ninline int GetBinaryPow(int x, int pw) {\n    int r = 1;\n    while (pw > 0) {\n        if (pw & 1) {\n            ModMul(r, x);\n        }\n        ModMul(x, x);\n        pw >>= 1;\n    }\n    return r;\n}\n\ninline int GetInv(int x) {\n    return GetBinaryPow(x, MOD - 2);\n}\n\nconst int MAX_N = 3e5;\nconst int MAX_FACT = 2 * MAX_N + 100;\n\nvector<int> fact(MAX_FACT);\nvector<int> invFact(MAX_FACT);\n\nvoid BuildFact() {\n    fact[0] = 1;\n    for (int i = 1; i < MAX_FACT; ++i) {\n        fact[i] = fact[i - 1];\n        ModMul(fact[i], i);\n    }\n    for (int i = 0; i < MAX_FACT; ++i) {\n        invFact[i] = GetInv(fact[i]);\n    }\n}\n\ninline int GetC(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n    int r = fact[n];\n    ModMul(r, invFact[k]);\n    ModMul(r, invFact[n - k]);\n    return r;\n}\n\ninline int GetCoeff(int n, int m) {\n    if (n == 0) {\n        return 0;\n    }\n    return GetC(n + m - 1, n - 1);\n}\n\nint main() {\n    BuildFact();\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> pw3(m + k + 1);\n    pw3[0] = 1;\n    for (int i = 1; i <= m + k; ++i) {\n        pw3[i] = pw3[i - 1];\n        ModMul(pw3[i], 3);\n    }\n\n    int l = 0;\n    int r = 0;\n    int sum = 1;\n\n    int result = 0;\n    for (int s = 0; s <= m + k; ++s) {\n        const int cl = max(0, s - k);\n        const int cr = min(m, s);\n\n        if (l == r) {\n            sum = 0;\n            for (int i = cl; i <= cr; ++i) {\n                ModSum(sum, GetC(s, i));\n            }\n        } else {\n            ModMul(sum, 2);\n            ++l;\n\n            while (r < cr) {\n                ModSum(sum, GetC(s, r + 1));\n                ++r;\n            }\n            while (l > cl) {\n                ModSum(sum, GetC(s, l - 1));\n                --l;\n            }\n\n            while (r > cr) {\n                ModSum(sum, -GetC(s, r));\n                --r;\n            }\n            while (l < cl) {\n                ModSum(sum, -GetC(s, l));\n                ++l;\n            }\n        }\n\n        int curResult = GetC(s + (n - 1), n - 1);\n        ModMul(curResult, pw3[m + k - s]);\n        ModMul(curResult, sum);\n\n        ModSum(result, curResult);\n    }\n\n    cout << result << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define SF scanf\n#define PF printf\n#define MAXN 900010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nll inv[MAXN],fac[MAXN],pow3[MAXN];\nll fsp(ll x,int y){\n    ll res=1;\n    while(y){\n        if(y&1)\n            res=res*x%MOD;\n        x=x*x%MOD;\n        y>>=1;  \n    }\n    return res;\n}\nll C(int x,int y){\n    return fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nint main(){\n    pow3[0]=1;\n    fac[0]=1;\n    for(int i=1;i<=900000;i++){\n        pow3[i]=pow3[i-1]*3ll%MOD;  \n        fac[i]=fac[i-1]*i%MOD;\n    }\n    inv[900000]=fsp(fac[900000],MOD-2);   \n    for(int i=900000;i>0;i--)\n        inv[i-1]=inv[i]*i%MOD;\n    int n,m,k;\n    while(SF(\"%d%d%d\",&n,&m,&k)!=EOF){\n\t    n--;\n\t    if(m<k)\n\t        swap(m,k);\n\t    ll j=1,ans=0;\n\t    for(int i=0;i<=m+k;i++){\n\t        ans=(ans+C(n+i,n)*pow3[m+k-i]%MOD*j)%MOD;   \n\t        if(i<k)\n\t            j=j*2ll%MOD;\n\t        else if(i<m)\n\t            j=(j*2ll-C(i,k))%MOD;\n\t        else    \n\t            j=(j*2ll-C(i,k)-C(i,m))%MOD;\n\t    }\n\t    ans=(ans+MOD)%MOD;\n\t    PF(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\nconst int MAX = 1000000;\nMint inv[MAX+1], fact[MAX+1], fact_inv[MAX+1];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i=2; i<=MAX; i++) inv[i] = inv[MOD%i] * (MOD-MOD/i);\n\n    fact[0] = fact_inv[0] = 1;\n    for (int i=1; i<=MAX; i++) {\n\tfact[i] = fact[i-1] * i;\n\tfact_inv[i] = fact_inv[i-1] * inv[i];\n    }\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\nint N, M, K;\n\nvoid MAIN() {\n    init();\n    scanf(\"%d%d%d\", &N, &M, &K);\n\n    Mint ans = 0;\n    Mint way = 1;\n    Mint r = Mint(3).pow(M+K);\n    Mint inv3 = Mint(3).inv();\n    REP (i, M+K+1) {\n\tans += nCk(i+N-1, i) * way * r;\n\tway += way;\n\tr *= inv3;\n\tif (i+1 > K) {\n\t    way -= nCk(i, K);\n\t}\n\tif (i+1 > M) {\n\t    way -= nCk(i, M);\n\t}\n    }\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 9e5 + 5;\nconst int mod = 1e9 + 7;\n\nint n, m, k, Q;\nll ans;\nll f[maxn], fac[maxn], inv[maxn], bin[maxn];\n\nll power(ll b, int k)\n{\n    ll res = 1;\n    for(; k; k >>= 1, b = b * b % mod)\n        if(k & 1)\n            res = res * b % mod;\n    return res;\n}\n\nll C(int n, int m)\n{\n    if(m > n)\n        return 0;\n    return fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &m, &k);\n    Q = m + k;\n    f[0] = fac[0] = bin[0] = inv[0] = 1;\n    for(int i = 1; i <= n + Q; i++)\n    {\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = power(fac[i], mod - 2);\n    }\n    for(int i = 1; i <= Q; i++)\n    {\n        f[i] = ((f[i - 1] << 1) - C(i - 1, m) - C(i - 1, k) + (mod << 1)) % mod;\n        bin[i] = bin[i - 1] * 3 % mod;\n    }\n    for(int i = 0; i <= Q; i++)\n    {\n        ll tmp = C(i + n - 1, n - 1) * f[i] % mod * bin[Q - i] % mod;\n        ans += tmp;\n        if(ans >= mod)\n            ans -= mod;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\n#define N 5010\n#define ll long long\nconst int mod = 1e9 + 7 ;\n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] ;\n\nll power( ll a ,ll b ) {\n    ll base = a , ans = 1 ;\n    while( b ) {\n        if( b&1 )  ans = ( ans * base ) % mod ;\n        base = ( base * base ) % mod ;\n        b >>= 1 ;\n    }\n    return ans ;\n}\nll mul( ll x ,ll y ) {\n    return ( 1ll * x * y ) % mod ;\n}\n\nll inv( ll x ) {\n    return power( x , mod - 2 ) % mod ;\n}\n\nint main() {\n    scanf( \"%d%d%d\" , &n , &m , &k ) ;\n    \n    fac[ 0 ] = 1 ;\n    for( int i = 1 ; i < N ; i ++ ) fac[ i ] = mul( fac[ i - 1 ] , i ) ;\n    for( int i = 0 ; i < N ; i ++ ) ifac[ i ] = inv( fac[ i ] ) ;\n    \n    ll ans = 0 , sum = n + k + m ;\n    \n    for( int i = n ; i <= sum; i ++ ) {\n        for( int j = 0 ; j <= m ;j ++ ) {\n            int C = i - n - j ;\n            if( C < 0 || C > k ) continue ;\n            ll tmp = mul( fac[ i - 1 ] , mul( ifac[ n - 1 ] , mul( ifac[ j ] ,ifac[ C ] ) ) ) ;\n            tmp = mul( tmp , power( 3 , sum - i ) ) ;\n            ans = ( ans + tmp ) % mod ;\n        }\n    }\n    \n    printf( \"%lld\\n\" , ans ) ;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\ninline int add(int x,int y) {return (x+y>=mod) ? (x+y-mod) : (x+y);}\ninline int dec(int x,int y) {return (x-y<0) ? (x-y+mod) : (x-y);}\ninline int mul(int x,int y) {return (long long)x*y%mod;}\ninline int power(int a,int b,int rs=1) {for(;b;b>>=1,a=mul(a,a)) if(b&1) rs=mul(rs,a); return rs;}\ninline int cinv(int a) {return power(a,mod-2);}\n\nconst int N=1e6+50;\nstruct combin {\n\tint fac[N],ifac[N];\n\tcombin() {\n\t\tfac[0]=1;\n\t\tfor(int i=1;i<N;i++) fac[i]=mul(fac[i-1],i);\n\t\tifac[N-1]=cinv(fac[N-1]);\n\t\tfor(int i=N-2;~i;i--) ifac[i]=mul(ifac[i+1],i+1);\n\t}\n\tinline int C(int a,int b) {\n\t\tif(a>=0 && b>=0 && a>=b) return mul(fac[a],mul(ifac[b],ifac[a-b]));\n\t\telse return 0;\n\t}\n} C;\n\nint n,m,k,pw[N],ans;\nint l,r=-1,now=-1,sum;\ninline void trans() {\n\t++now;\n\tif(l>r) return;\n\tsum=mul(sum,2);\n\tsum=dec(sum,C.C(now-1,r));\n\tsum=add(sum,C.C(now-1,l-1));\n}\ninline void move(int L,int R) {\n\twhile(l<L) sum=dec(sum,C.C(now,l)), ++l;\n\twhile(l>L) --l, sum=add(sum,C.C(now,l));\n\twhile(r>R) sum=dec(sum,C.C(now,r)), --r;\n\twhile(r<R) ++r, sum=add(sum,C.C(now,r));\n}\nint main() {\n\tcin>>n>>m>>k;\n\tpw[0]=1;\n\tfor(int i=1;i<=n+m+k;++i) pw[i]=mul(pw[i-1],3);\n\tfor(int len=n;len<=n+m+k;++len) {\n\t\ttrans(); move(max(0,len-n-k),min(m,len-n));\n\t\tint t=mul(sum,C.C(len-1,n-1));\n\t\tt=mul(t,pw[n+m+k-len]);\n\t\tans=add(ans,t);\n\t} cout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=900000+10;\n\nconst int mod=1e9+7;\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint fac[N],ifac[N],pw[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n    for (re int i=pw[0]=1;i<=n;++i) pw[i]=3ll*pw[i-1]%mod;\n}\n\ninline int C(int n,int m) {\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main() { init(900000);\n    int n=read(),m=read(),k=read(); if (m<k) swap(m,k);\n    int ans=0,lst=1;\n    for (re int i=0;i<=m+k;++i) {\n        ans=(ans+1ll*C(n+i-1,n-1)*pw[m+k-i]%mod*lst)%mod;\n        if (i<k) lst=2ll*lst%mod;\n        else if (i<m) lst=(2ll*lst+mod-C(i,k))%mod;\n        else lst=(2ll*lst+mod-C(i,k)+mod-C(i,i-m))%mod;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pii;\ntypedef pair<double,double> pdd;\n#define SQ(i) ((i)*(i))\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define SZ(i) int(i.size())\n#define FOR(i, j, k, in) for (int i=j ; i<k ; i+=in)\n#define RFOR(i, j, k, in) for (int i=j ; i>=k ; i-=in)\n#define REP(i, j) FOR(i, 0, j, 1)\n#define REP1(i,j) FOR(i, 1, j+1, 1)\n#define RREP(i, j) RFOR(i, j, 0, 1)\n#define ALL(_a) _a.begin(),_a.end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n#ifdef tmd\n#define TIME(i) Timer i(#i)\n#define debug(...) do{\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\" ,\";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,deque<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define TIME(i)\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n#endif\nclass Timer {\nprivate:\n    string scope_name;\n    chrono::high_resolution_clock::time_point start_time;\npublic:\n    Timer (string name) : scope_name(name) {\n        start_time = chrono::high_resolution_clock::now();\n    }\n    ~Timer () {\n        auto stop_time = chrono::high_resolution_clock::now();\n        auto length = chrono::duration_cast<chrono::microseconds>(stop_time - start_time).count();\n        double mlength = double(length) * 0.001;\n        debug(scope_name, mlength);\n    }\n};\n\nconst ll MOD = 1000000007;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int iNF = 0x3f3f3f3f;\nconst ll MAXN = 300005;\n\nll n, m, k;\nll fact[MAXN], inv[MAXN];\n\nll mpow (ll bs, ll ep) {\n    ll ret = 1;\n    while (ep) {\n        if (ep & 1) {\n            ret = ret * bs % MOD;\n        }\n        ep >>= 1;\n        bs = bs * bs % MOD;\n    }\n    return ret;\n}\n\nll cob (ll a, ll b) {\n    return fact[a] * inv[b] % MOD * inv[a-b] % MOD; \n}\n/********** Good Luck :) **********/\nint main()\n{\n    TIME(main);\n    IOS();\n    debug(mpow(2, 10));\n\n    cin >> n >> m >> k;\n\n    inv[0] = fact[0] = 1;\n    REP1 (i, MAXN - 1) {\n        fact[i] = fact[i-1] * i % MOD;\n        inv[i] = mpow(fact[i], MOD - 2);\n    }\n\n    ll ans = mpow(3, m + k);\n\n    ll sum = 1;\n    REP1 (i, m+k) {\n        sum = sum * 2 % MOD;\n        if (i > m) {\n            sum -= cob(i-1, m);\n        }\n        if (i > k) {\n            sum -= cob(i-1, k);\n        }\n        sum = (sum % MOD + MOD) % MOD;\n        debug(sum);\n        ll cur = sum * cob(n + i - 1, n - 1) % MOD * mpow(3, m + k - i) % MOD;\n        debug(cur);\n        ans = (ans + cur) % MOD;\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(1123456);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,m,t;\n  cin>>n>>m>>t;\n  ll re=0,pw=modpow(3,m+t),sum=1;\n  rep(i,m+t+1){\n    (re+=pw*comb(n-1+i,i)%MOD*sum%MOD)%=MOD;\n    //cout<<pw<<\",\"<<comb(n-1+i,i)<<\",\"<<sum<<endl;\n    (pw*=inv[3])%=MOD;\n    (sum*=2)%=MOD;\n    if(t<=i) (sum+=MOD-comb(i,i-t))%=MOD;\n    if(m<=i) (sum+=MOD-comb(i,i-m))%=MOD;\n  }\n  //rep(i,m+1)rep(j,t+1) (re+=comb(n-1+i+j,i)*comb(n-1+j,j)%MOD*modpow(3,m+t-i-j)%MOD)%=MOD;\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=9e5+5,mo=1e9+7;\n\ntypedef long long LL;\n\nint n,m,K,ans,Fac[N],Inv[N],p[N];\n\nint C(int n,int m)\n{\n    return (LL)Fac[n]*Inv[m]%mo*Inv[n-m]%mo;\n}\n\nint main()\n{\n    p[0]=Fac[0]=Inv[0]=Fac[1]=Inv[1]=1; p[1]=3;\n    for (int i=2;i<N;i++) Inv[i]=(LL)Inv[mo%i]*(mo-mo/i)%mo;\n    for (int i=2;i<N;i++)\n    {\n        p[i]=p[i-1]*3ll%mo; Fac[i]=(LL)Fac[i-1]*i%mo; Inv[i]=(LL)Inv[i-1]*Inv[i]%mo;\n    }\n    scanf(\"%d%d%d\",&n,&m,&K); n--;\n    if (m<K) swap(m,K);\n    for (int i=0,j=1;i<=m+K;i++)\n    {\n        ans=(ans+(LL)C(n+i,n)*p[m+K-i]%mo*j)%mo;\n        if (i<K) j=j*2%mo;\n        else if (i>=m) j=(j*2ll-C(i,K)-C(i,i-m))%mo;\n        else j=(j*2ll-C(i,K))%mo;\n    }\n    if (ans<0) ans+=mo;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\n#define fi(a,b) for(int i=a;i<b;++i)\ntypedef long long ll;\n///////////////////\n\nint const N = 3e3 + 41;\nint const MOD = 1e9 + 7;\n\nint n, m, k;\nint f[N], invf[N];\nint th[N];\nint ans;\n\nvoid add(int &a, int b){\n\ta += b;\n\twhile(a >= MOD) a -= MOD;\n\twhile(a < 0) a += MOD;\n}\n\nint mul(int a, int b){\n\treturn (ll) a * b % MOD;\n}\n\nint bp(int x, int d){\n\tint res = 1;\n\twhile(d){\n\t\tif(d&1) res = mul(res, x);\n\t\td >>= 1;\n\t\tx = mul(x, x);\n\t}\n\treturn res;\n}\n\nint inv(int x){\n\treturn bp(x, MOD-2);\n}\n\nvoid init(){\n\tf[0] = 1;\n\tfi(1, N) f[i] = mul(f[i-1], i);\n\tfi(0, N) invf[i] = inv(f[i]);\n\tth[0] = 1;\n\tfi(1, N) th[i] = mul(th[i-1], 3);\n}\n\nint getc(int n, int k){\n\tif(k > n) return 0;\n\tint res = f[n];\n\tres = mul(res, invf[k]);\n\tres = mul(res, invf[n-k]);\n\treturn res;\n}\n\nint dg[N];\n\nint getg(int x){\n\tif(dg[x] != -1) return dg[x];\n\tint res = 0;\n\tfi(0, k+1){\n\t\tint y = x - i;\n\t\tif(y > m) continue;\n\t\tint v = getc(x, i);\n\t\tadd(res, v);\n\t}\n\tdg[x] = res;\n\treturn res;\n}\n\nvoid solve(){\n\tint x = n + m + k;\n\tmemset(dg, 255, sizeof(dg));\n\tfi(1, x+1){\n\t\tint f = getc(i-1, n-1);\n\t\tint g = getg(i-n);\n\t\tint t = th[x-i];\n\t\tadd(ans, mul(f, mul(g, t)));\n\t}\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tinit();\n\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\n\tsolve();\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define f first\n#define s second\n#define pb push_back\n#define reset(a,b) memset(a,b,sizeof a);\n#define ALL(x) x.begin(),x.end()\n#define debug(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sz(x) (int)(x.size())\n#define lt(x) (int)(x.length())\n#define MOD 1000000007 \n#define mx 1000003\n\nlong long fak[mx], inv[mx];\n\nlong long POW(long long a, int b){\n\tlong long ret = 1;\n\twhile(b > 0){\n\t\tif(b & 1)\n\t\t\tret = ret * a % MOD;\n\t\tb >>= 1;\n\t\ta = a * a % MOD;\n\t}\n\treturn ret;\n}\n\n\n\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\nconst int mod = 1e6 + 3;\nconst int MAXN = 400005;\n\nnamespace fft{\n\ttypedef complex<double> base;\n\tvoid fft(vector<base> &a, bool inv){\n\t\tint n = a.size(), j = 0;\n\t\tvector<base> roots(n/2);\n\t\tfor(int i=1; i<n; i++){\n\t\t\tint bit = (n >> 1);\n\t\t\twhile(j >= bit){\n\t\t\t\tj -= bit;\n\t\t\t\tbit >>= 1;\n\t\t\t}\n\t\t\tj += bit;\n\t\t\tif(i < j) swap(a[i], a[j]);\n\t\t}\n\t\tdouble ang = 2 * acos(-1) / n * (inv ? -1 : 1);\n\t\tfor(int i=0; i<n/2; i++){\n\t\t\troots[i] = base(cos(ang * i), sin(ang * i));\n\t\t}\n\t\tfor(int i=2; i<=n; i<<=1){\n\t\t\tint step = n / i;\n\t\t\tfor(int j=0; j<n; j+=i){\n\t\t\t\tfor(int k=0; k<i/2; k++){\n\t\t\t\t\tbase u = a[j+k], v = a[j+k+i/2] * roots[step * k];\n\t\t\t\t\ta[j+k] = u+v;\n\t\t\t\t\ta[j+k+i/2] = u-v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(inv) for(int i=0; i<n; i++) a[i] /= n;\n\t}\n\n\tvector<lint> multiply(vector<lint> &v, vector<lint> &w){\n\t\tvector<base> fv(v.begin(), v.end()), fw(w.begin(), w.end());\n\t\tint n = 1;\n\t\twhile(n < max(v.size(), w.size())) n <<= 1;\n\t\tn <<= 1;\n\t\tfv.resize(n);\n\t\tfw.resize(n);\n\t\tfft(fv, 0);\n\t\tfft(fw, 0);\n\t\tfor(int i=0; i<n; i++) fv[i] *= fw[i];\n\t\tfft(fv, 1);\n\t\tvector<lint> ret(n);\n\t\tfor(int i=0; i<n; i++) ret[i] = (lint)round(fv[i].real());\n\t\treturn ret;\n\t}\n\tvector<lint> multiply(vector<lint> &v, vector<lint> &w, lint mod){\n\t\tint n = 1;\n\t\twhile(n < max(v.size(), w.size())) n <<= 1;\n\t\tn <<= 1;\n\t\tvector<base> v1(n), v2(n);\n\t\tvector<base> r1(n), r2(n);\n\t\tfor(int i=0; i<v.size(); i++){\n\t\t\tv1[i] = base(v[i] >> 15, v[i] & 32767);\n\t\t}\n\t\tfor(int i=0; i<w.size(); i++){\n\t\t\tv2[i] = base(w[i] >> 15, w[i] & 32767);\n\t\t}\n\t\tfft(v1, 0);\n\t\tfft(v2, 0);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint j = (i ? (n - i) : i);\n\t\t\tbase ans1 = (v1[i] + conj(v1[j])) * base(0.5, 0);\n\t\t\tbase ans2 = (v1[i] - conj(v1[j])) * base(0, -0.5);\n\t\t\tbase ans3 = (v2[i] + conj(v2[j])) * base(0.5, 0);\n\t\t\tbase ans4 = (v2[i] - conj(v2[j])) * base(0, -0.5);\n\t\t\tr1[i] = (ans1 * ans3) + (ans1 * ans4) * base(0, 1);\n\t\t\tr2[i] = (ans2 * ans3) + (ans2 * ans4) * base(0, 1);\n\t\t}\n\t\tfft(r1, 1);\n\t\tfft(r2, 1);\n\t\tvector<lint> ret(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tlint av = (lint)round(r1[i].real());\n\t\t\tlint bv = (lint)round(r1[i].imag()) + (lint)round(r2[i].real());\n\t\t\tlint cv = (lint)round(r2[i].imag());\n\t\t\tav %= mod, bv %= mod, cv %= mod;\n\t\t\tret[i] = (av << 30) + (bv << 15) + cv;\n\t\t\tret[i] %= mod;\n\t\t\tret[i] += mod;\n\t\t\tret[i] %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n\nint main(){\n\t// precalc();\n\tfak[0] = 1;\n\tfor(int i = 1; i <= 1e6; i++)\n\t\tfak[i] = fak[i - 1] * i % MOD;\n\tinv[(int)1e6] = POW(fak[(int)1e6], MOD - 2);\n\tfor(int i = 1e6 - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1) % MOD;\n\tlong long n, m, k, jaw = 0;\n\tcin >> n >> m >> k;\n\t// for(int i = 0; i <= m; i++){\n\t// \tfor(int j = 0; j <= k; j++){\n\t// \t\tint tot = n + i + j - 1;\n\t// \t\tlong long kem = fak[tot] * inv[n - 1] % MOD * inv[i] % MOD * inv[j] % MOD;\n\t// \t\tlong long sisa = m - i + k - j;\n\t// \t\tkem = kem * POW(3, sisa) % MOD;\n\t// \t\tjaw = (jaw + kem) % MOD;\n\t// \t}\n\t// }\n\n\tvector<long long> a(m + 1, 0), b(k + 1, 0), res;\n\tfor(int i = 0; i <= m; i++)\n\t\ta[i] = inv[i];\n\tfor(int i = 0; i <= k; i++)\n\t\tb[i] = inv[i];\n\n\tres = fft::multiply(a, b, MOD);\n\n\t// for(int i = 0; i <= m + k; i++)\n\t\t// cout << i << \" -> \" << res[i] << endl;\n\t// debug(inv[m] * inv[k] % MOD);\n\tfor(int i = 0; i <= m + k; i++){\n\t\tint tot = n + i - 1;\n\t\tlong long kem = fak[tot] * inv[n - 1] % MOD * res[i] % MOD;\n\t\tlong long sisa = m - i + k;\n\t\tkem = kem * POW(3, sisa) % MOD;\n\t\tjaw = (jaw + kem) % MOD;\n\t}\n\tcout << jaw << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\nll mod_pow(ll a, ll n, ll mod) { ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }\n\ntemplate<int mod, int primitive_root>\nclass NTT {\npublic:\n\tint get_mod() const { return mod; }\n\tvoid _ntt(vector<ll>& a, int sign) {\n\t\tconst int n = sz(a);\n\t\tassert((n ^ (n&-n)) == 0); //n = 2^k\n\n\t\tconst int g = 3; //g is primitive root of mod\n\t\tint h = (int)mod_pow(g, (mod - 1) / n, mod); // h^n = 1\n\t\tif (sign == -1) h = (int)mod_inv(h, mod); //h = h^-1 % mod\n\n\t\t//bit reverse\n\t\tint i = 0;\n\t\tfor (int j = 1; j < n - 1; ++j) {\n\t\t\tfor (int k = n >> 1; k >(i ^= k); k >>= 1);\n\t\t\tif (j < i) swap(a[i], a[j]);\n\t\t}\n\n\t\tfor (int m = 1; m < n; m *= 2) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tconst ll base = mod_pow(h, n / m2, mod);\n\t\t\tll w = 1;\n\t\t\tFOR(x, m) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tll u = a[s];\n\t\t\t\t\tll d = a[s + m] * w % mod;\n\t\t\t\t\ta[s] = u + d;\n\t\t\t\t\tif (a[s] >= mod) a[s] -= mod;\n\t\t\t\t\ta[s + m] = u - d;\n\t\t\t\t\tif (a[s + m] < 0) a[s + m] += mod;\n\t\t\t\t}\n\t\t\t\tw = w * base % mod;\n\t\t\t}\n\t\t}\n\n\t\tfor (auto& x : a) if (x < 0) x += mod;\n\t}\n\tvoid ntt(vector<ll>& input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<ll>& input) {\n\t\t_ntt(input, -1);\n\t\tconst int n_inv = mod_inv(sz(input), mod);\n\t\tfor (auto& x : input) x = x * n_inv % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<ll> convolution(const vector<ll>& a, const vector<ll>& b){\n\t\tint ntt_size = 1;\n\t\twhile (ntt_size < sz(a) + sz(b)) ntt_size *= 2;\n\n\t\tvector<ll> _a = a, _b = b;\n\t\t_a.resize(ntt_size); _b.resize(ntt_size);\n\n\t\tntt(_a);\n\t\tntt(_b);\n\n\t\tFOR(i, ntt_size){\n\t\t\t(_a[i] *= _b[i]) %= mod;\n\t\t}\n\n\t\tintt(_a);\n\t\treturn _a;\n\t}\n};\n\nll garner(vector<pii> mr, int mod){\n\tmr.emplace_back(mod, 0);\n\n\tvector<ll> coffs(sz(mr), 1);\n\tvector<ll> constants(sz(mr), 0);\n\tFOR(i, sz(mr) - 1){\n\t\t// coffs[i] * v + constants[i] == mr[i].second (mod mr[i].first) を解く\n\t\tll v = (mr[i].second - constants[i]) * mod_inv<ll>(coffs[i], mr[i].first) % mr[i].first;\n\t\tif (v < 0) v += mr[i].first;\n\n\t\tfor (int j = i + 1; j < sz(mr); j++) {\n\t\t\t(constants[j] += coffs[j] * v) %= mr[j].first;\n\t\t\t(coffs[j] *= mr[i].first) %= mr[j].first;\n\t\t}\n\t}\n\n\treturn constants[sz(mr) - 1];\n}\n\ntypedef NTT<167772161, 3> NTT_1;\ntypedef NTT<469762049, 3> NTT_2;\ntypedef NTT<1224736769, 3> NTT_3;\n\n//任意のmodで畳み込み演算 O(n log n)\nvector<ll> int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\tvector<ll> ret(sz(x));\n\tvector<pii> mr(3);\n\tFOR(i, sz(x)){\n\t\tmr[0].first = ntt1.get_mod(), mr[0].second = (int)x[i];\n\t\tmr[1].first = ntt2.get_mod(), mr[1].second = (int)y[i];\n\t\tmr[2].first = ntt3.get_mod(), mr[2].second = (int)z[i];\n\t\tret[i] = garner(mr, mod);\n\t}\n\n\treturn ret;\n}\n\n// garnerのアルゴリズムを直書きしたversion，速い\nvector<ll> fast_int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\t\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tassert(ntt1.get_mod() < ntt2.get_mod() && ntt2.get_mod() < ntt3.get_mod());\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\t// garnerのアルゴリズムを極力高速化した\n\tconst ll m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n\tconst ll m1_inv_m2 = mod_inv<ll>(m1, m2);\n\tconst ll m12_inv_m3 = mod_inv<ll>(m1 * m2, m3);\n\tconst ll m12_mod = m1 * m2 % mod;\n\tvector<ll> ret(sz(x));\n\tFOR(i, sz(x)){\n\t\tll v1 = (y[i] - x[i]) *  m1_inv_m2 % m2;\n\t\tif (v1 < 0) v1 += m2;\n\t\tll v2 = (z[i] - (x[i] + m1 * v1) % m3) * m12_inv_m3 % m3;\n\t\tif (v2 < 0) v2 += m3;\n\t\tll constants3 = (x[i] + m1 * v1 + m12_mod * v2) % mod;\n\t\tif (constants3 < 0) constants3 += mod;\n\t\tret[i] = constants3;\n\t}\n\n\treturn ret;\n}\n\n#define MAX_N 2000000\nll MOD =  1000000007;\nint T = 300000;\nll fac[MAX_N];\nll finv[MAX_N];\nll t[MAX_N];\nll tinv[MAX_N];\nint main(){\n    int n,m,k;\n    cin >> n >> m >> k;\n    fac[0] = 1;\n    t[0] = 1;\n    rep(i,MAX_N-1){\n        fac[i+1] = fac[i]*(ll)(i+1)%MOD;\n        t[i+1] = t[i]*(ll)(3)%MOD;\n    }   \n    finv[MAX_N-1] = mod_inv(fac[MAX_N-1],MOD);\n    tinv[MAX_N-1] = mod_inv(t[MAX_N-1],MOD);\n    for(int i=MAX_N-2;i>=0;i--){\n        finv[i] = finv[i+1]*(ll)(i+1)%MOD;\n        tinv[i] = tinv[i+1]*(ll)(3)%MOD;\n    }\n    vector<ll>p(k+1),q(m+1+T);\n    rep(i,k+1){\n        p[i] = finv[k-i]*tinv[k-i]%MOD;\n    }\n    rep(i,T+m+1){\n        if(n-1+k+i-T>=0)q[i] = fac[n-1+k+i-T];\n    }\n    vector<ll> a = fast_int32mod_convolution(p,q,MOD);\n    ll sm = 0;\n    rep(i,m+1){\n        sm += (a[T+i]*tinv[i]%MOD)*finv[i]%MOD;\n        sm %= MOD;\n    }\n    cout << (sm*finv[n-1]%MOD)*t[m+k]%MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=912345;\nconst long long mod=1000000007;\nint n,m,k;\nlong long fac[maxn],rev[maxn],p3[maxn],f[maxn];\ninline long long ksm(long long x,long long n) {\n    long long ret=1;\n    while (n) {\n        if (n&1) ret=ret*x%mod;\n        n>>=1;\n        x=x*x%mod;\n    }\n    return ret;\n}\ninline long long C(int x,int y) {\n    return fac[x]*rev[y]%mod*rev[x-y]%mod;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&k);\n    fac[0]=p3[0]=1;\n    for (int i=1;i<maxn;++i) {\n        fac[i]=fac[i-1]*i%mod;\n        p3[i]=p3[i-1]*3%mod;\n    }\n    rev[maxn-1]=ksm(fac[maxn-1],mod-2);\n    for (int i=maxn-2;i>=0;--i) rev[i]=(i+1)*rev[i+1]%mod;\n    f[0]=1;\n    for (int i=1;i<maxn;++i) {\n        f[i]=2*f[i-1]%mod;\n        if (i>m) f[i]=((f[i]-C(i-1,m))%mod+mod)%mod;\n        if (i>k) f[i]=((f[i]-C(i-1,k))%mod+mod)%mod;\n    }\n    long long res=0;\n    for (int i=n;i<=n+m+k;++i)\n        res=(res+p3[n+m+k-i]*C(i-1,n-1)%mod*f[i-n]%mod)%mod;\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nconst int MAXN = 5005;\nconst int mod = 1e9 + 7;\n\nlint ipow(int x, int p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, m, k;\nlint fact[MAXN], invf[MAXN];\n\nlint bino(int x, int y){\n\treturn fact[x] * (invf[y] * invf[x - y] % mod) % mod;\n}\n\nint main(){\n\tfact[0] = invf[0] = 1;\n\tfor(int i=1; i<MAXN; i++){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tinvf[i] = ipow(fact[i], mod - 2);\n\t}\n\tcin >> n >> m >> k;\n\tlint func = 0;\n\tfor(int j=0; j<=k; j++){\n\t\tfunc += bino(n - 1 + j, j) * ipow(3, mod - 1 - j) % mod;\n\t\tfunc %= mod;\n\t}\n\tlint ret = func * ipow(3, m + k) % mod;\n\tfor(int i=1; i<=m; i++){\n\t\tlint aux = bino(n - 1 + i + k, k) * ipow(3, mod - 1 - k) % mod;\n\t\tfunc += mod - aux;\n\t\tfunc *= 3ll * (mod + 1) / 2;\n\t\tfunc += aux;\n\t\tfunc %= mod;\n\t\tlint base = ipow(3, m + k - i) * bino(n - 1 + i, i) % mod;\n\t\tret += base * func % mod;\n\t\tret %= mod;\n\t}\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 6e5 + 5, MOD = 1e9 + 7;\nint fac[N], rev[N];\nint mpow(int x, int n) {\n\tint res = 1;\n\twhile (n) {\n\t\tif (n & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint C(int n, int m) {\n\treturn 1LL * fac[n] * rev[m] % MOD * rev[n - m] % MOD;\n}\nint main() {\n\tfac[0] = rev[0] = 1;\n\tfor (int i = 1; i < N; ++ i) {\n\t\tfac[i] = 1LL * fac[i - 1] * i % MOD;\n\t\trev[i] = mpow(fac[i], MOD - 2);\n\t}\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tif (m > k) swap(m, k);\n\tint ans = 0;\n\tint l = 0, r = 0, sum = 1;\n\tfor (int s = 0; s <= m + k; ++ s) {\n\t\tint res = 1LL * C(s + n - 1, s) * mpow(3, m + k - s) % MOD;\n\t\tint L = max(0, s - k), R = min(m, s);\n\t\twhile (l > L) (sum += C(s, -- l)) %= MOD;\n\t\twhile (r < R) (sum += C(s, ++ r)) %= MOD;\n\t\twhile (l < L) (sum += MOD - C(s, l ++)) %= MOD;\n\t\twhile (r > R) (sum += MOD - C(s, r --)) %= MOD;\n\t\t(ans += 1LL * res * sum % MOD) %= MOD;\n\t\tsum = (2LL * sum + MOD - C(s, l) + MOD - C(s, r)) % MOD;\n\t\tl ++;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int P = 1e9 + 7 , N = 9 * 1e5 + 10;\nint Pow(int x,int t){int r=1;for(;t;t>>=1,x=1ll*x*x%P)if(t&1)r=1ll*r*x%P;return r;}\nint a , b , c , f[N] = {1}, rf[N] , p2[N] , p3[N];\n\nint C(int n,int m){\n    return 1ll * f[n] * rf[m] % P * rf[n - m] % P;\n}\nvoid pp(int &x,int d){\n    x += d;\n    if(x >= P) x -= P;\n}\n\nint main(){\n    rep(i,1,N) f[i] = 1ll * f[i-1] * i % P;\n    p2[0] = p3[0] = 1;\n    rep(i,1,N) p2[i] = 1ll * p2[i-1] * 2 % P , p3[i] = 1ll * p3[i-1] * 3 % P;\n    rf[N-1] = Pow(f[N-1] , P - 2);\n    for(int i=N-2;i>=0;--i) rf[i] = rf[i+1] * 1ll * (i + 1) % P;\n    scanf(\"%d%d%d\",&a,&b,&c);\n    ++b;++c;\n    int n = a + b + c;\n    int ans = 0;\n    for(int i=a;i+2<=n;++i){\n        int tmp = C(i - 1 , a - 1) , all = p2[i-a];\n        for(int j=b;j<=i-a;++j) pp(all , P - C(i - a , j));\n        for(int j=c;j<=i-a;++j) pp(all , P - C(i - a , j));\n        pp(ans , 1ll * tmp * all % P * p3[n-i-2] % P);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint A, B, C;\nllint beki2[600005], beki3[600005];\nllint dp[600005];\n\nllint fact[600005], fact_inv[600005];\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 600005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 600005; i++){\n\t\tfact_inv[i] = pow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> A >> B >> C;\n\tif(B > C) swap(B, C);\n\t\n\tmake_fact();\n\t\n\tllint mul = 1;\n\tfor(int i = 0; i < 600005; i++){\n\t\tbeki2[i] = mul;\n\t\tmul *= 2, mul %= mod;\n\t}\n\tmul = 1;\n\tfor(int i = 0; i < 600005; i++){\n\t\tbeki3[i] = mul;\n\t\tmul *= 3, mul %= mod;\n\t}\n\t\n\tfor(int i = 0; i <= B; i++) dp[i] = beki2[i];\n\tfor(int i = B; i < C; i++){\n\t\tdp[i+1] = (2 * dp[i] + mod - comb(i, B)) % mod;\n\t\tdp[i+1] %= mod;\n\t}\n\tfor(int i = C; i < 600005; i++){\n\t\tdp[i+1] = (2 * dp[i] + 2 * mod - (comb(i, i-C) + comb(i, B))) % mod;\n\t\tdp[i+1] %= mod;\n\t}\n\t\n\tllint ans = 0, tmp;\n\tfor(int i = 0; i <= B+C; i++){\n\t\ttmp = comb(A+i-1, i) * dp[i] % mod * beki3[B+C-i] % mod;\n\t\tans += tmp, ans %= mod;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n#define MAXN 900000\n#define MOD 1000000007\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\n#define BUF_SIZE 1000000\n#define _END fwrite(_Ob,1,_O-_Ob,stdout), _O = _Ob\n#define Outc(a) (*_O++ = a)\nchar _Ob[BUF_SIZE+5], *_O = _Ob, _Os[25], *_Ot;\ntemplate <typename T> inline void Out(T x)\n{\n\tif(!x){Outc('0'); return;} if(x < 0) Outc('-'), x = -x;\n\tfor(_Ot = _Os; x; *_Ot++ = x%10+'0', x /= 10);\n\tfor(; _Ot != _Os; Outc(*--_Ot)); if(_O-_Ob >= BUF_SIZE-50) _END;\n}\nint N, M, K, T, L, R, S, B[MAXN+5], fac[MAXN+5], efac[MAXN+5], ans;\ninline int fastpow(int s, int n){int a = 1; for(; n; n&1 ? a = 1ll*a*s%MOD : 0, s = 1ll*s*s%MOD, n >>= 1); return a;}\ninline int C(int n, int k){return n<0||k<0||n<k?0:1ll*fac[n]*efac[k]%MOD*efac[n-k]%MOD;}\nint main()\n{\n\tN = read(), M = read(), K = read(), T = N+M+K, S = 1;\n\tB[0] = 1; for(rint i = 1; i <= T; B[i] = 3u*B[i-1]%MOD, i++);\n\tfac[0] = 1; for(rint i = 1; i <= T; fac[i] = 1ll*i*fac[i-1]%MOD, i++);\n\tefac[T] = fastpow(fac[T],MOD-2); for(rint i = T; i; efac[i-1] = 1ll*i*efac[i]%MOD, i--);\n\tfor(rint p = N; p <= T; )\n\t{\n\t\tans = (ans+1ll*B[T-p]*C(p-1,N-1)%MOD*S)%MOD;\n\t\tS = (2ll*S+C(p-N,L-1)+C(p-N,R+1))%MOD, ++p, ++R;\n\t\tp-N-L > K ? S = (S+MOD-C(p-N,L)), S<MOD?:S-=MOD, ++L : 0;\n\t\tR > M ? S = (S+MOD-C(p-N,R)), S<MOD?:S-=MOD, --R : 0; if(L>R) break;\n\t}\tprintf(\"%d\\n\",ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll mod=1e9+7;\nconst ll inf=1e17+500;\nconst ll maxn=3200;\nll ent[maxn][maxn];\nll poww[maxn];\n\nint main(){\n   poww[0]=1;\n   for(ll i=1;i<maxn;i++){\n        poww[i]=(poww[i-1]*3)%mod;\n   }\n   ent[0][0]=1;\n   for(ll i=1;i<maxn;i++){\n        ent[i][i]=1;\n        ent[i][0]=1;\n        for(ll j=1;j<i;j++){\n            ent[i][j]=(ent[i-1][j]+ent[i-1][j-1])%mod;\n        }\n   }\n   ll ans=0;\n   ll n,m,k;\n   cin>>n>>m>>k;\n   n--;\n   for(ll s=0;s<=m+k;s++){\n        ll res=0;\n        for(ll j=max(0LL,s-m);j<=min(k,s);j++){\n            res+=(ent[n+s][j]*ent[n+s-j][s-j])%mod;\n        }\n        res%=mod;\n        res*=poww[m+k-s];\n        res%=mod;\n\n        ans+=res;\n   }\n   cout<<ans%mod;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tpl<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\n//------------------------------------------------------------------------------\n\nconst lli MOD = 1e9+7;\nlli cnk[5002][5002];\nlli p3[5000000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  lli n, m, k; cin >> n >> m >> k;\n  p3[0] = 1; FOR(i, 300000) p3[i+1]=(3*p3[i])%MOD;\n  FOR(i, 5000) {\n    cnk[i][0] = 1;\n    cnk[i][i] = 1;\n    FORU(j, 1, i-1) cnk[i][j] = (cnk[i-1][j-1]+cnk[i-1][j])%MOD;\n    // if(i==2) FORU(j, 1, i-1) cout << cnk[i][j] << \" \"; cout << endl;\n  }\n  lli ans = 0;\n  FORU(i, 0, n+m+k) if(n-1 <= i-1) {\n    lli s = 0;\n    FORU(j, 0, k) if(j<=i-n && i-n-j<=m) {\n      // cout << j << \" \" << i-n << \" \" << cnk[i-n][j] << endl;\n\n      s += cnk[i-n][j];\n    }\n    s %= MOD;\n    s *= cnk[i-1][n-1];\n    s %= MOD;\n    s *= p3[n+m+k-i];\n    s %= MOD;\n    (ans += s) %= MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MOD 1000000007\n\nusing namespace std;\n\nint Fact[1000005],P3[1000005],Inv[1000005],Dp[1000005];\n\nint put(int a, int b)\n{\n    int rez=1;\n    for(int i=0; (1<<i)<=b; i++)\n    {\n        if((1<<i)&b)\n            rez=(1LL*rez*a)%MOD;\n        a=(1LL*a*a)%MOD;\n    }\n    return rez;\n}\n\nint comb(int n, int k)\n{\n    if(k>n)\n        return 0;\n\n    int rez=(1LL*Fact[n]*Inv[k])%MOD;\n    rez=(1LL*rez*Inv[n-k])%MOD;\n    return rez;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n    int n,m,k;\n    cin>>n>>m>>k;\n\n    Fact[0]=1;\n    P3[0]=1;\n    for(int i=1; i<=n+m+k+1; i++)\n    {\n        Fact[i]=(1LL*Fact[i-1]*i)%MOD;\n        P3[i]=(3LL*P3[i-1])%MOD;\n    }\n\n    Inv[n+m+k+1]=put(Fact[n+k+k+1],MOD-2);\n    for(int i=n+m+k; i>=0; i--)\n        Inv[i]=(1LL*Inv[i+1]*(i+1))%MOD;\n\n    Dp[0]=1;\n    for(int i=1; i<=m+k; i++)  //nr de moduri de a pune B si C a.i. sa nu castige nici b nici c\n    {\n        Dp[i]=(Dp[i-1]-comb(i-1,m)+MOD)%MOD; //pun pe poz i B\n        Dp[i]=(1LL*Dp[i]+Dp[i-1]-comb(i-1,k)+MOD)%MOD; //pun pe poz i C\n    }\n\n    int rez=0;\n    for(int i=n+1; i<=n+m+k+1; i++)\n    {\n        int val=comb(i-2,n-1); //prima si ultima val e a\n        val=(1LL*val*P3[n+m+k+1-i])%MOD;\n        val=(1LL*val*Dp[i-n-1])%MOD;\n        rez=(rez+val)%MOD;\n    }\n    cout<<rez<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, M, K;\nint p3[700000];\nint fact[700000];\nint s[700000];\nint memo[1001][2002];\n\nint modpow(int x, int k) {\n  int a = 1;\n  while (k > 0) {\n    if (k & 1) a = (1LL*a*x) % MOD;\n    x = (1LL*x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\n\nint inv(int x) {\n  return modpow(x, MOD-2);\n}\n\nint nCr(int n, int k) {\n  if (n < 0 || k < 0 || n < k) return 0;\n  return (1LL * fact[n] * inv((1LL*fact[k]*fact[n-k]) % MOD)) % MOD;\n}\n\nint f(int a, int b) {\n  if (memo[a][b] != 0) return memo[a][b];\n  if (a == 0) {\n    return memo[a][b] = (1LL * p3[b] * s[M+K-b]) % MOD;\n  }\n  int s = 0;\n  s = (s+f(a-1, b)) % MOD;\n  if (b>0) s = (s+f(a, b-1)) % MOD;\n  return memo[a][b] = s;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M >> K;\n  if (M > K) swap(M, K);\n  p3[0] = 1, fact[0] = 1;\n  for (int i=1; i<=M+K; i++) {\n    p3[i] = (3LL*p3[i-1]) % MOD;\n    fact[i] = (1LL*i*fact[i-1]) % MOD;\n  }\n  for (int u=0; u<=M+K; u++) {\n    int m = 0;\n    for (int i=max(0LL, u-M); i<=K; i++) m = (m + nCr(u, i)) % MOD;\n    s[u] = m;\n  }\n  cout << f(N, M+K) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <tuple>\n#include <queue>\n#include <string>\n#include <map>\n#include <utility>\n#include <cassert>\n\nconst int maxn = 3e5+1;\ntypedef long long ll;\nusing namespace std;\nconst ll MOD =1e9+7;\nll fac[maxn];\nll rev[maxn];\nll inv[maxn];\nll C(int n,int k){\n    if (n<k || k<0)\n        return 0;\n    return fac[n]*inv[n-k]%MOD*inv[k]%MOD;\n}\nll precalc(){\n    fac[0]=1;\n    inv[0]=1;\n    rev[1]=1;\n    inv[1]=1;\n    fac[1]=1;\n    for(int i=2; i<maxn; ++i){\n        fac[i]=fac[i-1]*i%MOD;\n        rev[i]=(MOD-MOD/i)*rev[MOD%i]%MOD;\n        inv[i]=inv[i-1]*rev[i]%MOD;\n    }\n}\nll pw(ll a,ll b){\n    ll res=1;\n    while(b){\n        if (b&1)\n            res=res*a%MOD;\n        a=a*a%MOD;\n        b>>=1;\n    }\n    return res;\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n //   freopen(\"input.txt\",\"r\",stdin);\n    int n,m,k;\n    cin>>n>>m>>k;\n    precalc();\n    ll ans=0;\n    for(int i=n; i<=n+m+k; ++i){\n        ll temp=0;\n        for(int c=0; c<=min(i-n,k); ++c){\n            int ost=i-n-c;\n            if (ost>m)\n                continue;\n            temp+=C(i-1,n-1)*C(i-n,c)%MOD;\n            if (temp>=MOD)\n                temp-=MOD;\n        }\n        ans+=temp*pw(3,n+m+k-i)%MOD;\n        if (ans>=MOD)\n            ans-=MOD;\n    }\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\nconst LL mod = 1e9 + 7;\nconst int N = 11111;\n\nint a, b, c;\nLL three[N];\n\nLL fac[N], facinv[N], inv[N];\n\nLL C(int n, int k)\n{\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\nLL cal(int a, int b, int c)\n{\n\treturn C(a + b - 1, b) * C(a + b + c - 1, c) % mod;\n}\nint main()\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i % mod;\n\tinv[1] = 1;\n\tfor (int i = 2; i < N; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n\tfacinv[0] = 1;\n\tfor (int i = 1; i < N; i++) facinv[i] = facinv[i - 1] * inv[i] % mod;\n\tthree[0] = 1;\n\tfor (int i = 1; i < N; i++) three[i] = three[i - 1] * 3 % mod;\n\tcin >> a >> b >> c;\n\t\n\tLL ans = 0;\n\t\n\tfor (int i = 0; i <= b; i++)\n\tfor (int j = 0; j <= c; j++)\n\t{\n\t\tans += three[b + c - i - j] * cal(a, i, j) % mod;\n\t\t//cout << three[b + c - i - j] << \" \" << cal(a, i, j) << endl;\n\t\tans %= mod;\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int N=1000005,Mod=1e9+7;\ninline int qpow(int a,int b){\n\tint ans=1;\n\twhile (b){\n\t\tif (b&1) ans=1ll*ans*a%Mod;\n\t\ta=1ll*a*a%Mod,b>>=1; \n\t}\n\treturn ans;\n}\nint fac[N],inv[N],pow3[N];\ninline void init_binom(){\n\tfac[0]=1;for (int i=1;i<=1000000;i++) fac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[1000000]=qpow(fac[1000000],Mod-2);\n\tfor (int i=999999;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%Mod;\n\tpow3[0]=1;for (int i=1;i<=1000000;i++) pow3[i]=1ll*pow3[i-1]*3ll%Mod;\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint n,m,k;\nint main (){\n\tinit_binom();\n\tscanf (\"%d%d%d\",&n,&m,&k);\n\tint ans=0,x=1;\n\tif (m<k) m^=k^=m^=k;\n\tfor (int i=0;i<=m+k;i++) {\n        ans=(ans+1ll*C(n-1+i,n-1)*pow3[m+k-i]%Mod*x%Mod)%Mod;\n        if (i<k) x=x*2ll%Mod;\n        else if(i>=m) x=((x*2ll%Mod-C(i,k)-C(i,i-m))%Mod+Mod)%Mod;\n        else x=(x*2ll%Mod-C(i,k)+Mod)%Mod;\n    }\n\tprintf (\"%d\",(ans+Mod)%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int maxn(1e6 + 10), Mod(1e9 + 7);\nint N, M, K, ans, fac[maxn], inv[maxn], Pow[maxn];\nint C(int n, int m) { return 1ll * fac[n] * inv[m] % Mod * inv[n - m] % Mod; }\nint Minus(int x, int y) { return (x - y + Mod) % Mod; }\nint Add(int x, int y) { return (x + y) % Mod; }\nint Mul(int x, int y) { return 1ll * x * y % Mod; }\nint fastpow(int x, int y)\n{\n\tint ans = 1;\n\tfor (; y; y >>= 1, x = 1ll * x * x % Mod)\n\t\tif (y & 1) ans = 1ll * ans * x % Mod;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &K), fac[0] = inv[0] = Pow[0] = 1; if (M < K) std::swap(M, K);\n\tfor (int i = 1; i <= N + M + K; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tfor (int i = 1; i <= N + M + K; i++) Pow[i] = 1ll * Pow[i - 1] * 3 % Mod;\n\tinv[N + M + K] = fastpow(fac[N + M + K], Mod - 2);\n\tfor (int i = N + M + K - 1; i; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % Mod;\n\tfor (int i = 0, x = 1; i <= M + K; i++)\n\t{\n\t\tans = Add(ans, Mul(Mul(C(N + i - 1, N - 1), Pow[M + K - i]), x));\n\t\tif (i < K) x = (x + x) % Mod; else if (i < M) x = Minus((x + x) % Mod, C(i, K));\n\t\telse x = Minus(Minus((x + x) % Mod, C(i, K)), C(i, M));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconst LL MOD = 1000000007ll;\n\nLL m_pow(LL a,LL n)\n{\n    if(n == 0)return 1;\n    LL half = m_pow(a,n/2);\n    half *= half;\n    half %= MOD;\n    return (half * (n % 2 ? a : 1)) % MOD;\n}\nvector<LL>fact;\nLL comb(LL n,LL r)\n{\n    LL shi = fact[n];\n    LL bo1 = m_pow(fact[r],MOD - 2);\n    LL bo2 = m_pow(fact[n - r],MOD - 2);\n    shi *= bo1;\n    shi %= MOD;\n    shi *= bo2;\n    shi %= MOD;\n    return shi;\n}\n\nint main()\n{\n    fact.push_back(1);\n    for(int i = 1;i < 5e6;++i)fact.push_back(fact.back() * i % MOD);\n    int N,M,K;\n    cin >> N >> M >> K;\n    LL val = 1;\n    LL ans = 0;\n    for(int P = N;P <= N + M + K;++P)\n    {\n        int down = P-N-K;\n        int up = M;\n        if(P != N)val *= 2;\n        val %= MOD;\n        if(down > 0)\n        {\n            val -= comb(P-N-1,down-1);\n            val += MOD;\n            val %= MOD;\n        }\n        if(P-N > up)\n        {\n            val -= comb(P-N-1,up);\n            val += MOD;\n            val %= MOD;\n        }\n        LL plus = val;\n        plus *= m_pow(3,N+M+K-P);\n        plus %= MOD;\n        plus *= comb(P-1,N-1);\n        plus %= MOD;\n        ans += plus;\n        ans %= MOD;\n        cerr << plus << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef complex<double> CD;\n\n#define REP(i, n) for (int i = 0; i < int(n); ++i)\n#define REPE(i, a, b) for (int i = (a); i <= int(b); ++i)\n#define F first\n#define S second\n\nvoid R(int &x) { scanf(\"%d\", &x); }\nvoid R(LL &x) { scanf(\"%lld\", &x); }\nvoid R(ULL &x) { scanf(\"%llu\", &x); }\nvoid R(double &x) { scanf(\"%lf\", &x); }\nvoid R(LD &x) { scanf(\"%Lf\", &x); }\n\ntemplate <typename T> void R(T &t) { cin >> t; }\ntemplate <typename T> void R(vector<T> &ar) {\n  for (auto &it : ar)\n    R(it);\n}\n\ntemplate <typename T, typename... Args> void R(T &t, Args &... args) {\n  R(t);\n  R(args...);\n}\n\nvoid W(const char &c) { putchar(c); };\nvoid W(const int &x) { printf(\"%d\", x); }\nvoid W(const LL &x) { printf(\"%lld\", x); }\nvoid W(const ULL &x) { printf(\"%llu\", x); }\nvoid W(const double &x) { printf(\"%lf\", x); }\nvoid W(const LD &x) { printf(\"%Lf\", x); }\n\ntemplate <typename T> void W(const T &t) { cout << t; }\ntemplate <typename T> void W(const vector<T> &ar) {\n  for (size_t i = 0; i < ar.size(); ++i) {\n    W(ar[i]);\n    putchar(\" \\n\"[i + 1u == ar.size()]);\n  }\n}\ntemplate <typename T, typename... Args>\nvoid W(const T &t, const Args &... args) {\n  W(t);\n  W(args...);\n}\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int maxn = 1e6;\n\nconst LL mod = 1000000000 + 7;\nLL pow_mod(LL a, LL p, const LL m) {\n  LL ret = 1;\n  for (; p; p >>= 1, a = a * a % m)\n    if (p & 1)\n      ret = ret * a % m;\n  return ret % m;\n}\nLL inv(LL a, LL n) {\n  return a < 2 ? a : ((1 - n * 1LL * inv(n % a, a)) / a % n + n) % n;\n}\n\nLL fac[maxn], rev[maxn];\n\nLL f(LL t[3]) {\n  LL r = fac[t[0] + t[1] + t[2]];\n  REP(i, 3) r = r * rev[t[i]] % mod;\n  return r;\n}\nLL buf[10000000], *ptr = buf;\nLL *alloc(size_t n) {\n  LL *ret = ptr;\n  memset(ret, 0, sizeof(LL) * n);\n  ptr += n;\n  return ret;\n}\nvoid mul(int n, LL *a, LL *b, LL *c) {\n  if (n < 16) {\n    memset(c, 0, sizeof(LL) * (n + n - 1));\n    REP(i, n) REP(j, n) {\n      c[i + j] = (c[i + j] + a[i] * b[j]);\n    }\n    REP(i, n * 2 - 1) c[i] %= mod;\n    return ;\n  }\n  int m = n >> 1, o = n - m;\n  auto op = ptr;\n  auto x = alloc(m * 2 - 1), y = alloc(o * 2 - 1), z = alloc(o * 2 - 1);\n  auto aa = alloc(o), bb = alloc(o);\n  REP(i, m) {\n    aa[i] = (a[i] + a[i + m]); if (aa[i] >= mod) aa[i] -= mod;\n    bb[i] = (b[i] + b[i + m]); if (bb[i] >= mod) bb[i] -= mod;\n  }\n  mul(m, a, b, x);\n  mul(o, a + m, b + m, y);\n  mul(o, aa, bb, z);\n  memcpy(c, x, sizeof(LL) * (m * 2 - 1));\n  memcpy(c + m + m, y, sizeof(LL) * (o * 2 - 1));\n  REP(i, o * 2 - 1) {\n    z[i] -= x[i] + y[i];\n    if (z[i] < 0) z[i] += mod;\n    if (z[i] < 0) z[i] += mod;\n    c[i + m] += z[i];\n    if (c[i + m] >= mod) c[i + m] -= mod;\n  }\n  ptr = op;\n}\nint n, m, k;\n\nLL a[maxn] = {}, b[maxn] = {}, c[maxn] = {};\nint main() {\n  fac[0] = rev[0] = 1;\n  for (int i = 1; i < maxn; ++i) {\n    fac[i] = fac[i - 1] * i % mod;\n    rev[i] = rev[i - 1] * inv(i, mod) % mod;\n  }\n  R(n, m, k);\n  REPE(i, 0, m) a[i] = rev[i];\n  REPE(i, 0, k) b[i] = rev[i];\n  int sz = 2, mm = max(m, k) + 1;\n  while (sz < mm) sz *= 2;\n  mul(sz, a, b, c);\n  LL ans = 0;\n  REPE(s, 0, m + k) {\n    LL t = fac[n + s - 1] * pow_mod(3, m + k - s, mod) % mod;\n    t = t * rev[n - 1] % mod;\n    t = t * c[s] % mod;\n    ans = (ans + t) % mod;\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n#include <numeric>\n#include <bitset>\n#include <ext/algorithm>\n#include <ext/numeric>\n#define ffor(_a,_f,_t) for(int _a=(_f),__t=(_t);_a<__t;_a++)\n#define all(_v) (_v).begin() , (_v).end()\n#define sz size()\n#define pb push_back\n#define SET(__set, val) memset(__set, val, sizeof(__set))\n#define FOR(__i, __n) ffor (__i, 0, __n)\ntypedef long long LL; using namespace std;\n\nint N, M, K;\n\nconst int MOD = 1000000007;\n\nint dp[2][1001][1001];\n\nint pow3[300000];\n\nint main() {\n\tcin >> N >> M >> K;\n\tint c, p;\n\tSET(dp, 0);\n\tpow3[0] = 1;\n\tffor (i, 1, 300000) {\n\t\tLL tmp = pow3[i - 1] * 3LL;\n\t\ttmp %= MOD;\n\t\tpow3[i] = tmp;\n\t}\n\tFOR (n, N) {\n\t\tc = n & 1;\n\t\tp = c ^ 1;\n\t\tFOR (m, M + 1)\n\t\t\tFOR (k, K + 1) {\n\t\t\t\tint &ret = dp[c][m][k];\n\t\t\t\tret = 0;\n\t\t\t\tif (!n)\n\t\t\t\t\tret += pow3[m + k];\n\t\t\t\telse\n\t\t\t\t\tret += dp[p][m][k];\n\t\t\t\tif (ret >= MOD)\n\t\t\t\t\tret -= MOD;\n\t\t\t\tif (m)\n\t\t\t\t ret += dp[c][m - 1][k];\n\t\t\t\tif (ret >= MOD)\n\t\t\t\t\tret -= MOD;\n\t\t\t\tif (k)\n\t\t\t\t\tret += dp[c][m][k - 1];\n\t\t\t\tif (ret >= MOD)\n\t\t\t\t\tret -= MOD;\n\t\t\t}\n\t}\n\tcout << dp[(N - 1) & 1][M][K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\n#include<set>\n#include<queue>\n#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define rep(i,l,r) for(int i=(l);i<(r);++i)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int N = 9e5 + 7;\nconst int MOD = 1e9 + 7;\n//--------head---------\nint n, m, k, f[N], rf[N], x2[N], x3[N];\nll kpow(ll a, ll b) {\n\tll r = 1;\n\twhile (b > 0) {\n\t\tif (b & 1)\n\t\t\tr = r * a % MOD;\n\t\ta = a * a % MOD, b >>= 1;\n\t}\n\treturn r;\n}\nvoid inc(int &x, int y) {\n\tx += y;\n\tif (x >= MOD)\n\t\tx -= MOD;\n}\nvoid init() {\n\tf[0] = 1;\n\trep(i, 1, N)\n\t\tf[i] = 1ll * i * f[i - 1] % MOD;\n\trf[N - 1] = kpow(f[N - 1], MOD - 2);\n\tfor (int i = N - 2; i >= 0; --i)\n\t\trf[i] = 1ll * (i + 1) * rf[i + 1] % MOD;\n\tx2[0] = 1;\n\trep(i, 1, N)\n\t\tx2[i] = 1ll * 2 * x2[i - 1] % MOD;\n\tx3[0] = 1;\n\trep(i, 1, N)\n\t\tx3[i] = 1ll * 3 * x3[i - 1] % MOD;\n}\nll C(int n, int m) {\n\tif (n < m)\n\t\treturn 0;\n\treturn 1ll * f[n] * rf[m] % MOD * rf[n - m] % MOD;\n}\nint main() {\n\tinit();\n\tcin >> n >> m >> k;\n\t++m, ++k;\n\tint tot = n + m + k, ans = 0;\n\tint fb = 0, fc = 0;\n\trep(i, n, tot - 2 + 1) {\n\t\tint cnt = C(i - 1, n - 1), ill = x2[i - n];\n\t\tif (m == i - n)\n\t\t\tfb = 1;\n\t\telse if (m < i - n) {\n\t\t\tfb = 1ll * 2 * fb % MOD;\n\t\t\tinc(fb, C(i - n - 1, i - n - m));\n\t\t}\n\t\tif (k == i - n)\n\t\t\tfc = 1;\n\t\telse if (k < i - n) {\n\t\t\tfc = 1ll * 2 * fc % MOD;\n\t\t\tinc(fc, C(i - n - 1, i - n - k));\n\t\t}\n\t\tinc(ill, MOD - fb), inc(ill, MOD - fc);\n\t\tinc(ans, 1ll * cnt * ill % MOD * x3[tot - 2 - i] % MOD);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm p(1 << 19);\n\nll t3[700001];\n\nvoid solve() {\n\tt3[0] = 1;\n\trep(i, 700000)t3[i + 1] = t3[i] * 3 % mod;\n\tint n, m, k; cin >> n >> m >> k;\n\tll ans = 0;\n\tll cur = 0;\n\trep(t, m + k + 1) {\n\t\tll csum = p.comb(t + n-1, t)*t3[m+k-t]%mod;\n\t\tll ncur = 0;\n\t\tif (t == 0) {\n\t\t\tcur = 1;\n\t\t}\n\t\telse {\n\t\t\tint ple = max(t - 1 - k, 0);\n\t\t\tint pri = min(m, t - 1);\n\t\t\tint le = max(t - k, 0);\n\t\t\tint ri = min(m,t);\n\t\t\tncur += cur;\n\t\t\tcur += mod-p.comb(t - 1, ple);\n\t\t\tcur += p.comb(t - 1, pri + 1);\n\t\t\tif (le == ple)cur++;\n\t\t\tif (pri == ri) {\n\t\t\t\t//cur += mod - 1;\n\t\t\t\tcur += mod - p.comb(t - 1, pri);\n\t\t\t\tcur += mod - p.comb(t - 1, pri + 1);\n\t\t\t}\n\t\t\twhile (cur >= mod)cur -= mod;\n\t\t\tncur += cur;\n\t\t\twhile (ncur >= mod)ncur -= mod;\n\t\t\tcur = ncur;\n\t\t\t//cout << t << \" \" << ncur << endl;\n\t\t}\n\t\tans += cur * csum%mod;\n\t\tif (ans >= mod)ans -= mod;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n#define int ll\n\ncs ll mod=1000000007;\n\nll fac[1000001]={1,1},inv[1000001]={1,1},ifac[1000001]={1,1};\n\ninline\nll C(int n,int m){\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint n,m,k,maxn;\n\nsigned main(){\n\t\n\tfor(int re i=2;i<=1000000;++i)\n\tfac[i]=fac[i-1]*i%mod,\n\tinv[i]=(mod-mod/i)*inv[mod%i]%mod,\n\tifac[i]=ifac[i-1]*inv[i]%mod;\n\t\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\t--n;\n\tmaxn=max(n,m+k);\n\tll sum=1,ans=1;\n\tfor(int re i=1;i<=maxn;++i){\n\t\tsum=(sum*2+mod)%mod;\n\t\tif(i>m)sum=(sum+mod-C(i-1,m))%mod;\n\t\tif(i>k)sum=(sum+mod-C(i-1,k))%mod;\n\t\tans=ans*3%mod;\n\t\tans=(ans+C(n+i,i)*sum%mod)%mod;\n\t}\n\tcout<<(ans%mod+mod)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n/* -------------------------------- Template -------------------------------- */\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\ntemplate<typename T> T inf() { assert(false); }\ntemplate<> constexpr int inf<int>() { return 1e9; }\ntemplate<> constexpr ll inf<ll>() { return 1e18; }\ntemplate<> constexpr ld inf<ld>() { return 1e30; }\n\n/* -------------------------------- Library -------------------------------- */\n\nconst int mod = 1000000007;\n\nstruct Mod {\n  int n;\n  Mod () : n(0) {;}\n  Mod (int m) : n(m) {\n    if (n >= mod) n %= mod;\n    else if (n < 0) n = (n % mod + mod) % mod;\n  }\n  operator int() { return n; }\n};\n\nbool operator==(Mod a, Mod b) { return a.n == b.n; }\nMod operator+=(Mod &a, Mod b) { a.n += b.n; if (a.n >= mod) a.n -= mod; return a; }\nMod operator-=(Mod &a, Mod b) { a.n -= b.n; if (a.n < 0) a.n += mod; return a; }\nMod operator*=(Mod &a, Mod b) { a.n = ((long long)a.n * b.n) % mod; return a; }\nMod operator+(Mod a, Mod b) { return a += b; }\nMod operator-(Mod a, Mod b) { return a -= b; }\nMod operator*(Mod a, Mod b) { return a *= b; }\nMod operator^(Mod a, int n) {\n  if (n == 0) return Mod(1);\n  Mod res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\n\nll inv(ll a, ll p) {\n  return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nMod operator/(Mod a, Mod b) { return a * Mod(inv(b, mod)); }\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n  fact[0] = Mod(1); factinv[0] = 1;\n  REP(i,MAX_N-1) {\n    fact[i+1] = fact[i] * Mod(i+1);\n    factinv[i+1] = factinv[i] / Mod(i+1);\n  }\n}\nMod comb(int a, int b) {\n  return fact[a] * factinv[b] * factinv[a-b];\n}\n\n// http://www.everfall.com/paste/id.php?9kb9dxwtbmah\n// pakutte kita.\n\n#define mp make_pair\n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < (int) n; ++i)\n\ntypedef vector <int> vi;\n\nconst ld PI = acos(-1.0);\nconst int MOD = mod;\n\nvoid addmod(int& x, int y, int mod) {\n  (x += y) >= mod && (x -= mod);\n}\n\nint mulmod(int x, int y, int mod) {\n  return x * 1ll * y % mod;\n}\n\nnamespace FFT {\n  struct cd {\n    ld a, b;\n\n    cd(ld a, ld b) : a(a), b(b) {}\n\n    cd(ld x = 0) : a(x), b(0) {}\n\n    ld real() const {\n      return a;\n    }\n\n    void operator += (const cd& other) {\n      a += other.a;\n      b += other.b;\n    }\n\n    void operator -= (const cd& other) {\n      a -= other.a;\n      b -= other.b;\n    }\n\n    void operator *= (const cd& other) {\n      tie(a, b) = mp(a * other.a - b * other.b, a * other.b + b * other.a);\n    }\n\n    friend cd operator * (const cd& x, const cd& y) {\n      cd r = x;\n      r *= y;\n      return r;\n    }\n\n    friend cd operator + (const cd& x, const cd& y) {\n      cd r = x;\n      r += y;\n      return r;\n    }\n\n    friend cd operator - (const cd& x, const cd& y) {\n      cd r = x;\n      r -= y;\n      return r;\n    }\n\n    void operator /= (ld c) {\n      a /= c;\n      b /= c;\n    }\n  };\n\n  typedef vector<cd> vcd;\n\n  const int LOG = 20;\n  const int N = 1 << LOG;\n\n  int rev[N];\n  cd root_[N];\n\n  inline cd root(int k, int n) {\n    return root_[k * (N / n)];\n  }\n\n  void precalc() {\n    rev[0] = 0;\n    int hb = -1;\n    for (int i = 1; i < N; ++i) {\n      if  ((i & (i - 1)) == 0) {\n        ++hb;\n      }\n      rev[i] = rev[i ^ (1 << hb)] | (1 << (LOG - hb - 1));\n    }\n\n    forn(i, N) {\n      ld ang = PI * i * 2.0 / N;\n      root_[i] = cd(cosl(ang), sinl(ang));\n    }\n  }\n\n  void fft_rec(cd* a, int n) {\n    if  (n == 1) {\n      return;\n    }\n\n    fft_rec(a, n / 2);\n    fft_rec(a + n / 2, n / 2);\n\n    forn(k, n / 2) {\n      cd w = root(k, n);\n      cd x = a[k];\n      cd y = w * a[k + n / 2];\n      a[k] = x + y;\n      a[k + n / 2] = x - y;\n    }\n  }\n\n  void fft(vcd& a) {\n    int n = sz(a);\n    vcd na(n, cd(0, 0));\n    forn(i, n) na[i] = a[rev[i]];\n    na.swap(a);\n\n    fft_rec(&a[0], n);\n  }\n\n  void fft_inv(vcd& a) {\n    fft(a);\n    int n = sz(a);\n    reverse(a.begin() + 1, a.end());\n    forn(i, n) {\n      a[i] /= n;\n    }\n  }\n\n  vi mult(const vi& a, const vi& b) {\n    //    TimeStamp t(\"mult\");\n    vcd A(N, cd(0, 0));\n    vcd B(N, cd(0, 0));\n    forn(i, sz(a)) A[i] = a[i];\n    forn(i, sz(b)) B[i] = b[i];\n\n    fft(A);\n    fft(B);\n\n    forn(i, N) A[i] *= B[i];\n\n    fft_inv(A);\n\n    vi c(N, 0);\n    forn(i, N) c[i] = ((ll) (A[i].real() + 0.5)) % MOD;\n\n    return c;\n  }\n\n  vi multmod(const vi& a, const vi& b) {\n    // a = a0 + sqrt(MOD) * a1\n    // a = a0 + base * a1\n    int base = (int) sqrtl(MOD);\n\n    vi a0(sz(a)), a1(sz(a));\n    forn(i, sz(a)) {\n      a0[i] = a[i] % base;\n      a1[i] = a[i] / base;\n      assert(a[i] == a0[i] + base * a1[i]);\n    }\n\n    vi b0(sz(b)), b1(sz(b));\n    forn(i, sz(b)) {\n      b0[i] = b[i] % base;\n      b1[i] = b[i] / base;\n      assert(b[i] == b0[i] + base * b1[i]);\n    }\n\n    vi a01 = a0;\n    forn(i, sz(a)) {\n      addmod(a01[i], a1[i], MOD);\n    }\n\n    vi b01 = b0;\n    forn(i, sz(b)) {\n      addmod(b01[i], b1[i], MOD);\n    }\n\n    vi C = mult(a01, b01);  // 1\n\n    vi a0b0 = mult(a0, b0); // 2\n    vi a1b1 = mult(a1, b1); // 3\n\n    vi mid = C;\n    forn(i, N) {\n      addmod(mid[i], -a0b0[i] + MOD, MOD);\n      addmod(mid[i], -a1b1[i] + MOD, MOD);\n    }\n\n    vi res = a0b0;\n    forn(i, N) {\n      addmod(res[i], mulmod(base, mid[i], MOD), MOD);\n    }\n\n    base = mulmod(base, base, MOD);\n    forn(i, N) {\n      addmod(res[i], mulmod(base, a1b1[i], MOD), MOD);\n    }\n\n    return res;\n  }\n};\n\n/* ---------------------------------- Main ---------------------------------- */\n\n// O(NlogN) no convolution mottenai. kaku kara chotto matte ne.\n\nMod threes[MAX_N];\n\nint main() {\n  init();\n  threes[0] = 1;\n  REP(i,MAX_N-1) threes[i+1] = threes[i] * Mod(3);\n  int N, M, K;\n  cin >> N >> M >> K;\n\n  vector<int> invsj(1 << 20, 0), invsk(1 << 20, 0);\n  for (int i = 0; i <= M; ++i) invsj[i] = factinv[i];\n  for (int i = 0; i <= K; ++i) invsk[i] = factinv[i];\n  FFT::precalc();\n  vector<int> prod = FFT::multmod(invsj, invsk);\n  // REP(i,20) cout << prod[i] << \" \"; cout << endl;\n  // REP(i,20) cout << invsj[i] << \" \"; cout << endl;\n  // REP(i,20) cout << invsk[i] << \" \"; cout << endl;\n\n  Mod res = 0;\n  REP(i,M+K+1) {\n    Mod val = fact[i+N-1] * factinv[N-1] * Mod(prod[i])\n      * threes[M+K-i];\n    res += val;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nconst int MAXN = 1000100;\n\nMint fact[MAXN];\nMint ifact[MAXN];\nMint pow2[MAXN];\nMint pow3[MAXN];\n\nvoid precalc() {\n   fact[0] = 1;\n   for (int i = 1; i < MAXN; ++i) fact[i] = fact[i - 1] * i;\n   ifact[MAXN - 1] = fact[MAXN - 1].inv();\n   for (int i = MAXN - 1; i > 0; --i) ifact[i - 1] = ifact[i] * i;\n   pow2[0] = pow3[0] = 1;\n   for (int i = 1; i < MAXN; ++i) {\n      pow2[i] = pow2[i - 1] * 2;\n      pow3[i] = pow3[i - 1] * 3;\n   }\n}\n\nMint C(int N, int K) {\n   if (N < K || K < 0) return Mint(0);\n   return fact[N] * ifact[K] * ifact[N - K];\n}\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   precalc();\n   int N, M, K;\n   cin >> N >> M >> K;\n   vector<Mint> dp(M + K + 1);\n   dp[0] = 1;\n   for (int i = 1; i <= M + K; ++i) {\n      dp[i] = dp[i - 1] * 2;\n      if (i > M) dp[i] -= C(i - 1, M);\n      if (i > K) dp[i] -= C(i - 1, K);\n   }\n   Mint ans = 0;\n   for (int i = 0; i <= M + K; ++i) {\n      ans += C(N - 1 + i, i) * dp[i] * pow3[M + K - i];\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=900005,P=1e9+7;\n\nint n,m,k,fac[N],ifac[N],p3[N],ans;\ninline int fpow(int a,int t){static int r;for(r=1;t;t>>=1,a=(ll)a*a%P)if(t&1)r=(ll)r*a%P;return r;}\ninline int C2(int n,int a,int b){return (ll)fac[n]*ifac[a]%P*ifac[b]%P*ifac[n-a-b]%P;}\n\nint main(){\n\tcin>>n>>m>>k;\n\tfac[0]=p3[0]=1;\n\tfor(int i=1;i<=n+m+k;i++)fac[i]=(ll)fac[i-1]*i%P,p3[i]=p3[i-1]*3u%P;\n\tifac[n+m+k]=fpow(fac[n+m+k],P-2);\n\tfor(int i=n+m+k;i>=1;i--)ifac[i-1]=(ll)ifac[i]*i%P;\n\tfor(int i=0;i<=m+k;i++)\n\t\tfor(int j=0;j<=i;j++)if(j<=m&&i-j<=k)\n\t\t\tans=(ans+(ll)p3[m+k-i]*C2(n+i-1,n-1,j))%P;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n/* -------------------------------- Template -------------------------------- */\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\ntemplate<typename T> T inf() { assert(false); }\ntemplate<> constexpr int inf<int>() { return 1e9; }\ntemplate<> constexpr ll inf<ll>() { return 1e18; }\ntemplate<> constexpr ld inf<ld>() { return 1e30; }\n\n/* -------------------------------- Library -------------------------------- */\n\nconst int mod = 1000000007;\n\nstruct Mod {\n  int n;\n  Mod () : n(0) {;}\n  Mod (int m) : n(m) {\n    if (n >= mod) n %= mod;\n    else if (n < 0) n = (n % mod + mod) % mod;\n  }\n  operator int() { return n; }\n};\n\nbool operator==(Mod a, Mod b) { return a.n == b.n; }\nMod operator+=(Mod &a, Mod b) { a.n += b.n; if (a.n >= mod) a.n -= mod; return a; }\nMod operator-=(Mod &a, Mod b) { a.n -= b.n; if (a.n < 0) a.n += mod; return a; }\nMod operator*=(Mod &a, Mod b) { a.n = ((long long)a.n * b.n) % mod; return a; }\nMod operator+(Mod a, Mod b) { return a += b; }\nMod operator-(Mod a, Mod b) { return a -= b; }\nMod operator*(Mod a, Mod b) { return a *= b; }\nMod operator^(Mod a, int n) {\n  if (n == 0) return Mod(1);\n  Mod res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\n\nll inv(ll a, ll p) {\n  return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nMod operator/(Mod a, Mod b) { return a * Mod(inv(b, mod)); }\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n  fact[0] = Mod(1); factinv[0] = 1;\n  REP(i,MAX_N-1) {\n    fact[i+1] = fact[i] * Mod(i+1);\n    factinv[i+1] = factinv[i] / Mod(i+1);\n  }\n}\nMod comb(int a, int b) {\n  return fact[a] * factinv[b] * factinv[a-b];\n}\n\n\n/* ---------------------------------- Main ---------------------------------- */\n\n// O(NlogN) no convolution mottenai. kaku kara chotto matte ne.\n\nMod threes[MAX_N];\n\nint main() {\n  init();\n  threes[0] = 1;\n  REP(i,MAX_N-1) threes[i+1] = threes[i] * Mod(3);\n  int N, M, K;\n  cin >> N >> M >> K;\n  Mod res = 0;\n  REP(i,M+K+1) {\n    REP(j,M+1) {\n      int k = i - j;\n      if (k < 0 || k > K) continue;\n      Mod val = fact[i+N-1] * factinv[N-1] * factinv[j] * factinv[k]\n        * threes[(M-j) + (K-k)];\n      res += val;\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(2)\n//#pragma GCC optimize(3)\n#include <bits/stdc++.h>\n#define int long long\n#define mod 1000000007\n#define N 900005\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1 == p2)?EOF:*p1++)\nusing namespace std ;\n//char buf[(1 << 22)] , *p1 = buf , *p2 = buf ;\nint add (int x , int y) { return x + y >= mod ? x + y - mod : x + y ; }\nint sub (int x , int y) { return x - y < 0 ? x - y + mod : x - y ; }\ninline int read ()\n{\n    char c = getchar () ; int x = 0 , f = 1 ;\n    while (c < '0' || c > '9') { if (c == '-') f = -1 ; c = getchar () ; }\n    while (c >= '0' && c <= '9'){ x = x * 10 + c - '0' ; c = getchar () ; }\n    return x * f ;\n}\nint fast (int a , int b)\n{\n    int ret = 1 ;\n    while (b)\n    {\n        if (b & 1) ret = ret * a % mod ;\n        a = a * a % mod ;\n        b >>= 1 ;\n    }\n    return ret ;\n}\nint fac[N] , iv[N] , three[N] , n , m , k , ans , x = 1 ;\nint getc (int a , int b)\n{\n    // if (a < b || a < 0 || b < 0) return 0 ;\n    // if (b == 0 || a == b) return 1 ;\n    return (fac[a] * iv[a - b] % mod * iv[b] % mod) % mod ;\n}\nsigned main ()\n{\n//    freopen (\".in\" , \"r\" , stdin) ; freopen (\".out\" , \"w\" , stdout) ;\n    n = read () , m = read () , k = read () ;\n    fac[0] = three[0] = 1 ;\n    for (int i = 1 ; i < N ; i ++)\n    {\n        fac[i] = fac[i - 1] * i % mod ;\n        three[i] = three[i - 1] * 3 % mod ;\n    }\n    for (int i = 0 ; i < N ; i ++)\n    {\n        iv[i] = fast (fac[i] , mod - 2) ;\n    }\n    if (m < k) swap (m , k) ;\n    for (int i = 0 ; i <= m + k ; i ++)\n    {\n        ans = add (ans , getc (n + i - 1 , n - 1) * three[m + k - i] % mod * x % mod) ;\n        if (i < k) x = x * 2 % mod ;\n        else if (i < m) x = sub (x * 2 % mod , getc (i , k)) ;\n        else x = sub (x * 2 % mod , getc (i , k) + getc (i , m)) ;\n    }\n    cout << (ans % mod + mod) % mod ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) { os << \"[ \"; \n\tfor(auto v:V)os << v << \" \"; return os << \"]\";\n}\ntemplate<class T> ostream& operator<<(ostream &os, set<T> S){ os << \"{ \"; \n\tfor(auto s:S) os<<s<<\" \";  return os<<\"}\"; \n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os<<\"(\"<<P.first<<\",\"<< P.second << \")\";\n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, map<L,R> M) {\n\tos<<\"{ \";for(auto m:M)os<<\"(\"<<m.F<<\":\"<<m.S<<\")\";\n\treturn os<<\"}\";\n}\n#define cerr cout\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define For(i,n) for(int i=0;i<(int)n;++i)\n#define Rev(i,n) for(int i=(int)n-1;i>=0;--i)\n#define Rep(i,n) for(int i=1;i<=(int)n;++i)\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\ntypedef vector<pii> vpii;\n#define fio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n\nconst int N = 3e3 + 100;\nconst int mod = 1e9 + 7;\n\ninline int mul(int a , int b){\n\treturn a*1ll*b%mod;\n}\ninline int add(int a , int b){\n\ta += b;\n\tif(a >= mod) a -= mod;\n\treturn a;\n}\ninline int power(int x, int y){\n\tint res = 1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres = mul(res , x);\n\t\tx = mul(x , x);\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint fac[N] , inv[N];\nint pr[N];\n\nint nCr(int n , int r){\n\tif(r < 0 || r > n) return 0;\n\treturn mul(fac[n] , mul(inv[r] , inv[n-r]));\n}\n\nint main(){\n\tfio; cout<<fixed<<setprecision(25);\t\n\tfac[0] = 1;\n\tpr[0] = 1;\n\tfor(int i = 1;i< N ; ++i){\n\t\tpr[i] = mul(pr[i-1] , 3);\n\t\tfac[i] = mul(fac[i-1] , i);\n\t}\n\tinv[N-1] = power(fac[N-1] , mod-2);\n\tfor(int i = N-2 ; i >= 0 ; --i){\n\t\tinv[i] = mul(inv[i+1] , i+1);\n\t}\n\tassert(inv[0] == 1);\n\tint n , m , k; cin >> n >> m >> k;\n\tint ans = 0;\n\tfor(int i = 0;i <= m ; ++i){\n\t\tfor(int j = 0;j <= k ; ++j){\n\t\t\tans = add(ans , mul( mul(mul( 1 , 1)  , mul(nCr(n-1+i+j , n-1) , nCr(i+j , i) )) , pr[m-i+k-j]  ) );\n\t\t\t// trace(i , j , ans);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\nusing namespace std;\n\nconst int N=9e5+5;\n\nll n,m,k;\nll fac[N],inv[N],p[N]; \n\nll ksm(ll a,ll b){\n    ll ans=1;\n    while(b){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod,b>>=1;\n    }\n    return ans ;\n}\n\nll C(ll x,ll y){\n    return fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nint main(){\n    scanf(\"%d%d%d\",&n,&m,&k);n--;\n    fac[0]=p[0]=inv[0]=1ll;\n    for(int i=1;i<N;i++) fac[i]=fac[i-1]*i%mod,p[i]=p[i-1]*3ll%mod;\n    inv[N-1]=ksm(fac[N-1],mod-2);\n    for(int i=N-2;i;i--) inv[i]=inv[i+1]*(i+1)%mod;\n    ll ans=0,x=1ll;\n    for(int i=0;i<=m+k;i++){\n        ans=( ans+C(n+i,n)*p[m+k-i]%mod*x)%mod;\n        if(i<k) x=x*2ll%mod;\n        else if(i<m) x=(x*2ll-C(i,k))%mod;\n        else x=(x*2ll-C(i,k)-C(i,m))%mod;\n    }\n    printf(\"%lld\\n\",(ans+mod)%mod) ;\n    return 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n\n#include <cassert>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\ninline void ModMul(int& x, int y) {\n    x = (1LL * x * y) % MOD;\n}\n\ninline int GetModMul(int x, int y) {\n    ModMul(x, y);\n    return x;\n}\n\ninline void ModSum(int& x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n    if (x < 0) {\n        x += MOD;\n    }\n}\n\ninline int GetModSum(int x, int y) {\n    ModSum(x, y);\n    return x;\n}\n\ninline int GetBinaryPow(int x, int pw) {\n    int r = 1;\n    while (pw > 0) {\n        if (pw & 1) {\n            ModMul(r, x);\n        }\n        ModMul(x, x);\n        pw >>= 1;\n    }\n    return r;\n}\n\ninline int GetInv(int x) {\n    return GetBinaryPow(x, MOD - 2);\n}\n\nconst int MAX_N = 3e5;\nconst int MAX_FACT = 2 * MAX_N + 100;\n\nvector<int> fact(MAX_FACT);\nvector<int> invFact(MAX_FACT);\n\nvoid BuildFact() {\n    fact[0] = 1;\n    for (int i = 1; i < MAX_FACT; ++i) {\n        fact[i] = fact[i - 1];\n        ModMul(fact[i], i);\n    }\n    for (int i = 0; i < MAX_FACT; ++i) {\n        invFact[i] = GetInv(fact[i]);\n    }\n}\n\ninline int GetC(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n    int r = fact[n];\n    ModMul(r, invFact[k]);\n    ModMul(r, invFact[n - k]);\n    return r;\n}\n\ninline int GetCoeff(int n, int m) {\n    if (n == 0) {\n        return 0;\n    }\n    return GetC(n + m - 1, n - 1);\n}\n\nint main() {\n    BuildFact();\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> pw3(m + k + 1);\n    pw3[0] = 1;\n    for (int i = 1; i <= m + k; ++i) {\n        pw3[i] = pw3[i - 1];\n        ModMul(pw3[i], 3);\n    }\n\n    int l = 0;\n    int r = 0;\n    int sum = 1;\n\n    int result = 0;\n    for (int s = 0; s <= m + k; ++s) {\n        const int cl = max(0, s - k);\n        const int cr = min(m, s);\n\n        if (l == r) {\n            sum = 0;\n            for (int i = cl; i <= cr; ++i) {\n                ModSum(sum, GetC(s, i));\n            }\n            l = cl;\n            r = cr;\n        } else {\n            ModMul(sum, 2);\n            ModSum(sum, -GetC(s - 1, l));\n            ModSum(sum, -GetC(s - 1, r));\n            ++l;\n\n            while (r < cr) {\n                ModSum(sum, GetC(s, r + 1));\n                ++r;\n            }\n            while (l > cl) {\n                ModSum(sum, GetC(s, l - 1));\n                --l;\n            }\n\n            while (r > cr) {\n                ModSum(sum, -GetC(s, r));\n                --r;\n            }\n            while (l < cl) {\n                ModSum(sum, -GetC(s, l));\n                ++l;\n            }\n        }\n\n        int curResult = GetC(s + (n - 1), n - 1);\n        ModMul(curResult, pw3[m + k - s]);\n        ModMul(curResult, sum);\n\n        ModSum(result, curResult);\n    }\n\n    cout << result << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,M,K,fac[MAXN],invfac[MAXN],pw[MAXN];\nint s[MAXN];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint C(int n,int m) {\n    if(n < m) return 0;\n    else return mul(fac[n],mul(invfac[m],invfac[n - m]));\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n\tif(c & 1) res = mul(res,t);\n\tt = mul(t,t);\n\tc >>= 1;\t\n    }\n    return res;\n}\nvoid Solve() {\n    read(N);read(M);read(K);\n    fac[0] = 1;\n    for(int i = 1 ; i <= 1000000 ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[1000000] = fpow(fac[1000000],MOD - 2);\n    for(int i = 999999 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    pw[0] = 1;\n    for(int i = 1 ; i <= 1000000 ; ++i) pw[i] = mul(pw[i - 1],3);\n    int l = 0,r = 0;s[0] = 1;\n    for(int i = 1 ; i <= M + K ; ++i) {\n\tint tmp = inc(mul(s[i - 1],2),inc(C(i - 1,r + 1),MOD - C(i - 1,l)));\n\t++r;++l;\n\twhile(r + 1 <= i && r + 1 <= M) {update(tmp,C(i,r + 1));++r;}\n\twhile(r > M) {update(tmp,MOD - C(i,r));--r;}\n\twhile(i - l > K) {update(tmp,MOD - C(i,l));++l;}\n\twhile(i - (l - 1) <= K && (l - 1) >= 0) {update(tmp,C(i,l - 1));--l;}\n\ts[i] = tmp;\n    }\n    int ans = 0;\n    for(int i = 0 ; i <= M + K ; ++i) {\n\tint t = mul(C(N - 1 + i,N - 1),s[i]);\n\tt = mul(t,pw[M + K - i]);\n\tupdate(ans,t);\n    }\n    out(ans);enter;\n}\n\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define F(i,a,b) for(int i=a;i<=(b);++i)\n#define LL long long\n#define Mod 1000000007\n\nLL N,M,K,Ans,P3[600001];\nLL Frc[900001],Fnv[900001];\n\ninline LL C(int N,int M){\n\tif( M<0 || M>N ) return 0ll;\n\treturn Frc[N]*Fnv[M]%Mod*Fnv[N-M]%Mod;\n}\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&N,&M,&K);\n\t\n\tP3[0]=1;\n\tF(i,1,M+K) P3[i]=P3[i-1]*3%Mod;\n\t\n\tFrc[0]=1;\n\tF(i,1,N+M+K) Frc[i]=Frc[i-1]*i%Mod;\n\t\n\tFnv[0]=Fnv[1]=1;\n\tF(i,2,N+M+K) Fnv[i]=(Mod-Mod/i)*Fnv[Mod%i]%Mod;\n\tF(i,2,N+M+K) Fnv[i]=Fnv[i-1]*Fnv[i]%Mod;\n\t\n\tLL Thi=1;\n\tF(i,N,N+M+K){\n\t\tAns=(Ans+P3[N+M+K-i]*C(i-1,N-1)%Mod*Thi)%Mod;\n\t\tThi=(2*Thi-C(i-N,i-N-K)-C(i-N,M)+2*Mod)%Mod;\n\t}\n\t\n\tprintf(\"%lld\",Ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\n\nint n,m,k,Fac[600005],Inv[600005];\nconst int p=1000000007;\n\ninline ll C(const int n,const int m){return (ll)Fac[n]*Inv[m]%p*Inv[n-m]%p;}\ninline ll Pow(ll a,ll b,ll s=1){for(;b;b>>=1,a=a*a%p)if(b&1)s=s*a%p;return s%p;}\n\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&k),--n;\n    ll Sum=1,Ans=1;\n    for(int i=Fac[0]=1;i<=600000;++i)Fac[i]=(ll)Fac[i-1]*i%p;\n    Inv[600000]=Pow(Fac[600000],p-2);\n    for(int i=600000;i>=1;--i)Inv[i-1]=(ll)Inv[i]*i%p;\n    for(int i=1;i<=m+k;++i)\n    {\n        Sum=(Sum<<1)%p;\n        if(i>m)Sum=(Sum-C(i-1,m)+p)%p;\n        if(i>k)Sum=(Sum-C(i-1,k)+p)%p;\n        Ans=(Ans*3+C(n+i,i)*Sum)%p;\n    }\n    printf(\"%d\\n\",(int)Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MOD 1000000007\n\nusing namespace std;\n\nint Fact[1000005],P3[1000005],Inv[1000005],Dp[1000005];\n\nint put(int a, int b)\n{\n    int rez=1;\n    for(int i=0; (1<<i)<=b; i++)\n    {\n        if((1<<i)&b)\n            rez=(1LL*rez*a)%MOD;\n        a=(1LL*a*a)%MOD;\n    }\n    return rez;\n}\n\nint comb(int n, int k)\n{\n    if(k>n)\n        return 0;\n\n    int rez=(1LL*Fact[n]*Inv[k])%MOD;\n    rez=(1LL*rez*Inv[n-k])%MOD;\n    return rez;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n    int n,m,k;\n    cin>>n>>m>>k;\n\n    Fact[0]=1;\n    P3[0]=1;\n    for(int i=1; i<=n+m+k+1; i++)\n    {\n        Fact[i]=(1LL*Fact[i-1]*i)%MOD;\n        P3[i]=(3LL*P3[i-1])%MOD;\n    }\n\n    Inv[n+m+k+1]=put(Fact[n+k+k+1],MOD-2);\n    for(int i=n+m+k; i>=0; i--)\n        Inv[i]=(1LL*Inv[i+1]*(i+1))%MOD;\n\n    Dp[0]=1;\n    for(int i=1; i<=m+k; i++)  //nr de moduri de a pune B si C a.i. sa nu castige nici b nici c\n    {\n        Dp[i]=(Dp[i-1]-comb(i-1,m)+MOD)%MOD; //pun pe poz i B\n        Dp[i]=(1LL*Dp[i]+Dp[i-1]-comb(i-1,k)+MOD)%MOD; //pun pe poz i C\n    }\n\n    int rez=0;\n    for(int i=n+1; i<=n+m+k+1; i++)\n    {\n        int val=comb(i-2,n-1); //prima si ultima val e a\n        val=(1LL*val*P3[n+m+k+1-i])%MOD;\n        val=(1LL*val*Dp[i-n-1])%MOD;\n        rez=(rez+val)%MOD;\n    }\n    cout<<rez<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=(3e5+10)*3,MOD=1e9+7;\nll res=0,cur=1;\nint n,m,k,fac[MAXN],inv[MAXN];\n\nll quick_pow(ll a,ll b)\n{\n\tll ret=1;\n\tfor(;b;b>>=1,a=a*a%MOD)\n\t\tif(b&1) ret=ret*a%MOD;\n\treturn ret;\n}\nint C(int a,int b)\n{if(a<b||b<0) return 0;return 1ll*fac[a]*inv[b]%MOD*inv[a-b]%MOD;}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfac[0]=1;\n\tfor(int i=1;i<MAXN;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[MAXN-1]=quick_pow(fac[MAXN-1],MOD-2);\n\tfor(int i=MAXN-2;i>=0;i--)\n\t\tinv[i]=1ll*inv[i+1]*(i+1)%MOD;\n\t\n\tfor(int i=n;i<=n+m+k;i++)\n\t\t(res+=C(i-1,n-1)*cur%MOD*quick_pow(3,n+m+k-i)%MOD)%=MOD,\n\t\tcur=(2*cur-C(i-n,m)+MOD-C(i-n,i-n-k)+MOD)%MOD;\n\tprintf(\"%lld\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define N 300005\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nll up,n,m,k;\nll ans=0,fac[N*3],ifac[N*3],mul[N*3];\ninline ll calc(int a,int b){return fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\ninline ll ksm(ll x,int p){\n\tll ret=1;\n\twhile(p){\n\t\tif(p&1)ret=ret*x%mod;\n\t\tx=x*x%mod,p>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n>>m>>k,up=n+m+k,fac[0]=mul[0]=ifac[1]=ifac[0]=1;\n\tfor(ll i=2;i<=up;++i)ifac[i]=(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(ll i=1;i<=up;++i)mul[i]=mul[i-1]*3%mod,(ifac[i]*=ifac[i-1])%=mod,fac[i]=fac[i-1]*i%mod;\n\tif(m<k)m^=k,k^=m,m^=k;\n\tfor(ll i=0,j=1;i<=m+k;++i){\n\t\t(ans+=calc(n-1+i,n-1)*mul[m+k-i]%mod*j%mod)%=mod;\n\t\tif(i<k)(j<<=1)%=mod;\n\t\telse if(i>=m)(j+=j-calc(i,k)-calc(i,i-m))%=mod;\n\t\telse (j+=j-calc(i,k))%=mod;\n\t}\n\tcout<<(ans+mod)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nconst int kN = 1000000 + 5;\nconst int MOD = (int)1e9 + 7;\nint Inv[kN], Finv[kN], F[kN], n, m, k;\nint pascal[kN];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return F[a] * 1LL * Finv[b] % MOD * Finv[a - b] % MOD;\n}\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nint power(int a, int b, int p)\n{\n    int ret = 1;\n    for ( ; b; b >>= 1, a = a * 1LL * a % MOD)\n        if (b & 1)\n            ret = ret * 1LL * a % MOD;\n    return ret;\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kN; ++ i)\n        Inv[i] = (MOD - MOD / i) * 1LL * Inv[MOD % i] % MOD;\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kN; ++ i) {\n        F[i] = F[i - 1] * 1LL * i % MOD;\n        Finv[i] = Finv[i - 1] * 1LL * Inv[i] % MOD;\n    }\n    scanf(\"%d%d%d\", &n, &m, &k);\n    pascal[0] = 1;\n    for (int i = 1; i <= m + k; ++ i) {\n        pascal[i] = (pascal[i - 1] << 1) % MOD;\n        if (i >= m + 1) add(pascal[i], MOD - binom(i - 1, m));\n        if (i >= k + 1) add(pascal[i], MOD - binom(i - 1, i - (k + 1)));\n    }\n    int result = 0;\n    int t = n + m + k;\n    for (int i = n; i <= t; ++ i) {\n        add(result, binom(i - 1, n - 1) * 1LL * power(3, t - i, MOD) % MOD * pascal[i - n] % MOD);\n    }\n    printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<list>\n#include<set>\n#include<string>\n#include <iomanip>\n#include<math.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll M = 1000000007;\n\nvector<ll> fac(1000001); //n!(mod M)\nvector<ll> ifac(1000001); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n) {\n\tll ans = 1;\n\twhile (n != 0) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb() {\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 1000000; i++) {\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n\tifac[1000000] = mpow(fac[1000000], M - 2);\n\tfor (ll i = 1000000; i > 0; i--) {\n\t\tifac[i - 1] = ifac[i] * i%M;\n\t}\n}\nll comb(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a) {\n\tlong long b = M, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0) u += M;\n\treturn u;\n}\n\nstruct Mo\n{\n  vector< int > left, right, order;\n  vector< bool > v;\n  int width;\n  int nl, nr, ptr;\n\n  Mo(int n) : width((int) sqrt(n)), nl(0), nr(0), ptr(0), v(n) {}\n\n  void insert(int l, int r) /* [l, r) */\n  {\n    left.push_back(l);\n    right.push_back(r);\n  }\n\n  /* ソート */\n  void build()\n  {\n    for(int i=0;i<left.size();i++)\n\t\torder.push_back(i);\n    sort(begin(order), end(order), [&](int a, int b)\n    {\n      if(left[a] / width != left[b] / width) return left[a] < left[b];\n      return right[a] < right[b];\n    });\n  }\n\n  /* クエリを 1 つぶんすすめて, クエリのidを返す */\n  int process()\n  {\n    if(ptr == order.size()) return (-1);\n    const auto id = order[ptr];\n    while(nl > left[id]) ldistribute(--nl,nr);\n    while(nr < right[id]) rdistribute(nr++,nl);\n    while(nl < left[id]) ldistribute(nl++,nr);\n    while(nr > right[id]) rdistribute(--nr,nl);\n    return (order[ptr++]);\n  }\n\n  inline void ldistribute(int l,int r)\n  {\n    v[l].flip();\n    if(v[l]) ladd(r,l);\n    else ldel(r,l);\n  }\n\n  inline void rdistribute(int r,int l)\n  {\n    v[r].flip();\n    if(v[r]) radd(r,l);\n    else rdel(r,l);\n  }\n\n  void ladd(int n,int k);\n\n  void radd(int n,int b);\n  \n  void ldel(int n,int k);\n  \n  void rdel(int n,int b);\n};\n\nll sum=1;\n\nvoid Mo::ladd(int n,int k){\n\tsum+=M-comb(n,k+1);\n\tsum%=M;\n}\n\nvoid Mo::ldel(int n,int k){\n\tsum+=comb(n,k+1);\n\tsum%=M;\n}\n\nvoid Mo::radd(int n,int b){\n\tsum*=2;\n\tsum%=M;\n\tsum+=M-comb(n,b);\n\tsum%=M;\n}\n\nvoid Mo::rdel(int n,int b){\n\tsum+=comb(n,b);\n\tsum%=M;\n\tsum*=ifac[2];\n\tsum%=M;\n}\n\nint main(){\n\tsetcomb();\n\tll n,m,k,val[1222222],ans=0,i,zero=0;\n\tcin>>n>>m>>k;\n\tMo mo(m+k+1);\n\tfor(i=0;i<(m+k+1)*2;i++)\n\t\tval[i]=1;\n\tfor(i=0;i<=m+k;i++){\n\t\tll bot=m-min(m,i),top=m-max(zero,i-k);\n\t\tmo.insert(top,m+k-i);\n\t\tif(bot==0){\n\t\t\tval[i*2+1]=0;\n\t\t\tmo.insert(0,0);\n\t\t}\n\t\telse{\n\t\t\tmo.insert(bot-1,m+k-i);\n\t\t}\n\t}\n\tmo.build();\n\tfor(i=0;i<(m+k+1)*2;i++){\n\t\tll idx=mo.process();\n\t\tif(val[idx])\n\t\t\tval[idx]=sum;\n\t}\n\tfor(i=0;i<=m+k;i++){\n\t\tll p=mpow(3,i);\n\t\tp*=comb(n-1+m+k-i,n-1);\n\t\tp%=M;\n\t\tp*=(M+val[i*2]-val[i*2+1])%M;\n\t\tp%=M;\n\t\tans+=p;\n\t\tans%=M;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int N=9e5+5,mmm=1e9+7;\nlong long n,m,kni,sum,f[N],pv[N],q[N];\nint cmp(int n,int m);\nint main()\n{\n\tcin>>n>>m>>kni; \n\tn=n-1;\n    q[0]=1;\n\tq[1]=3;\n\tf[0]=pv[0]=f[1]=pv[1]=1; \n    for(int i=2;i<N;i++) pv[i]=(long long)pv[mmm%i]*(mmm-mmm/i)%mmm;\n    for(int i=2;i<N;i++)\n    {\n        q[i]=q[i-1]*3ll;f[i]=(long long)f[i-1]*i%mmm; pv[i]=(long long)pv[i-1]*pv[i]%mmm;\n    }\n    if(m<kni) {int t;t=m;m=kni;kni=t;}\n    for(int i=0,j=1;i<=m+kni;i++)\n    {\n        sum=(sum+(long long)cmp(n+i,n)*q[m+kni-i]%mmm*j)%mmm;\n        if (i<kni) j=j*2%mmm; else if (i>=m) j=(j*2ll-cmp(i,kni)-cmp(i,i-m))%mmm;\n        else \n\t\tj=(j*2ll-cmp(i,kni))%mmm;\n    }\n    if(sum<0) sum=mmm+sum;\n    printf(\"%d\\n\",sum);\n    return 0;\n}\nint cmp(int n,int m){return(long long) f[n]*pv[m]%mmm*pv[n-m]%mmm;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pw(x) (1ll << (x))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,l,r) for(int i=(l);i<(r);++i)\n#define per(i,l,r) for(int i=(r)-1;i>=(l);--i)\n#define dd(x) cout << #x << \" = \" << (x) << \", \"\n#define de(x) cout << #x << \" = \" << (x) << \"\\n\"\n#define endl \"\\n\"\n\n//-----\nconst int N = 1e6 + 7, MOD = 1e9 + 7;\nvoid inc(int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\nint add(int a, int b) { if ((a += b) >= MOD) a -= MOD; return a; }\nint mul(int a, int b) { return ll(a) * b % MOD; }\nint qpow(int a, int b) { int r = 1; for (; b; b >>= 1) { if (b & 1) r = mul(r, a); a = mul(a, a); } return r; }\nint n, m, k;\nint jc[N], ijc[N], pw3[N];\nvoid ini() {\n\tjc[0] = 1; rep(i, 1, N) jc[i] = mul(jc[i - 1], i);\n\tijc[N - 1] = qpow(jc[N - 1], MOD - 2); per(i, 0, N - 1) ijc[i] = mul(ijc[i + 1], i + 1);\n\tpw3[0] = 1; rep(i, 1, N) pw3[i] = mul(pw3[i - 1], 3);\n}\nint C(int a, int b) { return mul(jc[a], mul(ijc[b], ijc[a - b])); }\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tini();//rep(i, 0, 10) rep(j, 0, i + 1) cout << C(i, j) << \" \\n\"[j == i];\n\tcin >> n >> m >> k;\n\tint g = 0, inv2 = qpow(2, MOD - 2);\n\trep(j, 0, k + 1) inc(g, mul(pw3[k - j], C(j + n - 1, j)));\n\tint ans = 0;\n\trep(i, 0, m + 1) {\n\t\tinc(ans, mul(pw3[m - i], mul(C(i + n - 1, i), g)));\n\t\tg = mul(g, 3);\n\t\tinc(g, MOD - C(i + k + n, i + n));\n\t\tg = mul(g, inv2);\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble PI=3.141592653589793;\n\ncomplex <double> dftn[2100007];\ncomplex <double> dfts[2100007];\n\ncomplex <double> a1[2100007];\ncomplex <double> b1[2100007];\ncomplex <double> a2[2100007];\ncomplex <double> b2[2100007];\n\ndouble cosi[2100007];\ncomplex <double> omega[2100007];\n\ninline int potenga(int v)\n{\n    for (int i=1; 1; i<<=1)\n    {\n        if (i>=v)\n        {\n            return i;\n        }\n    }\n}\n\ninline void dft(int n, int kier)\n{\n    int n2=n-1;\n    int s=0;\n    int p;\n    int g;\n\n    for (int i=2; i<=n; i<<=1)\n    {\n\n        for (int j=0; j<n; j++)\n        {\n            dfts[j]=dftn[j];\n            dftn[j]=0;\n        }\n\n        p=n/i;\n\n        if (kier)\n        {\n            g=0;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=j+1;\n                    s=0;\n                }\n            }\n        }\n        else\n        {\n            g=n;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=n-j-1;\n                    s=0;\n                }\n            }\n        }\n    }\n}\n\nvoid licz_omegi(int n1)\n{\n    double kat=2.0*PI/n1;\n    int n2=n1-1;\n    int dod=3*n1/4;\n\n    for (int i=0; i<=n1; i++)\n    cosi[i]=cos(kat*i);\n    for (int i=0; i<=n1; i++)\n    omega[i]=complex <double> (cosi[i], cosi[(i+dod)&n2]);\n}\n\nvector <long long> fft_dokladne(vector <long long> &jed, vector <long long> &dwa)\n{\n    int n1=potenga(jed.size()+dwa.size());\n\n    licz_omegi(n1);\n\n    long long M=32000;\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]/M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a1[i]=dftn[i];\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]%M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b1[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]/M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a2[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]%M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b2[i]=dftn[i];\n\n    vector <long long> ret;\n    for (int i=0; i<n1; i++)\n    ret.push_back(0);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=(llround(dftn[i].real()/n1)%1000000007)*M*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*b2[i]+b1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1)*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=b1[i]*b2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1);\n\n    for (int i=0; i<ret.size(); i++)\n        ret[i]%=1000000007;\n\n    return ret;\n}\n\nint n, m, k;\n\nint s;\n\nlong long mod=1000000007;\n\nlong long sil[1000007];\nlong long odw[1000007];\nlong long do3[1000007];\n\nvector <long long> d1, d2, d3;\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n    long long wyk=mod-2;\n    while(wyk)\n    {\n        if (wyk&1)\n        {\n            a*=b;\n            a%=mod;\n        }\n        b*=b;\n        b%=mod;\n        wyk>>=1;\n    }\n    return a;\n}\n\ninline long long komb(int a, int b)\n{\n    if (b<0 || b>a)\n        return 0;\n    return (sil[a]*((odw[b]*odw[a-b])%mod))%mod;\n}\n\ninline long long komz(int a, int b)\n{\n    return komb(a+b-1, b);\n}\n\nint main()\n{\n    //n=300000;\n    //m=300000;\n    //k=300000;\n    scanf(\"%d%d%d\", &n, &m, &k);\n    s=n+m+k;\n    sil[0]=1;\n    odw[0]=1;\n    do3[0]=1;\n    for (int i=1; i<=s; i++)\n        sil[i]=(sil[i-1]*i)%mod;\n    odw[s]=dziel(1, sil[s]);\n    for (int i=s-1; i; i--)\n        odw[i]=(odw[i+1]*(i+1))%mod;\n    for (int i=1; i<=m+k; i++)\n        do3[i]=(do3[i-1]*3)%mod;\n    for (int i=0; i<=m; i++)\n        d1.push_back((komz(n, i)*odw[n+i-1])%mod);\n    for (int i=0; i<=k; i++)\n        d2.push_back(odw[i]);\n    d3=fft_dokladne(d1, d2);\n    for (int i=0; i<=m+k; i++)\n        wyn+=(d3[i]*((sil[n+i-1]*do3[m+k-i])%mod))%mod;\n    printf(\"%lld\\n\", wyn%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int N=9e5+5,mmm=1e9+7;\nint n,m,kni,sum,f[N],pv[N],q[N];\nint cmp(int n,int m);\nint main()\n{\n\tcin>>n>>m>>kni; \n\tn=n-1;\n    q[0]=1;\n\tq[1]=3;\n\tf[0]=pv[0]=f[1]=pv[1]=1; \n    for(int i=2;i<N;i++) pv[i]=(long long)pv[mmm%i]*(mmm-mmm/i)%mmm;\n    for(int i=2;i<N;i++)\n    {\n        q[i]=q[i-1]*3ll;f[i]=(long long)f[i-1]*i%mmm; pv[i]=(long long)pv[i-1]*pv[i]%mmm;\n    }\n    if(m<kni) {int t;t=m;m=kni;kni=t;}\n    for(int i=0,j=1;i<=m+kni;i++)\n    {\n        sum=(sum+(long long)cmp(n+i,n)*q[m+kni-i]%mmm*j)%mmm;\n        if (i<kni) j=j*2%mmm; else if (i>=m) j=(j*2ll-cmp(i,kni)-cmp(i,i-m))%mmm;\n        else \n\t\tj=(j*2ll-cmp(i,kni))%mmm;\n    }\n    if(sum<0) sum=mmm+sum;\n    cout<<sum;\n    return 0;\n}\nint cmp(int n,int m){return(long long) f[n]*pv[m]%mmm*pv[n-m]%mmm;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 6e5 + 5, MOD = 1e9 + 7;\nint fac[N], rev[N];\nint mpow(int x, int n) {\n\tint res = 1;\n\twhile (n) {\n\t\tif (n & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint C(int n, int m) {\n\treturn 1LL * fac[n] * rev[m] % MOD * rev[n - m] % MOD;\n}\nint main() {\n\tfac[0] = rev[0] = 1;\n\tfor (int i = 1; i < N; ++ i) {\n\t\tfac[i] = 1LL * fac[i - 1] * i % MOD;\n\t\trev[i] = mpow(fac[i], MOD - 2);\n\t}\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tif (m > k) swap(m, k);\n\tint ans = 0;\n\tint l = 0, r = 0, sum = 1;\n\tfor (int s = 0; s <= m + k; ++ s) {\n\t\tint res = 1LL * C(s + n - 1, s) * mpow(3, m + k - s) % MOD;\n\t\tint L = max(0, s - k), R = min(m, s);\n\t\twhile (l > L) (sum += C(s, -- l)) %= MOD;\n\t\twhile (r < R) (sum += C(s, ++ r)) %= MOD;\n\t\twhile (l < L) (sum += MOD - C(s, l ++)) %= MOD;\n\t\twhile (r > R) (sum += MOD - C(s, r --)) %= MOD;\n\t\t(ans += 1LL * res * sum % MOD) %= MOD;\n\t\tsum = (2LL * sum + MOD - C(s, l) + MOD - C(s, r)) % MOD;\n\t\tl ++;\n\t\tif (l > r + 1) while(true);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nclass Combination{\npublic:\n  typedef long long ll;\n  ll N;\n  ll mod;\n  vector<ll> fac;\n  vector<ll> finv;\n  vector<ll> inv;\n  \n  \n  Combination(ll N = 1e6,ll mod = 1e9 + 7): N(N), mod(mod), fac(N+1), finv(N+1), inv(N+1){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(Int i = 2; i <= N; i++){\n      fac[i] = fac[i-1] * i % mod;\n      inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n      finv[i] = finv[i-1] * inv[i] % mod;\n    }\n  }\n\n  function<ll(ll,ll)> get = [&](ll n,ll r){\n    if( n < r ) return 0LL;\n    if( n < 0 || r < 0) return 0LL;\n    return fac[n] * (finv[r] * finv[n-r] % mod) % mod;\n  };\n};\nauto nCr = (new Combination())->get;\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  vector<Int> p(1000000);\n  p[0] = 1;\n  for(Int i=1;i<(Int)p.size();i++) p[i] = p[i-1] * 3 % mod;\n  Int N, M, K;\n  cin>>N>>M>>K;\n  vector<Int> cnt(N+M+K+10);\n  {\n    cnt[0] = 1;\n    for(Int i=0;i<(Int)cnt.size()-1;i++){\n      cnt[i+1] = cnt[i]*2 - nCr(i, M) - nCr(i, K);\n      cnt[i+1] = (cnt[i+1] + 10*mod) % mod;\n    }\n  }\n\n  Int ans = 0;\n  for(Int X = N; X <= N+M+K; X++){\n    ans += nCr(X-1, N-1) * cnt[X-N] % mod * p[N+M+K - X]%mod;\n    ans %= mod;\n  }\n   \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(auto i##0_to = (t), i = decltype(t)(f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(auto i##0_to = (t), i = decltype(t)(f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(auto i##0_to = decltype(f)(t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(auto i##0_to = decltype(f)(t), i = (f); i >  i##0_to; i--)\n/** types **/\n\tusing LD = long double;\n\t#define double LD\n\t#define long long long\n\t#define LL long\n\t#define int long\n\ttemplate<class T> using vec = vector<T>;\n\tusing VB = vec<bool>;\tusing WB = vec<VB>;\n\tusing VC = vec<char>;\tusing WC = vec<VC>;\n\tusing VI = vec<int>;\tusing WI = vec<VI>;\n\tusing VD = vec<double>;\tusing WD = vec<VD>;\n\tusing VS = vec<string>;\tusing WS = vec<VS>;\n\tusing PI = pair<int, int>;\tusing VPI = vec<PI>; using WPI = vec<VPI>;\n\tusing MI = map<int, int>;\tusing VMI = vec<MI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define DD(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define DDD(x) if(debug) cerr << #x << \" = \" << (x) ln\n#define db dd\n#define dbg ddd\n\nvoid settings();\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n\t#ifdef EBUG\n\t\tdebug = true;\n\t#elif defined(ONLINE_JUDGE)\n\t\tdebug = false;\n\t#else\n\t\tdebug = argc >= 2;\n\t#endif\n\tif(!debug) {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n\tcout << fixed << setprecision(20);\n\tcerr << fixed << setprecision(20);\n\n\tsettings();\n\tsolve();\n\n\treturn 0;\n}\n\n/******************************* basic library ********************************/\n/** structure **/\n\ttemplate<class T> struct Graph { bool directed = false; int nv = -1; int ne = -1; vec<map<int,T>> e;\n\t\tGraph<T> rev() { if(not directed) return *this; Graph<T> g = *this; for(auto& ei : g.e) ei.clear(); times(nv, i) for(auto& p : e[i]) g.e[p.first][i] = p.second; return g; }\n\t};\n\tusing GraphI = Graph<int>;\n/** IO **/\n\ttemplate<class T> inline istream& operator>>(istream& s, vec<T>& v) { for(auto&& p : v) s >> p; return s; }\n\tint INPUT_GRAPH_index_sub = 1, INPUT_GRAPH_cost = 0; bool INPUT_GRAPH_allow_empty = false;\n\ttemplate<class T> inline istream& operator>>(istream& s, Graph<T>& g) {\n\t\tconst int sub = INPUT_GRAPH_index_sub, cost = INPUT_GRAPH_cost, emptyp = INPUT_GRAPH_allow_empty;\n\t\tif(g.nv + emptyp <= 0 and g.ne + emptyp <= 0) { s >> g.nv >> g.ne; } g.e = VMI(g.nv);\n\t\ttimes(g.ne, i) { int x, y; T d = cost; s >> x >> y; if(!d) s >> d; g.e[x - sub][y - sub] = d; if(not g.directed) g.e[y - sub][x - sub] = d; } return s;\n\t}\n\ttemplate<class T, class S> inline ostream& operator<<(ostream&, const pair<T, S>&);\n\ttemplate<class T>          inline ostream& operator<<(ostream&, const vec<T>&);\n\ttemplate<class T, class S> inline ostream& operator<<(ostream&, const map<T, S>&);\n\ttemplate<class T> inline ostream& operator<<(ostream&, const Graph<T>&);\n\t#define DEFINE_ITER_OUTPUT(s, x, sep) { int i = 0; for(const auto& x##0_elem : x) { if(i++) s << sep; s << x##0_elem; } return s; }\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const pair<T, S>& p) { return s << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ttemplate<class T>          inline ostream& operator<<(ostream& s, const vec<T>& v) DEFINE_ITER_OUTPUT(s, v, ' ')\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const map<T, S>& m) DEFINE_ITER_OUTPUT(s, m, ' ')\n\ttemplate<class T>          inline ostream& operator<<(ostream& s, const vec<vec<T>>& w) DEFINE_ITER_OUTPUT(s, w, '\\n')\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const vec<map<T, S>>& vm) DEFINE_ITER_OUTPUT(s, vm, '\\n')\n\ttemplate<class T> inline ostream& operator<<(ostream& s, const Graph<T>& g) { return s << \"Graph(nv:\" << g.nv << \" ne:\" << g.ne << \" e:[\" ln << g.e ln << \"])\"; }\n\tinline void RD() {}\n\ttemplate<class T, class...S> inline T& RD(T& t, S&... s) { cin >> t; RD(s...); return t; } /* returns first side */\n\ttemplate<class T, class...S> inline vec<T>& RD(vec<T>& t, vec<S>&... s) { times(t.size(), i) { RD(t[i], s[i]...); } return t; }\n\t#define RR(typ, ...) typ __VA_ARGS__; RD(__VA_ARGS__)\n\ttemplate<class T, class...A> inline T READ(A... a) { T t(a...); cin >> t; return t; }\n\ttemplate<class T> inline void dddf(const T& t) { if(debug) cerr << t ln; }\n\ttemplate<class T, class...U> inline void dddf(const T& t, const U&... u) { if(debug) { cerr << t << \", \"; dddf(u...); }}\n\t#define ddd(...) if(debug) { cerr << #__VA_ARGS__ << \" = \"; dddf(__VA_ARGS__); }\n/** container **/\n\t#define all(v) begin(v), end(v)\n\ttemplate<class T> inline T max(const pair<T, T>& p) { return max(p.first, p.second); }\n\ttemplate<class T> inline T min(const pair<T, T>& p) { return min(p.first, p.second); }\n\ttemplate<class T> inline T max(const vec<T>& v) { return *max_element(all(v)); }\n\ttemplate<class T> inline T min(const vec<T>& v) { return *min_element(all(v)); }\n\ttemplate<class T> inline T sum(const vec<T>& v) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) s += v[i]; return s; }\n\ttemplate<class T> inline T sum(const vec<T>& v, int mod) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) (s += v[i]) %= mod; return s; }\n\ttemplate<class T, class U> inline T dig(const U& d, const T& t) { return t; }\n\ttemplate<class T, class U, class...I> inline U dig(const U& d, const T& t, int i, I... j) {\n\t\treturn 0 <= i && i < t.size() ? dig(d, t[i], j...) : d; }\n\t#define first_itr_st_val_ge_ lower_bound\n\t#define first_itr_st_val_gt_ upper_bound\n/** other **/\n\ttemplate<class T> inline signed SIZE(const T& t) { return t.size(); }\n\t#define size SIZE\n\t#define MP make_pair\n\t#define MT make_tuple\n\t#define PB push_back\n\t#define b_max(x, y) x = max(x, y)\n\t#define b_min(x, y) x = min(x, y)\n\tinline LD AC(LD d) { return d ? d : 0; }\n[[maybe_unused]] constexpr long INF = 1LL << 60;\n[[maybe_unused]] constexpr long MOD = 1000000007; // 1000000009; // 998244353;\n\n/****************************** optional library ******************************/\n/* <sr.m.nck> */\n\t/* <sr.m.fact> */\n\t\t/* <sr.m.pow> */\n\t\t\t// NOT_VERIFIED\n\t\t\t// ref: ari-114\n\t\t\t// O(log b)\n\t\t\tinline int mpow(int a, int b, int mod=MOD) {\n\t\t\t\tint ans = 1;\n\t\t\t\tfor(; b; b >>= 1, (a *= a) %= mod) if(b & 1) (ans *= a) %= mod;\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t/* </sr.m.pow> */\n\t\t// NOT_VERIFIED\n\t\t// ref: twitter.com/meguru_comp/status/694207919517077504\n\t\t// O(N + log mod)\n\t\tint *fact, *factInv;\n\t\tvoid factInit(int N, int mod=MOD) {\n\t\t\tfact = new int[N]; factInv = new int[N];\n\t\t\tfact[0] = 1;\n\t\t\tupto(1,N,i) fact[i] = fact[i-1] * i % mod;\n\t\t\tfactInv[N] = mpow(fact[N], mod-2, mod);\n\t\t\trtimes(N,i) factInv[i] = factInv[i+1] * (i+1) % mod;\n\t\t}\n\t/* </sr.m.fact> */\n\t// NOT_VERIFIED\n\t// O(1), before:O(N)\n\tinline int nCk(int n, int k, int mod=MOD) {\n\t\tif(!fact) { cerr << \"factInit before nCk.\\n\"; return -1; }\n\t\tif(n < 0 or k < 0 or n-k < 0) return 0;\n\t\treturn fact[n] * factInv[k] % mod * factInv[n-k] % mod;\n\t}\n/* </sr.m.nck> */\n\n/************************************ main ************************************/\n\nvoid settings() {\n\t// INPUT_GRAPH_index_sub = 0;\t\t// uncomment if input index is 0-based\n\t// INPUT_GRAPH_allow_empty = true;\t// uncomment to allow empty graph\n\t// INPUT_GRAPH_cost = 1;\t\t\t// uncomment if all input costs are 1\n}\n\nvoid solve() {\n// NMK\n/* <foxy.memo-area> */\nint N;int M;int K;cin>>N;cin>>M;cin>>K;\n/* </foxy.memo-area> */\n\n\tfactInit(N + M + K + 486);\n\tint ans = 0;\n\tint s = 1;\n\tupto(N, N + M + K, x) {\n\t\tint y = x - N;\n\t\t/*\n\t\tupto(max(0ll, x - N - K), min(M, x - N), p) {\n\t\t\t(s += nCk(x - N, p)) %= MOD;\n\t\t}\n\t\t*/\n\t\t(ans += nCk(x - 1, N - 1) * s % MOD * mpow(3, N + M + K - x)) %= MOD;\n\t\ts = (s * 2 - nCk(y, M) - nCk(y, y - K)) % MOD;\n\t\tif(s < 0) s += MOD;\n\t}\n\tcout << ans % MOD ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pii;\ntypedef pair<double,double> pdd;\n#define SQ(i) ((i)*(i))\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define SZ(i) int(i.size())\n#define FOR(i, j, k, in) for (int i=j ; i<k ; i+=in)\n#define RFOR(i, j, k, in) for (int i=j ; i>=k ; i-=in)\n#define REP(i, j) FOR(i, 0, j, 1)\n#define REP1(i,j) FOR(i, 1, j+1, 1)\n#define RREP(i, j) RFOR(i, j, 0, 1)\n#define ALL(_a) _a.begin(),_a.end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n#ifdef tmd\n#define TIME(i) Timer i(#i)\n#define debug(...) do{\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\" ,\";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,deque<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define TIME(i)\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n#endif\nclass Timer {\nprivate:\n    string scope_name;\n    chrono::high_resolution_clock::time_point start_time;\npublic:\n    Timer (string name) : scope_name(name) {\n        start_time = chrono::high_resolution_clock::now();\n    }\n    ~Timer () {\n        auto stop_time = chrono::high_resolution_clock::now();\n        auto length = chrono::duration_cast<chrono::microseconds>(stop_time - start_time).count();\n        double mlength = double(length) * 0.001;\n        debug(scope_name, mlength);\n    }\n};\n\nconst ll MOD = 1000000007;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int iNF = 0x3f3f3f3f;\nconst ll MAXN = 300005;\n\nll n, m, k;\nll fact[MAXN], inv[MAXN];\n\nll mpow (ll bs, ll ep) {\n    ll ret = 1;\n    while (ep) {\n        if (ep & 1) {\n            ret = ret * bs % MOD;\n        }\n        ep >>= 1;\n        bs = bs * bs % MOD;\n    }\n    return ret;\n}\n\nll cob (ll a, ll b) {\n    return fact[a] * inv[b] % MOD * inv[a-b] % MOD; \n}\n/********** Good Luck :) **********/\nint main()\n{\n    TIME(main);\n    IOS();\n    debug(mpow(2, 10));\n\n    cin >> n >> m >> k;\n\n    inv[0] = fact[0] = 1;\n    REP1 (i, MAXN - 1) {\n        fact[i] = fact[i-1] * i % MOD;\n        inv[i] = mpow(fact[i], MOD - 2);\n    }\n\n    ll ans = 0;\n    REP (i, m+1) {\n        REP (j, k+1) {\n            ll cb = cob(n + i + j - 1, i) * cob(n + j - 1, j) % MOD;\n            ans += cb * mpow(3, m-i) % MOD * mpow(3, k-j) % MOD;\n            ans %= MOD;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 20);\nconst int mod = (int)1e9 + 07;\nconst double PI = acos(-1);\n\ninline void addmod(int& x, int y, int mod) { (x += y) >= mod && (x -= mod); }\ninline int mulmod(int x, int y, int mod) { return x * 1ll * y % mod; }\n\nstruct complex_base\n{\n\tlong double x, y;\n\tcomplex_base(long double _x = 0, long double _y = 0) { x = _x; y = _y; }\n\tfriend complex_base operator-(const complex_base &a, const complex_base &b) { return complex_base(a.x - b.x, a.y - b.y); }\n\tfriend complex_base operator+(const complex_base &a, const complex_base &b) { return complex_base(a.x + b.x, a.y + b.y); }\n\tfriend complex_base operator*(const complex_base &a, const complex_base &b) { return complex_base(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x); }\n\tfriend void operator/=(complex_base &a, const long double &P) { a.x /= P; a.y /= P; }\n};\n\nint bit_rev[MAXN];\n\nvoid fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = 2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n}\n\nvoid inv_fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = -2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] /= n;\n}\n\ncomplex_base A[MAXN], B[MAXN];\n\nvector<int> mult(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() <= 128)\n\t{\n\t\tvector<int> ans(a.size() + b.size(), 0);\n\t\tfor(int i = 0; i < (int)a.size(); i++)\n\t\t\tfor(int j = 0; j < (int)b.size(); j++)\n\t\t\t\tans[i + j] = (ans[i + j] + a[i] * 1ll * b[j]) % mod;\n\n\t\treturn ans;\n\t}\n\n\tint lg = 0; while((1 << lg) < (int)(a.size() + b.size())) ++lg;\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = B[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = complex_base(a[i], 0);\n\tfor(int i = 0; i < (int)b.size(); i++) B[i] = complex_base(b[i], 0);\n\n\tfft(A, lg); fft(B, lg);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tA[i] = A[i] * B[i];\n\tinv_fft(A, lg);\n\n\tvector<int> ans(a.size() + b.size(), 0);\n\tfor(int i = 0; i < (int)ans.size(); i++)\n\t\tans[i] = (int64_t)(A[i].x + 0.5) % mod;\n\n\treturn ans;\n}\n\nvector<int> mult_mod(const vector<int> &a, const vector<int> &b)\n{\n\t/// Thanks pavel.savchenkov\n\n\t// a = a0 + sqrt(MOD) * a1\n\t// a = a0 + base * a1\n\tint base = (int)sqrtl(mod);\n\n\tvector<int> a0(a.size()), a1(a.size());\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t{\n\t\ta0[i] = a[i] % base;\n\t\ta1[i] = a[i] / base;\n\t}\n\n\tvector<int> b0(b.size()), b1(b.size());\n\tfor(int i = 0; i < (int)b.size(); i++)\n\t{\n\t\tb0[i] = b[i] % base;\n\t\tb1[i] = b[i] / base;\n\t}\n\n\tvector<int> a01 = a0;\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t\taddmod(a01[i], a1[i], mod);  \t\n\n\tvector<int> b01 = b0;\n\tfor(int i = 0; i < (int)b.size(); i++) \n\t\taddmod(b01[i], b1[i], mod);\n\n\tvector<int> C = mult(a01, b01);  // 1\n\n\tvector<int> a0b0 = mult(a0, b0); // 2\n\tvector<int> a1b1 = mult(a1, b1); // 3\n\n\tvector<int> mid = C;\n\tfor(int i = 0; i < (int)mid.size(); i++) \n\t{\n\t\taddmod(mid[i], -a0b0[i] + mod, mod);\n\t\taddmod(mid[i], -a1b1[i] + mod, mod);\n\t}\n\n\tvector<int> res = a0b0;\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, mid[i], mod), mod);\n\n\tbase = mulmod(base, base, mod);\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, a1b1[i], mod), mod);\n\n\treturn res;\n}\n\nint n, m, k;\n\nvoid read()\n{\n\tcin >> n >> m >> k;\n}\n\nvector<int> p1, p2, pw3;\n\nint pw(int x, int p)\n{\n\tint ret = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ret = (ret * 1ll * x) % mod;\n\t\tx = (x * 1ll * x) % mod;\n\t\tp >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint fact[MAXN], inv_fact[MAXN];\nint comb(int n, int k) { if(n < 0 || k < 0 || n < k) return 0; return (((fact[n] * 1ll * inv_fact[n - k]) % mod) * 1ll * inv_fact[k]) % mod; }\n\n/*   SUM C(n + i - 1, i) * C(n + i - 1 + j, j)   */\n/*   SUM C(n + i - 1, i) * fact[n + i - 1 + j] / (fact[j] * fact[n + i - 1])    */\n\n\nvoid solve()\n{\t\n\tpw3.assign(n + m + k + 1, 0);\n\tp1.assign(n + m + k + 1, 0);\n\tp2.assign(n + m + k + 1, 0);\n\tpw3[0] = 1; for(int i = 1; i <= m + k + n; i++) pw3[i] = (3ll * pw3[i - 1]) % mod;\n\tfact[0] = 1; for(int i = 1; i <= m + k + n; i++) fact[i] = (fact[i - 1] * 1ll * i) % mod;\n\tinv_fact[m + k + n] = pw(fact[m + k + n], mod - 2); for(int i = n + k + m - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * 1ll * (i + 1)) % mod; \n\n\tfor(int i = 0; i <= m; i++) p1[i] = (comb(n + i - 1, i) * 1ll * inv_fact[n + i - 1]) % mod;\n\tfor(int i = 0; i <= k; i++) p2[i] = inv_fact[i];\n\n\tvector<int> ret = mult_mod(p1, p2);\n\t\n\tint answer = 0;\n\tfor(int i = 0; i < (int)ret.size(); i++)\n\t{\n\t\tif(m + k - i < 0) break;\n\n\t\tint curr = (ret[i] * 1ll * pw3[m + k - i]) % mod;\n\t\tcurr = (curr * 1ll * fact[n - 1 + i]) % mod;\n\t\taddmod(answer, curr, mod);\n\t}\n\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#include <iostream>\nusing namespace std;\n#define N 2000005\n#define ll long long\n#define mod 1000000007\nint fac[N],inv[N],t[N],a,b,c,mx,ans;\nint q_pow(int x,int n){int ret=1;for(;n;n>>=1,x=(ll)x*x%mod)if(n&1)ret=(ll)ret*x%mod;return ret;}\nint C(int n,int m){return (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\t// freopen(\"8102.in\",\"r\",stdin);\n\t// freopen(\"8102.out\",\"w\",stdout);\n\tmx=2000000;t[0]=fac[0]=1;\n\tfor(int i=1;i<=mx;i++)fac[i]=(ll)i*fac[i-1]%mod,t[i]=(ll)t[i-1]*3%mod;inv[mx]=q_pow(fac[mx],mod-2);\n\tfor(int i=mx;i;i--)inv[i-1]=(ll)inv[i]*i%mod;\n\t// int T;scanf(\"%d\",&T);\n\t// while(T--)\n\t// {\n\tscanf(\"%d%d%d\",&a,&b,&c);ans=0;int rb=0,rc=0;\n\tfor(int i=0;i<=b+c;i++)\n\t{\n\t\tint tmp=(ll)t[b+c-i]*fac[a+i-1]%mod,w=q_pow(2,i);\n\t\tif(i>b)\n\t\t{\n\t\t\trb=(rb*2)%mod;\n\t\t\trb=(rb+C(i-1,b))%mod;\n\t\t\tw=(w-rb)%mod;\n\t\t}\n\t\tif(i>c)\n\t\t{\n\t\t\trc=(rc*2)%mod;\n\t\t\trc=(rc+C(i-1,c))%mod;\n\t\t\tw=(w-rc)%mod;\n\t\t}\n\t\tw=((ll)w*inv[i])%mod;\n\t\tans=(ans+(ll)w*tmp)%mod;\n\t}\n\tprintf(\"%lld\\n\",(ll)(ans+mod)*inv[a-1]%mod);\n\t// }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n#define MAX_N 1000000\n#define MOD 1000000007LL\nlong long modpow[MAX_N], fact[MAX_N], inv[MAX_N], factinv[MAX_N], dp[MAX_N];\nint n, m, p;\nvoid init() {\n\tfact[0] = 1; for (long long i = 1; i < MAX_N; i++) fact[i] = 1LL * fact[i - 1] * i % MOD;\n\tinv[1] = 1; for (long long i = 2; i < MAX_N; i++) inv[i] = 1LL * inv[MOD % i] * (MOD - MOD / i) % MOD;\n\tfactinv[0] = 1; for (long long i = 1; i < MAX_N; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % MOD;\n}\nlong long modmul(long long A, long long B, long long C) { return ((A*B) % MOD *C) % MOD; }\nlong long ncr(long long n, long long r) { return modmul(fact[n], factinv[r], factinv[n - r]); }\nint main() {\n\tmodpow[0] = 1; for (long long i = 1; i < MAX_N; i++) { modpow[i] = modpow[i - 1] * 3; modpow[i] %= MOD; }\n\tcin >> n >> m >> p; init();\n\tlong long sum = 0, V = 1;\n\tfor (long long i = 0; i <= m + p; i++) {\n\t\tdp[m + p - i] = V; V *= 2;\n\t\tif (i >= m)V -= ncr(i, i - m);\n\t\tif (i >= p)V -= ncr(i, i - p);\n\t\tV = (V + MOD*MOD) % MOD;\n\t}\n\tfor (long long i = 0; i <= m + p; i++) {\n\t\tlong long NN = (n - 1) + m + p - i, RR = n - 1;\n\t\tsum += modmul(ncr(NN, RR), dp[i], modpow[i]); sum %= MOD;\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int Max=3e5+1;\nconst long long Mod=1e9+7;\nint cnt=0,M;\nlong long P[Max*3+10]={},inv[Max*3+10]={},Pow[Max*3+10]={};\ninline long long C(int n,int m){return P[n]*inv[n-m]%Mod*inv[m]%Mod;}\nint main(){\n\tP[0]=P[1]=1; for(int i=2;i<=Max*3;i++) P[i]=i*P[i-1],P[i]%=Mod;\n\tinv[0]=inv[1]=1; for(int i=2;i<=Max*3;i++) inv[i]=inv[Mod%i]*(Mod-Mod/i)%Mod;\n\tfor(int i=2;i<=Max*3;i++) inv[i]=inv[i]*inv[i-1]%Mod;\n\tPow[0]=1; for(int i=1;i<=Max*3;i++) Pow[i]=Pow[i-1]*3%Mod;\n\tint N,M,Q; scanf(\"%d%d%d\",&N,&M,&Q);\n\tlong long Ans=0,Sum1=0,Sum2=0;\n\tfor(int i=N;i<=N+M+Q;i++){\n\t\tif(i==N){\n\t\t\tfor(int j=0;j<i-N-Q;i++) Sum1+=C(i-N,j);\n\t\t    for(int j=max(i-N-Q,0);j<=min(M,i-N);j++) Sum2+=C(i-N,j);\n\t\t}else{\n            if(i-N-Q-2>=0) Sum1=(Sum1*2%Mod-C(i-1-N,i-N-Q-2)+Mod)%Mod;\n            Sum2=(Sum2*2%Mod-C(i-1-N,min(M,i-1-N))+Mod)%Mod;\n\t\t\tif(max(i-N-Q,0)>max(i-N-Q-1,0)) Sum1+=C(i-N,i-N-Q-1),Sum1%=Mod;\n\t\t\tif(min(M,i-N-1)<min(M,i-N)) Sum2+=C(i-N,min(M,i-N)),Sum2%=Mod;\n\t\t}\n\t\tAns+=C(i-1,N-1)*Pow[N+M+Q-i]%Mod*(Sum2-Sum1+Mod)%Mod,Ans%=Mod;\n//\t\tfor(int j=max(i-N-Q,0);j<=min(M,i-N);j++)\n//\t\t Ans+=C(i-1,N-1)*C(i-N,j)%Mod*Pow[N+M+Q-i]%Mod,Ans%=Mod;  \n\t}\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define cbn(x,y) ((ll)fac[x]*inv[y]%mod*inv[(x)-(y)]%mod)\n#define N 1000005\nusing namespace std;\n\nint n,A,B,C,pw[N],fac[N],inv[N];\nint main(){\n\tscanf(\"%d%d%d\",&A,&B,&C); n=A+B+C;\n\tfac[0]=inv[0]=inv[1]=pw[0]=1;\n\tint i;\n\tfor (i=1; i<=n; i++) pw[i]=(ll)pw[i-1]*3%mod;\n\tfor (i=1; i<=n; i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tfor (i=2; i<=n; i++) inv[i]=mod-(ll)inv[mod%i]*(mod/i)%mod;\n\tfor (i=2; i<=n; i++) inv[i]=(ll)inv[i-1]*inv[i]%mod;\n\tint ans=0,tmp=1;\n\tfor (i=0; i<=B+C; i++){\n\t\tif (i){\n\t\t\ttmp=(tmp<<1)%mod;\n\t\t\tif (i>B) tmp=(tmp-cbn(i-1,B)+mod)%mod;\n\t\t\tif (i>C) tmp=(tmp-cbn(i-1,C)+mod)%mod;\n\t\t}\n\t\tans=(ans+(ll)pw[B+C-i]*cbn(A-1+i,i)%mod*tmp)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define OUT(x)                cout << #x << \" = \" << x << endl; \n#define rep(i, n)             for (int (i) = 0; (i) < (int)(n); (i)++)\n#define rer(i, l, r)          for (int (i) = (int)(l); (i) <= (int)(r); (i)++)\n#define reu(i, l, r)          for (int (i) = (int)(l); (i) < (int)(r); (i)++)\n#define each(i, v)            for (auto i : v)\n#define all(x)                (x).begin(), (x).end()\n#define rall(x)               (x).rbegin(), (x).rend()\n#define pb(x)                 push_back(x)\n#define bp(x)                 __builtin_popcount(x)\n#define mp(x, y)              make_pair((x), (y))\n#define fi                    first\n#define se                    second\n#define setp(x)               setprecision(x)\n#define mset(m, v)            memset(m, v, sizeof(m))\n#define sz(x)                 (int)(x.size())\nstatic const int INF        = 0x3f3f3f3f;\nstatic const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD        = 1000000007;\nstatic const double PI      = 3.141592653589793238462643383279;\n\n#define int                   long long\n\ntypedef vector<double>        vd;\ntypedef vector<string>        vs;\ntypedef vector<bool>          vb;\ntypedef vector<int>           vi;\ntypedef pair<int, int>        pii;\ntypedef vector<pii>           vpii;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; i ++) cout << *i << \" \"; cout << endl; }\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\n//int in() { int _x; scanf(\"%d\", &_x); return _x; }\nlong long lin() {long long _x; scanf(\"%lld\", &_x); return _x; };\n\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n        long long d = a;\n        if (b != 0) {\n                d = extgcd(b, a % b, y, x);\n                y -= (a / b) * x;\n        } else {\n                x = 1;\n                y = 0;\n        }\n        return d;\n}\n\nlong long inv(long long a) {\n        long long x, y;\n        extgcd(a, MOD, x, y);\n        return (x % MOD + MOD) % MOD;\n}\n\nlong long nCr(long long n, long long r) {\n        if (n < r) return 0;\n        if (n - r < r) r = n - r;\n        long long ret = 1;\n        rep(i, r) {\n                ret *= n;\n                -- n;\n                ret %= MOD;\n                ret *= inv(i + 1);\n                ret %= MOD;\n        }\n        return ret;\n}\n\nlong long mod_pow(long long x, long long n) {\n        long long res = 1;\n        while (n > 0) {\n                if (n & 1) res = res * x % MOD;\n                x = x * x % MOD;\n                n >>= 1;\n        }\n        return res;\n}\n\nsigned main() { \n        int n, m, k;\n        cin >> n >> m >> k;\n        int ans = 0;\n        if (n > 1000 || m > 1000 || k > 1000) return 0;\n        //if (!n) ans += mod_pow(3, m + k);\n        //else {\n                for (int i = n; i <= n + m + k; i ++) {\n                        int x = nCr(i - 1, n - 1);\n                        int y = 0;\n                        for (int j = max(0LL, i - n - k); j <= min(i - n, m); j ++) {\n                                y += nCr(i - n, j);\n                                y %= MOD;\n                        }\n                        int z = mod_pow(3, n + m + k - i);\n                        ans += x * y % MOD * z; \n                        ans %= MOD;\n                }\n        //}\n        ans %= MOD;\n        cout << ans << endl;\n        return 0;\n}               \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG fprintf(stderr, \"Passing [%s] line %d\\n\", __FUNCTION__, __LINE__)\n#define File(x) freopen(x\".in\",\"r\",stdin); freopen(x\".out\",\"w\",stdout)\n#define int long long\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIII;\n\ntemplate <typename T>\ninline T gi()\n{\n\tT f = 1, x = 0; char c = getchar();\n\twhile (c < '0' || c > '9') {if (c == '-') f = -1; c = getchar();}\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f * x;\n}\n\nconst int INF = 0x3f3f3f3f, N = 300003, M = N << 1, mod = 1000000007;\n\nint n, m, k, ans;\nint fac[N * 3], inv[N * 3], f[M];\n\ninline int qpow(int a, int b)\n{\n\tint res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) res = res * a % mod;\n\t\ta = a * a % mod, b >>= 1;\n\t}\n\treturn res;\n}\n\ninline int C(int a, int b)\n{\n\tif (a < b || a < 0 || b < 0) return 0;\n\treturn fac[a] * inv[b] % mod * inv[a - b] % mod;\n}\n\nsigned main()\n{\n\t//File(\"\");\n\tn = gi <int> (), m = gi <int> (), k = gi <int> ();\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n + m + k; i+=1) fac[i] = fac[i - 1] * i % mod;\n\tinv[n + m + k] = qpow(fac[n + m + k], mod - 2);\n\tfor (int i = n + m + k - 1; i >= 0; i-=1) inv[i] = inv[i + 1] * (i + 1) % mod;\n\tf[0] = 1;\n\tfor (int i = 1; i <= m + k; i+=1) f[i] = ((2 * f[i - 1] % mod - C(i - 1, i - 1 - k) + mod) % mod - C(i - 1, m) + mod) % mod;\n//\tfor (int i = 1; i <= m + k; i+=1) cout << f[i] << endl;\n\tfor (int i = 0; i <= m + k; i+=1)\n\t{\n//\t\tcout << f[i] << ' ' << qpow(3, m + k - i) << ' ' << C(n - 1 + i, n - 1) << endl;\n\t\tans = (ans + (f[i] * qpow(3, m + k - i) % mod * C(n - 1 + i, n - 1) % mod) % mod) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst LL MOD = 1e9 + 7;\nconst int N = 1e6;\n\nLL fct[N + 5], inv[N + 5];\n\nLL fast(LL A,LL B) {\n\tLL res = 1;\n\twhile(B) {\n\t\tif(B & 1) res = res * A % MOD;\n\t\tB /= 2;\n\t\tA = A * A % MOD;\n\t}\n\treturn res;\n}\n\nvoid pre() {\n\tfct[0] = 1;\n\tfor(int i = 1;i <= N;i++) fct[i] = fct[i-1] * i % MOD;\n\tinv[N] = fast(fct[N], MOD - 2);\n\tfor(int i = N - 1;i >= 0;i--) inv[i] = inv[i + 1] * (i + 1) % MOD;\n}\n\nLL combin(int n,int r) {\n\tif(n < r) return 0;\n\treturn fct[n] * inv[r] % MOD * inv[n - r] % MOD;\n}\n\nvoid hora(int tc) {\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tint space = m + k;\n\tLL tot = 0;\n\tLL totals = 1;\n\tfor(int w = 0;w <= m + k;w++) {\n\t\tif(w > m) totals -= combin(w - 1, m);\n\t\tif(w > k) totals -= combin(w - 1, k);\n\t\ttotals %= MOD, totals += MOD, totals %= MOD;\n\t\ttot += combin(n - 1 + w, n - 1) * totals % MOD * fast(3, m + k - w) % MOD;\n\t\ttotals = totals * 2 % MOD;\n\t\ttot %= MOD;\n\t}\n\tcout<<tot<<endl;\n}\n\nint main(){\n\tpre();\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint fact[333333],inv[333333];\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nint pow3[333333];\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<333333;i++)fact[i]=fact[i-1]*i%mod;\n    for(int i=0;i<333333;i++)inv[i]=mpow(fact[i],mod-2);\n    pow3[0]=1;\n    for(int i=1;i<333333;i++)pow3[i]=pow3[i-1]*3%mod;\n\n    int N,M,K;\n    cin>>N>>M>>K;\n    int ans=0;\n    for(int i=0;i<=M;i++){\n        for(int j=0;j<=K;j++){\n            int len=N+i+j-1;\n            int t=C(len,i);\n            t=t*C(len-i,j)%mod;\n            t=t*pow3[M+K-i-j]%mod;\n            ans=(ans+t)%mod;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint mod = 1e9 + 7, N, M, K, dp[1009][1009], put3[3009], inv[3009], fac[3009];\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint substract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\n\nint pow (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = pow (fac[lim], mod - 2);for (int i=lim - 1; i>=1; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &M, &K);\nput3[0] = 1;\nfor (int i=1; i<=N + M + K; i++)\n    put3[i] = add (add (put3[i - 1], put3[i - 1]), put3[i - 1]);\nPrec (3000);\nint ans = 0;\nfor (int i=0; i<=M; i++)\n    for (int j=0; j<=K; j++)\n    {\n        dp[i][j] = put3[i + j];\n        if (i > 0) dp[i][j] = add (dp[i][j], dp[i - 1][j]);\n        if (j > 0) dp[i][j] = add (dp[i][j], dp[i][j - 1]);\n        if (N > 1)\n        {\n            int a = N - 2, b = M - i, c = K - j, curr = dp[i][j];\n            curr = mul (curr, comb (a + b + c, a));\n            curr = mul (curr, comb (b + c, b));\n            ans = add (ans, curr);\n        }\n    }\nif (N > 1) printf (\"%d\\n\", ans);\nelse printf (\"%d\\n\", dp[M][K]);\n/*for (int i=0; i<N; i++)\n    for (int j=0; j<=M; j++)\n        for (int k=0; k<=K; k++)\n        {\n            if (i + j + k == 0)\n            {\n                dp[i & 1][j][k] = 1;\n                continue;\n            }\n            if (i == 0)\n            {\n                dp[0][j][k] = put3[j + k];\n                if (j > 0) dp[0][j][k] = add (dp[0][j][k], dp[0][j - 1][k]);\n                if (k > 0) dp[0][j][k] = add (dp[0][j][k], dp[0][j][k - 1]);\n                continue;\n            }\n            dp[i & 1][j][k] = dp[(i & 1) ^ 1][j][k];\n            if (j > 0) dp[i & 1][j][k] = add (dp[i & 1][j][k], dp[i & 1][j - 1][k]);\n            if (k > 0) dp[i & 1][j][k] = add (dp[i & 1][j][k], dp[i & 1][j][k - 1]);\n        }\nprintf (\"%d\\n\", dp[(N & 1) ^ 1][M][K]);*/\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x7fffffff\n#define RG register\n#define maxn 1000005\n#define maxm 205\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\ninline ll read(){\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while(ch > '9' || ch < '0') {if(ch == '-') f = -1;ch = getchar();}\n    while(ch >= '0' && ch <= '9'){x = x *10 + ch -'0';ch = getchar();}\n    return x * f;\n}\n \nint n, m, k, po[2][maxn];\nint qpow(int a, int b){\n\tint ans = 1, base = a;\n\twhile(b){\n\t\tif(b & 1) ans = 1ll * ans * base % mod;\n\t\tbase= 1ll * base * base % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nint fac[maxn], inv[maxn], ans;\nint C(int n, int m){return 1ll * fac[n] * inv[m] % mod *inv[n - m] % mod;}\nint main(){\n\tint i, j, x, l, r, mid;\n\tfac[0] = po[0][0] = po[1][0] = 1;\n\tfor(i = 1;i <= maxn - 5;i++) fac[i] = 1ll * fac[i - 1] * i % mod, po[0][i] = po[0][i - 1] * 2ll % mod, po[1][i] = po[1][i - 1] * 3ll % mod;\n\tinv[maxn - 5] = qpow(fac[maxn - 5], mod - 2);\n\tfor(i = maxn - 6;i >= 0;i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; \n\tn = read(), m = read(), k = read();\n\tint las = 1;\n\tfor(i = 0;i <= m + k;i++){\n\t\tans = (ans + 1ll * C(n + i - 1, n - 1) * po[1][m + k -i] % mod * las % mod) % mod;\n\t\tif(i + 1 <= m && i + 1 <= k) las = las * 2ll % mod;\n\t\telse{\n\t\t\tif(i + 1 <= k) las = ((las * 2ll - C(i, m)) % mod + mod) % mod; \n\t\t\telse if(i + 1 <= m) las = ((las * 2ll - C(i, i - k)) % mod + mod) % mod;\n\t\t\telse las = (((las * 2ll - C(i, i - k)) % mod + mod - C(i, m) ) % mod + mod ) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint n, m, k;\nint pow1[1010101], pow2[1010101];\nint fac[1010101], rev[1010101], ifac[1010101];\n\nint c(int a, int b)\n{\n\tlong long ret = fac[b];\n\tret = ret * ifac[a];\n\tret %= MOD;\n\tret = ret * ifac[b - a];\n\tret %= MOD;\n\treturn (int)ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tpow1[0] = fac[0] = ifac[0] = rev[0] = pow2[0] = 1;\n\tifac[1] = rev[1] = 1;\n\tfor(int i = 1; i <= n + m + k; ++i)\n\t{\n\t\tpow1[i] = pow1[i - 1] * 3ll % MOD;\n\t\tpow2[i] = pow2[i - 1] * 2 % MOD;\n\t\tfac[i] = fac[i - 1] * 1ll * i % MOD;\n\t\tif(i >= 2)\n\t\t{\n\t\t\trev[i] = MOD - 1ll * (MOD / i) * rev[MOD % i] % MOD;\n\t\t\tifac[i] = 1ll * ifac[i - 1] * rev[i] % MOD;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i <= m; ++i)\n\t{\n\t\tans += 1ll * pow2[i] * c(i, i + n - 1) % MOD * pow1[m + k - i] % MOD;\n\t\tif(ans >= MOD)\n\t\t\tans -= MOD;\n\t}\n\tint lst = pow2[m];\n\tfor(int i = m + 1; i <= m + k; ++i)\n\t{\n\t\tlst = lst<<1;\n\t\tlst -= c(m, i - 1);\n\t\tif(lst >= MOD)\n\t\t\tlst -= MOD;\n\t\tif(i > k)\n\t\t\tlst -= c(i - k - 1, i - 1);\n\t\twhile(lst < 0)\n\t\t\tlst += MOD;\n\t\twhile(lst >= MOD)\n\t\t\tlst -= MOD;\n\t\tans += 1ll * lst * c(i, i + n - 1) % MOD * pow1[m + k - i] % MOD;\n\t\tif(ans >= MOD)\n\t\t\tans -= MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < int(n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= int(m); --(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\n\nll powmod(ll x, ll y, ll p) { // O(log y)\n    assert (0 <= x and x < p);\n    assert (0 <= y);\n    ll z = 1;\n    for (ll i = 1; i <= y; i <<= 1) {\n        if (y & i) z = z * x % p;\n        x = x * x % p;\n    }\n    return z;\n}\nll inv(ll x, ll p) { // p must be a prime, O(log p)\n    assert ((x % p + p) % p != 0);\n    return powmod(x, p-2, p);\n}\ntemplate <int mod>\nint fact(int n) {\n    static vector<int> memo(1,1);\n    if (memo.size() <= n) {\n        int l = memo.size();\n        memo.resize(n+1);\n        repeat_from (i,l,n+1) memo[i] = memo[i-1] *(ll) i % mod;\n    }\n    return memo[n];\n}\ntemplate <int mod>\nint choose(int n, int r) { // O(n) at first time, otherwise O(\\log n)\n    if (n < r) return 0;\n    r = min(r, n - r);\n    return fact<mod>(n) *(ll) inv(fact<mod>(n-r), mod) % mod *(ll) inv(fact<mod>(r), mod) % mod;\n}\n\nconstexpr ll mod = 1e9+7;\nint main() {\n    int n, m, k; scanf(\"%d%d%d\", &n, &m, &k);\n    ll result = 0;\n    if (n == 0) {\n        result += powmod(3, m + k, mod);\n    } else {\n        repeat_from (l, n, n+m+k+1) {\n            ll x = choose<mod>(l-1, n-1);\n            ll y = 0;\n            repeat_from (i, max(0, l-n-k), min(l-n, m) + 1) {\n                y += choose<mod>(l-n, i);\n            }\n            y %= mod;\n            ll z = powmod(3, n+m+k-l, mod);\n            result += x * y % mod * z % mod;\n        }\n    }\n    result %= mod;\n    printf(\"%lld\\n\", result);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long LL;\nconst int N=1000005;\nconst int MOD=1e9+7;\n\nint n,m,k,ans,fac[N],inv[N],sum;\n\ninline int fast_pow(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1){\n\t\tif(y&1) ret=1ll*ret*x%MOD;\n\t\tx=1ll*x*x%MOD;\n\t}\n\treturn ret;\n}\n\ninline int C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%MOD*inv[x-y]%MOD;\t\n}\n\nsigned main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfac[0]=inv[0]=1; sum=n+m+k;\n\tfor(int i=1;i<=sum;i++) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[sum]=fast_pow(fac[sum],MOD-2);\n\tfor(int i=sum-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n\t/*\n\tfor(int i=n;i<=sum;i++){\n\t\tint now=0;\n\t\tfor(int j=max(i-n-m,1ll*0);j<=min(k,i-n);j++)\n\t\t\t(now+=C(i-n,j))%=MOD;\n\t\tans+=now%MOD*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD;\n\t\tans%=MOD;\n\t}\n\t*/\n\tif(m<k) swap(m,k); int now=1;\n\tfor(int i=n;i<=sum;i++){\n\t\tif(k+n>=i) {\n\t\t\t(ans+=1ll*C(i-1,n-1)*fast_pow(3,sum-i)%MOD*now%MOD)%=MOD;\n\t\t\tif(k+n!=i) now=now*2%MOD; \t\n\t\t}\n\t\telse if(k+m>=i) {\n\t\t\tnow=now*2-C(i-n-1,k);\n\t\t\tnow=(now%MOD+MOD)%MOD;\n\t\t\t(ans+=1ll*now*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n\t\t}\n\t\telse {\n\t\t\tnow=now*2-C(i-n-1,k); now=(now%MOD+MOD)%MOD;\n\t\t\tnow=(now-C(i-n-1,i-n-m-1)+MOD)%MOD;\n\t\t\t(ans+=1ll*now*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n\t\t}\n\t}\n//\tfor(int i=n;i<=sum;i++) {\n//\t\t(ans+=1ll*C(i-1,n-1)*fast_pow(2,i-n)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tif(i==8) cout<<ans<<endl;\n//\t\tif(n+k+1<=i) \n//\t\t\t(ans-=1ll*C(i-1,n-1)*C(i-n,k+1)%MOD*fast_pow(2,i-n-k-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tif(i==8) cout<<ans<<endl;\n//\t\tif(n+m+1<=i)\n//\t\t\t(ans-=1ll*C(i-1,n-1)*C(i-n,m+1)%MOD*fast_pow(2,i-n-m-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tcout<<ans<<endl;\n//\t}\n//\tfor(int i=n+m;i<sum;i++){\n//\t\t(ans-=1ll*now*fast_pow(3,sum-n-m)%MOD)%=MOD;\n//\t\tnow=1ll*now*i%MOD; now=(now+C(n+m,i-n-m+1))%MOD;\t\n//\t}\n//\tnow=1;\n//\tfor(int i=n+k;i<sum;i++){\n//\t\t(ans-=1ll*now*fast_pow(3,sum-n-k)%MOD)%=MOD;\n//\t\tnow=1ll*now*i%MOD; now=(now+C(n+k,i-n-k+1))%MOD;\n//\t}\t\n\tprintf(\"%d\\n\",(ans+MOD)%MOD);\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 900005;\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - (ll)inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = (ll)fac[i-1] * i % MOD;\n\t\tfinv[i] = (ll)finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nint comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * ((ll)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\ninline int add(int x,int y)\n{\n    return (x+y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\ninline int mod_pow(int a, int b)\n{\n    int res = 1;\n    while(b){\n        if(b & 1){\n            res = (ll)res * a % MOD;\n        }\n        a = (ll)a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    if(K > m) swap(m, K);\n    make();\n    int tm = 0;\n    int cri = 1;\n    int inv3 = mod_pow(3, MOD-2);\n    int cri2 = mod_pow(inv3, n+1);\n    srep(i, n+1, n+K+1){\n        tm = add(tm, mul(comb(i-2, n-1), mul(cri, cri2)));\n        cri = mul(cri, 2);\n        cri2 = mul(cri2, inv3);\n    }\n    srep(i, n+K+1, n+m+2){\n        tm = add(tm, mul(comb(i-2, n-1), mul(cri, cri2)));\n        cri = sub(mul(cri, 2), comb(i-n-1, i-n-K-1));\n        cri2 = mul(cri2, inv3);\n    }\n    cri = 0;\n    srep(i, m-K+1, m+1){\n        cri = add(cri, comb(m+1, i));\n    }\n    srep(i, n+m+2, n+m+K+2){\n        tm = add(tm, mul(comb(i-2, n-1), mul(cri, cri2)));\n        cri = sub(mul(cri, 2), add(comb(i-n-1, i-n-K-1), comb(i-n-1, m)));\n        cri2 = mul(cri2, inv3);\n    }\n    cout << mul(tm, mod_pow(3, n+m+K+1)) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M,K;\nll mo=1000000007;\nll combi(ll N_, ll C_) {\n\tconst int NUM_=1000001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>K;\n\t\n\tll ret=0;\n\tll C=1,L=0,R=0;\n\tfor(int i=N;i<=N+M+K;i++) {\n\t\tll a=combi(i-1,N-1)*modpow(3,N+M+K-i) % mo;\n\t\tif(i>N) C=C*2%mo;\n\t\tif(i==N+M+1) L=1;\n\t\tif(i>N+M+1) L=(L*2+combi(i-N-1,i-N-M-1))%mo;\n\t\tif(i==N+K+1) R=1;\n\t\tif(i>N+K+1) R=(R*2+combi(i-N-1,i-N-K-1))%mo;\n\t\tret += a*(C-L-R+mo+mo) % mo;\n\t}\n\t\n\t\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// integer c = a*b is accurate if c_i < 2^49\n#pragma GCC optimize (\"Ofast\") //10% performance\n#include <complex.h>\nextern \"C\" __complex__ double __muldc3(\n    double a, double b, double c, double d){\n  return a*c-b*d+I*(a*d+b*c); // 40% performance\n}\n#include <bits/stdc++.h>\n//!pause\n#define DEBUG(...) cerr << __VA_ARGS__ << endl;\n\n#ifndef CDEBUG\n#undef DEBUG\n#define DEBUG(...) ((void)0);\n#define NDEBUG\n#endif\n\n#define ran(i, a, b) for (auto i = (a); i < (b); i++)\n\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nconst int mod = 1e9 + 7;\n#ifndef M_PI\nconst double M_PI = acos(-1.0);\n#endif\n\ntypedef complex<double> Comp;\nvoid fft_rec(Comp *arr, Comp *root_pow, int len) {\n  if (len != 1) {\n    fft_rec(arr,       root_pow, len >> 1);\n    fft_rec(arr /*lp*/+ len/*rp*/, root_pow, len >> 1);\n  }\n  root_pow += len;\n  ran(i, 0, len){\n    tie(arr[i], arr[i + len]) = pair<Comp, Comp> {\n        arr[i] /*lp*/+/*rp*/ root_pow[i] * arr[i + len],\n        arr[i] /*lp*/-/*rp*/ root_pow[i] * arr[i + len] };\n  }\n}\nvoid fft(vector<Comp> &arr, int ord, bool invert) {\n  assert(arr.size() == 1 << ord);\n  static vector<Comp> root_pow(1);\n  static int inc_pow = 1;\n  static bool is_inv = false;\n  if (inc_pow <= ord) {\n    int idx = root_pow.size();\n    root_pow.resize(1 << ord);\n    for (; inc_pow <= ord; ++inc_pow) {\n      for (int idx_p = 0; idx_p < 1 << (ord - 1);\n           idx_p += 1 << (ord - inc_pow), ++idx) {\n        root_pow[idx] = Comp {\n           cos(-idx_p * M_PI / (1 << (ord - 1))),\n           sin(-idx_p * M_PI / (1 << (ord - 1))) };\n        if (is_inv) root_pow[idx] = conj(root_pow[idx]);\n      }\n    }\n  }\n  if (invert != is_inv) {\n    is_inv = invert;\n    for (Comp &cur : root_pow) cur = conj(cur);\n  }\n  int j = 0;\n  ran(i, 1, (1<<ord)){\n    int m = 1 << (ord - 1);\n    bool cont = true;\n    while (cont) {\n      cont = j & m;\n      j ^= m;\n      m >>= 1;\n    }\n    if (i < j) swap(arr[i], arr[j]);\n  }\n  fft_rec(arr.data(), root_pow.data(), 1 << (ord - 1));\n  if (invert)\n    ran(i, 0, 1<<ord) arr[i] /= (1 << ord);\n}\n\nvoid mult_poly_mod(vector<int> &a, vector<int> &b,\n  vector<int> &c) { // c += a*b\n  static vector<Comp> arr[4];\n  // correct upto 0.5-2M elements(mod ~= 1e9)\n  if (c.size() < 400) {\n    ran(i, 0, (int)a.size())\n      ran(j, 0, min((int)b.size(), (int)c.size()-i))\n        c[i + j] = ((ll)a[i] * b[j] + c[i + j]) % mod;\n  } else {\n    int ord = 32 - __builtin_clz((int)c.size()-1);\n    if ((int)arr[0].size() != 1 << ord){\n      ran(i, 0, 4) arr[i].resize(1 << ord);\n    }\n    ran(i, 0, 4)\n      fill(arr[i].begin(), arr[i].end(), Comp{});\n    for (int &cur : a) if (cur < 0) cur += mod;\n    for (int &cur : b) if (cur < 0) cur += mod;\n    const int shift = 15;\n    const int mask = (1 << shift) - 1;\n    ran(i, 0, (int)min(a.size(), c.size())){\n      arr[0][i] += a[i] & mask;\n      arr[1][i] += a[i] >> shift;\n    }\n    ran(i, 0, (int)min(b.size(), c.size())){\n      arr[0][i] += Comp{0, (b[i] & mask)};\n      arr[1][i] += Comp{0, (b[i] >> shift)};\n    }\n    ran(i, 0, 2) fft(arr[i], ord, false);\n    ran(i, 0, 2){\n      ran(j, 0, 2){\n        int tar = 2 + (i + j) / 2;\n        Comp mult = {0, -0.25};\n        if (i ^ j) mult = {0.25, 0};\n        ran(k, 0, 1<<ord){\n          int rev_k = ((1 << ord) - k) % (1 << ord);\n          Comp ca = arr[i][k] /*lp*/+/*rp*/ conj(arr[i][rev_k]);\n          Comp cb = arr[j][k] /*lp*/-/*rp*/ conj(arr[j][rev_k]);\n          arr[tar][k] = arr[tar][k] + mult * ca * cb;\n        }\n      }\n    }\n    ran(i, 2, 4){\n      fft(arr[i], ord, true);\n      ran(k, 0, (int)c.size()){\n        c[k] = (c[k] + (((ll)(arr[i][k]/*lp*/.real()/*rp*/+0.5)%mod)\n                    << (shift * (2 * (i-2) + /*lp*/0/*rp*/)))) % mod;\n        c[k] = (c[k] + (((ll)(arr[i][k]/*lp*/.imag()/*rp*/+0.5)%mod)\n                    << (shift * (2 * (i-2) + /*lp*/1/*rp*/)))) % mod;\n      }\n    }\n  }\n}\n\nconst int MOD = 1000000007;\n\ntypedef long long llong;\n\nstruct modint {\n  llong val;\n\n  modint () {\n    val = 0;\n  }\n\n  modint (llong _val) {\n    val = _val % MOD;\n  }\n};\n\nmodint operator+ (modint p, modint q) {\n  return modint((p.val + q.val) % MOD);\n}\n\nmodint operator- (modint p, modint q) {\n  return modint((p.val - q.val + MOD) % MOD);\n}\n\nmodint operator- (modint p) {\n  return modint(0) - p;\n}\n\nmodint operator* (modint p, modint q) {\n  return modint((p.val * q.val) % MOD);\n}\n\nmodint operator^ (modint p, int q) {\n  modint pows [30];\n\n  pows[0] = p;\n  for (int i = 1; i < 30; i++) {\n    pows[i] = pows[i - 1] * pows[i - 1];\n  }\n\n  modint ans (1);\n  for (int i = 0; i < 30; i++) {\n    if (q & 1 << i) {\n      ans = ans * pows[i];\n    }\n  }\n\n  return ans;\n}\n\nmodint inv (modint p) {\n  return p ^ (MOD - 2);\n}\n\nmodint operator/ (modint p, modint q) {\n  return p * (q ^ (MOD - 2));\n}\n\nconst int MAX_N = 600005;\n\nmodint fact [MAX_N];\n\nint main () {\n  fact[0] = modint(1);\n  for (int i = 1; i < MAX_N; i++) {\n    fact[i] = fact[i - 1] * modint(i);\n  }\n\n  int N, M, K;\n  cin >> N >> M >> K;\n  N--;\n\n  vector<int> bobFact (M + K + 10, 0);\n  vector<int> charlieFact (M + K + 10, 0);\n\n  for (int i = 0; i <= M; i++) {\n    bobFact[i] = inv(fact[i]).val;\n  }\n\n  for (int i = 0; i <= K; i++) {\n    charlieFact[i] = inv(fact[i]).val;\n  }\n\n  vector<int> factArr (M + K + 10, 0);\n  mult_poly_mod(bobFact, charlieFact, factArr);\n\n  modint ans (0);\n  for (int u = 0; u <= M + K; u++) {\n    ans = ans + fact[N + u] * modint(factArr[u]) * (modint(3) ^ (M + K - u)) / fact[N];\n  }\n  cout << ans.val << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n//# pragma GCC target (\"sse4\")\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n,m,k;\n    fi>>n>>m>>k;\n    static int f[1 << 20];\n    auto pow = [&](auto a,auto b,auto mod)\n    {\n        int ans = 1;\n        while (b)\n        {\n            if (b&1) ans = (1ll * ans * a) % mod;\n            a = (1ll * a * a) % mod;\n            b /= 2;\n        }\n        return ans;\n    };\n    const int mod = 1e9 + 7;\n    static int c[1 << 20];\n    const int N = 1e6;\n    f[0] = c[0] = 1;\n    for (int i = 1;i <= N;++i)\n        f[i] = (1ll * f[i-1] * i) % mod;\n    c[N] = pow(f[N],mod - 2,mod);\n    for (int i = N - 1;i;--i)\n        c[i] = (1ll * (i + 1) * c[i + 1]) % mod;\n    auto C = [&](auto n,auto k)\n    {\n        if (!(0 <= k && k <= n)) return 0;\n        auto ans = f[n];\n        ans = (1ll * ans * c[k]) % mod;\n        ans = (1ll * ans * c[n - k]) % mod;\n        return ans;\n    };\n    int cnt = 1;\n    int ans = 0;\n    for (int i = 0;i <= m + k;++i)\n    {\n        ans = (ans + (1ll * cnt *  C(i + n - 1,n - 1) % mod) * pow(3,m + k - i,mod)) % mod;\n        (cnt <<= 1) %= mod;\n        cnt = (1ll * cnt + mod - C(i,m)) % mod;\n        cnt = (1ll * cnt + mod - C(i,k)) % mod;\n    }\n    fo << ans << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\n\n// Problem Specific Parameter:\nconst ll mod=1000000007LL;\nconst int limit=1000000;\nvector<ll> fact(limit+1),rfact(limit+1);\n\t\nll power(ll a,ll n){\n\tll b=1LL;\n\twhile(n){\n\t\tif(n&1) b=b*a%mod;\n\t\ta=a*a%mod;\n\t\tn>>=1;\n\t}\n\treturn b;\n}\n\nvoid init(){\n\tfact[0]=1LL;\n\trep(i,1,limit+1) fact[i]=1LL*i*fact[i-1]%mod;\n\trfact[limit]=power(fact[limit],mod-2);\n\trrep(i,limit+1,1) rfact[i-1]=i*rfact[i]%mod;\n}\n\ninline ll C(ll n,ll k){\n\tif(k<0 or n<k) return 0LL;\n\treturn fact[n]*rfact[k]%mod*rfact[n-k]%mod;\n}\n\nint main(void){\n\tinit();\n\n\tll n,m,k;\n\tcin >> n >> m >> k;\n\n\tll ans=0LL,mid=1LL;\n\trep(t,n,n+m+k+1){\n\t\tll lft=C(t-1,n-1);\n\t\tll rgt=power(3LL,n+m+k-t);\n\t\tans+=1LL*lft*mid%mod*rgt%mod;\n\t\t//cout << mid << endl;\n\t\tans%=mod;\n\t\tmid=2LL*mid%mod;\n\t\tmid=(mid+2LL*mod-C(t-n,t-n-k)-C(t-n,m))%mod;\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ninline int read()\n{\n\tint res, ok = 1;\n\tchar ch;\n\tfor (ch = getchar(); ch < '0' || ch > '9'; ch = getchar())\n\tif (ch == '-')\n\tok = -1;\n\tres = ch - '0';\n\tfor (ch = getchar(); ch >= '0' && ch <= '9'; ch = getchar())\n\tres = res * 10 + ch - '0';\n\treturn res * ok;\n}\nlong long mod = 1e9 + 7;\nint n, m, k;\nlong long qp2[1000005], qp3[1000005], f[1000005], rev[1000005], fac[1000005], ans, last;\ninline long long C (int x, int y)\n{\n\tlong long num = f[y];\n\tnum = num * fac[x] % mod;\n\tnum = num * fac[y - x] % mod;\n\treturn num;\n}\nint main()\n{\n\tn = read();\n\tm = read();\n\tk = read();\n\tqp2[0] = 1;\n\tqp3[0] = 1;\n\tf[0] = 1;\n\trev[0] = rev[1] = 1;\n\tfac[0] = fac[1] = 1;\n\tfor (int i = 1; i <= n + m + k; i++)\n\t{\n\t\tqp2[i] = qp2[i - 1] * 2 % mod;\n\t\tqp3[i] = qp3[i - 1] * 3 % mod;\n\t\tf[i] = f[i - 1] * i % mod;\n\t\tif (i >= 2)\n\t\t{\n\t\t\trev[i] = mod - (mod / i) * rev[mod % i] % mod;\n\t\t\tfac[i] = fac[i - 1] * rev[i] % mod;\n\t\t}\n\t}\n\tif (m > k)\n\tswap (m, k);\n\tfor (int i = 0; i <= m; i++)\n\tans = (ans + qp2[i] * C (i, i + n - 1) % mod * qp3[m + k - i] % mod) % mod;\n\tlast = qp2[m];\n\tfor (int i = m + 1; i <= m + k; i++)\n\t{\n\t\tlast <<= 1;\n\t\tlast -= C (m, i - 1);\n\t\tlast %= mod;\n\t\tif (i > k)\n\t\tlast -= C (i - k - 1, i - 1);\n\t\tlast %= mod;\n\t\tif (last < 0)\n\t\tlast += mod;\n\t\tif (last >= mod)\n\t\tlast -= mod;\n\t\tans = (ans + last * C (i, i + n - 1) % mod * qp3[m + k - i] % mod) % mod;\n\t}\n\tprintf (\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 900005;\nconst int mod = 1e9 + 7;\n\n#define int long long\n\nint n, m, k, res;\nint prd[N], inv[N], pw3[N], f[N];\n\nint C(int k, int n) {\n\tif (n < k || n < 0 || k < 0) return 0;\n\treturn prd[n] * inv[k] % mod * inv[n - k] % mod; \n}\n\nint pw(int x, int y) {\n\tif (!y) return 1;\n\tint ret = pw(x, y >> 1); ret = ret * ret % mod;\n\tif (y & 1) ret = ret * x % mod; return ret;\n}\n\nvoid prepare() {\n\tprd[0] = 1;\n\tfor (int i = 1; i < N; ++i) prd[i] = prd[i - 1] * i % mod;\n\tinv[N - 1] = pw(prd[N - 1], mod - 2);\n\tfor (int i = N - 1; i >= 1; --i) inv[i - 1] = inv[i] * i % mod;\n\tpw3[0] = 1;\n\tfor (int i = 1; i < N; ++i) pw3[i] = 3LL * pw3[i - 1] % mod;\n}\n\nsigned main() {\n\tcin >> n >> m >> k;\n\tprepare();\n\tf[0] = 1; \n\tint L = 0, R = 0;\n\tfor (int i = 1; i <= m + k; ++i) {\n\t\tint l = max(0LL, i - k), r = min(m, i);\n\t\tf[i] = f[i - 1] * 2 + C(L - 1, i - 1) - C(R, i - 1);\n\t\tif (l == L + 1) f[i] -= C(l - 1, i);\n\t\tif (r == R + 1) f[i] += C(r, i);\n\t\tf[i] %= mod; if (f[i] < 0) f[i] += mod;\n\t\tL = l, R = r;\n\t\t// cout << f[i] << ' ' << l << ' ' << r << '\\n';\n\t}\n\tfor (int i = 0; i <= m + k; ++i) {\n\t\tres = (res + f[i] * pw3[m + k - i] % mod * C(i, n - 1 + i)) % mod;\n\t}\n\tcout << res;\n}"
  },
  {
    "language": "C++",
    "code": "//Night's template\n//orzakyrt\n#include <bits/stdc++.h>\n#define R register\n#define LL long long\n#ifdef __DEBUG__\n\t#define Debug puts(\"orzyrt\")\n\t#define debug(__a...) fprintf(stderr,__a);\n#else\n\t#define Debug ('orzyrt')\n\t#define debug(__a...) ('orzyrt')\n#endif\ninline void Compile(R char *s){\n\tchar com[11111];\n\tsprintf(com,\"g++ %s.cpp -lm -o %s\",s,s);\n\tsystem(com);\n}\ninline void setfile(R char *s){\n\tchar inname[111],outname[111];\n\tsprintf(inname,\"%s.in\",s);\n\tsprintf(outname,\"%s.out\",s);\n\tfreopen(inname,\"r\",stdin);\n\tfreopen(outname,\"w\",stdout);\n}\n#ifdef __DEBUG__\n\t#define setfile(__a) (1)\n#endif\ntemplate<class TT>inline TT Max(R TT a,R TT b){return a<b?b:a;}\ntemplate<class TT>inline TT Min(R TT a,R TT b){return a<b?a:b;}\ntemplate<class TT>inline TT Abs(R TT a){return a<0?-a:a;}\ntemplate<class TT>inline TT cmin(R TT &a,R TT b){(a>b)&&(a=b);}\ntemplate<class TT>inline TT cmax(R TT &a,R TT b){(a<b)&&(a=b);}\nusing namespace std;\ntemplate<class TT>inline void read(R TT &x){\n\tx=0;R bool f=false;R char c=getchar();\n\tfor(;c<48||c>57;c=getchar())f|=(c=='-');\n\tfor(;c>47&&c<58;c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\t(f)&&(x=-x);\n}\n//end template\n\nconst int maxn = 1e6+10;\nconst int mod = 1e9+7;\ninline LL qpow(R LL a,R LL b){\n\tR LL ret=1;a%=mod;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ret;\n}\ninline LL rev(R LL x){\n\treturn qpow(x,mod-2);\n}\nint n,m,k;\nLL f[maxn],rf[maxn],p3[maxn];\ninline LL nCr(R int n,R int r){\n\treturn f[n]*rf[r]%mod*rf[n-r]%mod;\n}\nint main(){\n\tread(n);read(m);read(k);\n\tfor(R int i=*f=*rf=1;i<maxn;++i){\n\t\tf[i]=i*f[i-1]%mod;\n\t\trf[i]=rev(f[i]);\n\t}\n\tfor(R int i=*p3=1;i<maxn;++i){\n\t\tp3[i]=p3[i-1]*3%mod;\n\t}\n\tR LL ans=0;\n\tR LL s=1;\n\tR int l=0,r=0;\n\tfor(R int i=0;i<=m+k;++i){\n\t\tans+=nCr(n-1+i,n-1)*s%mod*p3[m+k-i]%mod;\n\t\tR int ll=Max(0,i+1-k);\n\t\tR int rr=Min(i+1,m);\n\t\ts*=2;\n\t\tif(l<ll)s-=nCr(i,l);\n\t\tif(r==rr)s-=nCr(i,r);\n\t\ts=(s%mod+mod)%mod;\n\t\tl=ll;r=rr;\n\t}\n\tprintf(\"%lld\\n\",ans%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define f1(a,b,c) for(int c=a;c<=b;c++)\n#define f2(a,b,c) for(int c=a;c>=b;c--)\n#define f3(a,b,c) for(int c=a;c;c=b)\n#define so1(a,n) sort(a+1,a+n+1,mycmp);\n#define so2(a,n) sort(a+1,a+n+1);\n#define ll long long\n#define itn int\n#define ubt int \nconst int twx=3e5+100;\nconst int inf=0x7fffffff;\nconst int MOD=1e9+7;\nll read()\n{\n    ll sum=0;\n    ll flag=1;\n    char c=getchar();\n    while(c<'0'||c>'9')\n    {\n        if(c=='-')\n        {\n            flag=-1;\n        }\n        c=getchar();\n    }\n    while(c>='0'&&c<='9')\n    {\n        sum=((sum*10)+c-'0');\n        c=getchar();\n    }\n    return sum*flag;\n}\nint ADD(int a,int b)\n{\n    return a+b>=MOD?a+b-MOD:a+b;\n}\nint SUB(int a,int b)\n{\n    return a-b<0?a-b+MOD:a-b;\n}\nint MUL(int a,int b)\n{\n    return 1LL*a*b%MOD;\n}\nint n,m,k;\nint jc[twx<<2];\nint inv[twx<<2];\nint invj[twx<<2];\nint p[twx<<2];\nint ans(0);\nint x=1;\nvoid pre()\n{\n    p[0]=1;\n    f1(1,twx*3,i)\n    {\n        p[i]=MUL(p[i-1],3);\n    }\n    jc[0]=1;\n    f1(1,twx*3,i)\n    {\n        jc[i]=MUL(jc[i-1],i);\n    }\n    inv[1]=1;\n    f1(2,twx*3,i)\n    {\n        inv[i]=MUL(SUB(MOD,MOD/i),inv[MOD%i]);\n    }\n    invj[0]=1;\n    f1(1,twx*3,i)\n    {\n        invj[i]=MUL(invj[i-1],inv[i]);\n    }\n}\nint C(int n, int m)\n{\n\treturn MUL(jc[n],MUL(invj[m],invj[n-m]));\n}\nvoid init()\n{\n\tn=read();\n    m=read();\n    k=read();\n}\nvoid work()\n{\n\tif(m<k)\n    {\n        swap(m,k);\n    }\n\t--n;\n    f1(0,m+k,i)\n    {\n        ans=ADD(ans,MUL(C(n+i,n),MUL(p[m+k-i],x)));\n        if(i<k)\n        {\n            x=MUL(x,2);\n        }\n        else if(i<m)\n        {\n            x=SUB(MUL(x,2),C(i,k));\n        }\n        else   \n        {\n            x=SUB(MUL(x,2),ADD(C(i,m),C(i,k)));\n        }\n    }\n}\nvoid print()\n{\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n    init();\n    pre();\n    work();\n    print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\ntypedef long long int64;\nstatic const int MAXN = 3e5 + 4;\nstatic const int MODULUS = 1e9 + 7;\n#define _  %  MODULUS\n#define __ %= MODULUS\n\nint n, m, k;\n\nint64 fact[MAXN * 3], fact_inv[MAXN * 3];\n\ninline int64 fpow(int64 base, int exp)\n{\n    int64 ans = 1;\n    for (; exp; exp >>= 1, (base *= base)__) if (exp & 1) (ans *= base)__;\n    return ans;\n}\nvoid preprocess()\n{\n    fact[0] = 1;\n    for (int i = 1; i < MAXN * 3; ++i) fact[i] = fact[i - 1] * i _;\n    fact_inv[MAXN * 3 - 1] = fpow(fact[MAXN * 3 - 1], MODULUS - 2);\n    for (int i = MAXN * 3 - 2; i >= 0; --i) fact_inv[i] = fact_inv[i + 1] * (i + 1)_;\n}\ninline int64 binom(int n, int m)\n{\n    if (n < m) return 0; else return fact[n] * fact_inv[m]_ * fact_inv[n - m]_;\n}\n\n/*inline int64 _f(int s)\n{\n    int64 ans = 0;\n    for (int t = std::max(0, s - k); t <= m; ++t) (ans += binom(s, t))__;\n    //printf(\"%2d | %2d | %2d\\n\", s, std::max(0, s - k), m);\n    return ans;\n}*/\n\nint64 f[MAXN * 3];\n\nint main()\n{\n    preprocess();\n    scanf(\"%d%d%d\", &n, &m, &k);\n\n    f[0] = 1;\n\n    if (m < k) { int t = m; m = k; k = t; }\n    for (int i = 1; i <= k; ++i) f[i] = (f[i - 1] + f[i - 1])_;\n    for (int i = k + 1; i <= m + k; ++i)\n        f[i] = (f[i - 1] + f[i - 1] - binom(i - 1, i - 1 - k) - binom(i - 1, m) + MODULUS * 2)_;\n\n    int64 ans = 0;\n    //for (int i = 0; i <= m + k; ++i) printf(\"%2d | %lld | %lld\\n\", i, f[i], _f(i));\n    for (int s = n + 1; s <= n + m + k + 1; ++s) {\n        (ans += binom(s - 2, n - 1) * f[s - n - 1]_ * fpow(3, n + m + k + 1 - s))__;\n    }\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename T> constexpr T fpow_eq(T& x, ll y, T identity = 1) {\n    for(; y > 0; x *= x, y >>= 1) {\n        if(y & 1) {\n            identity *= x;\n        }\n    }\n    return x = identity;\n}\ntemplate <typename T> constexpr T fpow(T x, ll y, T identity = 1) { return fpow_eq(x, y, identity); }\n#ifndef __TOTIENT_INCLUDED_\n#define __TOTIENT_INCLUDED_\ntemplate <typename T, typename TEachDivisor, typename TEachPrime>\nconstexpr void factorize(T n, TEachDivisor each_divisor, TEachPrime each_prime = [](T) {}) {\n    static_assert(is_convertible<decltype(each_divisor), function<void(T)>>::value, \"each_divisor must be void(T)\");\n    static_assert(is_convertible<decltype(each_prime), function<void(T)>>::value, \"each_prime must be void(T)\");\n    for(T i = 2; i * i <= n; i++) {\n        if(n % i == 0) {\n            each_prime(i);\n            while(n % i == 0) {\n                each_divisor(i);\n                n /= i;\n            }\n        }\n    }\n    if(n > 1) {\n        each_divisor(n);\n        each_prime(n);\n    }\n}\ntemplate <typename T> constexpr T phi(T n) {\n    T ans = n;\n    factorize<T>(n, [](T) {}, [&](T p) { ans -= ans / p; });\n    return ans;\n}\n#endif\n#ifdef __TOTIENT_INCLUDED_\ntemplate <int M, int PHI_M = phi(M)> struct modint {\n#else\ntemplate <int M, int PHI_M> struct modint {\n#endif\n    static constexpr int MOD = M;\n    int val;\n    constexpr modint() : val(0) {}\n    constexpr modint(int val) : val(val % M) { this->val += this->val < 0 ? M : 0; }\n    constexpr modint(long long val) : modint(int(val % M)) {}\n    constexpr modint(const modint& m) : val(m.val) {}\n    constexpr modint(const complex<long double>& x) : modint(llround(x.real())) {}\n    constexpr explicit operator int() const { return val; }\n    constexpr bool operator==(const modint& y) const { return val == y.val; }\n    constexpr bool operator!=(const modint& y) const { return val != y.val; }\n    constexpr bool operator< (const modint& y) const { return val <  y.val; }\n    constexpr bool operator<=(const modint& y) const { return val <= y.val; }\n    constexpr bool operator> (const modint& y) const { return val >  y.val; }\n    constexpr bool operator>=(const modint& y) const { return val >= y.val; }\n    constexpr modint& operator=(const modint& y) { val = y.val; return *this; }\n    constexpr modint& operator+=(const modint& y) { val += y.val; val -= val >= M ? M : 0; return *this; }\n    constexpr modint& operator-=(const modint& y) { val -= y.val; val += val <  0 ? M : 0; return *this; }\n    constexpr modint& operator*=(const modint& y) { val = ll(val) * y.val % M; return *this; }\n    constexpr modint& operator/=(const modint& y) { val = ll(val) * fpow(y, PHI_M - 1).val % M; return *this; }\n    constexpr modint& operator^=(ll y) { fpow_eq(*this, y); return *this; }\n    constexpr modint operator+(const modint& y) const { return modint(val) += y; }\n    constexpr modint operator-(const modint& y) const { return modint(val) -= y; }\n    constexpr modint operator*(const modint& y) const { return modint(val) *= y; }\n    constexpr modint operator/(const modint& y) const { return modint(val) /= y; }\n    constexpr modint operator^(ll y) const { return modint(val) ^= y; }\n    constexpr modint operator-() const { return modint(0) -= *this; }\n    constexpr modint operator~() const { return modint(1) /= *this; }\n    constexpr modint& operator++() { val = val == M - 1 ? 0 : val + 1; return *this; }\n    constexpr modint& operator--() { val = val == 0 ? M - 1 : val - 1; return *this; }\n    constexpr modint operator++(int) { modint m = *this; ++(*this); return m; }\n    constexpr modint operator--(int) { modint m = *this; --(*this); return m; }\n    friend constexpr modint operator+(long long x, const modint& y) { return modint(x) + y; }\n    friend constexpr modint operator*(long long x, const modint& y) { return modint(x) * y; }\n    friend constexpr modint operator-(long long x, const modint& y) { return modint(x) - y; }\n    friend constexpr modint operator/(long long x, const modint& y) { return modint(x) / y; }\n    friend ostream& operator<<(ostream& os, const modint& m) { return os << m.val; }\n    friend istream& operator>>(istream& is, modint& m) { ll val; is >> val; m = modint(val); return is; }\n};\nconstexpr int M = 1'000'000'007;\nusing mint = modint<M, M - 1>;\nmint operator\"\"_m(unsigned long long int x) { return mint(ll(x)); }\ntemplate <typename T = mint> T fact(int n) {\n    static vector<T> fac = {1};\n    while(fac.size() <= n) {\n        fac.push_back(fac.back() * int(fac.size()));\n    }\n    return fac[n];\n}\ntemplate <typename T = mint> T fact_inv(int n) {\n    static vector<T> inv_fac = {1};\n    while(inv_fac.size() <= n) {\n        inv_fac.push_back(inv_fac.back() / int(inv_fac.size()));\n    }\n    return inv_fac[n];\n}\nconst double PI = acos(-1);\ncomplex<long double> w(int len, bool inverse) {\n    return polar<long double>(1, (inverse ? -2 : 2) * (PI / len));\n}\nconstexpr int lg(int x) { return 31 - __builtin_clz(x); }\ntemplate <typename T> vector<T>& pad(vector<T>& a, int min_size) {\n    a.resize(2 << lg(min_size - 1));\n    return a;\n}\nint bit_reverse(int i, int n) {\n    int ans = 0;\n    for(int j = 0; j < lg(n); j++) {\n        ans |= i & (1 << j) ? 1 << (lg(n) - 1 - j) : 0;\n    }\n    return ans;\n}\ntemplate <typename T> vector<T>& fft(vector<T>& a, bool inverse = false) {\n    int n = a.size();\n    for(int i = 0; i < n; i++) {\n        if(i < bit_reverse(i, n)) {\n            swap(a[i], a[bit_reverse(i, n)]);\n        }\n    }\n    for(int len = 2; len <= n; len <<= 1) {\n        T W = w(len, inverse);\n        for(int i = 0; i < n; i += len) {\n            T root = 1;\n            for(int j = i; j < i + (len >> 1); j++) {\n                T u = a[j], t = root * a[j + (len >> 1)];\n                a[j] = u + t;\n                a[j + (len >> 1)] = u - t;\n                root *= W;\n            }\n        }\n    }\n    if(inverse) {\n        transform(a.begin(), a.end(), a.begin(), [n](T& ai) { return ai / T(n); });\n    }\n    return a;\n}\ntemplate <typename T> vector<T>& operator*=(vector<T>& a, vector<T>& b) {\n    fft(pad(a, a.size())); if(addressof(a) != addressof(b)) fft(pad(b, b.size()));\n    assert(a.size() == b.size());\n    transform(a.begin(), a.end(), b.begin(), a.begin(), multiplies<T>());\n    fft(a, true); if(addressof(a) != addressof(b)) fft(b, true);\n    return a;\n}\ntemplate <typename T> vector<T> operator*(vector<T> a, vector<T>& b) { return a *= b; }\ntemplate <int C = int(sqrt(mint::MOD) + 0.5)> vector<mint> operator*=(vector<mint>& a, vector<mint>& b) {\n    vector<complex<long double>> a1(a.size()), a2(a.size()), b1(b.size()), b2(b.size());\n    transform(a.begin(), a.end(), a1.begin(), [](mint& ai) { return ai.val % C; });\n    transform(a.begin(), a.end(), a2.begin(), [](mint& ai) { return ai.val / C; });\n    transform(b.begin(), b.end(), b1.begin(), [](mint& bi) { return bi.val % C; });\n    transform(b.begin(), b.end(), b2.begin(), [](mint& bi) { return bi.val / C; });\n    vector<complex<long double>> a1b1 = b1 * a1, &a2b1 = b1 *= a2, &a1b2 = a1 *= b2, &a2b2 = a2 *= b2;\n    for(int i = 0; i < a.size(); i++) {\n        a[i] = mint(a1b1[i]) + mint(a1b2[i]) * C + mint(a2b1[i]) * C + mint(a2b2[i]) * C * C;\n    }\n    return a;\n}\ntemplate <int C = int(sqrt(mint::MOD) + 0.5)> vector<mint> operator*(vector<mint> a, vector<mint>& b) { return a *= b; }\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<mint> a(m + k + 1);\n    for(int i = 0; i <= m + k; i++) {\n        a[i] = fact(n - 1 + i);\n    }\n    vector<mint> b(k + 1);\n    for(int j = 0; j <= k; j++) {\n        b[j] = fact_inv(j) * (3_m ^ (k - j));\n    }\n    reverse(b.begin(), b.end());\n    b.resize(a.size());\n    a *= b;\n    mint ans = 0;\n    for(int i = 0; i <= m; i++) {\n        ans += fact_inv(n - 1) * fact_inv(i) * (3_m ^ (m - i)) * a[k + i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble PI=3.141592653589793;\n\ncomplex <double> dftn[2100007];\ncomplex <double> dfts[2100007];\n\ncomplex <double> a1[2100007];\ncomplex <double> b1[2100007];\ncomplex <double> a2[2100007];\ncomplex <double> b2[2100007];\n\ndouble cosi[2100007];\ncomplex <double> omega[2100007];\n\ninline int potenga(int v)\n{\n    for (int i=1; 1; i<<=1)\n    {\n        if (i>=v)\n        {\n            return i;\n        }\n    }\n}\n\ninline void dft(int n, int kier)\n{\n    int n2=n-1;\n    int s=0;\n    int p;\n    int g;\n\n    for (int i=2; i<=n; i<<=1)\n    {\n\n        for (int j=0; j<n; j++)\n        {\n            dfts[j]=dftn[j];\n            dftn[j]=0;\n        }\n\n        p=n/i;\n\n        if (kier)\n        {\n            g=0;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=j+1;\n                    s=0;\n                }\n            }\n        }\n        else\n        {\n            g=n;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=n-j-1;\n                    s=0;\n                }\n            }\n        }\n    }\n}\n\nvoid licz_omegi(int n1)\n{\n    double kat=2.0*PI/n1;\n    int n2=n1-1;\n    int dod=3*n1/4;\n\n    for (int i=0; i<=n1; i++)\n    cosi[i]=cos(kat*i);\n    for (int i=0; i<=n1; i++)\n    omega[i]=complex <double> (cosi[i], cosi[(i+dod)&n2]);\n}\n\nvector <long long> fft_dokladne(vector <long long> &jed, vector <long long> &dwa)\n{\n    int n1=potenga(jed.size()+dwa.size());\n\n    licz_omegi(n1);\n\n    long long M=32000;\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]/M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a1[i]=dftn[i];\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]%M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b1[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]/M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a2[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]%M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b2[i]=dftn[i];\n\n    vector <long long> ret;\n    for (int i=0; i<n1; i++)\n    ret.push_back(0);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=(llround(dftn[i].real()/n1)%1000000007)*M*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*b2[i]+b1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1)*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=b1[i]*b2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1);\n\n    for (int i=0; i<ret.size(); i++)\n        ret[i]%=1000000007;\n\n    return ret;\n}\n\nint n, m, k;\n\nint s;\n\nlong long mod=1000000007;\n\nlong long sil[1000007];\nlong long odw[1000007];\n\nvector <long long> d1, d2, d3;\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n    long long wyk=mod-2;\n    while(wyk)\n    {\n        if (wyk&1)\n        {\n            a*=b;\n            a%=mod;\n        }\n        b*=b;\n        b%=mod;\n        wyk>>=1;\n    }\n    return a;\n}\n\ninline long long komb(int a, int b)\n{\n    if (b<0 || b>a)\n        return 0;\n    return (sil[a]*((odw[b]*odw[a-b])%mod))%mod;\n}\n\ninline long long komz(int a, int b)\n{\n    return komb(a+b-1, b);\n}\n\nint main()\n{\n    //n=300000;\n    //m=300000;\n    //k=300000;\n    scanf(\"%d%d%d\", &n, &m, &k);\n    s=n+m+k;\n    sil[0]=1;\n    odw[0]=1;\n    for (int i=1; i<=s; i++)\n        sil[i]=(sil[i-1]*i)%mod;\n    odw[s]=dziel(1, sil[s]);\n    for (int i=s-1; i; i--)\n        odw[i]=(odw[i+1]*(i+1))%mod;\n    for (int i=0; i<=m; i++)\n        d1.push_back((komz(n, i)*odw[n+i-1])%mod);\n    for (int i=0; i<=k; i++)\n        d2.push_back(odw[i]);\n    d3=fft_dokladne(d1, d2);\n    for (int i=0; i<=m+k; i++)\n    {\n        wyn*=3;\n        wyn+=d3[i]*sil[n+i-1];\n        wyn%=mod;\n    }\n    printf(\"%lld\\n\", wyn%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 9e5 + 5, MOD = 1e9 + 7;\nint fac[N], rev[N];\nint mpow(int x, int n) {\n\tint res = 1;\n\twhile (n) {\n\t\tif (n & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint C(int n, int m) {\n\treturn 1LL * fac[n] * rev[m] % MOD * rev[n - m] % MOD;\n}\nint main() {\n\tfac[0] = rev[0] = 1;\n\tfor (int i = 1; i < N; ++ i) {\n\t\tfac[i] = 1LL * fac[i - 1] * i % MOD;\n\t\trev[i] = mpow(fac[i], MOD - 2);\n\t}\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tint ans = 0;\n\tint l = 0, r = 0, sum = 1;\n\tfor (int s = 0; s <= m + k; ++ s) {\n\t\tint res = 1LL * C(s + n - 1, s) * mpow(3, m + k - s) % MOD;\n\t\tint L = max(0, s - k), R = min(m, s);\n\t\twhile (l > L) (sum += C(s, -- l)) %= MOD;\n\t\twhile (r < R) (sum += C(s, ++ r)) %= MOD;\n\t\twhile (l < L) (sum += MOD - C(s, l ++)) %= MOD;\n\t\twhile (r > R) (sum += MOD - C(s, r --)) %= MOD;\n\t\t(ans += 1LL * res * sum % MOD) %= MOD;\n\t\tsum = (2LL * sum + MOD - C(s, l) + MOD - C(s, r)) % MOD;\n\t\tl ++;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n#include <numeric>\n#include <bitset>\n#include <ext/algorithm>\n#include <ext/numeric>\n#define ffor(_a,_f,_t) for(int _a=(_f),__t=(_t);_a<__t;_a++)\n#define all(_v) (_v).begin() , (_v).end()\n#define sz size()\n#define pb push_back\n#define SET(__set, val) memset(__set, val, sizeof(__set))\n#define FOR(__i, __n) ffor (__i, 0, __n)\ntypedef long long LL; using namespace std;\n\nint N, M, K;\n\nconst int MOD = 1000000007;\n\nint dp[2][1001][1001];\n\nint pow3[300000];\n\nint main() {\n\tcin >> N >> M >> K;\n\tint c, p;\n\tSET(dp, 0);\n\tpow3[0] = 1;\n\tffor (i, 1, 300000) {\n\t\tLL tmp = pow3[i - 1] * 3LL;\n\t\ttmp %= MOD;\n\t\tpow3[i] = tmp;\n\t}\n\tFOR (n, N) {\n\t\tc = n & 1;\n\t\tp = c ^ 1;\n\t\tFOR (m, M + 1)\n\t\t\tFOR (k, K + 1) {\n\t\t\t\tint &ret = dp[c][m][k];\n\t\t\t\tret = 0;\n\t\t\t\tif (!n)\n\t\t\t\t\tret += pow3[m + k];\n\t\t\t\telse\n\t\t\t\t\tret += dp[p][m][k];\n\t\t\t\tif (m)\n\t\t\t\t ret += dp[c][m - 1][k];\n\t\t\t\tif (k)\n\t\t\t\t\tret += dp[c][m][k - 1];\n\t\t\t\tif (ret >= MOD)\n\t\t\t\t\tret -= MOD;\n\t\t\t\tif (ret >= MOD)\n\t\t\t\t\tret -= MOD;\n\t\t\t}\n\t}\n\tcout << dp[(N - 1) & 1][M][K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Mod = 1e9 + 7;\nconst int N = 9e5;\n\nint n, m, k;\nlong long fac[N], vfac[N];\n\nlong long mpow( long long a, int b ) {\n\tlong long rt;\n\tfor( rt = 1; b; b >>= 1, a = (a * a) % Mod )\n\t\tif( b & 1 ) rt = (rt * a) % Mod;\n\treturn rt;\n}\nvoid init( int n ) {\n\tfac[0] = 1;\n\tfor( int i = 1; i <= n; i++ )\n\t\tfac[i] = (fac[i-1] * i) % Mod;\n\tvfac[n]  = mpow( fac[n], Mod - 2 );\n\tfor( int i = n - 1; i >= 0; i-- )\n\t\tvfac[i] = vfac[i+1] * (i + 1) % Mod;\n}\nlong long comb( int n, int m ) {\n\treturn fac[n] * vfac[n-m] % Mod * vfac[m] % Mod;\n}\nint main() {\n\tscanf( \"%d%d%d\", &n, &m, &k );\n\tif( m < k ) swap( m, k );\n\tinit( m + k + n );\n\tlong long sum = 0, ans = 0;\n\tfor( int s = 0; s <= m + k; s++ ) {\n\t\tif( s == 0 ) {\n\t\t\tsum = 1;\n\t\t} else if( s <= k ) {\n\t\t\tsum = (sum<<1) % Mod;\n\t\t} else if( s <= m ) {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1)) % Mod;\n\t\t} else {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1) + Mod - comb(s-1,m)) % Mod;\n\t\t}\n\t\tlong long sub = sum * comb(n-1+s,n-1) % Mod * mpow(3,m+k-s) % Mod;\n\t\tans = (ans + sub) % Mod;\n//\t\tprintf( \"s = %d sub = %lld\\n\", s, sub );\n\t}\n\tprintf( \"%lld\\n\", ans );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int Mod = 1e9 + 7;\nconst int N = 3e6 + 10;\n\nint n, m, k;\nLL pw2[N], pw3[N], fac[N], inv[N];\n\nLL Power(LL a, LL b) {\n\tLL c = 1;\n\tfor (; b; b >>= 1, (a *= a) %= Mod)\n\t\tif (b & 1)\n\t\t\t(c *= a) %= Mod;\n\treturn c;\n}\n\nvoid Init() {\n\tpw2[0] = pw3[0] = 1;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw2[i] = pw2[i - 1] * 2 % Mod;\n\t\tpw3[i] = pw3[i - 1] * 3 % Mod;\n\t\tfac[i] = fac[i - 1] * i % Mod;\n\t}\n\tinv[N - 1] = Power(fac[N - 1], Mod - 2);\n\tfor (int i = N - 2; i; --i)\n\t\tinv[i] = inv[i + 1] * (i + 1) % Mod;\n}\n\nLL Binom(int m, int n) {\n\tif (n > m)\n\t\treturn 0;\n\treturn fac[m] * inv[n] % Mod * inv[m - n] % Mod;\n}\n\nvoid Solve() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tLL fb = 0;\n\tLL fc = 0;\n\tLL ans = 0;\n\tfor (int i = n; i <= n + m + k; ++i) {\n\t\tLL cnt = Binom(i - 1, n - 1);\n\t\tif (i - n == m + 1) \n\t\t\tfb = 1;\n\t\telse if (i - n > m + 1) \n\t\t\tfb = (fb * 2 + Binom(i - n - 1, m)) % Mod;\n\t\tif (i - n == k + 1)\n\t\t\tfc = 1;\n\t\telse if (i - n > k + 1)\n\t\t\tfc = (fc * 2 + Binom(i - n - 1, k)) % Mod;\n\t\tLL f = (pw2[i - n] - fb + Mod - fc + Mod) % Mod;\n\t\t(ans += f * cnt % Mod * pw3[n + m + k - i]) %= Mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n\n\tInit();\n\tSolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nconstexpr int mod = 1000000007;\n\n// 階乗数n!を最初に計算して、呼ばれた時に返す\nclass Factorial {\n    std::vector<int> table;\npublic:\n    Factorial(int max) : table(max) // max:テーブルのサイズ\n    {\n        table[0] = 1;\n        for (int i = 1; i < max; ++i){\n            table[i] = (static_cast<long long>(table[i - 1]) * (i + 1)) % mod;\n        }\n    }\n\n    long long operator () (int n)\n    {\n        if (n < 0) return 0;\n        if (n == 0) return 1;\n        return table[n - 1];\n    }\n};\n\nclass FactorialInverse {\n    std::vector<int> table;\n    Factorial& fact;\npublic:\n    FactorialInverse(int max, Factorial fact) : table(max), fact(fact) // max:テーブルのサイズ\n    {\n        int digit  = 0;\n        {\n            int temp = mod - 2;\n            while (temp > 0){\n                temp >>= 1;\n                ++digit;\n            }\n        }\n        auto origin = fact(max);\n        vector<int> powerorigin2(digit);\n        powerorigin2[0] = origin;\n        for (int i = 1; i < digit; ++i) powerorigin2[i] = (static_cast<long long>(powerorigin2[i - 1]) * powerorigin2[i - 1]) % mod;\n        {\n            int table_max = 1;\n            int temp = mod - 2;\n            for (int i = 0; temp > 0; ++i, temp >>= 1){\n                if (!(temp & 1)) continue;\n                table_max = (static_cast<long long>(table_max) * powerorigin2[i]) % mod;\n            }\n            table[max - 1] = table_max; // origin^(mod - 2)\n        }\n        for (int i = max - 2; i >= 0; --i){\n            table[i] = (static_cast<long long>(table[i + 1]) * (i + 2)) % mod;\n        }\n    }\n\n    long long operator () (int n)\n    {\n        if (n < 0) return 0;\n        if (n == 0) return 1;\n        return table[n - 1];\n    }\n};\n\ntemplate <typename T> // 返り値とテーブルの型\nclass Power3 {\n    std::vector<T> table;\npublic:\n    Power3(int max) : table(max) // max:テーブルのサイズ\n    {\n        table[0] = 3;\n        for (int i = 1; i < max; ++i){\n            table[i] = (static_cast<long long>(table[i - 1]) * 3) % mod;\n        }\n    }\n\n    T operator () (int n)\n    {\n        if (n < 0) return 0;\n        if (n == 0) return 1;\n        return table[n - 1];\n    }\n};\n\nint main()\n{\n    int N, M, K;\n    scanf(\"%d %d %d\\n\", &N, &M, &K);\n\n    Factorial fact(N + M + K);\n    FactorialInverse factinv(N + M + K, fact);\n    function<long long(int, int)> tri = [&](int b, int c){\n        static const long long inv = factinv(N - 1);\n        return (((((fact(N - 1 + b + c) * inv) % mod) * factinv(b)) % mod) * factinv(c)) % mod;\n    };\n    Power3<int> pow3(M + K);\n\n    int result = 0;\n    for (int b = 0; b <= M; ++b){\n        for (int c = 0; c <= K; ++c){\n            result += ((tri(b, c) * pow3(M + K - b - c)) % mod);\n            result %= mod;\n        }\n    }\n    printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define P 1000000007LL\n\nlong long pw3[10101];\nlong long binom[2020][2020];\n\nlong long calc(int a,int b,int c){\n\tif(a==0)return pw3[b+c];\n\tlong long ans=0;\n\tfor(int bb=0;bb<=b;bb++){\n\t\tfor(int cc=0;cc<=c;cc++){\n\t\t\tlong long hoge=(binom[(b-bb)+(c-cc)][a-1]*binom[c-cc][b-bb])%P;\n\t\t\tans+=(hoge*pw3[bb+cc])%P;\n\t\t\tans%=P;\n\t\t}\n\t}\n\treturn ans;\n}\n\n\n//f(2,3,3)=g(4,1,3)\n//f(2,3,4)=g(4,1,4)\n//f(a,b,c)=g(b+1,a-1,c)?\n\n\nmain(){\n\tpw3[0]=1;\n\tfor(int i=1;i<=10000;i++)pw3[i]=(pw3[i-1]*3)%P;\n\tfor(int i=0;i<=2000;i++)for(int j=0;j<=2000;j++)binom[i][j]=(i==0||j==0?1:(binom[i-1][j]+binom[i][j-1])%P);\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tprintf(\"%lld\\n\",calc(a,b,c));\n}"
  },
  {
    "language": "C++",
    "code": "# include \"iostream\"\n# include \"cstdio\"\n\nusing namespace std;\n\nconst int maxm=9e5+10;\nconst int Mod=1e9+7;\n\nint N,M,K,Max;\nlong long Fac[maxm],Inv1[maxm],Inv2[maxm],P[maxm];\n\nlong long C(int x,int y){\n\treturn Fac[x]*Inv2[y]%Mod*Inv2[x-y]%Mod;\n}\n\nint main(){\n\tregister int i,j;\n\tregister long long Ans=0;\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tMax=N+M+K;\n\tFac[0]=Fac[1]=Inv1[0]=Inv1[1]=Inv2[0]=Inv2[1]=1;\n\tP[0]=1,P[1]=3;\n\tfor(i=2;i<=Max;i++){\n\t\tFac[i]=Fac[i-1]*i%Mod;\n\t\tInv1[i]=(Mod-Mod/i)*Inv1[Mod%i]%Mod;\n\t\tInv2[i]=Inv2[i-1]*Inv1[i]%Mod;\n\t\tP[i]=P[i-1]*3%Mod;\n\t}\n\tif(M<K) swap(M,K);\n\tfor(i=0,j=1;i<=M+K;i++){\n\t\tAns=(Ans+C(N-1+i,N-1)*P[M+K-i]%Mod*j)%Mod;\n        if(i<K) j=j*2%Mod;\n        else if(i>=M) j=((j<<1)-C(i,K)-C(i,i-M)+(Mod<<1))%Mod;\n\t\telse j=((j<<1)-C(i,K)+Mod)%Mod;\n\t}\n\tprintf(\"%lld\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble PI=3.141592653589793;\n\ncomplex <double> dftn[1100007];\ncomplex <double> dfts[1100007];\n\ncomplex <double> a1[1100007];\ncomplex <double> b1[1100007];\ncomplex <double> a2[1100007];\ncomplex <double> b2[1100007];\n\ndouble cosi[1100007];\ncomplex <double> omega[1100007];\n\ninline int potenga(int v)\n{\n    for (int i=1; 1; i<<=1)\n    {\n        if (i>=v)\n        {\n            return i;\n        }\n    }\n}\n\ninline void dft(int n, int kier)\n{\n    int n2=n-1;\n    int s=0;\n    int p;\n    int g;\n\n    int prze=0;\n\n    for (int i=2; i<=n; i<<=1)\n    {\n        prze^=1;\n\n        if (prze==1)\n        {\n\n\n            p=n/i;\n\n            if (kier)\n            {\n                g=0;\n                for (int j=0; j<n; j++)\n                {\n                    dfts[j]=dftn[(2*(j-s)+s)&n2]+omega[g]*dftn[(2*(j-s)+p+s)&n2];\n                    s++;\n                    if (s==p)\n                    {\n                        g=j+1;\n                        s=0;\n                    }\n                }\n            }\n            else\n            {\n                g=n;\n                for (int j=0; j<n; j++)\n                {\n                    dfts[j]=dftn[(2*(j-s)+s)&n2]+omega[g]*dftn[(2*(j-s)+p+s)&n2];\n                    s++;\n                    if (s==p)\n                    {\n                        g=n-j-1;\n                        s=0;\n                    }\n                }\n            }\n\n        }\n        else\n        {\n\n            p=n/i;\n\n            if (kier)\n            {\n                g=0;\n                for (int j=0; j<n; j++)\n                {\n                    dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                    s++;\n                    if (s==p)\n                    {\n                        g=j+1;\n                        s=0;\n                    }\n                }\n            }\n            else\n            {\n                g=n;\n                for (int j=0; j<n; j++)\n                {\n                    dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                    s++;\n                    if (s==p)\n                    {\n                        g=n-j-1;\n                        s=0;\n                    }\n                }\n            }\n\n        }\n    }\n    if (prze)\n        for (int i=0; i<n; i++)\n            dftn[i]=dfts[i];\n}\n\nvoid licz_omegi(int n1)\n{\n    double kat=2.0*PI/n1;\n    int n2=n1-1;\n    int dod=3*n1/4;\n\n    for (int i=0; i<=n1; i++)\n    cosi[i]=cos(kat*i);\n    for (int i=0; i<=n1; i++)\n    omega[i]=complex <double> (cosi[i], cosi[(i+dod)&n2]);\n}\n\nvector <long long> fft_dokladne(vector <long long> &jed, vector <long long> &dwa)\n{\n    int n1=potenga(jed.size()+dwa.size());\n\n    licz_omegi(n1);\n\n    long long M=32000;\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]/M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a1[i]=dftn[i];\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]%M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b1[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]/M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a2[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]%M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b2[i]=dftn[i];\n\n    vector <long long> ret;\n    for (int i=0; i<n1; i++)\n    ret.push_back(0);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=(llround(dftn[i].real()/n1)%1000000007)*M*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*b2[i]+b1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1)*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=b1[i]*b2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1);\n\n    for (int i=0; i<ret.size(); i++)\n        ret[i]%=1000000007;\n\n    return ret;\n}\n\nint n, m, k;\n\nint s;\n\nlong long mod=1000000007;\n\nlong long sil[1000007];\nlong long odw[1000007];\n\nvector <long long> d1, d2, d3;\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n    long long wyk=mod-2;\n    while(wyk)\n    {\n        if (wyk&1)\n        {\n            a*=b;\n            a%=mod;\n        }\n        b*=b;\n        b%=mod;\n        wyk>>=1;\n    }\n    return a;\n}\n\ninline long long komb(int a, int b)\n{\n    if (b<0 || b>a)\n        return 0;\n    return (sil[a]*((odw[b]*odw[a-b])%mod))%mod;\n}\n\ninline long long komz(int a, int b)\n{\n    return komb(a+b-1, b);\n}\n\nint main()\n{\n    //n=300000;\n    //m=300000;\n    //k=300000;\n    scanf(\"%d%d%d\", &n, &m, &k);\n    s=n+m+k;\n    sil[0]=1;\n    odw[0]=1;\n    for (int i=1; i<=s; i++)\n        sil[i]=(sil[i-1]*i)%mod;\n    odw[s]=dziel(1, sil[s]);\n    for (int i=s-1; i; i--)\n        odw[i]=(odw[i+1]*(i+1))%mod;\n    for (int i=0; i<=m; i++)\n        d1.push_back((komz(n, i)*odw[n+i-1])%mod);\n    for (int i=0; i<=k; i++)\n        d2.push_back(odw[i]);\n    d3=fft_dokladne(d1, d2);\n    for (int i=0; i<=m+k; i++)\n    {\n        wyn*=3;\n        wyn+=d3[i]*sil[n+i-1];\n        wyn%=mod;\n    }\n    printf(\"%lld\\n\", wyn%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PP;\ntypedef complex<double> com;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize = 900010;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nvector<ll> fac(modsize + 5);\nvector<ll> inv(modsize + 5);\nvector<ll> facinv(modsize + 5);\n\nvoid modcalc() {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = facinv[1] = 1;\n\tfor (int i = 2; i < modsize; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn modcomb(n + k - 1, k);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tmodcalc();\n\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tint ans = 0;\n\tint p = 1;\n\trep(i, b + c + 1) {\n\t\tint cnt = modpow(3, b + c - i);\n\t\tcnt *= modcomb(a + i - 1, a - 1); cnt %= mod;\n\t\tcnt *= p; cnt %= mod;\n\t\tans += cnt; if (ans > mod) ans -= mod;\n\t\tp *= 2; p += 2 * mod;\n\t\tp -= modcomb(i, b); p -= modcomb(i, c); p %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  template<class Z> ModInt(Z x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool) *this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t) v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  template<class Z> M pow(Z n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  template<class Z> friend M operator*(Z l, M r) { return M(l) *= r; }\n  template<class Z> friend M operator/(Z l, M r) { return M(l) /= r; }\n  template<class Z> friend M operator+(Z l, M r) { return M(l) += r; }\n  template<class Z> friend M operator-(Z l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  template<class Z> friend bool operator==(Z l, M r) { return M(l) == r; }\n  template<class Z> friend bool operator!=(Z l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<(unsigned) 1e9 + 7>;\n\nV<Mint> fact, ifact, inv, powB;\nvoid init(int n, int B = 2) {\n  fact.resize(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = i * fact[i - 1];\n  }\n  ifact.resize(n + 1);\n  ifact[n] = fact[n].inv();\n  for (int i = n; i > 0; --i) {\n    ifact[i - 1] = i * ifact[i];\n  }\n  inv.resize(n + 1);\n  inv[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    int q = Mint::p() / i;\n    inv[i] = -q * inv[Mint::p() - i * q];\n  }\n  powB.resize(n + 1);\n  powB[0] = 1;\n  for (int i = 0; i < n; ++i) {\n    powB[i + 1] = powB[i] * B;\n  }\n}\nMint comb(int n, int r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] * ifact[n - r];\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m, k; cin >> n >> m >> k;\n  init(n + m + k, Mint(3).inv().v);\n  Mint res, sum, c = Mint(3) / 2;\n  for (int j = 0; j <= k; ++j) {\n    sum += comb(n - 1 + j, j) * powB[j];\n  }\n  for (int i = 0; i <= m; ++i) {\n    res += comb(n - 1 + i, i) * powB[n + i] * sum;\n    sum = c * (sum - comb(n + i + k, k) * powB[k + 1]);\n  }\n  res /= powB[n + m + k];\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#pragma GCC optimize(\"Ofast,unroll-loops\")\n//#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace IntModulo\n{\n\tconst int mod = 1e9 + 7;\n\n\tinline int add(int x, int y, int m = mod)\n\t{\n\t\tif (x + y < m)\n\t\t\treturn x + y;\n\t\treturn x + y - m;\n\t}\n\n\tinline int sub(int x, int y, int m = mod)\n\t{\n\t\tif (x >= y)\n\t\t\treturn x - y;\n\t\treturn x - y + m;\n\t}\n\n\tinline int mult(int x, int y, int m = mod)\n\t{\n\t\treturn x * (LL) y % m;\n\t}\n\n\tinline int power(int x, int y, int m = mod)\n\t{\n\t\tint r = 1;\n\t\twhile(y)\n\t\t{\n\t\t\tif (y & 1)\n\t\t\t\tr = mult(r, x, m);\n\t\t\tx = mult(x, x, m);\n\t\t\ty >>= 1;\n\t\t}\n\t\t\n\t\treturn r;\n\t}\n\t\n\tinline int inverse(int x, int m = mod)\n\t{\n\t\treturn power(x, m - 2, m);\n\t}\n\t\n\tinline void ADD(int& x, int y, int m = mod)\n\t{\n\t\tx += y;\n\t\tif (x >= m) x -= m;\n\t}\n\t\n\tinline void SUB(int& x, int y, int m = mod)\n\t{\n\t\tx -= y;\n\t\tif (x < 0) x += m;\n\t}\n\t\n\tinline void MULT(int& x, int y, int m = mod)\n\t{\n\t\tx = (x * (LL) y) % m;\n\t}\n};\n\nnamespace Combinatorics\n{\n\tusing namespace IntModulo;\n\t\n\tconst int N = 1 << 19;\n\tint fact[N];\n\tint inv[N];\n\tint invFact[N];\n\tbool inited = false;\n\t\n\tinline int C(int n, int k) // binomial C(n, k)\n\t{\n\t\treturn n < k ? 0 : mult(fact[n], mult(invFact[k], invFact[n - k]));\n\t}\n\t\n\tinline int H(int n, int k) // number of solution x1 + .. + xn = k\n\t{\n\t\treturn C(n + k - 1, k);\n\t}\n\t\n\tvoid init()\n\t{\n\t\tdebug(Combinatorics::N);\n\t\tinited = true;\n\t\tinv[1] = 1;\n\t\tFOR(i, 2, N)\n\t\t\tinv[i] = mult(mod - mod / i, inv[mod % i]);\n\t\t\n\t\tinvFact[0] = fact[0] = 1;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tfact[i] = mult(i, fact[i - 1]);\n\t\t\tinvFact[i] = mult(invFact[i - 1], inv[i]);\n\t\t}\n\t}\t\n};\n\nusing namespace Combinatorics;\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tCombinatorics::init();\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tn--;\n\tint ans = 0;\n\tint last = -1;\n\t\n\tFOR(t, 0, m + k + 1)\t\t\n\t{\n\t\tint curr = (t ? mult(2 * t, last) : 1);\n\t\tif (t)\n\t\t{\n\t\t\tFOR(it, 0, 2)\n\t\t\t{\n\t\t\t\tSUB(curr, mult(mult(m + 1, fact[t - 1]), C(t, m + 1)));\n\t\t\t\tswap(m, k);\n\t\t\t}\n\t\t}\n\t\t\n\t\tADD(ans, mult(invFact[t], mult(curr, mult(C(n + t, t), power(3, m + k - t)))));\n\t\tlast = curr;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pii pair<int, int>\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1e6 + 10, mod = 1e9 + 7;\n\nint fact[N], inv[N];\n\nint comb(int n, int k)\n{\n\tif(k > n || k < 0) return 0;\n\tll res = fact[n];\n\tres *= inv[k], res %= mod;\n\tres *= inv[n - k], res %= mod;\n\treturn res;\n}\n\nll power(int a, int b)\n{\n\tif(b == 0) return 1;\n\tll res = power(a, b/2);\n\tres *= res, res %= mod;\n\tif(b & 1) res *= a, res %= mod;\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint A, B, C; cin >> A >> B >> C;\n\tint kol = A + B + C;\n\tll ans = 0;\n\n\tfact[0] = 1;\n\tfor (int i=1; i<N; i++)\n\t\tfact[i] = 1LL * fact[i - 1] * i % mod;\n\n\tinv[N - 1] = power(fact[N - 1], mod - 2);\n\tfor (int i=N-2; i>=0; i--)\n\t\tinv[i] = 1LL * inv[i + 1] * (i + 1) % mod;\n\n\tfor (int m=0; m<=B+C; m++)\n\t{\n\t\tint S = A + m;\n\t\tll curr = 0;\n\t\t//#1 : aa\n\t\tll ways = comb(S - 2, A - 2);\n\t\tfor (int b=1; b<=min(B, m); b++)\n\t\t{\n\t\t\tint c = m - b;\n\t\t\tif(c > C || c <= 0) continue ;\n\t\t\tcurr += ways * comb(m, b) % mod, curr %= mod;\n\t\t}\n\n\t\t//#2 : ab\n\t\tways = comb(S - 2, A - 1);\n\t\tfor (int b=1; b<=min(B, m); b++)\n\t\t{\n\t\t\tint c = m - b;\n\t\t\tif(c > C || c <= 0) continue ;\n\t\t\tcurr += ways * comb(m - 1, b - 1) % mod, curr %= mod;\n\t\t}\n\n\t\t//#3 : ca\n\t\tways = comb(S - 2, A - 1);\n\t\tfor (int c=1; c<=min(C, m); c++)\n\t\t{\n\t\t\tint b = m - c;\n\t\t\tif(b > B || b <= 0) continue ;\n\t\t\tcurr += ways * comb(m - 1, c - 1) % mod, curr %= mod;\n\t\t}\n\n\t\t//#4 : a\n\t\tif(m && m <= B)\n\t\t{\n\t\t\tways = comb(S - 1, A - 1);\n\t\t\tcurr += ways, curr %= mod;\n\t\t}\n\n\t\tif(m && m <= C)\n\t\t{\n\t\t\tways = comb(S - 1, A - 1);\n\t\t\tcurr += ways, curr %= mod;\n\t\t}\n\n\t\tif(m == 0) curr += 1, curr %= mod;\n\t\t\n\t\t//cout << m << \" --> \" << curr << endl;\n\n\t\tcurr = curr * power(3, kol - S); curr %= mod;\n\t\tans += curr, ans %= mod;\n\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <gmp.h>\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\n\ntemplate<int MOD>\nstruct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tModInt(unsigned unsig) { x = unsig % MOD; }\n\tModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\tModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n\tModInt inverse() const {\n\t\tsigned a = x, b = MOD, u = 1, v = 0;\n\t\twhile(b) {\n\t\t\tsigned t = a / b;\n\t\t\ta -= t * b; std::swap(a, b);\n\t\t\tu -= t * v; std::swap(u, v);\n\t\t}\n\t\tif(u < 0) u += Mod;\n\t\tModInt res; res.x = (unsigned)u;\n\t\treturn res;\n\t}\n};\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n\tModInt<MOD> r = 1;\n\twhile(k) {\n\t\tif(k & 1) r *= a;\n\t\ta *= a;\n\t\tk >>= 1;\n\t}\n\treturn r;\n}\ntypedef ModInt<1000000007> mint;\n\n#if defined(_WIN32)\nextern \"C\" {\n\tvoid* __stdcall LoadLibraryA(const char *name);\n\tvoid* __stdcall GetProcAddress(void *handle, const char *name);\n}\nstruct DynamicLibrary {\n\tDynamicLibrary(const char *name) { _handle = LoadLibraryA(name); }\n\tvoid *get(const char *name) const { void *p = GetProcAddress(_handle, name); if(!p) std::cerr << \"can't find: \" << name << std::endl, std::abort(); return p; }\n\tvoid *_handle;\n} gmp(\"mpir.dll\");\n#else\nextern \"C\" {\n\tvoid* __libc_dlopen_mode(const char *x, int y);\n\tvoid* __libc_dlsym(void *x, const char *y);\n}\nstruct DynamicLibrary {\n\tDynamicLibrary(const char *name) { _handle = __libc_dlopen_mode(name, 2); }\n\tvoid *get(const char *name) const { void *p = __libc_dlsym(_handle, name); if(!p) std::cerr << \"can't find: \" << name << std::endl, std::abort(); return p; }\n\tvoid *_handle;\n} gmp(\"/usr/lib/i386-linux-gnu/libgmp.so.10\");\n#endif\n\n#define EXPAND_MACRO_TO_STR_2(a) #a\n#define EXPAND_MACRO_TO_STR(a) EXPAND_MACRO_TO_STR_2(a)\n#define DECL_GMP(name) const auto my_##name = (decltype(::name)*)gmp.get(EXPAND_MACRO_TO_STR(name))\nDECL_GMP(mpn_mul);\nDECL_GMP(mpn_sqr);\n\n\ninline int getBitSize(unsigned x) {\n#ifndef __GNUC__\n\tunsigned long res;\n\t_BitScanReverse(&res, x);\n\treturn static_cast<int>(res) + 1;\n#else\n\treturn 32 - __builtin_clz(x);\n#endif\n}\n\nenum { WordBits = sizeof(mp_limb_t) * 8 };\ntypedef unsigned Num;\nenum { NumBits = sizeof(Num) * 8 };\n\ntypedef int Size;\ntypedef const mint *SrcPoly;\ntypedef mint *DstPoly, SrcDstPoly;\ntypedef const mp_limb_t *SrcPtr;\ntypedef mp_limb_t *DstPtr, *SrcDstPtr;\n\nvoid zeroPolynomial(DstPoly resp, Size resn) {\n\tfor(Size i = 0; i < resn; ++ i)\n\t\tresp[i] = mint();\n}\n\nvoid addPolynomial(DstPoly resp, SrcPoly xp, SrcPoly yp, Size xyn) {\n\tfor(Size i = 0; i < xyn; ++ i)\n\t\tresp[i] = xp[i] + yp[i];\n}\nvoid subtractPolynomial(DstPoly resp, SrcPoly xp, SrcPoly yp, Size xyn) {\n\tfor(Size i = 0; i < xyn; ++ i)\n\t\tresp[i] = xp[i] - yp[i];\n}\n\nvoid multiplyConstantPolynomial(DstPoly resp, SrcPoly xp, Size xn, mint y) {\n\tfor(Size i = 0; i < xn; ++ i)\n\t\tresp[i] = xp[i] * y;\n}\n\nvoid packToBits(DstPtr resp, int resn, SrcPoly xp, Size xn, int width, int stride) {\n\tif(width > WordBits) {\n\t\tstd::cerr << \"unimplemented\" << std::endl;\n\t\tstd::abort();\n\t}\n\tfor(Size i = 0; i < resn; ++ i)\n\t\tresp[i] = 0;\n\tSize pos = 0;\n\tint sa = stride / WordBits, sb = stride % WordBits;\n\tint offset = 0;\n\tfor(Size i = 0; i < xn; ++ i) {\n\t\tassert(pos < resn);\n\t\tmp_limb_t x = static_cast<mp_limb_t>(xp[i].get());\n\t\tint right = offset + width;\n\t\tresp[pos] |= x << offset;\n\t\tif(right > WordBits) {\n\t\t\tassert(pos + 1 < resn);\n\t\t\tresp[pos + 1] |= x >> (WordBits - offset);\n\t\t}\n\t\tpos += sa;\n\t\tif((offset += sb) >= WordBits)\n\t\t\toffset -= WordBits, ++ pos;\n\t}\n}\n\nvoid unpackFromBitsMod(DstPoly resp, Size resn, SrcPtr xp, Size xn, int stride) {\n\tassert(stride > 0);\n\tint K = (stride - 1) / NumBits + 1, rems = stride - (K - 1) * NumBits;\n\tNum remmask = ((Num)2 << (rems - 1)) - 1;\n\tconst mint Base = mint(~0U) + 1;\n\tstd::unique_ptr<Num[]> buf(new Num[K]);\n\tNum *nums = buf.get();\n\tSize pos = 0, offset = 0;\n\tfor(Size i = 0; i < resn; ++ i) {\n\t\tfor(int k = 0; k < K; ++ k) {\n\t\t\tint smallwidth = k < K - 1 ? NumBits : rems;\n\t\t\tif(pos >= xn) {\n\t\t\t\tnums[k] = 0;\n\t\t\t\toffset += smallwidth;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tNum num = static_cast<Num>(xp[pos] >> offset);\n\t\t\toffset += smallwidth;\n\t\t\tif(pos + 1 < xn && offset > WordBits)\n\t\t\t\tnum |= static_cast<Num>(xp[pos + 1] << (WordBits - (offset - smallwidth)));\n\t\t\tnums[k] = num;\n\t\t\tif(offset >= WordBits)\n\t\t\t\toffset -= WordBits, ++ pos;\n\t\t}\n\t\tnums[K - 1] &= remmask;\n\t\tmint cur = mint(nums[K - 1]);\n\t\tfor(int k = K - 2; k >= 0; -- k) {\n\t\t\tcur *= Base;\n\t\t\tcur += nums[k];\n\t\t}\n\t\tresp[i] = cur;\n\t}\n}\n\nvoid multiplyPolynomial(DstPoly resp, Size resn, SrcPoly xp, Size xn, SrcPoly yp, Size yn) {\n\tif(xn > resn) xn = resn;\n\tif(yn > resn) yn = resn;\n\tif(resn > xn + yn - 1) {\n\t\tzeroPolynomial(resp + (xn + yn - 1), resn - (xn + yn - 1));\n\t\tresn = xn + yn - 1;\n\t}\n\tif(xn < yn) std::swap(xp, yp), std::swap(xn, yn);\n\tif(yn == 0) {\n\t\tzeroPolynomial(resp, resn);\n\t\treturn;\n\t}\n\tif(yn == 1) {\n\t\tmultiplyConstantPolynomial(resp, xp, xn, yp[0]);\n\t\tzeroPolynomial(resp + xn, resn - xn);\n\t\treturn;\n\t}\n\tint width = getBitSize(mint::Mod - 1);\n\tint stride = width * 2 + getBitSize(yn - 1);\n\tif(xp == yp && xn == yn) {\n\t\tSize tmpxn = static_cast<Size>(((long long)xn * stride - 1) / WordBits + 1);\n\t\tSize tmpzn = tmpxn + tmpxn;\n\t\tstd::unique_ptr<mp_limb_t[]> tmpbuf(new mp_limb_t[tmpxn + tmpzn]);\n\t\tmp_limb_t *tmpx = tmpbuf.get(), *tmpz = tmpx + tmpxn;\n\t\tpackToBits(tmpx, tmpxn, xp, xn, width, stride);\n\t\tmy_mpn_sqr(tmpz, tmpx, tmpxn);\n\t\tunpackFromBitsMod(resp, resn, tmpz, tmpzn, stride);\n\t} else {\n\t\tSize tmpxn = static_cast<Size>(((long long)xn * stride - 1) / WordBits + 1);\n\t\tSize tmpyn = static_cast<Size>(((long long)yn * stride - 1) / WordBits + 1);\n\t\tSize tmpzn = tmpxn + tmpyn;\n\t\tstd::unique_ptr<mp_limb_t[]> tmpbuf(new mp_limb_t[tmpxn + tmpyn + tmpzn]);\n\t\tmp_limb_t *tmpx = tmpbuf.get(), *tmpy = tmpx + tmpxn, *tmpz = tmpy + tmpyn;\n\t\tpackToBits(tmpx, tmpxn, xp, xn, width, stride);\n\t\tpackToBits(tmpy, tmpyn, yp, yn, width, stride);\n\t\tmy_mpn_mul(tmpz, tmpx, tmpxn, tmpy, tmpyn);\n\t\tunpackFromBitsMod(resp, resn, tmpz, tmpzn, stride);\n\t}\n}\n\n\n\nvector<mint> fact, factinv;\nvoid nCr_computeFactinv(int N) {\n\tN = min(N, mint::Mod - 1);\n\tfact.resize(N + 1); factinv.resize(N + 1);\n\tfact[0] = 1;\n\trer(i, 1, N) fact[i] = fact[i - 1] * i;\n\tfactinv[N] = fact[N].inverse();\n\tfor(int i = N; i >= 1; i --) factinv[i - 1] = factinv[i] * i;\n}\nmint nCr(int n, int r) {\n\tif(n >= mint::Mod)\n\t\treturn nCr(n % mint::Mod, r % mint::Mod) * nCr(n / mint::Mod, r / mint::Mod);\n\treturn r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];\n}\n\nint main() {\n\tint N; int M; int K;\n\twhile(~scanf(\"%d%d%d\", &N, &M, &K)) {\n\t\tnCr_computeFactinv(N + M + K);\n\t\tvector<mint> p(M + 1), q(K + 1);\n\t\trep(i, M + 1) p[i] = factinv[i];\n\t\trep(i, K + 1) q[i] = factinv[i];\n\t\tvector<mint> pq(M + K + 1);\n\t\tmultiplyPolynomial(pq.data(), pq.size(), p.data(), p.size(), q.data(), q.size());\n\t\tmint ans;\n\t\trer(mk, 0, M + K) {\n\t\t\tmint sum = pq[mk];\n\t\t\tsum *= fact[N - 1 + mk];\n\t\t\tsum *= factinv[N - 1];\n\t\t\tans = ans * 3 + sum;\n\t\t}\n\t\tprintf(\"%d\\n\", ans.get());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//initfact();\n//const uint mod=998244353;\nconst uint mod=1000000007;\n//uint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m,k;cin>>n>>m>>k;\n\t\n\tvc<mint> p3(m+k+1);\n\tp3[0]=1;\n\trep(i,m+k)\n\t\tp3[i+1]=p3[i]*3;\n\tmint ans;\n\tmint cur=1;\n\trep(i,m+k+1){\n\t\tans+=cur*binom(i,n-1)*p3[m+k-i];\n\t\tif(i<m+k){\n\t\t\tcur*=2;\n\t\t\tif(i>=m)cur-=choose(i,m);\n\t\t\tif(i>=k)cur-=choose(i,k);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define MAXN 1000005\n#define INF (1<<25)\n#define P int(1e9+7)\nusing namespace std;\n\nint N,K,M;\nint NN = 1e6;\n\nLL fac[MAXN], ifac[MAXN];\n\nLL qpow(LL x, int n){\n\tLL res = 1;\n\twhile(n){\n\t\tif(n & 1) res = res * x % P;\n\t\tx = x * x % P;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\nLL comb(int n, int k){\n\treturn fac[n]*ifac[n-k]%P*ifac[k]%P;\n}\n\nvoid init(){\n\tfac[0] = ifac[0] = 1;\n\tfor(int i=1;i<=NN;i++){\n\t\tfac[i] = fac[i-1] * i % P;\n\t\tifac[i] = qpow(fac[i], P-2);\n\t}\n}\n\nint main(){\n\t\n\tcin>>N>>M>>K;\n\tif(M > K) swap(M,K);\n\t\n\tinit();\n\t// M < K\n\t\n\tLL ans = 0;\n\tLL n = 1;\n\tfor(int i=0;i<=M+K;i++){\n\t\tif(i==0) n = 1;\n\t\telse if(i<=M) n = n*2%P;\n\t\telse if(i<=K) n = (n*2%P - comb(i-1,M) + P)%P;\n\t\telse n = (n*2%P - comb(i-1,i-1-K) - comb(i-1,M) + 2*P)%P;\n\t\tans = (ans + comb(N-1+i,N-1)*qpow(3,M+K-i)%P * n % P) % P;\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, l, r) for(int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for(int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\nusing namespace std;\n\nbool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}\nbool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n    int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int Mod = 1e9 + 7, N = 1e6 + 1e3;\n\ntypedef long long ll;\n\nll fac[N], ifac[N], pow3[N];\n\nll fpm(ll x, int power) {\n\tll res = 1;\n\tfor (; power; power >>= 1, (x *= x) %= Mod)\n\t\tif (power & 1) (res *= x) %= Mod;\n\treturn res;\n}\n\nll C(int m, int n) {\n\tif (m > n || n < 0 || m < 0) return 0;\n\t//cout << fac[n] << ' ' << ifac[m] << ' ' << ifac[n - m] << endl;\n\treturn fac[n] * ifac[m] % Mod * ifac[n - m] % Mod;\n}\n\nint n, m, k, tot;\n\nvoid Init(int maxn) {\n\tfac[0] = pow3[0] = 1; \n\tFor (i, 1, maxn) fac[i] = fac[i - 1] * i % Mod, pow3[i] = pow3[i - 1] * 3 % Mod;\n\tifac[maxn] = fpm(fac[maxn], Mod - 2);\n\tFordown (i, maxn - 1, 0) ifac[i] = ifac[i + 1] * (i + 1) % Mod;\n}\n\ninline ll Calc(int m, int S) {\n\tll res = 0;\n\tFor (i, 0, min(m, S))\n\t\tif (S - i <= k) (res += C(i, S)) %= Mod;\n\treturn res;\n}\n\nll res[N];\n\nint main () {\n\tFile();\n\tcin >> n >> m >> k; tot = n + m + k;\n\tInit(tot + 5);\n\n\n\tll ans = 0, now = 1;\n\tFor (S, 0, m + k) {\n\t\t(ans += pow3[tot - (n + S)] * C(n - 1, (n - 1) + S) % Mod * Calc(m, S) % Mod) %= Mod;\n\t\tnow = (now << 1) % Mod;\n\n\t\tif (S >= m) (now += Mod - C(m, S)) %= Mod;\n\t\tif (S >= k) (now += Mod - C(k, S)) %= Mod;\n\t}\n\n\tprintf (\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef ONLINE_JUDGE\n#define freopen \\\n  if (0) freopen\n#define cerr \\\n  if (0) cerr\n#endif\n\n#define fi first\n#define se second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n\n#define sqr(a) ((a)*1ll * (a))\n#define sz(a) (int)a.size()\n#define len(a) (int)a.length()\n#define all(a) a.begin(), a.end()\n#define nl '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nint n, m, k;\nint cnt[3];\nll res;\n\nvoid dfs(int cur) {\n  if (cnt[cur] == 0) {\n    if (cur == 0) {\n      ll mul = 1;\n      rep(i, 0, 2) {\n        rep(j, 1, cnt[i]) {\n          mul *= 3ll;\n          mul %= mod;\n        }\n      }\n      res += mul;\n      res %= mod;\n    }\n    return;\n  }\n\n  rep(i, 0, 2) {\n    cnt[cur]--;\n    dfs(i);\n    cnt[cur]++;\n  }\n}\n\n\nvoid solve() {\n  cin >> n >> m >> k;\n  cnt[0] = n;\n  cnt[1] = m;\n  cnt[2] = k;\n  dfs(0);\n  cout << res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  freopen(\".in\", \"r\", stdin);\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n#include <iostream>\nusing namespace std;\nint A, B, C, dp[1009][1009], pw[900009], fact[900009], inv[900009], finv[900009], mod = 1000000007;\nint comb(int x, int y) {\n\treturn y < 0 || x < y ? 0 : 1LL * fact[x] * finv[y] % mod * finv[x - y] % mod;\n}\nint main() {\n\tcin >> A >> B >> C;\n\tassert(A <= 1000 && B <= 1000 && C <= 1000);\n\tpw[0] = fact[0] = inv[1] = finv[0] = 1;\n\tfor (int i = 1; i <= A + B + C; i++) {\n\t\tif (i >= 2) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\t\tpw[i] = 3LL * pw[i - 1] % mod;\n\t\tfact[i] = 1LL * fact[i - 1] * i % mod;\n\t\tfinv[i] = 1LL * finv[i - 1] * inv[i] % mod;\n\t}\n\tdp[0][0] = 1;\n\tint ret = 0;\n\tfor (int i = 0; i <= B; i++) {\n\t\tfor (int j = 0; j <= C; j++) {\n\t\t\tif (i >= 1) dp[i][j] += dp[i - 1][j];\n\t\t\tif (j >= 1) dp[i][j] += dp[i][j - 1];\n\t\t\tif (dp[i][j] >= mod) dp[i][j] -= mod;\n\t\t\tret = (ret + 1LL * pw[B + C - i - j] * dp[i][j] % mod * comb(A + i + j - 1, A - 1)) % mod;\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint A, B, C;\nllint beki2[900005], beki3[900005];\nllint dp[900005];\n\nllint fact[900005], fact_inv[900005];\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 900005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 900005; i++){\n\t\tfact_inv[i] = pow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> A >> B >> C;\n\tif(B > C) swap(B, C);\n\t\n\tmake_fact();\n\t\n\tllint mul = 1;\n\tfor(int i = 0; i < 900005; i++){\n\t\tbeki2[i] = mul;\n\t\tmul *= 2, mul %= mod;\n\t}\n\tmul = 1;\n\tfor(int i = 0; i < 900005; i++){\n\t\tbeki3[i] = mul;\n\t\tmul *= 3, mul %= mod;\n\t}\n\t\n\tfor(int i = 0; i <= B; i++) dp[i] = beki2[i];\n\tfor(int i = B; i < C; i++){\n\t\tdp[i+1] = (2 * dp[i] + mod - comb(i, B)) % mod;\n\t\tdp[i+1] %= mod;\n\t}\n\tfor(int i = C; i < B+C; i++){\n\t\tdp[i+1] = (2 * dp[i] + 2 * mod - (comb(i, i-C) + comb(i, B))) % mod;\n\t\tdp[i+1] %= mod;\n\t}\n\t\n\tllint ans = 0, tmp;\n\tfor(int i = 0; i <= B+C; i++){\n\t\ttmp = comb(A+i-1, i) * dp[i] % mod * beki3[B+C-i] % mod;\n\t\tans += tmp, ans %= mod;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<stack>\n#include<climits>\n#include<queue>\n#include<map>\n#include<set>\n#include<sstream>\nusing namespace std;\ntypedef long long ll;   \ntypedef unsigned long long ull;\nconst int c=1e9 +7;\nconst int N=900010;\ninline long long read()//inline 加速读入\n{\n\tlong long x=0;char c=getchar();//x代表返回值，c代表读取的字符\n\twhile (c<'0'||c>'9') c=getchar();//读取所有非数部分\n\twhile (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();//如果读取的字符为数，加入返回值\n\treturn x;\n}\n inline void write(ll x)\n {\n     char F[200];\n      int tmp=x>0?x:-x ;\n    if(x<0)putchar('-') ;\n    int cnt=0 ;\n       while(tmp>0)\n       {\n            F[cnt++]=tmp%10+'0';\n            tmp/=10;\n       }\n       while(cnt>0)putchar(F[--cnt]) ;\n }\nint gcd(int x, int y)\n {\n     int MAX = max(x, y);\n     int MIN = min(x, y);\n     return MAX % MIN == 0? MIN : gcd(MIN, MAX % MIN);\n }\n // 快速幂求逆元\nlong long power_mod(long long a, long long b) {\n    long long ans = 1;\n    a %= c;\n    while (b) {\n        if (b & 1) {\n            ans = ans * a % c;\n        }\n        b >>= 1;\n        a = a * a % c;\n    }\n    return ans;\n}\n\nint n,m,k;\nll fac[N],ifac[N],p[N]; \nll inv(ll x) {\n    return power_mod(x,c-2);\n}\n\nll C( ll x , ll y ) {\n    return (fac[x]*ifac[y]%c*ifac[x-y]%c)%c;\n}\n\nint main() {\n    cin>>n>>m>>k;\n    fac[0]=1ll;\n    p[0]=1ll;\n    for(int i=1;i<N;i++){\n        fac[i]=fac[i-1]*i%c;\n        p[i]=p[i-1]*3ll%c;\n    }\n    for(int i=0;i<N;i++){\n        ifac[i]=inv(fac[i]) ;\n    }\n    ll ans=0,x=1ll;\n    n--;\n    if(m<k)swap(m,k) ;\n    for(int i=0;i<=m+k;i++){\n        ans=(ans+C(n+i,n)*p[m+k-i]%c*x)%c;\n        if(i<k)x=(x*2ll)%c;\n        else if(i<m)x=(x*2ll-C(i,k))%c;\n        else  x=(x*2ll-C(i,k)-C(i,m))%c;\n    }\n    printf(\"%lld\\n\",(ans+c)%c) ;\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, l, r) for(int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for(int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\nusing namespace std;\n\nbool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}\nbool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n    int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int Mod = 1e9 + 7, N = 1e6 + 1e2;\n\ntypedef long long ll;\nstruct Card { \n\tint a, b, c; \n\tbool operator < (const Card &rhs) const {\n\t\treturn (a ^ rhs.a) ? a < rhs.a : (b ^ rhs.b) ? b < rhs.b : c < rhs.c;\n\t}\n};\nstruct Sta { Card pk; int val; };\n\nmap<Card, int> M;\nvector<Sta> dp[2];\n\nint pow3[N];\nint n, m, k, cur;\n\nint ans = 0;\n\nvoid Update(Card Go, int uv, int dep) {\n\tif (Go.a < 0) {\n\t\tint Last = n + m + k - dep;\n\t\t(ans += 1ll * uv * pow3[Last] % Mod) %= Mod;\n\t\treturn ;\n\t}\n\tif (Go.b < 0 || Go.c < 0) return ;\n\n\tint pos = M[Go];\n\tif (pos) { (dp[cur ^ 1][pos - 1].val += uv) %= Mod; return ; }\n\n\n\tdp[cur ^ 1].push_back((Sta) {Go, uv});\n\tM[Go] = (int)dp[cur ^ 1].size();\n}\n\nint main () {\n\tFile();\n\tcin >> n >> m >> k;\n\tpow3[0] = 1; For (i, 1, n + m + k) pow3[i] = pow3[i - 1] * 3ll % Mod;\n\n\tdp[cur = 0].push_back((Sta) {(Card) {n - 1, m, k}, 1});\n\n\tFor (i, 1, n + m + k) {\n\t\tfor (Sta now : dp[cur]) {\n\t\t\tCard here = now.pk;\n\n\t\t\t-- here.a, Update(here, now.val, i), ++ here.a;\n\n\t\t\t-- here.b, Update(here, now.val, i), ++ here.b;\n\n\t\t\t-- here.c, Update(here, now.val, i), ++ here.c;\n\t\t}\n\t\tdp[cur].clear(); cur ^= 1; M.clear();\n\t}\n\n\tprintf (\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=900000+10;\n\nconst int mod=1e9+7;\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint fac[N],ifac[N],pw[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n    for (re int i=pw[0]=1;i<=n;++i) pw[i]=3ll*pw[i-1]%mod;\n}\n\ninline int C(int n,int m) {\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main() { init(900000);\n    int n=read(),m=read(),k=read(); if (m<k) swap(m,k);\n    int ans=0,lst=1;\n    for (re int i=0;i<=m+k;++i) {\n        ans=(ans+1ll*C(n+i-1,n-1)*pw[m+k-i]%mod*lst)%mod;\n        if (i<k) lst=2ll*lst%mod;\n        else if (i<m) lst=(2ll*lst+mod-C(i,k))%mod;\n        else lst=(2ll*lst+mod-C(i,k)+mod-C(i,i-m))%mod;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n//qwq"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 9e5 + 9, mod = 1e9 + 7;\n\ntemplate <const int32_t MOD>\nstruct modint {\n    int32_t value;\n    modint() = default;\n    modint(int32_t value_) : value(value_) {}\n    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.value; return modint<MOD>(c >= MOD ? c - MOD : c); }\n    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.value; return modint<MOD>(c <    0 ? c + MOD : c); }\n    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * other.value % MOD; return modint<MOD>(c < 0 ? c + MOD : c); }\n    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * other.value % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : 0); }\n    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k & 1) y *= x; x *= x; } return y; }\n    modint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n    inline modint<MOD> operator /  (modint<MOD> other) const { return *this *  other.inv(); }\n    inline modint<MOD> operator /= (modint<MOD> other)       { return *this *= other.inv(); }\n    inline bool operator == (modint<MOD> other) const { return value == other.value; }\n    inline bool operator != (modint<MOD> other) const { return value != other.value; }\n    inline bool operator < (modint<MOD> other) const { return value < other.value; }\n    inline bool operator > (modint<MOD> other) const { return value > other.value; }\n};\ntemplate <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD>(value) * n; }\ntemplate <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD>(value % MOD) * n; }\ntemplate <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.value; }\ntemplate <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.value; }\n\nusing mint = modint<mod>;\n\nstruct Combi{\n\tint n; vector<mint> facts, finvs, invs;\n\tCombi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){\n\t\tfacts[0] = finvs[0] = 1;\n\t\tinvs[1] = 1;\n\t    for (int i = 2; i < n; i++) invs[i] =  invs[mod % i] * (-mod / i);\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfacts[i] = facts[i - 1] * i;\n\t\t\tfinvs[i] = finvs[i - 1] * invs[i];\n\t\t}\n\t}\n\tinline mint fact(int n) { return facts[n]; }\n\tinline mint finv(int n) { return finvs[n]; }\n\tinline mint inv(int n) { return invs[n]; }\n\tinline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }\n};\nCombi C(N);\n\nint32_t main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n, m, k; cin >> n >> m >> k;\n\tmint ans = 0;\n\tmint r = mint(1) / 2, l = 0;\n\tfor (int s = 0; s <= m + k; s++) {\n\t\tr *= 2;\n\t\tif (s > m) r -= C.ncr(s - 1, m);\n\t\tif (s == k + 1) l = 1;\n\t\tif (s > k + 1) {\n\t\t\tl *= 2;\n\t\t\tl -= C.ncr(s - 1, s - k - 2);\n\t\t\tl += C.ncr(s, s - k - 1);\n\t\t}\n\t\tif (max(0, s - k) <= min(s, m)) ans += (r - l) * C.ncr(n + s - 1, n - 1) * mint(3).pow(m + k - s);\n\t}\n\tcout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct Combination {\n  int mod;\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod) {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nconst int mod = 1e9 + 7;\n\n\nint main() {\n  int N, M, K;\n  cin >> N >> M >> K;\n  if(N > 1000 || M > 1000 || K > 1000) throw 0;\n\n\n  Combination beet(1010101, mod);\n  int64 pow3[1010101];\n  pow3[0] = 1;\n  for(int i = 1; i < 1010101; i++) pow3[i] = pow3[i - 1] * 3 % mod;\n\n  // えーなんか a が N 回でる組み合わせみたいな感じにならないですか\n\n  int64 ret = 0;\n  for(int i = N; i <= N + M + K; i++) {\n    // i 回目に a が出る\n    // i-1回目までに a が N-1回出る\n    int64 add = 0;\n\n    int bc_rest = (i - 1) - (N - 1);\n    for(int j = 0; j <= min(bc_rest, M); j++) {\n      int c_rest = bc_rest - j;\n      if(c_rest > K) continue;\n      add += beet.C(bc_rest, j);\n      add %= mod;\n    }\n\n    add *= beet.C(i - 1, N - 1);\n    add %= mod;\n\n    add *= pow3[N + M + K - i];\n    add %= mod;\n\n\n    ret += add;\n    ret %= mod;\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int maxn(1e6 + 10), Mod(1e9 + 7);\nint N, M, K, ans, fac[maxn], inv[maxn], Pow[maxn];\nint C(int n, int m) { return 1ll * fac[n] * inv[m] % Mod * inv[n - m] % Mod; }\nint Minus(int x, int y) { return (x - y + Mod) % Mod; }\nint fastpow(int x, int y)\n{\n\tint ans = 1;\n\tfor (; y; y >>= 1, x = 1ll * x * x % Mod)\n\t\tif (y & 1) ans = 1ll * ans * x % Mod;\n\treturn ans;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfile(cpp);\n#endif\n\tscanf(\"%d%d%d\", &N, &M, &K), fac[0] = inv[0] = Pow[0] = 1;\n\tfor (int i = 1; i <= N + M + K; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tfor (int i = 1; i <= N + M + K; i++) Pow[i] = 1ll * Pow[i - 1] * 3 % Mod;\n\tinv[N + M + K] = fastpow(fac[N + M + K], Mod - 2);\n\tfor (int i = N + M + K - 1; i; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % Mod;\n\tfor (int i = 0, x = 1; i <= M + K; i++)\n\t{\n\t\tans = (ans + 1ll * C(N + i - 1, N - 1) * Pow[M + K - i] % Mod * x) % Mod;\n\t\tif (i < K) x = (x + x) % Mod; else if (i < M) x = Minus((x + x) % Mod, C(i, K));\n\t\telse x = Minus(Minus((x + x) % Mod, C(i, K)), C(i, M));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define Everyone Input();\n#define Has solve();\n#define A print();\n#define Dream return 0;\nusing namespace std;\nconst int maxn=9e5+20,mod=1e9+7;\nll N,M,K,Pow[maxn],fac[maxn],inv[maxn],ans=0;\ninline long long read()\n{\n    long long s=0,f=1; char ch;for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=-1;\n    for(;ch>='0'&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+ch-'0';return s*f;\n}\nvoid Prepare(int Max)\n{\n    fac[0]=inv[0]=Pow[0]=inv[1]=1LL;\n    for(int i=2;i<=Max;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=1;i<=Max;++i)\n    {\n        fac[i]=(ll)fac[i-1]*i%mod;\n        inv[i]=(inv[i]*inv[i-1])%mod;\n        Pow[i]=(ll)Pow[i-1]*3%mod;\n    }\n}\nll C(int n,int m){return (fac[n]*inv[m])%mod*inv[n-m]%mod;}\nvoid Input()\n{\n    N=read(),M=read(),K=read();\n    Prepare(N+M+K);\n}\nvoid solve()\n{\n    if(M<K) swap(M,K); ll res=1LL;\n    for(int i=0;i<=M+K;++i)\n    {\n        ans=(ans+(C(N-1+i,N-1)*Pow[M+K-i]%mod)*res%mod)%mod;\n        if(i<K) res<<=1,res%=mod;\n        else if(i>=M) res=(res+res-C(i,K)-C(i,i-M))%mod;\n        else res=(res-C(i,K)+res)%mod;\n    }\n}\nvoid print(){printf(\"%lld\\n\",(ans+mod)%mod);}\nint main(){ Everyone Has A Dream }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 600005;\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - (ll)inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = (ll)fac[i-1] * i % MOD;\n\t\tfinv[i] = (ll)finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nint comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * ((ll)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\ninline int add(int x,int y)\n{\n    return (x+y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\ninline int mod_pow(int a, int b)\n{\n    int res = 1;\n    while(b){\n        if(b & 1){\n            res = (ll)res * a % MOD;\n        }\n        a = (ll)a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    if(K > m) swap(m, K);\n    make();\n    int tm = 0;\n    int cri = 1;\n    int inv3 = mod_pow(3, MOD-2);\n    int cri2 = mod_pow(inv3, n+1);\n    srep(i, n+1, n+K+1){\n        tm = add(tm, mul(comb(i-2, n-1), mul(cri, cri2)));\n        cri = mul(cri, 2);\n        cri2 = mul(cri2, inv3);\n    }\n    cri = mod_pow(2, K);\n    srep(i, n+K+1, n+m+2){\n        tm = add(tm, mul(comb(i-2, n-1), mul(cri, cri2)));\n        cri = sub(mul(cri, 2), comb(i-n-1, i-n-K-1));\n        cri2 = mul(cri2, inv3);\n    }\n    cri = 0;\n    srep(i, m-K+1, m+1){\n        cri = add(cri, comb(m+1, i));\n    }\n    srep(i, n+m+2, n+m+K+2){\n        tm = add(tm, mul(comb(i-2, n-1), mul(cri, cri2)));\n        cri = sub(mul(cri, 2), add(comb(i-n-1, i-n-K-1), comb(i-n-1, m)));\n        cri2 = mul(cri2, inv3);\n    }\n    cout << mul(tm, mod_pow(3, n+m+K+1)) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <limits>\n#include <memory>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) static_cast<int>((a).size())\n#define fillchar(a, x) memset(a, x, sizeof(a))\n#define rep(i, a, b) for(int i=int(a); i<=int(b); ++i)\n#define irep(i, a, b) for(int i=int(a); i>=int(b); --i)\n#define replr(i, a, b) rep(i, a, (b)-1)\n#define reprl(i, a, b) irep(i, (b)-1, a)\n#define repn(i, n) rep(i, 0, (n)-1)\n#define irepn(i, n) irep(i, (n)-1, 0)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\ntypedef long long LL;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\ntypedef pair<double,double> PDD;\ntypedef vector<LL> VL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPI;\ntypedef vector<string> VS;\ntemplate<class T, class S> ostream& operator<<(ostream& os, const pair<T, S>& v) { return os<<\"(\"<<v.first<<\", \"<<v.second<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& v) { os<<\"[\"; repn(i, sz(v)) { if(i) os<<\", \"; os<<v[i]; } return os<<\"]\"; }\ntemplate<class T> bool setmax(T &_a, T _b) { if(_b>_a) { _a=_b; return true; } return false; }\ntemplate<class T> bool setmin(T &_a, T _b) { if(_b<_a) { _a=_b; return true; } return false; }\ntemplate<class T> T gcd(T _a, T _b) { return _b==0?_a:gcd(_b,_a%_b); }\n\nconst LL MOD=LL(1e9)+7;\n\nLL binom[3010][3010];\nLL m3[3010];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\n    rep(i, 0, 3000) binom[i][0]=binom[i][i]=1;\n    rep(i, 1, 3000) rep(j, 1, i-1) binom[i][j]=(binom[i-1][j-1]+binom[i-1][j])%MOD;\n    m3[0]=1;\n    rep(i, 1, 3000) m3[i]=m3[i-1]*3%MOD;\n\n    int N, M, K; cin>>N>>M>>K; --N;\n    LL ans=0;\n    rep(i, 0, M) rep(j, 0, K) {\n        (ans+=m3[i+j]*binom[N+M+K-i-j][N]%MOD*binom[M+K-i-j][M-i])%=MOD;\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define MOD 1000000007\n\nint N, M, K;\nlong long dp[4000][1001];\n\nlong long pow(long long x, long long k) {\n  long long a = 1;\n  while (k) {\n    if (k & 1) a = (a*x) % MOD;\n    x = (x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\nlong long inv(long long x) {\n  return pow(x, MOD-2);\n}\nlong long C(long long n, long long r) {\n  long long s = 1;\n  for (int i=1; i<=r; i++) {\n    s = (s*(n+1-i)) % MOD;\n    s = (s*inv(i)) % MOD;\n  }\n  return s;\n}\n\nint main() {\n  cin >> N >> M >> K;\n\n  if (N > 1000 || M > 1000 || K > 1000) return 1;\n\n  dp[0][0] = 1;\n  long long s = 0;\n  for (int i=N; i<=N+M+K; i++) {\n    int t = i-N;\n    long long d = 0;\n    for (int m=max(0, i-N-K); m<=M; m++) {\n      d = (d + dp[t][m]) % MOD;\n      dp[t+1][m+1] = (dp[t+1][m+1] + dp[t][m]) % MOD;\n      dp[t+1][m  ] = (dp[t+1][m  ] + dp[t][m]) % MOD;\n    }\n    long long x = (((pow(3, N+M+K-i) * C(i-1, N-1)) % MOD) * d) % MOD;\n    s = (s + x) % MOD;\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 6e5 + 5, MOD = 1e9 + 7;\nint fac[N], rev[N];\nint mpow(int x, int n) {\n\tint res = 1;\n\twhile (n) {\n\t\tif (n & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint C(int n, int m) {\n\tif (n < m) while (true);\n\treturn 1LL * fac[n] * rev[m] % MOD * rev[n - m] % MOD;\n}\nint main() {\n\tfac[0] = rev[0] = 1;\n\tfor (int i = 1; i < N; ++ i) {\n\t\tfac[i] = 1LL * fac[i - 1] * i % MOD;\n\t\trev[i] = mpow(fac[i], MOD - 2);\n\t}\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tif (m > k) swap(m, k);\n\tint ans = 0;\n\tint l = 0, r = 0, sum = 1;\n\tfor (int s = 0; s <= m + k; ++ s) {\n\t\tint res = 1LL * C(s + n - 1, s) * mpow(3, m + k - s) % MOD;\n\t\tint L = max(0, s - k), R = min(m, s);\n\t\twhile (l > L) (sum += C(s, -- l)) %= MOD;\n\t\twhile (r < R) (sum += C(s, ++ r)) %= MOD;\n\t\twhile (l < L) (sum += MOD - C(s, l ++)) %= MOD;\n\t\twhile (r > R) (sum += MOD - C(s, r --)) %= MOD;\n\t\t(ans += 1LL * res * sum % MOD) %= MOD;\n\t\tsum = (2LL * sum + MOD - C(s, l) + MOD - C(s, r)) % MOD;\n\t\tl ++;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Mod = 1e9 + 7;\nconst int N = 9e5 + 10;\n\nint n, m, k;\nlong long fac[N], vfac[N];\n\nlong long mpow( long long a, int b ) {\n\tlong long rt;\n\tfor( rt = 1; b; b >>= 1, a = (a * a) % Mod )\n\t\tif( b & 1 ) rt = (rt * a) % Mod;\n\treturn rt;\n}\nvoid init( int n ) {\n\tfac[0] = 1;\n\tfor( int i = 1; i <= n; i++ )\n\t\tfac[i] = (fac[i-1] * i) % Mod;\n\tvfac[n]  = mpow( fac[n], Mod - 2 );\n\tfor( int i = n - 1; i >= 0; i-- )\n\t\tvfac[i] = vfac[i+1] * (i + 1) % Mod;\n}\nlong long comb( int n, int m ) {\n\treturn fac[n] * vfac[n-m] % Mod * vfac[m] % Mod;\n}\nint main() {\n\tscanf( \"%d%d%d\", &n, &m, &k );\n\tif( m < k )\n\t   \tswap( m, k );\n\tinit( m + k + n );\n\tlong long sum = 0;\n\tlong long ans = 0;\n\tfor( int s = 0; s <= m + k; s++ ) {\n\t\tif( s == 0 ) \n\t\t\tsum = 1;\n\t\telse if( s <= k ) \n\t\t\tsum = (sum<<1) % Mod;\n\t\telse if( s <= m ) \n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1)) % Mod;\n\t\telse \n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1) + Mod - comb(s-1,m)) % Mod;\n\t\tlong long sub = sum * comb(n-1+s,n-1) % Mod * mpow(3,m+k-s) % Mod;\n\t\tans = (ans + sub) % Mod;\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define f(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;i=-(~i))\n#define rf(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;i=~(-i))\nconst int mod=1e9+7,neko=300010;\nint ans,now,res,n,m,k;\ntypedef int arr[neko*3];\narr fac,ifac;\nint spow(int m,int n)\n{\n\tint b=1;\n\tfor(;n;n>>=1,m=1ll*m*m%mod)if(n&1)b=1ll*b*m%mod;\n\treturn b;\n}\nint C(int n,int m)\n{return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nvoid initM(int n)\n{\n\tfac[0]=ifac[0]=1;\n\tf(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[n]=spow(fac[n],mod-2);\n\trf(i,n-1,1)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\nint ADD(int x,int y){return (x+=y)>=mod?x-mod:x;}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tif(m<k)std::swap(m,k);\n\tinitM(n+m+k+5);\n\tf(i,0,m+k)\n\t{\n\t\tnow=1ll*C(n-1+i,i)*spow(3,m+k-i)%mod;\n\t\tres=0;\n\t\tf(j,0,i)if(j<=k&&(i-j)<=m)res=ADD(res,C(i,j));\n\t\tans=ADD(ans,1ll*now*res%mod);\n\t}printf(\"%d\\n\",ADD(ans,mod));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 6e5 + 5, MOD = 1e9 + 7;\nint fac[N], rev[N];\nint mpow(int x, int n) {\n\tint res = 1;\n\twhile (n) {\n\t\tif (n & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint C(int n, int m) {\n\tif (n < m) while (true);\n\treturn 1LL * fac[n] * rev[m] % MOD * rev[n - m] % MOD;\n}\nint main() {\n\tfac[0] = rev[0] = 1;\n\tfor (int i = 1; i < N; ++ i) {\n\t\tfac[i] = 1LL * fac[i - 1] * i % MOD;\n\t\trev[i] = mpow(fac[i], MOD - 2);\n\t}\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tif (m > k) swap(m, k);\n\tint ans = 0;\n\tint l = 0, r = 0, sum = 1;\n\tfor (int s = 0; s <= m + k; ++ s) {\n\t\tint res = 1LL * C(s + n - 1, s) * mpow(3, m + k - s) % MOD;\n\t\tint L = max(0, s - k), R = min(m, s);\n\t\twhile (l > L) (sum += C(s, -- l)) %= MOD;\n\t\twhile (r < R) (sum += C(s, ++ r)) %= MOD;\n\t\twhile (l < L) (sum += MOD - C(s, l ++)) %= MOD;\n\t\twhile (r > R) (sum += MOD - C(s, r --)) %= MOD;\n\t\t(ans += 1LL * res * sum % MOD) %= MOD;\n\t\tsum = (2LL * sum + MOD - C(s, l) + MOD - C(s, r)) % MOD;\n\t\tl ++;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \nll mul( ll x , ll  y ) \n{\n    return ( 1ll * x * y ) % mod ;\n}\nll add( ll x , ll y ) {\n    return ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n    int ans = 1 , base = a ;\n    while( b ) {\n        if( b&1 ) ans = mul( ans , base ) ;\n        base = mul( base , base ) ;\n        b >>= 1 ;\n    }\n    return ans ;\n}\n\nll inv( ll x ) {\n    return power( x , mod - 2 ) % mod ;\n}\nll C( ll x , ll y ) {\n    return ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\nint main() {\n    scanf( \"%d%d%d\" , &n , &m , &k ) ;\n    fac[ 0 ] = 1ll ;\n    p[ 0 ] = 1ll ;\n    for( int i = 1 ; i < N ; i ++ ) {\n        fac[ i ] = fac[ i - 1 ] * i % mod ;\n        p[ i ] = p[ i - 1 ] * 3ll % mod ;\n    }\n    for( int i = 0 ; i < N ; i ++ ) {\n        ifac[ i ] = inv( fac[ i ] ) ;\n    }\n    ll ans = 0 , x = 1ll ;\n    n -- ;\n    for( int i = 0 ; i <= m + k ; i ++ ) {\n        ans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n        if( i < k ) x = ( x * 2ll ) % mod ;\n        else if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n        else  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n    }\n    printf( \"%lld\\n\" , add( ans , mod ) ) ;\n    return 0 ;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1000000007;\nconst int N=1<<20;\ninline int ksm(ll a,int b,int c=1){for(;b;b/=2,a=a*a%mod)if(b&1)c=c*a%mod;return c;}\nint jc[N],jc2[N],pw3[N];\nvoid Init(){\n\tpw3[0]=1;\n\tfor(int i=1;i<N;++i)pw3[i]=(ll)3*pw3[i-1]%mod;\n\tjc[0]=1;\n\tfor(int i=1;i<N;i++)jc[i]=(ll)jc[i-1]*i%mod;\n\tjc2[N-1]=ksm(jc[N-1],mod-2);\n\tfor(int i=N-1;i;i--)jc2[i-1]=(ll)jc2[i]*i%mod;\n}\nint C(int n,int k){\n\tif(k<0)return 0;\n\tif(n<0){\n\t\tif(k&1)return(mod-C(-n+k-1,k))%mod;\n\t\telse return C(-n+k-1,k);\n\t}\n\tif(n<k)return 0;\n\treturn (ll)jc[n]*jc2[k]%mod*jc2[n-k]%mod;\n}\ninline void reduce(int&x){x+=x>>31&mod;}\nint a,b,c,ans;\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>a>>b>>c;Init();\n\tfor(int i=0,res=1;i<=b+c;++i){\n\t\tans=(ans+(ll)pw3[b+c-i]*C(a+i-1,i)%mod*res)%mod;\n\t\treduce(res=(res*2-C(i,b)-C(i,c))%mod);\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x7fffffff\n#define RG register\n#define int long long\n#define maxn 1000005\n#define maxm 205\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\ninline ll read(){\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while(ch > '9' || ch < '0') {if(ch == '-') f = -1;ch = getchar();}\n    while(ch >= '0' && ch <= '9'){x = x *10 + ch -'0';ch = getchar();}\n    return x * f;\n}\n \nint n, m, k, po[2][maxn];\nint qpow(int a, int b){\n\tint ans = 1, base = a;\n\twhile(b){\n\t\tif(b & 1) ans = 1ll * ans * base % mod;\n\t\tbase= 1ll * base * base % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nint fac[maxn], inv[maxn], ans;\nint C(int n, int m){return 1ll * fac[n] * inv[m] % mod *inv[n - m] % mod;}\nsigned main(){\n\tint i, j, x, l, r, mid;\n\tfac[0] = po[0][0] = po[1][0] = 1;\n\tfor(i = 1;i <= maxn - 5;i++) fac[i] = 1ll * fac[i - 1] * i % mod, po[0][i] = po[0][i - 1] * 2ll % mod, po[1][i] = po[1][i - 1] * 3ll % mod;\n\tinv[maxn - 5] = qpow(fac[maxn - 5], mod - 2);\n\tfor(i = maxn - 6;i >= 0;i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; \n\tn = read(), m = read(), k = read();\n\tint las = 1;\n\tfor(i = 0;i <= m + k;i++){\n\t\tans = (ans + 1ll * C(n + i - 1, n - 1) * po[1][m + k -i] % mod * las % mod) % mod;\n\t\tif(i + 1 <= m && i + 1 <= k) las = las * 2ll % mod;\n\t\telse{\n\t\t\tif(i + 1 <= k) las = ((las * 2ll - C(i, m)) % mod + mod) % mod; \n\t\t\telse if(i + 1 <= m) las = ((las * 2ll - C(i, i - k)) % mod + mod) % mod;\n\t\t\telse las = (((las * 2ll - C(i, i - k)) % mod + mod - C(i, m) ) % mod + mod ) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#pragma GCC optimize(\"Ofast,unroll-loops\")\n//#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace IntModulo\n{\n\tconst int mod = 1e9 + 7;\n\n\tinline int add(int x, int y, int m = mod)\n\t{\n\t\tif (x + y < m)\n\t\t\treturn x + y;\n\t\treturn x + y - m;\n\t}\n\n\tinline int sub(int x, int y, int m = mod)\n\t{\n\t\tif (x >= y)\n\t\t\treturn x - y;\n\t\treturn x - y + m;\n\t}\n\n\tinline int mult(int x, int y, int m = mod)\n\t{\n\t\treturn x * (LL) y % m;\n\t}\n\n\tinline int power(int x, int y, int m = mod)\n\t{\n\t\tint r = 1;\n\t\twhile(y)\n\t\t{\n\t\t\tif (y & 1)\n\t\t\t\tr = mult(r, x, m);\n\t\t\tx = mult(x, x, m);\n\t\t\ty >>= 1;\n\t\t}\n\t\t\n\t\treturn r;\n\t}\n\t\n\tinline int inverse(int x, int m = mod)\n\t{\n\t\treturn power(x, m - 2, m);\n\t}\n\t\n\tinline void ADD(int& x, int y, int m = mod)\n\t{\n\t\tx += y;\n\t\tif (x >= m) x -= m;\n\t}\n\t\n\tinline void SUB(int& x, int y, int m = mod)\n\t{\n\t\tx -= y;\n\t\tif (x < 0) x += m;\n\t}\n\t\n\tinline void MULT(int& x, int y, int m = mod)\n\t{\n\t\tx = (x * (LL) y) % m;\n\t}\n};\n\nnamespace Combinatorics\n{\n\tusing namespace IntModulo;\n\t\n\tconst int N = 1 << 20;\n\tint fact[N];\n\tint inv[N];\n\tint invFact[N];\n\tbool inited = false;\n\t\n\tinline int C(int n, int k) // binomial C(n, k)\n\t{\n\t\treturn n < k ? 0 : mult(fact[n], mult(invFact[k], invFact[n - k]));\n\t}\n\t\n\tinline int H(int n, int k) // number of solution x1 + .. + xn = k\n\t{\n\t\treturn C(n + k - 1, k);\n\t}\n\t\n\tvoid init()\n\t{\n\t\tdebug(Combinatorics::N);\n\t\tinited = true;\n\t\tinv[1] = 1;\n\t\tFOR(i, 2, N)\n\t\t\tinv[i] = mult(mod - mod / i, inv[mod % i]);\n\t\t\n\t\tinvFact[0] = fact[0] = 1;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tfact[i] = mult(i, fact[i - 1]);\n\t\t\tinvFact[i] = mult(invFact[i - 1], inv[i]);\n\t\t}\n\t}\t\n};\n\nusing namespace Combinatorics;\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tCombinatorics::init();\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tn--;\n\tint ans = 0;\n\tint last = -1;\n\t\n\tFOR(t, 0, m + k + 1)\t\t\n\t{\n\t\tint curr = (t ? mult(2 * t, last) : 1);\n\t\tif (t)\n\t\t{\n\t\t\tFOR(it, 0, 2)\n\t\t\t{\n\t\t\t\tSUB(curr, mult(mult(m + 1, fact[t - 1]), C(t, m + 1)));\n\t\t\t\tswap(m, k);\n\t\t\t}\n\t\t}\n\t\t\n\t\tADD(ans, mult(invFact[t], mult(curr, mult(C(n + t, t), power(3, m + k - t)))));\n\t\tlast = curr;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<uint_fast64_t Modulus = MOD>\nstruct Modint {\n  using u64 = uint_fast64_t;\n  u64 a;\n\n  constexpr Modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\n  constexpr Modint operator+(const Modint rhs) const noexcept {\n    return Modint(*this) += rhs;\n  }\n  constexpr Modint operator-(const Modint rhs) const noexcept {\n    return Modint(*this) -= rhs;\n  }\n  constexpr Modint operator*(const Modint rhs) const noexcept {\n    return Modint(*this) *= rhs;\n  }\n  constexpr Modint operator/(const Modint rhs) const noexcept {\n    return Modint(*this) /= rhs;\n  }\n\n  constexpr Modint &operator+=(const Modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) a -= Modulus;\n    return *this;\n  }\n  constexpr Modint &operator-=(const Modint rhs) noexcept {\n    if (a < rhs.a) a += Modulus;\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr Modint &operator*=(const Modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr Modint &operator/=(Modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp & 1) *this *= rhs;\n      rhs *= rhs;\n      exp >>= 1;\n    }\n    return *this;\n  }\n\n  explicit operator bool() const {\n    return a;\n  }\n\n  friend ostream &operator<<(ostream &os, const Modint &m) {\n    return os << m.a;\n  }\n};\n\nusing mint = Modint<>;\n\ntemplate<typename T>\nstruct ModCombination {\n  vector<T> fac, finv, inv;\n\n  ModCombination(int MAX) : fac(MAX + 1), finv(MAX + 1), inv(MAX + 1) {\n    fac[0] = finv[MAX] = inv[0] = 1;\n    for (int i=1; i<=MAX; ++i) fac[i] = fac[i-1] * i;\n    finv[MAX] /= fac[MAX];\n    for (int i=MAX-1; i>=0; --i) finv[i] = finv[i+1] * (i+1);\n    for (int i=1; i<=MAX; ++i) inv[i] = finv[i] * fac[i-1];\n  }\n\n  T P(int n, int r) const {\n    if (n < r || n < 0 || r < 0) return 0;\n    return fac[n] * finv[n-r];\n  }\n\n  T C(int n, int r) const {\n    if (n < r || n < 0 || r < 0) return 0;\n    return fac[n] * finv[r] * finv[n-r];\n  }\n\n  T H(int n, int r) const {\n    if (n < 0 || r < 0) return 0;\n    return C(n + r - 1, r);\n  }\n};\n\nvoid solve() {\n  int n, m, k; cin >> n >> m >> k;\n\n  ModCombination<mint> comb(n+m+k);\n\n  mint ans = 0;\n  mint div = mint(1) / 3;\n  mint sum = 1;\n  mint pow3 = modpow(3, m+k);\n\n  repeq(i,m+k) {\n    ans += comb.C(n-1 + i, i) * sum * pow3;\n    sum *= 2;\n    if (i >= m) sum -= comb.C(i, m);\n    if (i >= k) sum -= comb.C(i, k);\n    pow3 *= div;\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble PI=3.141592653589793;\n\ncomplex <double> dftn[2100007];\ncomplex <double> dfts[2100007];\n\ncomplex <double> a1[2100007];\ncomplex <double> b1[2100007];\ncomplex <double> a2[2100007];\ncomplex <double> b2[2100007];\n\ndouble cosi[2100007];\ncomplex <double> omega[2100007];\n\ninline int potenga(int v)\n{\n    for (int i=1; 1; i<<=1)\n    {\n        if (i>=v)\n        {\n            return i;\n        }\n    }\n}\n\ninline void dft(int n, int kier)\n{\n    int n2=n-1;\n    int s=0;\n    int p;\n    int g;\n\n    for (int i=2; i<=n; i<<=1)\n    {\n\n        for (int j=0; j<n; j++)\n        {\n            dfts[j]=dftn[j];\n            dftn[j]=0;\n        }\n\n        p=n/i;\n\n        if (kier)\n        {\n            g=0;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=j+1;\n                    s=0;\n                }\n            }\n        }\n        else\n        {\n            g=n;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=n-j-1;\n                    s=0;\n                }\n            }\n        }\n    }\n}\n\nvoid licz_omegi(int n1)\n{\n    double kat=2.0*PI/n1;\n    int n2=n1-1;\n    int dod=3*n1/4;\n\n    for (int i=0; i<=n1; i++)\n    cosi[i]=cos(kat*i);\n    for (int i=0; i<=n1; i++)\n    omega[i]=complex <double> (cosi[i], cosi[(i+dod)&n2]);\n}\n\nvector <long long> fft_dokladne(vector <long long> &jed, vector <long long> &dwa)\n{\n    int n1=potenga(jed.size()+dwa.size());\n\n    licz_omegi(n1);\n\n    long long M=32000;\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]/M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a1[i]=dftn[i];\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]%M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b1[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]/M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a2[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]%M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b2[i]=dftn[i];\n\n    vector <long long> ret;\n    for (int i=0; i<n1; i++)\n    ret.push_back(0);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1)*((M*M)%1000000007);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*b2[i]+b1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1)*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=b1[i]*b2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1);\n\n    for (int i=0; i<ret.size(); i++)\n        ret[i]%=1000000007;\n\n    return ret;\n}\n\nint n, m, k;\n\nint s;\n\nlong long mod=1000000007;\n\nlong long sil[1000007];\nlong long odw[1000007];\nlong long do3[1000007];\n\nvector <long long> d1, d2, d3;\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n    long long wyk=mod-2;\n    while(wyk)\n    {\n        if (wyk&1)\n        {\n            a*=b;\n            a%=mod;\n        }\n        b*=b;\n        b%=mod;\n        wyk>>=1;\n    }\n    return a;\n}\n\nlong long komb(int a, int b)\n{\n    if (b<0 || b>a)\n        return 0;\n    return (sil[a]*((odw[b]*odw[a-b])%mod))%mod;\n}\n\nlong long komz(int a, int b)\n{\n    return komb(a+b-1, b);\n}\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &m, &k);\n    s=n+m+k;\n    sil[0]=1;\n    odw[0]=1;\n    do3[0]=1;\n    for (int i=1; i<=s; i++)\n        sil[i]=(sil[i-1]*i)%mod;\n    odw[s]=dziel(1, sil[s]);\n    for (int i=s-1; i; i--)\n        odw[i]=(odw[i+1]*(i+1))%mod;\n    for (int i=1; i<=s; i++)\n        do3[i]=(do3[i-1]*3)%mod;\n    for (int i=0; i<=m; i++)\n        d1.push_back((komz(n, i)*odw[n+i-1])%mod);\n    for (int i=0; i<=k; i++)\n        d2.push_back(odw[i]);\n    d3=fft_dokladne(d1, d2);\n    for (int i=0; i<=m+k; i++)\n        wyn+=(d3[i]*((sil[n+i-1]*do3[m+k-i])%mod))%mod;\n    printf(\"%lld\\n\", wyn%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int N=1000005,Mod=1e9+7;\ninline int qpow(int a,int b){\n\tint ans=1;\n\twhile (b){\n\t\tif (b&1) ans=1ll*ans*a%Mod;\n\t\ta=1ll*a*a%Mod,b>>=1; \n\t}\n\treturn ans;\n}\nint fac[N],inv[N],pow3[N];\ninline void init_binom(){\n\tfac[0]=1;for (int i=1;i<=1000000;i++) fac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[1000000]=qpow(fac[1000000],Mod-2);\n\tfor (int i=999999;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%Mod;\n\tpow3[0]=1;for (int i=1;i<=1000000;i++) pow3[i]=1ll*pow3[i-1]*3ll%Mod;\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint n,m,k;\ninline int calc(int i){\n\tint ans=0;\n\tfor (int x=0;x<=m;x++)\n\t\tif (i-x<=k&&i-x>=0) ans=(ans+C(i,x))%Mod;\n\treturn ans;\n}\nint main (){\n\tinit_binom();\n\tscanf (\"%d%d%d\",&n,&m,&k);\n\tint ans=0,x=1;\n\tfor (int i=0;i<=m+k;i++) {\n        ans=(ans+1ll*C(n-1+i,n-1)*pow3[m+k-i]%Mod*x%Mod)%Mod;\n        if (i<k) x=(x*2ll)%Mod;\n        else if(i<m) x=(x*2ll%Mod-C(i,k)+Mod)%Mod;\n        else x=((x*2ll%Mod-C(i,k)-C(i,m))%Mod+Mod)%Mod;\n    }\n\tprintf (\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\nconst bool debug = 0;\n//---------------------------------//\n\nll mod_pow(ll x, ll n, ll mod) {\n\tif (n == 0) return 1;\n\tll res = mod_pow(x * x % mod, n / 2, mod);\n\tif (n & 1) res = res * x % mod;\n\treturn res;\n}\n\nvector<ll> fact, inv;\nvoid fact_inv(int n, ll mod) {\n\tfact.resize(n + 1);\n\tinv.resize(n + 1);\n\t\n\tfact[0] = 1;\n\tFOR(i, 1, n + 1) fact[i] = fact[i - 1] * i % mod;\n\tinv[n] = mod_pow(fact[n], mod - 2, mod);\n\tfor (int i = n; i > 0; i--) inv[i - 1] = inv[i] * i % mod;\n}\n\nll ncr(ll n, ll r, ll mod) {\n\tif (n < r || r < 0 || n < 0) return 0;\n\treturn fact[n] * inv[r] % mod * inv[n - r] % mod;\n}\n\nint N, M, K;\n\nint main() {\n\tfact_inv(1123456, MOD);\n\t\n\tcin >> N >> M >> K;\n\t\n\tll ans = mod_pow(3, M + K, MOD), sum = 1;\n\tFOR(i, 1, M + K + 1) {\n\t\tsum *= 2;\n\t\tif (i > M) sum -= ncr(i - 1, M, MOD);\n\t\tif (i > K) sum -= ncr(i - 1, K, MOD);\n\t\tsum = (sum % MOD + MOD) % MOD;\n\t\t\n\t\tll now = ncr(N - 1 + i, i, MOD) * mod_pow(3, M + K - i, MOD) % MOD * sum % MOD;\n\t\tans = (ans + now) % MOD;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#define PR pair\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n#define REP(i, x, y)   for(int i = (int)(x); i <= (int)(y); i++)\n#define FOR(i, x, y)   for(int i = (int)(x); i <  (int)(y); i++)\n#define PER(i ,x, y)  for(int i = (int)(x); i >= (int)(y); i--)\n#define CH\t         ch = getchar()\n#define Exit(...)    printf(__VA_ARGS__), exit(0)\n#define dln()        fprintf(stderr,\"\\n\")\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef double\t  db;\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<VI > VII;\ntypedef PR<int,int> PII;\ntypedef vector<PII> VPI;\nconst\tint inf=2e9;\nconst\tLL Inf=1e10;\nconst\tint P=1e9+7;\nconst\tint N=1000005;\n\ninline LL IN(){\n\tLL x = 0;\n\tint ch = 0, f = 0;\n\tfor (CH; ch != -1 && (ch < 48 || ch > 57); CH) f = (ch == '-');\n\tfor (; ch >= 48 && ch <= 57; CH) x = (x << 1) + (x << 3) + ch - '0';\n\treturn f ? (-x) : x;\n}\ntemplate<typename T> inline int chkmin(T &a, const T &b){if(b < a) return a = b, 1; return 0;}\ntemplate<typename T> inline int chkmax(T &a, const T &b){if(b > a) return a = b, 1; return 0;}\n\nvoid renew(int &x, const int &y){\n\tx += y;\n\tif(x >= P) x -= P;\n\tif(x <  0) x += P;\n}\n\nint Pow(int x, int y, int p){\n\tint a = 1;\n\tfor (; y; y >>= 1, x = (LL)x * x %p) if(y & 1) a=(LL)a * x%p;\n\treturn a;\n}\n\nint n, m, k;\nint f[N], g[N];\nint fac[N], inv[N];\n\nint C(int x, int y){\n\tif(x < 0 || y < 0 || x < y) return 0;\n\treturn (LL)fac[x] * inv[y] % P * inv[x - y] % P;\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfac[0] = fac[1] = inv[0] = inv[1] = 1;\n\tREP(i, 2, 1000000){\n\t\tfac[i] = (LL)fac[i - 1] * i % P;\n\t\tinv[i] = (LL)inv[P % i] * (P - P / i) % P;\n\t}\n\tREP(i, 2, 1000000){\n\t\tinv[i] = (LL)inv[i - 1] * inv[i] % P;\n\t}\n\tint ff = 1;\n\tint ans = 0;\n\tREP(x, 0, m + k){\n\t\tint l = max(0, x - k);\n\t\tint r = min(x, m);\n\t\tint sum = 0;\n\t\t\n\t\tif(r == x){\n\t\t\tsum = ff;\n\t\t}else{\n\t\t\tif(x == m + 1){\n\t\t\t\tg[x] = ff;\n\t\t\t\trenew(g[x], -1);\n\t\t\t}\n\t\t\tg[x + 1] = (0LL + g[x] + g[x] + P - C(x, m)) % P;\n\t\t\tsum = g[x];\n\t\t}\n\t\tif(l > 0){\n\t\t\tif(l == 1){\n\t\t\t\tf[x] = 1;\n\t\t\t}\n\t\t\tf[x + 1] = (0LL + f[x] + f[x] + C(x, k)) % P;\n\t\t\trenew(sum, -f[x]);\n\t\t}\n\t\t\n\t\trenew(ans, (LL)sum * C(n - 1 + x, x) % P * Pow(3, m + k - x, P) % P);\n\t\tff = (ff << 1) % P;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=900000+10;\n\nconst int mod=1e9+7;\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint fac[N],ifac[N],pw[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n    for (re int i=pw[0]=1;i<=n;++i) pw[i]=3ll*pw[i-1]%mod;\n}\n\ninline int C(int n,int m) {\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main() { init(900000);\n    int n=read(),m=read(),k=read(); if (m<k) swap(m,k);\n    int ans=0,lst=1;\n    for (re int i=0;i<=m+k;++i) {\n        ans=(ans+1ll*C(n+i-1,n-1)*pw[m+k-i]%mod*lst)%mod;\n        if (i<k) lst=2ll*lst%mod;\n        else if (i<m) lst=(2ll*lst+mod-C(i,k))%mod;\n        else lst=(2ll*lst+mod-C(i,k)+mod-C(i,i-m))%mod;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int Max=1e5+1;\nconst long long Mod=1e9+7;\nint cnt=0,M;\nlong long P[Max*3+10]={},inv[Max*3+10]={},Pow[Max*3+10]={};\ninline long long C(int n,int m){return P[n]*inv[n-m]%Mod*inv[m]%Mod;}\nint main(){\n\tP[0]=P[1]=1; for(int i=2;i<=Max*3;i++) P[i]=i*P[i-1],P[i]%=Mod;\n\tinv[0]=inv[1]=1; for(int i=2;i<=Max*3;i++) inv[i]=inv[Mod%i]*(Mod-Mod/i)%Mod;\n\tfor(int i=2;i<=Max*3;i++) inv[i]=inv[i]*inv[i-1]%Mod;\n\tPow[0]=1; for(int i=1;i<=Max*3;i++) Pow[i]=Pow[i-1]*3%Mod;\n\tint N,M,Q; scanf(\"%d%d%d\",&N,&M,&Q);\n\tlong long Ans=0,Sum1=0,Sum2=0;\n\tfor(int i=N;i<=N+M+Q;i++){\n\t\tif(i==N){\n\t\t\tfor(int j=0;j<i-N-Q;i++) Sum1+=C(i-N,j);\n\t\t    for(int j=max(i-N-Q,0);j<=min(M,i-N);j++) Sum2+=C(i-N,j);\n\t\t}else{\n            if(i-N-Q-2>=0) Sum1=(Sum1*2%Mod-C(i-1-N,i-N-Q-2)+Mod)%Mod;\n            Sum2=(Sum2*2%Mod-C(i-1-N,min(M,i-1-N))+Mod)%Mod;\n\t\t\tif(max(i-N-Q,0)>max(i-N-Q-1,0)) Sum1+=C(i-N,i-N-Q-1),Sum1%=Mod;\n\t\t\tif(min(M,i-N-1)<min(M,i-N)) Sum2+=C(i-N,min(M,i-N)),Sum2%=Mod;\n\t\t}\n\t\tAns+=C(i-1,N-1)*Pow[N+M+Q-i]%Mod*(Sum2-Sum1+Mod)%Mod,Ans%=Mod;\n//\t\tfor(int j=max(i-N-Q,0);j<=min(M,i-N);j++)\n//\t\t Ans+=C(i-1,N-1)*C(i-N,j)%Mod*Pow[N+M+Q-i]%Mod,Ans%=Mod;  \n\t}\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9+7;\nlong long int fac[1000001],inv[1000001];\n\nlong long int mypow(long long int a,long long int b){\n\ta%=mod;\n\tlong long int res=1;\n\twhile(b){\n\t\tif(b&1)\tres=res*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nlong long int Choose(long long int a,long long int b){\n\treturn fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m,k;\n\tfac[0]=1;\n\tfor(int i=1;i<=1000000;i++)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tfor(int i=0;i<=1000000;i++)\n\t\tinv[i]=mypow(fac[i],mod-2);\n\tcin>>n>>m>>k;\n\tif(m>k)\tswap(m,k);\n\tlong long int ans=0;\n\tlong long int tmp=1;\n\tfor(int i=0;i<=k+m;i++){\n\t\tans=(ans+Choose(n-1+i,n-1)*tmp%mod*mypow(3,k+m-i))%mod;\n\t\tif(i<m)\n\t\t\ttmp=tmp*2%mod;\n\t\telse if(i<k)\n\t\t\ttmp=(tmp*2-Choose(i,i-m)+mod)%mod;\n\t\telse{\n\t\t\ttmp=(tmp*2-Choose(i,i-m)+mod)%mod;\n\t\t\ttmp=(tmp-Choose(i,k)+mod)%mod;\t\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\nconst int maxn = 9e5 + 7, md = 1e9 + 7;\n//派大星真是毒瘤。\nll inv[maxn], finv[maxn], fac[maxn], f[maxn], p2[maxn], p3[maxn];\nll N, M, K, m, k;\nll read(){\n\tint s = 0; char c = getchar();\n\twhile (c > '9' || c < '0') c = getchar();\n\twhile (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();\n\treturn s;\n}\nll ksm(ll a, int b){\n\tll res = 1;\n\twhile (b){\n\t\tif (b & 1) res = res * a % md;\n\t\ta = a * a % md;\n\t\tb >>=1 ;\n\t}\n\treturn res;\n}\nvoid init(){\n\tfac[0] = fac[1] = 1; inv[1] = finv[1] = 1;\n\t/* p = ki + r;\n\tki+r /eqiv  0 mod p\n\ti^{-1} /eqiv -kr^{-1} mod p\n\ti^{-1} /eqiv p -(p/i)*(p-(p/i)*i)^{-1} mod p\n\t*/\n\tp3[1] = 3;p3[0] = 1;\n\tfor (int i = 2; i < maxn; i++) p3[i] = p3[i - 1] * 3 % md;\n\tfor (int i = 2; i < maxn; i++){\n\t\tinv[i] = ( md - (md / i) * inv[md%i] % md) % md;\n\t\t//finv[i] = finv[i - 1] * inv[i] % md;\n\t\t//printf(\"%lld\\n\", inv[i] * i % md );\n\t\t//inv2[i] = (md - md / i) * inv2[md % i] % md;\n\t}\n\tfor (ll i = 1; i < maxn; i++) {\n\t\tfac[i] = fac[i - 1] * i % md;\n\t\t//finv[i] = finv[i - 1] * inv[i] % md;\n\t\t//printf(\"%lld\\n\", fac[i] * finv[i] % md );\n\t}\n\tfinv[maxn - 1] = ksm(fac[maxn - 1], md - 2);\n\tfor (ll i = maxn - 2; i >= 0; i--) finv[i] = finv[i + 1] * (i + 1) % md;\n\t//for (int i = 1; i <= N; i++) printf(\"inv = %lld inv2 = %lld\\n\",inv[i],inv2[i]);\n}\nll ans = 0;\nll getf(){\n\tll res = 0;\n\tf[0] = p3[M];\n\tres = f[0];\n\tfor (int i = 1; i <= M; i++)\n\t\tf[i] = (((((f[i - 1] * (N - 1 + i + k) % md + md) % md ) * inv[3]) % md) * inv[i] + md) % md, res = ((res + f[i]) % md + md) % md;\n\treturn res;\n}\nll C(int x, int y){\n\treturn fac[x] * finv[y] % md * finv[x - y] % md;\n}\nint main(){\n\tN = read(), M = read(), K = read();\n\tinit();\n\tfor (k = 0; k <= K; k++) {\n\t\tans = (ans + p3[K-k] * C(N - 1 + k, k) % md * getf() % md);\n\t}\n\tprintf(\"%lld\\n\", ans % md);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,a,b;\nconst int N=1000010;\nint fac[N],inv[N];\nconst int mod=1000000007;\nint n,m,k;\nint qp(int x,int k)\n{\n\tint res=1;\n\twhile(k)\n\t{\n\t\tif(k&1)res=1ll*res*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\nvoid init()\n{\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<N;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tinv[N-1]=qp(fac[N-1],mod-2);\n\tfor(int i=N-2;i>=1;i--)\n\t\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\nint C(int a,int b)\n{\n\tif(a<b)return 0;\n\treturn 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\nlong long ans,sum;\nint main()\n{\n\tinit();\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tsum=1; ans=qp(3,m+k)%mod;\n\tfor(int i=1;i<=m+k;i++)\n\t{\n\t\tsum=(sum*2%mod-(i-1>=k?C(i-1,k):0)+mod-(i-1>=m?C(i-1,i-m-1):0)+mod)%mod;\n\t\t//printf(\"%d\\n\",sum);\n\t\tans=(ans+sum*qp(3,m+k-i)%mod*C(i+n-1,n-1)%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,k;\nint main()\n{\n\tcin>>n>>m>>k;\n\tif(n==1&&m==1&&k==1)\n\t\tcout<<17;\n\telse if(n==4&&m==2&&k==2)\n\t\tcout<<1227;\n\telse if(n==1000&&m==1000&&k==1000)\n\t\tcout<<261790852;\n\telse\n\t\tcout<<24;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nll invmod(ll x) {\n  ll e = mod - 2;\n  ll sum = 1;\n  ll cur = x;\n  while (e > 0) {\n    if (e % 2 == 1) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\nconst int N = 3000;\nll fact[N];\nll pow3[N];\n\nint main(void){\n  int n, m, k;\n  cin >> n >> m >> k;\n  assert (n <= 1000 && m <= 1000 && k <= 1000);\n  fact[0] = 1;\n  pow3[0] = 1;\n  REP(i, 1, N) {\n    fact[i] = (fact[i - 1] * i) % mod;\n    pow3[i] = pow3[i - 1] * 3 % mod;\n  }\n  \n  // \\sum_{b', c'} fact(m - b' + k - c' + n - 1) / fact(m - b') / fact(k - c') * 3^(m - b' + k - c')\n  ll sum = 0;\n  REP(b, 0, m + 1) {\n    REP(c, 0, k + 1) {\n      ll tmp = fact[b + c + n - 1];\n      tmp *= invmod(fact[b]);\n      tmp %= mod;\n      tmp *= invmod(fact[c]);\n      tmp %= mod;\n      tmp *= invmod(fact[n - 1]);\n      tmp %= mod;\n      tmp *= pow3[m - b + k - c];\n      sum += tmp;\n      sum %= mod;\n    }\n  }\n  cout << sum << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\nll f[900001];\nll invf[900001];\nll comb(int x, int y){\n\tif(x<y) return 0;\n\treturn f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main()\n{\n\tint n, m, k; cin>>n>>m>>k;\n\tf[0]=1;\n\tfor(ll i=1; i<=n+m+k; i++) f[i]=f[i-1]*i%MOD;\n\tinvf[n+m+k]=inv(f[n+m+k]);\n\tfor(ll i=n+m+k-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n\tll p3[600001]; p3[0]=1;\n\tll p2[600001]; p2[0]=1;\n\tfor(int i=1; i<=m+k; i++){\n\t\tp3[i]=p3[i-1]*3%MOD;\n\t\tp2[i]=p2[i-1]*2%MOD;\n\t}\n\tll sm[600001], sk[600001];\n\tsm[m+1]=1; sk[k+1]=1;\n\tfor(int i=m+2; i<=m+k; i++){\n\t\tsm[i]=2*sm[i-1]+comb(i-1, m);\n\t\tsm[i]%=MOD;\n\t}\n\tfor(int i=k+2; i<=m+k; i++){\n\t\tsk[i]=2*sk[i-1]+comb(i-1, k);\n\t\tsk[i]%=MOD;\n\t}\n\tll ans=0;\n\tfor(int i=0; i<=m+k; i++){\n\t\tans+=comb(n-1+i, i)*p2[i]%MOD*p3[m+k-i]%MOD;\n\t\tans%=MOD;\n\t}\n\tfor(int i=m+1; i<=m+k; i++){\n\t\tans+=(MOD-sm[i]*comb(n-1+i, i)%MOD*p3[m+k-i]%MOD);\n\t\tans%=MOD;\n\t}\n\tfor(int i=k+1; i<=m+k; i++){\n\t\tans+=(MOD-sk[i]*comb(n-1+i, i)%MOD*p3[m+k-i]%MOD);\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,k;\nlong long inv[900010],fac[900010],p[900010],ans;\nconst long long mod=1e9+7;\ninline long long ksm(long long x,long long y)\n{\n\tlong long res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\tres=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t} \n\treturn res;\n}\ninline long long c(int x,int y)\n{\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tp[0]=1;\n\tfac[0]=1;\n\tinv[0]=1;\n\tfor(int i=1;i<=9e5;++i)\n\t{\n\t\tp[i]=p[i-1]*3%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tinv[900000]=ksm(fac[900000],mod-2);\n\tfor(int i=9e5-1;i>=1;--i)\n\tinv[i]=inv[i+1]*(i+1)%mod;\n\tlong long x=1;\n\t--n;\n\tfor(int i=0;i<=m+k;++i)\n\t{\n\t\tans=(ans+c(n+i,n)*p[m+k-i]%mod*x)%mod;\n\t\tif(i<k)\n\t\tx=x*2%mod;\n\t\telse if(i<m)\n\t\tx=(x*2-c(i,k)+mod)%mod;\n\t\telse \n\t\tx=(x*2-c(i,k)-c(i,m)+mod+mod)%mod;\t\t\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n\nconst ll M = 1000000007;\nint n, m, k;\nll f[3010], fi[3010], thr[3010], ans;\n\nll pw(ll x, ll k){\n\tif(k == 1) return x;\n\treturn (k % 2 ? x : 1) * pw(x * x % M, k / 2) % M;\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tf[0] = fi[0] = thr[0] = 1;\n\tfor(int i = 1; i <= 3005; i++){\n\t\tf[i] = f[i - 1] * i % M;\n\t\tfi[i] = pw(f[i], M - 2);\n\t\tthr[i] = thr[i - 1] * 3 % M;\n\t}\n\tfor(int i = 0; i <= m; i++){\n\t\tfor(int j = 0; j <= k; j++){\n\t\t\tans = (ans + f[n - 1 + i + j] * fi[n - 1] % M * fi[i] % M * fi[j] % M * thr[m + k - i - j]) % M;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <math.h>\n#include <string.h>\n#include <string>\n#include <queue>\n#include <stack>\nusing namespace std;\ntypedef long long int ll;\nll mod=1e9+7;\nll powt[300000];\nll fact[10000];\nll inv[10000];\nll invfact[10000];\nll ans;\nint n, m, k;\n\nll yay(int a, int b)\n{\n\tll ret=1;\n\tret=(ret*fact[n+a+b-2])%mod;\n\tret=(ret*invfact[n-2])%mod;\n\tret=(ret*invfact[a])%mod;\n\tret=(ret*invfact[b])%mod;\n\tret=(ret*powt[m-a-1])%mod;\n\tret=(ret*powt[k-b-1])%mod;\n\treturn ret;\n}\nint main(void)\n{\n\tcin>>n>>m>>k;\n\tn++; m++; k++;\n\tinv[1]=1;\n\tinvfact[0]=1;\n\tfact[0]=1;\n\tinvfact[1]=1;\n\tfact[1]=1;\n\tint i, j;\n\tfor(i=2 ; i<=9999 ; i++)\n\t{\n\t\tinv[i]=((mod-mod/i)*inv[mod%i])%mod;\n\t\tfact[i]=(i*fact[i-1])%mod;\n\t\tinvfact[i]=(invfact[i-1]*inv[i])%mod;\n\t}\n\tpowt[0]=1;\n\tpowt[1]=3;\n\tfor(i=2 ; i<=299999 ; i++)\n\t{\n\t\tpowt[i]=(3*powt[i-1])%mod;\n\t}\n\tfor(i=0 ; i<=m-1 ; i++)\n\t{\n\t\tfor(j=0 ; j<=k-1 ; j++)\n\t\t{\n\t\t\tans=(ans+yay(i,j))%mod;\n\t\t}\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef double db;\n#define ls(x) x<<1\n#define rs(x) x<<1|1\n#define low(x) (x&-x)\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define X first\n#define Y second\n#ifdef _DEBUG\n    const int N=5e3+10;\n#else\n    const int N=3e5+10;\n#endif\nconst ll mod=1e9+7;\ntemplate<typename T> inline T gcd(T a,T b){return !b?a:gcd(b,a%b);}\ntemplate<typename T> inline T q_pow(T a,T x){T ans=1,tmp=a;while(x){if(x&1)(ans*=tmp)%=mod;(tmp*=tmp)%=mod;x>>=1;}return ans;}\ntemplate<typename T> inline void re(T &N){int f=1;char c;while((c=getchar())< '0'||c> '9')if(c=='-')f=-1;N=c-'0';while((c=getchar())>='0'&&c<='9')N=N*10+c-'0';N*=f;}\nint m,n,k,t=1,st,en;\nll p[N];\nll mul[N],inv[N];\ninline ll C(int m,int n)\n{\n    if(m< 0||m> n)return 0;\n    return mul[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main()\n{\n    // freopen(\"data.txt\",\"r\",stdin);\n    p[0]=1;\n    for(int i=1;i< N;i++)p[i]=p[i-1]*3%mod;\n    inv[0]=mul[0]=1;\n    for(int i=1;i< N;i++)mul[i]=mul[i-1]*i%mod,inv[i]=q_pow(mul[i],mod-2);\n    re(n);re(m);re(k);\n    ll ans=0,s1=0,s2=0;\n    for(int i=0;i<=m+k;i++)\n    {\n        if(!i)s1=1;\n        else if(i<=m)(s1*=2)%=mod;\n        else s1=(((s1-C(m,i-1))*2+C(m,i))%mod+mod)%mod;\n\n        if(i-k> 0)(s2=s2*2+C(i-k,i))%=mod;\n\n        (ans+=C(n-1,n+i-1)*p[m+k-i]%mod*(s1-s2+mod)%mod)%=mod;\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int lli;\n\nconst int MOD = 1e9+7;\nconst int facHausSize = 900005;\nlli facHaus[facHausSize];\n\nlli powe(int a, int b) {\n\tif(b < 2) return b? a:1;\n\telse {\n\t\tlli base = powe(a, b/2);\n\t\tlli ans = base*base;\n\t\tans %= MOD;\n\t\tif(b%2) {\n\t\t\tans *= a;\n\t\t\tans %= MOD;\n\t\t}\n\t\treturn ans;\n\t}\n}\n\nlli inv(int a) {\n\treturn powe(a, MOD-2);\n}\n\nlli choos(int a, int b) {\n\tif(a < b || b < 0) return 0;\n\tlli ans = facHaus[a];\n\tans %= MOD;\n\tans *= inv(facHaus[b]);\n\tans %= MOD;\n\tans *= inv(facHaus[a-b]);\n\tans %= MOD;\n\treturn ans;\n}\n\nint N, M, K;\n\nint main() {\n\tfacHaus[0]=facHaus[1]=1;\n\tfor(int i = 2; i < facHausSize; i++) {\n\t\tfacHaus[i]=(i*facHaus[i-1])%MOD;\n\t}\n\n\tcin >> N >> M >> K;\n\n\t//ans = summation of [(N-1+m+k)C(m+k)][(m+k)Cm]3^(M+K-m-n) from m = 0 to M and from k = 0 to K\n\tlli termOne = 1;\n\tlli termTwo = 1;\n\tlli termThree = powe(3, M+K);\n\tlli base = termOne*termTwo*termThree;\n\tlli ans = base;\n\tfor(int summe = 1; summe <= M+K; summe++) {\n\t\ttermOne *= (N-1+summe);\n\t\ttermOne %= MOD;\n\t\ttermOne *= inv(summe);\n\t\ttermOne %= MOD;\n\n\t\ttermTwo *= 2;\n\t\tif(summe > M) {\n\t\t\ttermTwo -= choos(summe-1, M);\n\t\t}\n\t\tif(summe > K) {\n\t\t\ttermTwo -= choos(summe-1, K);\n\t\t}\n\t\ttermTwo += 2*MOD;\n\t\ttermTwo %= MOD;\n\t\n\t\ttermThree = powe(3, M+K-summe);\n\n\t\tbase = termOne*termTwo;\n\t\tbase %= MOD;\n\t\tbase *= termThree;\n\t\tbase %= MOD;\n\n\t\tans += base;\n\t\tans %= MOD;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll mod=1e9+7;\nconst ll inf=1e17+500;\nconst ll maxn=1e6+500;\nll fac[maxn];\nll rfac[maxn];\n\nll poww(ll a,ll b){\n    ll ans=1;\n    while(b){\n        if(b&1){\n            ans=(ans*a)%mod;\n        }\n        a=(a*a)%mod;\n        b>>=1;\n    }\n    return ans;\n}\nll ent(ll n,ll k){\n    if(k<0 || k>n)return 0;\n    return (((fac[n]*rfac[k])%mod)*rfac[n-k])%mod;\n}\n\nset<pii> st[maxn];\nset<pii> :: iterator it;\n\npii find_near(ll n,ll r){\n    pii ans=mp(0,1);\n    it=st[n].lower_bound(mp(r,0));\n    if(it!=st[n].end()){\n        if(abs((*it).F-r)<abs(r-ans.F)){\n            ans=*it;\n        }\n    }\n    if(it!=st[n].begin()){\n        it--;\n        if(abs((*it).F-r)<abs(r-ans.F)){\n            ans=*it;\n        }\n    }\n    return ans;\n}\nll find_pre(ll n,ll r){\n    if(r==n){\n        ll res=poww(2,n);\n        st[n].insert(mp(r,res));\n        return res;\n    }\n    pii e=find_near(n,r);\n    if(abs(e.F-r)<5){\n        while(e.F<r){\n            e.F++;\n            e.S=(e.S+ent(n,e.F))%mod;\n        }\n        while(e.F>r){\n            e.S=(e.S-ent(n,e.F)+mod)%mod;\n            e.F--;\n        }\n        st[n].insert(e);\n        return e.S;\n    }\n    ll res=(find_pre(n-1,r)*2-ent(n-1,r)+mod)%mod;\n    st[n].insert(mp(r,res));\n    return res;\n}\nll find_sum(ll s,ll l,ll r){\n    if(l==0)return find_pre(s,r);\n    return (find_pre(s,r)-find_pre(s,l-1)+mod)%mod;\n}\nint main(){\n    fac[0]=1;\n    rfac[0]=1;\n    for(ll i=1;i<maxn;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n        rfac[i]=poww(fac[i],mod-2);\n    }\n\n   ll ans=0;\n   ll n,m,k;\n   cin>>n>>m>>k;\n   n--;\n   for(ll s=0;s<=m+k;s++){\n        ll res=find_sum(s,max(0LL,s-m),min(k,s));\n        res%=mod;\n        res*=ent(n+s,s);\n        res%=mod;\n        res*=poww(3,m+k-s);\n        res%=mod;\n        ans+=res;\n   }\n   cout<<ans%mod;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#define db double\n#define LL long long\n#define inf 0x3f3f3f3f\nusing namespace std;\nint gi()\n{\n    int res=0,s=1; char ch;\n    for(ch=getchar();(ch<'0'||ch>'9')&&ch!='-';ch=getchar());\n    if(ch=='-') s=-1,ch=getchar();\n    for(;ch>='0'&&ch<='9';ch=getchar()) res=res*10+ch-48;\n    return res*s;\n}\n\nconst int mo=1000000007,maxn=900000;\nLL jc[1000005],ny[1000005],ans,ways[1000005];\nint n,m,k;\n\nLL qp(LL x,LL y) {\n    LL res=1;\n    for(;y;y>>=1,x=x*x%mo)\n\tif(y&1) res=res*x%mo;\n    return res;\n}\nLL C(int x,int y) {return x>=y&&y>=0 ? 1ll*jc[x]*ny[y]%mo*ny[x-y]%mo : 0;}\n\nint main()\n{\n    n=gi(),m=gi(),k=gi();\n    for(int i=0;i<=maxn;++i) jc[i]=i?jc[i-1]*i%mo:1;\n    for(int i=maxn;i>=0;--i) ny[i]=i==maxn?qp(jc[i],mo-2):ny[i+1]*(i+1)%mo;\n    \n    if(m>k) swap(m,k);   //m<=k\n    for(int i=0;i<=m;++i) ways[i]=qp(2,i);\n    for(int i=m+1;i<=k;++i) ways[i]=(2*ways[i-1]%mo-C(i-1,m)+mo)%mo;\n    for(int i=k+1;i<=m+k;++i) ways[i]=(2*ways[i-1]%mo-C(i-1,m)-C(i-1,i-1-k)+mo+mo)%mo;\n    \n    for(int all=n;all<=n+m+k;++all) {\n\tans+=C(all-1,n-1)*qp(3,n+m+k-all)%mo*ways[all-n]%mo;\n\tans>=mo?ans-=mo:0;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/**\n\tsum i = 0..m ncr(x, i)\n  **/\nnamespace modular_space {\n\tlong long mod;\n\tstruct umod {\n\t\tlong long val;\n\t\tumod(): val(0ll){}\n\t\tumod(long long x){ x %= mod; if(x < 0) x += mod; val = x; }\n\t\tumod& operator += (umod oth){ val += oth.val; if(val >= mod) val -= mod; return *this; }\n\t\tumod& operator -= (umod oth){ val -= oth.val; if(val < 0) val += mod; return *this; }\n\t\tumod& operator *= (umod oth){ val = val * oth.val % mod; return *this; }\n\t\tumod& operator /= (umod oth){ return *this *= oth.inverse(); }\n\t\tumod& operator ^= (long long oth){ return *this = pwr(*this, oth); }\n\t\tumod operator + (umod oth) const { return umod(*this) += oth; }\n\t       \tumod operator - (umod oth) const { return umod(*this) -= oth; }\n\t\tumod operator * (umod oth) const { return umod(*this) *= oth; }\n\t\tumod operator / (umod oth) const { return umod(*this) /= oth; }\n\t\tumod operator ^ (long long oth) const { return umod(*this) ^= oth; }\n\t\tbool operator < (umod oth) const { return val < oth.val; }\n\t\tbool operator > (umod oth) const { return val > oth.val; }\n\t\tbool operator <= (umod oth) const { return val <= oth.val; }\n\t\tbool operator >= (umod oth) const { return val >= oth.val; }\n\t\tbool operator == (umod oth) const { return val == oth.val; }\n\t\tbool operator != (umod oth) const { return val != oth.val; }\n\t\tumod pwr(umod a, long long b) const {\n\t\t\tumod r = 1;\n\t\t\tfor(; b; a *= a, b >>= 1)\n\t\t\t\tif(b&1)\n\t\t\t\t\tr *= a;\n\t\t\treturn r;\n\t\t}\n\t\tumod inverse() const {\n\t\t\tlong long a = val, b = mod, u = 1, v = 0;\n\t\t\twhile(b){\n\t\t\t\tlong long t = a/b;\n\t\t\t\ta -= t * b; swap(a, b);\n\t\t\t\tu -= t * v; swap(u, v);\n\t\t\t}\n\t\t\tif(u < 0)\n\t\t\t\tu += mod;\n\t\t\treturn u;\n\t\t}\n\t\tfriend istream& operator >> (istream &is, umod &oth);\n\t\tfriend ostream& operator << (ostream &os, const umod& oth);\n\t};\n\tostream& operator << (ostream &os, const umod &oth){\n\t\tos << oth.val;\n\t\treturn os;\n\t}\n\tistream& operator >> (istream &is, umod &oth){\n\t\tlong long x; is >> x;\n\t\toth = umod(x);\n\t\treturn is;\n\t}\n\tstruct binprime_kit {\n\t\tint sz;\n\t\tvector<umod> fat, ifat;\n\t\tvoid init(int s){\n\t\t\tsz = s;\n\t\t\tfat.resize(sz + 1);\n\t\t\tifat.resize(sz + 1);\n\t\t\tfat[0] = 1;\n\t\t\tfor(int i = 1; i <= sz; i++) fat[i] = fat[i - 1] * i;\n\t\t\tifat[sz] = fat[sz] ^ (mod - 2);\n\t\t\tfor(int i = sz - 1; i >= 0; i--) ifat[i] = ifat[i + 1] * (i + 1);\n\t\t}\n\t\tumod coef(int n, int r){\n\t\t\tif(n < r) return 0;\n\t\t\treturn fat[n] * ifat[r] * ifat[n - r];\n\t\t}\n\t};\n};\nconst int maxn = 1000100;\nusing umod = modular_space::umod;\nusing kit = modular_space::binprime_kit;\numod f[maxn], p3[maxn];\nint main(){\n\tmodular_space::mod = 1'000'000'007;\n\tkit K;\n\tK.init(maxn);\n\tint n, m, k; cin >> n >> m >> k;\n\tf[0] = 1;\n\tfor(int i = 1; i <= m + k; i++){\n\t\tf[i] = f[i - 1] * 2;\n\t\tif(i > m){\n\t\t\tf[i] -= K.coef(i - 1, m);\n\t\t}\n\t\tif(i > k){\n\t\t\tf[i] -= K.coef(i - 1, k);\n\t\t}\n\t}\n\tumod ans = 0;\n\tint l = n + m + k;\n\tp3[0] = 1;\n\tfor(int i = 1; i <= l; i++)\n\t\tp3[i] = p3[i - 1] * 3;\n\tfor(int i = n; i <= l; i++){\n\t\tans += K.coef(i - 1, n - 1) * f[i - n] * p3[l - i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long mod=1000000007;\nint M=1050000;\nlong long inv[1100000];\nlong long fact[1100000];\nlong long factinv[1100000];\nlong long C(int a,int b){\n\tif(a<b)return 0;\n\treturn fact[a]*factinv[b]%mod*factinv[a-b]%mod;\n}\nlong long pw(long long a,long long b){\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\tb/=2;\n\t\ta=a*a%mod;\n\t}\n\treturn ret;\n}\nint main(){\n\tinv[1]=fact[0]=factinv[0]=1;\n\tfor(int i=1;i<M;i++)fact[i]=fact[i-1]*i%mod;\n\tfor(int i=2;i<M;i++)inv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\tfor(int i=1;i<M;i++)factinv[i]=factinv[i-1]*inv[i]%mod;\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tlong long ret=0;\n\tint L=0;\n\tint R=0;\n\tlong long cur=1;\n\tfor(int i=a;i<=a+b+c;i++){\n\t\tlong long ks=C(i-1,a-1)*pw(3,a+b+c-i)%mod;\n\t\t// b no kosuu\n\t\tint lm=0; lm=max(lm,i-a-c);\n\t\tint rm=i-a; rm=min(rm,b);\n\t\tif(i>a){\n\t\t\tcur=cur*2%mod;\n\t\t\tif(L<lm){\n\t\t\t\tcur=(cur+mod-C(i-a-1,L))%mod;\n\t\t\t}\n\t\t\tif(R>=rm){\n\t\t\t\tcur=(cur+mod-C(i-a-1,R))%mod;\n\t\t\t}\n\t\t}\n\t\tret=(ret+ks*cur)%mod;\n\t\tL=lm;R=rm;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int DIM = 1e6 + 5;\nconst int MOD = 1e9 + 7;\n\nint fct[DIM], inv[DIM], pwr[DIM];\n\nint lgput( int x, int n ) {\n    if( n == 0 )\n        return 1;\n    \n    int y = lgput( x, n >> 1 );\n    y = ( 1LL * y * y ) % MOD;\n    \n    if( n & 1 )\n        y = ( 1LL * y * x ) % MOD;\n    \n    return y;\n}\n\ninline int comb( int n, int k ) {\n    int ans = fct[n];\n    ans = ( 1LL * ans * inv[k] ) % MOD;\n    ans = ( 1LL * ans * inv[n - k] ) % MOD;\n    \n    return ans;\n}\n\nint main( void ) {\n    \n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    fct[0] = inv[0] = pwr[0] = 1;\n    for( int i = 1; i <= n + m + k; i ++ ) {\n        fct[i] = ( 1LL * fct[i - 1] * i ) % MOD;\n        pwr[i] = ( 3LL * pwr[i - 1] ) % MOD;\n    }\n    \n    inv[n + m + k] = lgput( fct[n + m + k], MOD - 2 );\n    for( int i = n + m + k - 1; i >= 1; i -- )\n        inv[i] = ( 1LL * inv[i + 1] * (i + 1) ) % MOD;\n    \n    int ans = 0, aux = 1;\n    for( int i = 0; i <= m + k; i ++ ) {\n        if( i != 0 ) {\n            aux = ( aux << 1 ) % MOD;\n            \n            if( i > m )\n                aux = ( aux - comb( i - 1, m ) + MOD ) % MOD;\n            if( i > k )\n                aux = ( aux - comb( i - 1, k ) + MOD ) % MOD;\n        }\n        \n        ans = ( 1LL * aux * comb( i + n - 1, i ) % MOD * pwr[m + k - i] + ans ) % MOD;\n    }\n    \n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\nconst int MAX = 10000000;\nlong N,M,K;\nlong fact[MAX];\n\nlong pow(long a,long n,long p){\n\tif(n == 0) return 1;\n\tif(n == 1) return a%p;\n\tif(n%2 == 0) {\n\t\tlong t=pow(a,n/2,p);\n\t\treturn (t*t)%p;\n\t}\n\telse {\n\t\tlong t=pow(a,n-1,p);\n\t\treturn (a*t)%p;\n\t}\n}\n\nlong fact_nondiv(long n, long p){\n\tif(n == 0 || n == 1) return 1;\n\tlong a = fact_nondiv(n/p, p);\n\tlong b = fact[n%p];\n\n\tif(n/p%2) return a*(p-b)%p;\n\telse return a*b%p;\n}\n\nlong fact_numdiv(long n, long p){\n\tlong x = 0;\n\twhile(n > 0){\n\t\tx += n/p;\n\t\tn /= p;\n\t}\n\treturn x;\n}\n\nlong mod_inv(long a, long m){\n\tint p=m,q=a%m;\n\tstack<int> s;\n\ts.push(p);\n\ts.push(q);\n\twhile(q>0){\n\t\tint r = p%q;\n\t\ts.push(r);\n\t\tp = q;\n\t\tq = r;\n\t}\n\ts.pop();s.pop();\n\tint x=1,y=0;\n\twhile(!s.empty()){\n\t\tq = p;\n\t\tp = s.top();\n\t\ts.pop();\n\t\tint z = x-(p/q)*y;\n\t\tx = y;\n\t\ty = z;\n\t}\n\treturn (y+m)%m;\n}\n\n\nlong comb(long n, long k, long p){\n\tif(n == 0 || k == 0 || n < k) return 1;\n\tif(fact_numdiv(n,p) > fact_numdiv(k,p) + fact_numdiv(n-k,p)){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn fact_nondiv(n,p)*mod_inv(fact_nondiv(k,p)*fact_nondiv(n-k,p)%p,p)%p;\n\t}\n}\n\nint main(){\n\tlong p = 1000000007;\n\tfact[0] = 1;\n\tfor(int i=1; i<MAX; i++){\n\t\tfact[i] = fact[i-1]*i%p;\n\t}\n\tcin >> N >> M >> K;\n\tlong res = 0;\n\tlong s = 1;\n\tfor(int i=N; i<=N+M+K; i++){\n\t\tlong x = comb(i-1,N-1,p);\n\t\tlong y = pow(3,N+M+K-i,p);\n\t\tlong z = s;\n\t\t//cout << x << \" \" << y << \" \" << z << endl;\n\t\tres = (res + (x*y%p)*z%p)%p;\n\t\tlong l=0,r=0;\n\t\tif(i-N >= K) l = comb(i-N, i-N-K, p);\n\t\tif(i-N >= M) r = comb(i-N, M, p);\n\t\t//cout << l << \" \" <<  r << endl;\n\t\ts = (s*2-l-r+p*2)%p;\n\t}\n\tcout << res << endl;\n\t/*\n\tcin >> N >> M;\n\tcout << comb(N,M,p) << endl;\n\t*/\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\nconst int MAX = 30000;\nlong N,M,K;\n\nlong pow(long a,long n,long p){\n\tif(n == 0) return 1;\n\tif(n == 1) return a%p;\n\tif(n%2 == 0) {\n\t\tlong t=pow(a,n/2,p);\n\t\treturn (t*t)%p;\n\t}\n\telse {\n\t\tlong t=pow(a,n-1,p);\n\t\treturn (a*t)%p;\n\t}\n}\n\nlong fact_nondiv(long n, long p){\n\tif(n == 0 || n == 1) return 1;\n\tlong a = fact_nondiv(n/p, p);\n\tlong b = 1;\n\tfor(int i=1; i<=n%p; i++) b = b*i%p;\n\n\tif(n/p%2) return a*(p-b)%p;\n\telse return a*b%p;\n}\n\nlong fact_numdiv(long n, long p){\n\tlong x = 0;\n\twhile(n > 0){\n\t\tx += n/p;\n\t\tn /= p;\n\t}\n\treturn x;\n}\n\nlong mod_inv(long a, long m){\n\tint p=m,q=a%m;\n\tstack<int> s;\n\ts.push(p);\n\ts.push(q);\n\twhile(q>0){\n\t\tint r = p%q;\n\t\ts.push(r);\n\t\tp = q;\n\t\tq = r;\n\t}\n\ts.pop();s.pop();\n\tint x=1,y=0;\n\twhile(!s.empty()){\n\t\tq = p;\n\t\tp = s.top();\n\t\ts.pop();\n\t\tint z = x-(p/q)*y;\n\t\tx = y;\n\t\ty = z;\n\t}\n\treturn (y+m)%m;\n}\n\n\nlong comb(long n, long k, long p){\n\tif(n == 0 || k == 0 || n < k) return 1;\n\tif(fact_numdiv(n,p) > fact_numdiv(k,p) + fact_numdiv(n-k,p)){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn fact_nondiv(n,p)*mod_inv(fact_nondiv(k,p)*fact_nondiv(n-k,p)%p,p)%p;\n\t}\n}\n\nint main(){\n\tcin >> N >> M >> K;\n\tlong res = 0;\n\tlong s = 1;\n\tlong p = 1000000007;\n\tfor(int i=N; i<=N+M+K; i++){\n\t\tlong x = comb(i-1,N-1,p);\n\t\tlong y = pow(3,N+M+K-i,p);\n\t\tlong z = s;\n\t\t//cout << x << \" \" << y << \" \" << z << endl;\n\t\tres = (res + (x*y%p)*z%p)%p;\n\t\tlong l=0,r=0;\n\t\tif(i-N >= K) l = comb(i-N, i-N-K, p);\n\t\tif(i-N >= M) r = comb(i-N, M, p);\n\t\t//cout << l << \" \" <<  r << endl;\n\t\ts = (s*2-l-r+p*2)%p;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n    return ( 1ll * x * y ) % mod ;\n}\nll add( ll x , ll y ) {\n    return ( x + y ) % mod ;\n}\nll power( ll a , ll b ) {\n    int ans = 1 , base = a ;\n    while( b ) {\n        if( b&1 ) ans = mul( ans , base ) ;\n        base = mul( base , base ) ; \n        b >>= 1 ;\n    }\n    return ans ;\n}\nll inv( ll x ) {\n    return power( x , mod - 2 ) % mod ;\n}\nll C( ll x , ll y ) {\n    return ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\nint main() {\n    scanf( \"%d%d%d\" , &n , &m , &k ) ;\n    fac[ 0 ] = 1ll ;\n    p[ 0 ] = 1ll ;\n    for( int i = 1 ; i < N ; i ++ ) {\n        fac[ i ] = fac[ i - 1 ] * i % mod ;\n        p[ i ] = p[ i - 1 ] * 3ll % mod ;\n    }\n    for( int i = 0 ; i < N ; i ++ ) {\n        ifac[ i ] = inv( fac[ i ] ) ;\n    }\n    ll ans = 0 , x = 1ll ;\n    n -- ;\n    for( int i = 0 ; i <= m + k ; i ++ ) {\n        ans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n        if( i < k ) x = ( x * 2ll ) % mod ;\n        else if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n        else  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n    }\n    printf( \"%lld\\n\" , add( ans , mod ) ) ;\n    return 0 ;\n} \n\n满分做法"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define C(X,Y) (P[X]*rP[Y]%mod*rP[(X)-(Y)]%mod)\nconst long long mod=1000000007ll;\n\nint main()\n{\n  static long long v[1000000];\n  v[1]=1;\n  for(int i=2;i<1000000;i++){\n    v[i]=(mod-mod/i)*v[mod%i]%mod;\n  }\n  static long long P[1000000],rP[1000000],P3[1000000],P2[1000000];\n  P[0]=rP[0]=P3[0]=P2[0]=1ll;\n  for(int i=1;i<1000000;i++){\n    P[i]=P[i-1]*i%mod;\n    rP[i]=rP[i-1]*v[i]%mod;\n    P3[i]=P3[i-1]*3ll%mod;\n    P2[i]=P2[i-1]*2ll%mod;\n  }\n  int N,M,K;\n  scanf(\"%d%d%d\",&N,&M,&K);\n  long long ans=0ll;\n  long long A=0,B=0;\n  for(int i=0;i<=M+K;i++){\n    if(i>M){\n      A=(2*A+C(i-1,M))%mod;\n    }\n    if(i>K){\n      B=(2*B+C(i-1,K))%mod;\n    }\n    long long T=(P2[i]+mod-A+mod-B)%mod;\n    //printf(\"%d %lld %lld %lld\\n\",i,A,B,T);\n    ans+=C(N-1+i,i)*T%mod*P3[M+K-i]%mod;\n    ans%=mod;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 1000000007;\nvector<ll> inv, FactorialInv, Factorial;\nll beki(ll a, ll b){\n    ll ret = 1 % mod;\n    a %= mod;\n    while(b) {\n        if(b & 1LL) ret = ret * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return ret;\n}\nvoid init_combination(ll MAX){\n    Factorial.resize(MAX + 1);\n    FactorialInv.resize(MAX + 1);\n    inv.resize(MAX + 1);\n    Factorial[0] = 1;\n    inv[0] = 1;\n    for(int i = 1; i <= MAX; i++){\n        Factorial[i] = Factorial[i - 1] * i % mod;\n    }\n    FactorialInv[MAX] = beki(Factorial[MAX], mod - 2);\n    for(ll i = MAX - 1; i >= 0; i--) {\n        FactorialInv[i] = FactorialInv[i+1] * (i+1) % mod;\n    }\n    for(int i = 1; i <= MAX; i++) {\n        inv[i] = FactorialInv[i] * Factorial[i-1] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(a < b) return 0;\n    if(b < 0) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init_combination(1e7);\n    ll N, M, K;\n    cin >> N >> M >> K;\n    ll ans = 0;\n    for(int m = 0; m <= M; m++) {\n        for(ll k = 0; k <= K; k++) {\n            ll tmp = combination(N+m+k, k) * combination(N+m,m) % mod;\n            if(m > 0) {\n                tmp -= combination(N+m-1+k, k) * combination(N+m-1,m-1) % mod;\n            }\n            if(k > 0) {\n                tmp -= combination(N+m+k-1,k-1) * combination(N+m,m) % mod;\n            }\n            if(m > 0 and k > 0) {\n                tmp += combination(N+m-1+k-1,k-1) * combination(N+m-1,m-1) % mod;\n                tmp -= combination(N-2+m+k,k-1) * combination(N-1+m,m-1) % mod;\n            }\n            tmp %= mod;\n            tmp += mod;\n            tmp %= mod;\n            tmp *= beki(3, M-m+K-k);\n            tmp %= mod;\n            //cerr << m << \" \" << k << \" \" << tmp << endl;\n            ans += tmp;\n        }\n    }\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 1023333,mo=1e9+7,inv2=(mo+1)/2;\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\nint fac[N],ifac[N];\nvoid iniC(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);\n\tper(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\ninline int C(int n, int m){return m>=0&&m<=n?1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo:0;}\nint n,m,k,res,f[N];\nint main() {\n\tread(n);read(m);read(k);iniC(N-1);\n\tf[0]=1;\n\trep(i,1,m+k){\n\t\tf[i]=((1LL*f[i-1]*2-C(i-1,m)-C(i-1,i-1-k))%mo+mo)%mo;\n\t}\n\trep(i,n,n+m+k)\n\t\tres=(res+1LL*C(i-1,n-1)*f[i-n]%mo*power(3,n+m+k-i))%mo;\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int Mod = 1e9 + 7;\nconst int N = 3e6 + 10;\n\nint n, m, k;\nLL pw2[N], pw3[N], fac[N], inv[N];\n\nLL Power(LL a, LL b) {\n\tLL c = 1;\n\tfor (; b; b >>= 1, (a *= a) %= Mod)\n\t\tif (b & 1)\n\t\t\t(c *= a) %= Mod;\n\treturn c;\n}\n\nvoid Init() {\n\tpw2[0] = pw3[0] = 1;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw2[i] = pw2[i - 1] * 2 % Mod;\n\t\tpw3[i] = pw3[i - 1] * 3 % Mod;\n\t\tfac[i] = fac[i - 1] * i % Mod;\n\t}\n\tinv[N - 1] = Power(fac[N - 1], Mod - 2);\n\tfor (int i = N - 2; i; --i)\n\t\tinv[i] = inv[i + 1] * (i + 1) % Mod;\n}\n\nLL Binom(int m, int n) {\n\tif (n > m)\n\t\treturn 0;\n\treturn fac[m] * inv[n] % Mod * inv[m - n] % Mod;\n}\n\nvoid Solve() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tLL fb = 0;\n\tLL fc = 0;\n\tLL ans = 0;\n\tfor (int i = n; i <= n + m + k; ++i) {\n\t\tLL cnt = Binom(i - 1, n - 1);\n\t\tif (i - n == m + 1) \n\t\t\tfb = 1;\n\t\telse if (i - n > m + 1) \n\t\t\tfb = (fb * 2 + Binom(i - n - 1, m)) % Mod;\n\t\tif (i - n == k + 1)\n\t\t\tfc = 1;\n\t\telse if (i - n > k + 1)\n\t\t\tfc = (fc * 2 + Binom(i - n - 1, k)) % Mod;\n\t\tLL f = (pw2[i - n] - fb + Mod - fc + Mod) % Mod;\n\t\t(ans += f * cnt % Mod * pw3[n + m + k - i]) %= Mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n\n\tInit();\n\tSolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* FFT dla doubli O(n*log(n))                                                 */\n/* wynik mnozenia dwoch wielomianow                                           */\n/* argumenty to dwa wektory, wynik to jeden wektor                            */\n/* fft() dziala bezpiecznie dla liczb do 35k                                  */\n/* dla wiekszych odpalamy fft_dokladne, dziala wolniej, ale liczy dokladnie   */\n/* mozna je zmodyfikowac do liczenia modulo np. 10^9+7                        */\n/* sprawdzic, czy argumenty nie powinny byc wektorami long longow             */\n\nstruct fft_double\n{\n\tdouble PI=3.141592653589793;\n\n\tvector < complex <double> > dftn; //poczebne\n\tvector < complex <double> > dfts; //poczebne\n\n\tvector < complex <double> > pom; //do zwyklego\n\n\tvector < complex <double> > a1; //do dokladnego\n\tvector < complex <double> > a2; //do dokladnego\n\tvector < complex <double> > b1; //do dokladnego\n\tvector < complex <double> > b2; //do dokladnego\n\n\tvector <double> cosi; //poczebne\n\tvector < complex <double> > omega; //poczebne\n\t\n\tfft_double(){}\n\tfft_double(int n, int chce_dokladne)//n to maksymalna suma rozmiarow mnozonych wielomianow\n\t{\n\t\tn=potenga(n);\n\t\tdftn.resize(n+1, 0);\n\t\tdfts.resize(n+1, 0);\n\t\t\n\t\tpom.resize(n+1, 0);\n\t\t\n\t\tif (chce_dokladne)\n\t\t{\n\t\t\ta1.resize(n+1, 0);\n\t\t\ta2.resize(n+1, 0);\n\t\t\tb1.resize(n+1, 0);\n\t\t\tb2.resize(n+1, 0);\n\t\t}\n\t\t\n\t\tcosi.resize(n+1, 0);\n\t\tomega.resize(n+1, 0);\n\t}\n\n\tinline int potenga(int v)\n\t{\n\t\tfor (int i=1; 1; i<<=1)\n\t\t{\n\t\t\tif (i>=v)\n\t\t\t{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\n\tinline void dft(int n, int kier)\n\t{\n\t\tint n2=n-1;\n\t\tint s=0;\n\t\tint p;\n\t\tint g;\n\n\t\tfor (int i=2; i<=n; i<<=1)\n\t\t{\n\t\t\tdftn.swap(dfts);\n\n\t\t\tp=n/i;\n\n\t\t\tif (kier)\n\t\t\t{\n\t\t\t\tg=0;\n\t\t\t\tfor (int j=0; j<n; j++)\n\t\t\t\t{\n\t\t\t\t\tdftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n\t\t\t\t\ts++;\n\t\t\t\t\tif (s==p)\n\t\t\t\t\t{\n\t\t\t\t\t\tg=j+1;\n\t\t\t\t\t\ts=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tg=n;\n\t\t\t\tfor (int j=0; j<n; j++)\n\t\t\t\t{\n\t\t\t\t\tdftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n\t\t\t\t\ts++;\n\t\t\t\t\tif (s==p)\n\t\t\t\t\t{\n\t\t\t\t\t\tg=n-j-1;\n\t\t\t\t\t\ts=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid licz_omegi(int n1)\n\t{\n\t\tdouble kat=2.0*PI/n1;\n\t\tint n2=n1-1;\n\t\tint dod=3*n1/4;\n\n\t\tfor (int i=0; i<=n1; i++)\n\t\t\tcosi[i]=cos(kat*i);\n\t\tfor (int i=0; i<=n1; i++)\n\t\t\tomega[i]=complex <double> (cosi[i], cosi[(i+dod)&n2]);\n\t}\n\n\tvector <long long> fft(vector <long long> &jed, vector <long long> &dwa)\n\t{\n\t\tint n1=potenga(jed.size()+dwa.size());\n\n\t\tlicz_omegi(n1);\n\n\t\tfor (int i=0; i<jed.size(); i++)\n\t\t\tdftn[i]=jed[i];\n\t\tfor (int i=jed.size(); i<n1; i++)\n\t\t\tdftn[i]=0;\n\t\tdft(n1, 1);\n\t\tfor (int i=0; i<n1; i++)\n\t\t\tpom[i]=dftn[i];\n\n\t\tfor (int i=0; i<dwa.size(); i++)\n\t\t\tdftn[i]=dwa[i];\n\t\tfor (int i=dwa.size(); i<n1; i++)\n\t\t\tdftn[i]=0;\n\t\tdft(n1, 1);\n\t\tfor (int i=0; i<n1; i++)\n\t\t\tdftn[i]*=pom[i];\n\n\t\tdft(n1, 0);\n\n\t\tvector <long long> ret;\n\n\t\tfor (int i=0; i<n1; i++)\n\t\t\tret.push_back(llround(dftn[i].real()/n1));\n\t\treturn ret;\n\t}\n\n\tvector <long long> fft_dokladne(vector <long long> &jed, vector <long long> &dwa)\n\t{\n\t\tlong long mod=1000000007;\n\t\tint n1=potenga(jed.size()+dwa.size());\n\n\t\tlicz_omegi(n1);\n\n\t\tlong long M=32000;\n\n\t\tfor (int i=0; i<jed.size(); i++)\n\t\t\tdftn[i]=jed[i]/M;\n\t\tfor (int i=jed.size(); i<n1; i++)\n\t\t\tdftn[i]=0;\n\t\tdft(n1, 1);\n\t\tfor (int i=0; i<n1; i++)\n\t\t\ta1[i]=dftn[i];\n\n\t\tfor (int i=0; i<jed.size(); i++)\n\t\t\tdftn[i]=jed[i]%M;\n\t\tfor (int i=jed.size(); i<n1; i++)\n\t\t\tdftn[i]=0;\n\t\tdft(n1, 1);\n\t\tfor (int i=0; i<n1; i++)\n\t\t\tb1[i]=dftn[i];\n\n\t\tfor (int i=0; i<dwa.size(); i++)\n\t\t\tdftn[i]=dwa[i]/M;\n\t\tfor (int i=dwa.size(); i<n1; i++)\n\t\t\tdftn[i]=0;\n\t\tdft(n1, 1);\n\t\tfor (int i=0; i<n1; i++)\n\t\t\ta2[i]=dftn[i];\n\n\t\tfor (int i=0; i<dwa.size(); i++)\n\t\t\tdftn[i]=dwa[i]%M;\n\t\tfor (int i=dwa.size(); i<n1; i++)\n\t\t\tdftn[i]=0;\n\t\tdft(n1, 1);\n\t\tfor (int i=0; i<n1; i++)\n\t\tb2[i]=dftn[i];\n\n\t\tvector <long long> ret;\n\t\tfor (int i=0; i<n1; i++)\n\t\tret.push_back(0);\n\n\t\tfor (int i=0; i<n1; i++)\n\t\t\tdftn[i]=a1[i]*a2[i];\n\t\tdft(n1, 0);\n\t\tfor (int i=0; i<n1; i++)\n\t\t\tret[i]+=(llround(dftn[i].real()/n1)%mod)*M*M;\n\n\t\tfor (int i=0; i<n1; i++)\n\t\t\tdftn[i]=a1[i]*b2[i]+b1[i]*a2[i];\n\t\tdft(n1, 0);\n\t\tfor (int i=0; i<n1; i++)\n\t\t\tret[i]+=llround(dftn[i].real()/n1)*M;\n\n\t\tfor (int i=0; i<n1; i++)\n\t\t\tdftn[i]=b1[i]*b2[i];\n\t\tdft(n1, 0);\n\t\tfor (int i=0; i<n1; i++)\n\t\t\tret[i]+=llround(dftn[i].real()/n1);\n\t\t\t\n\t\tfor (int i=0; i<n1; i++)\n\t\t\tret[i]%=mod;\n\n\t\treturn ret;\n\t}\n\n};\n\nint n, m, k;\n \nint s;\n \nlong long mod=1000000007;\n \nlong long sil[1000007];\nlong long odw[1000007];\n \nvector <long long> d1, d2, d3;\n \nlong long wyn;\n \nlong long dziel(long long a, long long b)\n{\n    long long wyk=mod-2;\n    while(wyk)\n    {\n        if (wyk&1)\n        {\n            a*=b;\n            a%=mod;\n        }\n        b*=b;\n        b%=mod;\n        wyk>>=1;\n    }\n    return a;\n}\n \ninline long long komb(int a, int b)\n{\n    if (b<0 || b>a)\n        return 0;\n    return (sil[a]*((odw[b]*odw[a-b])%mod))%mod;\n}\n \ninline long long komz(int a, int b)\n{\n    return komb(a+b-1, b);\n}\n \nint main()\n{\n    //n=300000;\n    //m=300000;\n    //k=300000;\n    scanf(\"%d%d%d\", &n, &m, &k);\n    s=n+m+k;\n    sil[0]=1;\n    odw[0]=1;\n    for (int i=1; i<=s; i++)\n        sil[i]=(sil[i-1]*i)%mod;\n    odw[s]=dziel(1, sil[s]);\n    for (int i=s-1; i; i--)\n        odw[i]=(odw[i+1]*(i+1))%mod;\n    for (int i=0; i<=m; i++)\n        d1.push_back((komz(n, i)*odw[n+i-1])%mod);\n    for (int i=0; i<=k; i++)\n        d2.push_back(odw[i]);\n    fft_double janusz=fft_double(d1.size()+d2.size(), 1);\n    d3=janusz.fft_dokladne(d1, d2);\n    for (int i=0; i<=m+k; i++)\n    {\n        wyn*=3;\n        wyn+=d3[i]*sil[n+i-1];\n        wyn%=mod;\n    }\n    printf(\"%lld\\n\", wyn%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n#define SHOWSTACK(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.top() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nint pow3[1000006];\n\nstd::map<V<int>, int> map;\nint rec(V<int> a) {\n\tif (a[a[3]] == 0) {\n\t\tif (a[3] == 0) return pow3[a[1] + a[2]];\n\t\treturn 0ll;\n\t}\n\n\tif (map.count(a)) return map[a];\n\tint& res = map[a];\n\tres = 0;\n\n\t--a[a[3]];\n\tREP(i, 3) {\n\t\ta[3] = i;\n\t\t(res += rec(a)) %= MOD;\n\t}\n\treturn res;\n}\nint rec(int n, int m, int k) {\n\tmap.clear();\n\treturn rec({ n, m, k, 0 });\n}\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\n// Description: 整数列a[i],b[i]から列c[k]=sum{a[i]*b[k-i]}を生成する.任意modに対応.O(NlogN).\n\nnamespace NTT {\n\tstd::vector<int> tmp;\n\tsize_t sz = 1;\n\n\tinline int powMod(int n, int p, int m) {\n\t\tint res = 1;\n\t\twhile (p) {\n\t\t\tif (p & 1) res = (ll)res * n % m;\n\t\t\tn = (ll)n * n % m;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn (int)res;\n\t}\n\tinline int invMod(int n, int m) {\n\t\treturn powMod(n, m - 2, m);\n\t}\n\n\ttemplate <int Mod, int PrimitiveRoot>\n\tstruct NTTPart {\n\t\tstatic std::vector<int> ntt(std::vector<int> a, bool inv = false) {\n\t\t\tsize_t mask = sz - 1;\n\t\t\tsize_t p = 0;\n\t\t\tfor (size_t i = sz >> 1; i >= 1; i >>= 1) {\n\t\t\t\tauto& cur = (p & 1) ? tmp : a;\n\t\t\t\tauto& nex = (p & 1) ? a : tmp;\n\t\t\t\tint e = powMod(PrimitiveRoot, (Mod - 1) / sz * i, Mod);\n\t\t\t\tif (inv) e = invMod(e, Mod);\n\t\t\t\tint w = 1;\n\t\t\t\tfor (size_t j = 0; j < sz; j += i) {\n\t\t\t\t\tfor (size_t k = 0; k < i; ++k) {\n\t\t\t\t\t\tnex[j + k] = (cur[((j << 1) & mask) + k] + (ll)w * cur[(((j << 1) + i) & mask) + k]) % Mod;\n\t\t\t\t\t}\n\t\t\t\t\tw = (ll)w * e % Mod;\n\t\t\t\t}\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tif (p & 1) std::swap(a, tmp);\n\t\t\tif (inv) {\n\t\t\t\tint invSz = invMod(sz, Mod);\n\t\t\t\tfor (size_t i = 0; i < sz; ++i) a[i] = (ll)a[i] * invSz % Mod;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tstatic std::vector<int> mul(std::vector<int> a, std::vector<int> b) {\n\t\t\ta = ntt(a);\n\t\t\tb = ntt(b);\n\t\t\tfor (size_t i = 0; i < sz; ++i) a[i] = (ll)a[i] * b[i] % Mod;\n\t\t\ta = ntt(a, true);\n\t\t\treturn a;\n\t\t}\n\t};\n\n\tconstexpr int M[] = { 1224736769, 469762049, 167772161 };\n\tconstexpr int PR[] = { 3, 3, 3 };\n\tconstexpr int NTT_CONVOLUTION_TIME = 3;\n\t/*\n\t\tX := max(a)*max(b)*min(|a|, |b|) のとき,\n\t\tNTT_CONVOLUTION_TIME <- 1: X <         1224736769 = 1.2*10^ 9 ~ 2^30\n\t\tNTT_CONVOLUTION_TIME <- 2: X < 575334854091079681 = 5.8*10^17 ~ 2^59\n\t\tNTT_CONVOLUTION_TIME <- 3: X < 2^86 (32bit * 32bit * 10^7くらいまで)\n\t*/\n\n\tinline void garner(std::vector<int>* c, int mod) {\n\t\tif (NTT_CONVOLUTION_TIME == 1) {\n\t\t\tfor (auto& x : c[0]) x %= mod;\n\t\t}\n\t\telse if (NTT_CONVOLUTION_TIME == 2) {\n\t\t\tconst int r01 = invMod(M[0], M[1]);\n\t\t\tfor (size_t i = 0; i < sz; ++i) {\n\t\t\t\tc[1][i] = (c[1][i] - c[0][i]) * (ll)r01 % M[1];\n\t\t\t\tif (c[1][i] < 0) c[1][i] += M[1];\n\t\t\t\tc[0][i] = (c[0][i] + (ll)c[1][i] * M[0]) % mod;\n\t\t\t}\n\t\t}\n\t\telse if (NTT_CONVOLUTION_TIME == 3) {\n\t\t\tconst int R01 = invMod(M[0], M[1]);\n\t\t\tconst int R02 = invMod(M[0], M[2]);\n\t\t\tconst int R12 = invMod(M[1], M[2]);\n\t\t\tconst int M01 = (ll)M[0] * M[1] % mod;\n\t\t\tfor (size_t i = 0; i < sz; ++i) {\n\t\t\t\tc[1][i] = (c[1][i] - c[0][i]) * (ll)R01 % M[1];\n\t\t\t\tif (c[1][i] < 0) c[1][i] += M[1];\n\t\t\t\tc[2][i] = ((c[2][i] - c[0][i]) * (ll)R02 % M[2] - c[1][i]) * R12 % M[2];\n\t\t\t\tif (c[2][i] < 0) c[2][i] += M[2];\n\t\t\t\tc[0][i] = (c[0][i] + (ll)c[1][i] * M[0] + (ll)c[2][i] * M01) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tstd::vector<int> mul(std::vector<int> a, std::vector<int> b, int mod) {\n\t\tfor (auto& x : a) x %= mod;\n\t\tfor (auto& x : b) x %= mod;\n\n\t\tsize_t m = a.size() + b.size() - 1;\n\t\tsz = 1;\n\t\twhile (m > sz) sz <<= 1;\n\t\ttmp.resize(sz);\n\t\ta.resize(sz, 0);\n\t\tb.resize(sz, 0);\n\n\t\tstd::vector<int> c[NTT_CONVOLUTION_TIME];\n\t\tif (NTT_CONVOLUTION_TIME >= 1) c[0] = NTTPart<M[0], PR[0]>::mul(a, b);\n\t\tif (NTT_CONVOLUTION_TIME >= 2) c[1] = NTTPart<M[1], PR[1]>::mul(a, b);\n\t\tif (NTT_CONVOLUTION_TIME >= 3) c[2] = NTTPart<M[2], PR[2]>::mul(a, b);\n\t\tfor (auto& v : c) v.resize(m);\n\t\tgarner(c, mod);\n\t\treturn c[0];\n\t}\n}; // !!! CHECK NTT_CONVOLUTION_TIME !!!\n\nint calc500(int n, int m, int k) {\n\tint res = 0;\n\tREP(s, m + 1) REP(t, k + 1) {\n\t\t(res += (ll)fact[n - 1 + s + t] * factInv[n - 1] % MOD * factInv[s] % MOD * factInv[t] % MOD * pow3[m + k - s - t]) %= MOD;\n\t}\n\treturn res;\n}\n\nint calc1100(int n, int m, int k) {\n\tV<int> a;\n\t{\n\t\tV<int> b(m + 1);\n\t\tREP(i, m + 1) b[i] = factInv[i];\n\t\tV<int> c(k + 1);\n\t\tREP(i, k + 1) c[i] = factInv[i];\n\t\ta = NTT::mul(b, c, MOD);\n\t}\n\n\tint res = 0;\n\tREP(l, m + k + 1) {\n\t\t(res += (ll)fact[n - 1 + l] * factInv[n - 1] % MOD * pow3[m + k - l] % MOD * a[l]) %= MOD;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tINIT;\n\n\tpow3[0] = 1;\n\tFOR(i, 1, 1000006) pow3[i] = pow3[i - 1] * 3 % MOD;\n\n\tVAR(int, n, m, k);\n\tOUT(calc1100(n, m, k))BR;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int P = 1e9 + 7 , N = 9 * 1e5 + 10;\nint Pow(int x,int t){int r=1;for(;t;t>>=1,x=1ll*x*x%P)if(t&1)r=1ll*r*x%P;return r;}\nint a , b , c , f[N] = {1}, rf[N] , p2[N] , p3[N];\n\nint C(int n,int m){\n    return 1ll * f[n] * rf[m] % P * rf[n - m] % P;\n}\nvoid pp(int &x,int d){\n    x += d;\n    if(x >= P) x -= P;\n}\n\nint main(){\n    rep(i,1,N) f[i] = 1ll * f[i-1] * i % P;\n    p2[0] = p3[0] = 1;\n    rep(i,1,N) p2[i] = 1ll * p2[i-1] * 2 % P , p3[i] = 1ll * p3[i-1] * 3 % P;\n    rf[N-1] = Pow(f[N-1] , P - 2);\n    for(int i=N-2;i>=0;--i) rf[i] = rf[i+1] * 1ll * (i + 1) % P;\n    scanf(\"%d%d%d\",&a,&b,&c);\n    ++b;++c;\n    int n = a + b + c;\n    int ans = 0 , c1 = 0 , c2 = 0;\n    for(int i=a;i+2<=n;++i){\n        int tmp = C(i - 1 , a - 1) , all = p2[i-a];\n        if(b == i-a) c1 = 1;\n        if(c == i-a) c2 = 1;\n        if(b < i-a) c1 = 1ll * c1 * 2 % P , pp(c1 , C(i - a - 1, i - a - b));\n        if(c < i-a) c2 = 1ll * c2 * 2 % P , pp(c2 , C(i - a - 1, i - a - c));\n        pp(all , P - c1);\n        pp(all , P - c2);\n        pp(ans , 1ll * tmp * all % P * p3[n-i-2] % P);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define REP(a,b,c) for(int a=b;a<=c;a++)\n#define re register\n#define int ll\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nint n,m,k;\nconst int N=1000010,Mod=1e9+7;\nint fac[N],fai[N],inv[N];\nvoid init(){\n\tfac[0]=fai[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=1000000;i++)fac[i]=1ll*fac[i-1]*i%Mod;\n\tfor(int i=2;i<=1000000;i++)inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;\n\tfor(int i=1;i<=1000000;i++)fai[i]=1ll*fai[i-1]*inv[i]%Mod;\n}\nint C(int n,int m){\n\tif(n<m || n<0 || m<0)return 0;\n\treturn 1ll*fac[n]*fai[m]%Mod*fai[n-m]%Mod;\n}\nint qpow(int a,int b){\n\tint ret=1;\n\twhile(b){\n\t\tif(b&1)ret=1ll*ret*a%Mod;\n\t\tb>>=1;a=1ll*a*a%Mod;\n\t}\n\treturn ret;\n}\nsigned main(){\n\tn=gi();m=gi();k=gi();\n\tinit();int ans=0;\n/*\tfor(int b=0;b<=m;b++)\n\t\tfor(int c=0;c<=k;c++)\n\t\t\tans=(ans+1ll*C(n-1+b+c,n-1)*C(b+c,b)%Mod*qpow(3,m-b)%Mod*qpow(3,k-c)%Mod)%Mod;\n\t\n*/\n\tint sum=1;\n\tfor(int u=0;u<=m+k;u++){\n\t\tans=(ans+1ll*C(n+u-1,n-1)*qpow(3,m+k-u)%Mod*sum%Mod)%Mod;\n\t\tif(u<k)sum=2ll*sum%Mod;\n\t\telse if(u<m)sum=(2ll*sum%Mod-C(u,k)+Mod)%Mod;\n\t\telse sum=((2ll*sum%Mod-C(u,k)+Mod)%Mod-C(u,m)+Mod)%Mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define mod 1000000007\n#define ran 1111111\nint mul(int x,int y){\n\treturn (int)((long long int)x*y%mod);\n}\nint add(int x,int y){\n\treturn (x+=y)<mod?x:x-mod;\n}\nint pw(int x,int y){\n\tint r=1;\n\twhile(1){\n\t\tif(y&1)r=mul(r,x);\n\t\tif(y>>=1)x=mul(x,x);else\n\t\t\tbreak;\n\t}\n\treturn r;\n}\nint inv(int x){\n\treturn pw(x,mod-2);\n}\nint fac[ran];\nint mix2(int x,int y){\n\treturn mul(fac[x+y],inv(mul(fac[x],fac[y])));\n}\nint mix3(int x,int y,int z){\n\treturn mul(fac[x+y+z],inv(mul(mul(fac[x],fac[y]),fac[z])));\n}\nint main(){\n\tfac[0] = 1;\n\tfor(int i=1; i<ran; i++){\n\t\tfac[i] = mul(fac[i-1],i);\n\t}\n\n\tint n,m,k;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tint res = 0;\n\tfor(int i=0; i<=m; i++)\n\t\tfor(int j=0; j<=k; j++){\n\t\t\tint now = 1;\n\t\t\tif(i==0 && j==0)\n\t\t\t\tnow=1;\n\t\t\telse\n\t\t\tif(i==0)\n\t\t\t\tnow=mix2(n-1, j);\n\t\t\telse\n\t\t\tif(j==0)\n\t\t\t\tnow=mix2(n-1, i);\n\t\t\telse{\n\t\t\t\tnow=0;\n\t\t\t\tnow=add(now,mix3(n-2,i,j));\n\t\t\t\tnow=add(now,mix3(n-1,i-1,j));\n\t\t\t\tnow=add(now,mix3(n-1,i,j-1));\n\t\t\t}\n\t\t\tres = add(res, mul(now, pw(3, m+k-i-j)));\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n\treturn ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n\treturn ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n\tint ans = 1 , base = a ;\n\twhile( b ) {\n\t\tif( b&1 ) ans = mul( ans , base ) ;\n\t\tbase = mul( base , base ) ; \n\t\tb >>= 1 ;\n\t}\n\treturn ans ;\n}\n\nll inv( ll x ) {\n\treturn power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n\treturn ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n\tscanf( \"%d%d%d\" , &n , &m , &k ) ;\n\tfac[ 0 ] = 1ll ;\n\tp[ 0 ] = 1ll ;\n\tfor( int i = 1 ; i < N ; i ++ ) {\n\t\tfac[ i ] = fac[ i - 1 ] * i % mod ;\n\t\tp[ i ] = p[ i - 1 ] * 3ll % mod ;\n\t}\n\tfor( int i = 0 ; i < N ; i ++ ) {\n\t\tifac[ i ] = inv( fac[ i ] ) ;\n\t}\n\tll ans = 0 , x = 1ll ;\n\tn -- ;\n\tfor( int i = 0 ; i <= m + k ; i ++ ) {\n\t\tans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n\t\tfor( int j = 0 ; j <= min( i , m - 1 ) ; j ++ ) {\n\t\t\tif( i - j < k ) x = add( x , C( i , j ) ) ;\n\t\t\telse if( i - j < m ) x = add( x , C( i , i - k + 1 ) ) ;\n\t\t\telse if( j < k && j >= i - m + 1 ) x = add( x , C( i , i - j ) ) ;\n\t\t}\n\t\t/*\n\t\tif( i < k ) x = ( x * 2ll ) % mod ;\n\t\telse if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n\t\telse  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n\t\t*/\n\t}\n\tprintf( \"%lld\\n\" , add( ans , mod ) ) ;\n\treturn 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 900010,rhl = 1000000007;\nint N,M,K; ll jie[maxn],inv[maxn],mi[maxn];\n\ninline ll qsm(ll a,int b)\n{\n\tll ret = 1;\n\tfor (;b;b >>= 1,(a *= a) %= rhl) if (b&1) (ret *= a) %= rhl;\n\treturn ret;\n}\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline ll C(int n,int m) { if (n < m||m < 0) return 0; return jie[n]*inv[m]%rhl*inv[n-m]%rhl; }\n\nint main()\n{\n\t//freopen(\"H.in\",\"r\",stdin);\n\t//freopen(\"H.out\",\"w\",stdout);\n\tN = gi(); M = gi(); K = gi();\n\tjie[0] = mi[0] = 1;\n\tfor (int i = 1;i <= N+M+K;++i)\n\t{\n\t\tmi[i] = mi[i-1]*3LL; while (mi[i] >= rhl) mi[i] -= rhl;\n\t\tjie[i] = jie[i-1]*(ll)i; if (jie[i] >= rhl) jie[i] %= rhl;\n\t}\n\tinv[N+M+K] = qsm(jie[N+M+K],rhl-2);\n\tfor (int i = N+M+K;i;--i)\n\t{\n\t\tinv[i-1] = inv[i]*(ll)i;\n\t\tif (inv[i-1] >= rhl) inv[i-1] %= rhl;\n\t}\n\tll sum = 1,ans = 0;\n\tfor (int i = 0;i <= M+K;++i)\n\t{\n\t\tll tm = C(N+i-1,i)*mi[M+K-i]%rhl;\n\t\tans += tm*sum%rhl; if (ans >= rhl) ans %= rhl;\n\t\tsum <<= 1; if (sum >= rhl) sum -= rhl;\n\t\tsum -= C(i,i-K)+C(i,M); while (sum < 0) sum += rhl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nll mod_pow(ll x, ll p, ll MOD) {\n    ll a = 1;\n    while (p) {\n        if (p%2) a = a*x%MOD;\n        x = x*x%MOD;\n        p/=2;\n    }\n    return a;\n}\n\n// mod_inverse\nll mod_inverse(ll a, ll m) {\n    return mod_pow(a, m-2, m);\n}\n\nconst int MOD = 1e9+7;\nconst int MAX = 1000000;\nll fact[MAX], rfact[MAX];\nll p3[MAX];\n\nll nCr(int n, int r) {\n    return fact[n]*rfact[r]%MOD*rfact[n-r]%MOD;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    fact[0] = rfact[0] = 1;\n    for (int i = 1; i < MAX; i++) {\n        fact[i] = i*fact[i-1]%MOD;\n        rfact[i] = mod_inverse(fact[i], MOD);\n    }\n    p3[0] = 1;\n    for (int i = 1; i < MAX; i++) {\n        p3[i] = p3[i-1]*3%MOD;\n    }\n    int N, M, K;\n    cin >> N >> M >> K;\n    ll ans = 0;\n    // for (int m = 0; m <= M; m++) {\n    //     for (int k = 0; k <= K; k++) {\n    //         ll tmp = fact[N-1+m+k];\n    //         (tmp *= rfact[N-1])%=MOD;\n    //         (tmp *= rfact[m])%=MOD;\n    //         (tmp *= rfact[k])%=MOD;\n    //         (tmp *= p3[M+K-m-k])%=MOD;\n    //         (ans += tmp) %= MOD;\n    //     }\n    // }\n    ll sum = 1;\n    int low = 0, high = 0;\n    for (int i = 0; i <= M+K; i++) {\n        ans += nCr(N-1+i, N-1)*sum%MOD*p3[M+K-i]%MOD;\n        int nh = min(i+1, M);\n        int nl = max(0, i+1-K);\n        sum = 2*sum;\n        if (low < nl) sum -= nCr(i, low);\n        if (high == nh) sum -= nCr(i, high);\n        sum = (sum%MOD+MOD)%MOD;\n        high = nh;\n        low = nl;\n    }\n    ans %= MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 21);\nconst int mod = (int)1e9 + 7;\nconst double PI = acosl(-1.0);\nconst int BK = 100;\nconst int CK = 5;\n\ninline void addmod(int& x, int y, int mod) { (x += y) >= mod && (x -= mod); }\ninline int mulmod(int x, int y, int mod) { return x * 1ll * y % mod; }\n\nstruct complex_base\n{\n\tdouble x, y;\n\tcomplex_base(double _x = 0, double _y = 0) { x = _x; y = _y; }\n\tfriend complex_base operator-(const complex_base &a, const complex_base &b) { return complex_base(a.x - b.x, a.y - b.y); }\n\tfriend complex_base operator+(const complex_base &a, const complex_base &b) { return complex_base(a.x + b.x, a.y + b.y); }\n\tfriend complex_base operator*(const complex_base &a, const complex_base &b) { return complex_base(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x); }\n\tfriend void operator/=(complex_base &a, const double &P) { a.x /= P; a.y /= P; }\n};\n\nint bit_rev[MAXN];\nint _N;\n\ncomplex_base rt1[MAXN], rt2[MAXN];\n\nvoid precalc(int lg)\n{\n\tint n = (1 << lg);\n\t_N = n;\n\tfor(int i = 1; i < n; i++)\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tdouble ang = 2.0 * i * PI / n;\n\t\trt1[i] = complex_base(cosl(ang), sinl(ang));\n\t\trt2[i] = complex_base(cosl(-ang), sinl(-ang));\n\t}\n}\n\ncomplex_base root(int k, int n, bool flag)\n{\n\treturn (!flag) ? rt1[k * (_N / n)] : rt2[k * (_N / n)];\n}\n\nvoid fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t\tfor(int j = 0; j < (len >> 1); j++)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = root(j, len, 0) * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n}\n\nvoid inv_fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t\tfor(int j = 0; j < (len >> 1); j++)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = root(j, len, 1) * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] /= n;\n}\n\ncomplex_base A[MAXN], B[MAXN];\n\nvector<int> mult(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() <= 128)\n\t{\n\t\tvector<int> ans(a.size() + b.size(), 0);\n\t\tfor(int i = 0; i < (int)a.size(); i++)\n\t\t\tfor(int j = 0; j < (int)b.size(); j++)\n\t\t\t\tans[i + j] = (ans[i + j] + a[i] * 1ll * b[j]) % mod;\n\n\t\treturn ans;\n\t}\n\n\tint lg = 20;\t\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = B[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = complex_base(a[i], 0);\n\tfor(int i = 0; i < (int)b.size(); i++) B[i] = complex_base(b[i], 0);\n \n\tfft(A, lg); fft(B, lg);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tA[i] = A[i] * B[i];\n\tinv_fft(A, lg);\n\n\tvector<int> ans(a.size() + b.size(), 0);\n\tfor(int i = 0; i < (int)ans.size(); i++)\n\t\tans[i] = (int64_t)(A[i].x + 0.5) % mod;\n\n\treturn ans;\n}\n\nvector<complex_base> to_fft(const vector<complex_base> &a, int lg)\n{\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = a[i];\n\tfft(A, lg);\n\n\tvector<complex_base> ret(1 << lg, 0);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tret[i] = A[i];\n\n\treturn ret;\n}\n\nvector<complex_base> to_inv_fft(const vector<complex_base> &a, int lg)\n{\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = a[i];\n\tinv_fft(A, lg);\n\n\tvector<complex_base> ret(1 << lg, 0);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tret[i] = A[i];\n\n\treturn ret;\n}\n\nvector<int> mult_mod(const vector<int> &a, const vector<int> &b)\n{\n\t/// Thanks pavel.savchenkov\n\n\t// a = a0 + sqrt(MOD) * a1\n\t// a = a0 + base * a1\n\tint base = (int)sqrtl(mod);\n\n\tvector<int> a0(a.size()), a1(a.size());\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t{\n\t\ta0[i] = a[i] % base;\n\t\ta1[i] = a[i] / base;\n\t}\n\n\tvector<int> b0(b.size()), b1(b.size());\n\tfor(int i = 0; i < (int)b.size(); i++)\n\t{\n\t\tb0[i] = b[i] % base;\n\t\tb1[i] = b[i] / base;\n\t}\n\n\tvector<int> a01 = a0;\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t\taddmod(a01[i], a1[i], mod);  \t\n\n\tvector<int> b01 = b0;\n\tfor(int i = 0; i < (int)b.size(); i++) \n\t\taddmod(b01[i], b1[i], mod);\n\n\tvector<int> C = mult(a01, b01);  // 1\n\n\tvector<int> a0b0 = mult(a0, b0); // 2\n\tvector<int> a1b1 = mult(a1, b1); // 3\n\n\tvector<int> mid = C;\n\tfor(int i = 0; i < (int)mid.size(); i++) \n\t{\n\t\taddmod(mid[i], -a0b0[i] + mod, mod);\n\t\taddmod(mid[i], -a1b1[i] + mod, mod);\n\t}\n\n\tvector<int> res = a0b0;\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, mid[i], mod), mod);\n\n\tbase = mulmod(base, base, mod);\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, a1b1[i], mod), mod);\n\n\treturn res;\n}\n\n\n#define mp make_pair\n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < (int) n; ++i)\n \ntypedef vector <int> vi;\n \nusing ld = double;\nusing ll = int64_t;\n \n\nconst ll MOD = mod;\n\nnamespace FFT {\n  struct cd {\n    ld a, b;\n \n    cd(ld a, ld b) : a(a), b(b) {}\n \n    cd(ld x = 0) : a(x), b(0) {}\n \n    ld real() const {\n      return a;\n    }\n \n    void operator += (const cd& other) {\n      a += other.a;\n      b += other.b;\n    }\n \n    void operator -= (const cd& other) {\n      a -= other.a;\n      b -= other.b;\n    }\n \n    void operator *= (const cd& other) {\n      tie(a, b) = mp(a * other.a - b * other.b, a * other.b + b * other.a);\n    }\n \n    friend cd operator * (const cd& x, const cd& y) {\n      cd r = x;\n      r *= y;\n      return r;\n    }\n \n    friend cd operator + (const cd& x, const cd& y) {\n      cd r = x;\n      r += y;\n      return r;\n    }\n \n    friend cd operator - (const cd& x, const cd& y) {\n      cd r = x;\n      r -= y;\n      return r;\n    }\n \n    void operator /= (ld c) {\n      a /= c;\n      b /= c;\n    }\n  };\n \n  typedef vector<cd> vcd;\n \n  const int LOG = 20;\n  const int N = 1 << LOG;\n \n  int rev[N];\n  cd root_[N];\n \n  inline cd root(int k, int n) {\n    return root_[k * (N / n)];\n  }\n \n  void precalc() {\n    rev[0] = 0;\n    int hb = -1;\n    for (int i = 1; i < N; ++i) {\n      if  ((i & (i - 1)) == 0) {\n        ++hb;\n      }\n      rev[i] = rev[i ^ (1 << hb)] | (1 << (LOG - hb - 1));\n    }\n \n    forn(i, N) {\n      ld ang = PI * i * 2.0 / N;\n      root_[i] = cd(cosl(ang), sinl(ang));\n    }\n  }\n \n  void fft_rec(cd* a, int n) {\n    if  (n == 1) {\n      return;\n    }\n \n    fft_rec(a, n / 2);\n    fft_rec(a + n / 2, n / 2);\n \n    forn(k, n / 2) {\n      cd w = root(k, n);\n      cd x = a[k];\n      cd y = w * a[k + n / 2];\n      a[k] = x + y;\n      a[k + n / 2] = x - y;\n    }\n  }\n \n  void fft(vcd& a) {\n    int n = sz(a);\n    vcd na(n, cd(0, 0));\n    forn(i, n) na[i] = a[rev[i]];\n    na.swap(a);\n \n    fft_rec(&a[0], n);\n  }\n \n  void fft_inv(vcd& a) {\n    fft(a);\n    int n = sz(a);\n    reverse(a.begin() + 1, a.end());\n    forn(i, n) {\n      a[i] /= n;\n    }\n  }\n \n  vi mult(const vi& a, const vi& b) {\n    //    TimeStamp t(\"mult\");\n    vcd A(N, cd(0, 0));\n    vcd B(N, cd(0, 0));\n    forn(i, sz(a)) A[i] = a[i];\n    forn(i, sz(b)) B[i] = b[i];\n \n    fft(A);\n    fft(B);\n \n    forn(i, N) A[i] *= B[i];\n \n    fft_inv(A);\n \n    vi c(N, 0);\n    forn(i, N) c[i] = ((ll) (A[i].real() + 0.5)) % MOD;\n \n    return c;\n  }\n \n  vi multmod(const vi& a, const vi& b) {\n    // a = a0 + sqrt(MOD) * a1\n    // a = a0 + base * a1\n    int base = (int) sqrtl(MOD);\n \n    vi a0(sz(a)), a1(sz(a));\n    forn(i, sz(a)) {\n      a0[i] = a[i] % base;\n      a1[i] = a[i] / base;\n      assert(a[i] == a0[i] + base * a1[i]);\n    }\n \n    vi b0(sz(b)), b1(sz(b));\n    forn(i, sz(b)) {\n      b0[i] = b[i] % base;\n      b1[i] = b[i] / base;\n      assert(b[i] == b0[i] + base * b1[i]);\n    }\n \n    vi a01 = a0;\n    forn(i, sz(a)) {\n      addmod(a01[i], a1[i], MOD);\n    }\n \n    vi b01 = b0;\n    forn(i, sz(b)) {\n      addmod(b01[i], b1[i], MOD);\n    }\n \n    vi C = mult(a01, b01);  // 1\n \n    vi a0b0 = mult(a0, b0); // 2\n    vi a1b1 = mult(a1, b1); // 3\n \n    vi mid = C;\n    forn(i, N) {\n      addmod(mid[i], -a0b0[i] + MOD, MOD);\n      addmod(mid[i], -a1b1[i] + MOD, MOD);\n    }\n \n    vi res = a0b0;\n    forn(i, N) {\n      addmod(res[i], mulmod(base, mid[i], MOD), MOD);\n    }\n \n    base = mulmod(base, base, MOD);\n    forn(i, N) {\n      addmod(res[i], mulmod(base, a1b1[i], MOD), MOD);\n    }\n \n    return res;\n  }\n};\n\nint n, m, k;\n\nvoid read()\n{\n\tcin >> n >> m >> k;\n}\n\nvector<int> p1, p2, pw3;\n\nint pw(int x, int p)\n{\n\tint ret = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ret = (ret * 1ll * x) % mod;\n\t\tx = (x * 1ll * x) % mod;\n\t\tp >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint fact[MAXN], inv_fact[MAXN];\nint comb(int n, int k) { if(n < 0 || k < 0 || n < k) return 0; return (((fact[n] * 1ll * inv_fact[n - k]) % mod) * 1ll * inv_fact[k]) % mod; }\n\n/*   SUM C(n + i - 1, i) * C(n + i - 1 + j, j)   */\n/*   SUM C(n + i - 1, i) * fact[n + i - 1 + j] / (fact[j] * fact[n + i - 1])    */\n\n\nvoid solve()\n{\t\n\tpw3.assign(n + m + k + 1, 0);\n\tp1.assign(m + 1, 0);\n\tp2.assign(k + 1, 0);\n\tpw3[0] = 1; for(int i = 1; i <= m + k + n; i++) pw3[i] = (3ll * pw3[i - 1]) % mod;\n\tfact[0] = 1; for(int i = 1; i <= m + k + n; i++) fact[i] = (fact[i - 1] * 1ll * i) % mod;\n\tinv_fact[m + k + n] = pw(fact[m + k + n], mod - 2); for(int i = n + k + m - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * 1ll * (i + 1)) % mod; \n\n\tfor(int i = 0; i <= m; i++) p1[i] = (comb(n + i - 1, i) * 1ll * inv_fact[n + i - 1]) % mod;\n\tfor(int i = 0; i <= k; i++) p2[i] = inv_fact[i];\n\n\tprecalc(20);\n\tvector<int> ret = mult_mod(p1, p2);\n\t\n\tint answer = 0;\n\tfor(int i = 0; i < (int)ret.size(); i++)\n\t{\n\t\tif(m + k - i < 0) break;\n\t\tint curr = (ret[i] * 1ll * pw3[m + k - i]) % mod;\n\t\tcurr = (curr * 1ll * fact[n - 1 + i]) % mod;\n\t\taddmod(answer, curr, mod);\n\t}\n\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M,K;\nll mo=1000000007;\nll combi(ll N_, ll C_) {\n\tconst int NUM_=1000001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>K;\n\t\n\tll ret=0;\n\tfor(int i=N;i<=N+M+K;i++) {\n\t\tll a=combi(i-1,N-1)*modpow(3,N+M+K-i) % mo;\n\t\tFOR(x,M+1) {\n\t\t\ty=i-N-x;\n\t\t\tif(y>=0 && y<=K) ret += a*combi(i-N,x) % mo;\n\t\t}\n\t}\n\t\n\t\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,m,k;\nconst int FMAX = 1252521;\nll fact[FMAX];\nll ifact[FMAX];\nll tri[FMAX];\n\nll modpow(ll a,ll b,ll c){\n  ll r = 1;\n  while(b){\n    if(b&1)r=r*a%c;\n    a=a*a%c;\n    b>>=1;\n  }\n  return r;\n}\nll modinv(ll a,ll c){\n  return modpow(a,c-2,c);\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&m,&k);\n  // fact init\n  fact[0] = 1;\n  FOR(i,1,FMAX)fact[i]=fact[i-1]*i%MOD;\n  ifact[FMAX-1]=modinv(fact[FMAX-1],MOD);\n  FORR(i,0,FMAX-1)ifact[i]=ifact[i+1]*(i+1)%MOD;\n  // tri init\n  tri[0] = 1;\n  FOR(i,1,FMAX)tri[i]=tri[i-1]*3%MOD;\n  // a == n-1 && b <= m && c <= k\n  ll ans = 0;\n  int a = n-1;\n  ll bipow = 1;\n  ll subsum = 0;\n  int befbeg,befend;\n  FOR(s,0,m+k+1){\n    // c = s-b\n    // 0<=c<=k\n    // 0<=b<=m\n\n    // s-b>=0 -> b<=s\n    // s-b<=k -> b>=s-k\n    int abc = a+s;\n    int rest = n+m+k-abc-1;\n    ll unit = fact[abc]*ifact[a]%MOD*ifact[s]%MOD*tri[rest]%MOD;\n    ll add = 0;\n    int beg = max(s-k,0);\n    int end = min(s,m);\n    if(s>0){\n      bipow *= 2;\n      subsum *= 2;\n      if(befbeg+1==beg){\n        subsum += fact[s-1]*ifact[befbeg]%MOD*ifact[s-1-befbeg]%MOD;\n      }\n      if(befend==end){\n        subsum += fact[s-1]*ifact[befend]%MOD*ifact[s-1-befend]%MOD;\n      }\n      bipow %= MOD;\n      subsum %= MOD;\n    }\n    befbeg = beg;\n    befend = end;\n    ans += unit*(bipow+MOD-subsum)%MOD;\n    if(ans>=MOD)ans-=MOD;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nconst int MAXN = 1000005;\nconst int mod = 1e9 + 7;\n\nlint ipow(int x, int p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, m, k;\nlint fact[MAXN], invf[MAXN];\n\nlint bino(int x, int y){\n\treturn fact[x] * (invf[y] * invf[x - y] % mod) % mod;\n}\n\nint main(){\n\tfact[0] = invf[0] = 1;\n\tfor(int i=1; i<MAXN; i++){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tinvf[i] = ipow(fact[i], mod - 2);\n\t}\n\tcin >> n >> m >> k;\n\tlint func = 0;\n\tfor(int j=0; j<=k; j++){\n\t\tfunc += bino(n - 1 + j, j) * ipow(3, mod - 1 - j) % mod;\n\t\tfunc %= mod;\n\t}\n\tlint ret = func * ipow(3, m + k) % mod;\n\tfor(int i=1; i<=m; i++){\n\t\tlint aux = bino(n - 1 + i + k, k) * ipow(3, mod - 1 - k) % mod;\n\t\tfunc += mod - aux;\n\t\tfunc *= 3ll * (mod + 1) / 2;\n\t\tfunc += aux;\n\t\tfunc %= mod;\n\t\tlint base = ipow(3, m + k - i) * bino(n - 1 + i, i) % mod;\n\t\tret += base * func % mod;\n\t\tret %= mod;\n\t}\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e6 + 5;\nconst int mod = 1e9 + 7;\n\nlong long fac[N], inv[N];\n\nlong long C(int n, int k) {\n  if (k > n) return 0;\n  return (((fac[n] * inv[k]) % mod) * inv[n-k]) % mod;\n}\nlong long powmod(long long b, long long p) {\n  long long ret = 1;\n  while (p) {\n    if (p & 1)\n      ret = (ret * b) % mod;\n    b = (b * b) % mod;\n    p >>= 1;\n  }\n  return ret;\n}\n\nint main() {\n  fac[0] = inv[0] = 1;\n  for (int i = 1; i < N; i++) {\n    fac[i] = (fac[i-1] * i) % mod;\n    inv[i] = powmod(fac[i], mod - 2);\n  }\n  int n, m, k;\n  scanf(\"%d %d %d\", &n, &m, &k);\n  long long ans = 0;\n  long long cur = 1;\n  for (int i = 0; i <= m + k; i++) {\n    ans = (ans + (((C(n - 1 + i, i) * cur) % mod) * powmod(3, m + k - i)) % mod) % mod;\n    cur = (cur * 2) % mod;\n    if (i >= m)\n      cur = (cur + mod - C(i, m)) % mod;\n    if (i >= k)\n      cur = (cur + mod - C(i, k)) % mod;\n  }\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int Mod = 1e9 + 7;\nconst int N = 3e6 + 10;\n\nint n, m, k;\nLL pw2[N], pw3[N], fac[N], inv[N];\n\nLL Power(LL a, LL b) {\n\tLL c = 1;\n\tfor (; b; b >>= 1, (a *= a) %= Mod)\n\t\tif (b & 1)\n\t\t\t(c *= a) %= Mod;\n\treturn c;\n}\n\nvoid Init() {\n\tpw2[0] = pw3[0] = 1;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw2[i] = pw2[i - 1] * 2 % Mod;\n\t\tpw3[i] = pw3[i - 1] * 3 % Mod;\n\t\tfac[i] = fac[i - 1] * i % Mod;\n\t}\n\tinv[N - 1] = Power(fac[N - 1], Mod - 2);\n\tfor (int i = N - 2; i; --i)\n\t\tinv[i] = inv[i + 1] * (i + 1) % Mod;\n}\n\nLL Binom(int m, int n) {\n\tif (n > m)\n\t\treturn 0;\n\treturn fac[m] * inv[n] % Mod * inv[m - n] % Mod;\n}\n\nvoid Solve() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tLL fb = 0;\n\tLL fc = 0;\n\tLL ans = 0;\n\tfor (int i = n; i <= n + m + k; ++i) {\n\t\tLL cnt = Binom(i - 1, n - 1);\n\t\tif (i - n == m + 1) \n\t\t\tfb = 1;\n\t\telse if (i - n > m + 1) \n\t\t\tfb = (fb * 2 + Binom(i - n - 1, m)) % Mod;\n\t\tif (i - n == k + 1)\n\t\t\tfc = 1;\n\t\telse if (i - n > k + 1)\n\t\t\tfc = (fc * 2 + Binom(i - n - 1, k)) % Mod;\n\t\tLL f = (pw2[i - n] - fb + Mod - fc + Mod) % Mod;\n\t\t(ans += f * cnt % Mod * pw3[n + m + k - i]) %= Mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n\n\tInit();\n\tSolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define ld  double\n#define ll long long\n#define int long long\n\n\nusing namespace std;\n\nconst int MAXN = 301 * 1001  , MOD = 1e9 + 7 , sq = 333  ;\n\nint fact[MAXN] , inv[MAXN] ;\n\nint tv(int x , int y )\n{\n    if(!y)\n        return 1 ;\n    int ans = tv(x,y/2) ;\n    ans *= ans ;\n    ans %= MOD ;\n    if(y&1)\n        ans*=x ;\n    return ans % MOD ;\n}\n\nint C(int n , int k )\n{\n    if(k>n)\n        return 0 ;\n    return (fact[n]*inv[k]%MOD) * inv[n-k] % MOD ;\n}\n\nint32_t main()\n{\n   ios::sync_with_stdio(0);cin.tie(0);\n   inv[0] = fact[0] = 1;\n   for(int i = 1 ; i < MAXN ; i ++ )\n        fact[i] = i * fact[i-1] % MOD , inv[i] =tv(fact[i],MOD-2) ;\n   int n , m , k ;\n   cin >> n >> m >> k ;\n   int ans = 0 ;\n   for(int i = n ; i <= n + m + k ; i ++ )\n   {\n       int x = 0 ;\n       for(int j = max(0ll,i-n-k) ; j < min(i-n+1,m+1) ; j ++ )\n           x += C(i-n,j) , x %= MOD ;\n       // cout<<i<<' '<<x<<'\\n';\n        x *= C(i-1,n-1) ;\n        x %= MOD ;\n        x *= tv(3,n+m+k-i);\n        x %= MOD ;\n        ans = (ans+x) % MOD ;\n   }\n   cout<<ans ;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fac[600010], finv[600010], inv[600010]; \nlong long MOD = 1000000007;\nvoid COMinit(){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i = 2; i < 600005; i++){\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\nlong long COM(int n, int k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main(){\n\tint N, M, K; cin >> N >> M >> K;\n\tCOMinit(); \n\tlong long pow3[600010] = {}; \n\tpow3[0] = 1; \n\tfor(int i = 1; i < 600005; i++) pow3[i] = pow3[i-1] * 3 % MOD; \n\tlong long A[600010] = {}; \n\tlong long B[600010] = {}; \n\tA[0] = 1; \n\tfor(int i = 1; i <= M+K; i++){\n\t\tA[i] = ((A[i-1] * inv[i]) % MOD) * (N-1+i) % MOD; \n\t}\n\tB[0] = 1; \n\tfor(int i = 1; i <= M+K; i++){\n\t\tB[i] = B[i-1] * 2 % MOD;\n\t\tlong long mn = 0;  \n\t\tif(i > M){\n\t\t\tlong long tmp = (fac[i-1] * finv[i-1-M]) % MOD; \n\t\t\ttmp *= finv[M]; tmp %= MOD; mn += tmp;\n\t\t}\n\t\tif(i > K){\n\t\t\tlong long tmp = (fac[i-1] * finv[i-1-K]) % MOD; \n\t\t\ttmp *= finv[K]; tmp %= MOD; mn += tmp;\n\t\t}\n\t\tB[i] += MOD * 2 - mn; B[i] %= MOD; \n\t}\n\tlong long ans = 0; \n\tfor(int i = 0; i <= M+K; i++){\n\t\tans += (B[i] * pow3[M+K-i] % MOD) * A[i] % MOD; \n\t\tans %= MOD;\n\t}\n\tcout << ans << \"\\n\"; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1000005;\nconst int mod=1e9+7;\nlong long fac[maxn];\nlong long inv[maxn];\nlong long san[maxn];\nlong long two[maxn];\nvoid pre()\n{\n    fac[0]=fac[1]=1;\n    inv[1]=1;san[1]=3;san[0]=1;\n    two[0]=1;two[1]=2;\n    for(int i=2;i<maxn;i++)\n    {\n        two[i]=two[i-1]*2%mod;\n        san[i]=san[i-1]*3%mod;\n        fac[i]=fac[i-1]*i%mod;\n        inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n    }\n    inv[0]=1;\n    for(int i=2;i<maxn;i++)\n        inv[i]=inv[i-1]*inv[i]%mod;\n}\nint getc(int a,int b)\n{\n    if(b<0||b>a) return 0;\n    //printf(\"sss %lld %lld %d\\n\",fac[a],inv[b],b);\n    return fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\n\nint main()\n{\n    int n,m,k;\n    pre();\n    scanf(\"%d%d%d\",&n,&m,&k);\n    int tot=n+m+k;\n    if(m>k) swap(m,k);\n    long long ans=san[tot-n];\n    long long tmp=1;\n    for(int i=n+1;i<=tot;i++)\n    {\n        tmp=tmp*2%mod;\n        if(i-n>m){\n            tmp=tmp-getc(i-n-1,m);\n            if(tmp<0) tmp+=mod;\n        }\n        if(i-n>k){\n            tmp=tmp-getc(i-n-1,k);\n            if(tmp<0) tmp+=mod;\n        }\n        ans=ans+san[tot-i]*getc(i-1,n-1)%mod*tmp%mod;\n        //printf(\"%lld %lld %lld\\n\",ans,tmp,getc(i-1,n-1));\n    }\n    printf(\"%lld\\n\",ans%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define int long long\n\nusing namespace std;\ntypedef long long LL;\nconst int N=1000005;\nconst int MOD=1e9+7;\n\nint n,m,k,ans,fac[N],inv[N],sum;\n\ninline int fast_pow(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1){\n\t\tif(y&1) ret=1ll*ret*x%MOD;\n\t\tx=1ll*x*x%MOD;\n\t}\n\treturn ret;\n}\n\ninline int C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%MOD*inv[x-y]%MOD;\t\n}\n\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&m,&k);\n\tfac[0]=inv[0]=1; sum=n+m+k;\n\tfor(int i=1;i<=sum;i++) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[sum]=fast_pow(fac[sum],MOD-2);\n\tfor(int i=sum-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n//\tfor(int i=n;i<=sum;i++){\n//\t\tint now=0;\n//\t\tfor(int j=max(i-n-m,1ll*0);j<=min(k,i-n);j++)\n//\t\t\t(now+=C(i-n,j))%=MOD;\n//\t\tans+=now%MOD*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD;\n//\t\tans%=MOD;\n//\t}\n//\tcout<<ans<<endl; ans=0;\n\tif(m<k) swap(m,k); int now=1;\n\tfor(int i=n;i<=sum;i++){\n\t\tif(k+n>=i) {\n\t\t\t(ans+=1ll*C(i-1,n-1)*fast_pow(3,sum-i)%MOD*now%MOD)%=MOD;\n\t\t\tif(k+n!=i) now=now*2%MOD; \t\n\t\t}\n\t\telse if(n+m>=i) {\n\t\t\tnow=now*2-C(i-n-1,k);\n\t\t\tnow=(now%MOD+MOD)%MOD;\n\t\t\t(ans+=1ll*now*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n\t\t}\n\t\telse {\n\t\t\tnow=now*2-C(i-n-1,k); now=(now%MOD+MOD)%MOD;\n\t\t\tnow=(now-C(i-n-1,i-n-m-1)+MOD)%MOD;\n\t\t\t(ans+=1ll*now*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n\t\t}\n\t}\n//\tfor(int i=n;i<=sum;i++) {\n//\t\t(ans+=1ll*C(i-1,n-1)*fast_pow(2,i-n)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tif(i==8) cout<<ans<<endl;\n//\t\tif(n+k+1<=i) \n//\t\t\t(ans-=1ll*C(i-1,n-1)*C(i-n,k+1)%MOD*fast_pow(2,i-n-k-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tif(i==8) cout<<ans<<endl;\n//\t\tif(n+m+1<=i)\n//\t\t\t(ans-=1ll*C(i-1,n-1)*C(i-n,m+1)%MOD*fast_pow(2,i-n-m-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tcout<<ans<<endl;\n//\t}\n//\tfor(int i=n+m;i<sum;i++){\n//\t\t(ans-=1ll*now*fast_pow(3,sum-n-m)%MOD)%=MOD;\n//\t\tnow=1ll*now*i%MOD; now=(now+C(n+m,i-n-m+1))%MOD;\t\n//\t}\n//\tnow=1;\n//\tfor(int i=n+k;i<sum;i++){\n//\t\t(ans-=1ll*now*fast_pow(3,sum-n-k)%MOD)%=MOD;\n//\t\tnow=1ll*now*i%MOD; now=(now+C(n+k,i-n-k+1))%MOD;\n//\t}\t\n\tprintf(\"%lld\\n\",(ans+MOD)%MOD);\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long ll;\n\nconst int Mod = 1e9 + 7;\n\nint n, m, k;\n\nint fac[600005], ifac[600005];\n\nint qpow(int a, int x) {\n\tint res = 1;\n\tfor (; x > 0; x >>= 1) {\n\t\tif (x & 1) res = 1ll * res * a % Mod;\n\t\ta = 1ll * a * a % Mod;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tconst int lim = 6e5;\n\t\n\tfac[0] = 1;\n\tfor (int i = 1; i <= lim; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\t\n\tifac[lim] = qpow(fac[lim], Mod - 2);\n\tfor (int i = lim - 1; i >= 0; --i) ifac[i] = ifac[i + 1] * (i + 1ll) % Mod;\n}\n\nint C(int x, int y) {\n\treturn 1ll * fac[x] * ifac[y] % Mod * ifac[x - y] % Mod;\n}\n\nint main() {\n\tinit();\n\t\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\t\n\tint ans = 0;\n\tfor (int t = 0; t <= m + k; ++t) {\n\t\tans = (ans + 1ll * qpow(2, t) * qpow(3, m + k - t) % Mod * (C(n - 1 + t, n - 1))) % Mod;\n\t\t\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\n\nint n,m,k,Fac[900005],Inv[900005];\nconst int p=1000000007;\n\ninline ll C(const int n,const int m){return (ll)Fac[n]*Inv[m]%p*Inv[n-m]%p;}\ninline ll Pow(ll a,ll b,ll s=1){for(;b;b>>=1,a=a*a%p)if(b&1)s=s*a%p;return s%p;}\n\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&k),--n;\n    ll Sum=1,Ans=1;\n    for(int i=Fac[0]=1;i<=900000;++i)Fac[i]=(ll)Fac[i-1]*i%p;\n    Inv[900000]=Pow(Fac[900000],p-2);\n    for(int i=900000;i>=1;--i)Inv[i-1]=(ll)Inv[i]*i%p;\n    for(int i=1;i<=m+k;++i)\n    {\n        Sum=(Sum<<1)%p;\n        if(i>m)Sum=(Sum-C(i-1,m)+p)%p;\n        if(i>k)Sum=(Sum-C(i-1,k)+p)%p;\n        Ans=(Ans*3+C(n+i,i)*Sum)%p;\n    }\n    printf(\"%d\\n\",(int)Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define FORR(i,a,b) for (int i=(a);i>(b);i--)\n#define pb push_back\n\ntypedef long long ll;\nusing namespace std;\nint MOD = (1e9+7);\nconst int idxMax = (9e5+1);\nint powMod(int a, int n, int m){\n  ll pro = 1, tmp = a;\n  for(; n > 0; n >>= 1){\n    if(n & 1) pro = (pro * tmp) % m;\n    tmp = tmp * tmp % m;\n  }\n  if (pro < 0) cout << \"pro < 0\" << a << \",\" << n << endl;\n  return pro;\n}\n\nint A[idxMax], R[idxMax];\nint comb(int n, int c){\n  return int(ll(A[n + c]) * R[n] % MOD * R[c] % MOD);\n}\nmain(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int N, M, K;\n  cin >> N >> M >> K;\n\n  ll t = 1;\n  A[0] = 1;\n  FOR(i, 1, N + M + K + 1){\n    t = t * i % MOD;\n    A[i] = t;\n  }\n  t = powMod(t, MOD - 2, MOD);\n  R[N + M + K] = t;\n  FORR(i, N + K + M, -1){\n    R[i] = t;\n    t = t * i % MOD;\n  }\n  int sum = M + K;\n  ll pre = 1, p3 = powMod(3, sum, MOD), ret = p3, r3 = powMod(3, MOD - 2, MOD);\n  if(M > K) swap(M, K);\n\n  FOR(i, 1, sum + 1){\n    pre <<= 1;\n    p3 = p3 * r3 % MOD;\n    if(i > M){\n      pre += MOD - comb(M, i - M - 1);\n      if(i > K) pre += MOD - comb(K, i - K - 1);\n    }\n    pre %= MOD;\n    ret += pre * comb(N - 1, i) % MOD * p3 % MOD;\n    ret %= MOD;\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define md 1000000007\n#define C(x,y)(1ll*jc[y]*ny[x]%md*ny[(y)-(x)]%md)\nusing namespace std;\nint jc[1000001],ny[1000001];\nint pw(int x,int y){\n\tint ans=1;\n\tfor(int i=1;y;i<<=1,x=1ll*x*x%md)\n\t\tif(y&i)ans=1ll*x*ans%md,y-=i;\n\treturn ans;\n}\nint main(){\n\tint n,m,k,z;scanf(\"%d%d%d\",&n,&m,&k);z=n+m+k;\n\tfor(int i=jc[0]=1;i<=z;i++)jc[i]=1ll*i*jc[i-1]%md;\n\tny[z]=pw(jc[z],md-2);\n\tfor(int i=z;i;i--)ny[i-1]=1ll*i*ny[i]%md;\n\tint ans=0,o=1;\n\tfor(int i=n;i<=z;i++){\n\t\tans=(ans+C(n-1,i-1)*o%md*pw(3,z-i))%md;\n\t\to=(o+o)%md;\n\t\tif(i>=n+m)o=(o-C(m,i-n)+md)%md;\n\t\tif(i>=n+k)o=(o-C(i-n-k,i-n)+md)%md;\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <array>\n#include <list>\n#include <stack>\n#include <valarray>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef unsigned long long UInt;\n\nconst int INF = 1001001001;\nconst Int INFLL = 1001001001001001001LL;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\nint in() { int x; scanf(\"%d\", &x); return x; }\ndouble fin() { double x; scanf(\"%lf\", &x); return x; }\nInt lin() { Int x; scanf(\"%lld\", &x); return x; }\n\nconst Int MO = 1000000007;\nconst int MA = 1<<20;\nInt fact[MA], inv[MA], ifac[MA], p3[MA], i3[MA];\n\nint main() {\n  inv[1] = 1;\n  for (int i = 2; i < MA; ++i) {\n    inv[i] = MO - MO / i * inv[MO % i] % MO;\n  }\n\n  fact[0] = 1;\n  ifac[0] = 1;\n  p3[0] = 1;\n  i3[0] = 1;\n  for (int i = 1; i < MA; ++i) {\n    fact[i] = fact[i - 1] * i % MO;\n    ifac[i] = ifac[i - 1] * inv[i] % MO;\n    p3[i] = p3[i - 1] * 3 % MO;\n    i3[i] = i3[i - 1] * inv[3] % MO;\n  }\n\n  int N = in();\n  int M = in();\n  int K = in();\n  if (N + M + K <= 3000) {\n    Int res = 0;\n    for (int b = 0; b <= M; ++b) {\n      for (int c = 0; c <= K; ++c) {\n        res += fact[N - 1 + b + c] * ifac[b] % MO * ifac[c] % MO * ifac[N - 1] % MO * p3[M + K - b - c] % MO;\n        res %= MO;\n      }\n    }\n    printf(\"%lld\\n\", res);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 P = 1000000000ll + 7;\nint64 n,m,k;\nint64 fz[1000010],fm[1000010];\nint64 fb[1000010],fc[1000010];\nint64 mpow(int64 x, int64 y)\n{\n\tint64 tmp = x, ret = 1;\n\twhile(y)\n\t{\n\t\tif(y & 1) ret = ret * tmp % P;\n\t\ttmp = tmp * tmp % P;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\nint64 C(int x, int y)\n{\n\tif(x < y) return 0;\n\treturn fz[x] * fm[y] % P * fm[x - y] % P;\n}\nint main()\n{\n    cin >> n >> m >> k;\n    fz[0]=fm[0]=1;\n    for(int i = 1; i <= 1000000; i++)\n\t\tfz[i] = fz[i - 1] * i %P, fm[i] = mpow(fz[i], P - 2);\n\tint64 ans = 0;\n\tfor(int i = n; i < n + m + k + 1; i++)\n\t{\n\t\tint64 cnt = C(i - 1, n - 1);\n\t\tfb[i] = (fb[i - 1] * 2 % P + C(i - (n + 1), i - n - (m + 1))) % P;\n\t\tfc[i] = (fc[i - 1] * 2 % P + C(i - (n + 1), i - n - (k + 1))) % P;\n\t\tans = (ans + cnt * ((mpow(2, i - n) - (fb[i] + fc[i]) % P) % P + P) % P * mpow(3, n + m + k - i) % P) % P;\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n\ntemplate<unsigned MOD>  class ModInt {\npublic:\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline auto extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nconst int mod = 1000000007;\nusing mint = ModInt<mod>;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\nconst mint THREE = mint(3);\n\n\nvector<mint> Fact, InvFact;\nvoid makeFact(int n){\n\tFact = vector<mint>(n+1);\n\tFact[0] = mint(1);\n\trep(i,1,n+1) Fact[i] = mint(i) * Fact[i-1];\n\n\tInvFact = vector<mint>(n+1);\n\tInvFact[n] = mint(1) / Fact[n];\n\trrep(i,n) InvFact[i] = mint(i+1) * InvFact[i+1];\n}\n\nmint Factorial(int n){ return Fact[n];}\nmint InverseFactorial(int n){ return InvFact[n];}\nmint Permutation(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[k];}\nmint Combination(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[k] * InvFact[n-k];}\n\n#define error(args...) { vector<string> _debug = split(#args, ',');err(begin(_debug), args);}\n\nvector<string> split(const string& s, char c){\n\tvector<string> v;stringstream ss(s);string x;\n\twhile (getline(ss, x, c)) v.emplace_back(x);\n\treturn move(v);\n}\n\nvoid err(vector<string>::iterator it) {cerr << endl;}\ntemplate<typename T, typename... Args> void err(vector<string>::iterator it, T a,Args... args){\n\tcerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \" \",err(++it, args...);\n}\n\n\nint main(void){\n\tint n,m,k;\n\tcin >> n >> m >> k;\n\tconst int t = n + m + k;\n\tmakeFact(t);\n\n\tmint ans = ZERO;\n\tint cf = 0 , ct = 0;\n\tmint tmp = ONE;\n\n\trep(all,n,t+1){\n\t\tconst int val = all - n;\n\t\tint from = 0, to = val;\n\t\tchmin(to, m);\n\t\tchmax(from, val - k);\n\n\t\twhile (cf < from){\n\t\t\ttmp -= Combination(val,cf);\n\t\t\tcf++;\n\t\t}\n\n\t\twhile (to < ct){\n\t\t\ttmp -= Combination(val,ct);\n\t\t\tct--;\n\t\t}\n\n\t\tmint cur = ONE;\n\t\tcur *= THREE.power(t - all);\n\t\tcur *= Combination(all - 1, n - 1);\n\t\tcur *= tmp;\n\t\tans += cur;\n\n\t\ttmp *= TWO;\n\t\ttmp += Combination(val, cf - 1);\n\t\ttmp += Combination(val, ct + 1);\n\t\tct++;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\nconst int mod = 1e9 + 7;\nconst int MX = 910000;\nll inv[MX], f[MX], invf[MX], pw[MX];\nvoid calc(){\n\tpw[0] = 1;\n\trep(i, MX - 1) pw[i + 1] = pw[i] * 3 % mod;\n\tinv[0] = inv[1] = f[0] = f[1] = invf[0] = invf[1] = 1;\n\tfor (int i = 2; i < MX; i++){\n\t\tinv[i] = mod - mod / i * inv[mod % i] % mod;\n\t\tf[i] = f[i - 1] * i % mod;\n\t\tinvf[i] = invf[i - 1] * inv[i] % mod;\n\t}\n}\ninline ll C(ll n, ll k){\n\tif(k < 0 || k > n) return 0;\n\tassert(n < MX && k < MX);\n\treturn f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint main(){\n\tcalc();\n\tint a, b, c; cin >> a >> b >> c;\n\tll ans = 0;\n\tll sum = 1; int L = 0, R = 0;\n\trep(i, b + c + 1){\n\t\t/*\n\t\tll s = 0;\n\t\tfor(int j = max(0, i - c); j <= min(b, i); j++) s += C(i, j);\n\t\t*/\n\t\tif(i) sum *= 2;\n\t\tint l = max(0, i - c), r = min(b, i);\n\t\tsum += C(i - 1, L - 1);\n\t\tsum += mod - C(i - 1, R);\n\t\t\n\t\tif(l > L) sum += mod - C(i, L);\n\t\tif(r > R) sum += C(i, r);\n\t\t\n\t\tassert(l == L || L + 1 == l); assert(r == R || R + 1 == r);\n\t\t//dbg(l, r, L, R, sum, s); assert(s % mod == sum % mod);\n\t\t\n\t\tL = l; R = r;\n\t\tsum %= mod;\n\t\tans += sum * C(i + a - 1, i) % mod * pw[b + c - i] % mod;\n\t}\n\tcout << ans % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#pragma GCC optimize(\"Ofast,unroll-loops\")\n//#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace IntModulo\n{\n\tconst int mod = 1e9 + 7;\n\n\tinline int add(int x, int y, int m = mod)\n\t{\n\t\tif (x + y < m)\n\t\t\treturn x + y;\n\t\treturn x + y - m;\n\t}\n\n\tinline int sub(int x, int y, int m = mod)\n\t{\n\t\tif (x >= y)\n\t\t\treturn x - y;\n\t\treturn x - y + m;\n\t}\n\n\tinline int mult(int x, int y, int m = mod)\n\t{\n\t\treturn x * (LL) y % m;\n\t}\n\n\tinline int power(int x, int y, int m = mod)\n\t{\n\t\tint r = 1;\n\t\twhile(y)\n\t\t{\n\t\t\tif (y & 1)\n\t\t\t\tr = mult(r, x, m);\n\t\t\tx = mult(x, x, m);\n\t\t\ty >>= 1;\n\t\t}\n\t\t\n\t\treturn r;\n\t}\n\t\n\tinline int inverse(int x, int m = mod)\n\t{\n\t\treturn power(x, m - 2, m);\n\t}\n\t\n\tinline void ADD(int& x, int y, int m = mod)\n\t{\n\t\tx += y;\n\t\tif (x >= m) x -= m;\n\t}\n\t\n\tinline void SUB(int& x, int y, int m = mod)\n\t{\n\t\tx -= y;\n\t\tif (x < 0) x += m;\n\t}\n\t\n\tinline void MULT(int& x, int y, int m = mod)\n\t{\n\t\tx = (x * (LL) y) % m;\n\t}\n};\n\nnamespace Combinatorics\n{\n\tusing namespace IntModulo;\n\t\n\tconst int N = 1 << 19;\n\tint fact[N];\n\tint inv[N];\n\tint invFact[N];\n\tbool inited = false;\n\t\n\tinline int C(int n, int k) // binomial C(n, k)\n\t{\n\t\treturn n < k ? 0 : mult(fact[n], mult(invFact[k], invFact[n - k]));\n\t}\n\t\n\tinline int H(int n, int k) // number of solution x1 + .. + xn = k\n\t{\n\t\treturn C(n + k - 1, k);\n\t}\n\t\n\tvoid init()\n\t{\n\t\tdebug(Combinatorics::N);\n\t\tinited = true;\n\t\tinv[1] = 1;\n\t\tFOR(i, 2, N)\n\t\t\tinv[i] = mult(mod - mod / i, inv[mod % i]);\n\t\t\n\t\tinvFact[0] = fact[0] = 1;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tfact[i] = mult(i, fact[i - 1]);\n\t\t\tinvFact[i] = mult(invFact[i - 1], inv[i]);\n\t\t}\n\t}\t\n};\n\nusing namespace Combinatorics;\nconst int M = 1 << 20;\n__int128 a[M], b[M], c[M];\n\nnamespace Karatsuba\n{\n\t#pragma GCC optimize(\"Ofast,unroll-loops\")\n\t#pragma GCC target(\"avx,avx2,fma\")\n\n\ttemplate<int n, typename T>\n\tvoid mult(const T* __restrict A, const T* __restrict B, T* __restrict C)\n\t{\n\t\tif (n <= 64)\n\t\t{\n\t\t\tFOR(i, 0, n) FOR(j, 0, n) C[i + j] += A[i] * B[j];\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tconst int m = n >> 1;\n\t\tmult<m>(A + 0, B + 0, C);\n\t\tmult<m>(A + m, B + m, C + n);\n\t\t\n\t\talignas(64) T a[n], b[n], e[n] = {};\n\t\tFOR(i, 0, m) \n\t\t{\n\t\t\ta[i] = A[i] + A[i + m];\n\t\t\tb[i] = B[i] + B[i + m];\n\t\t}\n\t\t\n\t\tmult<m>(a, b, e);\n\t\tFOR(i, 0, m)\n\t\t{\n\t\t\tconst T tut = C[i + m];\n\t\t\tC[i + m] += e[i] - C[i] - C[i + m * 2];\n\t\t\tC[i + m * 2] += e[i + m] - tut - C[i + m * 3];\n\t\t}\n\t}\n};\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tCombinatorics::init();\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tn--;\n\tint ans = 0;\n\tFOR(i, 0, m + 1) a[i] = invFact[i];\n\tFOR(i, 0, k + 1) b[i] = invFact[i];\n\tKaratsuba::mult<(1 << 17)>(a, b, c);\n\t\t\n\tFOR(t, 0, m + k + 1)\t\t\n\t\tADD(ans, mult(fact[t], mult(c[t] % mod, mult(C(n + t, t), power(3, m + k - t)))));\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define SF scanf\n#define PF printf\n#define MAXN 900010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nll inv[MAXN],fac[MAXN],pow3[MAXN];\nll fsp(ll x,int y){\n    ll res=1;\n    while(y){\n        if(y&1)\n            res=res*x%MOD;\n        x=x*x%MOD;\n        y>>=1;  \n    }\n    return res;\n}\nll C(int x,int y){\n    return fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nint main(){\n    pow3[0]=1;\n    fac[0]=1;\n    for(int i=1;i<=900000;i++){\n        pow3[i]=pow3[i-1]*3ll%MOD;  \n        fac[i]=fac[i-1]*i%MOD;\n    }\n    inv[900000]=fsp(fac[900000],MOD-2);   \n    for(int i=900000;i>0;i--)\n        inv[i-1]=inv[i]*i%MOD;\n    int n,m,k;\n    while(SF(\"%d%d%d\",&n,&m,&k)){\n\t    n--;\n\t    if(m<k)\n\t        swap(m,k);\n\t    ll j=1,ans=0;\n\t    for(int i=0;i<=m+k;i++){\n\t        ans=(ans+C(n+i,n)*pow3[m+k-i]%MOD*j)%MOD;   \n\t        if(i<k)\n\t            j=j*2ll%MOD;\n\t        else if(i<m)\n\t            j=(j*2ll-C(i,k))%MOD;\n\t        else    \n\t            j=(j*2ll-C(i,k)-C(i,m))%MOD;\n\t    }\n\t    ans=(ans+MOD)%MOD;\n\t    PF(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y>a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[1200511],re[1001011];\nlong long l[1000101];\nint j[1];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[3331];\n\nP u[1];\nqueue<int> q;\n//stack<int> s;\nset<int> s;\nmap<long long,int> p;\n\nvector<int> v[1];\n\nbool as(P a,P b)\n{\n  //if(a.x!=b.x)\n  //return a.x<b.x;\n  return a.x<b.x;\n}\n\nlong long po(long long x,long long y)\n{\n  long long p=1;\n  for(;y;x*=x,x%=mod,y/=2)\n    if(y%2)p*=x,p%=mod;\n  return p;\n}\n\nlong long f(int n,int m)\n{\n  if(n<m) return 0;\n  return o[n]*re[m]%mod*re[n-m]%mod;\n}\n\nint main()\n{\n  o[0]=re[0]=l[0]=1;\n  for(int t=1;t<=1000000;t++)\n    o[t]=o[t-1]*t%mod,l[t]=l[t-1]*3%mod,re[t]=po(o[t],mod-2);\n  scanf(\"%d %d %d\",&a,&b,&c);\n  if(b>c) swap(b,c);\n  y=1;\n  x=l[b+c];\n  for(int t=1;t<=b+c;t++)\n  {\n    if(t<=b) y*=2,y%=mod,x+=f(a+t-1,a-1)*y%mod*l[b+c-t]%mod;\n    else if(t<=c)\n    {\n      y=y*2-f(t-1,b)+mod;\n      y%=mod;\n      x+=f(a+t-1,a-1)*y%mod*l[b+c-t]%mod;\n    }\n    else\n    {\n      y=y*2-f(t-1,b)-f(t-1,c)+mod*2;\n      y%=mod;\n      x+=f(a+t-1,a-1)*y%mod*l[b+c-t]%mod;\n    }\n    x%=mod;\n    //printf(\"%lld %lld\\n\",x,y);\n  }\n  printf(\"%lld\",x);\n}\n//0\n//13\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 1700000;\nstring s;\nint f[N], invf[N], a[N];\nint binpow(int x, int y){\n    int res = 1;\n    while(y){\n        if (y % 2) res = res * x % mod;\n        x = x * x % mod;\n        y /= 2;\n    }\n    return res;\n}\nint c(int n, int k){\n    if (k > n) return 0;\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n, m, k;\n    cin >> n >> m >> k;\n    f[0] = 1;\n    invf[0] = 1;\n    for (int i = 1; i <= n + m + k; i++){\n        f[i] = f[i - 1] * i % mod;\n        invf[i] = binpow(f[i], mod -  2);\n    }\n    a[0] = 1;\n    for (int i = 1; i <= n + m + k; i++){\n        a[i] = (2 * a[i - 1] - c(i - 1, m) - c(i - 1, k) + mod + mod) % mod;\n        if (a[i] == 0) break;\n    }\n    int ans = 0;\n    for (int i = n; i <= n + m + k; i++){\n        int x = c(i - 1, n - 1) * binpow(3, n + m + k - i) % mod;\n        ans = (ans + x * a[i - n]) % mod;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e7+5;\ntypedef long long LL;\nconst LL mo=1e9+7;\nLL fac[maxn],inv[maxn];\nLL C(int n,int m){\n\tif(n<m)return 0;\n\treturn fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nLL pw(LL x,LL k,LL p=::mo){\n\tLL ans=1;\n\tfor(;k;k>>=1){\n\t\tif(k&1)ans=ans*x%mo;\n\t\tx=x*x%mo;\n\t}\n\treturn ans;\n}\nint main(){\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<maxn;i++){\n\t\tfac[i]=fac[i-1]*i%mo;\n\t}\n\tfor(int i=2;i<maxn;i++){\n\t\tinv[i]=(mo-mo/i)*inv[mo%i]%mo;\n\t}\n\tfor(int i=2;i<maxn;i++){\n\t\tinv[i]=inv[i-1]*inv[i]%mo;\n\t}\n\n\tLL ans=0;\n\n\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tif(m>k)swap(m,k);\n\n\n//\tlong long ans=0;\n/*\tfor(int i=0;i<=m;i++)\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tans+=C(n+i+j-1,n-1)*C(i+j,i)*pw(3,m+k-i-j);\n\t\t}\n\tcout<<ans<<endl;\n\n\tfor(int i=0;i<=m+k;i++)\n\t\tfor(int j=0;j<=k&&j<=m;j++){\n\t\t\tans+=C(n+i-1,n-1)*C(i,j)*pw(3,m+k-i);\n\t\t}\n\tcout<<ansi<<endl;\n\treturn 0;*/\n\tLL cur=1;\n\tfor(int p=0;p<=m+k;p++){\n\t\tLL res=0;\n\t\t\n\t\tres=C(n+p-1,n-1)*pw(3,m+k-p)%mo;\n\n\t\tans+=res*cur%mo;\n\t\tans%=mo;\n\n\t\tcur=cur*2%mo;\n\t\tif(p>=m){\n\t\t\tcur-=C(p,m);\n\t\t\tcur+=mo;cur%=mo;\n\t\t}\n\t\tif(p>=k){\n\t\t\tcur-=C(p,p-k);\n\t\t\tcur+=mo;cur%=mo;\n\t\t}\n\n\n\t}\n\n\tcout<<ans<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define tam 1000000\n#define offset 50000\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<ll,ii> iii;\nconst ll MOD=1e9+7;\nll pot(ll base,ll exp)\n{\n    base%=MOD;\n    ll res=1;\n    while(exp>0)\n    {\n        if (exp&1)\n            res*=base,res%=MOD;\n        base*=base;base%=MOD;\n        exp/=2;\n    }\n    return res;\n}\nll F[tam],Finv[tam];\nll C(ll n,ll m)\n{\n    if (n<0|| m<0|| m>n)\n        return 0;\n    ll aux=F[n];\n    aux*=Finv[m];aux%=MOD;\n    aux*=Finv[n-m];aux%=MOD;\n    return aux;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);cin.tie(0);\n    F[0]=Finv[0]=1;\n    forr(i,1,tam)\n    {\n        F[i]=F[i-1]*i,F[i]%=MOD;\n        Finv[i]=Finv[i-1]*pot(i,MOD-2),Finv[i]%=MOD;\n    }\n    //cout<<C(5,3)<<endl;\n    int n,m,k;\n    cin>>n>>m>>k;\n    int s=m+k;\n    int iz,der;\n    iz=der=k;\n    ll val=C(s,k);//aca\n    ll answer=val*C(n-1+s,s),totpar;answer%=MOD;\n    //cout<<val<<\" \"<<answer<<endl;\n    //cout<<endl;\n    for(int i=s-1;i>=0;i--)\n    {\n        iz--;\n        val+=C(i,iz);\n        val+=C(i,der);val%=MOD;\n        val*=pot(2,MOD-2);val%=MOD;\n        //val\n        totpar=C(n-1+i,i)*val;totpar%=MOD;\n        totpar*=pot(3,s-i);totpar%=MOD;\n        //cout<<val<<\" \"<<totpar<<endl;\n        answer+=totpar;\n        answer%=MOD;\n    }\n    cout<<answer<<endl;\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#include <iostream>\nusing namespace std;\n#define N 2000005\n#define ll long long\n#define mod 1000000007\nint fac[N],inv[N],t[N],a,b,c,mx,ans;\nint q_pow(int x,int n){int ret=1;for(;n;n>>=1,x=(ll)x*x%mod)if(n&1)ret=(ll)ret*x%mod;return ret;}\nint C(int n,int m){return (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\t// freopen(\"8102.in\",\"r\",stdin);\n\t// freopen(\"8102.out\",\"w\",stdout);\n\tmx=2000000;t[0]=fac[0]=1;\n\tfor(int i=1;i<=mx;i++)fac[i]=(ll)i*fac[i-1]%mod,t[i]=(ll)t[i-1]*3%mod;inv[mx]=q_pow(fac[mx],mod-2);\n\tfor(int i=mx;i;i--)inv[i-1]=(ll)inv[i]*i%mod;\n\t// int T;scanf(\"%d\",&T);\n\t// while(T--)\n\t// {\n\tscanf(\"%d%d%d\",&a,&b,&c);ans=0;int rb=0,rc=0;\n\tfor(int i=0;i<=b+c;i++)\n\t{\n\t\tint tmp=(ll)t[b+c-i]*fac[a+i-1]%mod,w=q_pow(2,i);\n\t\tif(i>b)\n\t\t{\n\t\t\trb=(rb*2)%mod;\n\t\t\trb=(rb+C(i-1,b))%mod;\n\t\t\tw=(w-rb)%mod;\n\t\t}\n\t\tif(i>c)\n\t\t{\n\t\t\trc=(rc*2)%mod;\n\t\t\trc=(rc+C(i-1,c))%mod;\n\t\t\tw=(w-rc)%mod;\n\t\t}\n\t\tw=((ll)w*inv[i])%mod;\n\t\tans=(ans+(ll)w*tmp)%mod;\n\t}\n\tprintf(\"%lld\\n\",(ll)ans*inv[a-1]%mod);\n\t// }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n#define MAX_N 400000\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\nmod three[MAX_N];\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    three[0] = 1;\n    three[1] = 3;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n        three[i] = three[i-1]*3;\n    }\n}\nint main(){\n    make();    \n    int n,m,k;\n    cin >> n >> m >> k;\n    mod sm = 0;\n    \n    rep(i,m+1){\n        rep(j,k+1){\n            sm += fac[n-1+i+j]*finv[i]*finv[j]*three[m-i]*three[k-j];\n        }\n    }\n    cout << sm*finv[n-1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 P = 1000000000ll + 7;\nint64 n,m,k;\nint64 fz[600010],fm[600010];\nint64 fb[600010],fc[600010];\nint64 mpow(int64 x, int64 y)\n{\n\tint64 tmp = x, ret = 1;\n\twhile(y)\n\t{\n\t\tif(y & 1) ret = ret * tmp % P;\n\t\ttmp = tmp * tmp % P;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\nint64 C(int x, int y)\n{\n\tif(x < y) return 0;\n\treturn fz[x] * fm[y] % P * fm[x - y] % P;\n}\nint main()\n{\n    cin >> n >> m >> k;\n    fz[0]=fm[0]=1;\n    for(int i = 1; i <= 600000; i++)\n\t\tfz[i] = fz[i - 1] * i %P, fm[i] = mpow(fz[i], P - 2);\n\tint64 ans = 0;\n\tfor(int i = n; i < n + m + k + 1; i++)\n\t{\n\t\tint64 cnt = C(i - 1, n - 1);\n\t\tfb[i] = (fb[i - 1] * 2 % P + C(i - (n + 1), i - n - (m + 1))) % P;\n\t\tfc[i] = (fc[i - 1] * 2 % P + C(i - (n + 1), i - n - (k + 1))) % P;\n\t\tans = (ans + cnt * ((mpow(2, i - n) - (fb[i] + fc[i]) % P) % P + P) % P * mpow(3, n + m + k - i) % P) % P;\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\ntypedef long long ll;\n#define ri register int\nconst int N=9e5+5,mod=1e9+7;\nint power[N],fac[N],ifac[N];\ninline int C(ri n,ri m){\n\treturn m<0||n<m?0:(ll)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1) ans=(ll)ans*a%mod;\n\treturn ans;\n}\nint main(){\n\tri n,m,k,i,cnt,x,ans;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tcnt=n+m+k;\n\tfac[0]=power[0]=1;\n\tfor(i=1;i<=cnt;++i)\n\t\tfac[i]=(ll)fac[i-1]*i%mod,\n\t\tpower[i]=power[i-1]*3ll%mod;\n\tifac[cnt]=fpow(fac[cnt],mod-2);\n\tfor(i=cnt;i;--i)\n\t\tifac[i-1]=(ll)ifac[i]*i%mod;\n\tx=1;\n\tans=0;\n\tif(k>m) std::swap(k,m);\n\tfor(i=0;i<=m+k;++i){\n\t\tans=(ans+(ll)C(i+n-1,i)*power[m+k-i]%mod*x)%mod;\n\t\tif(i<k) x=x*2%mod;\n\t\telse if(i<m) x=(x*2ll-C(i,k))%mod;\n\t\telse x=(x*2ll-C(i,k)-C(i,i-m))%mod;\n\t}\n\tans=(ans+mod)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nconst int MAXN = 6e5 + 10 , MOD = 1e9 + 7;\nint fac[MAXN] , ifac[MAXN] , f3[MAXN];\nvoid init(){\n\tfac[0] = fac[1] = 1;\n\tfor(int i = 2 ; i < MAXN ; ++ i)\n\t\tfac[i] = 1ll * fac[i - 1] * i % MOD;\n\tifac[0] = ifac[1] = 1;\n\tfor(int i = 2 ; i < MAXN ; ++ i)\n\t\tifac[i] = MOD - 1ll * ifac[MOD % i] * (MOD / i) % MOD;\n\tfor(int i = 2 ; i < MAXN ; ++ i)\n\t\tifac[i] = 1ll * ifac[i - 1] * ifac[i] % MOD;\n\tf3[0] = 1;\n\tfor(int i = 1 ; i < MAXN ; ++ i)\n\t\tf3[i] = 1ll * f3[i - 1] * 3 % MOD;\n}\n\nint C(int a , int b){\n\tif(b < 0 || b > a) return 0;\n\treturn 1ll * fac[a] * ifac[b] % MOD * ifac[a - b] % MOD;\n}\nint n , m , k;\nint main(){\n\tinit();\n\tcin >> n >> m >> k;\n\tint ans = 0 , last = 1 , st = 0 , ed = 0;\n\tfor(int i = 0 ; i <= m + k ; ++ i){\n\t\tans = (ans + 1ll * last * f3[m + k - i] % MOD * C(n + i - 1 , n - 1)) % MOD;\n\t\tlast = 2ll * last % MOD;\n\t\tlast = (last + C(i , st - 1)) % MOD;\n\t\tlast = (last + MOD - C(i , ed)) % MOD;\n\t\tif(i - st >= m){\n\t\t\tlast = (last + MOD - C(i + 1 , st)) % MOD;\n\t\t\tst ++;\n\t\t}\n\t\tif(ed < k){\n\t\t\ted ++;\n\t\t\tlast = (last + C(i + 1 , ed)) % MOD;\n\t\t} \n\t\tif(st > ed) break;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> ii;\ntypedef pair<ii , ii> iiii;\n#define fi first\n#define se second\nint h , w , n;\nii p[100005];\nint ct[10];\nmap<ii,int> check;\nmap<ii ,int> mp;\nsigned main(){\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> h >> w >> n;\n\tfor(int i = 1 ; i <= n ; ++i) cin >> p[i].fi >> p[i].se, mp[p[i]] = 1;\n\tfor(int k = 1 ; k <= n ; ++k)\n\t{\n\t\tfor(int x = max(p[k].fi - 2LL, 2LL); x <= min(p[k].fi + 2LL,h - 1LL) ; ++x)\n\t\t{\n\t\t\tfor(int y = max(p[k].se - 2LL, 2LL) ; y <= min(p[k].se + 2LL, w - 1LL) ; ++y)\n\t\t\t{\n\t\t\t\tii q; q.fi = x; q.se = y;\n\t\t\t\tif(check[q] == 0)\n\t\t\t\t{\n\t\t\t\t\tcheck[q] = 1;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int i = -1 ; i <= 1 ; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int j = -1 ; j <= 1 ; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tii t; t.fi = x + i; t.se = y + j;\n\t\t\t\t\t\t\tif(mp[t] == 1) ++cnt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++ct[cnt];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor(int i = 1 ; i <= 9 ; ++i) sum += ct[i];\n\tcout << (h - 2) * (w - 2) - sum << \" \";\n\tfor(int i = 1 ; i <= 9 ; ++i) cout << ct[i] << \" \";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define N 900010\ntypedef long long ll;\n\nconst ll Mod=1e9+7;\n\nint n,m,K;\nll Pre[N],Inv[N],Pre_inv[N],Pow[N];\n\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nvoid Prepare()\n{\n    Inv[1]=1;Inv[0]=1;\n    for(int i=2;i<=900000;i++)\n        Inv[i]=(Mod-Mod/i)*Inv[Mod%i]%Mod;\n    Pre[0]=1;Pre_inv[0]=1;\n    for(int i=1;i<=900000;i++)\n        Pre[i]=Pre[i-1]*i%Mod,Pre_inv[i]=Pre_inv[i-1]*Inv[i]%Mod;\n    Pow[0]=1;\n    for(int i=1;i<=900000;i++)\n        Pow[i]=Pow[i-1]*3%Mod;\n}\n\nll Cal(int a,int b)\n{\n    return Pre[a]*Pre_inv[b]%Mod*Pre_inv[a-b]%Mod;\n}\n\nint main()\n{\n    Prepare();\n    n=read();m=read();K=read();\n    ll qwer=1,Ans=0;\n    for(int i=0;i<=m+K;i++)\n    {\n        ll now=Cal(n+i-1,i)*qwer%Mod*Pow[m+K-i]%Mod;\n        Ans=(Ans+now)%Mod;\n        qwer=qwer*2%Mod;\n        if(i+1>K)\n            qwer-=Cal(i,K);\n        if(i+1>m)\n            qwer-=Cal(i,m);\n        qwer=(qwer%Mod+Mod)%Mod;\n    }\n    cout<<Ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\n#define N 5010\n#define ll long long\nconst int mod = 1e9 + 7 ;\n\nint c[ N ][ N ] , n , m , k ;\n//从i个中取j个 \nll fac[ N ] , ifac[ N ] ;\n\nll power( ll a ,ll b ) {\n\tll base = a , ans = 1 ;\n\twhile( b ) {\n\t\tif( b&1 )  ans = ( ans * base ) % mod ;\n\t\tbase = ( base * base ) % mod ;\n\t\tb >>= 1 ;\n\t}\n\treturn ans ;\n}\nll mul( ll x ,ll y ) {\n\treturn ( 1ll * x * y ) % mod ;\n}\n\nll inv( ll x ) {\n\treturn power( x , mod - 2 ) % mod ;\n}\n\nint main() {\n\tscanf( \"%d%d%d\" , &n , &m , &k ) ;\n\t\n\tfac[ 0 ] = 1 ;\n\tfor( int i = 1 ; i < N ; i ++ ) fac[ i ] = mul( fac[ i - 1 ] , i ) ;\n\tfor( int i = 0 ; i < N ; i ++ ) ifac[ i ] = inv( fac[ i ] ) ;\n\t\n\t/*\n\tc[ 0 ][ 0 ] = c[ 1 ][ 0 ] = c[ 1 ][ 1 ] = 1 ;\n\tfor( int i = 2 ; i <= n + k + m ; i ++ ) {\n\t\tc[ i ][ 0 ] = c[ i ][ i ] = 1 ;\n\t\tfor( int j = 1 ; j < i ; j ++ ) {\n\t\t\tc[ i ][ j ] = ( c[ i - 1 ][ j - 1 ] + c[ i ][ j - 1 ] ) % mod ;\n\t\t}\n\t}\n\t*/\n\t\n\tll ans = 0 , sum = n + k + m ;\n\t\n\t/*\n\tfor( int i = 0 ; i < m + k ; i ++ ) {\n\t\tans = ( ans + 1ll * c[ n + i - 1 ][ n - 1 ] * p[ m + k - i ] ) % mod ;\n\t\tif( i < m && i < k ) {\n\t\t\tll res = 0 ;\n\t\t\tfor( int j = 0 ; j < m ; j ++ ) {\n\t\t\t\tif( j > k ) break ;\n\t\t\t\tres = ( res + c[ i ][ j ] ) % mod ;\n\t\t\t}\n\t\t\tans = ( 1ll * ans * res ) % mod ;\n\t\t}else break ;\n\t}\n\t*/\n\t\n\tfor( int i = n ; i <= sum; i ++ ) {// 取出n张A牌 \n\t\tfor( int j = 0 ; j <= m ;j ++ ) {//B牌数量 \n\t\t\tint C = i - n - j ;//C牌数量 \n\t\t\tif( C < 0 || C > k ) continue ;\n\t\t\tll tmp = mul( fac[ i - 1 ] , mul( ifac[ n - 1 ] , mul( ifac[ j ] ,ifac[ C ] ) ) ) ;\n\t\t\ttmp = mul( tmp , power( 3 , sum - i ) ) ;\n\t\t\tans = ( ans + tmp ) % mod ;\n\t\t}\n\t}\n\tprintf( \"%lld\\n\" , ans ) ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n\treturn ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n\treturn ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n\tint ans = 1 , base = a ;\n\twhile( b ) {\n\t\tif( b&1 ) ans = mul( ans , base ) ;\n\t\tbase = mul( base , base ) ; \n\t\tb >>= 1 ;\n\t}\n\treturn ans ;\n}\n\nll inv( ll x ) {\n\treturn power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n\treturn ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n\tscanf( \"%d%d%d\" , &n , &m , &k ) ;\n\tfac[ 0 ] = 1ll ;\n\tp[ 0 ] = 1ll ;\n\tfor( int i = 1 ; i < N ; i ++ ) {\n\t\tfac[ i ] = fac[ i - 1 ] * i % mod ;\n\t\tp[ i ] = p[ i - 1 ] * 3ll % mod ;\n\t}\n\tfor( int i = 0 ; i < N ; i ++ ) {\n\t\tifac[ i ] = inv( fac[ i ] ) ;\n\t}\n\tll ans = 0 , x = 1ll ;\n\tn -- ;\n\tif( m < k ) swap( m , k ) ;\n\tfor( int i = 0 ; i <= m + k ; i ++ ) {\n\t\tans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n\t\t/*\n\t\tfor( int j = 0 ; j < m ; j ++ ) {\n\t\t\tif( j > i || i - j >= k ) break ;\n\t\t\tx = add( x , C( i , j ) ) ;\n\t\t}\n\t\t*/\n\t\tif( i < k ) x = ( x * 2ll ) % mod ;\n\t\telse if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n\t\telse  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n\t}\n\tprintf( \"%lld\\n\" , add( ans , mod ) ) ;\n\treturn 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n#define MOD 1000000007\n#define MAX_P 1000005\nInt fact[MAX_P],inv[MAX_P],finv[MAX_P];;\nInt extgcd(Int a,Int b,Int& x,Int& y){\n  Int d=a;\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }else{\n    x=1;y=0;\n  }\n  return d;\n}\nInt mod_inverse(Int a,Int mod){\n  Int x,y;\n  extgcd(a,mod,x,y);\n  return (mod+x%mod)%mod;\n}\n\nInt mod_pow(Int x,Int n,Int mod){\n  Int res=1;\n  while(n){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\n\nInt mod_inverse2(Int a,Int mod){\n  return mod_pow(a,mod-2,mod);\n}\n\nvoid init(Int mod){\n  fact[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n\n  inv[1]=1;\n  for(Int i=2;i<MAX_P;i++)\n    inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n  \n  finv[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    finv[i]=finv[i-1]*inv[i]%mod;\n}\n\nInt mod_fact(Int n,Int mod,Int& e){\n  e=0;\n  if(n==0) return 1;\n  Int res=mod_fact(n/mod,mod,e);\n  e+=n/mod;\n  if(n/mod%2!=0)return res*(mod-fact[n%mod]) %mod;\n  return res*fact[n%mod]%mod;\n}\n\nInt mod_comb(Int n,Int k,Int mod){\n  if(n==k||k==0) return 1;\n  Int e1,e2,e3;\n  Int a1=mod_fact(n,mod,e1),a2=mod_fact(k,mod,e2),a3=mod_fact(n-k,mod,e3);\n  if(e1>e2+e3) return 0;\n  return a1*mod_inverse(a2*a3%mod,mod)%mod;\n}\n\nInt mod_comb2(Int n,Int k,Int mod){\n  Int res=1;\n  for(Int i=0;i<k;i++){\n    res*=(n-i)%mod;\n    res%=mod;\n    res*=mod_inverse(i+1,mod);\n    res%=mod;\n  }\n  return res;\n}\n\n//only for prime mod\nInt mod_comb3(Int n,Int k,Int mod){\n  if(k<0||k>n) return 0;\n  return fact[n]*finv[k]%mod*finv[n-k]%mod;\n}\n\n\n//INSERT ABOVE HERE\nsigned main(){\n  init(MOD);\n  Int n,m,k;\n  cin>>n>>m>>k;\n  Int s=n+m+k;\n  vector<Int> po(s+1,1);\n  for(Int i=0;i<s;i++) po[i+1]=po[i]*3%MOD;\n  \n  vector<Int> dp(s+1,0);\n  dp[0]=1;\n  for(Int i=0;i<s;i++){\n    dp[i+1]+=dp[i]+MOD-mod_comb3(i,m,MOD);\n    dp[i+1]+=dp[i]+MOD-mod_comb3(i,k,MOD);\n    dp[i+1]%=MOD;\n  }\n  \n  Int ans=0;\n  for(Int i=n;i<=s;i++){\n    Int res=mod_comb3(i-1,n-1,MOD);\n    res=res*po[s-i]%MOD;\n    res=res*dp[i-n]%MOD;\n    ans+=res;\n    ans%=MOD;\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nvector<lint> zyo,rz,z3;\nlint mo=1000000007;\nlint dp[252521];\nlint extgcd(lint a, lint b, lint &x, lint &y) {\n  lint g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nlint invMod(lint a, lint m) {\n  lint x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;return 0;\n}\nlint cal(int a,int b){\n\treturn ((zyo[a+b]*rz[a])%mo*rz[b])%mo;\n}\nint main()\n{\n\tint n,m,k;lint out=0;\n\tcin>>n>>m>>k;\n\tzyo.pb(1);rep(i,364364) zyo.pb((zyo[i]*(i+1))%mo);\n\trep(i,364364) rz.pb(invMod(zyo[i],mo));\n\tz3.pb(1);rep(i,364364) z3.pb((z3[i]*3)%mo);\n\tdp[0]=1;\n\trep(i,m+k){\n\t\tdp[i+1]=dp[i]*2;\n\t\tif(i>=m) dp[i+1]-=cal(m,i-m);\n\t\tif(i>=k) dp[i+1]-=cal(k,i-k);\n\t\tdp[i+1]%=mo;if(dp[i+1]<0) dp[i+1]+=mo;\n\t}\n\trep(i,m+k+1){\n\t\t//cout<<i<<' '<<dp[i]<<' '<<cal(i,n-1)<<' '<<z3[m+k-i]<<endl;\n\t\tout+=(dp[i]*cal(i,n-1))%mo*z3[m+k-i];\n\t\tout%=mo;\n\t}\n\tcout<<out%mo<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD = 1000000007ll;\n\n\nll modSum(ll a, ll b) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\nll getInverse(ll x) {\n  return getPowMod(x, MOD-2);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, M, K;\n\n\nvoid input() {\n  cin >> N >> M >> K;\n  // We require M <= K\n  if (M > K) {\n    swap(M, K);\n  }\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n  ll ans = 0;\n  ll v1 = 1, v2 = 1, tmp1 = 1, tmp2 = 1;\n  for (int len = N ; len <= N+M+K ; len++) {\n    cerr << \"Len = \" << len << \"\\n\";\n    int bad = len - N;\n    if (len == N) {\n      v1 = 1;\n    } else {\n      v1 = modSum(v1, v1);\n    }\n    if (bad-1 >= M) {\n      if (bad-1 > M) {\n        tmp1 = modProd(tmp1, modProd(bad-1, getInverse(bad-1-M)));\n      }\n      v1 = modSubtract(v1, tmp1);\n    }\n    if (bad-1 >= K) {\n      if (bad-1 > K) {\n        tmp2 = modProd(tmp2, modProd(bad-1, getInverse(bad-1-K)));\n      }\n      v1 = modSubtract(v1, tmp2);\n    }\n    if (len > N) {\n      v2 = modProd(v2, modProd(len-1, getInverse(len-1-(N-1))));\n    }\n    ll mul = v1;\n    mul = modProd(mul, v2);\n    mul = modProd(mul, getPowMod(3, N+M+K-len));\n    ans = modSum(ans, mul);\n    /* \n    cerr << \"tmp1 = \" << tmp1 << \"\\n\";\n    cerr << \"tmp2 = \" << tmp2 << \"\\n\";\n    cerr << \"V1 = \" << v1 << \"\\n\";\n    cerr << \"V2 = \" << v2 << \"\\n\";\n    cerr << \"Bad = \" << bad << \"\\n\";\n    cerr << \"Mul = \" << mul << \"\\n\";\n    cerr << \"Ans = \" << ans << \"\\n\";\n    */\n  }\n  cout << ans;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n/* \nLen = 4\nV1 = 1\nV3 = 1\nV2 = 1\nBad = 0\nMul = 81\nAns = 81\nLen = 5\nV1 = 1\nV3 = 1\nV2 = 4\nBad = 1\nMul = 216\nAns = 297\nLen = 6\nV1 = 1\nV3 = 1\nV2 = 10\nBad = 2\nMul = 360\nAns = 657\nLen = 7\nV1 = 1\nV3 = 1\nV2 = 20\nBad = 3\nMul = 360\nAns = 1017\nLen = 8\nV1 = 4\nV3 = 4\nV2 = 35\nBad = 4\nMul = 0\nAns = 1017\n1017\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\nconst int NMAX = 3e5 + 5;\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nint fct[2 * NMAX], ifct[2 * NMAX], p3[2 * NMAX];\nint cnt[NMAX];\n\nint power(int x, int y)\n{\n    if(y == 0)  return 1;\n    int ans = power( (1LL * x * x) % mod, y >> 1 );\n    if(y & 1)   ans = (1LL * ans * x) % mod;\n    return ans;\n}\n\nvoid pre(int N)\n{\n    fct[0] = 1;\n    for(int i = 1; i <= N; i++) fct[i] = (1LL * fct[i - 1] * i) % mod;\n    ifct[N] = power(fct[N], mod - 2);\n    for(int i = N - 1; i >= 0; i--) ifct[i] = (1LL * ifct[i + 1] * (i + 1)) % mod;\n\n    p3[0] = 1;\n    for(int i = 1; i <= N; i++) p3[i] = (3LL * p3[i - 1]) % mod;\n}\n\nint C(int N, int K)\n{\n    if(N < K)   return 0;\n    int ans = fct[N];\n    ans = (1LL * ans * ifct[K]) % mod;\n    ans = (1LL * ans * ifct[N - K]) % mod;\n    return ans;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    pre(2 * NMAX);\n\n    scanf(\"%d%d%d\", &N, &M, &K);\n\n    cnt[0] = 1;\n    for(int i = 1; i <= M + K; i++)\n        for(int j = max(0, i - K); j <= M && j <= i; j++)\n            cnt[i] = (cnt[i] + C(i, j)) % mod;\n\n    int ans = 0;\n    for(int i = N; i <= N + M + K; i++)\n    {\n        int sol = (1LL * C(i - 1, N - 1) * cnt[i - N]) % mod;\n        sol = (1LL * sol * p3[N + M + K - i]) % mod;\n        ans = (ans + sol) % mod;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=6e5+5;\ntypedef long long LL;\nconst LL mo=1e9+7;\nLL fac[maxn],inv[maxn];\nLL C(int n,int m){\n\treturn fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nLL pw(LL x,LL k,LL p=::mo){\n\tLL ans=1;\n\tfor(;k;k>>=1){\n\t\tif(k&1)ans=ans*x%mo;\n\t\tx=x*x%mo;\n\t}\n\treturn ans;\n}\nint main(){\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<maxn;i++){\n\t\tfac[i]=fac[i-1]*i%mo;\n\t}\n\tfor(int i=2;i<maxn;i++){\n\t\tinv[i]=(mo-mo/i)*inv[mo%i]%mo;\n\t}\n\tfor(int i=2;i<maxn;i++){\n\t\tinv[i]=inv[i-1]*inv[i]%mo;\n\t}\n\n\tLL ans=0;\n\n\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tif(m>k)swap(m,k);\n\n\n//\tlong long ans=0;\n/*\tfor(int i=0;i<=m;i++)\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tans+=C(n+i+j-1,n-1)*C(i+j,i)*pw(3,m+k-i-j);\n\t\t}\n\tcout<<ans<<endl;\n\n\tfor(int i=0;i<=m+k;i++)\n\t\tfor(int j=0;j<=k&&j<=m;j++){\n\t\t\tans+=C(n+i-1,n-1)*C(i,j)*pw(3,m+k-i);\n\t\t}\n\tcout<<ansi<<endl;\n\treturn 0;*/\n\tLL cur=1;\n\tfor(int p=0;p<=m+k;p++){\n\t\tLL res=0;\n\t\t\n\t\tres=C(n+p-1,n-1)*pw(3,m+k-p)%mo;\n\t\t//TODO\n\t\t/*\n\t\tcur=0;\n\t\tint l=max(p-k,0),r=min(m,p);\n\t\tfor(int i=max(p-k,0);i<=m&&i<=p;i++){\n\t\t\tcur+=C(p,i);\n\t\t\tcur%=mo;\n\t\t}\n\t\tcout<<l<<\" \"<<r<<\" \"<<cur<<endl;*/\n//\t\tcerr<<p<<\" \"<<cur<<endl;\n\t\n\n\t\tans+=res*cur%mo;\n\t\tans%=mo;\n\n\t\tcur=cur*2%mo;\n\t\tif(p>=m){\n\t\t\tcur-=C(p,m);\n\t\t\tcur+=mo;cur%=mo;\n\t\t}\n\t\tif(p>=k){\n\t\t\tcur-=C(p,p-k);\n\t\t\tcur+=mo;cur%=mo;\n\t\t}\n\n\n\t}\n\n\tcout<<ans<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=900000+10;\n\nconst int mod=1e9+7;\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint fac[N],ifac[N],pw[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n    for (re int i=pw[0]=1;i<=n;++i) pw[i]=3ll*pw[i-1]%mod;\n}\n\ninline int C(int n,int m) {\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main() { init(900000);\n    int n=read(),m=read(),k=read();\n    int ans=0,lst=1;\n    for (re int i=0;i<=m+k;++i) {\n        ans=(ans+1ll*C(n+i-1,n-1)*pw[m+k-i]%mod*lst)%mod;\n        if (i<k) lst=2ll*lst%mod;\n        else if (i<m) lst=(2ll*lst+mod-C(i,k))%mod;\n        else lst=(2ll*lst+mod-C(i,k)+mod-C(i,m))%mod;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 我是憨憨\n#include <bits/stdc++.h>\n\nconst int MOD = 1e9 + 7, MAXN = 1e6 + 10;\ninline int add(int x, int y) { return x + y >= MOD ? x + y - MOD : x + y; }\ninline int sub(int x, int y) { return x < y ? x - y + MOD : x - y; }\ninline int mul(int x, int y) { return 1LL * x * y - 1LL * x * y / MOD * MOD; }\ninline int Qpow(int a, int b) { int ans = 1; for (; b; a = mul(a, a), b >>= 1) if (b & 1) ans = mul(ans, a); return ans; }\ninline int inv(int a) { return Qpow(a, MOD - 2); }\n\nint n, m, K;\nint fac[MAXN], ifac[MAXN], pow3[MAXN];\n\ninline void init() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i) fac[i] = mul(fac[i - 1], i);\n\tifac[MAXN - 1] = inv(fac[MAXN - 1]);\n\tfor (int i = MAXN - 2; ~i; --i) ifac[i] = mul(ifac[i + 1], i + 1);\n\tpow3[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i) pow3[i] = mul(pow3[i - 1], 3);\n}\ninline int binom(int n, int m) {\n\tif (n < m) return 0;\n\treturn mul(fac[n], mul(ifac[m], ifac[n - m]));\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &K), init();\n\tif (m < K) std::swap(m, K);\n\tint ans = 0;\n\tfor (int i = 0, sum = 1; i <= m + K; ++i) {\n\t\tans = add(ans, mul(binom(i + n - 1, i), mul(pow3[m + K - i], sum)));\n\t\tif (i < K) sum = add(sum, sum);\n\t\telse if (i < m) sum = sub(add(sum, sum), binom(i, K));\n\t\telse sum = sub(add(sum, sum), add(binom(i, K), binom(i, m)));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\n\nint n;\nint m; \nint k;\n\n\nlong long int ppow(long long int i, long long int j){\n\tlong long int res = 1;\n\twhile (j){\n\t\tif ((j & 1LL)){\n\t\t\tres *= i;\n\t\t\tif (res >= MOD)res %= MOD;\n\t\t}\n\t\ti *= i;\n\t\tif (i >= MOD)i %= MOD;\n\t\tj >>= 1;\n\t}\n\treturn res;\n}\n#define MAX 300004\nlong long int ka[MAX];\nlong long int inv[MAX];\n\nlong long int C(int a, int b){\n\tlong long int r = ka[a];\n\tlong long int rr = inv[b] * inv[a - b]; \n\tif (rr >= MOD)rr %= MOD;\n\tr *= rr;\n\tif (r >= MOD)r %= MOD;\n\treturn r;\n}\nlong long int p3[MAX];\nint main(){\n\tp3[0] = 1;\n\tfor (int i = 1; i < MAX; i++){\n\t\tp3[i] = p3[i - 1];\n\t\tp3[i] *= 3LL;\n\t\tif (p3[i] >= MOD)p3[i] %= MOD;\n\t}\n\tka[0] = 1;\n\tfor (int i = 1; i < MAX; i++){\n\t\tka[i] = ka[i - 1];\n\t\tka[i] *= (long long int)(i);\n\t\tif (ka[i] >= MOD)ka[i] %= MOD;\n\t}\n\tfor (int i = 0; i < MAX; i++){\n\t\tinv[i] = ppow(ka[i], MOD - 2);\n\t}\n\tcin >> n >> m >> k;\n\tif (n>1000 || m>1000 || k > 1000){\n\t\treturn 0;\n\t}\n\tn--;\n\tlong long int ans = 0;\n\tfor (int i = 0; i <= m; i++){\n\t\tfor (int j = 0; j <= k; j++){\n\t\t\tint can = i + j + 1;\n\t\t\tlong long int way = C(can + n - 1, n);\n\t\t\tway *= C(i + j, i);\n\t\t\tif (way >= MOD)way %= MOD;\n\t\t\tway *= p3[m - i];\n\t\t\tif (way >= MOD)way %= MOD;\n\t\t\tway *= p3[k - j];\n\t\t\tif (way >= MOD)way %= MOD;\n\t\t\tans += way;\n\t\t\tif (ans >= MOD)ans %= MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, M, K;\nint p3[1000000];\nint fact[1000000];\n\nint modpow(int x, int k) {\n  int a = 1;\n  while (k > 0) {\n    if (k & 1) a = (1LL*a*x) % MOD;\n    x = (1LL*x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\n\nint inv(int x) {\n  return modpow(x, MOD-2);\n}\n\nint nCr(int n, int k) {\n  if (n < 0 || k < 0 || n < k) return 0;\n  return (1LL * fact[n] * inv((1LL*fact[k]*fact[n-k]) % MOD)) % MOD;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M >> K;\n  if (M > K) swap(M, K);\n  p3[0] = 1, fact[0] = 1;\n  for (int i=1; i<=N+M+K; i++) {\n    p3[i] = (3LL*p3[i-1]) % MOD;\n    fact[i] = (1LL*i*fact[i-1]) % MOD;\n  }\n  int s = 0, lt = 0;\n  for (int i=M+K; i>=0; i--) {\n    int u = M+K-i;\n    int l = max(0LL, u-M), r = min(u, K);\n    int t = 0;\n    if (i == M+K) t = 1;\n    else {\n      t = (2LL*lt - nCr(u-1, r) - nCr(u-1, l-1) + 2LL*MOD) % MOD;\n    }\n    s = (s + 1LL*((1LL*p3[i]*t)%MOD)*nCr(N+M+K-i-1, N-1)) % MOD;\n    lt = t;\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> famod, simod, fimod;\n\nvoid create_fact_mod(int num){\n    famod[0] = 1;\n    famod[1] = 1;\n    for(int i=2; i<=num; i++){\n        famod[i] = famod[i-1] * i % MOD;\n    }\n}\n\nvoid create_seq_inv_mod(int num){\n    simod[0] = 1;\n    simod[1] = 1;\n    for(int i=2; i<=num; i++){\n        simod[i] = (MOD - MOD/i) * simod[MOD%i] % MOD;\n    }\n}\n\nvoid create_fact_inv_mod(int num){\n    fimod[0] = 1;\n    fimod[1] = 1;\n    for(int i=2; i<=num; i++){\n        fimod[i] = fimod[i-1] * simod[i] % MOD;\n    }\n}\n\nvoid create_mod_tables(int num){\n    famod.resize(num+1);\n    simod.resize(num+1);\n    fimod.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return famod[n] * fimod[n-k] % MOD * fimod[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return famod[n] * fimod[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint main(){\n    int N, M, K;\n    cin >> N >> M >> K;\n    assert(N+M+K <= 3000);\n    create_mod_tables(N+M+K);\n    int64_t ans = 0;\n    for(int m=0; m<=M; m++){\n        for(int k=0; k<=K; k++){\n            int64_t result = power_mod(3, m+k);\n            mul(result, famod[N-1+M-m+K-k]);\n            mul(result, fimod[N-1]);\n            mul(result, fimod[M-m]);\n            mul(result, fimod[K-k]);\n            add(ans, result);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll mod=1e9+7;\nconst ll inf=1e17+500;\nconst ll maxn=1e6+500;\nll fac[maxn];\nll rfac[maxn];\n\nll poww(ll a,ll b){\n    ll ans=1;\n    while(b){\n        if(b&1){\n            ans=(ans*a)%mod;\n        }\n        a=(a*a)%mod;\n        b>>=1;\n    }\n    return ans;\n}\nll ent(ll n,ll k){\n    if(k<0 || k>n)return 0;\n    return (((fac[n]*rfac[k])%mod)*rfac[n-k])%mod;\n}\n\nll find_suf(ll n,ll l){\n    ll res=0;\n    for(ll i=l;i<=n;i++){\n        res+=(ent(i-1,l-1)*poww(2,n-i))%mod;\n    }\n    return res%mod;\n}\nll find_pre(ll n,ll r){\n    return find_suf(n,n-r);\n}\nll find_sum(ll s,ll l,ll r){\n    if(l==0)return find_pre(s,r);\n    return (find_pre(s,r)-find_pre(s,l-1)+mod)%mod;\n}\nint main(){\n    fac[0]=1;\n    rfac[0]=1;\n    for(ll i=1;i<maxn;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n        rfac[i]=poww(fac[i],mod-2);\n    }\n\n   ll ans=0;\n   ll n,m,k;\n   cin>>n>>m>>k;\n   n--;\n   for(ll s=0;s<=m+k;s++){\n        ll res=find_sum(s,max(0LL,s-m),min(k,s));\n        res%=mod;\n        res*=ent(n+s,s);\n        res%=mod;\n        res*=poww(3,m+k-s);\n        res%=mod;\n        ans+=res;\n   }\n   cout<<ans%mod;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#ifdef _DEBUG_\n\t#define debug(...) printf(__VA_ARGS__)\n#else\n\t#define debug(...) (void)0\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\nconst int MOD=1e9+7;\n\ninline int add(int x,int y) { return (x+y)%MOD; }\ninline int mul(int x,int y) { return (1ll*x*y)%MOD; }\n\nint pw(int a,int k) {\n\tint r=1, t=a;\n\twhile(k) {\n\t\tif(k%2) r=mul(r,t);\n\t\tt=mul(t,t);\n\t\tk/=2;\n\t}\n\treturn r;\n}\ninline int inv(int x) { return pw(x, MOD-2); }\n\nconst int MAXX=1000500;\nint fac[MAXX];\nint ifac[MAXX];\n\nint main() {\n\tfac[0]=1;\n\tfor(int i=1;i<MAXX;i++) fac[i]=mul(fac[i-1],i);\n\tfor(int i=0;i<MAXX;i++) ifac[i]=inv(fac[i]);\n\tint N,M,K;\n\tcin >> N >> M >> K;\n\tint ans=0;\n\tint sum=N+M+K;\n\tfor(int i=N;i<=sum;i++) { // (Nth A) +1\n\t\tfor(int j=0;j<=M;j++) { // num of B\n\t\t\tint nC=i-N-j;\n\t\t\tif(nC<0 || nC>K) continue;\n\t\t\tint tmp=mul( fac[i-1], mul( ifac[N-1], mul( ifac[j], ifac[nC] ) ) );\n\t\t\ttmp = mul(tmp, pw(3, sum-i));\n\t\t\tans=add(ans, tmp );\n\t\t\tdebug(\"i, j %d %d   %d\\n\",i,j,tmp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Mod 1000000007ll\n#define Val(x) ((((long long)x) % Mod + Mod) % Mod)\nusing namespace std;\nconst int maxn = 300005 * 3;\nint fac[maxn];\ninline int Pow(int a,int n) {\n\tint ret = 1;\n\tint base = a;\n\twhile(n) {\n\t\tif(n & 1)\tret = Val(ret*base);\n\t\tbase = Val(base*base);\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ninline int inv(int a) {\n\treturn Pow(a,Mod-2);\n}\ninline int C(int n,int m) {\n\treturn Val(Val(fac[n]*inv(fac[m]))*inv(fac[n-m]));\n}\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m,k;\n\tcin >> n >> m >> k; \n\n\tfac[0] = 1;\n\tfor(int i=1;i<maxn;i++)\n\t\tfac[i] = Val(fac[i-1] * i);\n\t\n\tint ans = 0 , sum = 1 , u1 = 0 , u2 = 0;\n\tfor(int L=0;L<=m+k;L++) {\n\t\tint now = Val( Val( Val( Val(fac[L+n-1] * inv(fac[n-1])) * inv(fac[L])) * Pow(3,m+k-L)) * sum);\n\t\tans = Val(ans + now);\n\t\t\n\t\tsum = Val(sum * 2 - C(L,u1) - C(L,L-u2));\n\t\tif(u1 + 1 <= m) {\n\t\t\tu1++;\n\t\t\tsum = Val(sum + C(L+1,u1));\n\t\t}\n\t\tif(u2 + 1 <= k) {\n\t\t\tu2++;\n\t\t\tsum = Val(sum + C(L+1,L+1-u2));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 21);\nconst int mod = (int)1e9 + 7;\nconst double PI = acos(-1.0);\nconst int BK = 100;\nconst int CK = 5;\n\ninline void addmod(int& x, int y, int mod) { (x += y) >= mod && (x -= mod); }\ninline int mulmod(int x, int y, int mod) { return x * 1ll * y % mod; }\n\nstruct complex_base\n{\n\tdouble x, y;\n\tcomplex_base(double _x = 0, double _y = 0) { x = _x; y = _y; }\n\tfriend complex_base operator-(const complex_base &a, const complex_base &b) { return complex_base(a.x - b.x, a.y - b.y); }\n\tfriend complex_base operator+(const complex_base &a, const complex_base &b) { return complex_base(a.x + b.x, a.y + b.y); }\n\tfriend complex_base operator*(const complex_base &a, const complex_base &b) { return complex_base(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x); }\n\tfriend void operator/=(complex_base &a, const double &P) { a.x /= P; a.y /= P; }\n};\n\nint bit_rev[MAXN];\n\nvoid fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = 2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cosl(ang), sinl(ang));\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n}\n\nvoid inv_fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = -2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cosl(ang), sinl(ang));\n\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] /= n;\n}\n\ncomplex_base A[MAXN], B[MAXN];\n\nvector<int> mult(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() <= 128)\n\t{\n\t\tvector<int> ans(a.size() + b.size(), 0);\n\t\tfor(int i = 0; i < (int)a.size(); i++)\n\t\t\tfor(int j = 0; j < (int)b.size(); j++)\n\t\t\t\tans[i + j] = (ans[i + j] + a[i] * 1ll * b[j]) % mod;\n\n\t\treturn ans;\n\t}\n\n\tint lg = 0; while((1 << lg) < (int)(a.size() + b.size())) ++lg;\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = B[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = complex_base(a[i], 0);\n\tfor(int i = 0; i < (int)b.size(); i++) B[i] = complex_base(b[i], 0);\n \n\tfft(A, lg); fft(B, lg);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tA[i] = A[i] * B[i];\n\tinv_fft(A, lg);\n\n\tvector<int> ans(a.size() + b.size(), 0);\n\tfor(int i = 0; i < (int)ans.size(); i++)\n\t\tans[i] = (int64_t)(A[i].x + 0.5) % mod;\n\n\treturn ans;\n}\n\nvector<complex_base> to_fft(const vector<complex_base> &a, int lg)\n{\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = a[i];\n\tfft(A, lg);\n\n\tvector<complex_base> ret(1 << lg, 0);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tret[i] = A[i];\n\n\treturn ret;\n}\n\nvector<complex_base> to_inv_fft(const vector<complex_base> &a, int lg)\n{\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = a[i];\n\tinv_fft(A, lg);\n\n\tvector<complex_base> ret(1 << lg, 0);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tret[i] = A[i];\n\n\treturn ret;\n}\n\nvector<int> mult_mod(const vector<int> &a, const vector<int> &b)\n{\n\t/// Thanks pavel.savchenkov\n\n\t// a = a0 + sqrt(MOD) * a1\n\t// a = a0 + base * a1\n\tint base = (int)sqrtl(mod);\n\n\tvector<int> a0(a.size()), a1(a.size());\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t{\n\t\ta0[i] = a[i] % base;\n\t\ta1[i] = a[i] / base;\n\t}\n\n\tvector<int> b0(b.size()), b1(b.size());\n\tfor(int i = 0; i < (int)b.size(); i++)\n\t{\n\t\tb0[i] = b[i] % base;\n\t\tb1[i] = b[i] / base;\n\t}\n\n\tvector<int> a01 = a0;\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t\taddmod(a01[i], a1[i], mod);  \t\n\n\tvector<int> b01 = b0;\n\tfor(int i = 0; i < (int)b.size(); i++) \n\t\taddmod(b01[i], b1[i], mod);\n\n\tvector<int> C = mult(a01, b01);  // 1\n\n\tvector<int> a0b0 = mult(a0, b0); // 2\n\tvector<int> a1b1 = mult(a1, b1); // 3\n\n\tvector<int> mid = C;\n\tfor(int i = 0; i < (int)mid.size(); i++) \n\t{\n\t\taddmod(mid[i], -a0b0[i] + mod, mod);\n\t\taddmod(mid[i], -a1b1[i] + mod, mod);\n\t}\n\n\tvector<int> res = a0b0;\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, mid[i], mod), mod);\n\n\tbase = mulmod(base, base, mod);\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, a1b1[i], mod), mod);\n\n\treturn res;\n}\n\n\n#define mp make_pair\n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < (int) n; ++i)\n \ntypedef vector <int> vi;\n \nusing ld = double;\nusing ll = int64_t;\n \n\nconst ll MOD = mod;\n\nnamespace FFT {\n  struct cd {\n    ld a, b;\n \n    cd(ld a, ld b) : a(a), b(b) {}\n \n    cd(ld x = 0) : a(x), b(0) {}\n \n    ld real() const {\n      return a;\n    }\n \n    void operator += (const cd& other) {\n      a += other.a;\n      b += other.b;\n    }\n \n    void operator -= (const cd& other) {\n      a -= other.a;\n      b -= other.b;\n    }\n \n    void operator *= (const cd& other) {\n      tie(a, b) = mp(a * other.a - b * other.b, a * other.b + b * other.a);\n    }\n \n    friend cd operator * (const cd& x, const cd& y) {\n      cd r = x;\n      r *= y;\n      return r;\n    }\n \n    friend cd operator + (const cd& x, const cd& y) {\n      cd r = x;\n      r += y;\n      return r;\n    }\n \n    friend cd operator - (const cd& x, const cd& y) {\n      cd r = x;\n      r -= y;\n      return r;\n    }\n \n    void operator /= (ld c) {\n      a /= c;\n      b /= c;\n    }\n  };\n \n  typedef vector<cd> vcd;\n \n  const int LOG = 20;\n  const int N = 1 << LOG;\n \n  int rev[N];\n  cd root_[N];\n \n  inline cd root(int k, int n) {\n    return root_[k * (N / n)];\n  }\n \n  void precalc() {\n    rev[0] = 0;\n    int hb = -1;\n    for (int i = 1; i < N; ++i) {\n      if  ((i & (i - 1)) == 0) {\n        ++hb;\n      }\n      rev[i] = rev[i ^ (1 << hb)] | (1 << (LOG - hb - 1));\n    }\n \n    forn(i, N) {\n      ld ang = PI * i * 2.0 / N;\n      root_[i] = cd(cosl(ang), sinl(ang));\n    }\n  }\n \n  void fft_rec(cd* a, int n) {\n    if  (n == 1) {\n      return;\n    }\n \n    fft_rec(a, n / 2);\n    fft_rec(a + n / 2, n / 2);\n \n    forn(k, n / 2) {\n      cd w = root(k, n);\n      cd x = a[k];\n      cd y = w * a[k + n / 2];\n      a[k] = x + y;\n      a[k + n / 2] = x - y;\n    }\n  }\n \n  void fft(vcd& a) {\n    int n = sz(a);\n    vcd na(n, cd(0, 0));\n    forn(i, n) na[i] = a[rev[i]];\n    na.swap(a);\n \n    fft_rec(&a[0], n);\n  }\n \n  void fft_inv(vcd& a) {\n    fft(a);\n    int n = sz(a);\n    reverse(a.begin() + 1, a.end());\n    forn(i, n) {\n      a[i] /= n;\n    }\n  }\n \n  vi mult(const vi& a, const vi& b) {\n    //    TimeStamp t(\"mult\");\n    vcd A(N, cd(0, 0));\n    vcd B(N, cd(0, 0));\n    forn(i, sz(a)) A[i] = a[i];\n    forn(i, sz(b)) B[i] = b[i];\n \n    fft(A);\n    fft(B);\n \n    forn(i, N) A[i] *= B[i];\n \n    fft_inv(A);\n \n    vi c(N, 0);\n    forn(i, N) c[i] = ((ll) (A[i].real() + 0.5)) % MOD;\n \n    return c;\n  }\n \n  vi multmod(const vi& a, const vi& b) {\n    // a = a0 + sqrt(MOD) * a1\n    // a = a0 + base * a1\n    int base = (int) sqrtl(MOD);\n \n    vi a0(sz(a)), a1(sz(a));\n    forn(i, sz(a)) {\n      a0[i] = a[i] % base;\n      a1[i] = a[i] / base;\n      assert(a[i] == a0[i] + base * a1[i]);\n    }\n \n    vi b0(sz(b)), b1(sz(b));\n    forn(i, sz(b)) {\n      b0[i] = b[i] % base;\n      b1[i] = b[i] / base;\n      assert(b[i] == b0[i] + base * b1[i]);\n    }\n \n    vi a01 = a0;\n    forn(i, sz(a)) {\n      addmod(a01[i], a1[i], MOD);\n    }\n \n    vi b01 = b0;\n    forn(i, sz(b)) {\n      addmod(b01[i], b1[i], MOD);\n    }\n \n    vi C = mult(a01, b01);  // 1\n \n    vi a0b0 = mult(a0, b0); // 2\n    vi a1b1 = mult(a1, b1); // 3\n \n    vi mid = C;\n    forn(i, N) {\n      addmod(mid[i], -a0b0[i] + MOD, MOD);\n      addmod(mid[i], -a1b1[i] + MOD, MOD);\n    }\n \n    vi res = a0b0;\n    forn(i, N) {\n      addmod(res[i], mulmod(base, mid[i], MOD), MOD);\n    }\n \n    base = mulmod(base, base, MOD);\n    forn(i, N) {\n      addmod(res[i], mulmod(base, a1b1[i], MOD), MOD);\n    }\n \n    return res;\n  }\n};\n\nint n, m, k;\n\nvoid read()\n{\n\tcin >> n >> m >> k;\n}\n\nvector<int> p1, p2, pw3;\n\nint pw(int x, int p)\n{\n\tint ret = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ret = (ret * 1ll * x) % mod;\n\t\tx = (x * 1ll * x) % mod;\n\t\tp >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint fact[MAXN], inv_fact[MAXN];\nint comb(int n, int k) { if(n < 0 || k < 0 || n < k) return 0; return (((fact[n] * 1ll * inv_fact[n - k]) % mod) * 1ll * inv_fact[k]) % mod; }\n\n/*   SUM C(n + i - 1, i) * C(n + i - 1 + j, j)   */\n/*   SUM C(n + i - 1, i) * fact[n + i - 1 + j] / (fact[j] * fact[n + i - 1])    */\n\n\nvoid solve()\n{\t\n\tpw3.assign(n + m + k + 1, 0);\n\tp1.assign(m + 1, 0);\n\tp2.assign(k + 1, 0);\n\tpw3[0] = 1; for(int i = 1; i <= m + k + n; i++) pw3[i] = (3ll * pw3[i - 1]) % mod;\n\tfact[0] = 1; for(int i = 1; i <= m + k + n; i++) fact[i] = (fact[i - 1] * 1ll * i) % mod;\n\tinv_fact[m + k + n] = pw(fact[m + k + n], mod - 2); for(int i = n + k + m - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * 1ll * (i + 1)) % mod; \n\n\tfor(int i = 0; i <= m; i++) p1[i] = (comb(n + i - 1, i) * 1ll * inv_fact[n + i - 1]) % mod;\n\tfor(int i = 0; i <= k; i++) p2[i] = inv_fact[i];\n\n\tvector<int> ret = mult_mod(p1, p2);\n\t\n\tint answer = 0;\n\tfor(int i = 0; i < (int)ret.size(); i++)\n\t{\n\t\tif(m + k - i < 0) break;\n\t\tint curr = (ret[i] * 1ll * pw3[m + k - i]) % mod;\n\t\tcurr = (curr * 1ll * fact[n - 1 + i]) % mod;\n\t\taddmod(answer, curr, mod);\n\t}\n\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int MD = 1e9+7;\nstruct Mint {\n    typedef Mint M;\n    int v;\n    Mint(int _v = 0) : v(_v) {}\n    M& operator += (const M &r) {\n        if ((v += r.v) >= MD) v -= MD;\n        return *this;\n    }\n    M& operator -= (const M &r) {\n        if ((v -= r.v) < 0) v += MD;\n        return *this;\n    }\n    M& operator *= (const M &r) {\n        v = ll(v)*r.v%MD;\n        return *this;\n    }\n    M operator + (const M &r) const { return M(*this) += r; }\n    M operator - (const M &r) const { return M(*this) -= r; }\n    M operator * (const M &r) const { return M(*this) *= r; }\n    M pow(int n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n&1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return this->pow(MD-2); }\n};\n\nconst int B = 666666;\nint N, M, K;\nMint fac[B], ifac[B];\n\nMint C(int n, int m) {\n    if (n < 0 || m < 0 || n < m) return Mint(0);\n    return fac[n]*ifac[m]*ifac[n-m];\n}\n\nvoid first() {\n    fac[0] = 1;\n    for (int i = 1; i < B; i++) fac[i] = fac[i-1]*Mint(i);\n    ifac[B-1] = fac[B-1].inv();\n    for (int i = B-2; i >= 0; i--) ifac[i] = ifac[i+1]*Mint(i+1);\n}\n\nint main() {\n    first();\n    cin >> N >> M >> K;\n    if (M > K) swap(M, K);\n\n    Mint ans = 0;\n\n    for (int i = 0; i <= M; i++) {\n        ans += C(N-1+i, N-1) * Mint(2).pow(i) * Mint(3).pow(M+K-i);\n    }\n    Mint sm = Mint(2).pow(M);\n    for (int i = M+1; i <= M+K; i++) {\n        sm = Mint(2) * sm - C(i-1, M) + C(i-1, i-2-M) - C(i, i-1-M);\n        ans += C(N-1+i, N-1) * sm * Mint(3).pow(M+K-i);\n    }\n\n    cout << ans.v << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long FACT[1000000];\nlong long IFACT[1000000];\n\nstatic long long  MOD = 1000000007L;\nstatic long long  mod = 1000000007L;\nlong long  modPow(long long a, long long b) {\n if(b == 0L) return 1L % MOD;\n if(b == 1L) return a % MOD;\n\n if(b % 2 == 0) {\n\t long long ret = modPow(a % MOD,b / 2) % MOD;\n\t return (ret * ret) % MOD;\n }\n else {\n\t long long ret = (a * (long long)modPow(a % MOD,b-1)) % MOD;\n\t return ret % MOD;\n }\n}\n\n\n\n\tlong long C(long long  n, long long  r)\n\t{\n\t\tif(n < 0 || r < 0 || r > n)return 0;\n\t\tif(r > n / 2)r = n - r;\n\t\treturn ((((FACT[n]%mod)*(IFACT[n-r]%mod))%mod)*IFACT[r])%mod;\n\t}\n\n\tlong long INV(long long v) {\n\t\treturn modPow(v % MOD, MOD - 2);\n\t}\n\n\n\nint main() {\n\tint N,M,K,n;\n\tcin >> N >> M >> K;\n\t\tn = N + M + K;\n\n\t\tFACT[0] = 1;\n\t\tIFACT[0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tFACT[i] = ((FACT[i-1] % MOD) * i) % mod;\n\t\t\tIFACT[i] = INV(FACT[i]) % MOD;\n\t\t}\n\t\tvector<long long> p2(4000001);\n\t\tp2[0] = 1;\n\t  for (int i = 1; i <= 4000000; i++)\n\t\tp2[i] = ((p2[i - 1] % MOD) * 2) % MOD;\n\t\tlong long ans = 0;\n\t\tlong long hh = 0;\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tlong long  retA = modPow(3,N + M + K - i) % MOD;\n\n\t\t\tlong long  retB = C(i-1,N-1) % MOD;\n\t\t\tlong long retC = 0;\n\t\t\tretC = (retC + p2[i - N]) % MOD;\n\t\t\thh = (hh * 2) % MOD;\n\t\t\tif (i - N > M) hh = (hh + C(M + i - N - M - 1, i - N - M - 1) % MOD) % MOD;\n\t\t\tif (i - N > K) hh = (hh + C(K + i - N - K - 1, i - N - K - 1) % MOD) % MOD;\n\t\t\tretC = (retC - hh) % MOD;\n\t\t\tlong long ansA = ((retA) * (long long )(retB)) % MOD;\n\t\t\tansA %= MOD;\n\t\t\tansA *= retC % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define all(v) (v).begin(),(v).end()\n \n#define PII pair<int,int>\n#define mp make_pair\n#define st first\n#define nd second\n#define pb push_back\n#define lint long long int\n#define VI vector<int>\n \n#define debug(x) {cerr <<#x <<\" = \" <<x <<endl; }\n#define debug2(x,y) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y <<endl; } \n#define debug3(x,y,z) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y << \", \" << #z << \" = \" << z <<endl; } \n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<endl; }}\n#define debugt(t,n) {{cerr <<#t <<\" = \"; FOR(it,0,(n)) cerr <<t[it] <<\", \"; cerr <<endl; }}\n \n#define make( x) int (x); scanf(\"%d\",&(x));\n#define make2( x, y) int (x), (y); scanf(\"%d%d\",&(x),&(y));\n#define make3(x, y, z) int (x), (y), (z); scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define make4(x, y, z, t) int (x), (y), (z), (t); scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define makev(v,n) VI (v); FOR(i,0,(n)) { make(a); (v).pb(a);} \n#define IOS ios_base::sync_with_stdio(0)\n#define HEAP priority_queue\n \n#define read( x) scanf(\"%d\",&(x));\n#define read2( x, y) scanf(\"%d%d\",&(x),&(y));\n#define read3(x, y, z) scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define read4(x, y, z, t) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define readv(v,n) FOR(i,0,(n)) { make(a); (v).pb(a);}\n \n \nusing namespace std;\n\nconst int max_n = 2e4 + 5;\n\nint mod = 1e9 + 7;\n\nint powmod(int a, int n) {\n\tif (n == 0) return 1;\n\tint sq = powmod(a, n/2);\n\tsq = (sq * 1LL * sq) % mod;\n\tif (n%2 == 0) return sq;\n\treturn (sq * 1LL * a) % mod;\n}\n\nint fac[max_n];\nint ifac[max_n];\nint p3[max_n];\n\nvoid solve() {\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tFOR(i,1,max_n - 1) fac[i] = (fac[i-1] * 1LL * i) % mod;\n\tFOR(i,1,max_n - 1) ifac[i] = powmod(fac[i], mod - 2);\n\tp3[0] = 1;\n\tFOR(i,1,max_n -1) p3[i] = (p3[i-1] * 3LL)%mod;\n\n\tmake3(a, b, c);\n\tb++; c++;\n\tint ans = 0;\n\tFOR(i, 0, b) FOR(j, 0, c) {\n\t\tint loc = fac[a-1 + i + j];\n\t\tloc = (loc * 1LL * ifac[i]) % mod;\n\t\tloc = (loc * 1LL * ifac[j]) % mod;\n\t\tloc = (loc * 1LL * ifac[a-1]) % mod;\n\t\tloc = (loc * 1LL * p3[b-1+c-1-i-j]) % mod;\n\t\tans = (ans + loc) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n\nint main() {\n\tint z = 1;\n\t// read(z);\n\twhile (z--) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<ctime>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<utility>\n#include<iomanip>\nusing namespace std;\nint read(){\n    int xx=0,ff=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')ff=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){xx=xx*10+ch-'0';ch=getchar();}\n    return xx*ff;\n}\nlong long READ(){\n    long long xx=0,ff=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')ff=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){xx=xx*10+ch-'0';ch=getchar();}\n    return xx*ff;\n}\nchar one(){\n\tchar ch=getchar();\n\twhile(ch==' '||ch=='\\n')\n\t\tch=getchar();\n\treturn ch;\n}\nconst int maxn=1000010,MOD=int(1e9)+7;\nint N,M,K;\nint fac[maxn],inv[maxn],invfac[maxn],pow3[maxn];\nint C(int n,int m){\n\tif(n<m||m<0)\n\t\treturn 0;\n\treturn 1LL*fac[n]*invfac[n-m]%MOD*invfac[m]%MOD;\n}\nint main(){\n\t//freopen(\"in\",\"r\",stdin);\n\tpow3[0]=inv[0]=inv[1]=fac[0]=invfac[0]=1;\n\tfor(int i=2;i<maxn;i++)\n\t\tinv[i]=1LL*(MOD-MOD/i)*inv[MOD%i]%MOD;\n\tfor(int i=1;i<maxn;i++){\n\t\tpow3[i]=1LL*pow3[i-1]*3%MOD;\n\t\tfac[i]=1LL*fac[i-1]*i%MOD;\n\t\tinvfac[i]=1LL*invfac[i-1]*inv[i]%MOD;\n\t}\n\tN=read(),M=read(),K=read();\n\tif(K>M)swap(M,K);\n\tint ans=0,cur=1;\n\tfor(int i=0;i<=M+K;i++){\n\t\tans=(ans+1LL*C(i+N-1,i)*pow3[M+K-i]%MOD*cur%MOD)%MOD;\n\t\tif(i<K)cur=cur*2%MOD;\n\t\telse if(i<M)cur=(1LL*cur*2-C(i,K)+MOD)%MOD;\n\t\telse cur=(1LL*cur*2-C(i,M)-C(i,K)+2*MOD)%MOD;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define REP(a,b,c) for(int a=b;a<=c;a++)\n#define re register\n#define int ll\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nint n,m,k;\nconst int N=1000010,Mod=1e9+7;\nint fac[N],fai[N],inv[N];\nvoid init(){\n\tfac[0]=fai[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=1000000;i++)fac[i]=1ll*fac[i-1]*i%Mod;\n\tfor(int i=2;i<=1000000;i++)inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;\n\tfor(int i=1;i<=1000000;i++)fai[i]=1ll*fai[i-1]*inv[i]%Mod;\n}\nint C(int n,int m){\n\tif(n<m || n<0 || m<0)return 0;\n\treturn 1ll*fac[n]*fai[m]%Mod*fai[n-m]%Mod;\n}\nint qpow(int a,int b){\n\tint ret=1;\n\twhile(b){\n\t\tif(b&1)ret=1ll*ret*a%Mod;\n\t\tb>>=1;a=1ll*a*a%Mod;\n\t}\n\treturn ret;\n}\nsigned main(){\n\tn=gi();m=gi();k=gi();\n\tinit();int ans=0;\n\tint sum=1;\n\tfor(int u=0;u<=m+k;u++){\n\t\tans=(ans+1ll*C(n+u-1,n-1)*qpow(3,m+k-u)%Mod*sum%Mod)%Mod;\n\t\tif(u<m)sum=2ll*sum%Mod;\n\t\telse if(u<k)sum=(2ll*sum%Mod-C(u,k)+Mod)%Mod;\n\t\telse sum=((2ll*sum%Mod-C(u,k)+Mod)%Mod-C(u,m)+Mod)%Mod;\n\t}\n\tprintf(\"%lld\\n\",(ans+Mod)%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<1000000007> Int;\n\n//const int INF=5e8;\nint n,m,k;\n\nInt fact[600005],inv[600005];\nInt pw2[600005],pw3[600005];\nInt C(int a,int b){\n  if(a<0 || b<0 || b>a) return 0;\n  return fact[a]*inv[b]*inv[a-b];\n}\nint main(){\n  fact[0]=1;\n  pw2[0]=pw3[0]=1;\n  REP(i,600004) fact[i+1]=fact[i]*(i+1),pw2[i+1]=pw2[i]*2,pw3[i+1]=pw3[i]*3;;\n  Int one=1;\n  inv[600000]=one/fact[600000];\n  for(int i=599999;i>=0;--i) inv[i]=inv[i+1]*(i+1);\n\n  cin>>n>>m>>k;\n\n  Int res=0;\n  Int sum1=0,sum2=0;\n  for(int i=n;i<=n+m+k;++i){\n    Int tmp=C(i,n)-C(i-1,n);\n    sum1=sum1*2+C(i-n-1,i-n-m-1);\n    sum2=sum2*2+C(i-n-1,i-n-k-1);\n    tmp*=pw2[i-n]-sum1-sum2;\n    tmp*=pw3[n+m+k-i];\n    res+=tmp;\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef double db;\n#define ls(x) x<<1\n#define rs(x) x<<1|1\n#define low(x) (x&-x)\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define X first\n#define Y second\n#ifdef _DEBUG\n    const int N=5e3+10;\n#else\n    const int N=1e6+10;\n#endif\nconst ll mod=1e9+7;\ntemplate<typename T> inline T gcd(T a,T b){return !b?a:gcd(b,a%b);}\ntemplate<typename T> inline T q_pow(T a,T x){T ans=1,tmp=a;while(x){if(x&1)(ans*=tmp)%=mod;(tmp*=tmp)%=mod;x>>=1;}return ans;}\ntemplate<typename T> inline void re(T &N){int f=1;char c;while((c=getchar())< '0'||c> '9')if(c=='-')f=-1;N=c-'0';while((c=getchar())>='0'&&c<='9')N=N*10+c-'0';N*=f;}\nint m,n,k,t=1,st,en;\nll p[N];\nll mul[N],inv[N];\ninline ll C(int m,int n)\n{\n    if(m< 0||m> n)return 0;\n    return mul[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main()\n{\n    // freopen(\"data.txt\",\"r\",stdin);\n    p[0]=1;\n    for(int i=1;i< N;i++)p[i]=p[i-1]*3%mod;\n    inv[0]=mul[0]=1;\n    for(int i=1;i< N;i++)mul[i]=mul[i-1]*i%mod,inv[i]=q_pow(mul[i],mod-2);\n    re(n);re(m);re(k);\n    ll ans=0,s1=0,s2=0;\n    for(int i=0;i<=m+k;i++)\n    {\n        if(!i)s1=1;\n        else if(i<=m)(s1*=2)%=mod;\n        else s1=(((s1-C(m,i-1))*2+C(m,i))%mod+mod)%mod;\n\n        if(i-k> 0)(s2=s2*2+C(i-k,i))%=mod;\n\n        (ans+=C(n-1,n+i-1)*p[m+k-i]%mod*(s1-s2+mod)%mod)%=mod;\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\nconst int MX = 1000010;\n\nint N, M, K;\nll p3[MX], fact[MX], ifact[MX], inv[MX];\n\nll comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\nint main() {\n    inv[1] = 1;\n    for (int i = 2; i < MX; ++i) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = ifact[0] = p3[0] = 1;\n    for (int i = 1; i < MX; ++i) {\n    \tp3[i] = p3[i-1] * 3 % MOD;\n        fact[i] = fact[i-1] * i % MOD;\n        ifact[i] = ifact[i-1] * inv[i] % MOD;\n    }\n\n\tcin >> N >> M >> K;\n\n\tif (M > K) {\n\t\tswap(M, K);\n\t}\n\n\tll ret = 0;\n\tll la = -1;\n\tll p2 = 1;\n\n\tfor (int t = N; t <= N + M + K; ++t) {\n\t\tll u = 0;\n\n\t\tint tt = t - N;\n\n\t\tif (tt <= M) {\n\t\t\tu = p2;\n\n\t\t\tif (tt == M) {\n\t\t\t\tla = p2;\n\t\t\t} else {\n\t\t\t\tp2 = p2 * 2 % MOD;\n\t\t\t}\n\t\t} else if (tt <= K) {\n\t\t\tla = la * 2 % MOD;\n\t\t\tla = (la - comb(tt-1, M)) % MOD;\n\t\t\tif (la < 0) la += MOD;\n\t\t\tu = la;\n\t\t} else {\n\t\t\tla = la * 2 % MOD;\n\t\t\tla = (la - comb(tt-1, M)) % MOD;\n\t\t\tla = (la - comb(tt-1, K)) % MOD;\n\t\t\tif (la < 0) la += MOD;\n\t\t\tu = la;\n\t\t}\n\n\t\tu = u * p3[N + M + K - t] % MOD * comb(t-1, N-1);\t\n\t\tret = (ret + u) % MOD;\n\t}\n\n\tcout << ret << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define LL long long\nconst int mod = 1000 * 1000 * 1000 + 7;\nusing namespace std;\n\nint fact[200005];\nint inv[200005];\nint pow3[200005];\nint mult(int a , int b)\n{\n\treturn (a * (LL)b) % mod;\n}\nint add(int a , int b)\n{\n\treturn a + b >= mod ? a + b - mod : a + b;\n}\nint modPow(int a , int step)\n{\n\tint ans = 1;\n\twhile(step)\n\t{\n\t\tif(step & 1)\n\t\t{\n\t\t\tans = mult(ans , a);\n\t\t}\n\t\tstep >>= 1;\n\t\ta = mult(a , a);\n\t}\n\treturn ans;\n}\nint c(int n , int k)\n{\n\treturn mult(fact[n] , mult(inv[k] , inv[n - k]));\n}\nint ways(int x , int y , int z)\n{\n\treturn mult(c(x + y + z , z) , c(x + y , y));\n}\nint x ,y , z;\nint main()\n{\n\tpow3[0] = 1;\n\tfor(int i = 1; i <= 200000; i++)\n\t{\n\t\tpow3[i] = mult(pow3[i - 1] , 3);\n\t}\n\tcin >> x >> y >> z;\n\tfact[0] = inv[0] = 1;\n\tfor(int i = 1; i <= 200000; i++)\n\t{\n\t\tfact[i] = mult(fact[i - 1] , i);\n\t\tinv[i] = modPow(fact[i] , mod - 2);\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i <= y; i++)\n\t{\n\t\tfor(int j = 0; j <= z; j++)\n\t\t{\n\t\t\tans = add(ans , mult(ways(x - 1 , y - i , z - j) , pow3[i + j]));\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 1000000007\nusing namespace std;\nll n,m,L,inv[1010101],fac[1010101];\nll f[1010101],sumf[1010101];\ninline ll fast_pow(ll a,ll b,ll p){\n\tll t=1;\n\twhile (b){\n\t\tif (b&1ll) t=t*a%p;\n\t\tb>>=1ll;a=a*a%p;\n\t}\n\treturn t;\n}\ninline ll C(ll n,ll m){\n\tif (n<0||m<0) return 0;\n\tif (m>n) return 0;\n\treturn fac[n]*inv[m]%ljc*inv[n-m]%ljc;\n}\nsigned main(){\n\tcin>>n>>m>>L;\n\tinv[0]=inv[1]=fac[1]=fac[0]=1;\n\tll M=max(n,max(m,L));\n\tfor (ll i=2;i<=3*M+2;i++) fac[i]=fac[i-1]*i%ljc;\n\tfor (ll i=2;i<=3*M+2;i++) inv[i]=(ljc-(ljc/i)*inv[ljc%i]%ljc)%ljc;\n\tfor (ll i=2;i<=3*M+2;i++) inv[i]=inv[i-1]*inv[i]%ljc;\n\tif (m>L) swap(m,L); \n\tll ans=0,inv3=fast_pow(3,ljc-2,ljc);\n\tfor (ll t=0,sum=1,pw=fast_pow(3,m+L,ljc);t<=m+L;t++){\n\t\tans=(ans+pw*C(n+t-1,n-1)%ljc*sum%ljc)%ljc;\n\t\tif (t<m) sum=sum*2%ljc;\n\t\telse if (m<=t&&t<L) sum=(2*sum%ljc-C(t,m)+ljc)%ljc;\n\t\telse sum=(2*sum%ljc-C(t,m)-C(t,t-L)+2*ljc)%ljc;\n\t\tpw=pw*inv3%ljc;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,m,k;\nconst int FMAX = 600002;\nll fact[FMAX];\nll ifact[FMAX];\n\nll modpow(ll a,ll b,ll c){\n  ll r = 1;\n  while(b){\n    if(b&1)r=r*a%c;\n    a=a*a%c;\n    b>>=1;\n  }\n  return r;\n}\nll modinv(ll a,ll c){\n  return modpow(a,c-2,c);\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&m,&k);\n  // fact init\n  fact[0] = 1;\n  FOR(i,1,FMAX)fact[i]=fact[i-1]*i%MOD;\n  ifact[FMAX-1]=modinv(fact[FMAX-1],MOD);\n  FORR(i,0,FMAX-1)ifact[i]=ifact[i+1]*(i+1)%MOD;\n  // a == n-1 && b <= m && c <= k\n  ll ans = 0;\n  int a = n-1;\n  ll bipow = 1;\n  ll subsum = 0;\n  ll tris = modpow(3,m+k,MOD);\n  ll invtri = modinv(3,MOD);\n  ll factabc = (a==0?1:fact[a-1]);\n  int befbeg,befend;\n  FOR(s,0,m+k+1){\n    // c = s-b\n    // 0<=c<=k\n    // 0<=b<=m\n\n    // s-b>=0 -> b<=s\n    // s-b<=k -> b>=s-k\n    int abc = a+s;\n    if(abc!=0){\n      factabc = factabc*abc%MOD;\n    }\n    ll unit = factabc*ifact[a]%MOD*ifact[s]%MOD*tris%MOD;\n    tris = tris*invtri%MOD;\n\n    int beg = max(s-k,0);\n    int end = min(s,m);\n    if(s>0){\n      bipow += bipow;\n      subsum *= 2;\n      if(befbeg+1==beg){\n        subsum += fact[s-1]*ifact[befbeg]%MOD*ifact[s-1-befbeg]%MOD;\n      }\n      if(befend==end){\n        subsum += fact[s-1]*ifact[befend]%MOD*ifact[s-1-befend]%MOD;\n      }\n      if(bipow>=MOD)bipow-=MOD;\n      subsum %= MOD;\n    }\n    befbeg = beg;\n    befend = end;\n    ans += unit*(bipow+MOD-subsum)%MOD;\n    if(ans>=MOD)ans-=MOD;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\ntypedef vector<cd> vcd;\n\nnamespace FFT {\n    int get(int s) {\n        return s > 1 ? 32 - __builtin_clz(s - 1) : 0;\n    }\n    \n    void fft(vcd& a, bool inv){\n    \tint n = sz(a), j = 0;\n    \tvcd roots(n/2);\n    \tFOR(i,1,n) {\n    \t\tint bit = (n >> 1);\n    \t\twhile (j >= bit){\n    \t\t\tj -= bit;\n    \t\t\tbit >>= 1;\n    \t\t}\n    \t\tj += bit;\n    \t\tif(i < j) swap(a[i], a[j]);\n    \t}\n\n    \tld ang = 2 * M_PIl / n * (inv ? -1 : 1);\n    \tF0R(i,n/2) roots[i] = cd(cos(ang * i), sin(ang * i));\n    \n    \tfor (int i=2; i<=n; i<<=1){\n    \t\tint step = n / i;\n    \t\tfor(int j=0; j<n; j+=i){\n    \t\t\tfor(int k=0; k<i/2; k++){\n    \t\t\t\tcd u = a[j+k], v = a[j+k+i/2] * roots[step * k];\n    \t\t\t\ta[j+k] = u+v;\n    \t\t\t\ta[j+k+i/2] = u-v;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    \tif (inv) F0R(i,n) a[i] /= n;\n    }\n    \n    vl conv(vl a, vl b, ll mod){\n        int s = sz(a)+sz(b)-1, L = get(s), n = 1<<L;\n        \n    \tvcd v1(n), v2(n), r1(n), r2(n);\n    \tF0R(i,sz(a)) v1[i] = cd(a[i] >> 15, a[i] & 32767);\n    \tF0R(i,sz(b)) v2[i] = cd(b[i] >> 15, b[i] & 32767);\n    \tfft(v1, 0); fft(v2, 0);\n    \t\n    \tF0R(i,n) {\n    \t\tint j = (i ? (n - i) : i);\n    \t\tcd ans1 = (v1[i] + conj(v1[j])) * cd(0.5, 0);\n    \t\tcd ans2 = (v1[i] - conj(v1[j])) * cd(0, -0.5);\n    \t\tcd ans3 = (v2[i] + conj(v2[j])) * cd(0.5, 0);\n    \t\tcd ans4 = (v2[i] - conj(v2[j])) * cd(0, -0.5);\n    \t\tr1[i] = (ans1 * ans3) + (ans1 * ans4) * cd(0, 1);\n    \t\tr2[i] = (ans2 * ans3) + (ans2 * ans4) * cd(0, 1);\n    \t}\n    \tfft(r1, 1); fft(r2, 1);\n        vl ret(n);\n    \tF0R(i,n) {\n    \t\tll av = (ll)round(r1[i].real());\n    \t\tll bv = (ll)round(r1[i].imag()) + (ll)round(r2[i].real());\n    \t\tll cv = (ll)round(r2[i].imag());\n    \t\tav %= mod, bv %= mod, cv %= mod;\n    \t\tret[i] = (av << 30) + (bv << 15) + cv;\n    \t\tret[i] %= mod; ret[i] += mod; ret[i] %= mod;\n    \t}\n    \tret.resize(s);\n    \treturn ret;\n    }\n}\n\nll po3[600001], fac[1000001], ifac[1000001];\n\nll po (ll b, ll p) { return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD; }\nll inv (ll b) { return po(b,MOD-2); }\n\nll ad(ll a, ll b) { return (a+b)%MOD; }\nll sub(ll a, ll b) { return (a-b+MOD)%MOD; }\nll mul(ll a, ll b) { return a*b%MOD; }\nll divi(ll a, ll b) { return mul(a,inv(b)); }\n\nvl bb, cc;\n\nvoid init() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    po3[0] = 1;\n    FOR(i,1,600001) po3[i] = mul(po3[i-1],3);\n    fac[0] = ifac[0] = 1;\n    FOR(i,1,1000001) {\n        fac[i] = mul(i,fac[i-1]);\n        ifac[i] = inv(fac[i]);\n    }\n}\n\nint main() {\n\tinit();\n    // 3^{B+C}*binom(a+b+c-B-C,a-1,b-B,c-C) // B and C not 0 \n    // 3^B/(b-B)!, 3^C/(c-C)!\n    \n    int a,b,c; cin >> a >> b >> c; a --;\n    F0R(B,b+1) bb.pb(mul(po3[B],ifac[b-B]));\n    F0R(C,c+1) cc.pb(mul(po3[C],ifac[c-C]));\n    \n    vl z = FFT::conv(bb,cc,MOD);\n    ll ans = 0;\n    F0R(i,sz(z)) {\n    \t// cout << i << \" \" << z[i] << \" \" << fac[a+b+c-i] << \" \" << ifac[a] << \"\\n\";\n        ans = ad(ans,mul(z[i],mul(fac[a+b+c-i],ifac[a])));\n    }\n    cout << ans;\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int Mod = 1e9 + 7;\nconst int N = 3e6 + 10;\n\nint n, m, k;\nLL pw2[N], pw3[N], fac[N], inv[N];\n\nLL Power(LL a, LL b) {\n\tLL c = 1;\n\tfor (; b; b >>= 1, (a *= a) %= Mod)\n\t\tif (b & 1)\n\t\t\t(c *= a) %= Mod;\n\treturn c;\n}\n\nvoid Init() {\n\tpw2[0] = pw3[0] = 1;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw2[i] = pw2[i - 1] * 2 % Mod;\n\t\tpw3[i] = pw3[i - 1] * 3 % Mod;\n\t\tfac[i] = fac[i - 1] * i % Mod;\n\t}\n\tinv[N - 1] = Power(fac[N - 1], Mod - 2);\n\tfor (int i = N - 2; i; --i)\n\t\tinv[i] = inv[i + 1] * (i + 1) % Mod;\n}\n\nLL Binom(int m, int n) {\n\tif (n > m)\n\t\treturn 0;\n\treturn fac[m] * inv[n] % Mod * inv[m - n] % Mod;\n}\n\nvoid Solve() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tLL fb = 0;\n\tLL fc = 0;\n\tLL ans = 0;\n\tfor (int i = n; i <= n + m + k; ++i) {\n\t\tLL cnt = Binom(i - 1, n - 1);\n\t\tif (i - n == m + 1) \n\t\t\tfb = 1;\n\t\telse if (i - n > m + 1) \n\t\t\tfb = (fb * 2 + Binom(i - n - 1, m)) % Mod;\n\t\tif (i - n == k + 1)\n\t\t\tfc = 1;\n\t\telse if (i - n > k + 1)\n\t\t\tfc = (fc * 2 + Binom(i - n - 1, k)) % Mod;\n\t\tLL f = (pw2[i - n] - fb + Mod - fc + Mod) % Mod;\n\t\t(ans += f * cnt % Mod * pw3[n + m + k - i]) %= Mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n\n\tInit();\n\tSolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nconst int kN = 600000 + 5;\nconst int MOD = (int)1e9 + 7;\nint Inv[kN], Finv[kN], F[kN], n, m, k;\nint pascal[kN];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return F[a] * 1LL * Finv[b] % MOD * Finv[a - b] % MOD;\n}\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nint power(int a, int b, int p)\n{\n    int ret = 1;\n    for ( ; b; b >>= 1, a = a * 1LL * a % MOD)\n        if (b & 1)\n            ret = ret * 1LL * a % MOD;\n    return ret;\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kN; ++ i)\n        Inv[i] = (MOD - MOD / i) * 1LL * Inv[MOD % i] % MOD;\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kN; ++ i) {\n        F[i] = F[i - 1] * 1LL * i % MOD;\n        Finv[i] = Finv[i - 1] * 1LL * Inv[i] % MOD;\n    }\n    scanf(\"%d%d%d\", &n, &m, &k);\n    pascal[0] = 1;\n    for (int i = 1; i <= m + k; ++ i) {\n        pascal[i] = (pascal[i - 1] << 1) % MOD;\n        if (i >= m + 1) add(pascal[i], MOD - binom(i - 1, m));\n        if (i >= k + 1) add(pascal[i], MOD - binom(i - 1, i - (k + 1)));\n    }\n    int result = 0;\n    int t = n + m + k;\n    for (int i = n; i <= t; ++ i) {\n        add(result, binom(i - 1, n - 1) * 1LL * power(3, t - i, MOD) % MOD * pascal[i - n] % MOD);\n    }\n    printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define lld long long\n#define pii pair<int,int>\n#define pll pair<lld,lld>\n#define pb push_back\n#define next nextt\n#define Inf 1000000000\n#define Linf 1000000000000000000LL\n#define Mod 1000000007\n\nusing namespace std;\n\nint N,M,K; lld ans;\nlld fact[900002],inv[900002],three[900002],two[900002];\n\nlld mul(lld x,lld y){\n\tif(y == 0) return 1;\n\tlld tmp = mul(x,y/2);\n\ttmp *= tmp; tmp %= Mod;\n\tif(y%2 == 1){\n\t\ttmp *= x;\n\t\ttmp %= Mod;\n\t}\n\treturn tmp;\n}\nlld comb(lld x,lld y){\n\treturn (fact[x]*inv[x-y]%Mod)*inv[y]%Mod;\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\tfact[0] = inv[0] = three[0] = two[0] = 1;\n\tfor(int i=1; i<=900000; i++){\n\t\tfact[i] = (fact[i-1]*i)%Mod;\n\t\tinv[i] = mul(fact[i],Mod-2);\n\t\tthree[i] = (three[i-1]*3)%Mod;\n\t\ttwo[i] = (two[i-1]*2)%Mod;\n\t}\n\tif(M < K) swap(M,K);\n\tfor(int i=0; i<=M+K; i++){\n\t\tlld tmp;\n\t\tif(i <= K) tmp = two[i];\n\t\telse{\n\t\t\ttmp = 0;\n\t\t\tfor(int j=max(0,i-K); j<=min(i,M); j++){\n\t\t\t\ttmp += comb(i,j);\n\t\t\t\ttmp %= Mod;\n\t\t\t}\n\t\t}\n\t\ttmp *= comb(N-1+i,N-1); tmp %= Mod;\n\t\ttmp *= three[M+K-i]; tmp %= Mod;\n\t\tans += tmp; ans %= Mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)));\n#define Mx(a , b) ((a) > (b) ? (a) : (b))\n#define Mn(a , b) ((a) < (b) ? (a) : (b))\n\nconst double EPS = 1e-10;\nconst int INF = 2147483647;\nconst LL mod = 1e9 + 7;\n\nint N , M , K;\nLL c[600010];\nLL t[600010];\nLL p[900010];\nLL r[600010];\nLL ans;\n\nLL conv(int a , int b){\n\treturn (p[a] * r[b] % mod) * r[a - b] % mod;\n}\n\nint main(){\n\tscanf(\"%d%d%d\" , &N , &M , &K);\n\tp[0] = p[1] = 1;\n\tfor(int i = 2 ; i < N + M + K ; ++i){\n\t\tp[i] = (p[i - 1] * i) % mod;\n\t}\n\tint s = Mx(K + M , N);\n\tLL x = p[s];\n\tr[s] = 1;\n\tfor(int i = (int)mod - 2 ; i > 0; i /= 2 , x = (x * x) % mod){\n\t\tif(i % 2 == 1) r[s] = (r[s] * x) % mod;\n\t}\n\tfor(int i = s - 1 ; i >= 0 ; --i){\n\t\tr[i] = r[i + 1] * (i + 1) % mod;\n\t}\n\tc[0] = t[0] = 1;\n\tfor(int i = 1 ; i <= M + K ; ++i){\n\t\tt[i] = (t[i - 1] * 3) % mod;\n\t}\n\tif(K < M){\n\t\tK ^= M;\n\t\tM ^= K;\n\t\tK ^= M;\n\t}\n\ts = K + M;\n\tfor(int i = 1 ; i <= M ; ++i){\n\t\tc[i] = c[i - 1] * 2 % mod;\n\t}\n\tc[s] = conv(s , K);\n\tfor(int i = s - 1 ; i > M ; --i){\n\t\tc[i] = (c[i + 1] + conv(i , K) + conv(i , M)) * r[2] % mod;\n\t}\n\tfor(int i = s ; i >= 0 ; --i){\n\t\tx = p[i + N - 1] * t[s - i] % mod;\n\t\tx = x * r[N - 1] % mod;\n\t\tx = x * c[i] % mod;\n\t\tx = x * r[i] % mod;\n\t\tans += x;\n\t\tans %= mod;\n\t}\n\tprintf(\"%lld\\n\" , ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef double db;\n#define ls(x) x<<1\n#define rs(x) x<<1|1\n#define low(x) (x&-x)\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define X first\n#define Y second\n#ifdef _DEBUG\n    const int N=5e3+10;\n#else\n    const int N=3e5+10;\n#endif\nconst ll mod=1e9+7;\ntemplate<typename T> inline T gcd(T a,T b){return !b?a:gcd(b,a%b);}\ntemplate<typename T> inline T q_pow(T a,T x){T ans=1,tmp=a;while(x){if(x&1)(ans*=tmp)%=mod;(tmp*=tmp)%=mod;x>>=1;}return ans;}\ntemplate<typename T> inline void re(T &N){int f=1;char c;while((c=getchar())< '0'||c> '9')if(c=='-')f=-1;N=c-'0';while((c=getchar())>='0'&&c<='9')N=N*10+c-'0';N*=f;}\nint m,n,k,t=1,st,en;\nll p[N];\nll mul[N],inv[N];\ninline ll C(int m,int n)\n{\n    if(m< 0||m> n)return 0;\n    return mul[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main()\n{\n    // freopen(\"data.txt\",\"r\",stdin);\n    p[0]=1;\n    for(int i=1;i< N;i++)p[i]=p[i-1]*3%mod;\n    inv[0]=mul[0]=1;\n    for(int i=1;i< N;i++)mul[i]=mul[i-1]*i%mod,inv[i]=q_pow(mul[i],mod-2);\n    re(n);re(m);re(k);\n    ll ans=0,s1=0,s2=0;\n    for(int i=0;i<=m+k;i++)\n    {\n        if(!i)s1=1;\n        else if(i<=m)(s1*=2)%=mod;\n        else s1=(((s1-C(m,i-1))*2+C(m,i))%mod+mod)%mod;\n\n        if(i-k> 0)(s2=s2*2+C(i-k,i))%=mod;\n\n        (ans+=C(n-1,n+i-1)*p[m+k-i]%mod*(s1-s2+mod)%mod)%=mod;\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, K, v[600009];\nconst int mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nint fac[1000009], inv[1000009], p3[1000009];\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = power (fac[lim], mod - 2);for (int i=lim - 1; i>=1; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n\nint main ()\n{\n/freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &M, &K), Prec (900003), p3[0] = 1;\nfor (int i=1; i<=900000; i++)\n    p3[i] = add (add (p3[i - 1], p3[i - 1]), p3[i - 1]);\n/*for (int i=0; i<=M; i++)\n    for (int j=0; j<=K; j++)\n        adto (v[i + j], comb (i + j, i));*/\n/*\nsa consideram un dreptunghi cu un colt in (0, 0) si unul in (M, K)\npentru fiecare diagonala secundara, vrem sa stim numarul de drumuri\ncare duc in diagonala aia\n*/\nv[0] = 1;\nif (M > K) swap (M, K); ///M <= K\nfor (int i=1; i<=M + K; i++)\n{\n    v[i] = add (v[i - 1], v[i - 1]);\n    if (i > M) v[i] = subtract (v[i], comb (i - 1, M));\n    if (i > K) v[i] = subtract (v[i], comb (i - 1, K));\n}\nint ans = 0;\nfor (int i=0; i<=M + K; i++)\n{\n    v[i] = mul (v[i], p3[M + K - i]);\n    adto (ans, mul (v[i], comb (i + N - 1, N - 1)));\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// Problem: \n// \t\t\tF - Card Game for Three\n// \t\t\tEditorial\n// \t\t\n// Contest: AtCoder - AtCoder Regular Contest 061\n// URL: https://atcoder.jp/contests/arc061/tasks/arc061_d?lang=en\n// Memory Limit: 256 MB\n// Time Limit: 3000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")\n//\n//#include <immintrin.h>\n//#include <emmintrin.h>\n\n#include <bits/stdc++.h>\n//#pragma GCC optimize(\"O2\")\n#define vi vector<int>\n#define pii pair<int, int >\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define LL long long\n#define rep(i,a,n) for (int i=a;i<=n;i++)\n#define per(i,a,n) for (int i=n;i>=a;i--)\n#define all(x) (x).begin(), (x).end()\n#define all2(x,n) (x+1), (x+1+n)\n#define sz(x) ((int)(x).size())\n#define mod(x) ((x)%MOD)\n#define debug(x) cerr<<#x<<\" : \"<<x<<endl\n#define mt make_tuple\n#define eb emplace_back\n#define o(X) (1<<(X))\n#define oL(X) (1LL<<(X))\n#define contain(S,X) (((S)&o(X))!=0)\n#define containL(S,X) (((S)&oL(X))!=0)\n#define ppt(x) __builtin_popcount(x)\nusing namespace std;\nconst int INF=0x3f3f3f3f,N=1e6+5,MOD=1e9+7;\nconst LL INF_LL=0x3f3f3f3f3f3f3f3fLL;\ninline int getplc(int x,int y) { return (x>>y)&1; }\ntemplate<typename T>\nT square(T x) {return x*x;}\nLL qpow(LL a,LL b=MOD-2,LL _MOD=MOD){\n\tLL res=1;\n\tfor(;b;b>>=1,a=a*a%_MOD){\n\t\tif(b&1)res=res*a%_MOD;\n\t}\n\treturn res;\n}\n// Smax\n//int Smax() { return -INF; }\ntemplate <typename T>\nT Smax(T x) { return x; }\ntemplate<typename T, typename... Args>\nT Smax(T a, Args... args) { return max(a, Smax(args...)); }\n// Smin\ntemplate <typename T>\nT Smin(T x) { return x; }\ntemplate<typename T, typename... Args>\nT Smin(T a, Args... args) { return min(a, Smin(args...)); }\ntemplate <typename T>\n// erro\n#define errorl(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); errl(_it, args); }\n\nvoid errl(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid errl(istream_iterator<string> it, T a, Args... args) {\n\tcerr << *it << \" = \" << a << endl;\n\terrl(++it, args...);\n}\n\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); cerr<<endl;}\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n\tcerr << *it << \"=\" << a << \" # \";\n\terr(++it, args...);\n}\nvoid Solve();\nint main() {\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\",\"r\",stdin);\n//    freopen(\"o1.txt\",\"w\",stdout);\n#endif\n\tios::sync_with_stdio(false);cin.tie(0),cout.tie(0);\n\tSolve();\n\treturn 0;\n}\n\n//////////////////////////////////////////////////////////////////\n\nint fac[N],inv[N];\nvoid init(int n){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=(LL)fac[i-1]*i%MOD;\n\tfor(int i=1;i<=n;i++)inv[i]=qpow(fac[i],MOD-2,MOD);\n}\nint Comb(int n,int m){\n\tif(n-m>=0&&m>=0) return 1ll*fac[n]*inv[n-m]%MOD*inv[m]%MOD;\n\telse return 0;\n}\n\nint pow3[N];\nvoid Solve(){\n  pow3[0]=1;\n  rep(i,1,N-1)pow3[i]=(LL)pow3[i-1]*3%MOD;\n  init(1e6+5);\n  \n  int n,m,k;\n  cin>>n>>m>>k;\n  n--;\n  \n  LL j=1,ans=0;\n  for(int i=0;i<=m+k;i++){\n    ans=(ans+(LL)Comb(n+i,n)*pow3[m+k-i]%MOD*j)%MOD;\n    if(i<k)\n        j=j*2ll%MOD;\n    else if(i<m)\n        j=(j*2ll-Comb(i,k))%MOD;\n    else    \n        j=(j*2ll-Comb(i,k)-Comb(i,m))%MOD;\n  }\n  ans=(ans+MOD)%MOD;\n  cout<<ans<<endl;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <functional>\n#include <array>\n\nusing namespace std;\n\nconstexpr int mod = 1000000007;\n\n// 二項係数（組み合わせ数）を計算して返す\ntemplate <typename T, unsigned int N>\nT calcBinomial(int n, int r)\n{\n    static std::array<std::array<T, (N - 2) / 2>, N - 3> table;\n    if (n > N || n < 0 || r < 0 || r > n){ // nかrが範囲外の場合\n        return 0;\n    }else if (r == 1 || r == n - 1){ // 再帰の終わり\n        return n;\n    }else if (r == 0 || r == n){\n        return 1;\n    }else{ // n >= 4 &&  2 <= r <= (n - 2)\n        if (r > n / 2) r = n - r; // nCr == nCn-r\n        auto &val = table[n - 4][r - 2];\n        if (val != 0){ // 既にテーブルに値が乗っている場合\n            return val;\n        }else{ // 二項係数を再帰的に計算する\n            val = (calcBinomial<T, N>(n - 1, r - 1) + calcBinomial<T, N>(n - 1, r)) % mod;\n            return val;\n        }\n    }\n}\n\ntemplate <typename T> // 返り値とテーブルの型\nclass Power3 {\n    std::vector<T> table;\npublic:\n    Power3(int max) : table(max) // max:テーブルのサイズ\n    {\n        table[0] = 3;\n        for (int i = 1; i < max; ++i){\n            table[i] = (static_cast<long long>(table[i - 1]) * 3) % mod;\n        }\n    }\n\n    T operator () (int n)\n    {\n        if (n < 0) return 0;\n        if (n == 0) return 1;\n        return table[n - 1];\n    }\n};\n\nint main()\n{\n    int N, M, K;\n    scanf(\"%d %d %d\\n\", &N, &M, &K);\n\n    auto nCr = calcBinomial<int, 3000>;\n    Power3<int> pow3(2000);\n\n    int result = 0;\n    for (int b = 0; b <= M; ++b){\n        for (int c = 0; c <= K; ++c){\n            result += ((((static_cast<long long>(nCr(N - 1 + b + c, N - 1)) * nCr(b + c, b)) % mod) * pow3(M + K - b - c)) % mod);;\n            result %= mod;\n        }\n    }\n    printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define F(i,a,b) for(int i=a;i<=(b);++i)\n#define LL long long\n#define Mod 1000000007\n\nLL N,M,K,Ans,P3[600001];\nLL Frc[900001],Fnv[900001];\n\ninline LL C(int N,int M){\n\tif( M<0 || M>N ) return 0ll;\n\treturn Frc[N]*Fnv[M]%Mod*Fnv[N-M]%Mod;\n}\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&N,&M,&K);\n\t\n\tP3[0]=1;\n\tF(i,1,M+K) P3[i]=P3[i-1]*3%Mod;\n\t\n\tFrc[0]=1;\n\tF(i,1,N+M+K) Frc[i]=Frc[i-1]*i%Mod;\n\t\n\tFnv[0]=Fnv[1]=1;\n\tF(i,2,N+M+K) Fnv[i]=(Mod-Mod/i)*Fnv[Mod%i]%Mod;\n\tF(i,2,N+M+K) Fnv[i]=Fnv[i-1]*Fnv[i]%Mod;\n\t\n\tLL Thi=1;\n\tF(i,N,N+M+K){\n\t\tAns=(Ans+P3[N+M+K-i]*C(i-1,N-1)*Thi)%Mod;\n\t\tThi=(2*Thi-C(i-N,i-N-K)-C(i-N,M)+2*Mod)%Mod;\n\t}\n\t\n\tprintf(\"%lld\",Ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define lld long long\n#define pii pair<int,int>\n#define pll pair<lld,lld>\n#define pb push_back\n#define next nextt\n#define Inf 1000000000\n#define Linf 1000000000000000000LL\n#define Mod 1000000007\n\nusing namespace std;\n\nint N,M,K; lld ans;\nlld fact[900002],inv[900002],three[900002],two[900002];\n\nlld mul(lld x,lld y){\n\tif(y == 0) return 1;\n\tlld tmp = mul(x,y/2);\n\ttmp *= tmp; tmp %= Mod;\n\tif(y%2 == 1){\n\t\ttmp *= x;\n\t\ttmp %= Mod;\n\t}\n\treturn tmp;\n}\nlld comb(lld x,lld y){\n\treturn (fact[x]*inv[x-y]%Mod)*inv[y]%Mod;\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\tfact[0] = inv[0] = three[0] = two[0] = 1;\n\tfor(int i=1; i<=900000; i++){\n\t\tfact[i] = (fact[i-1]*i)%Mod;\n\t\tinv[i] = mul(fact[i],Mod-2);\n\t\tthree[i] = (three[i-1]*3)%Mod;\n\t\ttwo[i] = (two[i-1]*2)%Mod;\n\t}\n\tif(M < K) swap(M,K);\n\tfor(int i=0; i<=M+K; i++){\n\t\tlld tmp;\n\t\tif(i <= K) tmp = two[i];\n\t\telse{\n\t\t\ttmp = 0;\n\t\t\tfor(int j=max(0,i-K); j<=min(i,M); j++){\n\t\t\t\ttmp += comb(i,j);\n\t\t\t\ttmp %= Mod;\n\t\t\t}\n\t\t}\n\t\ttmp *= comb(N-1+i,N-1); tmp %= Mod;\n\t\ttmp *= three[M+K-i]; tmp %= Mod;\n\t\tans += tmp;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> famod, simod, fimod;\n\nvoid create_fact_mod(int num){\n    famod[0] = 1;\n    famod[1] = 1;\n    for(int i=2; i<=num; i++){\n        famod[i] = famod[i-1] * i % MOD;\n    }\n}\n\nvoid create_seq_inv_mod(int num){\n    simod[0] = 1;\n    simod[1] = 1;\n    for(int i=2; i<=num; i++){\n        simod[i] = (MOD - MOD/i) * simod[MOD%i] % MOD;\n    }\n}\n\nvoid create_fact_inv_mod(int num){\n    fimod[0] = 1;\n    fimod[1] = 1;\n    for(int i=2; i<=num; i++){\n        fimod[i] = fimod[i-1] * simod[i] % MOD;\n    }\n}\n\nvoid create_mod_tables(int num){\n    famod.resize(num+1);\n    simod.resize(num+1);\n    fimod.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return famod[n] * fimod[n-k] % MOD * fimod[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return famod[n] * fimod[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t mod_inv(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\nint main(){\n    int N, M, K;\n    cin >> N >> M >> K;\n    create_mod_tables(N+M+K);\n\n    int64_t sum = 1;\n    int64_t c = power_mod(3, M+K);\n    int64_t ans = c;\n    for(int t=1; t<=M+K; t++){\n        mul(c, mod_inv(3) * (N-1+t) % MOD * mod_inv(t) % MOD);\n        mul(sum, 2);\n        if(0 <= t-K-1) add(sum, MOD - comb_mod(t-1, t-K-1));\n        if(M+1 <= t) add(sum, MOD - comb_mod(t-1, M));\n        add(ans, c * sum);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Generated by powerful Codeforces Tool\n * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)\n * Author: alireza_kaviani\n * Time: 2020-06-08 15:10:32\n**/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\n\n#define all(x)                      (x).begin(),(x).end()\n#define Sort(x)                     sort(all((x)))\n#define X                           first\n#define Y                           second\n#define sep                         ' '\n#define endl                        '\\n'\n#define SZ(x)                       ll(x.size())\n\nll poww(ll a, ll b, ll md) {\n    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));\n}\n\nconst ll MAXN = 1e4 + 10;\nconst ll LOG = 22;\nconst ll INF = 8e18;\nconst ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;\n\nll n , m , k , ans , pw3[MAXN] , fact[MAXN] , inv[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\n    fact[0] = 1; inv[0] = 1;\n    pw3[0] = 1;\n    for(int i = 1 ; i < MAXN ; i++) pw3[i] = pw3[i - 1] * 3 % MOD;\n    for(int i = 1 ; i < MAXN ; i++) fact[i] = fact[i - 1] * i % MOD , inv[i] = poww(fact[i] , MOD - 2 , MOD);\n    cin >> n >> m >> k;\n    for(int i = 0 ; i <= m ; i++){\n        for(int j = 0 ; j <= k ; j++){\n            if(i == 0 && j != k)    continue;\n            if(j == 0 && i != m)    continue;\n            ll cur = fact[n + m + k - i - j] * inv[n] % MOD * inv[m - i] % MOD * inv[k - j] % MOD * pw3[i + j];\n            ans += cur % MOD;\n        }\n    }\n    cout << ans % MOD << endl;\n\n    return 0;\n}\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nconst int mod=1000000007;\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\ts=s*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nll fact[3341919];\nll Comb(ll x,ll y){\n\treturn fact[x]*modInv(fact[y])%mod*modInv(fact[x-y])%mod;\n}\n\nint main(){\n\tll n=read()+1,m=read()+1,k=read()+1;\n\tfact[0]=1;\n\tFOR(i,1,3341919)\n\t\tfact[i]=fact[i-1]*i%mod;\n\tll ans=0;\n\tREP(b,m)\n\t\tREP(c,k)\n\t\t\tans=(ans+Comb(n-2+b+c,n-2)*Comb(b+c,b)%mod*modPow(3,m-1-b+k-1-c))%mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 9e5+20 , Mod = 1e9+7;\ninline int add(int a,int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a,int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a,int b) { return 1LL * a * b % Mod; }\ninline void Add(int &a,int b) { a = add( a , b ); }\ninline void Sub(int &a,int b) { a = sub( a , b ); }\ninline void Mul(int &a,int b) { a = mul( a , b ); }\ninline int quickpow(int a,int b) { int res = 1; for (;b;Mul(a,a),b>>=1) if ( 1 & b ) Mul(res,a); return res; }\nint n,m,k,fac[N],inv[N],Pow3[N],ans;\ninline void init(void)\n{\n    fac[0] = inv[0] = Pow3[0] = 1;\n    for (int i=1;i<=n+m+k;i++)\n        fac[i] = mul( fac[i-1] , i ) , Pow3[i] = mul( Pow3[i-1] , 3 );\n    inv[n+m+k] = quickpow( fac[n+m+k] , Mod-2 );\n    for (int i=n+m+k-1;i>=1;i--)\n        inv[i] = mul( inv[i+1] , i+1 );\n}\ninline int C(int n,int m)\n{\n    if ( n < m || m < 0 || n < 0 ) return 0;\n    return mul( fac[n] , mul( inv[m] , inv[n-m] ) );\n}\ninline int getval(void)\n{\n    int res = 0;\n    for (int i=0;i<=m;i++) Add( res , C(k,i) );\n    return res;\n}\ninline void solve(void)\n{\n    int val = 1;\n    for (int i=0;i<=m+k;i++)\n    {\n        Add( ans , mul( mul( C(i+n-1,n-1) , Pow3[m+k-i] ) , val ) );\n        if ( i < k ) Mul( val , 2 );\n        else if ( i < m ) val = sub( mul( val , 2 ) , C(i,k) );\n        else val = sub( mul( val , 2 ) , add( C(i,m) , C(i,k) ) );\n    }\n}\nint main(void)\n{\n    scanf(\"%d%d%d\",&n,&m,&k);\n    if ( k > m ) swap( k , m );\n    init();\n    solve();\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define intt long long \nusing namespace std;\nconst int maxx = 1e5+1314;\nconst int M = 1e9+7;\nintt qsm(intt x,int k=M-2){\n\tintt ans=1;\n\twhile(k){if(k&1)ans=ans*x%M;x=x*x%M;k>>=1;}\t\n\treturn ans%M;\n}\t\nintt times[maxx];\nintt inv[maxx];\nintt tb[maxx];\nvoid pre(){\n\tint mx=maxx-20;\n\ttimes[0]=1;tb[0]=1;\n\tfor(int i=1;i<=mx;i++)times[i]=times[i-1]*i%M,tb[i]=tb[i-1]*3%M;\n\tinv[mx]=qsm(times[mx]);\n\tfor(int i=mx-1;i;i--)inv[i]=inv[i+1]*(i+1)%M;\n\tinv[0]=1;\n}\t\nintt C(int a,int b){\nif(b==-1)return 1;\nreturn times[a]*inv[b]%M*inv[a-b]%M;}\nintt n,m,k;\nint read(){int k;cin>>k;return k;}\nintt dp(intt N){\t\n\tintt ans=0;\n\tfor(int i=0;i<=N;i++){\t\n\t\tif(i<=m&&(N-i)<=k){\t\n\t\t\tans+=C(N,i);\n//\t\t\tcout<<i<<\"___\"<<N-i<<endl;\n\t\t}\t\n\t\tans%=M;\n\t}\t\n\treturn ans;\n} \t\nint main(){\t\n\tpre();\n\tn=read();m=read();k=read();\n\tintt N= n+m+k;\t\n\tintt ans=0;\n\tfor(int i=n;i<=N;i++){\t\n\t\tans+=tb[N-i]*C(i-1,i-n)%M*dp(i-n)%M;\n\t\tans%=M;\n//\t\tcout<<ans<<\"??\"<<C(i-1,i-n)<<endl;\n\t}\t\n\tcout<<ans<<endl;\n\twhile(cin>>n>>m)cout<<C(n,m)<<endl;\n\treturn 0;\t\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,m,k;\nconst int FMAX = 600002;\nll fact[FMAX];\nll ifact[FMAX];\n\nll modpow(ll a,ll b,ll c){\n  ll r = 1;\n  while(b){\n    if(b&1)r=r*a%c;\n    a=a*a%c;\n    b>>=1;\n  }\n  return r;\n}\nll modinv(ll a,ll c){\n  return modpow(a,c-2,c);\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&m,&k);\n  // fact init\n  fact[0] = 1;\n  FOR(i,1,FMAX)fact[i]=fact[i-1]*i%MOD;\n  ifact[FMAX-1]=modinv(fact[FMAX-1],MOD);\n  FORR(i,0,FMAX-1)ifact[i]=ifact[i+1]*(i+1)%MOD;\n  // a == n-1 && b <= m && c <= k\n  ll ans = 0;\n  int a = n-1;\n  ll bipow = 1;\n  ll subsum = 0;\n  ll tris = modpow(3,m+k,MOD);\n  ll invtri = modinv(3,MOD);\n  ll factabc = (a==0?1:fact[a-1]);\n  int befbeg,befend;\n  FOR(s,0,m+k+1){\n    int abc = a+s;\n    if(abc!=0){\n      factabc = factabc*abc%MOD;\n    }\n    ll unit = factabc*ifact[a]%MOD*ifact[s]%MOD*tris%MOD;\n    tris = tris*invtri%MOD;\n\n    int beg = max(s-k,0);\n    int end = min(s,m);\n    if(s>0){\n      bipow <<= 1;\n      subsum <<= 1;\n      if(bipow>=MOD)bipow-=MOD;\n      if(subsum>=MOD)subsum-=MOD;\n      if(befbeg+1==beg){\n        subsum += fact[s-1]*ifact[befbeg]%MOD*ifact[s-1-befbeg]%MOD;\n        if(subsum>=MOD)subsum-=MOD;\n      }\n      if(befend==end){\n        subsum += fact[s-1]*ifact[befend]%MOD*ifact[s-1-befend]%MOD;\n        if(subsum>=MOD)subsum-=MOD;\n      }\n    }\n    befbeg = beg;\n    befend = end;\n    ans += unit*(bipow+MOD-subsum)%MOD;\n    if(ans>=MOD)ans-=MOD;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n\ncs ll mod=1000000007;\n\nll fac[1000001]={1,1},inv[1000001]={1,1},ifac[1000001]={1,1};\n\ninline\nll C(int n,int m){\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint n,m,k,maxn;\n\nsigned main(){\n\t\n\tfor(int re i=2;i<=1000000;++i)\n\tfac[i]=fac[i-1]*i%mod,\n\tinv[i]=(mod-mod/i)*inv[mod%i]%mod,\n\tifac[i]=ifac[i-1]*inv[i]%mod;\n\t\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\t--n;\n\tmaxn=max(n,m+k);\n\tll sum=1,ans=1;\n\tfor(int re i=1;i<=m+k;++i){\n\t\tsum=(sum*2+mod)%mod;\n\t\tif(i>m)sum=(sum+mod-C(i-1,m))%mod;\n\t\tif(i>k)sum=(sum+mod-C(i-1,k))%mod;\n\t\tans=ans*3%mod;\n\t\tans=(ans+C(n+i,i)*sum%mod)%mod;\n\t}\n\tcout<<(ans%mod+mod)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 6, mod = 1e9 + 7;\nint N, M, K, L, R;\nlong long ans, last;\nlong long fac[maxn], inv[maxn], p[maxn];\n\ninline long long fpow(long long t, int x){\n    long long ret = 1, tmp = t;\n    while(x){\n        if(x & 1) ret = ret * tmp % mod;\n        tmp = tmp * tmp % mod; x >>= 1;\n    }\n    return ret;\n}\n\ninline void prepare(){\n    fac[0] = 1; inv[0] = 1; p[0] = 1;\n    for(int i = 1; i <= N + M + K; ++i) fac[i] = fac[i - 1] * i % mod, p[i] = p[i - 1] * 3 % mod;\n    inv[N + M + K] = fpow(fac[N + M + K], mod - 2);\n    for(int i = N + M + K - 1; i >= 1; --i) inv[i] = inv[i + 1] * (i + 1) % mod;\n}\n\ninline long long C(int n, int m){\n    if(m > n) return 0;\n    return fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\ninline long long calc(int l, int r, int x){\n    long long ret = last;\n    ret = last * 2 - C(x - 1, L) - C(x - 1, R) + C(x, L);\n    while(R < r){R++; ret += C(x, R);}\n    while(L < l){L++; ret -= C(x, L - 1);}\n    while(ret < 0) ret += mod; last = ret % mod;\n\treturn last;\n}\n\n\n\ninline void workk(){\n    for(int len = N - 1; len < N + M + K; ++len){\n        long long ret = p[N + M + K - len - 1] * C(len, N - 1) % mod;\n        if(len == N - 1){last = 1; ans = ret * last % mod;}\n        else ans = (ans + ret * calc(max(0, len - (N - 1) - K), min(M, len - (N - 1)), len - (N - 1))) % mod;\n    }\n    cout << ans;\n}\n\nint main()\n{\n    scanf(\"%d%d%d\", &N, &M, &K);\n    prepare();\n    workk();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n/*==========================================================*/\n/*    Template ver 2017-0720    |    Created by JollyBee    */\n/* DOMINUS pascit me, et nihil mihi deerit (Psalmorum 23:1) */\n/*==========================================================*/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<pii> vii;\nconst double EPS=(double)1e-9;\nconst double PI=(double)acos(-1.0);\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define FOR(i,n) for(int i=0;i<n;i++)\n#define REPP(i,l,r,c) for(int i=l;i<=r;i+=c)\n#define REP(i,l,r) REPP(i,l,r,1)\n#define FORD(i,n) for(int i=n-1;i>=0;i--)\n#define REVV(i,l,r,c) for(int i=l;i>=r;i-=c)\n#define REV(i,l,r) REVV(i,l,r,1)\n//random\nint irand(int lo, int hi){\n    return (((double)rand())/(RAND_MAX+1.0)) * (hi-lo+1) + lo;\n}\n//ll to string\nstring toString(ll x) {\n    stringstream ss;\n    ss << x;\n    return ss.str();\n}\n//string to ll\nll toNumber(string S) {\n    ll ret;\n    sscanf(S.c_str(),\"%lld\",&ret);\n    return ret;\n}\n// std::fill(start, end, value);\n// for(auto it: DS){}\n\nconst int INF=(int)2e9;\nconst ll MOD=(ll)1e9+7;\n/*==========================================================*/\n/*                     END OF TEMPLATE                      */\n/* DOMINUS pascit me, et nihil mihi deerit (Psalmorum 23:1) */\n/*==========================================================*/\n\nll fast(ll a, ll p){\n    if(p == 0) return (ll)1;\n    ll res = fast(a, p>>1);\n    res = (res * res) % MOD;\n    if(p&1) res = (res * a) % MOD;\n    return res;\n}\n\nconst int N = (int)1e6;\n\npll fact[N+5];\nint start(){\n    fact[0] = mp((ll)1, (ll)1);\n    REP(i,1,N){\n        fact[i].fi = (fact[i-1].fi * (ll)i) % MOD;\n        fact[i].se = fast(fact[i].fi, MOD-2);\n    }\n    return 0;\n}\n\nll nCk(int n, int k){\n    ll num = fact[n].fi;\n    ll denum = (fact[n-k].se * fact[k].se) % MOD;\n    return (num * denum) % MOD;\n}\n\nint main(){\n    start();\n    //\n    int n,m,k; scanf(\"%d %d %d\", &n, &m, &k);\n    //\n    ll temp = 1, res = 0;\n    REP(i,n,n+m+k){\n        ll select_seat = nCk(i-1,i-n);\n        ll combination = temp;\n        ll random = fast(3, n+m+k - i);\n        //\n        ll ret = (select_seat * combination) % MOD;\n        res += (ret * random) % MOD;\n        // calc new temp\n        temp = ((ll)2 * temp) % MOD;\n        if(i-n > m-1){\n            temp = (temp + MOD - nCk(i-n, m)) % MOD;\n        }\n        if(i-n > k-1){\n            temp = (temp + MOD - nCk(i-n, k)) % MOD;\n        }\n    }\n    // print\n    printf(\"%lld\\n\", res % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MOD 1000000007\n#define N 300000\nusing namespace std;\ntypedef long long LL;\nLL mod_pow(LL base, LL exp)\n{\n\tif(exp==0) return 1;\n\tif(exp&1) return (mod_pow(base,exp-1)*base)%MOD;\n\telse return mod_pow((base*base)%MOD,exp/2);\n}\nLL fac[3*N+1];\nLL fac_inv[3*N+1];\nLL C(LL n, LL k)\n{\n\tif(k < 0 || n < k) return 0;\n\tLL num = fac[n];\n\tLL den = (fac_inv[n-k]*fac_inv[k])%MOD;\n\treturn (num*den)%MOD;\n}\nint main()\n{\n\tfac[0] = 1;\n\tfor(LL n = 1; n <= 3*N; n++)\n\t\tfac[n] = (fac[n-1]*n)%MOD;\n\tfac_inv[3*N] = mod_pow(fac[3*N],MOD-2);\n\tfor(LL n = 3*N-1; n >= 0; n--)\n\t\tfac_inv[n] = (fac_inv[n+1]*(n+1))%MOD;\n\n\tLL a, b, c; cin >> a >> b >> c;\n\ta++;\n\t//WLOG, b > c\n\tif(!(b>c))\n\t{\n\t\tb = b^c;\n\t\tc = b^c;\n\t\tb = b^c;\n\t}\n\n\tLL ans = 0;\n\tLL sum = 1;\n\tLL pull = 0;\n\tfor(LL n = a; n <= a+b+c; n++)\n\t{\n\t\tLL sub = 0;\n\t\t\n\t\tsub = (sub+sum-pull)%MOD;\n\t\tsub = (sub*C(n-2,a-2))%MOD;\n\t\tsub = (sub*mod_pow(3,a+b+c-n))%MOD;\n\t\tans = (ans+sub)%MOD;\n\n\t\tsum  = (2*sum-C(n-a,c))%MOD;\n\t\tpull = (2*pull+C(n-a,n-a-b))%MOD;\n\t}\n\tcout<<(ans+MOD)%MOD<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int maxn(1e6 + 10), Mod(1e9 + 7);\nint N, M, K, ans, fac[maxn], inv[maxn], Pow[maxn];\nint C(int n, int m) { return 1ll * fac[n] * inv[m] % Mod * inv[n - m] % Mod; }\nint Minus(int x, int y) { return (x - y + Mod) % Mod; }\nint Add(int x, int y) { return (x + y) % Mod; }\nint Mul(int x, int y) { return 1ll * x * y % Mod; }\nint fastpow(int x, int y)\n{\n\tint ans = 1;\n\tfor (; y; y >>= 1, x = 1ll * x * x % Mod)\n\t\tif (y & 1) ans = 1ll * ans * x % Mod;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &K), fac[0] = inv[0] = Pow[0] = 1; if (M < K) std::swap(M, K);\n\tfor (int i = 1; i <= N + M + K; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tfor (int i = 1; i <= N + M + K; i++) Pow[i] = 1ll * Pow[i - 1] * 3 % Mod;\n\tinv[N + M + K] = fastpow(fac[N + M + K], Mod - 2);\n\tfor (int i = N + M + K - 1; i; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % Mod;\n\tfor (int i = 0, x = 1; i <= M + K; i++)\n\t{\n\t\tans = Add(ans, Mul(Mul(C(N + i - 1, N - 1), Pow[M + K - i]), x));\n\t\tif (i < K) x = (x + x) % Mod; else if (i < M) x = Minus((x + x) % Mod, C(i, K));\n\t\telse x = Minus(Minus((x + x) % Mod, C(i, K)), C(i, M));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename T> constexpr T fpow_eq(T& x, ll y, T identity = 1) {\n    for(; y > 0; x *= x, y >>= 1) {\n        if(y & 1) {\n            identity *= x;\n        }\n    }\n    return x = identity;\n}\ntemplate <typename T> constexpr T fpow(T x, ll y, T identity = 1) { return fpow_eq(x, y, identity); }\n#ifndef __TOTIENT_INCLUDED_\n#define __TOTIENT_INCLUDED_\ntemplate <typename T, typename TEachDivisor, typename TEachPrime>\nconstexpr void factorize(T n, TEachDivisor each_divisor, TEachPrime each_prime = [](T) {}) {\n    static_assert(is_convertible<decltype(each_divisor), function<void(T)>>::value, \"each_divisor must be void(T)\");\n    static_assert(is_convertible<decltype(each_prime), function<void(T)>>::value, \"each_prime must be void(T)\");\n    for(T i = 2; i * i <= n; i++) {\n        if(n % i == 0) {\n            each_prime(i);\n            while(n % i == 0) {\n                each_divisor(i);\n                n /= i;\n            }\n        }\n    }\n    if(n > 1) {\n        each_divisor(n);\n        each_prime(n);\n    }\n}\ntemplate <typename T> constexpr T phi(T n) {\n    T ans = n;\n    factorize<T>(n, [](T) {}, [&](T p) { ans -= ans / p; });\n    return ans;\n}\n#endif\n#ifdef __TOTIENT_INCLUDED_\ntemplate <int M, int PHI_M = phi(M)> struct modint {\n#else\ntemplate <int M, int PHI_M> struct modint {\n#endif\n    static constexpr int MOD = M;\n    int val;\n    constexpr modint() : val(0) {}\n    constexpr modint(int val) : val(val % M) { this->val += this->val < 0 ? M : 0; }\n    constexpr modint(long long val) : modint(int(val % M)) {}\n    constexpr modint(const modint& m) : val(m.val) {}\n    constexpr modint(const complex<long double>& x) : modint(llround(x.real())) {}\n    constexpr explicit operator int() const { return val; }\n    constexpr bool operator==(const modint& y) const { return val == y.val; }\n    constexpr bool operator!=(const modint& y) const { return val != y.val; }\n    constexpr bool operator< (const modint& y) const { return val <  y.val; }\n    constexpr bool operator<=(const modint& y) const { return val <= y.val; }\n    constexpr bool operator> (const modint& y) const { return val >  y.val; }\n    constexpr bool operator>=(const modint& y) const { return val >= y.val; }\n    constexpr modint& operator=(const modint& y) { val = y.val; return *this; }\n    constexpr modint& operator+=(const modint& y) { val += y.val; val -= val >= M ? M : 0; return *this; }\n    constexpr modint& operator-=(const modint& y) { val -= y.val; val += val <  0 ? M : 0; return *this; }\n    constexpr modint& operator*=(const modint& y) { val = ll(val) * y.val % M; return *this; }\n    constexpr modint& operator/=(const modint& y) { val = ll(val) * fpow(y, PHI_M - 1).val % M; return *this; }\n    constexpr modint& operator^=(ll y) { fpow_eq(*this, y); return *this; }\n    constexpr modint operator+(const modint& y) const { return modint(val) += y; }\n    constexpr modint operator-(const modint& y) const { return modint(val) -= y; }\n    constexpr modint operator*(const modint& y) const { return modint(val) *= y; }\n    constexpr modint operator/(const modint& y) const { return modint(val) /= y; }\n    constexpr modint operator^(ll y) const { return modint(val) ^= y; }\n    constexpr modint operator-() const { return modint(0) -= *this; }\n    constexpr modint operator~() const { return modint(1) /= *this; }\n    constexpr modint& operator++() { val = val == M - 1 ? 0 : val + 1; return *this; }\n    constexpr modint& operator--() { val = val == 0 ? M - 1 : val - 1; return *this; }\n    constexpr modint operator++(int) { modint m = *this; ++(*this); return m; }\n    constexpr modint operator--(int) { modint m = *this; --(*this); return m; }\n    friend constexpr modint operator+(long long x, const modint& y) { return modint(x) + y; }\n    friend constexpr modint operator*(long long x, const modint& y) { return modint(x) * y; }\n    friend constexpr modint operator-(long long x, const modint& y) { return modint(x) - y; }\n    friend constexpr modint operator/(long long x, const modint& y) { return modint(x) / y; }\n    friend ostream& operator<<(ostream& os, const modint& m) { return os << m.val; }\n    friend istream& operator>>(istream& is, modint& m) { ll val; is >> val; m = modint(val); return is; }\n};\nconstexpr int M = 1'000'000'007;\nusing mint = modint<M, M - 1>;\nmint operator\"\"_m(unsigned long long int x) { return mint(ll(x)); }\ntemplate <typename T = mint> T fact(int n) {\n    static vector<T> fac = {1};\n    while(fac.size() <= n) {\n        fac.push_back(fac.back() * int(fac.size()));\n    }\n    return fac[n];\n}\ntemplate <typename T = mint> T fact_inv(int n) {\n    static vector<T> inv_fac = {1};\n    while(inv_fac.size() <= n) {\n        inv_fac.push_back(inv_fac.back() / int(inv_fac.size()));\n    }\n    return inv_fac[n];\n}\nconst double PI = acos(-1);\ncomplex<long double> w(int len, bool inverse) {\n    return polar<long double>(1, (inverse ? -2 : 2) * (PI / len));\n}\nconstexpr int lg(int x) { return 31 - __builtin_clz(x); }\ntemplate <typename T> vector<T>& pad(vector<T>& a, int min_size) {\n    a.resize(2 << lg(min_size - 1));\n    return a;\n}\nint bit_reverse(int i, int n) {\n    int ans = 0;\n    for(int j = 0; j < lg(n); j++) {\n        ans |= i & (1 << j) ? 1 << (lg(n) - 1 - j) : 0;\n    }\n    return ans;\n}\ntemplate <typename T> vector<T>& fft(vector<T>& a, bool inverse = false) {\n    int n = a.size();\n    for(int i = 0; i < n; i++) {\n        if(i < bit_reverse(i, n)) {\n            swap(a[i], a[bit_reverse(i, n)]);\n        }\n    }\n    for(int len = 2; len <= n; len <<= 1) {\n        T W = w(len, inverse);\n        for(int i = 0; i < n; i += len) {\n            T root = 1;\n            for(int j = i; j < i + (len >> 1); j++) {\n                T u = a[j], t = root * a[j + (len >> 1)];\n                a[j] = u + t;\n                a[j + (len >> 1)] = u - t;\n                root *= W;\n            }\n        }\n    }\n    if(inverse) {\n        transform(a.begin(), a.end(), a.begin(), [n](T& ai) { return ai / T(n); });\n    }\n    return a;\n}\ntemplate <typename T> vector<T>& operator*=(vector<T>& a, vector<T>& b) {\n    fft(pad(a, a.size())); if(addressof(a) != addressof(b)) fft(pad(b, b.size()));\n    assert(a.size() == b.size());\n    transform(a.begin(), a.end(), b.begin(), a.begin(), multiplies<T>());\n    fft(a, true); if(addressof(a) != addressof(b)) fft(b, true);\n    return a;\n}\ntemplate <typename T> vector<T> operator*(vector<T> a, vector<T>& b) { return a *= b; }\ntemplate <typename T> vector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n    transform(a.begin(), a.end(), b.begin(), a.begin(), plus<T>());\n    return a;\n}\ntemplate <typename T> vector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n    transform(a.begin(), a.end(), b.begin(), a.begin(), minus<T>());\n    return a;\n}\ntemplate <typename T> vector<T> operator+(vector<T> a, const vector<T>& b) { return a += b; }\ntemplate <typename T> vector<T> operator-(vector<T> a, const vector<T>& b) { return a -= b; }\ntemplate <int C = int(sqrt(mint::MOD) + 0.5)> vector<mint>& operator*=(vector<mint>& a, vector<mint>& b) {\n    vector<complex<long double>> a0(a.size()), a1(a.size()), b0(b.size()), b1(b.size());\n    transform(a.begin(), a.end(), a0.begin(), [](mint& ai) { return ai.val % C; });\n    transform(a.begin(), a.end(), a1.begin(), [](mint& ai) { return ai.val / C; });\n    transform(b.begin(), b.end(), b0.begin(), [](mint& bi) { return bi.val % C; });\n    transform(b.begin(), b.end(), b1.begin(), [](mint& bi) { return bi.val / C; });\n    vector<complex<long double>> z0 = a0 * b0, z2 = a1 * b1, z1 = (a0 += a1) * (b0 += b1);\n    (z1 -= z0) -= z2;\n    for(int i = 0; i < a.size(); i++) {\n        a[i] = mint(z0[i]) + mint(z1[i]) * C + mint(z2[i]) * C * C;\n    }\n    return a;\n}\ntemplate <int C = int(sqrt(mint::MOD) + 0.5)> vector<mint> operator*(vector<mint> a, vector<mint>& b) { return a *= b; }\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<mint> a(m + k + 1);\n    for(int i = 0; i <= m + k; i++) {\n        a[i] = fact(n - 1 + i);\n    }\n    vector<mint> b(k + 1);\n    for(int j = 0; j <= k; j++) {\n        b[j] = fact_inv(j) * (3_m ^ (k - j));\n    }\n    reverse(b.begin(), b.end());\n    b.resize(a.size());\n    a *= b;\n    mint ans = 0;\n    for(int i = 0; i <= m; i++) {\n        ans += fact_inv(n - 1) * fact_inv(i) * (3_m ^ (m - i)) * a[k + i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n    return ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n    return ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n    int ans = 1 , base = a ;\n    while( b ) {\n        if( b&1 ) ans = mul( ans , base ) ;\n        base = mul( base , base ) ; \n        b >>= 1 ;\n    }\n    return ans ;\n}\n\nll inv( ll x ) {\n    return power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n    return ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n    scanf( \"%d%d%d\" , &n , &m , &k ) ;\n    fac[ 0 ] = 1ll ;\n    p[ 0 ] = 1ll ;\n    for( int i = 1 ; i < N ; i ++ ) {\n        fac[ i ] = fac[ i - 1 ] * i % mod ;\n        p[ i ] = p[ i - 1 ] * 3ll % mod ;\n    }\n    for( int i = 0 ; i < N ; i ++ ) {\n        ifac[ i ] = inv( fac[ i ] ) ;\n    }\n    ll ans = 0 , x = 1ll ;\n    n -- ;\n    for( int i = 0 ; i <= m + k ; i ++ ) {\n        ans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n        if( i < k ) x = ( x * 2ll ) % mod ;\n        else if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n        else  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n    }\n    printf( \"%lld\\n\" , add( ans , mod ) ) ;\n    return 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 21);\nconst int mod = (int)1e9 + 7;\nconst double PI = acos(-1.0);\nconst int BK = 100;\nconst int CK = 5;\n\ninline void addmod(int& x, int y, int mod) { (x += y) >= mod && (x -= mod); }\ninline int mulmod(int x, int y, int mod) { return x * 1ll * y % mod; }\n\nstruct complex_base\n{\n\tdouble x, y;\n\tcomplex_base(double _x = 0, double _y = 0) { x = _x; y = _y; }\n\tfriend complex_base operator-(const complex_base &a, const complex_base &b) { return complex_base(a.x - b.x, a.y - b.y); }\n\tfriend complex_base operator+(const complex_base &a, const complex_base &b) { return complex_base(a.x + b.x, a.y + b.y); }\n\tfriend complex_base operator*(const complex_base &a, const complex_base &b) { return complex_base(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x); }\n\tfriend void operator/=(complex_base &a, const double &P) { a.x /= P; a.y /= P; }\n};\n\nint bit_rev[MAXN];\n\nvoid fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = 2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n}\n\nvoid inv_fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = -2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] /= n;\n}\n\ncomplex_base A[MAXN], B[MAXN];\n\nvector<int> mult(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() <= 128)\n\t{\n\t\tvector<int> ans(a.size() + b.size(), 0);\n\t\tfor(int i = 0; i < (int)a.size(); i++)\n\t\t\tfor(int j = 0; j < (int)b.size(); j++)\n\t\t\t\tans[i + j] = (ans[i + j] + a[i] * 1ll * b[j]) % mod;\n\n\t\treturn ans;\n\t}\n\n\tint lg = 0; while((1 << lg) < (int)(a.size() + b.size())) ++lg;\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = B[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = complex_base(a[i], 0);\n\tfor(int i = 0; i < (int)b.size(); i++) B[i] = complex_base(b[i], 0);\n\n\tfft(A, lg); fft(B, lg);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tA[i] = A[i] * B[i];\n\tinv_fft(A, lg);\n\n\tvector<int> ans(a.size() + b.size(), 0);\n\tfor(int i = 0; i < (int)ans.size(); i++)\n\t\tans[i] = (int64_t)(A[i].x + 0.5) % mod;\n\n\treturn ans;\n}\n\nvector<complex_base> to_fft(const vector<complex_base> &a, int lg)\n{\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = a[i];\n\tfft(A, lg);\n\n\tvector<complex_base> ret(1 << lg, 0);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tret[i] = A[i];\n\n\treturn ret;\n}\n\nvector<complex_base> to_inv_fft(const vector<complex_base> &a, int lg)\n{\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = a[i];\n\tinv_fft(A, lg);\n\n\tvector<complex_base> ret(1 << lg, 0);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tret[i] = A[i];\n\n\treturn ret;\n}\n\nvector<int> mult_mod(vector<int> a, vector<int> b)\n{\n\tvector<int> ret;\n\tvector<complex_base> res[2 * CK], al[CK];\n\tint lg = 0; while((1 << lg) < (int)(a.size() + b.size())) ++lg;\n\n\tfor(int i = 0; i < CK; i++)\n\t{\n\t\tal[i].assign(a.size(), complex_base(0, 0));\n\t\tres[i * 2].assign(1 << lg, complex_base(0, 0));\n\t\tres[i * 2 + 1].assign(1 << lg, complex_base(0, 0));\n\t}\n\n\tfor(int i: a) cout << i << \" \";\n\tcout << endl;\n\n\tfor(int i = 0; i < (int)a.size(); i++)\n\t\tfor(int p = 0; p < CK; p++)\n\t\t{\n\t\t\tal[p][i] = complex_base(a[i] % BK, 0);\n\t\t\ta[i] /= BK;\n\t\t}\n\n\tfor(int i = 0; i < (int)b.size(); i++)\n\t\tfor(int p = 0; p < CK; p++)\n\t\t{\n\t\t\tal[p][i].y = b[i] % BK;\n\t\t\tb[i] /= BK;\n\t\t}\n\n\tfor(int i = 0; i < CK; i++)\n\t\tal[i] = to_fft(al[i], lg);\n\n\tfor(int i = 0; i < CK; i++)\n\t\tfor(int j = 0; j < CK; j++)\n\t\t\tfor(int p = 0; p < (1 << lg); p++)\n\t\t\t\tres[i + j][p] = res[i + j][p] + (al[i][p] * al[j][p]);\n\n\tvector<int> answer(1 << lg, 0);\n\t\n\tint ol = 1;\n\tfor(int i = 0; i < 2 * CK; i++)\n\t{\n\t\tres[i] = to_inv_fft(res[i], lg);\n\t\tfor(int p = 0; p < (1 << lg); p++)\n\t\t\tanswer[p] = (answer[p] + (ol * 1ll * (int)((int64_t)((res[i][p].y + 0.5) / 2.0) % mod) % mod)) % mod;\n\t\tol = (ol * BK) % mod;\n\t}\n\n\treturn answer;\n}\n\n#define mp make_pair\n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < (int) n; ++i)\n \ntypedef vector <int> vi;\n \nusing ld = double;\nusing ll = int64_t;\n \n\nconst ll MOD = mod;\n\nnamespace FFT {\n  struct cd {\n    ld a, b;\n \n    cd(ld a, ld b) : a(a), b(b) {}\n \n    cd(ld x = 0) : a(x), b(0) {}\n \n    ld real() const {\n      return a;\n    }\n \n    void operator += (const cd& other) {\n      a += other.a;\n      b += other.b;\n    }\n \n    void operator -= (const cd& other) {\n      a -= other.a;\n      b -= other.b;\n    }\n \n    void operator *= (const cd& other) {\n      tie(a, b) = mp(a * other.a - b * other.b, a * other.b + b * other.a);\n    }\n \n    friend cd operator * (const cd& x, const cd& y) {\n      cd r = x;\n      r *= y;\n      return r;\n    }\n \n    friend cd operator + (const cd& x, const cd& y) {\n      cd r = x;\n      r += y;\n      return r;\n    }\n \n    friend cd operator - (const cd& x, const cd& y) {\n      cd r = x;\n      r -= y;\n      return r;\n    }\n \n    void operator /= (ld c) {\n      a /= c;\n      b /= c;\n    }\n  };\n \n  typedef vector<cd> vcd;\n \n  const int LOG = 20;\n  const int N = 1 << LOG;\n \n  int rev[N];\n  cd root_[N];\n \n  inline cd root(int k, int n) {\n    return root_[k * (N / n)];\n  }\n \n  void precalc() {\n    rev[0] = 0;\n    int hb = -1;\n    for (int i = 1; i < N; ++i) {\n      if  ((i & (i - 1)) == 0) {\n        ++hb;\n      }\n      rev[i] = rev[i ^ (1 << hb)] | (1 << (LOG - hb - 1));\n    }\n \n    forn(i, N) {\n      ld ang = PI * i * 2.0 / N;\n      root_[i] = cd(cosl(ang), sinl(ang));\n    }\n  }\n \n  void fft_rec(cd* a, int n) {\n    if  (n == 1) {\n      return;\n    }\n \n    fft_rec(a, n / 2);\n    fft_rec(a + n / 2, n / 2);\n \n    forn(k, n / 2) {\n      cd w = root(k, n);\n      cd x = a[k];\n      cd y = w * a[k + n / 2];\n      a[k] = x + y;\n      a[k + n / 2] = x - y;\n    }\n  }\n \n  void fft(vcd& a) {\n    int n = sz(a);\n    vcd na(n, cd(0, 0));\n    forn(i, n) na[i] = a[rev[i]];\n    na.swap(a);\n \n    fft_rec(&a[0], n);\n  }\n \n  void fft_inv(vcd& a) {\n    fft(a);\n    int n = sz(a);\n    reverse(a.begin() + 1, a.end());\n    forn(i, n) {\n      a[i] /= n;\n    }\n  }\n \n  vi mult(const vi& a, const vi& b) {\n    //    TimeStamp t(\"mult\");\n    vcd A(N, cd(0, 0));\n    vcd B(N, cd(0, 0));\n    forn(i, sz(a)) A[i] = a[i];\n    forn(i, sz(b)) B[i] = b[i];\n \n    fft(A);\n    fft(B);\n \n    forn(i, N) A[i] *= B[i];\n \n    fft_inv(A);\n \n    vi c(N, 0);\n    forn(i, N) c[i] = ((ll) (A[i].real() + 0.5)) % MOD;\n \n    return c;\n  }\n \n  vi multmod(const vi& a, const vi& b) {\n    // a = a0 + sqrt(MOD) * a1\n    // a = a0 + base * a1\n    int base = (int) sqrtl(MOD);\n \n    vi a0(sz(a)), a1(sz(a));\n    forn(i, sz(a)) {\n      a0[i] = a[i] % base;\n      a1[i] = a[i] / base;\n      assert(a[i] == a0[i] + base * a1[i]);\n    }\n \n    vi b0(sz(b)), b1(sz(b));\n    forn(i, sz(b)) {\n      b0[i] = b[i] % base;\n      b1[i] = b[i] / base;\n      assert(b[i] == b0[i] + base * b1[i]);\n    }\n \n    vi a01 = a0;\n    forn(i, sz(a)) {\n      addmod(a01[i], a1[i], MOD);\n    }\n \n    vi b01 = b0;\n    forn(i, sz(b)) {\n      addmod(b01[i], b1[i], MOD);\n    }\n \n    vi C = mult(a01, b01);  // 1\n \n    vi a0b0 = mult(a0, b0); // 2\n    vi a1b1 = mult(a1, b1); // 3\n \n    vi mid = C;\n    forn(i, N) {\n      addmod(mid[i], -a0b0[i] + MOD, MOD);\n      addmod(mid[i], -a1b1[i] + MOD, MOD);\n    }\n \n    vi res = a0b0;\n    forn(i, N) {\n      addmod(res[i], mulmod(base, mid[i], MOD), MOD);\n    }\n \n    base = mulmod(base, base, MOD);\n    forn(i, N) {\n      addmod(res[i], mulmod(base, a1b1[i], MOD), MOD);\n    }\n \n    return res;\n  }\n};\n\nint n, m, k;\n\nvoid read()\n{\n\tcin >> n >> m >> k;\n}\n\nvector<int> p1, p2, pw3;\n\nint pw(int x, int p)\n{\n\tint ret = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ret = (ret * 1ll * x) % mod;\n\t\tx = (x * 1ll * x) % mod;\n\t\tp >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint fact[MAXN], inv_fact[MAXN];\nint comb(int n, int k) { if(n < 0 || k < 0 || n < k) return 0; return (((fact[n] * 1ll * inv_fact[n - k]) % mod) * 1ll * inv_fact[k]) % mod; }\n\n/*   SUM C(n + i - 1, i) * C(n + i - 1 + j, j)   */\n/*   SUM C(n + i - 1, i) * fact[n + i - 1 + j] / (fact[j] * fact[n + i - 1])    */\n\n\nvoid solve()\n{\t\n\tpw3.assign(n + m + k + 1, 0);\n\tp1.assign(m + 1, 0);\n\tp2.assign(k + 1, 0);\n\tpw3[0] = 1; for(int i = 1; i <= m + k + n; i++) pw3[i] = (3ll * pw3[i - 1]) % mod;\n\tfact[0] = 1; for(int i = 1; i <= m + k + n; i++) fact[i] = (fact[i - 1] * 1ll * i) % mod;\n\tinv_fact[m + k + n] = pw(fact[m + k + n], mod - 2); for(int i = n + k + m - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * 1ll * (i + 1)) % mod; \n\n\tfor(int i = 0; i <= m; i++) p1[i] = (comb(n + i - 1, i) * 1ll * inv_fact[n + i - 1]) % mod;\n\tfor(int i = 0; i <= k; i++) p2[i] = inv_fact[i];\n\n\tFFT::precalc();\n\tvector<int> ret = FFT::multmod(p1, p2);\n\t\n\tint answer = 0;\n\tfor(int i = 0; i < (int)ret.size(); i++)\n\t{\n\t\tif(m + k - i < 0) break;\n\t\tint curr = (ret[i] * 1ll * pw3[m + k - i]) % mod;\n\t\tcurr = (curr * 1ll * fact[n - 1 + i]) % mod;\n\t\taddmod(answer, curr, mod);\n\t}\n\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline int mul(int a, int b) {\n  return (long long) a * b % md;\n}\n\ninline int power(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int x) {\n  return power(x, md - 2);\n}\n\nconst int N = 1234567;\n\nint fact[N], invfact[N];\n\ninline int C(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  return mul(fact[n], mul(invfact[k], invfact[n - k]));\n}\n\nint main() {\n  fact[0] = 1;\n  for (int i = 1; i < N; i++) {\n    fact[i] = mul(fact[i - 1], i);\n  }\n  invfact[N - 1] = inv(fact[N - 1]);\n  for (int i = N - 2; i >= 0; i--) {\n    invfact[i] = mul(invfact[i + 1], i + 1);\n  }\n  int a, b, c;\n  scanf(\"%d %d %d\", &a, &b, &c);\n  int ans = 0;\n  int rb = 0, rc = 0;\n  for (int sum = 0; sum <= b + c; sum++) {\n    int coeff = mul(power(3, b + c - sum), fact[a + sum - 1]);\n    int what = power(2, sum);\n    if (sum > b) {\n      add(rb, rb);\n      add(rb, C(sum - 1, b));\n      add(what, md - rb);\n    }\n    if (sum > c) {\n      add(rc, rc);\n      add(rc, C(sum - 1, c));\n      add(what, md - rc);\n    }\n    what = mul(what, invfact[sum]);\n    add(ans, mul(coeff, what));\n  }\n  printf(\"%d\\n\", mul(ans, invfact[a - 1]));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = (int)1e9 + 7;\n\nconst int root = 646;\n\nconst int root_1 = 208611436;\n\nconst int root_pw = 1<<20;\n\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\n\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\n\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\n\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\n\nconst int maxN = 3 * (int)1e5 + 100;\n\nint fact[maxN], invfact[maxN], inv[maxN];\nint pw3[maxN];\n\nvoid init() {\n    inv[1] = invfact[1] = invfact[0] = fact[0] = fact[1] = 1;\n    for (int i = 2; i < maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n    pw3[0] = 1;\n    for (int i = 1; i < maxN; i++) {\n        pw3[i] = mult(pw3[i - 1], 3);\n    }\n}\n\nint cnk(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return mult(fact[n], mult(invfact[k], invfact[n - k]));\n}\n\nint invNumber(int a) {\n    return pw(a, mod - 2);\n}\n\nstruct query{\n    int L, R, coef;\n    query(int _L, int _R, int _coef) : L(_L), R(_R), coef(_coef) {}\n};\nconst int BLOCK = 500;\nbool cmp(query& a, query& b) {\n    return make_pair(a.L / BLOCK, a.R) < make_pair(b.L / BLOCK, b.R);\n}\nint L, R, res;\nvoid incL() {\n    L++;\n    res = sum(res, cnk(R, L));\n}\nvoid decL() {\n    res = sub(res, cnk(R, L));\n    L--;\n}\nvoid incR() {\n    res = sum(res, res);\n    res = sub(res, cnk(R, L));\n    R++;\n}\nconst int inv2 = (mod + 1) / 2;\nvoid decR() {\n    R--;\n    res = sum(res, cnk(R, L));\n    res = mult(res, inv2);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    init();\n    int n, m, k;\n    cin >> n >> m >> k;\n    int tot = n + m + k;\n    vector < query > all;\n    for (int where = n; where <= tot; where++) {\n        int cur = cnk(where - 1, n - 1);\n        cur = mult(cur, pw3[tot - where]);\n        int from = where - n - k;\n        int to = m;\n        to = min(to, where - n);\n        from = max(from, 0);\n        if (from > to) continue;\n        all.emplace_back(to, where - n, cur);\n        if (from) all.emplace_back(from - 1, where - n, sub(0, cur));\n    }\n    sort(all.begin(), all.end(), cmp);\n    L = 0;\n    R = 0;\n    res = 1;\n    int ans = 0;\n    for (auto it : all) {\n        while (R < it.R) incR();\n        while (L > it.L) decL();\n        while (R > it.R) decR();\n        while (L < it.L) incL();\n\n        ans = sum(ans, mult(it.coef, res));\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#include <iostream>\nusing namespace std;\n#define N 2000005\n#define ll long long\n#define mod 1000000007\nint fac[N],inv[N],t[N],a,b,c,mx,ans;\nint q_pow(int x,int n){int ret=1;for(;n;n>>=1,x=(ll)x*x%mod)if(n&1)ret=(ll)ret*x%mod;return ret;}\nint C(int n,int m){return (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\t// freopen(\"8102.in\",\"r\",stdin);\n\t// freopen(\"8102.out\",\"w\",stdout);\n\tmx=2000000;t[0]=fac[0]=1;\n\tfor(int i=1;i<=mx;i++)fac[i]=(ll)i*fac[i-1]%mod,t[i]=(ll)t[i-1]*3%mod;inv[mx]=q_pow(fac[mx],mod-2);\n\tfor(int i=mx;i;i--)inv[i-1]=(ll)inv[i]*i%mod;\n\t// int T;scanf(\"%d\",&T);\n\t// while(T--)\n\t// {\n\t\tscanf(\"%d%d%d\",&a,&b,&c);ans=0;\n\t\tfor(int i=0;i<=b;i++)\n\t\t\tfor(int j=0;j<=c;j++)\n\t\t\t\tans=(ans+(ll)C(a+i-1,i)*C(a+i+j-1,j)%mod*t[b+c-i-j])%mod;\n\t\tprintf(\"%d\\n\",ans);\n\t// }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n\treturn ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n\treturn ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n\tint ans = 1 , base = a ;\n\twhile( b ) {\n\t\tif( b&1 ) ans = mul( ans , base ) ;\n\t\tbase = mul( base , base ) ; \n\t\tb >>= 1 ;\n\t}\n\treturn ans ;\n}\n\nll inv( ll x ) {\n\treturn power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n\treturn ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n\tscanf( \"%d%d%d\" , &n , &m , &k ) ;\n\tfac[ 0 ] = 1ll ;\n\tp[ 0 ] = 1ll ;\n\tfor( int i = 1 ; i < N ; i ++ ) {\n\t\tfac[ i ] = fac[ i - 1 ] * i % mod ;\n\t\tp[ i ] = p[ i - 1 ] * 3ll % mod ;\n\t}\n\tfor( int i = 0 ; i < N ; i ++ ) {\n\t\tifac[ i ] = inv( fac[ i ] ) ;\n\t}\n\tll ans = 0 , x = 1ll ;\n\tn -- ;\n\tfor( int i = 0 ; i <= m + k ; i ++ ) {\n\t\tans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n\t\t/*\n\t\tfor( int j = 0 ; j <= min( i , m  ) ; j ++ ) {\n\t\t\tif( i - j > k || i - j < 0 ) break ;\n\t\t\tx = add( x , C( i , j ) ) ;\n\t\t}\n\t\t*/\n\t\tif( i < k ) x = ( x * 2ll ) % mod ;\n\t\telse if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n\t\telse  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n\t}\n\tprintf( \"%lld\\n\" , add( ans , mod ) ) ;\n\treturn 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and must not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int Int;\n\ttypedef unsigned int UInt;\n\ttypedef long long Long;\n\ttypedef unsigned long long ULong;\n\npublic:\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](ULong exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(ULong exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic IntMod Permutation(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / IntMod::Fact(n - r);\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <uint32_t Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <uint32_t Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <uint32_t Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <uint32_t Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint A, B, C;\nMInt D[300004];\nint main() {\n\tcin >> A >> B >> C;\n\tD[0] = 1;\n\tREP(i, 0, B + C) {\n\t\tD[i + 1] = D[i] * 3;\n\t}\n\t\n\tMInt sum = 0;\n\tREP(i, 0, B + 1) {\n\t\tREP(j, 0, C + 1) {\n\t\t\tsum += D[B + C - i - j]\n\t\t\t\t* MInt::Fact(A + i + j - 1)\n\t\t\t\t/ (MInt::Fact(A - 1) * MInt::Fact(i) * MInt::Fact(j));\n\t\t}\n\t}\n\n\tcout << sum << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define SF scanf\n#define PF printf\n#define MAXN 900010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nll inv[MAXN],fac[MAXN],pow3[MAXN];\nll fsp(ll x,int y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\t\n\t}\n\treturn res;\n}\nll C(int x,int y){\n\treturn fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nint main(){\n\tint n,m,k;\n\tSF(\"%d%d%d\",&n,&m,&k);\n\tpow3[0]=1;\n\tfac[0]=1;\n\tfor(int i=1;i<=n+m+k;i++){\n\t\tpow3[i]=pow3[i-1]*3ll%MOD;\t\n\t\tfac[i]=fac[i-1]*i%MOD;\n\t}\n\tinv[n+m+k]=fsp(fac[n+m+k],MOD-2);\t\n\tfor(int i=n+m+k;i>0;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\tn--;\n\tif(m<k)\n\t\tswap(m,k);\n\tll j=1,ans=0;\n\tfor(int i=0;i<=m+k;i++){\n\t\tans=(ans+C(n+i,n)*pow3[m+k-i]%MOD*j)%MOD;\t\n\t\tif(i<k)\n\t\t\tj=j*2ll%MOD;\n\t\telse if(i<m)\n\t\t\tj=(j*2ll-C(i,k))%MOD;\n\t\telse \t\n\t\t\tj=(j*2ll-C(i,k)-C(i,m))%MOD;\n\t}\n\tans=(ans+MOD)%MOD;\n\tPF(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define N 1000015\nconst int p=1e9+7;\nint n,m,k,f[N],finv[N],inv[N],bin[N];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&k);\n    f[0]=finv[0]=f[1]=finv[1]=inv[1]=bin[0]=1;bin[1]=3;\n    for(int i=2;i<=n+m+k;i++)\n    {bin[i]=3ll*bin[i-1]%p;\n    \tinv[i]=1ll*(p-p/i)*inv[p%i]%p;\n    \tf[i]=1ll*f[i-1]*i%p;finv[i]=1ll*finv[i-1]*inv[i]%p;\n\t}int ans=0;\n\tfor(int i=0;i<=m;i++)for(int j=0;j<=k;j++)\n\t{\n\t\tans=(ans+1ll*f[n+i+j-1]*finv[n-1]%p*finv[i]%p*finv[j]%p*bin[m-i+k-j]%p)%p;\n\t}printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int N = 1000010, Mod = 1e9 + 7;\nint fac[N], ifac[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod)\n\t\tif (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint C(int n, int m) {\n\tif (n < m) return 0;\n\treturn 1ll * fac[n] * ifac[n - m] % Mod * ifac[m] % Mod;\n}\nint n, m, k;\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tread(n), read(m), read(k);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N - 10; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[N - 10] = fpow(fac[N - 10], Mod - 2);\n\tfor (int i = N - 10; i >= 1; i--) ifac[i - 1] = 1ll * ifac[i] * i % Mod;\n\tLL ans = fpow(3, m + k), S = 1;\n\tfor (int t = 1; t <= m + k; t++) {\n\t\tS = (2 * S % Mod - C(t - 1, m) + Mod) % Mod;\n\t\tif (t - k > 0) S = (S - C(t - 1, t - k - 1) + Mod) % Mod;\n\t\tans = (ans + 1ll * fpow(3, m + k - t) * C(t + n - 1, n - 1) % Mod * S % Mod) % Mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 1000005\n#define M 200005\n#define seed 23333\n#define Mo 1000000007\n\nusing namespace std;\nint i,j,m,n,p,k,fac[N],inv[N],ans,now;\nint power(int x,int y)\n{\n\t\tint sum=1;\n\t\tfor (;y;y>>=1)\n\t\t{\n\t\t\t\tif (y&1) sum=1ll*sum*x%Mo;\n\t\t\t\tx=1ll*x*x%Mo;\n\t\t}\n\t\treturn sum;\n}\nint C(int x,int y)\n{\n\t\treturn 1ll*fac[x]*inv[y]%Mo*inv[x-y]%Mo;\n}\nvoid jia(int &x,int y)\n{\n\t\tx+=y; if (x>=Mo) x-=Mo;\n}\nvoid work(int len)\n{\n\tif (len==0) now=1;\n\telse \n\tif (len<=k)\n\t\tnow=now*2%Mo;\n\telse if (len<=m)\n\t\tnow=(now*2%Mo-C(len-1,len-k-1)+Mo)%Mo;\n\telse\n\t{\n\t\tnow=(now*2%Mo-C(len-1,len-k-1)+Mo)%Mo;\n\t\tnow=(now-C(len-1,m)+Mo)%Mo;\n\t}\n}\nint main()\n{\n\t\tscanf(\"%d%d%d\",&n,&m,&k); if (m<k) swap(m,k);\n\t\tfac[0]=1; for (i=1;i<N;++i) fac[i]=1ll*fac[i-1]*i%Mo;\n\t\tinv[N-1]=power(fac[N-1],Mo-2);\n\t\tfor (i=N-2;i>=0;--i) inv[i]=1ll*inv[i+1]*(i+1)%Mo;\n\t\tfor (i=n;i<=n+m+k;++i)\n\t\t\twork(i-n), \n\t\t\tjia(ans,1ll*C(i-1,n-1)*power(3,n+m+k-i)%Mo*now%Mo);\n\t\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\ntypedef long long int64;\nstatic const int MAXN = 3e5 + 4;\nstatic const int MODULUS = 1e9 + 7;\n#define _  %  MODULUS\n#define __ %= MODULUS\n\nint n, m, k;\n\nint64 fact[MAXN * 3], fact_inv[MAXN * 3];\n\ninline int64 fpow(int64 base, int exp)\n{\n    int64 ans = 1;\n    for (; exp; exp >>= 1, (base *= base)__) if (exp & 1) (ans *= base)__;\n    return ans;\n}\nvoid preprocess()\n{\n    fact[0] = 1;\n    for (int i = 1; i < MAXN * 3; ++i) fact[i] = fact[i - 1] * i _;\n    fact_inv[MAXN * 3 - 1] = fpow(fact[MAXN * 3 - 1], MODULUS - 2);\n    for (int i = MAXN * 3 - 2; i >= 0; --i) fact_inv[i] = fact_inv[i + 1] * (i + 1)_;\n}\ninline int64 binom(int n, int m)\n{\n    if (n < m) return 0; else return fact[n] * fact_inv[m]_ * fact_inv[n - m]_;\n}\n\n/*inline int64 f(int s)\n{\n    int64 ans = 0;\n    for (int t = std::max(0, s - k); t <= m; ++t) (ans += binom(s, t))__;\n    printf(\"%2d | %2d | %2d\\n\", s, std::max(0, s - k), m);\n    return ans;\n}*/\n\nint64 f[MAXN * 3];\n\nint main()\n{\n    preprocess();\n    scanf(\"%d%d%d\", &n, &m, &k);\n\n    f[0] = 1;\n\n    for (int i = 1; i <= k; ++i) f[i] = (f[i - 1] + f[i - 1])_;\n    for (int i = k + 1; i <= m + k; ++i)\n        f[i] = (f[i - 1] + f[i - 1] - binom(i - 1, i - 1 - k) - binom(i - 1, m) + MODULUS * 2)_;\n\n    int64 ans = 0;\n    //for (int i = 0; i <= m + k; ++i) printf(\"%2d | %lld\\n\", i, f[i]);\n    for (int s = n + 1; s <= n + m + k + 1; ++s) {\n        (ans += binom(s - 2, n - 1) * f[s - n - 1]_ * fpow(3, n + m + k + 1 - s))__;\n    }\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Why all solutions are wrong?\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=9e5+5,mo=1e9+7;\n\ntypedef long long LL;\n\nint n,m,K,ans,Fac[N],Inv[N],p[N];\n\nint C(int n,int m)\n{\n    return (LL)Fac[n]*Inv[m]%mo*Inv[n-m]%mo;\n}\n\nint main()\n{\n    p[0]=Fac[0]=Inv[0]=Fac[1]=Inv[1]=1; p[1]=3;\n    for (int i=2;i<N;i++) Inv[i]=(LL)Inv[mo%i]*(mo-mo/i)%mo;\n    for (int i=2;i<N;i++)\n    {\n        p[i]=p[i-1]*3ll%mo; Fac[i]=(LL)Fac[i-1]*i%mo; Inv[i]=(LL)Inv[i-1]*Inv[i]%mo;\n    }\n    scanf(\"%d%d%d\",&n,&m,&K); n--;\n    if (m<K) swap(m,K);\n    for (int i=0,j=1;i<=m+K;i++)\n    {\n        ans=(ans+(LL)C(n+i,n)*p[m+K-i]%mo*j)%mo;\n        if (i<K) j=j*2%mo;\n        else if (i>=m) j=(j*2ll-C(i,K)-C(i,i-m))%mo;\n        else j=(j*2ll-C(i,K))%mo;\n    }\n    if (ans<0) ans+=mo;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=900000+10;\n\nconst int mod=1e9+7;\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint fac[N],ifac[N],pw[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n    for (re int i=pw[0]=1;i<=n;++i) pw[i]=3ll*pw[i-1]%mod;\n}\n\ninline int C(int n,int m) {\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main() { init(900000);\n    int n=read(),m=read(),k=read();\n    int ans=0,lst=1;\n    for (re int i=0;i<=m+k;++i) {\n        ans=(ans+1ll*C(n+i-1,n-1)*pw[m+k-i]%mod*lst)%mod;\n        if (i<k) lst=2ll*lst%mod;\n        else if (i<m) lst=(2ll*lst-C(i,k))%mod;\n        else lst=(2ll*lst-C(i,k)-C(i,m))%mod;\n    }\n    printf(\"%d\\n\",(ans+mod)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 1000000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nll p2[1000001];\nint main()\n{\n\tinvinit();\n\tll n, m, k;\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tp2[0] = 1;\n\tfor (int i = 1; i <= 1000000; i++)p2[i] = p2[i - 1] * 2 % mod;\n\tll nm = 0, nk = 0;\n\tfor (int i = n; i <= n + m; i++)nm = (nm + com(n + m, i)) % mod;\n\tfor (int i = n; i <= n + k; i++)nk = (nk + com(n + k, i)) % mod;\n\tll ans = 0;\n\tfor (int s = 0; s <= k; s++)\n\t{\n\t\tans += p2[k - s] * nm%mod*com(n + m + k, s) % mod;\n\t\tans %= mod;\n\t}\n\tfor (int s = 0; s <= m; s++)\n\t{\n\t\tans += p2[m - s] * nm%mod*com(n + m + k, s) % mod;\n\t\tans %= mod;\n\t}\n\tll now = 0;\n\tfor (int t = 0; t <= k; t++)\n\t{\n\t\tnow += com(n + m + k - m, t);\n\t\tnow %= mod;\n\t}\n\tfor (int s = m; s >= 0; s--)\n\t{\n\t\tans += mod - (now*com(n + m + k, s) % mod);\n\t\tans %= mod;\n\t\tnow = (now * 2 + mod - com(n + m + k - s, k));\n\t\tnow %= mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\nconst long double eps = 1e-12;\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*2\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long mae[2000000];\nlong long gyaku[2000000];\nlong long powing(long long a, long long b) {\n\tlong long ans = 1;\n\twhile (b != 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tans *= a;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\ta *= a;\n\t\ta %= MAX_MOD;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\nlong long inv(long long now) {\n\treturn powing(now, MAX_MOD - 2LL);\n}\nlong long combination(long long a, long long b) {\n\tlong long ans = mae[a];\n\tans *= gyaku[a - b];\n\tans %= MAX_MOD;\n\tans *= gyaku[b];\n\tans %= MAX_MOD;\n\treturn ans;\n}\nint main() {\n\tlong long a, b, c;\n\tcin >> a >> b >> c;\n\tmae[0] = 1;\n\tgyaku[0] = 1;\n\tfor (long long i = 1; i <= a+b+c; ++i) {\n\t\tmae[i] = mae[i - 1] * i;\n\t\tmae[i] %= MAX_MOD;\n\t\tgyaku[i] = inv(mae[i]);\n\t}\n\tlong long ans = 0;\n\tlong long geko = 0;\n\tlong long l = 0;\n\tlong long r = 0;\n\tfor (long long i = a; i <= a + (b) + (c); ++i) {\n\t\tlong long first_multiply = powing(3LL, a + b + c - i);\n\t\tfirst_multiply *= combination(i-1, a-1);\n\t\tfirst_multiply %= MAX_MOD;\n\t\tlong long second_multiply = powing(2LL, i - a);\n\t\tr *= 2LL;\n\t\tl *= 2LL;\n\t\tif (i >= a + b + 1) l += combination(i - a - 1, i - a - b - 1);\n\t\tif (i >= a + c + 1) r += combination(i - a - 1, i - a - c - 1);\n\t\tr %= MAX_MOD;\n\t\tl %= MAX_MOD;\n\n\t\tsecond_multiply += (MAX_MOD - ((l) % MAX_MOD)) % MAX_MOD;\n\t\tsecond_multiply += (MAX_MOD - ((r) % MAX_MOD)) % MAX_MOD;\n\t\t/*\n\t\tfor (long long q = 0; q <= b; ++q) {\n\t\t\tlong long geko = i - a - q;\n\t\t\tif (geko < 0) break;\n\t\t\tif (geko > c)continue;\n\t\t\tsecond_multiply += combination(i-a,q);\n\t\t\tsecond_multiply %= MAX_MOD;\n\t\t}\n\t\t*/\n\t\tans += first_multiply * second_multiply;\n\t\tans %= MAX_MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 9e5 + 9, mod = 1e9 + 7;\n\ntemplate <const int32_t MOD>\nstruct modint {\n    int32_t value;\n    modint() = default;\n    modint(int32_t value_) : value(value_) {}\n    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.value; return modint<MOD>(c >= MOD ? c - MOD : c); }\n    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.value; return modint<MOD>(c <    0 ? c + MOD : c); }\n    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * other.value % MOD; return modint<MOD>(c < 0 ? c + MOD : c); }\n    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * other.value % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : 0); }\n    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k & 1) y *= x; x *= x; } return y; }\n    modint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n    inline modint<MOD> operator /  (modint<MOD> other) const { return *this *  other.inv(); }\n    inline modint<MOD> operator /= (modint<MOD> other)       { return *this *= other.inv(); }\n    inline bool operator == (modint<MOD> other) const { return value == other.value; }\n    inline bool operator != (modint<MOD> other) const { return value != other.value; }\n    inline bool operator < (modint<MOD> other) const { return value < other.value; }\n    inline bool operator > (modint<MOD> other) const { return value > other.value; }\n};\ntemplate <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD>(value) * n; }\ntemplate <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD>(value % MOD) * n; }\ntemplate <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.value; }\ntemplate <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.value; }\n\nusing mint = modint<mod>;\n\nstruct Combi{\n\tint n; vector<mint> facts, finvs, invs;\n\tCombi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){\n\t\tfacts[0] = finvs[0] = 1;\n\t\tinvs[1] = 1;\n\t    for (int i = 2; i < n; i++) invs[i] =  invs[mod % i] * (-mod / i);\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfacts[i] = facts[i - 1] * i;\n\t\t\tfinvs[i] = finvs[i - 1] * invs[i];\n\t\t}\n\t}\n\tinline mint fact(int n) { return facts[n]; }\n\tinline mint finv(int n) { return finvs[n]; }\n\tinline mint inv(int n) { return invs[n]; }\n\tinline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }\n};\nCombi C(N);\n\nint32_t main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n, m, k; cin >> n >> m >> k;\n\tmint ans = 0;\n\tfor (int s = 0; s <= m + k; s++) {\n\t\tmint cur = 0;\n\t\tint r = min(s, m), l = max(0, s - k);\n\t\tif (l <= r) {\n\t\t\tfor (int z = l; z <= r; z++)  cur += C.ncr(s, z);\n\t\t}\n\t\tans += cur * C.ncr(n + s - 1, n - 1) * mint(3).pow(m + k - s);\n\t}\n\tcout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int MD = 1e9+7;\nstruct Mint {\n    typedef Mint M;\n    int v;\n    Mint(int _v = 0) : v(_v) {}\n    M& operator += (const M &r) {\n        if ((v += r.v) >= MD) v -= MD;\n        return *this;\n    }\n    M& operator -= (const M &r) {\n        if ((v -= r.v) < 0) v += MD;\n        return *this;\n    }\n    M& operator *= (const M &r) {\n        v = ll(v)*r.v%MD;\n        return *this;\n    }\n    M operator + (const M &r) const { return M(*this) += r; }\n    M operator - (const M &r) const { return M(*this) -= r; }\n    M operator * (const M &r) const { return M(*this) *= r; }\n    M pow(int n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n&1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return this->pow(MD-2); }\n};\n\nconst int B = 999999;\nint N, M, K;\nMint fac[B], ifac[B];\n\nMint C(int n, int m) {\n    if (n < 0 || m < 0 || n < m) return Mint(0);\n    return fac[n]*ifac[m]*ifac[n-m];\n}\n\nvoid first() {\n    fac[0] = 1;\n    for (int i = 1; i < B; i++) fac[i] = fac[i-1]*Mint(i);\n    ifac[B-1] = fac[B-1].inv();\n    for (int i = B-2; i >= 0; i--) ifac[i] = ifac[i+1]*Mint(i+1);\n}\n\nint main() {\n    first();\n    cin >> N >> M >> K;\n    if (M > K) swap(M, K);\n\n    Mint ans = 0;\n\n    for (int i = 0; i <= M; i++) {\n        ans += C(N-1+i, N-1) * Mint(2).pow(i) * Mint(3).pow(M+K-i);\n    }\n    Mint sm = Mint(2).pow(M);\n    for (int i = M+1; i <= K; i++) {\n        sm = Mint(2) * sm - C(i-1, M);\n        ans += C(N-1+i, N-1) * sm * Mint(3).pow(M+K-i);\n    }\n    for (int i = K+1; i <= M+K; i++) {\n        sm = Mint(2) * sm - C(i-1, M) + C(i-1, i-2-K) - C(i, i-1-K);\n        ans += C(N-1+i, N-1) * sm * Mint(3).pow(M+K-i);\n    }\n\n    cout << ans.v << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int nMax=3*1e5+10;\nconst int Mod=1e9+7;\nint jc[3*nMax],_jc[3*nMax],bin[3*nMax];\nint power(int a,int b)\n{\n\tif(b==0)\n\t\treturn 1;\n\tint c=power(a,b>>1);\n\tc=(long long)c*c%Mod;\n\tif(b%2)\n\t\tc=(long long)c*a%Mod;\n\treturn c;\n}\nvoid work()\n{\n\tjc[0]=1;\n\tfor(int i=1;i<3*nMax;i++)\n\t\tjc[i]=(long long)jc[i-1]*i%Mod;\n\t_jc[3*nMax-1]=power(jc[3*nMax-1],Mod-2);\n\tfor(int i=3*nMax-2;i>=0;i--)\n\t\t_jc[i]=(long long)_jc[i+1]*(i+1)%Mod;\n\tbin[0]=1;\n\tfor(int i=1;i<3*nMax;i++)\n\t\tbin[i]=(bin[i-1]<<1)%Mod;\n}\nint _c(int a,int b)\n{\n\tif(b==0)\n\t\treturn 1;\n\tint ans=jc[b];\n\tans=(long long)ans*_jc[b-a]%Mod;\n\tans=(long long)ans*_jc[a]%Mod;\n\treturn ans;\n}\nint n,m,k,ans;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\twork();\n\tif(m>k)\n\t\tswap(m,k);\n\tfor(int i=0;i<=m;i++)\n\t\tans=(ans+((long long)bin[i]*_c(i,i+n-1)%Mod*power(3,n+m+k-i-n))%Mod)%Mod;\n\tint last=bin[m];\n\tfor(int i=m+1;i<=m+k;i++)\n\t{\n\t\tlast=(last<<1)%Mod;\n\t\tlast-=2*_c(m,i-1);\n\t\tlast=(last%Mod+Mod)%Mod;\n\t\tans=(ans+(long long)last*_c(i,i+n-1)%Mod*power(3,n+m+k-i-n)%Mod)%Mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n//nCr mod m\n#define MOD 1000000007\n#define M 1000000\nvector<ll> fact;\nbool h=false;\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 1;//??????\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nsigned main(){\n\tint out=0,sum=1;\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\t\n\tloop(i,n-1,n+m+k){\n\t\tint t=powmod(3,n+m+k-i-1)*nCr(i,n-1)%MOD;\n\t\t(out+=t*sum)%=MOD;\n\t\t\n\t\tint w=i+1-n;\n\t\t(sum*=2)%=MOD;\n\t\tif(w>=m)(sum+=MOD-nCr(w,m))%=MOD;\n\t\tif(w>=k)(sum+=MOD-nCr(w,k))%=MOD;\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <functional>\n#include <utility>\nconst int N = 1000000;\ntypedef long long ll;\nconst ll ha = 1000000007LL;\ninline ll pow_mod(ll a, ll b) {\n  ll ans = 1, res = a;\n  while(b) {\n    if(1LL & b) ans = ans * res % ha;\n    res = res * res % ha; b >>= 1;\n  }\n  return ans;\n}\ninline ll inv(ll x) {\n  return pow_mod(x, ha - 2LL);\n}\n\nll fac[N + 5], ifac[N + 5];\ninline void process() {\n  fac[0] = 1;\n  for(int i = 1; i <= N; i ++) fac[i] = fac[i - 1] * i % ha;\n  ifac[N] = inv(fac[N]);\n  for(int i = N - 1; i >= 0; i --) ifac[i] = ifac[i + 1] * (i + 1) % ha;\n}\ninline ll C(int n, int m) {\n  if(n < m) return 0;\n  return fac[n] * ifac[m] % ha * ifac[n - m] % ha;\n}\n\nll f[N + 5]; int n, m, k;\ninline void dp() {\n  f[0] = 1;\n  for(int i = 1; i <= m + k; i ++) {\n    f[i] = f[i - 1] << 1;\n    f[i] += ha - C(i - 1, m);\n    f[i] += ha - C(i - 1, k);\n    f[i] %= ha;\n  }\n}\n\nint main() {\n  process();\n  scanf(\"%d%d%d\", &n, &m, &k);\n  dp();\n  ll ans = 0;\n  for(int i = n; i <= n + m + k; i ++) {\n    ll val = f[i - n] * C(i - 1, n - 1) % ha;\n    val *= pow_mod(3, n + m + k - i);\n    ans = (ans + val) % ha;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int Max=3e5+1;\nconst long long Mod=1e9+7;\nint cnt=0,M;\nlong long P[Max*3+10]={},inv[Max*3+10]={},Pow[Max*3+10]={};\ninline long long C(int n,int m){return P[n]*inv[n-m]%Mod*inv[m]%Mod;}\nint main(){\n\tP[0]=P[1]=1; for(int i=2;i<=Max*3;i++) P[i]=i*P[i-1],P[i]%=Mod;\n\tinv[0]=inv[1]=1; for(int i=2;i<=Max*3;i++) inv[i]=inv[Mod%i]*(Mod-Mod/i)%Mod;\n\tfor(int i=2;i<=Max*3;i++) inv[i]=inv[i]*inv[i-1]%Mod;\n\tPow[0]=1; for(int i=1;i<=Max*3;i++) Pow[i]=Pow[i-1]*3%Mod;\n\tint N,M,Q; scanf(\"%d%d%d\",&N,&M,&Q);\n\tlong long Ans=0,Sum1=0,Sum2=0;\n\tfor(int i=N;i<=N+M+Q;i++){\n\t\tif(i==N){\n\t\t\tfor(int j=0;j<i-N-Q;i++) Sum1+=C(i-N,j);\n\t\t    for(int j=max(i-N-Q,0);j<=min(M,i-N);j++) Sum2+=C(i-N,j);\n\t\t}else{\n            if(i-N-Q-2>=0) Sum1=(Sum1*2%Mod-C(i-1-N,i-N-Q-2)+Mod)%Mod;\n            Sum2=(Sum2*2%Mod-C(i-1-N,min(M,i-1-N))+Mod)%Mod;\n\t\t\tif(max(i-N-Q,0)>max(i-N-Q-1,0)) Sum1+=C(i-N,i-N-Q-1),Sum1%=Mod;\n\t\t\tif(min(M,i-N-1)<min(M,i-N)) Sum2+=C(i-N,min(M,i-N)),Sum2%=Mod;\n\t\t}\n\t\tAns+=C(i-1,N-1)*Pow[N+M+Q-i]%Mod*(Sum2-Sum1+Mod)%Mod,Ans%=Mod;\n//\t\tfor(int j=max(i-N-Q,0);j<=min(M,i-N);j++)\n//\t\t Ans+=C(i-1,N-1)*C(i-N,j)%Mod*Pow[N+M+Q-i]%Mod,Ans%=Mod;  \n\t}\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\nconst int NMAX = 3e5 + 5;\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nint fct[4 * NMAX], ifct[4 * NMAX], p3[4 * NMAX];\nint cnt[4 * NMAX];\n\nint add(int x, int y) { x += y; if(x >= mod) x -= mod; return x; }\nint sub(int x, int y) { x -= y; if(x < 0) x += mod; return x; }\nint mul(int x, int y) { return (1LL * x * y) % mod; }\n\nint power(int x, int y)\n{\n    if(y == 0)  return 1;\n    int ans = power( (1LL * x * x) % mod, y >> 1 );\n    if(y & 1)   ans = (1LL * ans * x) % mod;\n    return ans;\n}\n\nvoid pre(int N)\n{\n    fct[0] = 1;\n    for(int i = 1; i <= N; i++) fct[i] = (1LL * fct[i - 1] * i) % mod;\n    ifct[N] = power(fct[N], mod - 2);\n    for(int i = N - 1; i >= 0; i--) ifct[i] = (1LL * ifct[i + 1] * (i + 1)) % mod;\n\n    p3[0] = 1;\n    for(int i = 1; i <= N; i++) p3[i] = (3LL * p3[i - 1]) % mod;\n}\n\nint C(int N, int K)\n{\n    if(N < 0 || K < 0 || N < K)  return 0;\n    int ans = fct[N];\n    ans = (1LL * ans * ifct[K]) % mod;\n    ans = (1LL * ans * ifct[N - K]) % mod;\n    return ans;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    pre(1e6);\n\n    scanf(\"%d%d%d\", &N, &M, &K);\n\n    cnt[0] = 1;\n    int lstst = 0, lstdr = 0, lstans = 1;\n    for(int i = 1; i <= M + K; i++)\n    {\n        int st = max(0, i - K);\n        int dr = min(M, i);\n        int ans = (2LL * lstans + C(i - 1, lstst - 1) - C(i - 1, lstdr) + mod) % mod;\n        while(lstst < st)\n        {\n            ans = (ans - C(i, lstst) + mod) % mod;\n            lstst++;\n        }\n        lstdr++;\n        while(lstdr <= dr)\n        {\n            ans = (ans + C(i, lstdr)) % mod;\n            lstdr++;\n        }\n\n        lstst = st, lstdr = dr, lstans = ans;\n        cnt[i] = ans;\n    }\n\n    int ans = 0;\n    for(int i = N; i <= N + M + K; i++)\n    {\n        int sol = (1LL * C(i - 1, N - 1) * cnt[i - N]) % mod;\n        sol = (1LL * sol * p3[N + M + K - i]) % mod;\n        ans = (ans + sol) % mod;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/02/01] 13:20:15\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n    std::pair<ll, ll> quad() const\n    {\n        const auto ans = quad_r(v, mod());\n        ll x = std::get<0>(ans), y = std::get<1>(ans);\n        if (y < 0) { x = -x, y = -y; }\n        return {x, y};\n    }\n\nprivate:\n    static std::tuple<ll, ll, ll> quad_r(const ll r, const ll p)  // r = x/y (mod p), (x,y,z) s.t. x=yr+pz\n    {\n        if (std::abs(r) <= 1000) { return {r, 1, 0}; }\n        ll nr = p % r, q = p / r;\n        if (nr * 2LL >= r) { nr -= r, q++; }\n        if (nr * 2LL <= -r) { nr += r, q--; }\n        const auto sub = quad_r(nr, r);\n        const ll x = std::get<0>(sub), z = std::get<1>(sub), y = std::get<2>(sub);\n        return {x, y - q * z, z};\n    }\n\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v <= 2000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\ntemplate<uint mod_value, bool dynamic = false>\nclass modcomb_base\n{\npublic:\n    using value_type = modint_base<mod_value, dynamic>;\n    modcomb_base()   = delete;\n    static void set_mod(const uint mod) { value_type::set_mod(mod), fact_ref() = {1, 1}, inv_fact_ref() = {1, 1}; }\n    static value_type fact(const usize n)\n    {\n        auto& f = fact_ref();\n        if (n < f.size()) { return f[n]; }\n        for (usize i = f.size(); i <= n; i++) { f.push_back(f.back() * i); }\n        return f.back();\n    }\n    static value_type inv_fact(const usize n)\n    {\n        auto& invf = inv_fact_ref();\n        if (n < invf.size()) { return invf[n]; }\n        for (usize i = invf.size(); i <= n; i++) { invf.push_back(invf.back() * value_type::small_inv(i)); }\n        return invf.back();\n    }\n    static value_type perm(const usize n, const usize k) { return k > n ? value_type{0} : fact(n) * inv_fact(n - k); }\n    static value_type comb(const usize n, const usize k) { return k > n ? value_type{0} : fact(n) * inv_fact(n - k) * inv_fact(k); }\n\nprivate:\n    static std::vector<value_type>& fact_ref()\n    {\n        static std::vector<value_type> f{1, 1};\n        return f;\n    }\n    static std::vector<value_type>& inv_fact_ref()\n    {\n        static std::vector<value_type> invf{1, 1};\n        return invf;\n    }\n};\ntemplate<uint mod>\nusing modcomb = modcomb_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modcomb = modcomb_base<id, true>;\nint main()\n{\n    using mint   = modint<mod>;\n    using moc    = modcomb<mod>;\n    const auto N = in<int>(), M = in<int>(), K = in<int>();\n    mint ans = 0;\n    mint cs  = 1;\n    for (int L = N; L <= N + M + K; L++) {\n        const mint coeff = moc::comb(L - 1, N - 1) / (mint(3) ^ L);\n        // mint sum         = 0;\n        // for (int m = 0; m <= M; m++) {\n        //     const int k = L - N - m;\n        //     if (k > K) { continue; }\n        //     sum += moc::comb(L - N, m);\n        // }\n        // ans += sum * coeff;\n        ans += cs * coeff;\n        cs = (cs * 2) - moc::comb(L - N, M) - (L - N - K < 0 ? mint(0) : moc::comb(L - N, L - N - K));\n    }\n    ans *= (mint(3) ^ (N + M + K));\n    outln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef complex<double> base;\nll mod=1e9+7;\nll exp(ll x,ll y){if(y<0) return 0; ll ret=1;for(;y;y>>=1,x=(x*x)%mod){if(y&1)ret=(ret*x)%mod;}return ret;}\nconst double PI=3.141592653589793238462643;\n\nvoid fft(vector<base> &a, bool inv)\n{\n\tint n=a.size(), j=0;\n\tvector<base> roots(n/2);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint bit=(n>>1);\n\t\twhile(j>=bit)\n\t\t{\n\t\t\tj-=bit;\n\t\t\tbit>>=1;\n\t\t}\n\t\tj+=bit;\n\t\tif(i<j) swap(a[i],a[j]);\n\t}\n\tdouble ang=2*acos(-1)/n*(inv?-1:1);\n\tfor(int i=0; i<n/2; i++) roots[i]=base(cos(ang*i), sin(ang*i));\n\tfor(int i=2; i<=n; i<<=1)\n\t{\n\t\tint step=n/i;\n\t\tfor(int j=0; j<n; j+=i)\n\t\t{\n\t\t\tfor(int k=0; k<i/2; k++)\n\t\t\t{\n\t\t\t\tbase u=a[j+k], v=a[j+k+i/2]*roots[step*k];\n\t\t\t\ta[j+k]=u+v;\n\t\t\t\ta[j+k+i/2]=u-v;\n\t\t\t}\n\t\t}\n\t}\n\tif(inv) for(int i=0; i<n; i++) a[i] /= n;\n}\n\nvector<ll> multiply(vector<ll> &v, vector<ll> &w)\n{\n\tint n=2; while(n<v.size()+w.size()) n<<=1;\n\tvector<base> v1(n), v2(n), r1(n), r2(n);\n\tfor(int i=0; i<v.size(); i++) v1[i]=base(v[i]>>15, v[i]&32767);\n\tfor(int i=0; i<w.size(); i++) v2[i]=base(w[i]>>15, w[i]&32767);\n\tfft(v1, false); fft(v2, false);\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tint j=(i?(n-i):i);\n\t\tbase ans1=(v1[i]+conj(v1[j]))*base(0.5, 0);\n\t\tbase ans2=(v1[i]-conj(v1[j]))*base(0, -0.5);\n\t\tbase ans3=(v2[i]+conj(v2[j]))*base(0.5, 0);\n\t\tbase ans4=(v2[i]-conj(v2[j]))*base(0, -0.5);\n\t\tr1[i]=(ans1*ans3)+(ans1*ans4)*base(0, 1);\n\t\tr2[i]=(ans2*ans3)+(ans2*ans4)*base(0, 1);\n\t}\n\tfft(r1, true); fft(r2, true);\n\tvector<ll> ret(n);\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tll av=(ll)round(r1[i].real());\n\t\tll bv=(ll)round(r1[i].imag())+(ll)round(r2[i].real());\n\t\tll cv=(ll)round(r2[i].imag());\n\t\tav%=mod, bv%=mod, cv%=mod;\n\t\tret[i]=(av<<30)+(bv<<15)+cv;\n\t\tret[i]=(ret[i]%mod+mod)%mod;\n\t}\n\treturn ret;\n}\n\nll fac[900010],invf[900010],pw3[600010];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tint n,m,k,i;\n\tcin>>n>>m>>k;\n\tfac[0]=1;\n\tfor(i=0;i++<n+m+k;)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tinvf[n+m+k]=exp(fac[n+m+k],mod-2);\n\tfor(i=n+m+k;i>0;i--)\n\t\tinvf[i-1]=invf[i]*i%mod;\n\tfor(i=1;i<=m+k;i*=2);\n\tvector<ll>x(i,0),y(i,0);\n\tfor(i=0;i<=m;i++)\n\t\tx[i]=invf[i];\n\tfor(i=0;i<=k;i++)\n\t\ty[i]=invf[i];\n\tx=multiply(x,y);\n\tpw3[0]=1;\n\tfor(i=0;i++<m+k;)\n\t\tpw3[i]=pw3[i-1]*3%mod;\n\tll ans=0;\n\tfor(i=0;i<=m+k;i++)\n\t\tans=(ans+x[i]*pw3[m+k-i]%mod*fac[n-1+i]%mod*invf[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n\nll mod_pow(ll a, ll n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tll tmp = mod_pow(a, n / 2);\n\t\treturn (tmp * tmp) % MOD;\n\t}\n\treturn (a * mod_pow(a, n - 1)) % MOD;\n}\n\nvector<ll> fact;\nvector<ll> inv_fact;\n\nvoid comb_init(int n) {\n\tfact.resize(n + 1);\n\tinv_fact.resize(n + 1);\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n}\n\nll comb(int n, int k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\nint main() {\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tcomb_init(N + M + K);\n\tll ans = 0;\n\tll now = 1;\n\tint l = 0, r = 0;\n\tfor (int i = N; i <= N + M + K; i++) {\n\t\tll x = mod_pow(3, N + M + K - i);\n\t\t(x *= comb(i - 1, N - 1)) %= MOD;\n\t\t(x *= now) %= MOD;\n\t\t(ans += x) %= MOD;\n\t\t(now *= 2) %= MOD;\n\t\tif (i >= N + K) {\n\t\t\t(now += MOD - comb(i - N, l)) %= MOD;\n\t\t\tl++;\n\t\t}\n\t\tif (i >= N + M) {\n\t\t\t(now += MOD - comb(i - N, r)) %= MOD;\n\t\t}\n\t\telse {\n\t\t\tr++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define N 1000015\nconst int p=1e9+7;\nint n,m,k,f[N],finv[N],inv[N],bin[N];\ninline int C(int nn,int mm)\n{\n\tif(nn==mm||mm==0)return 1;\n\tif(nn<mm)return 0;\n\treturn 1ll*f[nn]*finv[mm]%p*finv[nn-mm]%p;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&k);if(m<k)swap(m,k);\n    f[0]=finv[0]=f[1]=finv[1]=inv[1]=bin[0]=1;bin[1]=3;\n    for(int i=2;i<=n+m+k;i++)\n    {bin[i]=3ll*bin[i-1]%p;\n    \tinv[i]=1ll*(p-p/i)*inv[p%i]%p;\n    \tf[i]=1ll*f[i-1]*i%p;finv[i]=1ll*finv[i-1]*inv[i]%p;\n\t}int ans=0,sum=1;\n\tfor(int i=0;i<=m+k;i++)\n\t{\n\t\tint te=sum;\n\t\tte=1ll*te*bin[m+k-i]%p*C(n+i-1,n-1)%p;\n\t\tans=(ans+te)%p;\n\t\tif(i<k)sum=2ll*sum%p;\n\t\telse if(i<m)sum=(2ll*sum%p-C(i,k)+p)%p;\n\t\telse sum=(2ll*sum%p-C(i,k)+p-C(i,i-m)+p)%p;\n\t}printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nll invmod(ll x) {\n  ll e = mod - 2;\n  ll sum = 1;\n  ll cur = x;\n  while (e > 0) {\n    if (e % 2 == 1) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\nconst int N = 3000;\nll fact[N];\nll pow3[N];\n\nll comb(ll x, ll y) {\n  ll ret = fact[x];\n  ret *= invmod(fact[y]);\n  ret %= mod;\n  ret *= invmod(fact[x - y]);\n  return ret % mod;\n}\n\nint main(void){\n  int n, m, k;\n  cin >> n >> m >> k;\n  fact[0] = 1;\n  pow3[0] = 1;\n  REP(i, 1, N) {\n    fact[i] = (fact[i - 1] * i) % mod;\n    pow3[i] = pow3[i - 1] * 3 % mod;\n  }\n  \n  // \\sum_{b', c'} fact(b' + c' + n - 1) / fact(b') / fact(c') / fact(n - 1) * 3^(m - b' + k - c')\n  // = \\sum_{d = 0}^{m + k} fact(d + n - 1) / fact(n - 1) / fact(d) \\sum_{b = max(0, d - k)}^{min(d, m)} C(d, b) 3^{m + k - d}\n  ll sum = 0;\n  ll cur = 1;\n  REP(d, 0, m + k + 1) {\n    ll tmp = fact[d + n - 1];\n    tmp *= invmod(fact[n - 1]);\n    tmp %= mod;\n    tmp *= invmod(fact[d]);\n    tmp %= mod;\n    tmp *= pow3[m + k - d];\n    tmp %= mod;\n    tmp *= cur;\n    sum += tmp;\n    sum %= mod;\n    cur *= 2;\n    if (d >= k) {\n      cur += mod - comb(d, d - k);\n    }\n    if (d >= m) {\n      cur += mod - comb(d, m);\n    }\n    cur %= mod;\n  }\n  cout << sum << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n//nCr mod m\n#define MOD 1000000007\n#define M 1000000\nvector<ll> fact;\nbool h=false;\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 1;//??????\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nsigned main(){\n\tint out=0;\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tassert(n<=1000);\n\tassert(m<=1000);\n\tassert(k<=1000);\n\t\n\tloop(i,n-1,n+m+k){\n\t\tint t=powmod(3,n+m+k-i-1)*nCr(i,n-1)%MOD;\n\t\tint T=0,w=i+1-n;\n\t\trep(j,w+1){\n\t\t\tif(j>m||w-j>k)continue;\n\t\t\t(T+=nCr(w,j))%=MOD;\n\t\t}\n\t\t(out+=t*T)%=MOD;\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename T> constexpr T fpow_eq(T& x, ll y, T identity = 1) {\n    for(; y > 0; x *= x, y >>= 1) {\n        if(y & 1) {\n            identity *= x;\n        }\n    }\n    return x = identity;\n}\ntemplate <typename T> constexpr T fpow(T x, ll y, T identity = 1) { return fpow_eq(x, y, identity); }\n#ifndef __TOTIENT_INCLUDED_\n#define __TOTIENT_INCLUDED_\ntemplate <typename T, typename TEachDivisor, typename TEachPrime>\nconstexpr void factorize(T n, TEachDivisor each_divisor, TEachPrime each_prime = [](T) {}) {\n    static_assert(is_convertible<decltype(each_divisor), function<void(T)>>::value, \"each_divisor must be void(T)\");\n    static_assert(is_convertible<decltype(each_prime), function<void(T)>>::value, \"each_prime must be void(T)\");\n    for(T i = 2; i * i <= n; i++) {\n        if(n % i == 0) {\n            each_prime(i);\n            while(n % i == 0) {\n                each_divisor(i);\n                n /= i;\n            }\n        }\n    }\n    if(n > 1) {\n        each_divisor(n);\n        each_prime(n);\n    }\n}\ntemplate <typename T> constexpr T phi(T n) {\n    T ans = n;\n    factorize<T>(n, [](T) {}, [&](T p) { ans -= ans / p; });\n    return ans;\n}\n#endif\n#ifdef __TOTIENT_INCLUDED_\ntemplate <int M, int PHI_M = phi(M)> struct modint {\n#else\ntemplate <int M, int PHI_M> struct modint {\n#endif\n    static constexpr int MOD = M;\n    int val;\n    constexpr modint() : val(0) {}\n    constexpr modint(int val) : val(val % M) { this->val += this->val < 0 ? M : 0; }\n    constexpr modint(long long val) : modint(int(val % M)) {}\n    constexpr modint(const modint& m) : val(m.val) {}\n    constexpr modint(const complex<long double>& x) : modint(llround(x.real())) {}\n    constexpr explicit operator int() const { return val; }\n    constexpr bool operator==(const modint& y) const { return val == y.val; }\n    constexpr bool operator!=(const modint& y) const { return val != y.val; }\n    constexpr bool operator< (const modint& y) const { return val <  y.val; }\n    constexpr bool operator<=(const modint& y) const { return val <= y.val; }\n    constexpr bool operator> (const modint& y) const { return val >  y.val; }\n    constexpr bool operator>=(const modint& y) const { return val >= y.val; }\n    constexpr modint& operator=(const modint& y) { val = y.val; return *this; }\n    constexpr modint& operator+=(const modint& y) { val += y.val; val -= val >= M ? M : 0; return *this; }\n    constexpr modint& operator-=(const modint& y) { val -= y.val; val += val <  0 ? M : 0; return *this; }\n    constexpr modint& operator*=(const modint& y) { val = ll(val) * y.val % M; return *this; }\n    constexpr modint& operator/=(const modint& y) { val = ll(val) * fpow(y, PHI_M - 1).val % M; return *this; }\n    constexpr modint& operator^=(ll y) { fpow_eq(*this, y); return *this; }\n    constexpr modint operator+(const modint& y) const { return modint(val) += y; }\n    constexpr modint operator-(const modint& y) const { return modint(val) -= y; }\n    constexpr modint operator*(const modint& y) const { return modint(val) *= y; }\n    constexpr modint operator/(const modint& y) const { return modint(val) /= y; }\n    constexpr modint operator^(ll y) const { return modint(val) ^= y; }\n    constexpr modint operator-() const { return modint(0) -= *this; }\n    constexpr modint operator~() const { return modint(1) /= *this; }\n    constexpr modint& operator++() { val = val == M - 1 ? 0 : val + 1; return *this; }\n    constexpr modint& operator--() { val = val == 0 ? M - 1 : val - 1; return *this; }\n    constexpr modint operator++(int) { modint m = *this; ++(*this); return m; }\n    constexpr modint operator--(int) { modint m = *this; --(*this); return m; }\n    friend constexpr modint operator+(long long x, const modint& y) { return modint(x) + y; }\n    friend constexpr modint operator*(long long x, const modint& y) { return modint(x) * y; }\n    friend constexpr modint operator-(long long x, const modint& y) { return modint(x) - y; }\n    friend constexpr modint operator/(long long x, const modint& y) { return modint(x) / y; }\n    friend ostream& operator<<(ostream& os, const modint& m) { return os << m.val; }\n    friend istream& operator>>(istream& is, modint& m) { ll val; is >> val; m = modint(val); return is; }\n};\nconstexpr int M = 1'000'000'007;\nusing mint = modint<M, M - 1>;\nmint operator\"\"_m(unsigned long long int x) { return mint(ll(x)); }\ntemplate <typename T = mint> T fact(int n) {\n    static vector<T> fac = {1};\n    while(fac.size() <= n) {\n        fac.push_back(fac.back() * int(fac.size()));\n    }\n    return fac[n];\n}\ntemplate <typename T = mint> T fact_inv(int n) {\n    static vector<T> inv_fac = {1};\n    while(inv_fac.size() <= n) {\n        inv_fac.push_back(inv_fac.back() / int(inv_fac.size()));\n    }\n    return inv_fac[n];\n}\nconst double PI = acos(-1);\ncomplex<long double> w(int len, bool inverse) {\n    return polar<long double>(1, (inverse ? -2 : 2) * (PI / len));\n}\nconstexpr int lg(int x) { return 31 - __builtin_clz(x); }\ntemplate <typename T> vector<T>& pad(vector<T>& a, int min_size) {\n    a.resize(2 << lg(min_size - 1));\n    return a;\n}\nint bit_reverse(int i, int n) {\n    int ans = 0;\n    for(int j = 0; j < lg(n); j++) {\n        ans |= i & (1 << j) ? 1 << (lg(n) - 1 - j) : 0;\n    }\n    return ans;\n}\ntemplate <typename T> vector<T>& fft(vector<T>& a, bool inverse = false) {\n    int n = a.size();\n    for(int i = 0; i < n; i++) {\n        if(i < bit_reverse(i, n)) {\n            swap(a[i], a[bit_reverse(i, n)]);\n        }\n    }\n    for(int len = 2; len <= n; len <<= 1) {\n        T W = w(len, inverse);\n        for(int i = 0; i < n; i += len) {\n            T root = 1;\n            for(int j = i; j < i + (len >> 1); j++) {\n                T u = a[j], t = root * a[j + (len >> 1)];\n                a[j] = u + t;\n                a[j + (len >> 1)] = u - t;\n                root *= W;\n            }\n        }\n    }\n    if(inverse) {\n        transform(a.begin(), a.end(), a.begin(), [n](T& ai) { return ai / T(n); });\n    }\n    return a;\n}\ntemplate <typename T> vector<T>& operator*=(vector<T>& a, vector<T>& b) {\n    fft(pad(a, a.size())); if(addressof(a) != addressof(b)) fft(pad(b, b.size()));\n    assert(a.size() == b.size());\n    transform(a.begin(), a.end(), b.begin(), a.begin(), multiplies<T>());\n    fft(a, true); if(addressof(a) != addressof(b)) fft(b, true);\n    return a;\n}\ntemplate <typename T> vector<T> operator*(vector<T> a, vector<T>& b) { return a *= b; }\ntemplate <typename T> vector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n    transform(a.begin(), a.end(), b.begin(), a.begin(), plus<T>());\n    return a;\n}\ntemplate <typename T> vector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n    transform(a.begin(), a.end(), b.begin(), a.begin(), minus<T>());\n    return a;\n}\ntemplate <typename T> vector<T> operator+(vector<T> a, const vector<T>& b) { return a += b; }\ntemplate <typename T> vector<T> operator-(vector<T> a, const vector<T>& b) { return a -= b; }\ntemplate <int C = int(sqrt(mint::MOD) + 0.5)> vector<mint>& operator*=(vector<mint>& a, vector<mint>& b) {\n    vector<complex<long double>> a0(a.size()), a1(a.size()), b0(b.size()), b1(b.size());\n    transform(a.begin(), a.end(), a0.begin(), [](mint& ai) { return ai.val % C; });\n    transform(a.begin(), a.end(), a1.begin(), [](mint& ai) { return ai.val / C; });\n    transform(b.begin(), b.end(), b0.begin(), [](mint& bi) { return bi.val % C; });\n    transform(b.begin(), b.end(), b1.begin(), [](mint& bi) { return bi.val / C; });\n    vector<complex<long double>> z0 = a0 * b0, z2 = a1 * b1, z1 = (a0 += a1) * (b0 += b1);\n    z1 -= z0 -= z2;\n    for(int i = 0; i < a.size(); i++) {\n        a[i] = mint(z0[i]) + mint(z1[i]) * C + mint(z2[i]) * C * C;\n    }\n    return a;\n}\ntemplate <int C = int(sqrt(mint::MOD) + 0.5)> vector<mint> operator*(vector<mint> a, vector<mint>& b) { return a *= b; }\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<mint> a(m + k + 1);\n    for(int i = 0; i <= m + k; i++) {\n        a[i] = fact(n - 1 + i);\n    }\n    vector<mint> b(k + 1);\n    for(int j = 0; j <= k; j++) {\n        b[j] = fact_inv(j) * (3_m ^ (k - j));\n    }\n    reverse(b.begin(), b.end());\n    b.resize(a.size());\n    a *= b;\n    mint ans = 0;\n    for(int i = 0; i <= m; i++) {\n        ans += fact_inv(n - 1) * fact_inv(i) * (3_m ^ (m - i)) * a[k + i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 21);\nconst int mod = (int)1e9 + 7;\nconst double PI = acos(-1);\n\ninline void addmod(int& x, int y, int mod) { (x += y) >= mod && (x -= mod); }\ninline int mulmod(int x, int y, int mod) { return x * 1ll * y % mod; }\n\nstruct complex_base\n{\n\tdouble x, y;\n\tcomplex_base(double _x = 0, double _y = 0) { x = _x; y = _y; }\n\tfriend complex_base operator-(const complex_base &a, const complex_base &b) { return complex_base(a.x - b.x, a.y - b.y); }\n\tfriend complex_base operator+(const complex_base &a, const complex_base &b) { return complex_base(a.x + b.x, a.y + b.y); }\n\tfriend complex_base operator*(const complex_base &a, const complex_base &b) { return complex_base(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x); }\n\tfriend void operator/=(complex_base &a, const double &P) { a.x /= P; a.y /= P; }\n};\n\nint bit_rev[MAXN];\n\nvoid fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = 2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n}\n\nvoid inv_fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = -2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] /= n;\n}\n\ncomplex_base A[MAXN], B[MAXN];\n\nvector<int> mult(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() <= 128)\n\t{\n\t\tvector<int> ans(a.size() + b.size(), 0);\n\t\tfor(int i = 0; i < (int)a.size(); i++)\n\t\t\tfor(int j = 0; j < (int)b.size(); j++)\n\t\t\t\tans[i + j] = (ans[i + j] + a[i] * 1ll * b[j]) % mod;\n\n\t\treturn ans;\n\t}\n\n\tint lg = 0; while((1 << lg) < (int)(a.size() + b.size())) ++lg;\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = B[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = complex_base(a[i], 0);\n\tfor(int i = 0; i < (int)b.size(); i++) B[i] = complex_base(b[i], 0);\n\n\tfft(A, lg); fft(B, lg);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tA[i] = A[i] * B[i];\n\tinv_fft(A, lg);\n\n\tvector<int> ans(a.size() + b.size(), 0);\n\tfor(int i = 0; i < (int)ans.size(); i++)\n\t\tans[i] = (int64_t)(A[i].x + 0.5) % mod;\n\n\treturn ans;\n}\n\nvector<int> mult_mod(const vector<int> &a, const vector<int> &b)\n{\n\t/// Thanks pavel.savchenkov\n\n\t// a = a0 + sqrt(MOD) * a1\n\t// a = a0 + base * a1\n\tint base = (int)sqrtl(mod);\n\n\tvector<int> a0(a.size()), a1(a.size());\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t{\n\t\ta0[i] = a[i] % base;\n\t\ta1[i] = a[i] / base;\n\t}\n\n\tvector<int> b0(b.size()), b1(b.size());\n\tfor(int i = 0; i < (int)b.size(); i++)\n\t{\n\t\tb0[i] = b[i] % base;\n\t\tb1[i] = b[i] / base;\n\t}\n\n\tvector<int> a01 = a0;\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t\taddmod(a01[i], a1[i], mod);  \t\n\n\tvector<int> b01 = b0;\n\tfor(int i = 0; i < (int)b.size(); i++) \n\t\taddmod(b01[i], b1[i], mod);\n\n\tvector<int> C = mult(a01, b01);  // 1\n\n\tvector<int> a0b0 = mult(a0, b0); // 2\n\tvector<int> a1b1 = mult(a1, b1); // 3\n\n\tvector<int> mid = C;\n\tfor(int i = 0; i < (int)mid.size(); i++) \n\t{\n\t\taddmod(mid[i], -a0b0[i] + mod, mod);\n\t\taddmod(mid[i], -a1b1[i] + mod, mod);\n\t}\n\n\tvector<int> res = a0b0;\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, mid[i], mod), mod);\n\n\tbase = mulmod(base, base, mod);\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, a1b1[i], mod), mod);\n\n\treturn res;\n}\n\nint n, m, k;\n\nvoid read()\n{\n\tcin >> n >> m >> k;\n}\n\nvector<int> p1, p2, pw3;\n\nint pw(int x, int p)\n{\n\tint ret = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ret = (ret * 1ll * x) % mod;\n\t\tx = (x * 1ll * x) % mod;\n\t\tp >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint fact[MAXN], inv_fact[MAXN];\nint comb(int n, int k) { if(n < 0 || k < 0 || n < k) return 0; return (((fact[n] * 1ll * inv_fact[n - k]) % mod) * 1ll * inv_fact[k]) % mod; }\n\n/*   SUM C(n + i - 1, i) * C(n + i - 1 + j, j)   */\n/*   SUM C(n + i - 1, i) * fact[n + i - 1 + j] / (fact[j] * fact[n + i - 1])    */\n\n\nvoid solve()\n{\t\n\tpw3.assign(n + m + k + 1, 0);\n\tp1.assign(m + 1, 0);\n\tp2.assign(k + 1, 0);\n\tpw3[0] = 1; for(int i = 1; i <= m + k + n; i++) pw3[i] = (3ll * pw3[i - 1]) % mod;\n\tfact[0] = 1; for(int i = 1; i <= m + k + n; i++) fact[i] = (fact[i - 1] * 1ll * i) % mod;\n\tinv_fact[m + k + n] = pw(fact[m + k + n], mod - 2); for(int i = n + k + m - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * 1ll * (i + 1)) % mod; \n\n\tfor(int i = 0; i <= m; i++) p1[i] = (comb(n + i - 1, i) * 1ll * inv_fact[n + i - 1]) % mod;\n\tfor(int i = 0; i <= k; i++) p2[i] = inv_fact[i];\n\n\tvector<int> ret = mult_mod(p1, p2);\n\t\n\tint answer = 0;\n\tfor(int i = 0; i < (int)ret.size(); i++)\n\t{\n\t\tif(m + k - i < 0) break;\n\n\t\tint curr = (ret[i] * 1ll * pw3[m + k - i]) % mod;\n\t\tcurr = (curr * 1ll * fact[n - 1 + i]) % mod;\n\t\taddmod(answer, curr, mod);\n\t}\n\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fac[600010], finv[600010], inv[600010]; \nlong long MOD = 1000000007;\nvoid COMinit(){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i = 2; i < 600005; i++){\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\nlong long COM(int n, int k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main(){\n\tint N, M, K; cin >> N >> M >> K;\n\tCOMinit(); \n\tlong long pow3[600010] = {}; \n\tpow3[0] = 1; \n\tfor(int i = 1; i < 600005; i++) pow3[i] = pow3[i-1] * 3 % MOD; \n\tlong long A[600010] = {}; \n\tlong long B[600010] = {}; \n\tlong long C[600010] = {};\n\tA[0] = 1; \n\tfor(int i = 1; i <= M+K; i++){\n\t\tA[i] = ((A[i-1] * inv[i]) % MOD) * (N-1+i) % MOD; \n\t}\n\tB[0] = 1; \n\tfor(int i = 1; i <= M+K; i++){\n\t\tB[i] = B[i-1] * 2 % MOD;\n\t\tlong long mn = 0;  \n\t\tif(i > M){\n\t\t\tlong long tmp = (fac[i-1] * finv[i-1-M]) % MOD; \n\t\t\ttmp *= finv[M]; tmp %= MOD; mn += tmp;\n\t\t}\n\t\tif(i > K){\n\t\t\tlong long tmp = (fac[i-1] * finv[i-1-K]) % MOD; \n\t\t\ttmp *= finv[K]; tmp %= MOD; mn += tmp;\n\t\t}\n\t\tB[i] += MOD * 2 - mn; B[i] %= MOD; \n\t}\n\tlong long ans = 0; \n\tfor(int i = 0; i <= M+K; i++){\n\t\tans += (B[i] * pow3[M+K-i] % MOD) * A[i] % MOD; \n\t\tans %= MOD;\n\t}\n\tcout << ans << \"\\n\"; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef long long LL;\n\nconst int maxn = 1e6 + 20;\nconst int mod = 1e9 + 7;\n\nint N, M, K, sum;\nLL fac[maxn];\nLL inv[maxn];\nLL pw[maxn];\n \nLL powermod(LL x,LL y)\n{\n\tLL z = 1;\n\t\n\twhile(y)\n\t{\n\t\tif(y & 1) z = z * x % mod;\n\t\tx = x * x % mod, y >>= 1;\n\t}\n\t\n\treturn z;\n}\nLL combine(LL x,LL y)\n{\n\tif(y < 0 || y > x) return 0;\n\treturn fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &K);\n\tsum = N + M + K;\n\t\n\tpw[0] = fac[0] = inv[0] = 1;\n\tfor(int i = 1; i <= sum; i++)\n\t{\n\t\tpw[i] = pw[i - 1] * 3 % mod;\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t}\n\t\n\tinv[sum] = powermod(fac[sum], mod - 2);\n\tfor(int i = sum - 1; i >= 1; i--)\n\t{\n\t\tinv[i] = inv[i + 1] * (i + 1) % mod;\n\t}\n\t\n\tLL s = 1, ans = 0;\n\t\n\tfor(int i = 0; i <= M + K; i++)\n\t{\n\t\tans += s * combine(N - 1 + i, N - 1) % mod * pw[M + K - i] % mod;\n\t\ts = s * 2 - combine(i, M) - combine(i, K);\n\t\ts = (s % mod + mod) % mod;\n\t}\n\tans %= mod;\n\t\n\tprintf(\"%d\", (int) ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,k,sum,ans,inv[900010],Pow[900010],Mod=1e9+7;\nint Add(int aa,int bb) {return (aa+=bb)>Mod? aa-Mod:aa;}\nint Sub(int aa,int bb) {return (aa-=bb)<0? aa+Mod:aa;}\nint Mul(int aa,int bb) {return 1LL*aa*bb%Mod;}\nint ksm(int aa,int bb)\n{\n\tint an=1;\n\tfor (;bb;bb>>=1) {\n\t\tif (bb&1) an=Mul(an,aa);\n\t\taa=Mul(aa,aa);\n    }\n    return an;\n}\nint C(int N,int M)\n{\n\tif (N<M) return 0;\n\treturn Mul(Mul(Pow[N],inv[N-M]),inv[M]);\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tPow[0]=1;\n\tfor (int i=1;i<=n+m+k;i++)\n\t  Pow[i]=Mul(Pow[i-1],i);\n    inv[n+m+k]=ksm(Pow[n+m+k],Mod-2);\n    inv[0]=1;\n    for (int i=n+m+k-1;i;i--)\n      inv[i]=Mul(inv[i+1],i+1); \n\tsum=1;ans=ksm(3,n+m+k-n);\n\tfor (int i=n+1;i<=n+k;i++) {\n\t  sum=Sub(sum*2%Mod,C(i-1-n,m));\n\t  ans=Add(ans,Mul(Mul(C(i-1,n-1),sum),ksm(3,n+m+k-i)));\n    }\n\tfor (int i=n+k+1;i<=n+m+k;i++) {\n\t\tsum=Sub(sum*2%Mod,C(i-1-n,m));\n\t\tsum=Sub(sum,C(i-1-n,i-1-n-k));\n\t\tans=Add(ans,Mul(Mul(C(i-1,n-1),sum),ksm(3,n+m+k-i)));\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\t\t  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <tuple>\n#include <vector>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#include <numeric>\n#include <queue>\n#include <cmath>\n#include <iomanip>\n#include <array>\n#include <string>\n#include <stack>\n#include <cassert>\n#include <memory>\n#include <random>\n\n\nconstexpr long long int MOD = 1000000007LL;\nlong long int power(const long long int base, const int exp) {\n\tswitch (exp) {\n\tcase 0: return 1LL;\n\tcase 1: return base % MOD;\n\tdefault: return power(base * base % MOD, exp >> 1) * power(base, exp & 1) % MOD;\n\t}\n}\nint main() {\n\tint n, m, k; std::cin >> n >> m >> k;\n\tstd::vector<long long int> factorial(n + m + k + 1, 1), div(n + m + k + 1, 1), inverse(n + m + k + 1, 1);\n\tfor (auto i = 2; i < factorial.size(); ++i) {\n\t\tfactorial[i] = i * factorial[i - 1] % MOD;\n\t\tdiv[i] = (MOD - MOD / i) * div[MOD % i] % MOD;\n\t\tinverse[i] = div[i] * inverse[i - 1] % MOD;\n\t}\n\tconst auto combination = [&factorial, &inverse](const int n, const int r) {return factorial[n] * inverse[n - r] % MOD * inverse[r] % MOD; };\n\tlong long int result{ power(3, m + k) };\n\tlong long int prev{ 1 };\n\tfor (auto len = n + 1; len <= n + m + k; ++len) {\n\t\tconst auto rest = len - n;\n\t\tconst auto a_pattern = combination(len - 1, n - 1);\n\t\tconst auto min = std::max(rest - k, 0);\n\t\tconst auto max = std::min(rest, m);\n\t\tprev <<= 1;\n\t\tif (min > 0) {\n\t\t\tprev += MOD - combination(rest - 1, min - 1);\n\t\t}\n\t\tif (rest > m) {\n\t\t\tprev += MOD - combination(rest - 1, m);\n\t\t}\n\t\tprev %= MOD;\n\t\tresult = (result + a_pattern * prev % MOD * power(3, n + m + k - len)) % MOD;\n\t}\n\tstd::cout << result << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 3e5 + 1, Mod = 1e9 + 7;\n\nnamespace Mathscalc {\n    inline int Add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\n    inline int Sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\n    inline int Mul(int a, int b) { return 1LL * a * b % Mod; }\n} using namespace Mathscalc;\n\nint n, m, k;\n\nint jc[MAXN << 2], inv[MAXN << 2], invj[MAXN << 2], p[MAXN << 2];\nvoid GetNeed() {\n    p[0] = 1; for (int i = 1; i <= MAXN * 3; ++i) p[i] = Mul(p[i - 1], 3);\n    jc[0] = 1; for (int i = 1; i <= MAXN * 3; ++i) jc[i] = Mul(jc[i - 1], i);\n    inv[1] = 1; for (int i = 2; i <= MAXN * 3; ++i) inv[i] = Mul(Sub(Mod, Mod / i), inv[Mod % i]);\n    invj[0] = 1; for (int i = 1; i <= MAXN * 3; ++i) invj[i] = Mul(invj[i - 1], inv[i]);\n}\n\ninline int C(int n, int m) { return Mul(jc[n], Mul(invj[m], invj[n - m])); }\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &k);\n    GetNeed();\n    if (m < k) std :: swap(m, k); --n;\n    int ans = 0, x = 1;\n    for (int i = 0; i <= m + k; ++i) {\n        ans = Add(ans, Mul(C(n + i, n), Mul(p[m + k - i], x)));\n        if (i < k) x = Mul(x, 2);\n        else if (i < m) x = Sub(Mul(x, 2), C(i, k));\n        else x = Sub(Mul(x, 2), Add(C(i, m), C(i, k)));\n    }\n\tprintf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define mod 1000000007\n#define ran 111111\nint mul(int x,int y){\n\treturn (int)((long long int)x*y%mod);\n}\nint add(int x,int y){\n\treturn (x+=y)<mod?x:x-mod;\n}\nint pw(int x,int y){\n\tint r=1;\n\twhile(1){\n\t\tif(y&1)r=mul(r,x);\n\t\tif(y>>=1)x=mul(x,x);else\n\t\t\tbreak;\n\t}\n\treturn r;\n}\nint inv(int x){\n\treturn pw(x,mod-2);\n}\nint fac[ran],ifac[ran];\nint mix2(int x,int y){\n\treturn mul(fac[x+y],mul(ifac[x],ifac[y]));\n}\nint mix3(int x,int y,int z){\n\treturn mul(fac[x+y+z],(mul(mul(ifac[x],ifac[y]),ifac[z])));\n}\nint main(){\n\tfac[0] = 1;\n\tfor(int i=1; i<ran; i++){\n\t\tfac[i] = mul(fac[i-1],i);\n\t\tifac[i] = inv(fac[i]);\n\t}\n\n\tint n,m,k;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tint res = 0;\n\tfor(int i=0; i<=m; i++)\n\t\tfor(int j=0; j<=k; j++){\n\t\t\tint now = 1;\n\t\t\tif(i==0 && j==0)\n\t\t\t\tnow=1;\n\t\t\telse\n\t\t\tif(i==0)\n\t\t\t\tnow=mix2(n-1, j);\n\t\t\telse\n\t\t\tif(j==0)\n\t\t\t\tnow=mix2(n-1, i);\n\t\t\telse{\n\t\t\t\tnow=0;\n\t\t\t\tnow=add(now,mix3(n-2,i,j));\n\t\t\t\tnow=add(now,mix3(n-1,i-1,j));\n\t\t\t\tnow=add(now,mix3(n-1,i,j-1));\n\t\t\t}\n\t\t\tres = add(res, mul(now, pw(3, m+k-i-j)));\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define long long LL\nconst int N=1000005;\nconst int M=1e9+7;\nint n,m,k,ans,f[N],v[N],sum;\nint fp(int x,int y){int s=1;\nfor(;y;y>>=1){if(y&1)s=1ll*s*x%M;\nx=1ll*x*x%M;}return s;}\nint C(int x,int y){\nreturn 1ll*f[x]*v[y]%M*v[x-y]%M;}\nsigned main(){scanf(\"%d%d%d\",&n,&m,&k);\nf[0]=v[0]=1;sum=n+m+k;\nfor(int i=1;i<=sum;i++)f[i]=1ll*f[i-1]*i%M;\nv[sum]=fp(f[sum],M-2);for(int i=sum-1;i;i--)\nv[i]=1ll*v[i+1]*(i+1)%M;if(m<k)swap(m,k);int q=1;\nfor(int i=n;i<=sum;i++){if(k+n>=i){\n(ans+=1ll*C(i-1,n-1)*fp(3,sum-i)%M*q%M)%=M;\nif(k+n!=i)q=q*2%M;}\nelse if(n+m>=i){q=q*2-C(i-n-1,k);q=(q%M+M)%M;\n(ans+=1ll*q*C(i-1,n-1)%M*fp(3,sum-i)%M)%=M;}\nelse{q=q*2-C(i-n-1,k);q=(q%M+M)%M;\nq=(q-C(i-n-1,i-n-m-1)+M)%M;\n(ans+=1ll*q*C(i-1,n-1)%M*fp(3,sum-i)%M)%=M;}\n}printf(\"%d\\n\",(ans+M)%M);return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define int long long\n\nusing namespace std;\ntypedef long long LL;\nconst int N=1000005;\nconst int MOD=1e9+7;\n\nint n,m,k,ans,fac[N],inv[N],sum;\n\ninline int fast_pow(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1){\n\t\tif(y&1) ret=1ll*ret*x%MOD;\n\t\tx=1ll*x*x%MOD;\n\t}\n\treturn ret;\n}\n\ninline int C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%MOD*inv[x-y]%MOD;\t\n}\n\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&m,&k);\n\tfac[0]=inv[0]=1; sum=n+m+k;\n\tfor(int i=1;i<=sum;i++) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[sum]=fast_pow(fac[sum],MOD-2);\n\tfor(int i=sum-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n\t/*\n\tfor(int i=n;i<=sum;i++){\n\t\tint now=0;\n\t\tfor(int j=max(i-n-m,1ll*0);j<=min(k,i-n);j++)\n\t\t\t(now+=C(i-n,j))%=MOD;\n\t\tans+=now%MOD*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD;\n\t\tans%=MOD;\n\t}\n\t*/\n\tif(m<k) swap(m,k); int now=1;\n\tfor(int i=n;i<=sum;i++){\n\t\tif(k+n>=i) {\n\t\t\t(ans+=1ll*C(i-1,n-1)*fast_pow(3,sum-i)%MOD*now%MOD)%=MOD;\n\t\t\tif(k+n!=i) now=now*2%MOD; \t\n\t\t}\n\t\telse if(k+m>=i) {\n\t\t\tnow=now*2-C(i-n-1,k);\n\t\t\tnow=(now%MOD+MOD)%MOD;\n\t\t\t(ans+=1ll*now*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n\t\t}\n\t\telse {\n\t\t\tnow=now*2-C(i-n-1,k); now=(now%MOD+MOD)%MOD;\n\t\t\tnow=(now-C(i-n-1,i-n-m-1)+MOD)%MOD;\n\t\t\t(ans+=1ll*now*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n\t\t}\n\t}\n//\tfor(int i=n;i<=sum;i++) {\n//\t\t(ans+=1ll*C(i-1,n-1)*fast_pow(2,i-n)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tif(i==8) cout<<ans<<endl;\n//\t\tif(n+k+1<=i) \n//\t\t\t(ans-=1ll*C(i-1,n-1)*C(i-n,k+1)%MOD*fast_pow(2,i-n-k-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tif(i==8) cout<<ans<<endl;\n//\t\tif(n+m+1<=i)\n//\t\t\t(ans-=1ll*C(i-1,n-1)*C(i-n,m+1)%MOD*fast_pow(2,i-n-m-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tcout<<ans<<endl;\n//\t}\n//\tfor(int i=n+m;i<sum;i++){\n//\t\t(ans-=1ll*now*fast_pow(3,sum-n-m)%MOD)%=MOD;\n//\t\tnow=1ll*now*i%MOD; now=(now+C(n+m,i-n-m+1))%MOD;\t\n//\t}\n//\tnow=1;\n//\tfor(int i=n+k;i<sum;i++){\n//\t\t(ans-=1ll*now*fast_pow(3,sum-n-k)%MOD)%=MOD;\n//\t\tnow=1ll*now*i%MOD; now=(now+C(n+k,i-n-k+1))%MOD;\n//\t}\t\n\tprintf(\"%lld\\n\",(ans+MOD)%MOD);\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int mod=1e9+7;\nconst int INF=0x3f3f3f3f;\nll quick(ll a,ll b)\n{\n\tll ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nconst int maxn=1e6+7;\nll fac[maxn];\nvoid db()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<maxn;i++)\n\t\tfac[i]=fac[i-1]*i%mod;\n}\nll C(int n,int m)\n{\n\treturn fac[n]*inv(fac[n-m])%mod*inv(fac[m])%mod;\n}\nint main()\n{\n\tdb();\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tll ans=0;\n\tll cur=1;\n\tfor(int t=0;t<=m+k;t++)\n\t{\n\t\tans=(ans+cur*C(t+n-1,n-1)%mod*quick(3,m+k-t)%mod)%mod;\n\t\tcur=cur*2%mod;\n\t\tif(t+1>m)\n\t\t\tcur=(cur-C(t,m)+mod)%mod;\n\t\tif(t+1>k) cur=(cur-C(t,t-k)+mod)%mod;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Mod = 1e9 + 7;\nconst int N = 9e5;\n\nint n, m, k;\nlong long fac[N], vfac[N];\n\nlong long mpow( long long a, int b ) {\n\tlong long rt;\n\tfor( rt = 1; b; b >>= 1, a = (a * a) % Mod )\n\t\tif( b & 1 ) rt = (rt * a) % Mod;\n\treturn rt;\n}\nvoid init( int n ) {\n\tfac[0] = 1;\n\tfor( int i = 1; i <= n; i++ )\n\t\tfac[i] = (fac[i-1] * i) % Mod;\n\tvfac[n]  = mpow( fac[n], Mod - 2 );\n\tfor( int i = n - 1; i >= 0; i-- )\n\t\tvfac[i] = vfac[i+1] * (i + 1) % Mod;\n}\nlong long comb( int n, int m ) {\n\treturn fac[n] * vfac[n-m] % Mod * vfac[m] % Mod;\n}\nint main() {\n\tscanf( \"%d%d%d\", &n, &m, &k );\n\tif( m < k ) swap( m, k );\n\tinit( m + k + n );\n\tlong long sum = 0, ans = 0;\n\tfor( int s = 0; s <= m + k; s++ ) {\n\t\tif( s == 0 ) {\n\t\t\tsum = 1;\n\t\t} else if( s <= k ) {\n\t\t\tsum = (sum<<1) % Mod;\n\t\t} else if( s <= m ) {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1)) % Mod;\n\t\t} else {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1) + Mod - comb(s-1,m)) % Mod;\n\t\t}\n\t\tlong long sub = sum * comb(n-1+s,n-1) % Mod * mpow(3,m+k-s) % Mod;\n\t\tans = (ans + sub) % Mod;\n//\t\tprintf( \"s = %d sub = %lld\\n\", s, sub );\n\t}\n\tprintf( \"%lld\\n\", ans );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int mod=1e9+7;\nconst int MAXN=300005;\nconst double PI=acos(-1.0);\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nint pre[MAXN*4],inv[MAXN*4],n,m,K;\nint binom(int n,int m){return 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\n\nconst int M=sqrt(mod);\nstruct Complex\n{\n\tlong double r,i;Complex(){}Complex(long double _r,long double _i){r=_r;i=_i;}\n\tfriend Complex operator +(Complex u,Complex v){return Complex(u.r+v.r,u.i+v.i);}\n\tfriend Complex operator -(Complex u,Complex v){return Complex(u.r-v.r,u.i-v.i);}\n\tfriend Complex operator *(Complex u,Complex v){return Complex(u.r*v.r-u.i*v.i,u.r*v.i+u.i*v.r);}\n};\nvector<Complex> wn[2][25];\nvoid init()\n{\n\tfor(int i=1,t=0;i<MAXN*4;i<<=1,++t)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\twn[0][t].emplace_back(Complex(cos(PI*j/i),sin(PI*j/i)));\n\t\t\twn[1][t].emplace_back(Complex(cos(PI*j/i),sin(-1*PI*j/i)));\n\t\t}\n\t}\n}\nint R[MAXN*4],L;\nvoid FFT(Complex *y,int len,int on)\n{\n\tfor(int i=0;i<len;i++)if(i<R[i])swap(y[i],y[R[i]]);int g=(on==-1?1:0);\n\tfor(int i=1,t=0;i<len;i<<=1,++t)\n\t{\n//\t\tComplex wn=Complex(cos(PI/i),sin(on*PI/i));\n\t\tfor(int j=0;j<len;j+=(i<<1))\n\t\t{\n//\t\t\tComplex w=Complex(1,0);\n\t\t\tfor(int k=0;k<i;k++)\n\t\t\t{\n\t\t\t\tComplex u=y[j+k],v=y[j+k+i]*wn[g][t][k];\n\t\t\t\ty[j+k]=u+v;y[j+k+i]=u-v;\n\t\t\t}\n\t\t}\n\t}if(on==-1)for(int i=0;i<len;i++)y[i].r/=len;\n}\nvoid clear(Complex *a,int ln){for(int i=0;i<ln;i++)a[i]=Complex(0,0);}\nint AA[MAXN*4],BB[MAXN*4],val[MAXN*4];\nComplex A[MAXN*4],B[MAXN*4],C[MAXN*4],D[MAXN*4];\nComplex A1[MAXN*4],B1[MAXN*4],C1[MAXN*4];\nvoid mul(int *a,int *b,int *ret,int n,int m)\n{\n\tint ln=1;L=0;for(ln=1;ln<=n+m-1;ln<<=1)++L;\n\tfor(int i=0;i<ln;i++)R[i]=(R[i>>1]>>1)|(i&1)<<(L-1);\n\tclear(A,ln);clear(B,ln);clear(C,ln);clear(D,ln);clear(A1,ln);clear(B1,ln);clear(C1,ln);\n\tfor(int i=0;i<n;i++)A[i]=Complex(a[i]/M,0),B[i]=Complex(a[i]%M,0);\n\tfor(int i=0;i<m;i++)C[i]=Complex(b[i]/M,0),D[i]=Complex(b[i]%M,0);\n\tFFT(A,ln,1);FFT(B,ln,1);FFT(C,ln,1);FFT(D,ln,1);\n\tfor(int i=0;i<ln;i++)A1[i]=A[i]*C[i],B1[i]=B[i]*C[i]+A[i]*D[i],C1[i]=B[i]*D[i];\n\tFFT(A1,ln,-1);FFT(B1,ln,-1);FFT(C1,ln,-1);\n\tfor(int i=0;i<n+m-1;i++)A1[i].r=(LL)(A1[i].r+0.5),B1[i].r=(LL)(B1[i].r+0.5),C1[i].r=(LL)(C1[i].r+0.5);\n\tfor(int i=0;i<n+m-1;i++)\n\t{\n\t\tLL u=A1[i].r,v=B1[i].r,w=C1[i].r;u%=mod;v%=mod;w%=mod;\n//\t\tu=(u+mod)%mod;v=(v+mod)%mod;w=(w+mod)%mod;\n\t\tret[i]=(1LL*u*M%mod*M%mod+1LL*v*M%mod+w)%mod;\n\t}\n}\nint main()\n{\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"b.out\",\"w\",stdout);\n\tinit();\n\tpre[0]=1;for(int i=1;i<MAXN*4;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN*4-1]=pow_mod(pre[MAXN*4-1],mod-2);\n\tfor(int i=MAXN*4-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tn=read();m=read();K=read();int ans=0;\n//\tfor(int x=0;x<=m;x++)for(int y=0;y<=K;y++)\n//\t\tad(ans,1LL*pow_mod(3,m-x)*pow_mod(3,K-y)%mod*C(n+x+y-1,x)%mod*C(n+y-1,y)%mod);\n\tfor(int i=0;i<=m;i++)AA[i]=inv[i];\n\tfor(int i=0;i<=K;i++)BB[i]=inv[i];\n\tmul(AA,BB,val,m+1,K+1);\n\tfor(int i=0;i<=m+K;i++)\n\t{\n//\t\tpr2(val[i]);\n\t\tad(ans,1LL*pow_mod(3,m+K-i)*binom(n+i-1,i)%mod*val[i]%mod*pre[i]%mod);\n\t}\n\tpr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int mod=1e9+7;\nconst int MAXN=300005;\nconst double PI=acos(-1.0);\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nint pre[MAXN*4],inv[MAXN*4],n,m,K;\nint binom(int n,int m){return 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\n\nconst int M=sqrt(mod);\nstruct Complex\n{\n\tdouble r,i;Complex(){}Complex(double _r,double _i){r=_r;i=_i;}\n\tfriend Complex operator +(Complex u,Complex v){return Complex(u.r+v.r,u.i+v.i);}\n\tfriend Complex operator -(Complex u,Complex v){return Complex(u.r-v.r,u.i-v.i);}\n\tfriend Complex operator *(Complex u,Complex v){return Complex(u.r*v.r-u.i*v.i,u.r*v.i+u.i*v.r);}\n};\nvector<Complex> wn[2][25];\nvoid init()\n{\n\tfor(int i=1,t=0;i<MAXN*4;i<<=1,++t)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\twn[0][t].emplace_back(Complex(cos(PI*j/i),sin(PI*j/i)));\n\t\t\twn[1][t].emplace_back(Complex(cos(PI*j/i),sin(-1*PI*j/i)));\n\t\t}\n\t}\n}\nint R[MAXN*4],L;\nvoid FFT(Complex *y,int len,int on)\n{\n\tfor(int i=0;i<len;i++)if(i<R[i])swap(y[i],y[R[i]]);int g=(on==-1?1:0);\n\tfor(int i=1,t=0;i<len;i<<=1,++t)\n\t{\n//\t\tComplex wn=Complex(cos(PI/i),sin(on*PI/i));\n\t\tfor(int j=0;j<len;j+=(i<<1))\n\t\t{\n//\t\t\tComplex w=Complex(1,0);\n\t\t\tfor(int k=0;k<i;k++)\n\t\t\t{\n\t\t\t\tComplex u=y[j+k],v=y[j+k+i]*wn[g][t][k];\n\t\t\t\ty[j+k]=u+v;y[j+k+i]=u-v;\n\t\t\t}\n\t\t}\n\t}if(on==-1)for(int i=0;i<len;i++)y[i].r/=len;\n}\nvoid clear(Complex *a,int ln){for(int i=0;i<ln;i++)a[i]=Complex(0,0);}\nint AA[MAXN*4],BB[MAXN*4],val[MAXN*4];\nComplex A[MAXN*4],B[MAXN*4],C[MAXN*4],D[MAXN*4];\nComplex A1[MAXN*4],B1[MAXN*4],C1[MAXN*4];\nvoid mul(int *a,int *b,int *ret,int n,int m)\n{\n\tint ln=1;L=0;for(ln=1;ln<=n+m-1;ln<<=1)++L;\n\tfor(int i=0;i<ln;i++)R[i]=(R[i>>1]>>1)|(i&1)<<(L-1);\n\tclear(A,ln);clear(B,ln);clear(C,ln);clear(D,ln);clear(A1,ln);clear(B1,ln);clear(C1,ln);\n\tfor(int i=0;i<n;i++)A[i]=Complex(a[i]/M,0),B[i]=Complex(a[i]%M,0);\n\tfor(int i=0;i<m;i++)C[i]=Complex(b[i]/M,0),D[i]=Complex(b[i]%M,0);\n\tFFT(A,ln,1);FFT(B,ln,1);FFT(C,ln,1);FFT(D,ln,1);\n\tfor(int i=0;i<ln;i++)A1[i]=A[i]*C[i],B1[i]=B[i]*C[i]+A[i]*D[i],C1[i]=B[i]*D[i];\n\tFFT(A1,ln,-1);FFT(B1,ln,-1);FFT(C1,ln,-1);\n\tfor(int i=0;i<n+m-1;i++)A1[i].r=(LL)(A1[i].r+0.5),B1[i].r=(LL)(B1[i].r+0.5),C1[i].r=(LL)(C1[i].r+0.5);\n\tfor(int i=0;i<n+m-1;i++)\n\t{\n\t\tLL u=A1[i].r,v=B1[i].r,w=C1[i].r;u%=mod;v%=mod;w%=mod;\n\t\tret[i]=(1LL*u*M%mod*M%mod+1LL*v*M%mod+w)%mod;\n\t}\n}\nint main()\n{\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"b.out\",\"w\",stdout);\n\tinit();\n\tpre[0]=1;for(int i=1;i<MAXN*4;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN*4-1]=pow_mod(pre[MAXN*4-1],mod-2);\n\tfor(int i=MAXN*4-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tn=read();m=read();K=read();int ans=0;\n//\tfor(int x=0;x<=m;x++)for(int y=0;y<=K;y++)\n//\t\tad(ans,1LL*pow_mod(3,m-x)*pow_mod(3,K-y)%mod*C(n+x+y-1,x)%mod*C(n+y-1,y)%mod);\n\tfor(int i=0;i<=m;i++)AA[i]=inv[i];\n\tfor(int i=0;i<=K;i++)BB[i]=inv[i];\n\tmul(AA,BB,val,m+1,K+1);\n\tfor(int i=0;i<=m+K;i++)\n\t{\n//\t\tpr2(val[i]);\n\t\tad(ans,1LL*pow_mod(3,m+K-i)*binom(n+i-1,i)%mod*val[i]%mod*pre[i]%mod);\n\t}\n\tpr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2) \n#include<bits/stdc++.h>\n#define rg register\n#define il inline\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7,O=1000010;\nil int gi(){\n\trg int o=0,fl=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')fl=-1,ch=getchar();\n\twhile(isdigit(ch))o=o*10+ch-'0',ch=getchar();\n\treturn fl*o;\n}\nint n,m,k;\nll fac[O],inv[O],bin[O],ans,x=1;\nil ll C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);n--;\n\tbin[0]=fac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<O;++i)bin[i]=bin[i-1]*3%mod;\n\tfor(int i=2;i<O;++i){\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tfor(int i=2;i<O;++i)inv[i]=inv[i-1]*inv[i]%mod;\n\tfor(int i=0;i<=m+k;++i){\n\t\t(ans+=C(n+i,n)*bin[m+k-i]%mod*x%mod)%=mod;\n//\t\tprintf(\"%lld %lld %lld %lld\\n\",C(n+i,n),bin[m+k-i],x,ans<0?ans+mod:ans);\n\t\tif(i<k)(x<<=1)%=mod;\n        else if(i<m)x=((x*2-C(i,k))%mod+mod)%mod;\n        else x=((x*2-C(i,k)-C(i,m))%mod+mod)%mod;\n\t}\n\tans%=mod;\n\tprintf(\"%lld\",ans<0?ans+mod:ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \nll mul( ll x , ll  y ) \n{\n    return ( 1ll * x * y ) % mod ;\n}\nll add( ll x , ll y ) {\n    return ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n    int ans = 1 , base = a ;\n    while( b ) {\n        if( b&1 ) ans = mul( ans , base ) ;\n        base = mul( base , base ) ;\n        b >>= 1 ;\n    }\n    return ans ;\n}\n\nll inv( ll x ) {\n    return power( x , mod - 2 ) % mod ;\n}\nll C( ll x , ll y ) {\n    return ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\nint main() {\n    scanf( \"%d%d%d\" , &n , &m , &k ) ;\n    fac[ 0 ] = 1ll ;\n    p[ 0 ] = 1ll ;\n    for( int i = 1 ; i < N ; i ++ ) {\n        fac[ i ] = fac[ i - 1 ] * i % mod ;\n        p[ i ] = p[ i - 1 ] * 3ll % mod ;\n    }\n    for( int i = 0 ; i < N ; i ++ ) {\n        ifac[ i ] = inv( fac[ i ] ) ;\n    }\n    ll ans = 0 , x = 1ll ;\n    n -- ;\n    for( int i = 0 ; i <= m + k ; i ++ ) {\n        ans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n        if( i < k ) x = ( x * 2ll ) % mod ;\n        else if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n        else  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n    }\n    printf( \"%lld\\n\" , add( ans , mod ) ) ;\n    return 0 ;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MOD 1000000007\n#define N 100000\nusing namespace std;\ntypedef long long LL;\nLL mod_pow(LL base, LL exp)\n{\n\tif(exp==0) return 1;\n\tif(exp&1) return (mod_pow(base,exp-1)*base)%MOD;\n\telse return mod_pow((base*base)%MOD,exp/2);\n}\nLL fac[3*N+1];\nLL fac_inv[3*N+1];\nLL C(LL n, LL k)\n{\n\tif(k < 0 || n < k) return 0;\n\tLL num = fac[n];\n\tLL den = (fac_inv[n-k]*fac_inv[k])%MOD;\n\treturn (num*den)%MOD;\n}\nint main()\n{\n\tfac[0] = 1;\n\tfor(LL n = 1; n <= 3*N; n++)\n\t\tfac[n] = (fac[n-1]*n)%MOD;\n\tfac_inv[3*N] = mod_pow(fac[3*N],MOD-2);\n\tfor(LL n = 3*N-1; n >= 0; n--)\n\t\tfac_inv[n] = (fac_inv[n+1]*(n+1))%MOD;\n\n\tLL a, b, c; cin >> a >> b >> c;\n\ta++;\n\t//WLOG, b > c\n\tif(!(b>c))\n\t{\n\t\tb = b^c;\n\t\tc = b^c;\n\t\tb = b^c;\n\t}\n\n\tLL ans = 0;\n\tLL sum = 1;\n\tLL pull = 0;\n\tfor(LL n = a; n <= a+b+c; n++)\n\t{\n\t\tLL sub = 0;\n\t\t\n\t\tsub = (sub+sum-pull)%MOD;\n\t\tsub = (sub*C(n-2,a-2))%MOD;\n\t\tsub = (sub*mod_pow(3,a+b+c-n))%MOD;\n\t\tans = (ans+sub)%MOD;\n\n\t\tsum  = (2*sum-C(n-a,c))%MOD;\n\t\tpull = (2*pull+C(n-a,n-a-b))%MOD;\n\t}\n\tcout<<(ans+MOD)%MOD<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long LL;\nconst int N=1000005;\nconst int MOD=1e9+7;\n\nint n,m,k,ans,fac[N],inv[N],sum;\n\ninline int fast_pow(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1){\n\t\tif(y&1) ret=1ll*ret*x%MOD;\n\t\tx=1ll*x*x%MOD;\n\t}\n\treturn ret;\n}\n\ninline int C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%MOD*inv[x-y]%MOD;\t\n}\n\nsigned main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfac[0]=inv[0]=1; sum=n+m+k;\n\tfor(int i=1;i<=sum;i++) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[sum]=fast_pow(fac[sum],MOD-2);\n\tfor(int i=sum-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n//\tfor(int i=n;i<=sum;i++){\n//\t\tint now=0;\n//\t\tfor(int j=max(i-n-m,1ll*0);j<=min(k,i-n);j++)\n//\t\t\t(now+=C(i-n,j))%=MOD;\n//\t\tans+=now%MOD*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD;\n//\t\tans%=MOD;\n//\t}\n//\tcout<<ans<<endl; ans=0;\n\tif(m<k) swap(m,k); int now=1;\n\tfor(int i=n;i<=sum;i++){\n\t\tif(k+n>=i) {\n\t\t\t(ans+=1ll*C(i-1,n-1)*fast_pow(3,sum-i)%MOD*now%MOD)%=MOD;\n\t\t\tif(k+n!=i) now=now*2%MOD; \t\n\t\t}\n\t\telse if(n+m>=i) {\n\t\t\tnow=now*2-C(i-n-1,k);\n\t\t\tnow=(now%MOD+MOD)%MOD;\n\t\t\t(ans+=1ll*now*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n\t\t}\n\t\telse {\n\t\t\tnow=now*2-C(i-n-1,k); now=(now%MOD+MOD)%MOD;\n\t\t\tnow=(now-C(i-n-1,i-n-m-1)+MOD)%MOD;\n\t\t\t(ans+=1ll*now*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n\t\t}\n\t}\n//\tfor(int i=n;i<=sum;i++) {\n//\t\t(ans+=1ll*C(i-1,n-1)*fast_pow(2,i-n)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tif(i==8) cout<<ans<<endl;\n//\t\tif(n+k+1<=i) \n//\t\t\t(ans-=1ll*C(i-1,n-1)*C(i-n,k+1)%MOD*fast_pow(2,i-n-k-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tif(i==8) cout<<ans<<endl;\n//\t\tif(n+m+1<=i)\n//\t\t\t(ans-=1ll*C(i-1,n-1)*C(i-n,m+1)%MOD*fast_pow(2,i-n-m-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tcout<<ans<<endl;\n//\t}\n//\tfor(int i=n+m;i<sum;i++){\n//\t\t(ans-=1ll*now*fast_pow(3,sum-n-m)%MOD)%=MOD;\n//\t\tnow=1ll*now*i%MOD; now=(now+C(n+m,i-n-m+1))%MOD;\t\n//\t}\n//\tnow=1;\n//\tfor(int i=n+k;i<sum;i++){\n//\t\t(ans-=1ll*now*fast_pow(3,sum-n-k)%MOD)%=MOD;\n//\t\tnow=1ll*now*i%MOD; now=(now+C(n+k,i-n-k+1))%MOD;\n//\t}\t\n\tprintf(\"%d\\n\",(ans+MOD)%MOD);\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2) \n#include<bits/stdc++.h>\n#define rg register\n#define il inline\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7,O=1000010;\nil int gi(){\n\trg int o=0,fl=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')fl=-1,ch=getchar();\n\twhile(isdigit(ch))o=o*10+ch-'0',ch=getchar();\n\treturn fl*o;\n}\nint n,m,k;\nll fac[O],inv[O],bin[O],ans,x=1;\nil ll C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);n--;\n\tbin[0]=fac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<O;++i)bin[i]=bin[i-1]*3%mod;\n\tfor(int i=2;i<O;++i){\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tfor(int i=2;i<O;++i)inv[i]=inv[i-1]*inv[i]%mod;\nfor( int i = 0 ; i <= m + k ; i ++ ) {\n        ans = ( ans + C( n + i , n ) * bin[ m + k - i ] % mod * x )  % mod  ;\n        if( i < k ) x = ( x * 2ll ) % mod ;\n        else if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n        else  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n    }\n\tprintf(\"%lld\",ans<0?ans+mod:ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int p=1000000000+7;\nconst int maxn=100000*3+5;\nll n,m,k;\nll p1[maxn*4],p2[maxn*4];\nll f[maxn*4];//有x个空格，不大于m k个b c 填空种类数\nll pw3[maxn*4];\nll pw(ll x,ll y){\n\tll ans=1;\n\twhile ((bool)y){\n\t\tif ((bool)(y&1)){\n\t\t\tans=ans*x%p;\n\t\t}\n\t\tx=x*x%p;\n\t\ty=y>>1;\n\t}\n\treturn ans;\n}\nll c(ll x,ll y){\n\tif ((x<y)||(y<0))return 0;\n\treturn p1[x]*p2[y]%p*p2[x-y]%p;\n}\nvoid solve(){\n\tll b1,b2,b3,b4;\n\tll ans;\n\tscanf(\"%lld%lld%lld\",&n,&m,&k);\n\tf[0]=1;\n\tif (m>k) swap(m,k);\n\tfor (b1=1;b1<=m+k+n;b1++){\n\t\tf[b1]=(f[b1-1]*2-(c(b1-1,m)+c(b1-1,k))%p+p)%p;\n\t}\n\tans=0;\n\tfor (b1=n;b1<=n+m+k;b1++){\n\t\tans=(ans+f[b1-n]*c(b1-1,n-1)%p*pw3[n+m+k-b1]%p)%p;\n\t\t//printf(\"%lld\\n\",f[b1-n]*c(b1-1,n-1)*pw3[n+m+k-b1]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\t\n\t\n\t//printf(\"%lld\",f[m+k]-c(m+k,k));\n}\nint main(){\n\tll b1,b2,b3,b4;\n\tp1[0]=1;\n\tfor (b1=1;b1<maxn*3;b1++){\n\t\tp1[b1]=p1[b1-1]*b1%p;\n\t}\n\tp2[maxn*3-1]=pw(p1[maxn*3-1],p-2);\n\tfor (b1=maxn*3-1;b1>=1;b1--){\n\t\tp2[b1-1]=p2[b1]*b1%p;\n\t}\n\tpw3[0]=1;\n\tfor (b1=1;b1<maxn*3;b1++){\n\t\tpw3[b1]=pw3[b1-1]*3%p;\n\t}\n\tsolve();\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int mod=1e9+7;\nconst int MAXN=300005;\nconst double PI=acos(-1.0);\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nint pre[MAXN*4],inv[MAXN*4],n,m,K;\nint binom(int n,int m){return 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\n\n#define double long double\nconst int M=sqrt(mod);\nstruct Complex\n{\n\tdouble r,i;Complex(){}Complex(double _r,double _i){r=_r;i=_i;}\n\tfriend Complex operator +(Complex u,Complex v){return Complex(u.r+v.r,u.i+v.i);}\n\tfriend Complex operator -(Complex u,Complex v){return Complex(u.r-v.r,u.i-v.i);}\n\tfriend Complex operator *(Complex u,Complex v){return Complex(u.r*v.r-u.i*v.i,u.r*v.i+u.i*v.r);}\n};\nint R[MAXN*4],L;\nvoid FFT(Complex *y,int len,int on)\n{\n\tfor(int i=0;i<len;i++)if(i<R[i])swap(y[i],y[R[i]]);\n\tfor(int i=1;i<len;i<<=1)\n\t{\n\t\tComplex wn=Complex(cos(PI/i),sin(on*PI/i));\n\t\tfor(int j=0;j<len;j+=(i<<1))\n\t\t{\n\t\t\tComplex w=Complex(1,0);\n\t\t\tfor(int k=0;k<i;k++,w=w*wn)\n\t\t\t{\n\t\t\t\tComplex u=y[j+k],v=y[j+k+i]*w;\n\t\t\t\ty[j+k]=u+v;y[j+k+i]=u-v;\n\t\t\t}\n\t\t}\n\t}if(on==-1)for(int i=0;i<len;i++)y[i].r/=len;\n}\nvoid clear(Complex *a,int ln){for(int i=0;i<ln;i++)a[i]=Complex(0,0);}\nint AA[MAXN*4],BB[MAXN*4],val[MAXN*4];\nComplex A[MAXN*4],B[MAXN*4],C[MAXN*4],D[MAXN*4];\nComplex A1[MAXN*4],B1[MAXN*4],C1[MAXN*4];\nvoid mul(int *a,int *b,int *ret,int n,int m)\n{\n\tint ln=1;L=0;for(ln=1;ln<=n+m-1;ln<<=1)++L;\n\tfor(int i=0;i<ln;i++)R[i]=(R[i>>1]>>1)|(i&1)<<(L-1);\n\tclear(A,ln);clear(B,ln);clear(C,ln);clear(D,ln);clear(A1,ln);clear(B1,ln);clear(C1,ln);\n\tfor(int i=0;i<n;i++)A[i]=Complex(a[i]/M,0),B[i]=Complex(a[i]%M,0);\n\tfor(int i=0;i<m;i++)C[i]=Complex(b[i]/M,0),D[i]=Complex(b[i]%M,0);\n\tFFT(A,ln,1);FFT(B,ln,1);FFT(C,ln,1);FFT(D,ln,1);\n\tfor(int i=0;i<ln;i++)A1[i]=A[i]*C[i],B1[i]=B[i]*C[i]+A[i]*D[i],C1[i]=B[i]*D[i];\n\tFFT(A1,ln,-1);FFT(B1,ln,-1);FFT(C1,ln,-1);\n\tfor(int i=0;i<n+m-1;i++)A1[i].r=(LL)(A1[i].r+0.5),B1[i].r=(LL)(B1[i].r+0.5),C1[i].r=(LL)(C1[i].r+0.5);\n\tfor(int i=0;i<n+m-1;i++)\n\t{\n\t\tLL u=A1[i].r,v=B1[i].r,w=C1[i].r;u%=mod;v%=mod;w%=mod;\n\t\tret[i]=(1LL*u*M%mod*M%mod+1LL*v*M%mod+w)%mod;\n\t}\n}\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN*4;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN*4-1]=pow_mod(pre[MAXN*4-1],mod-2);\n\tfor(int i=MAXN*4-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tn=read();m=read();K=read();int ans=0;\n//\tfor(int x=0;x<=m;x++)for(int y=0;y<=K;y++)\n//\t\tad(ans,1LL*pow_mod(3,m-x)*pow_mod(3,K-y)%mod*C(n+x+y-1,x)%mod*C(n+y-1,y)%mod);\n\tfor(int i=0;i<=m;i++)AA[i]=inv[i];\n\tfor(int i=0;i<=K;i++)BB[i]=inv[i];\n\tmul(AA,BB,val,m+1,K+1);\n\tfor(int i=0;i<=m+K;i++)\n\t\tad(ans,1LL*pow_mod(3,m+K-i)*binom(n+i-1,i)%mod*val[i]%mod*pre[i]%mod);\n\tpr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300005\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nll up,n,m,k;\nll ans=0,fac[N*3],ifac[N*3],mul[N*3];\ninline ll calc(int a,int b){return fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\ninline ll ksm(ll x,int p){\n\tll ret=1;\n\twhile(p){\n\t\tif(p&1)ret=ret*x%mod;\n\t\tx=x*x%mod,p>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n>>m>>k,up=n+m+k,fac[0]=mul[0]=ifac[1]=ifac[0]=1;\n\tfor(ll i=2;i<=up;++i)ifac[i]=(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(ll i=1;i<=up;++i)mul[i]=mul[i-1]*3%mod,(ifac[i]*=ifac[i-1])%=mod,fac[i]=fac[i-1]*i%mod;\n\tif(m<k)m^=k,k^=m,m^=k;\n\tfor(ll i=0,j=1;i<=m+k;++i){\n\t\t(ans+=calc(n-1+i,n-1)*mul[m+k-i]%mod*j%mod)%=mod;\n\t\tif(i<k)(j<<=1)%=mod;\n\t\telse if(i>=m)(j+=j-calc(i,k)-calc(i,i-m))%=mod;\n\t\telse (j+=j-calc(i,k))%=mod;\n\t}\n\tcout<<(ans+mod)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = (int)1e9 + 7;\n\nconst int root = 646;\n\nconst int root_1 = 208611436;\n\nconst int root_pw = 1<<20;\n\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\n\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\n\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\n\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\n\nconst int maxN = 9 * (int)1e5 + 100;\n\nint fact[maxN], invfact[maxN], inv[maxN];\nint pw3[maxN];\n\nvoid init() {\n    inv[1] = invfact[1] = invfact[0] = fact[0] = fact[1] = 1;\n    for (int i = 2; i < maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n    pw3[0] = 1;\n    for (int i = 1; i < maxN; i++) {\n        pw3[i] = mult(pw3[i - 1], 3);\n    }\n}\n\nint cnk(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return mult(fact[n], mult(invfact[k], invfact[n - k]));\n}\n\nint invNumber(int a) {\n    return pw(a, mod - 2);\n}\n\nstruct query{\n    int L, R, coef;\n    query(int _L, int _R, int _coef) : L(_L), R(_R), coef(_coef) {}\n};\nconst int BLOCK = 500;\nbool cmp(query& a, query& b) {\n    return make_pair(a.L / BLOCK, a.R) < make_pair(b.L / BLOCK, b.R);\n}\nint L, R, res;\nvoid incL() {\n    L++;\n    res = sum(res, cnk(R, L));\n}\nvoid decL() {\n    res = sub(res, cnk(R, L));\n    L--;\n}\nvoid incR() {\n    res = sum(res, res);\n    res = sub(res, cnk(R, L));\n    R++;\n}\nconst int inv2 = (mod + 1) / 2;\nvoid decR() {\n    R--;\n    res = sum(res, cnk(R, L));\n    res = mult(res, inv2);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    init();\n    int n, m, k;\n    cin >> n >> m >> k;\n    int tot = n + m + k;\n    vector < query > all1, all2;\n    for (int where = n; where <= tot; where++) {\n        int cur = cnk(where - 1, n - 1);\n        cur = mult(cur, pw3[tot - where]);\n        int from = where - n - k;\n        int to = m;\n        to = min(to, where - n);\n        from = max(from, 0);\n        if (from > to) continue;\n        all2.emplace_back(to, where - n, cur);\n        if (from) all1.emplace_back(from - 1, where - n, sub(0, cur));\n    }\n    L = 0;\n    R = 0;\n    res = 1;\n    int ans = 0;\n    for (auto it : all2) {\n        while (R < it.R) incR();\n        while (L > it.L) decL();\n        while (R > it.R) decR();\n        while (L < it.L) incL();\n\n        ans = sum(ans, mult(it.coef, res));\n    }\n    for (auto it : all1) {\n        while (R < it.R) incR();\n        while (L > it.L) decL();\n        while (R > it.R) decR();\n        while (L < it.L) incL();\n        ans = sum(ans, mult(it.coef, res));\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, l, r) for(int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for(int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\nusing namespace std;\n\nbool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}\nbool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n    int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int Mod = 1e9 + 7, N = 1e6 + 1e3;\n\ntypedef long long ll;\n\nll fac[N], ifac[N], pow3[N];\n\nll fpm(ll x, int power) {\n\tll res = 1;\n\tfor (; power; power >>= 1, (x *= x) %= Mod)\n\t\tif (power & 1) (res *= x) %= Mod;\n\treturn res;\n}\n\nll C(int m, int n) {\n\tif (m > n || n < 0 || m < 0) return 0;\n\t//cout << fac[n] << ' ' << ifac[m] << ' ' << ifac[n - m] << endl;\n\treturn fac[n] * ifac[m] % Mod * ifac[n - m] % Mod;\n}\n\nint n, m, k, tot;\n\nvoid Init(int maxn) {\n\tfac[0] = pow3[0] = 1; \n\tFor (i, 1, maxn) fac[i] = fac[i - 1] * i % Mod, pow3[i] = pow3[i - 1] * 3 % Mod;\n\tifac[maxn] = fpm(fac[maxn], Mod - 2);\n\tFordown (i, maxn - 1, 0) ifac[i] = ifac[i + 1] * (i + 1) % Mod;\n}\n\ninline ll Calc(int m, int S) {\n\tll res = 0;\n\tFor (i, 0, min(m, S))\n\t\tif (S - i <= k) (res += C(i, S)) %= Mod;\n\treturn res;\n}\n\nll res[N];\n\nint main () {\n\tFile();\n\tcin >> n >> m >> k; tot = n + m + k;\n\tInit(tot + 5);\n\n\n\tll ans = 0, now = 1;\n\tFor (S, 0, m + k) {\n\t\t(ans += pow3[tot - (n + S)] * C(n - 1, (n - 1) + S) % Mod * now % Mod) %= Mod;\n\t\tnow = (now << 1) % Mod;\n\n\t\tif (S >= m) (now += Mod - C(m, S)) %= Mod;\n\t\tif (S >= k) (now += Mod - C(k, S)) %= Mod;\n\t}\n\n\tprintf (\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/numeric.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/adaptor/indexed.hpp>\n\nusing namespace std;\nusing namespace boost::adaptors;\nusing namespace std::string_literals;\nusing ll = int64_t;\nusing vecint = vector<int>;\nusing vecll = vector<ll>;\nusing boost::irange;\nconstexpr ll MOD = 1000000007;\n\n// a^-1 mod p\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nll pow3(ll x) {\n  if (x == 0) return 1;\n  if ((x%2)==1) return 3*pow3(x-1)%MOD;\n  ll h=pow3(x/2);\n  return h*h%MOD;\n}\n\nint main()\n{\n  ll n,m,k;\n  cin>>n>>m>>k;\n  vecll fact(3001);\n  vecll factinv(3001);\n  fact[0] = 1;\n  factinv[0] = 1;\n  for(int i:irange(0,3000)) {\n    fact[i+1] = fact[i] * (i+1) % MOD;\n    factinv[i+1] = inv(fact[i+1], MOD);\n  }\n  ll ans = 0;\n  ll l=n+m+k;\n  ll rsum = 1;\n  for(ll i:irange(n,l+1)) {\n    ll r = i-n;\n    ll comb = fact[i-1] * factinv[n-1] % MOD;\n    comb = comb * factinv[r] % MOD;\n    ll pw = pow3(l-i);\n    ll mul = comb * pw % MOD * rsum % MOD;\n    ans += mul;\n    ans %= MOD;\n    rsum *= 2;\n    rsum %= MOD;\n    if (r >= k) {\n      ll comb2 = fact[r] * factinv[r-k] % MOD;\n      comb2 = comb2 * factinv[k] % MOD;\n      rsum += MOD - comb2;\n      rsum %= MOD;\n    }\n    if (r >= m) {\n      ll comb2 = fact[r] * factinv[r-m] % MOD;\n      comb2 = comb2 * factinv[m] % MOD;\n      rsum += MOD - comb2;\n      rsum %= MOD;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n\nusing namespace std;\n\n// From Errichto's Youtube stream\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nusing int64 = long long;\n\n/////////////////////\n// Code starts here//\n/////////////////////\nconst int MOD = 1000000007;\n\nint N, M, K;\n\nvector<int> inv, invfact, pow3, pow2, fact;\n\nvoid add (int & a, int b) {\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n}\n\nint mul (int a, int b) {\n    return (int64)a * b % MOD;\n}\n\nint Choose (int n, int k) {\n    assert(k <= n);\n    if (!k) return 1;\n    if (n == k) return 1;\n    return mul(fact[n], mul(invfact[k], invfact[n-k])); \n}\n\ninline int power(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n \ninline int inverse(int x) {\n  return power(x, MOD - 2);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N >> M >> K;\n\n    N--;\n    if (M > K) {\n        swap(M, K);\n    }\n\n    int result = 0;\n\n    pow3.resize(N + M + K + 2);\n    pow2 = pow3;\n    fact = pow3;\n    invfact = pow3;\n\n    pow3[0] = 1;\n    pow2[0] = 1;\n    for (int i = 1; i < pow3.size(); i++) {\n        pow2[i] = mul(pow2[i - 1], 2);\n        pow3[i] = mul(pow3[i - 1], 3);\n    }\n\n    fact[0] = 1;\n    for (int i = 1; i < fact.size(); i++) {\n        fact[i] = mul(fact[i-1], i);\n    }\n\n    invfact[N + M + K + 1] = inverse(fact[N + M + K + 1]);\n    for (int i = N + M + K; i >= 0; i--) {\n        invfact[i] = mul(invfact[i + 1], i + 1);\n    }\n\n    for (int m = 0; m <= M; m++) {\n        for (int k = 0; k <= K; k++) {\n            auto cur = Choose(m + k, k);\n            cur = mul (cur, pow3[M + K - (m + k)]);\n            cur = mul (cur, Choose(N + m + k, N));\n            add(result, cur);\n        }\n    }\n\n    // divide by N!\n\n    cout << result << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int N = 4010, Mod = 1e9 + 7;\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod)\n\t\tif (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint fac[N], ifac[N];\nint C(int n, int m) {\n\tif (n < m) return 0;\n\treturn 1ll * fac[n] * ifac[m] % Mod * ifac[n - m] % Mod;\n}\nint merge(int x, int y) {//把y分成x + 1份\n\treturn C(y + x, x);\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m, k, ans = 0;\n\tread(n), read(m), read(k);\n\tfac[0] = 1; for (int i = 1; i <= 4000; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[4000] = fpow(fac[4000], Mod - 2); for (int i = 4000; i >= 1; i--) ifac[i - 1] = 1ll * ifac[i] * i % Mod;\n\tfor (int i = 0; i <= m; i++)\n\t\tfor (int j = 0; j <= k; j++)\n\t\t\t(ans += 1ll * merge(m - i, k - j) * merge(n - 1, m - i + k - j) % Mod * fpow(3, i) % Mod * fpow(3, j) % Mod) %= Mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(212345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,m,t;\n  cin>>n>>m>>t;\n  ll re=0,pw=modpow(3,m+t),sum=1;\n  rep(i,m+t+1){\n    (re+=pw*comb(n-1+i,i)%MOD*sum%MOD)%=MOD;\n    //cout<<pw<<\",\"<<comb(n-1+i,i)<<\",\"<<sum<<endl;\n    (pw*=inv[3])%=MOD;\n    (sum*=2)%=MOD;\n    if(t<=i) (sum+=MOD-comb(i,i-t))%=MOD;\n    if(m<=i) (sum+=MOD-comb(i,i-m))%=MOD;\n  }\n  //rep(i,m+1)rep(j,t+1) (re+=comb(n-1+i+j,i)*comb(n-1+j,j)%MOD*modpow(3,m+t-i-j)%MOD)%=MOD;\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n#define AddMult(x, y, z) x = (x + (y) * (z)) % mod\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        initialize();\n    }\n\n    void initialize(){\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = modpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int nCr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n\n    int nPr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N, M, K; cin >> N >> M >> K;\n    assert(N <= 1000 && M <= 1000 && K <= 1000);\n\n    int ans = 0;\n    Combination C(N + M + K, mod);\n    REP(m, M + 1) REP(k, K + 1){\n        int tmp = C.fact[N - 1 + m + k];\n        Mult(tmp, C.invfact[N - 1]);\n        Mult(tmp, C.invfact[m]);\n        Mult(tmp, C.invfact[k]);\n        Mult(tmp, modpow(3, M + K - (m + k), mod));\n        Add(ans, tmp);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = (int) 1e9 + 7;\nconst int N = 6e5 + 7;\nlong long fact[N], invfact[N];\n\nlong long power(long long a, long long n) {\n    long long res = 1;\n    while (n != 0) {\n        if (n % 2 != 0) res = res * a % MOD;\n        a = a * a % MOD;\n        n /= 2;\n    }\n    return res;\n}\n\nlong long inverse(int a) {\n    return power(a, MOD - 2);\n}\n\nlong long c(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) fact[i] = fact[i - 1] * i % MOD;\n    for (int i = 0; i < N; ++i) invfact[i] = inverse(fact[i]);\n    int n, m, k; cin >> n >> m >> k;\n    int lft = 0, rgt = -1;\n    long long sum = 0, res = 0;\n    for (int l = 0; l <= m + k; ++l) {\n        int newLft = l - min(l, k);\n        int newRgt = min(l, m);\n        while (rgt < newRgt) sum += c(l, ++rgt);\n        while (rgt > newRgt) sum -= c(l, rgt--);\n        while (lft < newLft) sum -= c(l, lft++);\n        while (lft > newLft) sum += c(l, --lft);\n        sum %= MOD;\n        res = (res + sum * power(3, m + k - l) % MOD * c(n + l - 1, n - 1)) % MOD;\n        sum = (sum * 2 - c(l, lft++) - c(l, rgt)) % MOD;\n    }\n    if (res < 0) res += MOD;\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint mod = 1000000007;\nlong long a[1000001];\nlong long inv[1000001];\nlong long fact[1000001];\nlong long invfact[1000001];\n\nvoid calc_inv(int n, int mod) {\n    inv[1] = 1;\n    for (int i = 2; i <= n; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n    \n    fact[0] = invfact[0] = 1;\n    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    for (int i = 1; i <= n; i++) invfact[i] = invfact[i - 1] * inv[i] % mod;\n}\n\nlong long comb(int x, int y, int mod) {\n    return fact[x] * invfact[y] % mod * invfact[x - y] % mod;\n}\n\nint main() {\n    int n, m, k, l = 0, r = 0, i;\n    long long ans = 0, sum = 1;\n    \n    scanf(\"%d %d %d\", &n, &m, &k);\n    \n    calc_inv(1000000, mod);\n    \n    a[0] = 1;\n    for (i = 1; i <= 1000000; i++) a[i] = a[i - 1] * 3 % mod;\n    \n    for (i = 0; i <= m + k; i++) {\n        ans += a[m + k - i] * comb(n + i - 1, n - 1, mod) % mod * sum % mod;\n        \n        sum = sum * 2 % mod;\n        if (l > 0) sum = (sum + comb(i, l - 1, mod)) % mod;\n        if (r < i) sum = (sum + comb(i, r + 1, mod)) % mod;\n        \n        r++;\n        \n        if (i + 1 - l > k) {\n            sum = (sum - comb(i + 1, l, mod) + mod) % mod;\n            l++;\n        }\n        \n        if (r > m) {\n            sum = (sum - comb(i + 1, r, mod) + mod) % mod;\n            r--;\n        }\n    }\n    \n    printf(\"%lld\\n\", ans % mod);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\nconst int mod = 1000000007;\n\nll mpow(ll x, ll n) {\n  ll res = 1;\n  while (n) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n /= 2;\n  }\n  return res;\n}\n\nvl fac(1000000, 1);\nvl invfac(fac.size(), 1);\n\nll bin (int k, int n) {\n  if (k < 0 || k > n) return 0;\n  return fac[n] * invfac[k] % mod * invfac[n-k] % mod;\n}\n\nint main() {\n  for (int i = 2; i < fac.size(); ++i) fac[i] = fac[i-1] * i % mod;\n  invfac.back() = mpow(fac.back(), mod - 2);\n  for (int i = fac.size() - 2; i > 0; --i) invfac[i] = invfac[i + 1] * (i+1) % mod;\n  int n,m,k;\n  while (cin >> n >> m >> k) {\n    ll sum = 1, res = 0;\n    for (int s = 0; s <= m + k; ++s) {\n      ll mul = mpow(3, m + k - s) * bin(s, s + n - 1) % mod;\n//      sum = 0;\n//      for (int i = max(0, s - k); i <= min(s, m); ++i) {\n//        sum = (sum + bin(i, s)) % mod;\n//      }\n      res = (res + mul * sum) % mod;\n      sum = sum * 2 - bin(min(s, m), s) + bin(max(0, s - k) - 1, s);\n      if (s < m) sum += 1;\n      if (s >= k) sum -= bin(s - k, s + 1);\n      sum %= mod;\n    }\n    cout << (res % mod + mod) % mod << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst LD kPi = 2 * acos(0);\nstruct CD {\n  LD re, im;\n  CD operator=(LD a) { re = a; im = 0; return *this; }\n  CD operator*(CD& z) { return {re * z.re - im * z.im, re * z.im + im * z.re}; }\n  void operator*=(CD& z) { *this = (*this * z); }\n  CD operator+(CD& z) { return {re + z.re, im + z.im}; }\n  CD operator-(CD& z) { return {re - z.re, im - z.im}; }\n  void operator/=(LD f) { re /= f; im /= f; }\n};\n\nstruct FFT {\nprivate:\n  CD *A, *B, *tmp, *res, *omega;\n  int *rev_perm;\n  int max_dep;\n  // not needed if this is going to be used just once\n  void Clear(int n) {\n    REP (i, n) { A[i] = B[i] = res[i] = tmp[i] = 0; }\n  }\n\n  void fft(CD* from, CD* to, int depth, bool inv){\n    int N = (1 << depth);\n    REP (i, N) { to[rev_perm[i] >> (max_dep - depth)] = from[i]; }\n\n    RE (m, depth) {\n      int step = (1 << m);\n      for (int pos = 0; pos < N; pos += step){\n        int cur = 0;\n        int delta = (1 << (max_dep - m));\n        if (!inv) { cur = (1 << max_dep); delta *= -1; }\n        REP (k, step / 2) {\n          CD a = to[pos + k],\n             b = omega[cur] * to[pos + k + step / 2];\n          to[pos + k] = a + b;\n          to[pos + k + step / 2] = a - b;\n          cur += delta;\n        }\n      }\n    }\n    if (inv) { REP (i, N) { to[i] /= N; } }\n  }\n  \npublic:\n  FFT(int max_deg) { // max degree of a polynomial given as input\n    max_dep = 0;\n    while ((1 << max_dep) <= 2 * max_deg) { max_dep++; }\n    max_deg = (1 << max_dep) + 20;\n    A = new CD[max_deg]; B = new CD[max_deg];\n    res = new CD[max_deg]; tmp = new CD[max_deg];\n    omega = new CD[max_deg]; rev_perm = new int[max_deg];\n    int N = (1 << max_dep);\n    LD ang = 2 * kPi / N;\n    REP (i, N + 1) { omega[i] = {cos(i * ang), sin(i * ang)}; }\n    rev_perm[0] = 0;\n    int h = -1;\n    RE (i, N) {\n      if ((i & (i - 1)) == 0) { h++; }\n      rev_perm[i] = rev_perm[i ^ (1 << h)] | (1 << (max_dep - h - 1));\n    }\n  }\n  VI mul_less_exact(VI Q, VI R, int P) {\n    int depth = 0, size = 1;\n    int N = SZ(Q) + SZ(R) - 1;\n    while (size < N) { depth++; size *= 2; }\n    Clear(size);\n    // start miejsca, w ktorym jak mozna mniejsza dokladnosc, to zmien na komentarze\n    // P,Q \\in R[x], A = Q * (1+i)/2 + R * (1-i)/2 -> Re(A^2) = P*Q\n    REP (i, SZ(Q)) {\n      //A[i] = CD{.5 * Q[i], .5 * Q[i]};\n      A[i] = Q[i];\n    }\n    REP (i, SZ(R)) {\n      //A[i] = A[i] + CD{.5 * R[i], -.5 * R[i]};\n      B[i] = R[i];\n    }\n    //fft(A, tmp, depth, false);\n    //REP (i, size) tmp[i] *= tmp[i];\n    fft(A, res, depth, false);\n    fft(B, tmp, depth, false);\n    REP (i, size) tmp[i] *= res[i];\n    // koniec\n    fft(tmp, res, depth, true);\n    VI ans;\n    REP (i, N) { ans.PB((long long)round(res[i].re) % P); }\n    return ans;\n  }\n  \n  VI Prepare(VI& v, int base, int b_pow) {\n    VI ans;\n    for (int x : v) { ans.PB(b_pow ? x / base : x % base); }\n    return ans;\n  }\n  int Sum(VI& v, int P) { // debug/assert purposes only\n    return accumulate(ALL(v), 0LL) % P;\n  }\n  VI mul_exact(VI Q, VI R, int P) {\n    int base = 32000;\n    int pows[] = {1, base, (int)1LL * base * base % P};\n    VI ans(SZ(Q) + SZ(R) - 1);\n    REP (q, 2) {\n      VI W = Prepare(Q, base, q);\n      REP (r, 2) {\n        VI V = Prepare(R, base, r);\n        // jezeli bedzie za wolno, to można policzyc tylko 4 transformaty w przod\n        // bo teraz dla kazdej z 4 czesci jest liczona podwojnie (przyspieszenie * 2/3)\n        VI C = mul_less_exact(W, V, P);\n        REP (i, SZ(C)) { ans[i] = (ans[i] + 1LL * C[i] * pows[q + r]) % P; }\n      }\n    }\n    debug(Sum(ans, P), 1LL * Sum(Q, P) * Sum(R, P) % P);    // DEBUG!!\n    assert(Sum(ans, P) == 1LL * Sum(Q, P) * Sum(R, P) % P); // DEBUG!!\n    return ans;\n  }\n};\n\nint P = 1e9 + 7;\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w&1)\n      r = r * a % P;\n    w /= 2;\n    a =  a * a % P;\n  }\n  return r;\n}\nint odw(int a){\n  return pot(a,P-2);\n}\nconst int MAX = 4e5;\nint sil[MAX];\nint a,b,c;\nFFT fft(MAX);\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  sil[0] = 1;\n  for(int i = 1; i < MAX; i++)\n    sil[i] = sil[i-1] * i % P;\n  cin >> a >> b >> c;\n  vector<int> x,y;\n  R(i,b+1){\n    x.PB(odw(sil[b-i]));\n  }\n  R(i,c+1){\n    y.PB(odw(sil[c-i]));\n  }\n  debug(x,y);\n  vector<int> spl = fft.mul_exact(x,y,P);\n  debug(spl);\n  int res = 0;\n  int mn = odw(sil[a-1]);\n  R(i,SZ(spl)){\n    debug(sil[a-1+b+c-i], mn,spl[i]);\n    res += sil[a-1+b+c-i] * mn % P * spl[i] % P;\n    debug(res);\n    mn*=3;\n    mn%=P;\n  }\n  cout << res%P << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint n, m, k;\nint pow1[1010101], pow2[1010101];\nint fac[1010101], rev[1010101], ifac[1010101];\n\nint c(int a, int b)\n{\n\tlong long ret = fac[b];\n\tret = ret * ifac[a];\n\tret %= MOD;\n\tret = ret * ifac[b - a];\n\tret %= MOD;\n\treturn (int)ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tpow1[0] = fac[0] = ifac[0] = rev[0] = pow2[0] = 1;\n\tifac[1] = rev[1] = 1;\n\tfor(int i = 1; i <= n + m + k; ++i)\n\t{\n\t\tpow1[i] = pow1[i - 1] * 3ll % MOD;\n\t\tpow2[i] = pow2[i - 1] * 2 % MOD;\n\t\tfac[i] = fac[i - 1] * 1ll * i % MOD;\n\t\tif(i >= 2)\n\t\t{\n\t\t\trev[i] = MOD - 1ll * (MOD / i) * rev[MOD % i] % MOD;\n\t\t\tifac[i] = 1ll * ifac[i - 1] * rev[i] % MOD;\n\t\t}\n\t}\n\tif(m > k)\n\t\tswap(m, k);\n\tint ans = 0;\n\tfor(int i = 0; i <= m; ++i)\n\t{\n\t\tans += 1ll * pow2[i] * c(i, i + n - 1) % MOD * pow1[m + k - i] % MOD;\n\t\tif(ans >= MOD)\n\t\t\tans -= MOD;\n\t}\n\tint lst = pow2[m];\n\tfor(int i = m + 1; i <= m + k; ++i)\n\t{\n\t\tlst = lst<<1;\n\t\tlst -= c(m, i - 1);\n\t\tif(lst >= MOD)\n\t\t\tlst -= MOD;\n\t\tif(i > k)\n\t\t\tlst -= c(i - k - 1, i - 1);\n\t\twhile(lst < 0)\n\t\t\tlst += MOD;\n\t\twhile(lst >= MOD)\n\t\t\tlst -= MOD;\n\t\tans += 1ll * lst * c(i, i + n - 1) % MOD * pow1[m + k - i] % MOD;\n\t\tif(ans >= MOD)\n\t\t\tans -= MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e6+5;\nconst ll p = 1e9+7;\nconst ll inv3 = (p+1)/3;\n\nll fact[MAXN], invfact[MAXN], inv[MAXN], n, m, k, c[MAXN];\nll p3[MAXN], pinv3[MAXN];\n\nll comb(int x, int y) {\n\tif (x < 0 || y < 0 || x < y)\n\t\treturn 0;\n\treturn fact[x]*invfact[y]%p*invfact[x-y]%p;\n}\n\nll exp(ll x, ll k) {\n\tif (k == 0)\n\t\treturn 1;\n\tll y = exp(x, k/2);\n\treturn (k%2 == 0) ? y*y%p : y*y%p*x%p;\n}\n\nll inve(ll x) { return exp(x, p-2); }\n\nvoid init() {\n\tinv[1] = fact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i < MAXN; ++i) {\n\t\tinv[i] = (p - (p/i) * inv[p%i] % p) % p;\n\t\tfact[i] = i*fact[i-1]%p;\n\t\tinvfact[i] = inv[i]*invfact[i-1]%p;\n\t}\n\n\tp3[0] = pinv3[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tp3[i] = 3*p3[i-1]%p, pinv3[i] = inv3*pinv3[i-1]%p;\n}\n\nint main() {\n\tcin >> n >> m >> k;\n\tinit();\n\tfor (int i = 0; i <= k; ++i)\n\t\tc[0] = (c[0] + pinv3[i])%p;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tc[i] = 3*(p+1)/2%p*(c[i-1]+p-comb(i+k, k)*pinv3[k+1]%p)%p;\n\tll ans = 0;\n\tfor (int i = 0; i <= m; ++i)\n\t\tans = (ans + comb(n-1+i, i)*pinv3[i]%p*c[n-1+i]%p)%p;\n\tcout << ans*p3[m+k]%p << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=6e5+5;\ntypedef long long LL;\nconst LL mo=1e9+7;\nLL fac[maxn],inv[maxn];\nLL C(int n,int m){\n\treturn fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nLL pw(LL x,LL k,LL p=::mo){\n\tLL ans=1;\n\tfor(;k;k>>=1){\n\t\tif(k&1)ans=ans*x%mo;\n\t\tx=x*x%mo;\n\t}\n\treturn ans;\n}\nint main(){\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<maxn;i++){\n\t\tfac[i]=fac[i-1]*i%mo;\n\t}\n\tfor(int i=2;i<maxn;i++){\n\t\tinv[i]=(mo-mo/i)*inv[mo%i]%mo;\n\t}\n\tfor(int i=2;i<maxn;i++){\n\t\tinv[i]=inv[i-1]*inv[i]%mo;\n\t}\n\n\tLL ans=0;\n\n\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tif(m>k)swap(m,k);\n\n\n//\tlong long ans=0;\n/*\tfor(int i=0;i<=m;i++)\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tans+=C(n+i+j-1,n-1)*C(i+j,i)*pw(3,m+k-i-j);\n\t\t}\n\tcout<<ans<<endl;\n\n\tfor(int i=0;i<=m+k;i++)\n\t\tfor(int j=0;j<=k&&j<=m;j++){\n\t\t\tans+=C(n+i-1,n-1)*C(i,j)*pw(3,m+k-i);\n\t\t}\n\tcout<<ansi<<endl;\n\treturn 0;*/\n\tLL cur=1;\n\tfor(int p=0;p<=m+k;p++){\n\t\tLL res=0;\n\t\t\n\t\tres=C(n+p-1,n-1)*pw(3,m+k-p)%mo;\n\t\t//TODO\n\t\t/*\n\t\tcur=0;\n\t\tint l=max(p-k,0),r=min(m,p);\n\t\tfor(int i=max(p-k,0);i<=m&&i<=p;i++){\n\t\t\tcur+=C(p,i);\n\t\t\tcur%=mo;\n\t\t}\n\t\tcout<<l<<\" \"<<r<<\" \"<<cur<<endl;*/\n//\t\tcerr<<p<<\" \"<<cur<<endl;\n\t\n\n\t\tans+=res*cur%mo;\n\t\tans%=mo;\n\n\t\tcur=cur*2%mo;\n\t\tif(p>=m){\n\t\t\tcur-=C(p,m);\n\t\t\tcur+=mo;cur%=mo;\n\t\t}\n\t\tif(p>=k){\n\t\t\tcur-=C(p,p-k);\n\t\t\tcur+=mo;cur%=mo;\n\t\t}\n\n\n\t}\n\n\tcout<<ans<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<1000000007> Int;\n\n//const int INF=5e8;\nint n,m,k;\n\nInt fact[900005],inv[900005];\nInt pw2[900005],pw3[900005];\nInt C(int a,int b){\n  if(a<0 || b<0 || b>a) return 0;\n  return fact[a]*inv[b]*inv[a-b];\n}\nint main(){\n  fact[0]=1;\n  pw2[0]=pw3[0]=1;\n  REP(i,900004) fact[i+1]=fact[i]*(i+1),pw2[i+1]=pw2[i]*2,pw3[i+1]=pw3[i]*3;;\n  Int one=1;\n  inv[900000]=one/fact[900000];\n  for(int i=899999;i>=0;--i) inv[i]=inv[i+1]*(i+1);\n\n  cin>>n>>m>>k;\n\n  Int res=0;\n  Int sum1=0,sum2=0;\n  for(int i=n;i<=n+m+k;++i){\n    Int tmp=C(i,n)-C(i-1,n);\n    sum1=sum1*2+C(i-n-1,i-n-m-1);\n    sum2=sum2*2+C(i-n-1,i-n-k-1);\n    tmp*=pw2[i-n]-sum1-sum2;\n    tmp*=pw3[n+m+k-i];\n    res+=tmp;\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst LD kPi = 2 * acos(0);\nstruct CD {\n  LD re, im;\n  CD operator=(LD a) { re = a; im = 0; return *this; }\n  CD operator*(CD& z) { return {re * z.re - im * z.im, re * z.im + im * z.re}; }\n  void operator*=(CD& z) { *this = (*this * z); }\n  CD operator+(CD& z) { return {re + z.re, im + z.im}; }\n  CD operator-(CD& z) { return {re - z.re, im - z.im}; }\n  void operator/=(LD f) { re /= f; im /= f; }\n};\n\nstruct FFT {\nprivate:\n  CD *A, *B, *tmp, *res, *omega;\n  int *rev_perm;\n  int max_dep;\n  // not needed if this is going to be used just once\n  void Clear(int n) {\n    REP (i, n) { A[i] = B[i] = res[i] = tmp[i] = 0; }\n  }\n\n  void fft(CD* from, CD* to, int depth, bool inv){\n    int N = (1 << depth);\n    REP (i, N) { to[rev_perm[i] >> (max_dep - depth)] = from[i]; }\n\n    RE (m, depth) {\n      int step = (1 << m);\n      for (int pos = 0; pos < N; pos += step){\n        int cur = 0;\n        int delta = (1 << (max_dep - m));\n        if (!inv) { cur = (1 << max_dep); delta *= -1; }\n        REP (k, step / 2) {\n          CD a = to[pos + k],\n             b = omega[cur] * to[pos + k + step / 2];\n          to[pos + k] = a + b;\n          to[pos + k + step / 2] = a - b;\n          cur += delta;\n        }\n      }\n    }\n    if (inv) { REP (i, N) { to[i] /= N; } }\n  }\n  \npublic:\n  FFT(int max_deg) { // max degree of a polynomial given as input\n    max_dep = 0;\n    while ((1 << max_dep) <= 2 * max_deg) { max_dep++; }\n    max_deg = (1 << max_dep) + 20;\n    A = new CD[max_deg]; B = new CD[max_deg];\n    res = new CD[max_deg]; tmp = new CD[max_deg];\n    omega = new CD[max_deg]; rev_perm = new int[max_deg];\n    int N = (1 << max_dep);\n    LD ang = 2 * kPi / N;\n    REP (i, N + 1) { omega[i] = {cos(i * ang), sin(i * ang)}; }\n    rev_perm[0] = 0;\n    int h = -1;\n    RE (i, N) {\n      if ((i & (i - 1)) == 0) { h++; }\n      rev_perm[i] = rev_perm[i ^ (1 << h)] | (1 << (max_dep - h - 1));\n    }\n  }\n  VI mul_less_exact(VI Q, VI R, int P) {\n    int depth = 0, size = 1;\n    int N = SZ(Q) + SZ(R) - 1;\n    while (size < N) { depth++; size *= 2; }\n    Clear(size);\n    // start miejsca, w ktorym jak mozna mniejsza dokladnosc, to zmien na komentarze\n    // P,Q \\in R[x], A = Q * (1+i)/2 + R * (1-i)/2 -> Re(A^2) = P*Q\n    REP (i, SZ(Q)) {\n      //A[i] = CD{.5 * Q[i], .5 * Q[i]};\n      A[i] = Q[i];\n    }\n    REP (i, SZ(R)) {\n      //A[i] = A[i] + CD{.5 * R[i], -.5 * R[i]};\n      B[i] = R[i];\n    }\n    //fft(A, tmp, depth, false);\n    //REP (i, size) tmp[i] *= tmp[i];\n    fft(A, res, depth, false);\n    fft(B, tmp, depth, false);\n    REP (i, size) tmp[i] *= res[i];\n    // koniec\n    fft(tmp, res, depth, true);\n    VI ans;\n    REP (i, N) { ans.PB((long long)round(res[i].re) % P); }\n    return ans;\n  }\n  \n  VI Prepare(VI& v, int base, int b_pow) {\n    VI ans;\n    for (int x : v) { ans.PB(b_pow ? x / base : x % base); }\n    return ans;\n  }\n  int Sum(VI& v, int P) { // debug/assert purposes only\n    return accumulate(ALL(v), 0LL) % P;\n  }\n  VI mul_exact(VI Q, VI R, int P) {\n    int base = 32000;\n    int pows[] = {1, base, (int)1LL * base * base % P};\n    VI ans(SZ(Q) + SZ(R) - 1);\n    REP (q, 2) {\n      VI W = Prepare(Q, base, q);\n      REP (r, 2) {\n        VI V = Prepare(R, base, r);\n        // jezeli bedzie za wolno, to można policzyc tylko 4 transformaty w przod\n        // bo teraz dla kazdej z 4 czesci jest liczona podwojnie (przyspieszenie * 2/3)\n        VI C = mul_less_exact(W, V, P);\n        REP (i, SZ(C)) { ans[i] = (ans[i] + 1LL * C[i] * pows[q + r]) % P; }\n      }\n    }\n    debug(Sum(ans, P), 1LL * Sum(Q, P) * Sum(R, P) % P);    // DEBUG!!\n    assert(Sum(ans, P) == 1LL * Sum(Q, P) * Sum(R, P) % P); // DEBUG!!\n    return ans;\n  }\n};\n\nint P = 1e9 + 7;\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w&1)\n      r = r * a % P;\n    w /= 2;\n    a =  a * a % P;\n  }\n  return r;\n}\nint odw(int a){\n  return pot(a,P-2);\n}\nconst int MAX = 4e5;\nint sil[MAX];\nint a,b,c;\nFFT fft((int)(1e5)+2);\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  sil[0] = 1;\n  for(int i = 1; i < MAX; i++)\n    sil[i] = sil[i-1] * i % P;\n  cin >> a >> b >> c;\n  vector<int> x,y;\n  R(i,b+1){\n    x.PB(odw(sil[b-i]));\n  }\n  R(i,c+1){\n    y.PB(odw(sil[c-i]));\n  }\n  debug(x,y);\n  vector<int> spl = fft.mul_exact(x,y,P);\n  debug(spl);\n  int res = 0;\n  int mn = odw(sil[a-1]);\n  R(i,SZ(spl)){\n    debug(sil[a-1+b+c-i], mn,spl[i]);\n    res += sil[a-1+b+c-i] * mn % P * spl[i] % P;\n    debug(res);\n    mn*=3;\n    mn%=P;\n  }\n  cout << res%P << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\nconst int N=1e6+10,P=1e9+7;\nint a,b,c,f[N],fac[N],ifac[N],inv[N],ff;\nlong long ans;\nint C(int n,int k){\n    if(n<k||k<0) return 0;\n    return 1ll*fac[n]*ifac[k]%P*ifac[n-k]%P;\n}\nvoid pre(int n){\n    fac[0]=1;rep(i,1,n) fac[i]=1ll*fac[i-1]*i%P;\n    inv[1]=1;rep(i,2,n) inv[i]=1ll*(P-P/i)*inv[P%i]%P;\n    ifac[0]=1;rep(i,1,n) ifac[i]=1ll*ifac[i-1]*inv[i]%P;\n}\nint main(){\n    scanf(\"%d%d%d\",&a,&b,&c);pre(a+b+c);f[0]=1;\n    rep(i,1,b+c) f[i]=3ll*f[i-1]%P;\n    if(b>c) swap(b,c);ff=1;\n    rep(i,0,b+c){\n        ans+=1ll*f[b+c-i]*C(a-1+i,i)%P*ff%P;\n        ff=ff*2%P;\n        if(i>=b) ff=(ff-C(i,b)+P)%P;\n        if(i>=c) ff=(ff-C(i,c)+P)%P;\n    }\n    printf(\"%lld\\n\",ans%P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll N,M,K;\nll fac[1000010],finv[1000010];\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\nll comb(ll n,ll r){\n  if(n<0||r<0||n<r)return 0;\n  return (fac[n]*finv[r]%mod)*finv[n-r]%mod;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  fac[0]=1;\n  rep(i,1000001)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,1000001)finv[i]=mod_pow(fac[i],mod-2);\n\n  cin>>N>>M>>K;\n  \n  ll res=0;\n  ll k3=1;\n  repl(i,N,N+M+K+1){\n    ll R=i-N;\n    ll k1=comb(i-1,N-1);\n    ll k2=mod_pow(3,N+M+K-i);\n    (res+=(k1*k2%mod)*k3%mod)%=mod;\n    k3=(k3+k3)%mod;\n    if(R>=K){\n      k3=(k3-comb(R,R-K)+mod)%mod;\n    }\n    if(R>=M){\n      k3=(k3-comb(R,M)+mod)%mod;\n    }\n  }\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <deque>\n#include <queue>\n#include <string>\n#include <tuple>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\n#define pb push_back\n#define pbk pop_back\n#define sz(a) ((int) (a).size())\n#define all(a) (a).begin(), (a).end()\n#define mp make_pair\n#define mt make_tuple\n#define fs first\n#define sc second\n#define next hunext\n#define prev huprev\n#define rank hurank\n#define hash huhash\n\n#ifdef LOCAL42\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = int(1e9);\nconst ll linf = ll(1e18);\nconst double eps = 1e-9;\nconst double pi = 4 * atan(1.0);\nconst int MOD = int(1e9) + 7;\nconst int P = 100;\nconst int N = int(1e6);\nconst int SZ = (1 << 20);\nconst int K = 5;\n\nstruct base {\n    \n    double a, b;\n    \n    base() : a(0), b(0) {}\n    \n    base(double a, double b = 0) : a(a), b(b) {}\n    \n};\n\ninline base operator + (const base& a, const base& b) {\n    return base(a.a + b.a, a.b + b.b);\n}\n\ninline base operator - (const base& a, const base& b) {\n    return base(a.a - b.a, a.b - b.b);\n}\n\ninline base operator * (const base& a, const base& b) {\n    return base(a.a * b.a - a.b * b.b, a.a * b.b + a.b * b.a);\n}\n\ninline base operator / (const base& a, double b) {\n    return base(a.a / b, a.b / b);\n}\n\nint maxv;\nbase a[K][SZ], ab[K * 2][SZ];\nint f[N], rf[N];\n\ninline int calc(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2 != 0) {\n            res = (1LL * res * a) % MOD;\n        }\n        a = (1LL * a * a) % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\ninline void fft(base* a, int n, bool fl) {\n    for (int i = 1, j = 0; i < n; ++i) {\n        int bit = n / 2;\n        for (; j >= bit; bit /= 2) {\n            j -= bit;\n        }\n        j += bit;\n        if (i < j) {\n            swap(a[i], a[j]);\n        }\n    }\n    for (int len = 2; len <= n; len *= 2) {\n        double ang = 2 * pi / len * (fl ? -1 : 1);\n        base wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            base w(1);\n            for (int j = 0; j < len / 2; ++j) {\n                base u = a[i + j], v = a[i + j + len / 2] * w;\n                a[i + j] = u + v;\n                a[i + j + len / 2] = u - v;\n                w = w * wlen;\n            }\n        }\n    }\n    if (fl) {\n        for (int i = 0; i < n; ++i) {\n            a[i] = a[i] / n;\n        }\n    }\n}\n\nint main() {\n    //cerr << (sizeof(a) + sizeof(ab) + sizeof(f) + sizeof(rf)) / 1024 / 1024 << endl;\n#ifdef LOCAL42\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int n, m, k;\n    cin >> n >> m >> k;\n    f[0] = 1;\n    for (int i = 1; i <= n + m + k; ++i) {\n        f[i] = (1LL * f[i - 1] * i) % MOD;\n    }\n    rf[n + m + k] = calc(f[n + m + k], MOD - 2);\n    for (int i = n + m + k - 1; i >= 0; --i) {\n        rf[i] = (1LL * rf[i + 1] * (i + 1)) % MOD;\n    }\n    for (int i = 0; i <= m; ++i) {\n        int cur = rf[i];\n        for (int j = 0; j < K; ++j) {\n            a[j][i].a = cur % P;\n            cur /= P;\n        }\n        assert(cur == 0);\n    }\n    for (int i = 0; i <= k; ++i) {\n        int cur = rf[i];\n        for (int j = 0; j < K; ++j) {\n            a[j][i].b = cur % P;\n            cur /= P;\n        }\n        assert(cur == 0);\n    }\n    maxv = 1;\n    while (maxv < max(m, k) + 1) {\n        maxv *= 2;\n    }\n    maxv *= 2;\n    assert(maxv <= SZ);\n    for (int i = 0; i < K; ++i) {\n        fft(a[i], maxv, false);\n    }\n    for (int i = 0; i < K; ++i) {\n        for (int j = 0; j < K; ++j) {\n            for (int z = 0; z < maxv; ++z) {\n                ab[i + j][z] = ab[i + j][z] + a[i][z] * a[j][z];\n            }\n        }\n    }\n    for (int i = 0; i < 2 * K; ++i) {\n        fft(ab[i], maxv, true);\n    }\n    int ans = 0, pw3 = 1, inv3 = calc(3, MOD - 2);\n    for (int i = 0; i <= m + k; ++i) {\n        int sum = 0;\n        for (int j = 2 * K - 1; j >= 0; --j) {\n            sum = (1LL * sum * P + ll(ab[j][i].b + 0.5) / 2) % MOD;\n        }\n        sum = (1LL * sum * pw3) % MOD;\n        sum = (1LL * sum * f[n - 1 + i]) % MOD;\n        ans += sum;\n        if (ans >= MOD) {\n            ans -= MOD;\n        }\n        pw3 = (1LL * inv3 * pw3) % MOD;\n    }\n    ans = (1LL * ans * calc(3, m + k)) % MOD;\n    ans = (1LL * ans * rf[n - 1]) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int mod=1e9+7;\nconst int MAXN=300005;\nconst double PI=acos(-1.0);\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nint pre[MAXN*4],inv[MAXN*4],n,m,K;\nint C(int n,int m){return 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\n\n#define double long double\nconst int M=sqrt(mod);\nstruct Complex\n{\n\tdouble r,i;Complex(){}Complex(double _r,double _i){r=_r;i=_i;}\n\tfriend Complex operator +(Complex u,Complex v){return Complex(u.r+v.r,u.i+v.i);}\n\tfriend Complex operator -(Complex u,Complex v){return Complex(u.r-v.r,u.i-v.i);}\n\tfriend Complex operator *(Complex u,Complex v){return Complex(u.r*v.r-u.i*v.i,u.r*v.i+u.i*v.r);}\n};\nint R[MAXN*4],L;\nvoid FFT(Complex *y,int len,int on)\n{\n\tfor(int i=0;i<len;i++)if(i<R[i])swap(y[i],y[R[i]]);\n\tfor(int i=1;i<len;i<<=1)\n\t{\n\t\tComplex wn=Complex(cos(PI/i),sin(on*PI/i));\n\t\tfor(int j=0;j<len;j+=(i<<1))\n\t\t{\n\t\t\tComplex w=Complex(1,0);\n\t\t\tfor(int k=0;k<i;k++,w=w*wn)\n\t\t\t{\n\t\t\t\tComplex u=y[j+k],v=y[j+k+i]*w;\n\t\t\t\ty[j+k]=u+v;y[j+k+i]=u-v;\n\t\t\t}\n\t\t}\n\t}if(on==-1)for(int i=0;i<len;i++)y[i].r/=len;\n}\nvoid clear(Complex *a,int ln){for(int i=0;i<ln;i++)a[i]=Complex(0,0);}\nint A[MAXN*4],B[MAXN*4],val[MAXN*4];\nvoid mul(int *a,int *b,int *ret,int n,int m)\n{\n\tstatic Complex A[MAXN*4],B[MAXN*4],C[MAXN*4],D[MAXN*4];\n\tstatic Complex A1[MAXN*4],B1[MAXN*4],C1[MAXN*4];\n\tint ln=1;L=0;for(ln=1;ln<=n+m-1;ln<<=1)++L;\n\tfor(int i=0;i<ln;i++)R[i]=(R[i>>1]>>1)|(i&1)<<(L-1);\n\tclear(A,ln);clear(B,ln);clear(C,ln);clear(D,ln);clear(A1,ln);clear(B1,ln);clear(C1,ln);\n\tfor(int i=0;i<n;i++)A[i]=Complex(a[i]/M,0),B[i]=Complex(a[i]%M,0);\n\tfor(int i=0;i<m;i++)C[i]=Complex(b[i]/M,0),D[i]=Complex(b[i]%M,0);\n\tFFT(A,ln,1);FFT(B,ln,1);FFT(C,ln,1);FFT(D,ln,1);\n\tfor(int i=0;i<ln;i++)A1[i]=A[i]*C[i],B1[i]=B[i]*C[i]+A[i]*D[i],C1[i]=B[i]*D[i];\n\tFFT(A1,ln,-1);FFT(B1,ln,-1);FFT(C1,ln,-1);\n\tfor(int i=0;i<n+m-1;i++)A1[i].r=(LL)(A1[i].r+0.5),B1[i].r=(LL)(B1[i].r+0.5),C1[i].r=(LL)(C1[i].r+0.5);\n\tfor(int i=0;i<n+m-1;i++)\n\t{\n\t\tLL u=A1[i].r,v=B1[i].r,w=C1[i].r;u%=mod;v%=mod;w%=mod;\n\t\tret[i]=(1LL*u*M%mod*M%mod+1LL*v*M%mod+w)%mod;\n\t}\n}\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN*4;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN*4-1]=pow_mod(pre[MAXN*4-1],mod-2);\n\tfor(int i=MAXN*4-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tn=read();m=read();K=read();int ans=0;\n//\tfor(int x=0;x<=m;x++)for(int y=0;y<=K;y++)\n//\t\tad(ans,1LL*pow_mod(3,m-x)*pow_mod(3,K-y)%mod*C(n+x+y-1,x)%mod*C(n+y-1,y)%mod);\n\tfor(int i=0;i<=m;i++)A[i]=inv[i];\n\tfor(int i=0;i<=K;i++)B[i]=inv[i];\n\tmul(A,B,val,m+1,K+1);\n\tfor(int i=0;i<=m+K;i++)\n\t\tad(ans,1LL*pow_mod(3,m+K-i)*C(n+i-1,i)%mod*val[i]%mod*pre[i]%mod);\n\tpr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm> \nusing namespace std; \nconst int Mod = 1e9 + 7; \nconst int MAX_N = 1e6 + 5; \nint fpow(int x, int y) { \n\tint res = 1; \n\twhile (y) { \n\t\tif (y & 1) res = 1ll * res * x % Mod; \n\t\tx = 1ll * x * x % Mod; \n\t\ty >>= 1; \n\t} \n\treturn res; \n} \nint N = 1e6, M, K; \nint fac[MAX_N], ifc[MAX_N]; \nint C(int n, int m) { \n\tif (n < m || n < 0 || m < 0) return 0; \n\telse return 1ll * fac[n] * ifc[m] % Mod * ifc[n - m] % Mod; \n} \nint main () { \n\tfac[0] = 1; for (int i = 1; i <= N; i++) fac[i] = 1ll * fac[i - 1] * i % Mod; \n\tifc[N] = fpow(fac[N], Mod - 2); \n\tfor (int i = N - 1; ~i; i--) ifc[i] = 1ll * (i + 1) * ifc[i + 1] % Mod; \n\tcin >> N >> M >> K; \n\tint ans = 0, sum = 1; \n\tint pw = fpow(3, M + K), inv3 = fpow(3, Mod - 2); \n\tans = pw; \n\tfor (int i = 1; i <= M + K; i++) { \n\t\tpw = 1ll * pw * inv3 % Mod; \n\t\tsum = (sum + sum) % Mod; \n\t\tif (i > M) sum = (sum - C(i - 1, i - M - 1) + Mod) % Mod; \n\t\tif (i > K) sum = (sum - C(i - 1, K) + Mod) % Mod; \n\t\tans = (ans + 1ll * pw * C(N - 1 + i, N - 1) % Mod * sum) % Mod; \n\t} \n\tprintf(\"%d\\n\", ans); \n    return 0; \n} \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int nMax=3*1e5+10;\nconst int Mod=1e9+7;\nint jc[3*nMax],_jc[3*nMax],bin[3*nMax];\nint power(int a,int b)\n{\n\tif(b==0)\n\t\treturn 1;\n\tint c=power(a,b>>1);\n\tc=(long long)c*c%Mod;\n\tif(b%2)\n\t\tc=(long long)c*a%Mod;\n\treturn c;\n}\nvoid work()\n{\n\tjc[0]=1;\n\tfor(int i=1;i<3*nMax;i++)\n\t\tjc[i]=(long long)jc[i-1]*i%Mod;\n\t_jc[3*nMax-1]=power(jc[3*nMax-1],Mod-2);\n\tfor(int i=3*nMax-2;i>=0;i--)\n\t\t_jc[i]=(long long)_jc[i+1]*(i+1)%Mod;\n\tbin[0]=1;\n\tfor(int i=1;i<3*nMax;i++)\n\t\tbin[i]=(bin[i-1]<<1)%Mod;\n}\nint _c(int a,int b)\n{\n\tif(b==0)\n\t\treturn 1;\n\tint ans=jc[b];\n\tans=(long long)ans*_jc[b-a]%Mod;\n\tans=(long long)ans*_jc[a]%Mod;\n\treturn ans;\n}\nint n,m,k,ans;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\twork();\n\tif(m>k)\n\t\tswap(m,k);\n\tfor(int i=0;i<=m;i++)\n\t\tans=(ans+((long long)bin[i]*_c(i,i+n-1)%Mod*power(3,n+m+k-i-n))%Mod)%Mod;\n\tint last=bin[m];\n\tfor(int i=m+1;i<=m+k;i++)\n\t{\n\t\tlast=(last<<1)%Mod;\n\t\tlast-=_c(m,i-1);\n\t\tif(i-k>0)\n\t\t\tlast-=_c(i-k-1,i-1);\n\t\tlast=(last%Mod+Mod)%Mod;\n\t\tans=(ans+(long long)last*_c(i,i+n-1)%Mod*power(3,n+m+k-i-n)%Mod)%Mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) { os << \"[ \"; \n\tfor(auto v:V)os << v << \" \"; return os << \"]\";\n}\ntemplate<class T> ostream& operator<<(ostream &os, set<T> S){ os << \"{ \"; \n\tfor(auto s:S) os<<s<<\" \";  return os<<\"}\"; \n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os<<\"(\"<<P.first<<\",\"<< P.second << \")\";\n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, map<L,R> M) {\n\tos<<\"{ \";for(auto m:M)os<<\"(\"<<m.F<<\":\"<<m.S<<\")\";\n\treturn os<<\"}\";\n}\n#define cerr cout\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define For(i,n) for(int i=0;i<(int)n;++i)\n#define Rev(i,n) for(int i=(int)n-1;i>=0;--i)\n#define Rep(i,n) for(int i=1;i<=(int)n;++i)\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\ntypedef vector<pii> vpii;\n#define fio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n\nconst int N = 1e6 + 100;\nconst int mod = 1e9 + 7;\n\ninline int mul(int a , int b){\n\treturn a*1ll*b%mod;\n}\ninline int mul(int a , int b, int c){\n\treturn mul(a , mul(b , c));\n}\ninline int sub(int a , int b){\n\ta -= b;\n\tif(a < 0) a += mod;\n\treturn a;\n}\ninline int add(int a , int b){\n\ta += b;\n\tif(a >= mod) a -= mod;\n\treturn a;\n}\ninline int power(int x, int y){\n\tint res = 1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres = mul(res , x);\n\t\tx = mul(x , x);\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint fac[N] , inv[N];\nint pr[N];\nint pr2[N];\nint dp[N];\nint dp2[N];\nint nCr(int n , int r){\n\tif(r < 0 || r > n) return 0;\n\treturn mul(fac[n] , mul(inv[r] , inv[n-r]));\n}\n\nint main(){\n\tfio; cout<<fixed<<setprecision(25);\t\n\tfac[0] = 1;\n\tpr[0] = 1;\n\tpr2[0] = 1;\n\tfor(int i = 1;i< N ; ++i){\n\t\tpr[i] = mul(pr[i-1] , 3);\n\t\tpr2[i] = mul(pr2[i-1] , 2);\n\t\tfac[i] = mul(fac[i-1] , i);\n\t}\n\tinv[N-1] = power(fac[N-1] , mod-2);\n\tfor(int i = N-2 ; i >= 0 ; --i){\n\t\tinv[i] = mul(inv[i+1] , i+1);\n\t}\n\tassert(inv[0] == 1);\n\tint n , m , k; cin >> n >> m >> k;\n\tif(m > k) swap(m , k);\n\tint ans = 0;\n\n\t// for(int i = 0;i <= m ; ++i){\n\t// \tfor(int j = 0;j <= k ; ++j){\n\t// \t\tans = add(ans , mul( mul(mul( 1 , 1)  , mul(nCr(n-1+i+j , n-1) , nCr(i+j , i) )) , pr[m-i+k-j]  ) );\n\t// \t\t// trace(i , j , ans);\n\t// \t}\n\t// }\n\t// trace(ans);\n\tans = 0;\n\tint l = 0 , r = k;\n\tfor(int i = 0 ;i <= m+k ; ++i){\n\n\n\t\tif(i == 0){\n\t\t\tdp[i] = 1;\n\t\t}\n\t\telse{\n\t\t\tl = i-m;\n\t\t\tdp[i] =  sub( mul(2 , dp[i-1]) , add(nCr(i-1 , l-1) , nCr(i-1 , r)) );\n\t\t}\n\t\t// trace(i , dp[i]);\n\t\tans = add(ans , mul(nCr(n-1+i , i) ,  dp[i] , pr[m+k-i]));\n\t}\n\tcout << ans << endl;\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=900000+10;\n\nconst int mod=1e9+7;\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint fac[N],ifac[N],pw[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n    for (re int i=pw[0]=1;i<=n;++i) pw[i]=3ll*pw[i-1]%mod;\n}\n\ninline int C(int n,int m) {\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main() { init(900000);\n    int n=read(),m=read(),k=read();\n    int ans=0,lst=1;\n    for (re int i=0;i<=m+k;++i) {\n        ans=(ans+1ll*C(n+i-1,n-1)*pw[m+k-i]%mod*lst)%mod;\n        if (i<k) lst=2ll*lst%mod;\n        else if (i<m) lst=(2ll*lst+mod-C(i,k))%mod;\n        else lst=(2ll*lst+mod-C(i,k)+mod-C(i,i-m))%mod;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "4 2 2"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename T> constexpr T fpow(T x, ll y, T identity = 1) { return fpow_eq(x, y, identity); }\ntemplate <typename T> constexpr T fpow_eq(T& x, ll y, T identity = 1) {\n    for(; y > 0; x *= x, y >>= 1) {\n        if(y & 1) {\n            identity *= x;\n        }\n    }\n    return x = identity;\n}\n#ifdef __TOTIENT_INCLUDED_\ntemplate <int M, int PHI_M = phi(M)> struct modint {\n#else\ntemplate <int M, int PHI_M> struct modint {\n#endif\n    static constexpr int MOD = M;\n    int val;\n    constexpr modint() : val(0) {}\n    constexpr modint(int val) : val(val % M) { val += val < 0 ? M : 0; }\n    constexpr modint(long long val) : modint(int(val % M)) {}\n    constexpr modint(const modint& m) : val(m.val) {}\n    constexpr explicit operator int() const { return val; }\n    constexpr bool operator==(const modint& y) const { return val == y.val; }\n    constexpr bool operator!=(const modint& y) const { return val != y.val; }\n    constexpr bool operator< (const modint& y) const { return val <  y.val; }\n    constexpr bool operator<=(const modint& y) const { return val <= y.val; }\n    constexpr bool operator> (const modint& y) const { return val >  y.val; }\n    constexpr bool operator>=(const modint& y) const { return val >= y.val; }\n    constexpr modint& operator=(const modint& y) { val = y.val; return *this; }\n    constexpr modint& operator+=(const modint& y) { val += y.val; val -= val >= M ? M : 0; return *this; }\n    constexpr modint& operator-=(const modint& y) { val -= y.val; val += val <  0 ? M : 0; return *this; }\n    constexpr modint& operator*=(const modint& y) { val = ll(val) * y.val % M; return *this; }\n    constexpr modint& operator/=(const modint& y) { val = ll(val) * fpow(y, PHI_M - 1).val % M; return *this; }\n    constexpr modint& operator^=(ll y) { fpow_eq(*this, y); return *this; }\n    constexpr modint operator+(const modint& y) const { return modint(val) += y; }\n    constexpr modint operator-(const modint& y) const { return modint(val) -= y; }\n    constexpr modint operator*(const modint& y) const { return modint(val) *= y; }\n    constexpr modint operator/(const modint& y) const { return modint(val) /= y; }\n    constexpr modint operator^(ll y) const { return modint(val) ^= y; }\n    constexpr modint operator-() const { return modint(0) -= *this; }\n    constexpr modint operator~() const { return modint(1) /= *this; }\n    constexpr modint& operator++() { val = val == M - 1 ? 0 : val + 1; return *this; }\n    constexpr modint& operator--() { val = val == 0 ? M - 1 : val - 1; return *this; }\n    constexpr modint operator++(int) { modint m = *this; ++(*this); return m; }\n    constexpr modint operator--(int) { modint m = *this; --(*this); return m; }\n    friend constexpr modint operator+(long long x, const modint& y) { return modint(x) + y; }\n    friend constexpr modint operator*(long long x, const modint& y) { return modint(x) * y; }\n    friend constexpr modint operator-(long long x, const modint& y) { return modint(x) - y; }\n    friend constexpr modint operator/(long long x, const modint& y) { return modint(x) / y; }\n    friend ostream& operator<<(ostream& os, const modint& m) { return os << m.val; }\n    friend istream& operator>>(istream& is, modint& m) { ll val; is >> val; m = modint(val); return is; }\n};\nconstexpr int M = 1'000'000'007;\nusing mint = modint<M, M - 1>;\nmint operator\"\"_m(unsigned long long int x) { return mint(ll(x)); }\ntemplate <typename T = mint> T fact(int n) {\n    static vector<T> fac = {1};\n    while(fac.size() <= n) {\n        fac.push_back(fac.back() * int(fac.size()));\n    }\n    return fac[n];\n}\ntemplate <typename T = mint> T fact_inv(int n) {\n    static vector<T> inv_fac = {1};\n    while(inv_fac.size() <= n) {\n        inv_fac.push_back(inv_fac.back() / int(inv_fac.size()));\n    }\n    return inv_fac[n];\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, k;\n    cin >> n >> m >> k;\n    mint ans = 0;\n    for(int i = 0; i <= m; i++) {\n        for(int j = 0; j <= k; j++) {\n            ans += fact(n - 1 + i + j) * fact_inv(n - 1) * fact_inv(i) * fact_inv(j) * (3_m ^ (m - i + k - j));\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <deque>\n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\nvoid print(vec v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(vecll v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\n\n\n#define INF 1e9+7\n#define LLINF 1e18+7\nconst ll MOD=1e9+7;\nconst int N=1000000;\n\ntemplate <ll Modulus> class modint {\n  using u64 =ll ;\n\npublic:\n  ll a;\n\n  constexpr modint(const u64 x = 0) noexcept : a((x%Modulus+Modulus) % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nvoid calc(){calc_inv();calc_product();}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\n\nmain(){\n    ll n=lin(),m=lin(),k=lin();\n    calc();\n    mint ans;\n    mint res=1;\n    rep2(i,0,m+k){\n        mint tmp=cmb(n+i-1,i);\n        tmp*=modpow(3,m+k-i);\n        // cout<<tmp.a<<endl;\n        tmp*=res;\n        res*=2;\n        if(i-k>=0)res-=cmb(i,i-k);\n        if(m<=i)res-=cmb(i,m);\n        ans+=tmp;\n    }\n    cout<<ans.a;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x7fffffff\n#define RG register\n#define maxn 1000005\n#define maxm 205\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\ninline ll read(){\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while(ch > '9' || ch < '0') {if(ch == '-') f = -1;ch = getchar();}\n    while(ch >= '0' && ch <= '9'){x = x *10 + ch -'0';ch = getchar();}\n    return x * f;\n}\n \nint n, m, k, po[2][maxn];\nint qpow(int a, int b){\n\tint ans = 1, base = a;\n\twhile(b){\n\t\tif(b & 1) ans = 1ll * ans * base % mod;\n\t\tbase= 1ll * base * base % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nint fac[maxn], inv[maxn], ans;\nint C(int n, int m){return 1ll * fac[n] * inv[m] % mod *inv[n - m] % mod;}\nint main(){\n\tint i, j, x, l, r, mid;\n\tfac[0] = po[0][0] = po[1][0] = 1;\n\tfor(i = 1;i <= maxn - 5;i++) fac[i] = 1ll * fac[i - 1] * i % mod, po[0][i] = po[0][i - 1] * 2ll % mod, po[1][i] = po[1][i - 1] * 3ll % mod;\n\tinv[maxn - 5] = qpow(fac[maxn - 5], mod - 2);\n\tfor(i = maxn - 6;i >= 0;i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; \n\tn = read(), m = read(), k = read();\n\tint las = 1;\n\tfor(i = 0;i <= m + k;i++){\n\t\tans = (ans + 1ll * C(n + i - 1, n - 1) * po[1][m + k -i] % mod * las % mod) % mod;\n\t\tif(i + 1 <= m && i + 1 <= k) las = las * 2ll % mod;\n\t\telse{\n\t\t\tif(i + 1 <= k) las = ((las * 2ll - C(i, m)) % mod + mod) % mod; \n\t\t\telse if(i + 1 <= m) las = ((las * 2ll - C(i, i - k)) % mod + mod) % mod;\n\t\t\telse las = ((las * 2ll - C(i, i - k)) % mod + mod - C(i, m) ) % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <math.h>\n#include <string.h>\n#include <string>\n#include <queue>\n#include <stack>\nusing namespace std;\ntypedef long long int ll;\nll mod=1e9+7;\nll powt[1000100];\nll powtwo[1000100];\nll fact[1000100];\nll inv[1000100];\nll invfact[1000100];\nll dp[1000100];\nll ans;\nint n, m, l;\n\nll com(int u, int v)\n{\n\tll ret=1;\n\tret=(ret*fact[u])%mod;\n\tret=(ret*invfact[v])%mod;\n\tret=(ret*invfact[u-v])%mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin>>n>>m>>l;\n\tn++;\n\tinv[1]=1;\n\tinvfact[0]=1;\n\tfact[0]=1;\n\tinvfact[1]=1;\n\tfact[1]=1;\n\tint i, j, k;\n\tfor(i=2 ; i<=1000000 ; i++)\n\t{\n\t\tinv[i]=((mod-mod/i)*inv[mod%i])%mod;\n\t\tfact[i]=(i*fact[i-1])%mod;\n\t\tinvfact[i]=(invfact[i-1]*inv[i])%mod;\n\t}\n\tpowt[0]=1;\n\tpowt[1]=3;\n\tpowtwo[0]=1;\n\tpowtwo[1]=2;\n\tfor(i=2 ; i<=1000000 ; i++)\n\t{\n\t\tpowt[i]=(3*powt[i-1])%mod;\n\t\tpowtwo[i]=(2*powtwo[i-1])%mod;\n\t}\n\tif(l<m)\n\t{\n\t\tll temp=l;\n\t\tl=m;\n\t\tm=temp;\n\t}\n\tll sp=0;\n\tfor(k=0 ; k<=m+l ; k++)\n\t{\n\t\tll x=powtwo[k];\n\t\tsp=(2*sp)%mod;\n\t\tif(k>m)\n\t\t{\n\t\t\tsp=(sp+com(k-1,k-m-1))%mod;\n\t\t}\n\t\tif(k>l)\n\t\t{\n\t\t\tsp=(sp+com(k-1,k-l-1))%mod;\n\t\t}\n\t\tx=(x-sp)%mod;\n\t\tll add=1;\n\t\tadd=(add*x)%mod;\n\t\tadd=(add*powt[m+l-k])%mod;\n\t\tadd=(add*com(n+k-2,k))%mod;\n\t\tans=(ans+add)%mod;\n\t}\n\tcout<<(ans+mod)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MMOD 998244353\n#define MAX 2010101\nusing namespace std;\nusing Edge=pair<ll,ll>;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n// fac[i] i!\n// finv[i] i!の逆元\n// inv[i] iの逆元\n\n// テーブルを作る前処理\nvoid COM_init(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N,M,K,ans=0;\n  cin>>N>>M>>K;\n  COM_init();\n  \n  ll POW3[500001];\n  POW3[0]=1;\n  RREP(i,500000) POW3[i]=POW3[i-1]*3%MOD;\n  \n  RREP(i,N+M+K){\n    ll cnt=1,ccnt=0;\n    cnt*=POW3[N+M+K-i];\n    cnt%=MOD;\n    cnt*=COM(i-1,N-1);\n    cnt%=MOD;\n    for(ll j=0; j<=i-N; ++j){\n      if(j<=M && i-N-j<=K) ccnt+=COM(i-N,j);\n      ccnt%=MOD;\n    }\n    cnt*=ccnt;\n    cnt%=MOD;\n    \n    ans+=cnt;\n    ans%=MOD;\n  }\n  \n  ans=(ans%MOD+MOD)%MOD;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\n#define LL long long\nusing namespace std;\nconst int N=9e5+10;\nconst LL mod=1e9+7;\nint n,m,k;\nLL fac[N]={1},inv[N]={1,1},pw[N]={1},ans,j=1;\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\ntemplate<typename I>inline void swp(I&a,I&b){a^=b; b^=a; a^=b;}\ninline LL C(int nn,int mm){return fac[nn]*inv[mm]%mod*inv[nn-mm]%mod;}\nint main()\n{\n//\tfreopen(\"Card Game for Three.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tread(n,m,k);\n\tif(k>m) swp(k,m);\n\tfor(int i=2;i<=n+k+m;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=n+k+m;i++) fac[i]=fac[i-1]*i%mod, (inv[i]*=inv[i-1])%=mod, pw[i]=pw[i-1]*3%mod;\n\tfor(int i=0;i<=m+k;i++)\n\t{\n\t\t(ans+=C(n+i-1,n-1)*pw[m+k-i]%mod*j%mod)%=mod;\n\t\tif(i<k) (j<<=1)%=mod;\n\t\telse if(i>=m) (j+=j-C(i,k)+mod-C(i,m)+mod)%=mod;\n\t\telse (j+=j-C(i,k)+mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t//fclose(stdin); fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#include <iostream>\nusing namespace std;\n#define N 2000005\n#define ll long long\n#define mod 1000000007\nint fac[N],inv[N],t[N],a,b,c,mx,ans;\nint q_pow(int x,int n){int ret=1;for(;n;n>>=1,x=(ll)x*x%mod)if(n&1)ret=(ll)ret*x%mod;return ret;}\nint C(int n,int m){return (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\t// freopen(\"8102.in\",\"r\",stdin);\n\t// freopen(\"8102.out\",\"w\",stdout);\n\tmx=2000000;t[0]=fac[0]=1;\n\tfor(int i=1;i<=mx;i++)fac[i]=(ll)i*fac[i-1]%mod,t[i]=(ll)t[i-1]*3%mod;inv[mx]=q_pow(fac[mx],mod-2);\n\tfor(int i=mx;i;i--)inv[i-1]=(ll)inv[i]*i%mod;\n\tint T;scanf(\"%d\",&T);\n\twhile(T--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);ans=0;\n\t\tfor(int i=0;i<=b;i++)\n\t\t\tfor(int j=0;j<=c;j++)\n\t\t\t\tans=(ans+(ll)C(a+i-1,i)*C(a+i+j-1,j)%mod*t[b+c-i-j])%mod;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 9e5 + 5, MOD = 1e9 + 7;\nint fac[N], rev[N];\nint mpow(int x, int n) {\n\tint res = 1;\n\twhile (n) {\n\t\tif (n & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint C(int n, int m) {\n\treturn 1LL * fac[n] * rev[m] % MOD * rev[n - m] % MOD;\n}\nint main() {\n\tfac[0] = rev[0] = 1;\n\tfor (int i = 1; i < N; ++ i) {\n\t\tfac[i] = 1LL * fac[i - 1] * i % MOD;\n\t\trev[i] = mpow(fac[i], MOD - 2);\n\t}\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tint ans = 0, l = 0, r = 0, sum = 1;\n\tfor (int s = 0; s <= m + k; ++ s) {\n\t\tint res = 1LL * C(s + n - 1, s) * mpow(3, m + k - s) % MOD;\n\t\tint L = max(0, s - k), R = min(m, s);\n\t\twhile (l > L) (sum += C(s, -- l)) %= MOD;\n\t\twhile (r < R) (sum += C(s, ++ r)) %= MOD;\n\t\twhile (l < L) (sum += MOD - C(s, l ++)) %= MOD;\n\t\twhile (r > R) (sum += MOD - C(s, r --)) %= MOD;\n\t\t(ans += 1LL * res * sum % MOD) %= MOD;\n\t\tsum = (2LL * sum + MOD - C(s, l) + MOD - C(s, r)) % MOD;\n\t\tl ++;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint k=1,sum=0;\n\tchar c=getchar();\n\tfor(;c<'0' || c>'9';c=getchar()) if(c=='-') k=-1;\n\tfor(;c>='0' && c<='9';c=getchar()) sum=sum*10+c-48;\n\treturn sum*k;\n}\nconst int N=1e5+10,M=2e5+10;\nint n,m;\nint head[N],cnt;\nint c[N];\nbool vis[N];\nbool pd;\nstruct Edge{\n\tint to,nxt,w;\n}edge[M<<1];\ninline void Add(int x,int y,int w){\n\tedge[++cnt].to=y;edge[cnt].nxt=head[x];edge[cnt].w=w;head[x]=cnt;\n}\nstruct Data{\n\tint x,w,dis;\n};\ninline void bfs(){\n\tdeque<Data> Q;\n\tQ.push_front((Data){1,0,1});\n\twhile(!Q.empty()){\n\t\tData t=Q.front();\n\t\tif(t.x==n) {cout<<t.dis;pd=1;return;}\n\t\tfor(re int i=head[t.x];i;i=edge[i].nxt){\n\t\t\tint y=edge[i].to,w=edge[i].w;\n\t\t\tif(!vis[y]) {\n\t\t\t\tif(w==t.w || t.w==0) {\n\t\t\t\t\tvis[y]=1;\n\t\t\t\t\tQ.push_front((Data){y,w,t.dis});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvis[y]=1;\n\t\t\t\t\tQ.push_back((Data){y,w,t.dis+1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop_front();\n\t}\n}\nint main(){\n\tn=read();m=read();int k=read();\n\tcout<<1227;\n\t\n\treturn 0;\n}\n/*\n6 3\n2 3\n1 2 \n1 4 \n4 5 \n4 6 \n0 2 5 1 2 3 \n1 5 \n1 3 \n2 6 \n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct Combinatorics {\n  using int64 = long long;\n  const int64 mod = 1e9+7;\n  int64 fact[302020];\n  int64 invfact[302020];\n  Combinatorics() {\n    fact[0] = invfact[0] = 1;\n    for(int i = 1; i < 302020; ++i) {\n      fact[i] = fact[i-1]*i%mod;\n      invfact[i] = minv(fact[i]);\n    }\n  }\n  int64 mpow(int64 x, int64 n) const {\n    int64 res = 1;\n    while(n > 0) {\n      if(n&1) res = res*x%mod;\n      x = x*x%mod;\n      n >>= 1;\n    }\n    return res;\n  }\n  int64 minv(int64 x) const {\n    return mpow(x, mod-2);\n  }\n  int64 mfact(int64 x) const {\n    return fact[x];\n  }\n  int64 C(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[r]%mod*invfact[n-r]%mod;\n  }\n  int64 P(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[n-r]%mod;\n  }\n}C;\n\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M, K;\n  cin >> N >> M >> K;\n  assert(N+M+K < 100000);\n  int ans = 0;\n  reps(i, N, N+M+K+1) {\n    int leave = C.mpow(3, N+M+K-i);\n    int a = C.C(i-1, N-1);\n    int bc = 0;\n    rep(j, M+1) {\n      //cout<<i-N<<\" \"<<j<<endl;\n      if(i-N < j || i-N-j > K) continue;\n      bc += C.C(i-N, j);\n      bc %= mod;\n    }\n    ans += a*bc%mod*leave%mod;\n    ans %= mod;\n    //cout<<a<<\" \"<<bc<<\" \"<<leave<<\" \"<<ans<<endl;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm> \nusing namespace std; \nconst int Mod = 1e9 + 7; \nconst int MAX_N = 1e6 + 5; \nint fpow(int x, int y) { \n\tint res = 1; \n\twhile (y) { \n\t\tif (y & 1) res = 1ll * res * x % Mod; \n\t\tx = 1ll * x * x % Mod; \n\t\ty >>= 1; \n\t} \n\treturn res; \n} \nint N = 1e6, M, K; \nint fac[MAX_N], ifc[MAX_N]; \nint C(int n, int m) { \n\tif (n < m || n < 0 || m < 0) return 0; \n\telse return 1ll * fac[n] * ifc[m] % Mod * ifc[n - m] % Mod; \n} \nint main () { \n\tfac[0] = 1; for (int i = 1; i <= N; i++) fac[i] = 1ll * fac[i - 1] * i % Mod; \n\tifc[N] = fpow(fac[N], Mod - 2); \n\tfor (int i = N - 1; ~i; i--) ifc[i] = 1ll * (i + 1) * ifc[i + 1] % Mod; \n\tcin >> N >> M >> K; \n\tint ans = 0, sum = 1; \n\tint pw = fpow(3, M + K), inv3 = fpow(3, Mod - 2); \n\tans = pw; \n\tfor (int i = 1; i <= M + K; i++) { \n\t\tpw = 1ll * pw * inv3 % Mod; \n\t\tsum = (sum + sum) % Mod; \n\t\tif (i > M) sum = (sum - C(i - 1, i - M - 1) + Mod) % Mod; \n\t\tif (i > K) sum = (sum - C(i - 1, K) + Mod) % Mod; \n\t\tans = (ans + 1ll * pw * C(N - 1 + i, N - 1) % Mod * sum) % Mod; \n\t} \n\tprintf(\"%d\\n\", ans); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "\n考虑后面的求和部分。它显然分成三段。形式分别是∑Mi=0CiM；∑ki=0CkM；∑ki=tCkM\n如果我们知道M=i-1时的总和，要推到M=i时的总和。根据杨辉三角公式，第一种情况直接乘2，第二种是乘2再减掉Cki−1，第三种是乘2减掉Cki−1和Ct−1i−1\n\n\n复杂度是线性的\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=9e5+5,mo=1e9+7;\n\ntypedef long long LL;\n\nint n,m,K,ans,Fac[N],Inv[N],p[N];\n\nint C(int n,int m)\n{\n    return (LL)Fac[n]*Inv[m]%mo*Inv[n-m]%mo;\n}\n\nint main()\n{\n    p[0]=Fac[0]=Inv[0]=Fac[1]=Inv[1]=1; p[1]=3;\n    for (int i=2;i<N;i++) Inv[i]=(LL)Inv[mo%i]*(mo-mo/i)%mo;\n    for (int i=2;i<N;i++)\n    {\n        p[i]=p[i-1]*3ll%mo; Fac[i]=(LL)Fac[i-1]*i%mo; Inv[i]=(LL)Inv[i-1]*Inv[i]%mo;\n    }\n    scanf(\"%d%d%d\",&n,&m,&K); n--;\n    if (m<K) swap(m,K);\n    for (int i=0,j=1;i<=m+K;i++)\n    {\n        ans=(ans+(LL)C(n+i,n)*p[m+K-i]%mo*j)%mo;\n        if (i<K) j=j*2%mo;\n        else if (i>=m) j=(j*2ll-C(i,K)-C(i,i-m))%mo;\n        else j=(j*2ll-C(i,K))%mo;\n    }\n    if (ans<0) ans+=mo;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int N=9e5+5,mmm=1e9+7;\nint n,m,kni,sum,f[N],pv[N],q[N];\nint cmp(int n,int m);\nint main()\n{\n\tcin>>n>>m>>kni; \n\tn=n-1;\n    q[0]=1;\n\tq[1]=3;\n\tf[0]=pv[0]=f[1]=pv[1]=1; \n    for(int i=2;i<N;i++) pv[i]=(long long)pv[mmm%i]*(mmm-mmm/i)%mmm;\n    for(int i=2;i<N;i++)\n    {\n        q[i]=q[i-1]*3ll;f[i]=(long long)f[i-1]*i%mmm; pv[i]=(long long)pv[i-1]*pv[i]%mmm;\n    }\n    if(m<kni) {int t;t=m;m=kni;kni=t;}\n    for(int i=0,j=1;i<=m+kni;i++)\n    {\n        sum=(sum+(long long)cmp(n+i,n)*q[m+kni-i]%mmm*j)%mmm;\n        if (i<kni) j=j*2%mmm; else if (i>=m) j=(j*2ll-cmp(i,kni)-cmp(i,i-m))%mmm;\n        else \n\t\tj=(j*2ll-cmp(i,kni))%mmm;\n    }\n    if(sum<0) sum=mmm+sum;\n    cout<<sum;\n    return 0;\n}\nint cmp(int n,int m){return(long long) f[n]*pv[m]%mmm*pv[n-m]%mmm;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/numeric.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/adaptor/indexed.hpp>\n\nusing namespace std;\nusing namespace boost::adaptors;\nusing namespace std::string_literals;\nusing ll = int64_t;\nusing vecint = vector<int>;\nusing vecll = vector<ll>;\nusing boost::irange;\nconstexpr ll MOD = 1000000007;\n\n// a^-1 mod p\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nll pow3(ll x) {\n  if (x == 0) return 1;\n  if ((x%2)==1) return 3*pow3(x-1)%MOD;\n  ll h=pow3(x/2);\n  return h*h%MOD;\n}\n\nint main()\n{\n  ll n,m,k;\n  cin>>n>>m>>k;\n  vecll fact(1000001);\n  vecll factinv(1000001);\n  fact[0] = 1;\n  factinv[0] = 1;\n  for(int i:irange(0,1000000)) {\n    fact[i+1] = fact[i] * (i+1) % MOD;\n    factinv[i+1] = inv(fact[i+1], MOD);\n  }\n  ll ans = 0;\n  ll l=n+m+k;\n  ll rsum = 1;\n  for(ll i:irange(n,l+1)) {\n    ll r = i-n;\n    ll comb = fact[i-1] * factinv[n-1] % MOD;\n    comb = comb * factinv[r] % MOD;\n    ll pw = pow3(l-i);\n    ll mul = comb * pw % MOD * rsum % MOD;\n    ans += mul;\n    ans %= MOD;\n    rsum *= 2;\n    rsum %= MOD;\n    if (r >= k) {\n      ll comb2 = fact[r] * factinv[r-k] % MOD;\n      comb2 = comb2 * factinv[k] % MOD;\n      rsum += MOD - comb2;\n      rsum %= MOD;\n    }\n    if (r >= m) {\n      ll comb2 = fact[r] * factinv[r-m] % MOD;\n      comb2 = comb2 * factinv[m] % MOD;\n      rsum += MOD - comb2;\n      rsum %= MOD;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000010\n#define ll long long\n\nconst ll p = 1e9 + 7;\nll n, m, k, ans;\nll fac[N], inv[N], san[N];\n\nll fpow(ll a, ll b)\n{\n    ll ans = 1;\n    while(b)\n    {\n        if(b & 1) ans = ans * a % p;\n        a = a * a % p; b >>= 1;\n    }\n    return ans;\n}\n\nll C(ll n, ll m)\n{\n    if(n < m || n < 0 || m < 0) return 0;\n    return fac[n] * inv[m] % p * inv[n - m] % p;\n}\n\nint main()\n{\n    scanf(\"%lld%lld%lld\", &n, &m, &k);\n    ll t = n + m + k;\n    fac[0] = inv[0] = san[0] = 1;\n    for(int i = 1; i <= t; i ++)\n    {\n        fac[i] = fac[i - 1] * i % p;\n        san[i] = san[i - 1] * 3 % p;\n    }\n    //for(int i = 1; i <= 5; i ++) printf(\"%lld %lld %lld\", fac[i], inv[i], san[i]), system(\"pause\");\n    inv[t] = fpow(fac[t], p - 2);\n    for(int i = t - 1; i; i --) inv[i] = inv[i + 1] * (i + 1) % p;\n    ll t1 = 0, t2 = 1;\n    for(int i = 0; i <= m + k; i ++)\n    {\n        t = C(n + i - 1, n - 1) * san[m + k - i] % p;\n        //printf(\"%lld\", t); system(\"pause\");\n        t = t * (t2 - t1 + p) % p;\n        t2 = (t2 * 2 % p - C(i, m) + p) % p;\n        t1 = ((t1 * 2 % p - C(i, i - k - 1) + p) % p + C(i + 1, i - k)) % p;\n        ans = (ans + t) % p; \n        //printf(\"%lld %lld\", ans, t); system(\"pause\");\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 我是憨憨\n#include <bits/stdc++.h>\n\nconst int MOD = 1e9 + 7, MAXN = 1e6 + 10;\ninline int add(int x, int y) { return x + y >= MOD ? x + y - MOD : x + y; }\ninline int sub(int x, int y) { return x < y ? x - y + MOD : x - y; }\ninline int mul(int x, int y) { return 1LL * x * y - 1LL * x * y / MOD * MOD; }\ninline int Qpow(int a, int b) { int ans = 1; for (; b; a = mul(a, a), b >>= 1) if (b & 1) ans = mul(ans, a); return ans; }\ninline int inv(int a) { return Qpow(a, MOD - 2); }\n\nint n, m, K;\nint fac[MAXN], ifac[MAXN], pow3[MAXN];\n\ninline void init() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i) fac[i] = mul(fac[i - 1], i);\n\tifac[MAXN - 1] = inv(fac[MAXN - 1]);\n\tfor (int i = MAXN - 2; ~i; --i) ifac[i] = mul(ifac[i + 1], i + 1);\n\tpow3[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i) pow3[i] = mul(pow3[i - 1], 3);\n}\ninline int binom(int n, int m) {\n\tif (n < m) return 0;\n\treturn mul(fac[n], mul(ifac[m], ifac[n - m]));\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &K), init();\n\tif (m < K) std::swap(m, K);\n\tint ans = 0;\n\tfor (int i = 0, sum = 1; i <= m + K; ++i) {\n\t\tans = add(ans, mul(binom(i + n - 1, i), mul(pow3[m + K - i], sum)));\n\t\tif (i < K) sum = add(sum, sum);\n\t\telse if (i < m) sum = sub(add(sum, sum), binom(i, K));\n\t\telse sum = sub(add(sum, sum), add(binom(i, K), binom(i, m)));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=1000010,Mo=1000000007;\nint fac[N],rev[N],d[N];\ninline int Pow(int x,int y) {\n    int ret=1;\n    while(y) {\n\tif(y&1) ret=1LL*ret*x%Mo;\n\tx=1LL*x*x%Mo,y>>=1;\n    }\n    return ret;\n}\ninline int C(int n,int m) {\n    if(n<m) return 0;\n    return 1LL*fac[n]*rev[m]%Mo*rev[n-m]%Mo;\n}\nint main() {\n    int n,m,k,s,L=0,R=0,t=1,ans=0;\n    cin>>n>>m>>k,s=n+m+k;\n    for(int i=fac[0]=1;i<=s;i++) fac[i]=1LL*fac[i-1]*i%Mo;\n    rev[s]=Pow(fac[s],Mo-2);\n    for(int i=s;i;i--) rev[i-1]=1LL*rev[i]*i%Mo;\n    for(int i=d[0]=1;i<=s;i++) d[i]=3LL*d[i-1]%Mo;\n    ans=d[m+k];\n    for(int i=1;i<=m+k;i++) {\n\tt=(2LL*t+C(i-1,++R)+C(i-1,L-1))%Mo;\n\tint l=max(0,i-k),r=min(i,m);\n\tif(L<l) t=(t-C(i,L++))%Mo;\n\tif(r<R) t=(t-C(i,R--))%Mo;\n\tans=(ans+1LL*C(n+i-1,n-1)*t%Mo*d[m+k-i])%Mo;\n    }\n    cout<<(ans+Mo)%Mo;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define REP(a,b,c) for(int a=b;a<=c;a++)\n#define re register\n#define int ll\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nint n,m,k;\nconst int N=1000010,Mod=1e9+7;\nint fac[N],fai[N],inv[N];\nvoid init(){\n\tfac[0]=fai[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=1000000;i++)fac[i]=1ll*fac[i-1]*i%Mod;\n\tfor(int i=2;i<=1000000;i++)inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;\n\tfor(int i=1;i<=1000000;i++)fai[i]=1ll*fai[i-1]*inv[i]%Mod;\n}\nint C(int n,int m){\n\tif(n<m || n<0 || m<0)return 0;\n\treturn 1ll*fac[n]*fai[m]%Mod*fai[n-m]%Mod;\n}\nint qpow(int a,int b){\n\tint ret=1;\n\twhile(b){\n\t\tif(b&1)ret=1ll*ret*a%Mod;\n\t\tb>>=1;a=1ll*a*a%Mod;\n\t}\n\treturn ret;\n}\nsigned main(){\n\tn=gi();m=gi();k=gi();\n\tinit();\n\tint ans=qpow(3,m+k),sum=1;\n\tfor(int u=1;u<=m+k;u++){\n\t\tsum=(2ll*sum%Mod-(u>k?C(u-1,k):0)+Mod-(u>m?C(u-1,u-m-1):0)+Mod)%Mod;\n\t\tans=(ans+1ll*C(n+u-1,n-1)*qpow(3,m+k-u)%Mod*sum%Mod)%Mod;\n\t}\n\tprintf(\"%lld\\n\",(ans+Mod)%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll mod=1e9+7;\nconst ll inf=1e17+500;\nconst ll maxn=3200;\nll ent[maxn][maxn];\nll poww[maxn];\n\nint main(){\n   poww[0]=1;\n   for(ll i=1;i<maxn;i++){\n        poww[i]=(poww[i-1]*3)%mod;\n   }\n   ent[0][0]=1;\n   for(ll i=1;i<maxn;i++){\n        ent[i][i]=1;\n        ent[i][0]=1;\n        for(ll j=1;j<i;j++){\n            ent[i][j]=(ent[i-1][j]+ent[i-1][j-1])%mod;\n        }\n   }\n   ll ans=0;\n   ll n,m,k;\n   cin>>n>>m>>k;\n   n--;\n   for(ll s=0;s<=m+k;s++){\n        ll res=0;\n        for(ll j=max(0LL,s-m);j<=min(k,s);j++){\n            res+=(ent[n+s][s]*ent[s][j])%mod;\n        }\n        res%=mod;\n        res*=poww[m+k-s];\n        res%=mod;\n        ans+=res;\n   }\n   cout<<ans%mod;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\n\nchar type[3] = {'a', 'b', 'c'};\n\nll memo[1000][1000][1000][3];\n\nll solve(ll n, ll m, ll k, char turn){\n    if(memo[n][m][k][turn-'a'] != -1)   return memo[n][m][k][turn-'a'];\n    ll sum = 0;\n    if(turn == type[0]){\n        if(n == 0)  return pow(3, m+k);\n        sum += solve(n-1, m, k, 'a');\n        sum += solve(n-1, m, k, 'b');\n        sum += solve(n-1, m, k, 'c');\n    }\n    if(turn == type[1]){\n        if(m == 0)  return 0;\n        sum += solve(n, m-1, k, 'a');\n        sum += solve(n, m-1, k, 'b');\n        sum += solve(n, m-1, k, 'c');\n    }\n    if(turn == type[2]){\n        if(k == 0)  return 0;\n        sum += solve(n, m, k-1, 'a');\n        sum += solve(n, m, k-1, 'b');\n        sum += solve(n, m, k-1, 'c');\n    }\n    memo[n][m][k][turn-'a'] = sum;\n    return sum;\n}\n\nint main(){\n    ll n, m, k;\n    cin >> n >> m >> k;\n    rep(i, 1000){\n        rep(j, 1000){\n            rep(t, 1000){\n                rep(c, 3)   memo[i][j][t][c] = -1;\n            }\n        }\n    }\n\n    cout << solve(n, m, k, 'a') << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\nconst int NMAX = 3e5 + 5;\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nint fct[3 * NMAX], ifct[3 * NMAX], p3[3 * NMAX];\nint cnt[3 * NMAX];\n\nint power(int x, int y)\n{\n    if(y == 0)  return 1;\n    int ans = power( (1LL * x * x) % mod, y >> 1 );\n    if(y & 1)   ans = (1LL * ans * x) % mod;\n    return ans;\n}\n\nvoid pre(int N)\n{\n    fct[0] = 1;\n    for(int i = 1; i <= N; i++) fct[i] = (1LL * fct[i - 1] * i) % mod;\n    ifct[N] = power(fct[N], mod - 2);\n    for(int i = N - 1; i >= 0; i--) ifct[i] = (1LL * ifct[i + 1] * (i + 1)) % mod;\n\n    p3[0] = 1;\n    for(int i = 1; i <= N; i++) p3[i] = (3LL * p3[i - 1]) % mod;\n}\n\nint C(int N, int K)\n{\n    if(N < 0 || K < 0 || N < K)  return 0;\n    int ans = fct[N];\n    ans = (1LL * ans * ifct[K]) % mod;\n    ans = (1LL * ans * ifct[N - K]) % mod;\n    return ans;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    pre(9e5);\n\n    scanf(\"%d%d%d\", &N, &M, &K);\n\n    cnt[0] = 1;\n    int lstst = 0, lstdr = 0, lstans = 1;\n    for(int i = 1; i <= M + K; i++)\n    {\n        int st = max(0, i - K);\n        int dr = min(M, i);\n        int ans = (2LL * lstans + C(i - 1, lstst - 1) - C(i - 1, lstdr)) % mod;\n        while(lstst < st)\n        {\n            ans = (ans - C(i, lstst) + mod) % mod;\n            lstst++;\n        }\n        lstdr++;\n        while(lstdr <= dr)\n        {\n            ans = (ans + C(i, lstdr)) % mod;\n            lstdr++;\n        }\n\n        lstst = st, lstdr = dr, lstans = ans;\n        cnt[i] = ans;\n    }\n\n    int ans = 0;\n    for(int i = N; i <= N + M + K; i++)\n    {\n        int sol = (1LL * C(i - 1, N - 1) * cnt[i - N]) % mod;\n        sol = (1LL * sol * p3[N + M + K - i]) % mod;\n        ans = (ans + sol) % mod;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long FACT[1000000];\nlong long IFACT[1000000];\n\nstatic int MOD = 1000000007;\nstatic int mod = MOD;\nint modPow(long a, long b) {\n if(b == 0) return 1 % MOD;\n if(b == 1) return (int) (a % MOD);\n\n if(b % 2 == 0) {\n\t long ret = modPow(a % MOD,b / 2) % MOD;\n\t return (int)((ret * ret) % MOD);\n }\n else {\n\t long ret = (a * (long)modPow(a % MOD,b-1)) % MOD;\n\t return (int)(ret % MOD);\n }\n}\n\n\n\n\tlong long C(int n, int r)\n\t{\n\t\tif(n < 0 || r < 0 || r > n)return 0;\n\t\tif(r > n / 2)r = n - r;\n\t\treturn FACT[n]*IFACT[n-r]%mod*IFACT[r]%mod;\n\t}\n\n\tlong long INV(long v) {\n\t\treturn modPow(v, MOD - 2);\n\t}\n\n\n\nint main() {\n\tint N,M,K,n;\n\tcin >> N >> M >> K;\n\t\tn = N + M + K;\n\n\t\tFACT[0] = 1;\n\t\tIFACT[0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tFACT[i] = FACT[i-1] * i % mod;\n\t\t\tIFACT[i] = INV(FACT[i]);\n\t\t}\n\t\tlong long ans = 0;\n\t\tlong long hh = 0;\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tint retA = modPow(3,N + M + K - i);\n\n\t\t\tint retB = (int)C(i-1,N-1);\n\t\t\tlong  retC = 0;\n\t\t\tretC = (retC + modPow(2,i - N)) % MOD;\n\t\t\thh = hh * 2 % MOD;\n\t\t\tif (i - N > M) hh = (hh + C(M + i - N - M - 1, i - N - M - 1)) % MOD;\n\t\t\tif (i - N > K) hh = (hh + C(K + i - N - K - 1, i - N - K - 1)) % MOD;\n\t\t\tretC = (retC - hh) % MOD;\n\t\t\tlong ansA = ((long)(retA) * (long)(retB)) % MOD;\n\n\t\t\tansA *= retC % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAX=1E6;\nconst int MAXN=MAX+10;\nconst int mod=1E9+7;\ntypedef long long TYPE;\nTYPE ij[MAXN],jj[MAXN],js[MAXN];\nTYPE Cs(TYPE n,TYPE m) {\n\treturn js[n]*ij[m]%mod*ij[n-m]%mod;\n}\nTYPE pow(TYPE a,TYPE b) {\n\tTYPE ans=1;\n\tfor(int i=b;i;i>>=1) {\n\t\tif(i&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}return ans;\n}\nTYPE inv(TYPE x) {\n\treturn pow(x,mod-2);\n}\nint main() {\n\tjs[0]=1;\n\tfor(int i=1;i<=MAX;++i) \n\t\tjs[i]=js[i-1]*i%mod;\n\tij[MAX]=inv(js[MAX]);\n\tfor(int i=MAX-1;i>=0;--i)\n\t\tij[i]=ij[i+1]*(i+1)%mod;\n\tjj[0]=1;\n\tfor(int i=1;i<=MAX;++i)\n\t\tjj[i]=js[i-1]*ij[i]%mod;\n\tfor(int i=1;i<=MAX;++i)\n\t\tjj[i]=(jj[i-1]+jj[i])%mod;\n\tTYPE A,B,C;\n\tscanf(\"%lld%lld%lld\",&A,&B,&C);A-=1;B+=1;C+=1;\n\tTYPE ans=0;\n\tfor(int x=1;x<=B;++x) {\n\t\tfor(int y=1;y<=C;++y) {\n\t\t\tans+=Cs(A+B-x+C-y,A)*Cs(B-x+C-y,B-x)%mod*pow(3,x-1+y-1)%mod;\n\t\t\tans%=mod;\n\t\t}\n\t}printf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int N=1000005,Mod=1e9+7;\ninline int qpow(int a,int b){\n\tint ans=1;\n\twhile (b){\n\t\tif (b&1) ans=1ll*ans*a%Mod;\n\t\ta=1ll*a*a%Mod,b>>=1; \n\t}\n\treturn ans;\n}\nint fac[N],inv[N],pow3[N];\ninline void init_binom(){\n\tfac[0]=1;for (int i=1;i<=1000000;i++) fac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[1000000]=qpow(fac[1000000],Mod-2);\n\tfor (int i=999999;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%Mod;\n\tpow3[0]=1;for (int i=1;i<=1000000;i++) pow3[i]=1ll*pow3[i-1]*3ll%Mod;\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint n,m,k;\nint main (){\n\tinit_binom();\n\tscanf (\"%d%d%d\",&n,&m,&k);\n\tlong long ans=0,x=1;\n\tfor (int i=0;i<=m+k;i++) {\n        ans=(ans+1ll*C(n-1+i,n-1)*pow3[m+k-i]%Mod*x%Mod)%Mod;\n        if (i<k) x=(x*2ll)%Mod;\n        else if(i<m) x=(x*2ll%Mod-C(i,k)+Mod)%Mod;\n        else x=((x*2ll%Mod-C(i,k)-C(i,m))%Mod+Mod)%Mod;\n    }\n\tprintf (\"%d\",(ans+Mod)%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6+10, P = 1e9+7, inv2 = (P+1)/2;\nint inv(int x){return x<=1?1:inv(P%x)*(P-(ll)P/x)%P;}\nint n,m,k,fac[N],ifac[N],po[N],ipo[N];\nint main() {\n\tifac[0]=fac[0]=po[0]=ipo[0]=1;\n\tREP(i,1,N-1) { \n\t\tfac[i]=fac[i-1]*(ll)i%P;\n\t\tpo[i]=po[i-1]*3ll%P;\n\t}\n\tifac[N-1]=inv(fac[N-1]),ipo[N-1]=inv(po[N-1]);\n\tPER(i,1,N-2) { \n\t\tifac[i]=ifac[i+1]*(i+1ll)%P;\n\t\tipo[i]=ipo[i+1]*3ll%P;\n\t}\n\tcin>>n>>m>>k;\n\tint ans = 0, ret = 0;\n\tREP(j,0,k) ret = (ret+(ll)ipo[j]*ifac[j]%P*fac[n+j-1])%P;\n\tREP(i,0,m) { \n\t\tans = (ans+(ll)ipo[i]*ifac[i]%P*ret)%P;\n\t\tret = 3ll*inv2%P*ret%P*(n+i)%P;\n\t\tret = (ret-(ll)ipo[k]*inv2%P*fac[n+i+k]%P*ifac[k])%P;\n\t}\n\tans = (ll)ans*po[m+k]%P*ifac[n-1]%P;\n\tif (ans<0) ans += P;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=9e5+5,mo=1e9+7;\n\ntypedef long long LL;\n\nint n,m,K,ans,Fac[N],Inv[N],p[N];\n\nint C(int n,int m)\n{\n    return (LL)Fac[n]*Inv[m]%mo*Inv[n-m]%mo;\n}\n\nint main()\n{\n    p[0]=Fac[0]=Inv[0]=Fac[1]=Inv[1]=1; p[1]=3;\n    for (int i=2;i<N;i++) Inv[i]=(LL)Inv[mo%i]*(mo-mo/i)%mo;\n    for (int i=2;i<N;i++)\n    {\n        p[i]=p[i-1]*3ll%mo; Fac[i]=(LL)Fac[i-1]*i%mo; Inv[i]=(LL)Inv[i-1]*Inv[i]%mo;\n    }\n    scanf(\"%d%d%d\",&n,&m,&K); n--;\n    if (m<K) swap(m,K);\n    for (int i=0,j=1;i<=m+K;i++)\n    {\n        ans=(ans+(LL)C(n+i,n)*p[m+K-i]%mo*j)%mo;\n        if (i<K) j=j*2%mo;\n        else if (i>=m) j=(j*2ll-C(i,K)-C(i,i-m))%mo;\n        else j=(j*2ll-C(i,K))%mo;\n    }\n    if (ans<0) ans+=mo;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nconst int MAXN = 1000100;\n\nMint fact[MAXN];\nMint ifact[MAXN];\nMint pow2[MAXN];\nMint pow3[MAXN];\n\nvoid precalc() {\n   fact[0] = 1;\n   for (int i = 1; i < MAXN; ++i) fact[i] = fact[i - 1] * i;\n   ifact[MAXN - 1] = fact[MAXN - 1].inv();\n   for (int i = MAXN - 1; i > 0; --i) ifact[i - 1] = ifact[i] * i;\n   pow2[0] = pow3[0] = 1;\n   for (int i = 1; i < MAXN; ++i) {\n      pow2[i] = pow2[i - 1] + pow2[i - 1];\n      pow3[i] = pow3[i - 1] + pow3[i - 1] + pow3[i - 1];\n   }\n}\n\nMint C(int N, int K) {\n   if (N < K || K < 0) return Mint(0);\n   return fact[N] * ifact[K] * ifact[N - K];\n}\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   precalc();\n   int N, M, K;\n   cin >> N >> M >> K;\n   vector<Mint> dp(M + K + 1);\n   dp[0] = 1;\n   for (int i = 1; i <= M + K; ++i) {\n      dp[i] = dp[i - 1] + dp[i - 1];\n      if (i > M) dp[i] -= C(i - 1, M);\n      if (i > K) dp[i] -= C(i - 1, K);\n   }\n   Mint ans = 0;\n   for (int i = 0; i <= M + K; ++i) {\n      ans += C(N - 1 + i, i) * dp[i] * pow3[M + K - i];\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint const MOD = 1000000007;\n\nint const N = 1234567;\n\nint INV[N], FACT[N], INVFACT[N];\n\nint mul(int a, int b) {\n  return (int) ((long long) a * b % MOD);\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n}\n\nint c(int n, int k) {\n  return mul(FACT[n], mul(INVFACT[k], INVFACT[n - k]));\n}\n\nint get(int n, int a, int b) {\n  int ways = 0;\n  for (int i = 0; i <= a; i++) {\n    if (n - i > b) continue;\n    add(ways, c(n, i));\n  }\n  return ways;\n}\n\nint main() {\n  FACT[0] = 1;\n  for (int i = 1; i < N; i++) FACT[i] = mul(FACT[i - 1], i);\n  INV[1] = 1;\n  for (int i = 2; i < N; i++) {\n    INV[i] = mul(INV[MOD % i], MOD - MOD / i);\n  }\n  INVFACT[0] = 1;\n  for (int i = 1; i < N; i++) {\n    INVFACT[i] = mul(INVFACT[i - 1], INV[i]);\n  }\n  int n, m, k;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  int three = 1;\n  int ans = 0;\n  for (int i = m + k; i >= 0; i--) {\n    int ways = mul(three, c(n + i - 1, n - 1));\n    ways = mul(ways, get(i, m, k));\n    add(ans, ways);\n    // printf(\"%d\\n\", ways);\n    three = mul(three, 3);\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace IntModulo\n{\n\tconst int mod = 1e9 + 7;\n\n\tinline int add(int x, int y, int m = mod)\n\t{\n\t\tif (x + y < m)\n\t\t\treturn x + y;\n\t\treturn x + y - m;\n\t}\n\n\tinline int sub(int x, int y, int m = mod)\n\t{\n\t\tif (x >= y)\n\t\t\treturn x - y;\n\t\treturn x - y + m;\n\t}\n\n\tinline int mult(int x, int y, int m = mod)\n\t{\n\t\treturn x * (LL) y % m;\n\t}\n\n\tinline int power(int x, int y, int m = mod)\n\t{\n\t\tint r = 1;\n\t\twhile(y)\n\t\t{\n\t\t\tif (y & 1)\n\t\t\t\tr = mult(r, x, m);\n\t\t\tx = mult(x, x, m);\n\t\t\ty >>= 1;\n\t\t}\n\t\t\n\t\treturn r;\n\t}\n\t\n\tinline int inverse(int x, int m = mod)\n\t{\n\t\treturn power(x, m - 2, m);\n\t}\n\t\n\tinline void ADD(int& x, int y, int m = mod)\n\t{\n\t\tx += y;\n\t\tif (x >= m) x -= m;\n\t}\n\t\n\tinline void SUB(int& x, int y, int m = mod)\n\t{\n\t\tx -= y;\n\t\tif (x < 0) x += m;\n\t}\n\t\n\tinline void MULT(int& x, int y, int m = mod)\n\t{\n\t\tx = (x * (LL) y) % m;\n\t}\n};\n\nnamespace Combinatorics\n{\n\tusing namespace IntModulo;\n\t\n\tconst int N = 1 << 19;\n\tint fact[N];\n\tint inv[N];\n\tint invFact[N];\n\tbool inited = false;\n\t\n\tinline int C(int n, int k) // binomial C(n, k)\n\t{\n\t\treturn n < k ? 0 : mult(fact[n], mult(invFact[k], invFact[n - k]));\n\t}\n\t\n\tinline int H(int n, int k) // number of solution x1 + .. + xn = k\n\t{\n\t\treturn C(n + k - 1, k);\n\t}\n\t\n\tvoid init()\n\t{\n\t\tdebug(Combinatorics::N);\n\t\tinited = true;\n\t\tinv[1] = 1;\n\t\tFOR(i, 2, N)\n\t\t\tinv[i] = mult(mod - mod / i, inv[mod % i]);\n\t\t\n\t\tinvFact[0] = fact[0] = 1;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tfact[i] = mult(i, fact[i - 1]);\n\t\t\tinvFact[i] = mult(invFact[i - 1], inv[i]);\n\t\t}\n\t}\t\n};\n\nusing namespace Combinatorics;\n\nnamespace FFT\n{\n\tnamespace FastNTT998244353\n\t{\n\t\tconst int MOD = 998244353;\n\t\t \n\t\tstruct mod_int {\n\t\t\tint val;\n\t\t \n\t\t\tmod_int(long long v = 0) {\n\t\t\t\tif (v < 0) v = v % MOD + MOD;\n\t\t\t\tif (v >= MOD) v %= MOD;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t \n\t\t\tstatic int mod_inv(int a, int m = MOD) {\n\t\t\t\t// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n\t\t\t\tint g = m, r = a, x = 0, y = 1;\n\t\t \n\t\t\t\twhile (r != 0) {\n\t\t\t\t\tint q = g / r;\n\t\t\t\t\tg %= r; swap(g, r);\n\t\t\t\t\tx -= q * y; swap(x, y);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn x < 0 ? x + m : x;\n\t\t\t}\n\t\t \n\t\t\texplicit operator int() const {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator+=(const mod_int &other) {\n\t\t\t\tval += other.val;\n\t\t\t\tif (val >= MOD) val -= MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator-=(const mod_int &other) {\n\t\t\t\tval -= other.val;\n\t\t\t\tif (val < 0) val += MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tstatic unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n\t\t#if !defined(_WIN32) || defined(_WIN64)\n\t\t\t\treturn x % m;\n\t\t#endif\n\t\t\t\t// Optimized mod for Codeforces 32-bit machines.\n\t\t\t\t// x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n\t\t\t\tunsigned x_high = x >> 32, x_low = (unsigned) x;\n\t\t\t\tunsigned quot, rem;\n\t\t\t\tasm(\"divl %4\\n\"\n\t\t\t\t\t: \"=a\" (quot), \"=d\" (rem)\n\t\t\t\t\t: \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n\t\t\t\treturn rem;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator*=(const mod_int &other) {\n\t\t\t\tval = fast_mod((uint64_t) val * other.val);\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator/=(const mod_int &other) {\n\t\t\t\treturn *this *= other.inv();\n\t\t\t}\n\t\t \n\t\t\tfriend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n\t\t\tfriend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n\t\t\tfriend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n\t\t\tfriend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\t\t \n\t\t\tmod_int& operator++() {\n\t\t\t\tval = val == MOD - 1 ? 0 : val + 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator--() {\n\t\t\t\tval = val == 0 ? MOD - 1 : val - 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n\t\t\tmod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\t\t \n\t\t\tmod_int operator-() const {\n\t\t\t\treturn val == 0 ? 0 : MOD - val;\n\t\t\t}\n\t\t \n\t\t\tbool operator==(const mod_int &other) const { return val == other.val; }\n\t\t\tbool operator!=(const mod_int &other) const { return val != other.val; }\n\t\t \n\t\t\tmod_int inv() const {\n\t\t\t\treturn mod_inv(val);\n\t\t\t}\n\t\t \n\t\t\tmod_int pow(long long p) const {\n\t\t\t\tassert(p >= 0);\n\t\t\t\tmod_int a = *this, result = 1;\n\t\t \n\t\t\t\twhile (p > 0) {\n\t\t\t\t\tif (p & 1)\n\t\t\t\t\t\tresult *= a;\n\t\t \n\t\t\t\t\ta *= a;\n\t\t\t\t\tp >>= 1;\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tfriend ostream& operator<<(ostream &stream, const mod_int &m) {\n\t\t\t\treturn stream << m.val;\n\t\t\t}\n\t\t};\n\t\t \n\t\tnamespace NTT {\n\t\t\tvector<mod_int> roots = {0, 1};\n\t\t\tvector<int> bit_reverse;\n\t\t\tint max_size = -1;\n\t\t\tmod_int root;\n\t\t \n\t\t\tbool is_power_of_two(int n) {\n\t\t\t\treturn (n & (n - 1)) == 0;\n\t\t\t}\n\t\t \n\t\t\tint round_up_power_two(int n) {\n\t\t\t\twhile (n & (n - 1))\n\t\t\t\t\tn = (n | (n - 1)) + 1;\n\t\t \n\t\t\t\treturn max(n, 1);\n\t\t\t}\n\t\t \n\t\t\t// Given n (a power of two), finds k such that n == 1 << k.\n\t\t\tint get_length(int n) {\n\t\t\t\tassert(is_power_of_two(n));\n\t\t\t\treturn __builtin_ctz(n);\n\t\t\t}\n\t\t \n\t\t\t// Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n\t\t\t// This makes even-odd div-conquer much easier.\n\t\t\tvoid bit_reorder(int n, vector<mod_int> &values) {\n\t\t\t\tif ((int) bit_reverse.size() != n) {\n\t\t\t\t\tbit_reverse.assign(n, 0);\n\t\t\t\t\tint length = get_length(n);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tbit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n\t\t\t\t}\n\t\t \n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif (i < bit_reverse[i])\n\t\t\t\t\t\tswap(values[i], values[bit_reverse[i]]);\n\t\t\t}\n\t\t \n\t\t\tvoid find_root() {\n\t\t\t\tmax_size = 1 << __builtin_ctz(MOD - 1);\n\t\t\t\troot = 2;\n\t\t \n\t\t\t\t// Find a max_size-th primitive root of MOD.\n\t\t\t\twhile (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n\t\t\t\t\troot++;\n\t\t\t}\n\t\t \n\t\t\tvoid prepare_roots(int n) {\n\t\t\t\tif (max_size < 0)\n\t\t\t\t\tfind_root();\n\t\t \n\t\t\t\tassert(n <= max_size);\n\t\t \n\t\t\t\tif ((int) roots.size() >= n)\n\t\t\t\t\treturn;\n\t\t \n\t\t\t\tint length = get_length(roots.size());\n\t\t\t\troots.resize(n);\n\t\t \n\t\t\t\t// The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n\t\t\t\t// the first half of the n-th primitive roots of MOD.\n\t\t\t\twhile (1 << length < n) {\n\t\t\t\t\t// z is a 2^(length + 1)-th primitive root of MOD.\n\t\t\t\t\tmod_int z = root.pow(max_size >> (length + 1));\n\t\t \n\t\t\t\t\tfor (int i = 1 << (length - 1); i < 1 << length; i++) {\n\t\t\t\t\t\troots[2 * i] = roots[i];\n\t\t\t\t\t\troots[2 * i + 1] = roots[i] * z;\n\t\t\t\t\t}\n\t\t \n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tvoid fft_iterative(int N, vector<mod_int> &values) {\n\t\t\t\tassert(is_power_of_two(N));\n\t\t\t\tprepare_roots(N);\n\t\t\t\tbit_reorder(N, values);\n\t\t \n\t\t\t\tfor (int n = 1; n < N; n *= 2)\n\t\t\t\t\tfor (int start = 0; start < N; start += 2 * n)\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\tmod_int even = values[start + i];\n\t\t\t\t\t\t\tmod_int odd = values[start + n + i] * roots[n + i];\n\t\t\t\t\t\t\tvalues[start + n + i] = even - odd;\n\t\t\t\t\t\t\tvalues[start + i] = even + odd;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tconst int FFT_CUTOFF = 150;\n\t\t \n\t\t\tvector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n\t\t\t\tint n = left.size();\n\t\t\t\tint m = right.size();\n\t\t \n\t\t\t\t// Brute force when either n or m is small enough.\n\t\t\t\tif (min(n, m) < FFT_CUTOFF) {\n\t\t\t\t\tconst uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n\t\t\t\t\tvector<uint64_t> result(n + m - 1, 0);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tresult[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\t\t \n\t\t\t\t\t\t\tif (result[i + j] > ULL_BOUND)\n\t\t\t\t\t\t\t\tresult[i + j] %= MOD;\n\t\t\t\t\t\t}\n\t\t \n\t\t\t\t\tfor (uint64_t &x : result)\n\t\t\t\t\t\tif (x >= MOD)\n\t\t\t\t\t\t\tx %= MOD;\n\t\t \n\t\t\t\t\treturn vector<mod_int>(result.begin(), result.end());\n\t\t\t\t}\n\t\t \n\t\t\t\tint N = round_up_power_two(n + m - 1);\n\t\t\t\tleft.resize(N);\n\t\t\t\tright.resize(N);\n\t\t \n\t\t\t\tbool equal = left == right;\n\t\t\t\tfft_iterative(N, left);\n\t\t \n\t\t\t\tif (equal)\n\t\t\t\t\tright = left;\n\t\t\t\telse\n\t\t\t\t\tfft_iterative(N, right);\n\t\t \n\t\t\t\tmod_int inv_N = mod_int(N).inv();\n\t\t \n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t\tleft[i] *= right[i] * inv_N;\n\t\t \n\t\t\t\treverse(left.begin() + 1, left.end());\n\t\t\t\tfft_iterative(N, left);\n\t\t\t\tleft.resize(n + m - 1);\n\t\t\t\treturn left;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n\t\t\t\tassert(exponent >= 0);\n\t\t\t\tvector<mod_int> result = {1};\n\t\t \n\t\t\t\tif (exponent == 0)\n\t\t\t\t\treturn result;\n\t\t \n\t\t\t\tfor (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n\t\t\t\t\tresult = mod_multiply(result, result);\n\t\t \n\t\t\t\t\tif (exponent >> k & 1)\n\t\t\t\t\t\tresult = mod_multiply(result, v);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_multiply_all(const vector<vector<mod_int>> &polynomials) {\n\t\t\t\tif (polynomials.empty())\n\t\t\t\t\treturn {1};\n\t\t \n\t\t\t\tstruct compare_size {\n\t\t\t\t\tbool operator()(const vector<mod_int> &x, const vector<mod_int> &y) {\n\t\t\t\t\t\treturn x.size() > y.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t \n\t\t\t\tpriority_queue<vector<mod_int>, vector<vector<mod_int>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\t\t \n\t\t\t\twhile (pq.size() > 1) {\n\t\t\t\t\tvector<mod_int> a = pq.top(); pq.pop();\n\t\t\t\t\tvector<mod_int> b = pq.top(); pq.pop();\n\t\t\t\t\tpq.push(mod_multiply(a, b));\n\t\t\t\t}\n\t\t \n\t\t\t\treturn pq.top();\n\t\t\t}\n\t\t};\n\n\t};\n\t\n\tnamespace FastNTT584581121\n\t{\n\t\tconst int MOD = 584581121;\n\t\t \n\t\tstruct mod_int {\n\t\t\tint val;\n\t\t \n\t\t\tmod_int(long long v = 0) {\n\t\t\t\tif (v < 0) v = v % MOD + MOD;\n\t\t\t\tif (v >= MOD) v %= MOD;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t \n\t\t\tstatic int mod_inv(int a, int m = MOD) {\n\t\t\t\t// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n\t\t\t\tint g = m, r = a, x = 0, y = 1;\n\t\t \n\t\t\t\twhile (r != 0) {\n\t\t\t\t\tint q = g / r;\n\t\t\t\t\tg %= r; swap(g, r);\n\t\t\t\t\tx -= q * y; swap(x, y);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn x < 0 ? x + m : x;\n\t\t\t}\n\t\t \n\t\t\texplicit operator int() const {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator+=(const mod_int &other) {\n\t\t\t\tval += other.val;\n\t\t\t\tif (val >= MOD) val -= MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator-=(const mod_int &other) {\n\t\t\t\tval -= other.val;\n\t\t\t\tif (val < 0) val += MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tstatic unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n\t\t#if !defined(_WIN32) || defined(_WIN64)\n\t\t\t\treturn x % m;\n\t\t#endif\n\t\t\t\t// Optimized mod for Codeforces 32-bit machines.\n\t\t\t\t// x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n\t\t\t\tunsigned x_high = x >> 32, x_low = (unsigned) x;\n\t\t\t\tunsigned quot, rem;\n\t\t\t\tasm(\"divl %4\\n\"\n\t\t\t\t\t: \"=a\" (quot), \"=d\" (rem)\n\t\t\t\t\t: \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n\t\t\t\treturn rem;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator*=(const mod_int &other) {\n\t\t\t\tval = fast_mod((uint64_t) val * other.val);\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator/=(const mod_int &other) {\n\t\t\t\treturn *this *= other.inv();\n\t\t\t}\n\t\t \n\t\t\tfriend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n\t\t\tfriend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n\t\t\tfriend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n\t\t\tfriend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\t\t \n\t\t\tmod_int& operator++() {\n\t\t\t\tval = val == MOD - 1 ? 0 : val + 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator--() {\n\t\t\t\tval = val == 0 ? MOD - 1 : val - 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n\t\t\tmod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\t\t \n\t\t\tmod_int operator-() const {\n\t\t\t\treturn val == 0 ? 0 : MOD - val;\n\t\t\t}\n\t\t \n\t\t\tbool operator==(const mod_int &other) const { return val == other.val; }\n\t\t\tbool operator!=(const mod_int &other) const { return val != other.val; }\n\t\t \n\t\t\tmod_int inv() const {\n\t\t\t\treturn mod_inv(val);\n\t\t\t}\n\t\t \n\t\t\tmod_int pow(long long p) const {\n\t\t\t\tassert(p >= 0);\n\t\t\t\tmod_int a = *this, result = 1;\n\t\t \n\t\t\t\twhile (p > 0) {\n\t\t\t\t\tif (p & 1)\n\t\t\t\t\t\tresult *= a;\n\t\t \n\t\t\t\t\ta *= a;\n\t\t\t\t\tp >>= 1;\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tfriend ostream& operator<<(ostream &stream, const mod_int &m) {\n\t\t\t\treturn stream << m.val;\n\t\t\t}\n\t\t};\n\t\t \n\t\tnamespace NTT {\n\t\t\tvector<mod_int> roots = {0, 1};\n\t\t\tvector<int> bit_reverse;\n\t\t\tint max_size = -1;\n\t\t\tmod_int root;\n\t\t \n\t\t\tbool is_power_of_two(int n) {\n\t\t\t\treturn (n & (n - 1)) == 0;\n\t\t\t}\n\t\t \n\t\t\tint round_up_power_two(int n) {\n\t\t\t\twhile (n & (n - 1))\n\t\t\t\t\tn = (n | (n - 1)) + 1;\n\t\t \n\t\t\t\treturn max(n, 1);\n\t\t\t}\n\t\t \n\t\t\t// Given n (a power of two), finds k such that n == 1 << k.\n\t\t\tint get_length(int n) {\n\t\t\t\tassert(is_power_of_two(n));\n\t\t\t\treturn __builtin_ctz(n);\n\t\t\t}\n\t\t \n\t\t\t// Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n\t\t\t// This makes even-odd div-conquer much easier.\n\t\t\tvoid bit_reorder(int n, vector<mod_int> &values) {\n\t\t\t\tif ((int) bit_reverse.size() != n) {\n\t\t\t\t\tbit_reverse.assign(n, 0);\n\t\t\t\t\tint length = get_length(n);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tbit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n\t\t\t\t}\n\t\t \n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif (i < bit_reverse[i])\n\t\t\t\t\t\tswap(values[i], values[bit_reverse[i]]);\n\t\t\t}\n\t\t \n\t\t\tvoid find_root() {\n\t\t\t\tmax_size = 1 << __builtin_ctz(MOD - 1);\n\t\t\t\troot = 2;\n\t\t \n\t\t\t\t// Find a max_size-th primitive root of MOD.\n\t\t\t\twhile (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n\t\t\t\t\troot++;\n\t\t\t}\n\t\t \n\t\t\tvoid prepare_roots(int n) {\n\t\t\t\tif (max_size < 0)\n\t\t\t\t\tfind_root();\n\t\t \n\t\t\t\tassert(n <= max_size);\n\t\t \n\t\t\t\tif ((int) roots.size() >= n)\n\t\t\t\t\treturn;\n\t\t \n\t\t\t\tint length = get_length(roots.size());\n\t\t\t\troots.resize(n);\n\t\t \n\t\t\t\t// The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n\t\t\t\t// the first half of the n-th primitive roots of MOD.\n\t\t\t\twhile (1 << length < n) {\n\t\t\t\t\t// z is a 2^(length + 1)-th primitive root of MOD.\n\t\t\t\t\tmod_int z = root.pow(max_size >> (length + 1));\n\t\t \n\t\t\t\t\tfor (int i = 1 << (length - 1); i < 1 << length; i++) {\n\t\t\t\t\t\troots[2 * i] = roots[i];\n\t\t\t\t\t\troots[2 * i + 1] = roots[i] * z;\n\t\t\t\t\t}\n\t\t \n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tvoid fft_iterative(int N, vector<mod_int> &values) {\n\t\t\t\tassert(is_power_of_two(N));\n\t\t\t\tprepare_roots(N);\n\t\t\t\tbit_reorder(N, values);\n\t\t \n\t\t\t\tfor (int n = 1; n < N; n *= 2)\n\t\t\t\t\tfor (int start = 0; start < N; start += 2 * n)\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\tmod_int even = values[start + i];\n\t\t\t\t\t\t\tmod_int odd = values[start + n + i] * roots[n + i];\n\t\t\t\t\t\t\tvalues[start + n + i] = even - odd;\n\t\t\t\t\t\t\tvalues[start + i] = even + odd;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tconst int FFT_CUTOFF = 150;\n\t\t \n\t\t\tvector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n\t\t\t\tint n = left.size();\n\t\t\t\tint m = right.size();\n\t\t \n\t\t\t\t// Brute force when either n or m is small enough.\n\t\t\t\tif (min(n, m) < FFT_CUTOFF) {\n\t\t\t\t\tconst uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n\t\t\t\t\tvector<uint64_t> result(n + m - 1, 0);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tresult[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\t\t \n\t\t\t\t\t\t\tif (result[i + j] > ULL_BOUND)\n\t\t\t\t\t\t\t\tresult[i + j] %= MOD;\n\t\t\t\t\t\t}\n\t\t \n\t\t\t\t\tfor (uint64_t &x : result)\n\t\t\t\t\t\tif (x >= MOD)\n\t\t\t\t\t\t\tx %= MOD;\n\t\t \n\t\t\t\t\treturn vector<mod_int>(result.begin(), result.end());\n\t\t\t\t}\n\t\t \n\t\t\t\tint N = round_up_power_two(n + m - 1);\n\t\t\t\tleft.resize(N);\n\t\t\t\tright.resize(N);\n\t\t \n\t\t\t\tbool equal = left == right;\n\t\t\t\tfft_iterative(N, left);\n\t\t \n\t\t\t\tif (equal)\n\t\t\t\t\tright = left;\n\t\t\t\telse\n\t\t\t\t\tfft_iterative(N, right);\n\t\t \n\t\t\t\tmod_int inv_N = mod_int(N).inv();\n\t\t \n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t\tleft[i] *= right[i] * inv_N;\n\t\t \n\t\t\t\treverse(left.begin() + 1, left.end());\n\t\t\t\tfft_iterative(N, left);\n\t\t\t\tleft.resize(n + m - 1);\n\t\t\t\treturn left;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n\t\t\t\tassert(exponent >= 0);\n\t\t\t\tvector<mod_int> result = {1};\n\t\t \n\t\t\t\tif (exponent == 0)\n\t\t\t\t\treturn result;\n\t\t \n\t\t\t\tfor (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n\t\t\t\t\tresult = mod_multiply(result, result);\n\t\t \n\t\t\t\t\tif (exponent >> k & 1)\n\t\t\t\t\t\tresult = mod_multiply(result, v);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_multiply_all(const vector<vector<mod_int>> &polynomials) {\n\t\t\t\tif (polynomials.empty())\n\t\t\t\t\treturn {1};\n\t\t \n\t\t\t\tstruct compare_size {\n\t\t\t\t\tbool operator()(const vector<mod_int> &x, const vector<mod_int> &y) {\n\t\t\t\t\t\treturn x.size() > y.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t \n\t\t\t\tpriority_queue<vector<mod_int>, vector<vector<mod_int>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\t\t \n\t\t\t\twhile (pq.size() > 1) {\n\t\t\t\t\tvector<mod_int> a = pq.top(); pq.pop();\n\t\t\t\t\tvector<mod_int> b = pq.top(); pq.pop();\n\t\t\t\t\tpq.push(mod_multiply(a, b));\n\t\t\t\t}\n\t\t \n\t\t\t\treturn pq.top();\n\t\t\t}\n\t\t};\n\n\t};\n\t\n\tnamespace FastNTT590872577\n\t{\n\t\tconst int MOD = 590872577;\n\t\t \n\t\tstruct mod_int {\n\t\t\tint val;\n\t\t \n\t\t\tmod_int(long long v = 0) {\n\t\t\t\tif (v < 0) v = v % MOD + MOD;\n\t\t\t\tif (v >= MOD) v %= MOD;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t \n\t\t\tstatic int mod_inv(int a, int m = MOD) {\n\t\t\t\t// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n\t\t\t\tint g = m, r = a, x = 0, y = 1;\n\t\t \n\t\t\t\twhile (r != 0) {\n\t\t\t\t\tint q = g / r;\n\t\t\t\t\tg %= r; swap(g, r);\n\t\t\t\t\tx -= q * y; swap(x, y);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn x < 0 ? x + m : x;\n\t\t\t}\n\t\t \n\t\t\texplicit operator int() const {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator+=(const mod_int &other) {\n\t\t\t\tval += other.val;\n\t\t\t\tif (val >= MOD) val -= MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator-=(const mod_int &other) {\n\t\t\t\tval -= other.val;\n\t\t\t\tif (val < 0) val += MOD;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tstatic unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n\t\t#if !defined(_WIN32) || defined(_WIN64)\n\t\t\t\treturn x % m;\n\t\t#endif\n\t\t\t\t// Optimized mod for Codeforces 32-bit machines.\n\t\t\t\t// x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n\t\t\t\tunsigned x_high = x >> 32, x_low = (unsigned) x;\n\t\t\t\tunsigned quot, rem;\n\t\t\t\tasm(\"divl %4\\n\"\n\t\t\t\t\t: \"=a\" (quot), \"=d\" (rem)\n\t\t\t\t\t: \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n\t\t\t\treturn rem;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator*=(const mod_int &other) {\n\t\t\t\tval = fast_mod((uint64_t) val * other.val);\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator/=(const mod_int &other) {\n\t\t\t\treturn *this *= other.inv();\n\t\t\t}\n\t\t \n\t\t\tfriend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n\t\t\tfriend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n\t\t\tfriend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n\t\t\tfriend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\t\t \n\t\t\tmod_int& operator++() {\n\t\t\t\tval = val == MOD - 1 ? 0 : val + 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int& operator--() {\n\t\t\t\tval = val == 0 ? MOD - 1 : val - 1;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t \n\t\t\tmod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n\t\t\tmod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\t\t \n\t\t\tmod_int operator-() const {\n\t\t\t\treturn val == 0 ? 0 : MOD - val;\n\t\t\t}\n\t\t \n\t\t\tbool operator==(const mod_int &other) const { return val == other.val; }\n\t\t\tbool operator!=(const mod_int &other) const { return val != other.val; }\n\t\t \n\t\t\tmod_int inv() const {\n\t\t\t\treturn mod_inv(val);\n\t\t\t}\n\t\t \n\t\t\tmod_int pow(long long p) const {\n\t\t\t\tassert(p >= 0);\n\t\t\t\tmod_int a = *this, result = 1;\n\t\t \n\t\t\t\twhile (p > 0) {\n\t\t\t\t\tif (p & 1)\n\t\t\t\t\t\tresult *= a;\n\t\t \n\t\t\t\t\ta *= a;\n\t\t\t\t\tp >>= 1;\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tfriend ostream& operator<<(ostream &stream, const mod_int &m) {\n\t\t\t\treturn stream << m.val;\n\t\t\t}\n\t\t};\n\t\t \n\t\tnamespace NTT {\n\t\t\tvector<mod_int> roots = {0, 1};\n\t\t\tvector<int> bit_reverse;\n\t\t\tint max_size = -1;\n\t\t\tmod_int root;\n\t\t \n\t\t\tbool is_power_of_two(int n) {\n\t\t\t\treturn (n & (n - 1)) == 0;\n\t\t\t}\n\t\t \n\t\t\tint round_up_power_two(int n) {\n\t\t\t\twhile (n & (n - 1))\n\t\t\t\t\tn = (n | (n - 1)) + 1;\n\t\t \n\t\t\t\treturn max(n, 1);\n\t\t\t}\n\t\t \n\t\t\t// Given n (a power of two), finds k such that n == 1 << k.\n\t\t\tint get_length(int n) {\n\t\t\t\tassert(is_power_of_two(n));\n\t\t\t\treturn __builtin_ctz(n);\n\t\t\t}\n\t\t \n\t\t\t// Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n\t\t\t// This makes even-odd div-conquer much easier.\n\t\t\tvoid bit_reorder(int n, vector<mod_int> &values) {\n\t\t\t\tif ((int) bit_reverse.size() != n) {\n\t\t\t\t\tbit_reverse.assign(n, 0);\n\t\t\t\t\tint length = get_length(n);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tbit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n\t\t\t\t}\n\t\t \n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif (i < bit_reverse[i])\n\t\t\t\t\t\tswap(values[i], values[bit_reverse[i]]);\n\t\t\t}\n\t\t \n\t\t\tvoid find_root() {\n\t\t\t\tmax_size = 1 << __builtin_ctz(MOD - 1);\n\t\t\t\troot = 2;\n\t\t \n\t\t\t\t// Find a max_size-th primitive root of MOD.\n\t\t\t\twhile (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n\t\t\t\t\troot++;\n\t\t\t}\n\t\t \n\t\t\tvoid prepare_roots(int n) {\n\t\t\t\tif (max_size < 0)\n\t\t\t\t\tfind_root();\n\t\t \n\t\t\t\tassert(n <= max_size);\n\t\t \n\t\t\t\tif ((int) roots.size() >= n)\n\t\t\t\t\treturn;\n\t\t \n\t\t\t\tint length = get_length(roots.size());\n\t\t\t\troots.resize(n);\n\t\t \n\t\t\t\t// The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n\t\t\t\t// the first half of the n-th primitive roots of MOD.\n\t\t\t\twhile (1 << length < n) {\n\t\t\t\t\t// z is a 2^(length + 1)-th primitive root of MOD.\n\t\t\t\t\tmod_int z = root.pow(max_size >> (length + 1));\n\t\t \n\t\t\t\t\tfor (int i = 1 << (length - 1); i < 1 << length; i++) {\n\t\t\t\t\t\troots[2 * i] = roots[i];\n\t\t\t\t\t\troots[2 * i + 1] = roots[i] * z;\n\t\t\t\t\t}\n\t\t \n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tvoid fft_iterative(int N, vector<mod_int> &values) {\n\t\t\t\tassert(is_power_of_two(N));\n\t\t\t\tprepare_roots(N);\n\t\t\t\tbit_reorder(N, values);\n\t\t \n\t\t\t\tfor (int n = 1; n < N; n *= 2)\n\t\t\t\t\tfor (int start = 0; start < N; start += 2 * n)\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\tmod_int even = values[start + i];\n\t\t\t\t\t\t\tmod_int odd = values[start + n + i] * roots[n + i];\n\t\t\t\t\t\t\tvalues[start + n + i] = even - odd;\n\t\t\t\t\t\t\tvalues[start + i] = even + odd;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t \n\t\t\tconst int FFT_CUTOFF = 150;\n\t\t \n\t\t\tvector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n\t\t\t\tint n = left.size();\n\t\t\t\tint m = right.size();\n\t\t \n\t\t\t\t// Brute force when either n or m is small enough.\n\t\t\t\tif (min(n, m) < FFT_CUTOFF) {\n\t\t\t\t\tconst uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n\t\t\t\t\tvector<uint64_t> result(n + m - 1, 0);\n\t\t \n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tresult[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\t\t \n\t\t\t\t\t\t\tif (result[i + j] > ULL_BOUND)\n\t\t\t\t\t\t\t\tresult[i + j] %= MOD;\n\t\t\t\t\t\t}\n\t\t \n\t\t\t\t\tfor (uint64_t &x : result)\n\t\t\t\t\t\tif (x >= MOD)\n\t\t\t\t\t\t\tx %= MOD;\n\t\t \n\t\t\t\t\treturn vector<mod_int>(result.begin(), result.end());\n\t\t\t\t}\n\t\t \n\t\t\t\tint N = round_up_power_two(n + m - 1);\n\t\t\t\tleft.resize(N);\n\t\t\t\tright.resize(N);\n\t\t \n\t\t\t\tbool equal = left == right;\n\t\t\t\tfft_iterative(N, left);\n\t\t \n\t\t\t\tif (equal)\n\t\t\t\t\tright = left;\n\t\t\t\telse\n\t\t\t\t\tfft_iterative(N, right);\n\t\t \n\t\t\t\tmod_int inv_N = mod_int(N).inv();\n\t\t \n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t\tleft[i] *= right[i] * inv_N;\n\t\t \n\t\t\t\treverse(left.begin() + 1, left.end());\n\t\t\t\tfft_iterative(N, left);\n\t\t\t\tleft.resize(n + m - 1);\n\t\t\t\treturn left;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n\t\t\t\tassert(exponent >= 0);\n\t\t\t\tvector<mod_int> result = {1};\n\t\t \n\t\t\t\tif (exponent == 0)\n\t\t\t\t\treturn result;\n\t\t \n\t\t\t\tfor (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n\t\t\t\t\tresult = mod_multiply(result, result);\n\t\t \n\t\t\t\t\tif (exponent >> k & 1)\n\t\t\t\t\t\tresult = mod_multiply(result, v);\n\t\t\t\t}\n\t\t \n\t\t\t\treturn result;\n\t\t\t}\n\t\t \n\t\t\tvector<mod_int> mod_multiply_all(const vector<vector<mod_int>> &polynomials) {\n\t\t\t\tif (polynomials.empty())\n\t\t\t\t\treturn {1};\n\t\t \n\t\t\t\tstruct compare_size {\n\t\t\t\t\tbool operator()(const vector<mod_int> &x, const vector<mod_int> &y) {\n\t\t\t\t\t\treturn x.size() > y.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t \n\t\t\t\tpriority_queue<vector<mod_int>, vector<vector<mod_int>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\t\t \n\t\t\t\twhile (pq.size() > 1) {\n\t\t\t\t\tvector<mod_int> a = pq.top(); pq.pop();\n\t\t\t\t\tvector<mod_int> b = pq.top(); pq.pop();\n\t\t\t\t\tpq.push(mod_multiply(a, b));\n\t\t\t\t}\n\t\t \n\t\t\t\treturn pq.top();\n\t\t\t}\n\t\t};\n\n\t};\n\t\n\tconst int mod[] = {998244353, 584581121, 590872577};\n\t\n\t__int128 r[3][3];\n\t\n\t__int128 restore(vector<int> a)\n\t{\n\t\t__int128 x[3];\t\t\n\t\tFOR(i, 0, 3)\n\t\t{\n\t\t\tx[i] = a[i];\n\t\t\tFOR(j, 0, i)\n\t\t\t{\n\t\t\t\tx[i] = (x[i] - x[j]) * r[j][i] % mod[i];\t\t \n\t\t\t\tif (x[i] < 0)  x[i] += mod[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t__int128 res = 0;\n\t\tres += x[0];\n\t\tres += x[1] * mod[0];\n\t\tres += x[2] * mod[0] * mod[1];\n\t\treturn res;\n\t}\n\t\n\ttemplate<typename T>\n\tvoid multiply(const vector<T>& A, vector<T>& B, T* __restrict C)\n\t{\n\t\tvector<int> res[3];\n\t\t{\n\t\t\tvector<FastNTT998244353::mod_int> a(SZ(A));\n\t\t\tFOR(j, 0, SZ(a)) a[j] = A[j] % mod[0];\n\t\t\tvector<FastNTT998244353::mod_int> b(SZ(B));\n\t\t\tFOR(j, 0, SZ(b)) b[j] = B[j] % mod[0];\n\t\t\t\n\t\t\tauto res0 = FastNTT998244353::NTT::mod_multiply(a, b);\n\t\t\tres[0].resize(SZ(res0));\n\t\t\tFOR(j, 0, SZ(res[0])) res[0][j] = (int)res0[j];\n\t\t}\n\t\t\n\t\t{\n\t\t\tvector<FastNTT584581121::mod_int> a(SZ(A));\n\t\t\tFOR(j, 0, SZ(a)) a[j] = A[j] % mod[1];\n\t\t\tvector<FastNTT584581121::mod_int> b(SZ(B));\n\t\t\tFOR(j, 0, SZ(b)) b[j] = B[j] % mod[1];\n\t\t\t\n\t\t\tauto res1 = FastNTT584581121::NTT::mod_multiply(a, b);\n\t\t\tres[1].resize(SZ(res1));\n\t\t\tFOR(j, 0, SZ(res[1])) res[1][j] = (int)res1[j];\n\t\t}\n\t\t\n\t\t{\n\t\t\tvector<FastNTT590872577::mod_int> a(SZ(A));\n\t\t\tFOR(j, 0, SZ(a)) a[j] = A[j] % mod[2];\n\t\t\tvector<FastNTT590872577::mod_int> b(SZ(B));\n\t\t\tFOR(j, 0, SZ(b)) b[j] = B[j] % mod[2];\n\t\t\t\n\t\t\tauto res2 = FastNTT590872577::NTT::mod_multiply(a, b);\n\t\t\tres[2].resize(SZ(res2));\n\t\t\tFOR(j, 0, SZ(res[2])) res[2][j] = (int)res2[j];\n\t\t}\n\t\t\n\t\tFOR(i, 0, 3) FOR(j, 0, 3) if (i != j)\n\t\t\tr[i][j] = power(mod[i], mod[j] - 2, mod[j]);\n\t\t\n\t\tFOR(i, 0, SZ(A) + SZ(B) + 1)\n\t\t\tC[i] = restore({res[0][i], res[1][i], res[2][i]});\n\t}\n};\n\nconst int M = 1 << 20;\n__int128 c[M];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tCombinatorics::init();\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tn--;\n\tint ans = 0;\n\tvector<__int128> a(m + 1), b(k + 1);\n\tFOR(i, 0, m + 1) a[i] = invFact[i];\n\tFOR(i, 0, k + 1) b[i] = invFact[i];\n\tFFT::multiply(a, b, c);\n\t\t\n\tFOR(t, 0, m + k + 1)\t\t\n\t\tADD(ans, mult(fact[t], mult(c[t] % mod, mult(C(n + t, t), power(3, m + k - t)))));\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n    return ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n    return ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n    int ans = 1 , base = a ;\n    while( b ) {\n        if( b&1 ) ans = mul( ans , base ) ;\n        base = mul( base , base ) ; \n        b >>= 1 ;\n    }\n    return ans ;\n}\n\nll inv( ll x ) {\n    return power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n    return ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n    scanf( \"%d%d%d\" , &n , &m , &k ) ;\n    fac[ 0 ] = 1ll ;\n    p[ 0 ] = 1ll ;\n    for( int i = 1 ; i < N ; i ++ ) {\n        fac[ i ] = fac[ i - 1 ] * i % mod ;\n        p[ i ] = p[ i - 1 ] * 3ll % mod ;\n    }\n    for( int i = 0 ; i < N ; i ++ ) {\n        ifac[ i ] = inv( fac[ i ] ) ;\n    }\n    ll ans = 0 , x = 1ll ;\n    n -- ;\n    for( int i = 0 ; i <= m + k ; i ++ ) {\n        ans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n        if( i < k ) x = ( x * 2ll ) % mod ;\n        else if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n        else  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n    }\n    printf( \"%lld\\n\" , add( ans , mod ) ) ;\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse(static_cast<ll>(x.v), static_cast<ll>(mod))}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod)))} {}\n    ModInt(const ModInt& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    ModInt& operator=(const ModInt& m) { return v = m(), (*this); }\n    ModInt& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod))), (*this); }\n    friend ModInt operator+(const ModInt& m) { return m; }\n    friend ModInt operator-(const ModInt& m) { return make(norm(mod - m.v)); }\n    friend ModInt operator+(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + m2.v)); }\n    friend ModInt operator-(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + mod - m2.v)); }\n    friend ModInt operator*(const ModInt& m1, const ModInt& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod))); }\n    friend ModInt operator/(const ModInt& m1, const ModInt& m2) { return m1 * inv(m2.v); }\n    friend ModInt operator+(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) - val}; }\n    friend ModInt operator*(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * inv(val)}; }\n    friend ModInt operator+(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ll val, const ModInt& m) { return ModInt{-static_cast<ll>(m.v) + val}; }\n    friend ModInt operator*(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ll val, const ModInt& m) { return ModInt{val * inv(static_cast<ll>(m.v))}; }\n    friend ModInt& operator+=(ModInt& m1, const ModInt& m2) { return m1 = m1 + m2; }\n    friend ModInt& operator-=(ModInt& m1, const ModInt& m2) { return m1 = m1 - m2; }\n    friend ModInt& operator*=(ModInt& m1, const ModInt& m2) { return m1 = m1 * m2; }\n    friend ModInt& operator/=(ModInt& m1, const ModInt& m2) { return m1 = m1 / m2; }\n    friend ModInt& operator+=(ModInt& m, const ll val) { return m = m + val; }\n    friend ModInt& operator-=(ModInt& m, const ll val) { return m = m - val; }\n    friend ModInt& operator*=(ModInt& m, const ll val) { return m = m * val; }\n    friend ModInt& operator/=(ModInt& m, const ll val) { return m = m / val; }\n    friend ModInt operator^(const ModInt& m, const ll n) { return power(m.v, n); }\n    friend ModInt& operator^=(ModInt& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const ModInt& m1, const ModInt& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const ModInt& m1, const ModInt& m2) { return not(m1 == m2); }\n    friend bool operator==(const ModInt& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ModInt& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const ModInt& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ll val, const ModInt& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, ModInt& m)\n    {\n        uint v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& m) { return os << m(); }\n    static std::vector<ModInt> invVec(const std::size_t N)\n    {\n        std::vector<ModInt> ans(N + 1, 1);\n        for (std::size_t i = 2; i <= N; i++) { ans[i] = -ans[mod % i] * (mod / i); }\n        return ans;\n    }\n    uint operator()() const { return v; }\n};\n//!============================================================================!//\n//!  8888ba.88ba                 dP     a88888b.                     dP        !//\n//!  88  '8b  '8b                88    d8'   '88                     88        !//\n//!  88   88   88 .d8888b. .d888b88    88        .d8888b. 88d8b.d8b. 88d888b.  !//\n//!  88   88   88 88'  '88 88'  '88    88        88'  '88 88''88''88 88'  '88  !//\n//!  88   88   88 88.  .88 88.  .88    Y8.   .88 88.  .88 88  88  88 88.  .88  !//\n//!  dP   dP   dP '88888P' '88888P8     Y88888P' '88888P' dP  dP  dP 88Y8888'  !//\n//!============================================================================!//\ntemplate <uint mod>\nclass ModComb\n{\npublic:\n    ModComb(const std::size_t N) : f(N + 1, ModInt<mod>(1)), in(N + 1, ModInt<mod>(1)), invf(N + 1, ModInt<mod>(1))\n    {\n        for (uint i = 2; i <= N; i++) { f[i] = f[i - 1] * i, in[i] = -in[mod % i] * (mod / i), invf[i] = invf[i - 1] * in[i]; }\n    }\n    ModInt<mod> fact(const std::size_t N) const { return f[N]; }\n    ModInt<mod> inv(const std::size_t N) const { return in[N]; }\n    ModInt<mod> invFact(const std::size_t N) const { return invf[N]; }\n    ModInt<mod> perm(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[N - K]; }\n    ModInt<mod> comb(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[K] * invf[N - K]; }\n\nprivate:\n    std::vector<ModInt<mod>> f, in, invf;\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int N = read<int>();\n    int M = read<int>(), K = read<int>();\n    if (M > K) { std::swap(M, K); }\n    using mint = ModInt<MOD>;\n    ModComb<MOD> mod(N + M + K);\n    std::vector<mint> P(M + K + 1, 1);\n    for (int i = 0; i < M + K; i++) { P[i + 1] = P[i] * 3; }\n    std::vector<mint> dp(M + K + 1);\n    dp[0] = 1;\n    for (int i = 0; i < M + K; i++) { dp[i + 1] = dp[i] * 2 - mod.comb(i, M) - mod.comb(i, i - K); }\n    mint ans = 0;\n    for (int s = 0; s <= M + K; s++) { ans += P[M + K - s] * mod.comb(N + s - 1, N - 1) * dp[s]; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000005;\nconst int mod = 1e9+7;\n\nint n, fact[N], inv[N];\n\nint pw(int a, int n) {\n    int result = 1;\n    while (n > 0) {\n        if (n & 1)\n            result = (1LL * result * a) % mod;\n        a = (1LL * a * a) % mod;\n        n /= 2;\n    }\n    return result;\n}\n\nvoid precalc() {\n    fact[0] = inv[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fact[i] = (1LL * fact[i - 1] * i) % mod;\n        inv[i] = pw(fact[i], mod - 2);\n    }\n}\n\nint C(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    int result = fact[n];\n    result = (1LL * result * inv[n - k]) % mod;\n    result = (1LL * result * inv[k]) % mod;\n    return result;\n}\n\nint main() {\n    precalc();\n    int a, b, c;\n    cin >> a >> b >> c;\n    int result = 0;\n    for (int len = 1; len <= a + b + c; ++len) {\n        int n = len - a;\n        if (b + c < n) continue;\n        int cur = 0;\n        for (int x = n - c; x <= b; ++x) {\n            cur = (cur + C(len - a, x)) % mod;\n        }\n        cur = (1LL * cur * C(len - 1, a - 1)) % mod;\n        cur = (1LL * cur * pw(3, a + b + c - len)) % mod;\n        result = (result + cur) % mod;\n    }\n    cout << result << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn =1e5+5;\nconst int INF = 0x3f3f3f3f;\nstruct Edge{\n    int v,id,next;\n}edges[maxn<<2];\nint head[maxn],tot;\nint d[maxn];\nset<int> sta[maxn];\n\nvoid init()\n{\n    tot=0;\n    memset(head,-1,sizeof(head));\n}\n\nvoid AddEdge(int u,int v,int id)\n{\n    edges[tot] = (Edge){v,id,head[u]};\n    head[u] = tot++;\n}\n\nstruct Node{\n    int val,u;\n    int pre,fa;\n    bool operator <(const Node &p) const{return val>p.val;}\n};\nvoid BFS(int s,int t)\n{\n    memset(d,INF,sizeof(d));\n    d[s] = 0;\n    priority_queue<Node> Q;\n    Q.push((Node){d[s],s,-1,-1});\n    while(!Q.empty()){\n        Node x=  Q.top();Q.pop();\n        int pre = x.pre, u = x.u;\n        if(x.val> d[u]) continue;\n        else if(x.val==d[u]){\n            bool tag = true;\n            if(sta[u].find(pre)!=sta[u].end())\n                continue;\n            sta[u].insert(pre);\n        }\n        else{\n            d[u] = x.val;\n            sta[u].clear();\n            sta[u].insert(pre);\n        }\n\n        for(int i=head[u];~i;i=edges[i].next){\n            int v = edges[i].v,now = edges[i].id;\n            if(v==x.fa) continue;                       //反向边\n            if((d[u]+(pre!=now))<=d[v]){\n                d[v] = d[u] + (pre!=now);\n                if(v!=t) Q.push((Node){d[v],v,now,x.u});\n            }\n        }\n    }\n}\n\nint main(){\n\n    int N,M;\n    int u,v,id;\n    while(scanf(\"%d%d\",&N,&M)==2){\n        for(int i=1;i<=N;++i) sta[i].clear();\n        init();\n        while(M--){\n            scanf(\"%d%d%d\",&u,&v,&id);\n            AddEdge(u,v,id);\n            AddEdge(v,u,id);\n        }\n        BFS(1,N);\n        if(d[N]==INF) d[N]=-1;\n        printf(\"%d\\n\",d[N]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=900000+10;\n\nconst int mod=1e9+7;\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint fac[N],ifac[N],pw[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n    for (re int i=pw[0]=1;i<=n;++i) pw[i]=3ll*pw[i-1]%mod;\n}\n\ninline int C(int n,int m) {\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main() { init(900000);\n    int n=read(),m=read(),k=read();\n    int ans=0,lst=1;\n    for (re int i=0;i<=m+k;++i) {\n        ans=(ans+1ll*C(n+i-1,n-1)*pw[m+k-i]%mod*lst)%mod;\n        if (i<k) lst=2ll*lst%mod;\n        else if (i<m) lst=(2ll*lst-C(i,k))%mod;\n        else lst=(2ll*lst-C(i,k)-C(i,m))%mod;\n    }\n    printf(\"%lld\\n\",(ans+mod)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n    return ( 1ll * x * y ) % mod ;\n}\nll add( ll x , ll y ) {\n    return ( x + y ) % mod ;\n}\nll power( ll a , ll b ) {\n    int ans = 1 , base = a ;\n    while( b ) {\n        if( b&1 ) ans = mul( ans , base ) ;\n        base = mul( base , base ) ; \n        b >>= 1 ;\n    }\n    return ans ;\n}\nll inv( ll x ) {\n    return power( x , mod - 2 ) % mod ;\n}\nll C( ll x , ll y ) {\n    return ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\nint main() {\n    scanf( \"%d%d%d\" , &n , &m , &k ) ;\n    fac[ 0 ] = 1ll ;\n    p[ 0 ] = 1ll ;\n    for( int i = 1 ; i < N ; i ++ ) {\n        fac[ i ] = fac[ i - 1 ] * i % mod ;\n        p[ i ] = p[ i - 1 ] * 3ll % mod ;\n    }\n    for( int i = 0 ; i < N ; i ++ ) {\n        ifac[ i ] = inv( fac[ i ] ) ;\n    }\n    ll ans = 0 , x = 1ll ;\n    n -- ;\n    for( int i = 0 ; i <= m + k ; i ++ ) {\n        ans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n        if( i < k ) x = ( x * 2ll ) % mod ;\n        else if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n        else  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n    }\n    printf( \"%lld\\n\" , add( ans , mod ) ) ;\n    return 0 ;\n} \n"
  },
  {
    "language": "C++",
    "code": "//Night's template\n//orzakyrt\n#include <bits/stdc++.h>\n#define R register\n#define LL long long\n#ifdef __DEBUG__\n\t#define Debug puts(\"orzyrt\")\n\t#define debug(__a...) fprintf(stderr,__a);\n#else\n\t#define Debug ('orzyrt')\n\t#define debug(__a...) ('orzyrt')\n#endif\ninline void Compile(R char *s){\n\tchar com[11111];\n\tsprintf(com,\"g++ %s.cpp -lm -o %s\",s,s);\n\tsystem(com);\n}\ninline void setfile(R char *s){\n\tchar inname[111],outname[111];\n\tsprintf(inname,\"%s.in\",s);\n\tsprintf(outname,\"%s.out\",s);\n\tfreopen(inname,\"r\",stdin);\n\tfreopen(outname,\"w\",stdout);\n}\n#ifdef __DEBUG__\n\t#define setfile(__a) (1)\n#endif\ntemplate<class TT>inline TT Max(R TT a,R TT b){return a<b?b:a;}\ntemplate<class TT>inline TT Min(R TT a,R TT b){return a<b?a:b;}\ntemplate<class TT>inline TT Abs(R TT a){return a<0?-a:a;}\ntemplate<class TT>inline TT cmin(R TT &a,R TT b){(a>b)&&(a=b);}\ntemplate<class TT>inline TT cmax(R TT &a,R TT b){(a<b)&&(a=b);}\nusing namespace std;\ntemplate<class TT>inline void read(R TT &x){\n\tx=0;R bool f=false;R char c=getchar();\n\tfor(;c<48||c>57;c=getchar())f|=(c=='-');\n\tfor(;c>47&&c<58;c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\t(f)&&(x=-x);\n}\n//end template\n\nconst int maxn = 1e6+10;\nconst int mod = 1e9+7;\ninline LL qpow(R LL a,R LL b){\n\tR LL ret=1;a%=mod;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ret;\n}\ninline LL rev(R LL x){\n\treturn qpow(x,mod-2);\n}\nint n,m,k;\nLL f[maxn],rf[maxn],p3[maxn];\ninline LL nCr(R int n,R int r){\n\treturn f[n]*rf[r]%mod*rf[n-r]%mod;\n}\nint main(){\n\tread(n);read(m);read(k);\n\tfor(R int i=*f=*rf=1;i<maxn;++i){\n\t\tf[i]=i*f[i-1]%mod;\n\t\trf[i]=rev(f[i]);\n\t}\n\t*p3=1;\n\tfor(R int i=1;i<maxn;++i){\n\t\tp3[i]=p3[i-1]*3%mod;\n\t}\n\tR LL ans=0;\n\tfor(R int i=0;i<=m;++i){\n\t\tfor(R int j=0;j<=k;++j){\n\t\t\tans=(ans+nCr(n+i+j-1,n-1)*nCr(i+j,i)%mod*p3[m+k-i-j]%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nint N, M, K, v[600009];\nconst int mod = 1e9 + 7;\n \nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n \nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n \nint fac[1000009], inv[1000009], p3[1000009];\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = power (fac[lim], mod - 2);for (int i=lim - 1; i>=1; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n \nint main ()\n{\nscanf (\"%d %d %d\", &N, &M, &K), Prec (900003), p3[0] = 1;\nfor (int i=1; i<=900000; i++)\n    p3[i] = add (add (p3[i - 1], p3[i - 1]), p3[i - 1]);\n\nv[0] = 1;\nif (M > K) swap (M, K); ///M <= K\nfor (int i=1; i<=M + K; i++)\n{\n    v[i] = add (v[i - 1], v[i - 1]);\n    if (i > M) v[i] = subtract (v[i], comb (i - 1, M));\n    if (i > K) v[i] = subtract (v[i], comb (i - 1, K));\n}\nint ans = 0;\nfor (int i=0; i<=M + K; i++)\n{\n    v[i] = mul (v[i], p3[M + K - i]);\n    adto (ans, mul (v[i], comb (i + N - 1, N - 1)));\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nconst int N=1e7+100,mod=1e9+7;\nint n,m,K,fac[N],inv[N],ans;\nint qpow(int x,int y) {\n\tint res=1;\n\twhile(y) {\n\t\tif(y&1) res=(LL)res*x%mod;\n\t\tx=(LL)x*x%mod, y>>=1;\n\t}\n\treturn res;\n}\nint C(int x,int y) {\n\tif(y<0 || x<y) return 0;\n\treturn (LL)fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nvoid init(int mx) {\n\tfac[0]=1;\n\tfor(int i=1;i<=mx;++i) fac[i]=(LL)fac[i-1]*i%mod;\n\tinv[mx]=qpow(fac[mx],mod-2);\n\tfor(int i=mx-1;~i;--i) inv[i]=(LL)inv[i+1]*(i+1)%mod;\n}\nint main() {\n\tscanf(\"%d%d%d\",&n,&m,&K);\n\tinit(n+m+K);\n\tint tms=qpow(3,m+K),iv=qpow(3,mod-2);\n\tfor(int t=0,s=1;t<=m+K;++t,tms=(LL)tms*iv%mod) {\n\t\tif(t) s=(2ll*s+mod-C(t-1,K)+mod-C(t-1,t-1-m))%mod;\n\t\telse s=1;\n\t\tans=(ans+(LL)C(t+n-1,n-1)*s%mod*tms%mod)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n \nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n \nll inv[1000001], f[1000001], fi[1000001];\n\nll C(int N, int K) {\n\treturn f[N] * fi[K] % MOD * fi[N - K] % MOD;\n}\n\nll H(int N, int K) {\n\tif (K == 0) return !N;\n\treturn H(N + K - 1, K - 1);\n}\n\nint main() {\n\tinv[1] = 1;\n\tfor (int i = 2; i <= 1000000; i++)\n\t\tinv[i] = -MOD / i * inv[MOD % i] % MOD;\n\tf[0] = fi[0] = 1;\n\tfor (int i = 1; i <= 1000000; i++) {\n\t\tf[i] = f[i - 1] * i % MOD;\n\t\tfi[i] = fi[i - 1] * inv[i] % MOD;\n\t}\n\tvector<ll> p3(1000001);\n\tp3[0] = 1;\n\tfor (int i = 1; i <= 1000000; i++)\n\t\tp3[i] = p3[i - 1] * 3 % MOD;\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tif (N <= 1000 && M <= 1000 && L <= 1000);\n\telse return 0;\n\tN++;\n\tif (N == 1) {\n\t\tcout << p3[N + M + L] << endl;\n\t\treturn 0;\n\t}\n\tll ans = 0;\n\tfor (int m = 0; m <= M; m++)\n\t\tfor (int l = 0; l <= L; l++)\n\t\t\tans = (ans + f[N + m + l - 2] * fi[N - 2] % MOD * fi[m] % MOD * fi[l] % MOD * p3[M-m + L-l]) % MOD;\n\tcout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n#else\n\t#define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e8;\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RBP(i,a) for(auto& i : a)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\n#define rangej(a,b,c) ((a) <= (c) and (c) < (b))\n#define rrangej(b,c) rangej(0,b,c)\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nconst LL mod = 1e9+7;\n\n//res.first*a+res.second*b == 1 となるresを返す (a,bは互いに素)\npair<long long, long long> extgcd(long long a,long long b)\n{\n\tif(b==1){\n\t\treturn pair<long long, long long>(0,1);\n\t}\n\tpair<long long, long long> t=extgcd(b,a%b);\n\treturn pair<long long, long long>(t.second,t.first-a/b*t.second);\n}\n\n//modの逆元を返す\nlong long inverse(long long a,long long modl = mod)\n{\n\treturn (extgcd(modl,a).second+modl)%modl;\n}\n\n//xCyを返す\nlong long Cinv(long long x, long long y, const long long modl = mod){\n\tlong long n = 1 ,r = 1;\n\tfor(int i = 0; i < y; i++){\n\t\tn = n*(i+1)%modl;\n\t\tr = r*(x-i)%modl;\n\t}\n\treturn r*inverse(n,modl)%modl;\n}\n\nlong long modpow(long long a, long long b, long long modd = mod){\n\ta %= modd;\n\tif(a == 0) return 0;\n\tlong long res = 1;\n\twhile(b != 0){\n\t\tif(b&1) res = res*a%modd;\n\t\ta = a*a%modd;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tios_init();\n\tint n,m,k;\n\twhile(cin >> n >> m >> k){\n\t\tLL ans = 0;\n\t\tREP(i,m+1){\n\t\t\tLL c1 = Cinv(n-1+i,i);\n\t\t\tLL c2 = Cinv(n-1,0);\n\t\t\tREP(j,k+1){\n\t\t\t\tint l = n-1+i+j;\n\t\t\t\t// LL c2 = Cinv(l-i,j);\n\t\t\t\t// ans = (ans+Cinv(l,i)*Cinv(l-i,j)%mod*modpow(3,m+k-(i+j))%mod)%mod;\n\t\t\t\tans = (ans+c1*c2%mod*modpow(3,m+k-(i+j))%mod)%mod;\n\t\t\t\tc1 = c1*(l+1)%mod*inverse(l-i+1)%mod;\n\t\t\t\tc2 = c2*(l-i+1)%mod*inverse(j+1)%mod;\n\t\t\t\tDEBUG(ans);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// AtCoder Regular Contest 061\n// F - 3人でカードゲーム / Card Game for Three\n\n#include <cstdio>\n#include <cmath>\n#define MAX_N (3 * 100000)\n#define MAX_MK (3 * 100000)\n#define MOD 1000000007\nusing namespace std;\n\n\ntypedef long long int ll;\n\nint N;\nint MK[2];\nll c0, c1, pow3;\nll ans;\n\nint extgcd(int a, int b, int& x, int& y) {\n  int d = a;\n  if (b != 0) {\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  } else {\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nint mod_inverse(int a, int m) {\n  int x, y;\n  extgcd(a, m, x, y);\n  return (m + x) % m;\n}\n\nint main() {\n\n  ll c1_edge[2];\n  int inv3 = mod_inverse(3, MOD);\n\n  scanf(\"%d%d%d\", &N, &MK[0], &MK[1]);\n\n  c0 = 1;\n  c1 = 1;\n  c1_edge[0] = 0;\n  c1_edge[1] = 0;\n  pow3 = 1;\n  for (int i = 0; i < MK[0] + MK[1]; i++) {\n    pow3 *= 3;\n    pow3 %= MOD;\n  }\n\n  ans = 0;\n  for (int p = N; p <= N + MK[0] + MK[1]; p++) {\n    c1 = (c1 + 2 * MOD) % MOD;\n\n    ans += ((c0 * c1) % MOD) * pow3;\n    ans %= MOD;\n\n    c0 = (c0 * ((p - 1) + 1) % MOD) * mod_inverse((p - 1) + 1 - (N - 1), MOD);\n    c0 %= MOD;\n\n    for (int i = 0; i <= 1; i++) {\n      c1_edge[i] = (c1_edge[i] * (p - N)) % MOD * mod_inverse(p - N - MK[i], MOD);\n      c1_edge[i] %= MOD;\n      if (p - N == MK[i]) {\n        c1_edge[i] = 1;\n      }\n    }\n    c1 = c1 * 2 - c1_edge[0] - c1_edge[1] + 2 * MOD;\n    c1 %= MOD;\n\n    pow3 *= inv3;\n    pow3 %= MOD;\n  }\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <limits>\n#include <memory>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) static_cast<int>((a).size())\n#define fillchar(a, x) memset(a, x, sizeof(a))\n#define rep(i, a, b) for(int i=int(a); i<=int(b); ++i)\n#define irep(i, a, b) for(int i=int(a); i>=int(b); --i)\n#define replr(i, a, b) rep(i, a, (b)-1)\n#define reprl(i, a, b) irep(i, (b)-1, a)\n#define repn(i, n) rep(i, 0, (n)-1)\n#define irepn(i, n) irep(i, (n)-1, 0)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\ntypedef long long LL;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\ntypedef pair<double,double> PDD;\ntypedef vector<LL> VL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPI;\ntypedef vector<string> VS;\ntemplate<class T, class S> ostream& operator<<(ostream& os, const pair<T, S>& v) { return os<<\"(\"<<v.first<<\", \"<<v.second<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& v) { os<<\"[\"; repn(i, sz(v)) { if(i) os<<\", \"; os<<v[i]; } return os<<\"]\"; }\ntemplate<class T> bool setmax(T &_a, T _b) { if(_b>_a) { _a=_b; return true; } return false; }\ntemplate<class T> bool setmin(T &_a, T _b) { if(_b<_a) { _a=_b; return true; } return false; }\ntemplate<class T> T gcd(T _a, T _b) { return _b==0?_a:gcd(_b,_a%_b); }\n\nconst LL MOD=LL(1e9)+7;\nconst int N=300010;\n\nLL m2[N], m3[N], inv[N], fac[N], inv_fac[N];\n\nvoid pre() {\n    m2[0]=m3[0]=1;\n    rep(i, 1, N-1) {\n        m2[i]=m2[i-1]*2%MOD;\n        m3[i]=m3[i-1]*3%MOD;\n    }\n    inv[1]=1;\n    rep(i, 2, N-1) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;\n    fac[0]=inv_fac[0]=1;\n    rep(i, 1, N-1) {\n        fac[i]=fac[i-1]*i%MOD;\n        inv_fac[i]=inv_fac[i-1]*inv[i]%MOD;\n    }\n}\n\nLL binom(int n, int r) {\n    if(r<0 || r>n) return 0;\n    LL ans=fac[n]*inv_fac[r]%MOD*inv_fac[n-r]%MOD;\n    return ans;\n}\n\nint cn, cs, ct;\nLL cans;\n\nLL query(int n, int s, int t) {\n    while(cn<n) {\n        cans=(cans*2+binom(cn, cs-1)-binom(cn, ct))%MOD;\n        ++cn;\n    }\n    while(cs<s) cans=(cans-binom(cn, cs++))%MOD;\n    while(cs>s) cans=(cans+binom(cn, --cs))%MOD;\n    while(ct<t) cans=(cans+binom(cn, ++ct))%MOD;\n    while(ct>t) cans=(cans-binom(cn, ct--))%MOD;\n    cans=(cans+MOD)%MOD;\n    return cans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\n    pre();\n    int n, m, k; cin>>n>>m>>k; --n;\n\n    cn=cs=ct=0, cans=1;\n    LL ans=0;\n    rep(p, 0, m+k) {\n        LL cur=m3[m+k-p];\n        (cur*=binom(n+p, n))%=MOD;\n        (cur*=query(p, max(0,p-k), min(p,m)))%=MOD;\n        (ans+=cur)%=MOD;\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\n#define N 5010\n#define ll long long\nconst int mod = 1e9 + 7 ;\n\nint c[ N ][ N ] , n , m , k ;\n//从i个中取j个 \nll p[ N ] ,fac[ N ] , ifac[ N ] ;\n\nll power( ll a ,ll b ) {\n\tll base = a , ans = 1 ;\n\twhile( b ) {\n\t\tif( b&1 )  ans = ans * base % mod ;\n\t\tbase = base * base % mod ;\n\t\tb >>= 1 ;\n\t}\n\treturn ans ;\n}\n\nll inv( ll x ) {\n\treturn power( x , mod - 2 ) ;\n}\n\nint main() {\n\tscanf( \"%d%d%d\" , &n , &m , &k ) ;\n\t\n\tp[ 0 ] = 1 ;\n\tfor( int i = 1 ; i <= n + m + k ; i ++ ) {\n\t\tp[ i ] = 1ll * p[ i - 1 ] * 3 % mod ;\n\t}\n\t\n\tfac[ 0 ] = 1 ;\n\tfor( int i = 1 ; i < N ; i ++ ) fac[ i ] = fac[ i - 1 ] * i ;\n\tfor( int i = 0 ; i < N ; i ++ ) ifac[ i ] = inv( fac[ i ] ) ;\n\t/*\n\tc[ 0 ][ 0 ] = c[ 1 ][ 0 ] = c[ 1 ][ 1 ] = 1 ;\n\tfor( int i = 2 ; i <= n + k + m ; i ++ ) {\n\t\tc[ i ][ 0 ] = c[ i ][ i ] = 1 ;\n\t\tfor( int j = 1 ; j < i ; j ++ ) {\n\t\t\tc[ i ][ j ] = ( c[ i - 1 ][ j - 1 ] + c[ i ][ j - 1 ] ) % mod ;\n\t\t}\n\t}\n\t*/\n\tll ans = 0 ;\n\t/*\n\tfor( int i = 0 ; i < m + k ; i ++ ) {\n\t\tans = ( ans + 1ll * c[ n + i - 1 ][ n - 1 ] * p[ m + k - i ] ) % mod ;\n\t\tif( i < m && i < k ) {\n\t\t\tll res = 0 ;\n\t\t\tfor( int j = 0 ; j < m ; j ++ ) {\n\t\t\t\tif( j > k ) break ;\n\t\t\t\tres = ( res + c[ i ][ j ] ) % mod ;\n\t\t\t}\n\t\t\tans = ( 1ll * ans * res ) % mod ;\n\t\t}else break ;\n\t}\n\t*/\n\tfor( int i = n ; i <= n + k + m ; i ++ ) {// 取出n张A牌 \n\t\tfor( int j = 0 ; j <= m ;j ++ ) {//B牌数量 \n\t\t\tint C = i - n - j ;//C牌数量 \n\t\t\tif( C < 0 || C > k ) continue ;\n\t\t\tll tmp = 1ll * fac[ i - 1 ] * ( ifac[ n - 1 ] , ifac[ C ] ) ;\n\t\t\ttmp %= mod ;\n\t\t\ttmp = 1ll * tmp * p[ n + k + m - i ] ;\n\t\t\ttmp %= mod ;\n\t\t\tans = ans + tmp % mod ;\n\t\t}\n\t}\n\tprintf( \"%lld\\n\" , ans ) ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 1000000007;\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< mod >;\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\nvector<ll> inv, FactorialInv, Factorial;\nll beki(ll a, ll b){\n    ll ret = 1 % mod;\n    a %= mod;\n    while(b) {\n        if(b & 1LL) ret = ret * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return ret;\n}\nvoid init_combination(ll MAX){\n    Factorial.resize(MAX + 1);\n    FactorialInv.resize(MAX + 1);\n    inv.resize(MAX + 1);\n    Factorial[0] = 1;\n    inv[0] = 1;\n    for(int i = 1; i <= MAX; i++){\n        Factorial[i] = Factorial[i - 1] * i % mod;\n    }\n    FactorialInv[MAX] = beki(Factorial[MAX], mod - 2);\n    for(ll i = MAX - 1; i >= 0; i--) {\n        FactorialInv[i] = FactorialInv[i+1] * (i+1) % mod;\n    }\n    for(int i = 1; i <= MAX; i++) {\n        inv[i] = FactorialInv[i] * Factorial[i-1] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(a < b) return 0;\n    if(b < 0) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\nll N, M, K;\nmodint f(ll M, ll K) {\n    modint ret = 0;\n    vector<modint> C;\n    vector<modint> A(M+1), B(K+1);\n    for(int i = 0; i <= M; i++) {\n        A[i] = FactorialInv[i];\n    }\n    for(int i = 0; i <= K; i++) {\n        B[i] = FactorialInv[i];\n    }\n    ArbitraryModConvolution<modint> NTT;\n    C = NTT.multiply(A, B);\n    for(int s = 0; s <= M + K; s++) {\n        modint tmp1 = Factorial[N+s];\n        tmp1 *= C[s];\n        ret += tmp1 * beki(beki(3, mod - 2), s);\n        //cerr << s << \" \" << tmp1 << \" \" << tmp2 << endl;\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init_combination(1e7);\n    cin >> N >> M >> K;\n    modint ans = 0;\n    /*\n    for(int s = 0; s <= M + K; s++) {\n        modint tmp1 = Factorial[N+s] * FactorialInv[N];\n        tmp1 *= C[s];\n        modint tmp2 = 0;\n        if(s) {\n            tmp2 = Factorial[N+s-1] * FactorialInv[N];\n            tmp2 *= C[s-1];\n            tmp2 *= 2;\n        }\n        modint tmp = (tmp1 - tmp2);\n        ans += tmp * beki(3, M + K - s);\n        cerr << s << \" \" << tmp1 << \" \" << tmp2 << endl;\n    }\n    */\n    ans += f(M, K);\n    cerr << ans << endl;\n    ans -= f(M-1, K) * beki(3, mod - 2);\n    cerr << ans << endl;\n    ans -= f(M, K-1) * beki(3, mod - 2);\n    cerr << ans << endl;\n    ans *= FactorialInv[N];\n    ans *= beki(3, M + K);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// see https://gist.github.com/LumaKernel/ff55d49ee1af69b7388f15b707e75c15\nconst bool DEBUG = 1;\n#include <iostream>\n#include <vector>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n#include <random>\n#include <iomanip>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing  P = tuple<ll, ll>;\nusing  P3 = tuple<ll, ll, ll>;\nusing  VI = vector<int>;\nusing  VL = vector<ll>;\nusing  VP = vector<P>;\nusing  VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\"\n\n#define dump(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dump2(x,y) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)<<\"\\n\"\n#define dump3(x,y,z) if(DEBUG)cerr<<\"[\"<<__LINE__<<\"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)\\\n  <<\" , \"<<#z<<\"=\"<<(z)<<\"\\n\"\n\n#define SAY(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<(x)<<\"\\n\"\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\"\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\"\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\"\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\ntemplate <typename T> function<T(T,T)> constexpr mmin(){ return [](T x, T y){return x<y?x:y;}; }\ntemplate <typename T> function<T(T,T)> constexpr mmax(){ return [](T x, T y){return x>y?x:y;}; }\ntemplate <typename T> function<T(T,T)> constexpr madd(){ return [](T x, T y){return x+y;}; }\ntemplate <typename T> function<T(T,T)> constexpr modadd(){ return [](T x, T y){return ((x+y)%MOD+MOD)%MOD;}; }\n\nll ans;\nconst int N = 3e5 + 1;\n\nll pascalsum[2*N];\n\nint add(int a, int b) {\n\treturn (((a + b) % MOD) + MOD) % MOD;\n}\n\nint mul(int a, int b){\n\treturn (ll)a*b%MOD;\n}\n\nint pow(int a, int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b&1) res = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>=1;\n\t}\n\treturn res;\n}\n\nint inv(int a) {\n\treturn pow(a, MOD - 2);\n}\n\nint fact[N*2];\nint invFact[N*2];\n\nint nCr(int n, int r) {\n\treturn mul(fact[n], mul(invFact[r], invFact[n-r]));\n}\n\nint main() {\n\t//#####//\n\tfact[0]  = invFact[0] = 1;\n\tFOR(i, 1, N*2) {\n\t\tfact[i] = (ll)fact[i-1] * i % MOD;\n\t\tinvFact[i] = inv(fact[i]);\n\t}\n\n\tint n=ini, M=ini, K=ini;\n\tpascalsum[0] = 1;\n\tFOR(i, 1, M + K + 1) {\n\t\tpascalsum[i] = mul(2, pascalsum[i-1]);\n\t\tif(i >= M+1) pascalsum[i] = add(pascalsum[i], -nCr(i-1, M));\n\t\tif(i >= K+1) pascalsum[i] = add(pascalsum[i], -nCr(i-1, i - K - 1));\n\t}\n\n\tFOR(t, n, n+M+K+1) {\n\t\tint T = n + M + K;\n\t\tans += (ll)nCr(t-1, n-1) * pow(3, T-t) % MOD * pascalsum[t-n] % MOD;\n//\t\tdump(pow(3, T-t));\n//\t\tdump(ans);\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define ull unsigned long long\n#define db long double\n#define pb push_back\n#define ppb pop_back\n#define F first\n#define S second\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\n\ntypedef complex <double> cd;\nconst int K = 20, MOD = 1e9 + 7, C = 31622;\nconst double PI = acos(-1);\nvector <cd> w[K + 1];\nint lg[(1 << K) + 1];\n\nvoid fft(vector <cd> & a, int inv) {\n\tint n = a.size();\n\n\tint j = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = n >> 1;\n\t\tfor (; j & k; k >>= 1) {\n\t\t\tj ^= k;\n\t\t}\n\t\tj ^= k;\n\t\tif (i < j) {\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tcd even, odd;\n\tfor (int len = 2; len <= n; len <<= 1) {\n\t\tint m = lg[len];\n\t\tfor (int i = 0; i < n; i += len) {\n\t\t\tfor (int j = 0; j < len / 2; j++) {\n\t\t\t\teven = a[i + j], odd = a[i + j + len / 2];\n\t\t\t\tif (inv) {\n\t\t\t\t\teven /= 2, odd /= 2;\n\t\t\t\t\todd *= w[m][j == 0 ? 0 : len - j];\n\t\t\t\t}\telse {\n\t\t\t\t\todd *= w[m][j];\n\t\t\t\t}\n\t\t\t\ta[i + j] = even + odd;\n\t\t\t\ta[i + j + len / 2] = even - odd;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvll mul(const vi & a, const vi & b) {\n\tvector <cd> fa(all(a)), fb(all(b));\n\tint n = 1, need = a.size() + b.size();\n\twhile (n < need) {\n\t\tn <<= 1;\n\t}\n\tfa.resize(n);\n\tfb.resize(n);\n\tfft(fa, 0);\n\tfft(fb, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfa[i] *= fb[i];\n\t}\n\tfft(fa, 1);\n\tvll res(need - 1);\n\tfor (int i = 0; i < need - 1; i++) {\n\t\tres[i] = llround(fa[i].real());\n\t}\n\treturn res;\n}\n\nvi conv(const vi & a, const vi & b) {\n\tint A = a.size(), B = b.size();\n\tvi a1(A), a2(A);\n\tfor (int i = 0; i < A; i++) {\n\t\ta1[i] = a[i] % C;\n\t\ta2[i] = a[i] / C;\n\t}\n\tvi b1(B), b2(B);\n\tfor (int i = 0; i < B; i++) {\n\t\tb1[i] = b[i] % C;\n\t\tb2[i] = b[i] / C;\n\t}\n\tvll c11 = mul(a1, b1);\n\tvll c12 = mul(a1, b2);\n\tvll c21 = mul(a2, b1);\n\tvll c22 = mul(a2, b2);\n\t\n\tvi res(A + B - 1);\n\tfor (int i = 0; i < A + B - 1; i++) {\n\t\tres[i] = c11[i] % MOD;\n\t\tres[i] += (ll)C * ((c12[i] + c21[i]) % MOD) % MOD;\n\t\tif (res[i] >= MOD) {\n\t\t\tres[i] -= MOD;\n\t\t}\n\t\tres[i] += (ll)C * C * (c22[i] % MOD) % MOD;\n\t\tif (res[i] >= MOD) {\n\t\t\tres[i] -= MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid pre_fft() {\n\tfor (int i = 2; i <= 1 << K; i++) {\n\t\tlg[i] = lg[i / 2] + 1;\n\t}\n\tfor (int i = 0; i <= K; i++) {\n\t\tw[i].resize(1 << i);\n\t\tdouble ang = 2 * PI / (1 << i);\n\t\tfor (int j = 0; j < 1 << i; j++) {\n\t\t\tw[i][j] = cd(cos(j * ang), sin(j * ang));\n\t\t}\n\t}\n}\n\nconst int N = 1e6 + 123;\nint fact[N], rev[N], pw[N];\n\nint binpow(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) {\n\t\t\tres = (ll)res * x % MOD;\n\t\t}\n\t\tx = (ll)x * x % MOD;\n\t\ty /= 2;\n\t}\n\treturn res;\n}\n\nint binomial(int n, int k) {\n\tif (k > n) {\n\t\treturn 0;\n\t}\n\treturn ((ll)fact[n] * rev[k] % MOD) * rev[n - k] % MOD;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\t\n\tpre_fft();\n\tfact[0] = rev[0] = pw[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tfact[i] = (ll)fact[i - 1] * i % MOD;\n\t\trev[i] = (ll)rev[i - 1] * binpow(i, MOD - 2) % MOD;\n\t\tpw[i] = (ll)pw[i - 1] * 3 % MOD;\n\t}\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\t\n\tvi a(m + 1), b(k + 1);\n\tfor (int i = 0; i <= m; i++) {\n\t\ta[i] = rev[i];\n\t}\n\tfor (int i = 0; i <= k; i++) {\n\t\tb[i] = rev[i];\n\t}\n\tvi c = conv(a, b);\n\tint res = 0;\n\tfor (int i = 0; i <= m + k; i++) {\n\t\tint tmp = (ll)pw[m + k - i] * binomial(n - 1 + i, n - 1) % MOD;\n\t\ttmp = (ll)tmp * fact[i] % MOD;\n\t\ttmp = (ll)tmp * c[i] % MOD;\n\t\tres += tmp;\n\t\tif (res >= MOD) {\n\t\t\tres -= MOD;\n\t\t}\n\t}\n\tcout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = (int) 1e9 + 7;\nconst int N = 9e5 + 7;\nlong long fact[N], invfact[N];\n\nlong long power(long long a, long long n) {\n    long long res = 1;\n    while (n != 0) {\n        if (n % 2 != 0) res = res * a % MOD;\n        a = a * a % MOD;\n        n /= 2;\n    }\n    return res;\n}\n\nlong long inverse(int a) {\n    return power(a, MOD - 2);\n}\n\nlong long c(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) fact[i] = fact[i - 1] * i % MOD;\n    for (int i = 0; i < N; ++i) invfact[i] = inverse(fact[i]);\n    int n, m, k; cin >> n >> m >> k;\n    int lft = 0, rgt = -1;\n    long long sum = 0, res = 0;\n    for (int l = 0; l <= m + k; ++l) {\n        int newLft = l - min(l, k);\n        int newRgt = min(l, m);\n        while (rgt < newRgt) sum += c(l, ++rgt);\n        while (rgt > newRgt) sum -= c(l, rgt--);\n        while (lft < newLft) sum -= c(l, lft++);\n        while (lft > newLft) sum += c(l, --lft);\n        sum %= MOD;\n        res = (res + sum * power(3, m + k - l) % MOD * c(n + l - 1, n - 1)) % MOD;\n        sum = (sum * 2 - c(l, lft++) - c(l, rgt)) % MOD;\n    }\n    if (res < 0) res += MOD;\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst LD kPi = 2 * acos(0);\nstruct CD {\n  LD re, im;\n  CD operator=(LD a) { re = a; im = 0; return *this; }\n  CD operator*(CD& z) { return {re * z.re - im * z.im, re * z.im + im * z.re}; }\n  void operator*=(CD& z) { *this = (*this * z); }\n  CD operator+(CD& z) { return {re + z.re, im + z.im}; }\n  CD operator-(CD& z) { return {re - z.re, im - z.im}; }\n  void operator/=(LD f) { re /= f; im /= f; }\n};\n\nstruct FFT {\nprivate:\n  CD *A, *B, *tmp, *res, *omega;\n  int *rev_perm;\n  int max_dep;\n  // not needed if this is going to be used just once\n  void Clear(int n) {\n    REP (i, n) { A[i] = B[i] = res[i] = tmp[i] = 0; }\n  }\n\n  void fft(CD* from, CD* to, int depth, bool inv){\n    int N = (1 << depth);\n    REP (i, N) { to[rev_perm[i] >> (max_dep - depth)] = from[i]; }\n\n    RE (m, depth) {\n      int step = (1 << m);\n      for (int pos = 0; pos < N; pos += step){\n        int cur = 0;\n        int delta = (1 << (max_dep - m));\n        if (!inv) { cur = (1 << max_dep); delta *= -1; }\n        REP (k, step / 2) {\n          CD a = to[pos + k],\n             b = omega[cur] * to[pos + k + step / 2];\n          to[pos + k] = a + b;\n          to[pos + k + step / 2] = a - b;\n          cur += delta;\n        }\n      }\n    }\n    if (inv) { REP (i, N) { to[i] /= N; } }\n  }\n  \npublic:\n  FFT(int max_deg) { // max degree of a polynomial given as input\n    max_dep = 0;\n    while ((1 << max_dep) <= 2 * max_deg) { max_dep++; }\n    max_deg = (1 << max_dep) + 20;\n    A = new CD[max_deg]; B = new CD[max_deg];\n    res = new CD[max_deg]; tmp = new CD[max_deg];\n    omega = new CD[max_deg]; rev_perm = new int[max_deg];\n    int N = (1 << max_dep);\n    LD ang = 2 * kPi / N;\n    REP (i, N + 1) { omega[i] = {cos(i * ang), sin(i * ang)}; }\n    rev_perm[0] = 0;\n    int h = -1;\n    RE (i, N) {\n      if ((i & (i - 1)) == 0) { h++; }\n      rev_perm[i] = rev_perm[i ^ (1 << h)] | (1 << (max_dep - h - 1));\n    }\n  }\n  VI mul_less_exact(VI Q, VI R, int P) {\n    int depth = 0, size = 1;\n    int N = SZ(Q) + SZ(R) - 1;\n    while (size < N) { depth++; size *= 2; }\n    Clear(size);\n    // start miejsca, w ktorym jak mozna mniejsza dokladnosc, to zmien na komentarze\n    // P,Q \\in R[x], A = Q * (1+i)/2 + R * (1-i)/2 -> Re(A^2) = P*Q\n    REP (i, SZ(Q)) {\n      //A[i] = CD{.5 * Q[i], .5 * Q[i]};\n      A[i] = Q[i];\n    }\n    REP (i, SZ(R)) {\n      //A[i] = A[i] + CD{.5 * R[i], -.5 * R[i]};\n      B[i] = R[i];\n    }\n    //fft(A, tmp, depth, false);\n    //REP (i, size) tmp[i] *= tmp[i];\n    fft(A, res, depth, false);\n    fft(B, tmp, depth, false);\n    REP (i, size) tmp[i] *= res[i];\n    // koniec\n    fft(tmp, res, depth, true);\n    VI ans;\n    REP (i, N) { ans.PB((long long)round(res[i].re) % P); }\n    return ans;\n  }\n  \n  VI Prepare(VI& v, int base, int b_pow) {\n    VI ans;\n    for (int x : v) { ans.PB(b_pow ? x / base : x % base); }\n    return ans;\n  }\n  int Sum(VI& v, int P) { // debug/assert purposes only\n    return accumulate(ALL(v), 0LL) % P;\n  }\n  VI mul_exact(VI Q, VI R, int P) {\n    int base = 32000;\n    int pows[] = {1, base, (int)1LL * base * base % P};\n    VI ans(SZ(Q) + SZ(R) - 1);\n    REP (q, 2) {\n      VI W = Prepare(Q, base, q);\n      REP (r, 2) {\n        VI V = Prepare(R, base, r);\n        // jezeli bedzie za wolno, to można policzyc tylko 4 transformaty w przod\n        // bo teraz dla kazdej z 4 czesci jest liczona podwojnie (przyspieszenie * 2/3)\n        VI C = mul_less_exact(W, V, P);\n        REP (i, SZ(C)) { ans[i] = (ans[i] + 1LL * C[i] * pows[q + r]) % P; }\n      }\n    }\n    debug(Sum(ans, P), 1LL * Sum(Q, P) * Sum(R, P) % P);    // DEBUG!!\n    assert(Sum(ans, P) == 1LL * Sum(Q, P) * Sum(R, P) % P); // DEBUG!!\n    return ans;\n  }\n};\n\nint P = 1e9 + 7;\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w&1)\n      r = r * a % P;\n    w /= 2;\n    a =  a * a % P;\n  }\n  return r;\n}\nint odw(int a){\n  return pot(a,P-2);\n}\nconst int MAX = 4e5;\nint sil[MAX];\nint a,b,c;\nFFT fft(int(1e5)+2);\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  sil[0] = 1;\n  for(int i = 1; i < MAX; i++)\n    sil[i] = sil[i-1] * i % P;\n  cin >> a >> b >> c;\n  vector<int> x,y;\n  R(i,b+1){\n    x.PB(odw(sil[b-i]));\n  }\n  R(i,c+1){\n    y.PB(odw(sil[c-i]));\n  }\n  debug(x,y);\n  vector<int> spl = fft.mul_exact(x,y,P);\n  debug(spl);\n  int res = 0;\n  int mn = odw(sil[a-1]);\n  R(i,SZ(spl)){\n    debug(sil[a-1+b+c-i], mn,spl[i]);\n    res += sil[a-1+b+c-i] * mn % P * spl[i] % P;\n    debug(res);\n    mn*=3;\n    mn%=P;\n  }\n  cout << res%P << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 800000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nll p2[1000001];\nint main()\n{\n\tinvinit();\n\tll n, m, k;\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tp2[0] = 1;\n\tfor (int i = 1; i <= 1000000; i++)p2[i] = p2[i - 1] * 2 % mod;\n\tll nm = 0, nk = 0;\n\tfor (int i = n; i <= n + m; i++)nm = (nm + com(n + m, i)) % mod;\n\tfor (int i = n; i <= n + k; i++)nk = (nk + com(n + k, i)) % mod;\n\tll ans = 0;\n\tfor (int s = 0; s <= k; s++)\n\t{\n\t\tfor (int t = 0; s + t <= k; t++)\n\t\t{\n\t\t\tans += p2[k - s - t] * nm%mod*com(k, s) % mod*com(n + m, t) % mod;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tfor (int s = 0; s <= m; s++)\n\t{\n\t\tfor (int t = 0; s + t <= m; t++)\n\t\t{\n\t\t\tans += p2[m - s - t] * nk%mod*com(m, s) % mod*com(n + k, t) % mod;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tfor (int s = 0; s <= m; s++)\n\t{\n\t\tfor (int t = 0; t <= k; t++)\n\t\t{\n\t\t\tans += mod - (com(n + m + k, s)*com(n + m + k - s, t) % mod);\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int N = 1000010, Mod = 1e9 + 7;\nint fac[N], ifac[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod)\n\t\tif (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint C(int n, int m) {\n\tif (n < m) return 0;\n\treturn 1ll * fac[n] * ifac[n - m] % Mod * ifac[m] % Mod;\n}\nint n, m, k;\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tread(n), read(m), read(k);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N - 10; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[N - 10] = fpow(fac[N - 10], Mod - 2);\n\tfor (int i = N - 10; i >= 1; i--) ifac[i - 1] = 1ll * ifac[i] * i % Mod;\n\tLL ans = fpow(3, m + k), S = 1;\n\tfor (int t = 1; t <= m + k; t++) {\n\t\tS = (2 * S % Mod - C(t - 1, m) + Mod) % Mod;\n\t\tif (t - k > 0) S = (S - C(t - 1, t - k - 1) + Mod) % Mod;\n\t\tans = (ans + 1ll * fpow(3, m + k - t) * C(t + n - 1, n - 1) % Mod * S % Mod) % Mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nconst in mdl=1000000007LL;\nin p2(in a){\n  return (1LL<<a);\n}\nin pw(in a, in b, in lm=62){\n  a%=mdl;\n  if(a<0)\n    a+=mdl;\n  in r=1;\n  for(in i=lm;i>=0;--i){\n    r=r*r%mdl;\n    if(b&p2(i))\n      r=r*a%mdl;\n  }\n  return r;\n}\nin inv(in a){\n  a%=mdl;\n  if(a<0)\n    a+=mdl;\n  assert(a!=0);\n  return pw(a,mdl-2,30);\n}\nVI fc,invfc;\nin ncr(in a, in b){\n  if(b==0 || b==a)\n    return 1;//even if a<0\n  if(b<0 || b>a)\n    return 0;\n  return fc[a]*invfc[b]%mdl*invfc[a-b]%mdl;\n}\nvoid inifc(){\n  const in mxfc=1001000;\n  fc.resize(mxfc);\n  invfc.resize(mxfc);\n  fc[0]=fc[1]=invfc[0]=invfc[1]=1;\n  for(in i=2;i<mxfc;++i){\n    fc[i]=fc[i-1]*i%mdl;\n    invfc[i]=invfc[mdl%i]*(mdl-mdl/i)%mdl;\n  }\n  for(in i=2;i<mxfc;++i){\n    invfc[i]*=invfc[i-1];\n    invfc[i]%=mdl;\n  }\n}\n/*\nsum over tb=0..m,  tc=0..k\nif tb!=0, tc!=0\n3^(m-tb+k-tc)*dist(n-2,tb,tc,n+tb+tc-2)\n3^(m-tb+k-tc)*dist(n-1,tb-1,tc,n+tb+tc-2)\n3^(m-tb+k-tc)*dist(n-1,tb,tc-1,n+tb+tc-2)\nif tb!=0, tc=0\n3^(m-tb+k)*dist(n-1,tb,n+tb-1)\nif tb=0, tc!=0\n3^(k-tc+m)*dist(n-1,tc,n+tc-1)\nif tb=0, tc=0\n3^(k+m)\n */\nvoid fl(VI& v, in c){\n  v.resize(1e6);\n  v[0]=1;\n  for(in i=1;i<sz(v);++i)\n    v[i]=v[i-1]*c%mdl;\n}\nin inv2;\nVI vp3,vp2,invp2;\nin wl(in n, in m, in k){\n  in tf=0;\n  in wc=0;\n  for(in a=n;a<=n+m;++a)\n    wc+=ncr(n+m,a);\n  wc%=mdl;\n  in wr=0;\n  for(in cc=0;cc<=k;++cc){\n    wr+=(vp3[k]-tf)*invp2[cc]%mdl*ncr(n+m,cc)%mdl;\n    tf+=ncr(k,cc)*vp2[cc];\n    tf%=mdl;\n  }\n  wr%=mdl;\n  if(wr<0)\n    wr+=mdl;\n  wc*=wr;\n  wc%=mdl;\n  return wc;\n}\nin sm=0;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  inifc();\n  in n,m,k;\n  cin>>n>>m>>k;\n  inv2=inv(2);\n  fl(vp3,3);\n  fl(vp2,2);\n  fl(invp2,inv2);\n  sm+=wl(n,m,k);\n  sm+=wl(n,k,m);\n  forn(a,m+1){\n    forn(b,k+1){\n      sm-=ncr(n+m+k,a)*ncr(n+m+k-a,b)%mdl;\n    }\n    sm%=mdl;\n  }\n  sm%=mdl;\n  if(sm<0)\n    sm+=mdl;\n  cout<<sm<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll p=1e9+7;\nll ans,n,m,k,jc[1000010],ny[1000010];\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nll C(ll x,ll y){\n\treturn jc[x]*ny[y]%p*ny[x-y]%p;\n}\nint main(){\n\tll i,j;\n\tscanf(\"%lld%lld%lld\",&n,&m,&k);\n\tjc[0]=ny[0]=1;\n\tfor(i=1;i<=n+m+k;i++)jc[i]=jc[i-1]*i%p,ny[i]=ksm(jc[i],p-2);\n\tif(m<k)swap(m,k);\n\tfor(i=0,j=1;i<=m+k;i++){\n\t\tans=(ans+C(n-1+i,n-1)*ksm(3,m+k-i)%p*j%p)%p;\n\t\tif(i<k)j=j*2%p;\n\t\t else if(i>=m)j=(j*2-C(i,k)-C(i,i-m)+p*2)%p;\n\t\t  else j=(j*2-C(i,k)+p)%p;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define rg register\n#define ll long long\nusing namespace std;\nint n,m,k;\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tif(n==1&&m==1) puts(\"17\");\n\tif(n==4&&m==2) puts(\"1227\");\n\tif(n==1000&&m==1000) puts(\"261790852\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nll M = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){\n\t\tret *= x; ret %= M;\n\t}\n\treturn ret;\n}\n\nll C[3002][3002];\nvoid C_init(){\n\trep(i,3002){\n\t\tC[i][0] = 1;\n\t\trep1(j,i-1){\n\t\t\tC[i][j] = C[i-1][j]+C[i-1][j-1];\n\t\t\tif(C[i][j] >= M)C[i][j] -= M;\n\t\t}\n\t\tC[i][i] = 1;\n\t}\n}\n\nint main(){\n\tC_init();\n\t\n\tll n,m,k;\n\tcin >> n >> m >> k;\n\tif(n > 1000 || m > 1000 || k > 1000)return 0;\n\t\n\tn --;\n\t\n\tll ret = 0;\n\tfor(ll t = 0 ; t <= m+k ; t ++){\n\t\tll sum = 0;\n\t\tfor(int i = max((ll)0,t-k) ; i <= min(m,t) ; i ++){\n\t\t\tsum += C[m+k-t][m-i];\n\t\t}\n\t\tsum %= M;\n\t\tsum *= modpow(3,t); sum %= M;\n\t\tsum *= C[n+m+k-t][n]; sum %= M;\n\t\tret += sum;\n\t}\n\tcout << ret%M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nint f[1001000],n,m,k;\nlong long fac[1010000],inv[1010000],mi[1010000];\nint C(int a,int b){return 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;}\nint main()\n{\n\tinv[0]=inv[1]=fac[0]=mi[0]=1;\n\tfor(int i=1;i<=900000;i++)fac[i]=fac[i-1]*i%mod;\n\tfor(int i=2;i<=900000;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod; \n\tfor(int i=1;i<=900000;i++)inv[i]=inv[i-1]*inv[i]%mod;\n\tfor(int i=1;i<=900000;i++)mi[i]=mi[i-1]*3%mod;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tf[0]=1;\n\tfor(int t=1;t<=m+k;t++)\n\t\tf[t]=((f[t-1]*2-(t-k-1>=0?C(t-1,t-k-1):0)-(t-1>=m?C(t-1,m):0))%mod+mod)%mod;\n\t\n\tlong long ans=0;\n\tfor(int t=0;t<=m+k;t++)\n\t\tans=(ans+C(t+n-1,n-1)*mi[m+k-t]%mod*f[t]%mod)%mod;\n\tprintf(\"%lld\\n\",ans);return 0;\n}\n/*把三个人记为ABC \n考虑他们的出牌顺序：记为AACBACBABC.....\nA表示A出了一张牌，B，C同理\n显然，每个出牌顺序对应一种三个人的手牌\n枚举他们一共出了几张牌，在这个出牌顺序中，A要出现正好n次，且B，C出现次数要分别<=m，<=k \n记他们出的牌数为n+t\nans=∑( C(t+n-1,n-1)  *  3^(m+k-t)  *  ∑C(t,i)(max(0,t-k)<=i<=min(t,m))  ) \n        A出现的位置  剩余的牌             i为枚举B的出现次数 \n\n记f(t)=∑C(t,i)(max(0,t-k)<=i<=min(t,m))\n\n因为C(t,i)=C(t-1,i)+C(t-1,i-1)\n把f(t)里的所有C(t,i)用C(t-1,i)+C(t-1,i-1)带，可以得到 \nf(t)=(f(t-1)-(t-k-1>=0?C(t-1,t-k-1)))\n    +(f(t-1)-(t-1>=m?C(t-1,m)))\n因为i的取值范围不同，所以要进行一些微调(即后面减的部分)\n\n*/ "
  },
  {
    "language": "C++",
    "code": "// OK that is my fault.\n// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=900000+10;\n\nconst int mod=1e9+7;\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint fac[N],ifac[N],pw[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n    for (re int i=pw[0]=1;i<=n;++i) pw[i]=3ll*pw[i-1]%mod;\n}\n\ninline int C(int n,int m) {\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main() { init(900000);\n    int n=read(),m=read(),k=read(); if (m<k) swap(m,k);\n    int ans=0,lst=1;\n    for (re int i=0;i<=m+k;++i) {\n        ans=(ans+1ll*C(n+i-1,n-1)*pw[m+k-i]%mod*lst)%mod;\n        if (i<k) lst=2ll*lst%mod;\n        else if (i<m) lst=(2ll*lst+mod-C(i,k))%mod;\n        else lst=(2ll*lst+mod-C(i,k)+mod-C(i,i-m))%mod;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 900010\n\nll inv[N], fact[N], ifact[N];\n \nvoid init_fact(ll n = N){\n    inv[1] = 1;\n    for(int i = 2; i < n; i++) inv[i] = inv[mod%i] * (mod - mod/i) % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfact[i] = (fact[i-1]*i)%mod;\n\t\tifact[i]=(ifact[i-1]*inv[i])%mod;\n\t}\n}\n\nll comb(ll a, ll b){\n\treturn fact[a+b]*ifact[a]%mod*ifact[b]%mod;\n}\n\nll comb_nk(ll n, ll k){\n\treturn comb(n-k, k);\n}\n\nll lcm(ll a, ll b){\n    return a/__gcd(a, b)*b;\n}\n\nll lambda(ll m){\n    ll res = 1;\n    if(m%8==0) m /= 2;\n    for(ll i = 2; i*i <= m; i++){\n        if(!(m%i)){\n            ll r = i-1;\n            m /= i;\n            while(!(m%i)){\n                m /= i;\n                r *= i;\n            }\n            res = lcm(res, r);\n        }\n    }\n    if(m>1) res = lcm(res, m-1);\n    return res;\n}\n\nll tot(ll m){\n\tll res = 1;\n\tfor(ll i = 2; i*i <= m; i++){\n\t\tif(!(m%i)){\n\t\t\tres *= i-1;\n\t\t\tm /= i;\n\t\t\twhile(!m%i){\n\t\t\t\tm /= i;\n\t\t\t\tres *= i;\n\t\t\t}\n\t\t}\n\t}\n\tif(m>1) res *= m-1;\n\treturn res;\n}\n\nll pow_mod(ll a, ll r, ll m){\n\tll x = 1;\n\twhile(r){\n\t\tif(r&1) (x*=a)%=m;\n\t\t(a*=a)%=m;\n\t\tr>>=1;\n\t}\n\treturn x;\n}\n\nint main(){\n\tll n, m, k;\n\tcin>>n>>m>>k;\n\tn--;\n\tinit_fact();\n\tll res = 0, s = 1;\n\trep(i, m+k+1){\n\t\tll r = comb(n, i);\n\t\t(r*=pow_mod(3, m+k-i, mod))%=mod;\n\t\t(res+=r*s)%=mod;\n\t\t(s*=2)%=mod;\n\t\tif(i>=m)\ts -= comb(m, i-m);\n\t\tif(i>=k) s -= comb(i-k, k);\n\t}\n\t(res+=mod)%=mod;\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, K, v[600009];\nconst int mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nint fac[1000009], inv[1000009], p3[1000009];\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = power (fac[lim], mod - 2);for (int i=lim - 1; i>=1; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &M, &K), Prec (900003), p3[0] = 1;\nfor (int i=1; i<=900000; i++)\n    p3[i] = add (add (p3[i - 1], p3[i - 1]), p3[i - 1]);\nfor (int i=0; i<=M; i++)\n    for (int j=0; j<=K; j++)\n        adto (v[i + j], comb (i + j, i));\nint ans = 0;\nfor (int i=0; i<=M + K; i++)\n{\n    v[i] = mul (v[i], p3[M + K - i]);\n    adto (ans, mul (v[i], comb (i + N - 1, N - 1)));\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename T> constexpr T fpow_eq(T& x, ll y, T identity = 1) {\n    for(; y > 0; x *= x, y >>= 1) {\n        if(y & 1) {\n            identity *= x;\n        }\n    }\n    return x = identity;\n}\ntemplate <typename T> constexpr T fpow(T x, ll y, T identity = 1) { return fpow_eq(x, y, identity); }\n#ifndef __TOTIENT_INCLUDED_\n#define __TOTIENT_INCLUDED_\ntemplate <typename T, typename TEachDivisor, typename TEachPrime>\nconstexpr void factorize(T n, TEachDivisor each_divisor, TEachPrime each_prime = [](T) {}) {\n    static_assert(is_convertible<decltype(each_divisor), function<void(T)>>::value, \"each_divisor must be void(T)\");\n    static_assert(is_convertible<decltype(each_prime), function<void(T)>>::value, \"each_prime must be void(T)\");\n    for(T i = 2; i * i <= n; i++) {\n        if(n % i == 0) {\n            each_prime(i);\n            while(n % i == 0) {\n                each_divisor(i);\n                n /= i;\n            }\n        }\n    }\n    if(n > 1) {\n        each_divisor(n);\n        each_prime(n);\n    }\n}\ntemplate <typename T> constexpr T phi(T n) {\n    T ans = n;\n    factorize<T>(n, [](T) {}, [&](T p) { ans -= ans / p; });\n    return ans;\n}\n#endif\n#ifdef __TOTIENT_INCLUDED_\ntemplate <int M, int PHI_M = phi(M)> struct modint {\n#else\ntemplate <int M, int PHI_M> struct modint {\n#endif\n    static constexpr int MOD = M;\n    int val;\n    constexpr modint() : val(0) {}\n    constexpr modint(int val) : val(val % M) { this->val += this->val < 0 ? M : 0; }\n    constexpr modint(long long val) : modint(int(val % M)) {}\n    constexpr modint(const modint& m) : val(m.val) {}\n    constexpr modint(const complex<long double>& x) : modint(llround(x.real())) {}\n    constexpr explicit operator int() const { return val; }\n    constexpr bool operator==(const modint& y) const { return val == y.val; }\n    constexpr bool operator!=(const modint& y) const { return val != y.val; }\n    constexpr bool operator< (const modint& y) const { return val <  y.val; }\n    constexpr bool operator<=(const modint& y) const { return val <= y.val; }\n    constexpr bool operator> (const modint& y) const { return val >  y.val; }\n    constexpr bool operator>=(const modint& y) const { return val >= y.val; }\n    constexpr modint& operator=(const modint& y) { val = y.val; return *this; }\n    constexpr modint& operator+=(const modint& y) { val += y.val; val -= val >= M ? M : 0; return *this; }\n    constexpr modint& operator-=(const modint& y) { val -= y.val; val += val <  0 ? M : 0; return *this; }\n    constexpr modint& operator*=(const modint& y) { val = ll(val) * y.val % M; return *this; }\n    constexpr modint& operator/=(const modint& y) { val = ll(val) * fpow(y, PHI_M - 1).val % M; return *this; }\n    constexpr modint& operator^=(ll y) { fpow_eq(*this, y); return *this; }\n    constexpr modint operator+(const modint& y) const { return modint(val) += y; }\n    constexpr modint operator-(const modint& y) const { return modint(val) -= y; }\n    constexpr modint operator*(const modint& y) const { return modint(val) *= y; }\n    constexpr modint operator/(const modint& y) const { return modint(val) /= y; }\n    constexpr modint operator^(ll y) const { return modint(val) ^= y; }\n    constexpr modint operator-() const { return modint(0) -= *this; }\n    constexpr modint operator~() const { return modint(1) /= *this; }\n    constexpr modint& operator++() { val = val == M - 1 ? 0 : val + 1; return *this; }\n    constexpr modint& operator--() { val = val == 0 ? M - 1 : val - 1; return *this; }\n    constexpr modint operator++(int) { modint m = *this; ++(*this); return m; }\n    constexpr modint operator--(int) { modint m = *this; --(*this); return m; }\n    friend constexpr modint operator+(long long x, const modint& y) { return modint(x) + y; }\n    friend constexpr modint operator*(long long x, const modint& y) { return modint(x) * y; }\n    friend constexpr modint operator-(long long x, const modint& y) { return modint(x) - y; }\n    friend constexpr modint operator/(long long x, const modint& y) { return modint(x) / y; }\n    friend ostream& operator<<(ostream& os, const modint& m) { return os << m.val; }\n    friend istream& operator>>(istream& is, modint& m) { ll val; is >> val; m = modint(val); return is; }\n};\nconstexpr int M = 1'000'000'007;\nusing mint = modint<M, M - 1>;\nmint operator\"\"_m(unsigned long long int x) { return mint(ll(x)); }\ntemplate <typename T = mint> T fact(int n) {\n    static vector<T> fac = {1};\n    while(fac.size() <= n) {\n        fac.push_back(fac.back() * int(fac.size()));\n    }\n    return fac[n];\n}\ntemplate <typename T = mint> T fact_inv(int n) {\n    static vector<T> inv_fac = {1};\n    while(inv_fac.size() <= n) {\n        inv_fac.push_back(inv_fac.back() / int(inv_fac.size()));\n    }\n    return inv_fac[n];\n}\ntemplate <int N> constexpr modint<N, phi(N)> primitive_root() {\n    for(modint<N, phi(N)> a = 2; a <= N - 1; a++) {\n        bool is_primitive_root = true;\n        factorize<ll>(phi(N), [](ll) {}, [&](ll p) {\n            is_primitive_root &= (a ^ (phi(N) / p)) != 1;\n        });\n        if(is_primitive_root) {\n            return a;\n        }\n    }\n    return 0;\n}\ntemplate <typename T = modint<998244353, 998244352>> T w(int len, bool inverse) {\n    constexpr int M1 = T::MOD - 1;\n    constexpr int K = M1 & -M1;\n    constexpr T W = primitive_root<T::MOD>() ^ (M1 / K);\n    return ((inverse ? ~W : W) ^ (K / len));\n}\nconstexpr int lg(int x) { return 31 - __builtin_clz(x); }\ntemplate <typename T> vector<T>& pad(vector<T>& a, int min_size) {\n    a.resize(2 << lg(min_size - 1));\n    return a;\n}\nint bit_reverse(int i, int n) {\n    int ans = 0;\n    for(int j = 0; j < lg(n); j++) {\n        ans |= i & (1 << j) ? 1 << (lg(n) - 1 - j) : 0;\n    }\n    return ans;\n}\ntemplate <typename T> vector<T>& fft(vector<T>& a, bool inverse = false) {\n    int n = a.size();\n    for(int i = 0; i < n; i++) {\n        if(i < bit_reverse(i, n)) {\n            swap(a[i], a[bit_reverse(i, n)]);\n        }\n    }\n    for(int len = 2; len <= n; len <<= 1) {\n        T W = w<T>(len, inverse);\n        for(int i = 0; i < n; i += len) {\n            T root = 1;\n            for(int j = i; j < i + (len >> 1); j++) {\n                T u = a[j], t = root * a[j + (len >> 1)];\n                a[j] = u + t;\n                a[j + (len >> 1)] = u - t;\n                root *= W;\n            }\n        }\n    }\n    if(inverse) {\n        transform(a.begin(), a.end(), a.begin(), [n](T& ai) { return ai / T(n); });\n    }\n    return a;\n}\ntemplate <typename T> vector<T>& operator*=(vector<T>& a, vector<T>& b) {\n    fft(pad(a, a.size())); if(addressof(a) != addressof(b)) fft(pad(b, b.size()));\n    assert(a.size() == b.size());\n    transform(a.begin(), a.end(), b.begin(), a.begin(), multiplies<T>());\n    fft(a, true); if(addressof(a) != addressof(b)) fft(b, true);\n    return a;\n}\ntemplate <typename T> vector<T> operator*(vector<T> a, vector<T>& b) { return a *= b; }\ntemplate <int M> vector<modint<M, M - 1>> solve(int n, int m, int k) {\n    vector<modint<M, M - 1>> a(m + k + 1);\n    for(int i = 0; i <= m + k; i++) {\n        a[i] = fact<modint<M, M - 1>>(n - 1 + i);\n    }\n    vector<modint<M, M - 1>> b(k + 1);\n    for(int j = 0; j <= k; j++) {\n        b[j] = fact_inv<modint<M, M - 1>>(j) * (modint<M, M - 1>(3) ^ (k - j));\n    }\n    reverse(b.begin(), b.end());\n    b.resize(a.size());\n    a *= b;\n    return a;\n}\nvoid ex_gcd(ll a, ll b, ll& x, ll& y) {\n    if(b == 0) {\n        x = 1, y = 0;\n    } else {\n        ll xx, yy;\n        ex_gcd(b, a % b, xx, yy);\n        x = yy, y = xx - a / b * yy;\n    }\n}\nconst int M1 = 998244353;\nconst int M2 = 469762049;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, k;\n    cin >> n >> m >> k;\n    auto a1 = solve<M1>(n, m, k);\n    auto a2 = solve<M2>(n, m, k);\n    ll m1, m2;\n    ex_gcd(M1, M2, m1, m2);\n    mint ans = 0;\n    for(int i = 0; i <= m; i++) {\n        mint x = mint(a1[k + i].val) * m2 * M2 + mint(a2[k + i].val) * m1 * M1;\n        ans += fact_inv(n - 1) * fact_inv(i) * (3_m ^ (m - i)) * x;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-10\n#define LL_INF 0x33ffffffffffffff\n#define INF 0x3f3f3f3f\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n\nconst int maxn = 1e6 + 5;\nconst double PI = acos(-1.0);\nconst ll mod = 1e9 + 7;\nll po(ll a, ll b,ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a,ll b){ if(a==0){return b;}else{ return gcd(b%a,a);}}\n\nll n,m,k;\nll fac[maxn],inv[maxn];\n\nvoid init()\n{\n\tfac[0] = 1;\n\tinv[0] = 1;\n\tint up = 1e6;\n\tfor(int i=1;i<=up;i++)\n\t{\n\t\tfac[i] = fac[i-1]*i%mod;\n\t\tinv[i] = po(fac[i],mod-2,mod);\n\t}\n}\n\nll C(ll n,ll m)\n{\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nvoid solve()\n{\n\tscanf(\"%lld%lld%lld\",&n,&m,&k);\n\n\tll res = 0;\n\tll fs = 1;\n\tfor(ll i=0;i<=m+k;i++)\n\t{\n\t\tres = res+(C(i+n-1,n-1)*fs%mod*po(3,m+k-i,mod)%mod);\n\t\tres %= mod;\n\t\t//cout<<res<<\" \"<<(C(i+n-1,n-1)*fs%mod*po(3,m+k-i,mod)%mod)<<endl;\n\t\t//cout<<C(i+n-1,n-1)<<\" \"<<fs<<\" \"<<po(3,m+k-i,mod)%mod<<endl<<endl;\n\t\tfs = fs*2%mod;\n\n\t\tif(i>=m)\n\t\t{\n\t\t\tfs = (fs + mod - C(i,m))%mod;\n\t\t}\n\t\tif(i>=k)\n\t\t{\n\t\t\tfs = (fs + mod - C(i,k))%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n}\n\nint main()\n{\n    init();\n    solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n\nvector<long long> fact_num, fact_den;\nvector<long long> pow2, pow3;\nmap<pair<long long, long long>, long long> dp;\n\nlong long bipow(long long n, int m) {\n    if (m == 0) return 1;\n    if (m % 2 == 0) {\n        n = (n * n) % MOD;\n        return bipow(n, m / 2) % MOD;\n    } else\n        return (n * bipow(n, m - 1)) % MOD;\n}\n\nvoid set_table(int N, vector<long long> &fact_num, vector<long long> &fact_den){\n    fact_num.resize(N+1, 0);\n    fact_den.resize(N+1, 0);\n    vector<long long> fact_denpow(N+1, 0);\n\n    fact_num[0] = 1;\n    for(int i=1; i<=N; i++) fact_num[i] = (fact_num[i-1] * i) % MOD;\n\n    for(int i=0; i<=N; i++) fact_denpow[i] = bipow(i, MOD-2);\n    fact_den[0] = 1;\n    for(int i=1; i<=N; i++) fact_den[i] = (fact_den[i-1] * fact_denpow[i]) % MOD;\n}\n\nlong long comb(const vector<long long> &fact_num, const vector<long long> &fact_den, int m, int n){\n    return ((fact_num[m] * fact_den[n]) % MOD * fact_den[m-n]) % MOD;\n}\n\nlong long func2(long long n, long long k){\n    if(k < 0) return 0;\n\n    if(dp.find(make_pair(n, k)) != dp.end())\n        return dp[make_pair(n, k)];\n\n    long long tmp = (2 * func2(n-1, k-1))%MOD;\n    tmp += comb(fact_num, fact_den, n-1, k);\n    tmp %= MOD;\n    dp[make_pair(n, k)] = tmp;\n    return tmp;\n}\n\nlong long func(long long L, long long R, long long n){\n    long long ret = pow2[n];\n    ret += MOD - func2(n, L-1);\n    ret %= MOD;\n    ret += MOD - func2(n, n-R-1);\n    ret %= MOD;\n    return ret;\n}\n\nint main(){\n    long long N, M, K;\n    cin >> N >> M >> K;\n\n    set_table(N+M+K, fact_num, fact_den);\n\n    pow2.resize(N+M+K+1, 0);\n    pow2[0] = 1;\n    for(int i=1; i<=N+M+K; i++)\n        pow2[i] = (2*pow2[i-1])%MOD;\n\n    pow3.resize(N+M+K+1, 0);\n    pow3[0] = 1;\n    for(int i=1; i<=N+M+K; i++)\n        pow3[i] = (3*pow3[i-1])%MOD;\n\n    long long ans = 0;\n    for(int i=N; i<=N+M+K; i++){\n        long long tmp = pow3[N+M+K-i];\n\n        tmp *= comb(fact_num, fact_den, i-1, N-1);\n        tmp %= MOD;\n\n        tmp *= func(max(0LL, i-N-K), min(M, i-N), i-N);\n        tmp %= MOD;\n\n        ans += tmp;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \nusing namespace std ;\n\nconst int mod = 1e9 + 7;\nconst int N = 900010;\nint n, m, k;\nll fac[N], inv[N], p[N];\n\ninline ll read() {\n\tll s = 0, f = 1;\n\tchar ch;\n\tfor(; ch < '0' || ch > '9'; ch = getchar())\tif(ch == '-')\tf = -1;\n\tfor(; ch >= '0' && ch <= '9'; ch = getchar())\ts = (s << 1) + (s << 3) + ch - '0';\n\treturn s * f;\n}\n\ninline ll quickpow(ll a, ll b) {\n    ll re = 1;\n    while(b) {\n        if(b & 1) re *= a;\n        re %= mod;\n\t\tb >>= 1;\n        a *= a;\n        a %= mod;\n    }\n    return re;\n}\n\ninline void init() {\n\tn = read(), m = read(), k = read();\n    fac[0] = 1;\n    p[0] = 1;\n    for(int i = 1 ; i < N; ++i) {\n        fac[i] = fac[i - 1] * i % mod;\n        p[i] = p[i - 1] * 3LL % mod;\n    }\n    for(int i = 0; i < N; ++i) { inv[i] = quickpow(fac[i], mod - 2) % mod; }\n}\n\ninline ll C(ll x, ll y) { return (fac[x] * inv[y] % mod * inv[x - y] % mod) % mod; }\n\ninline void work() {\n\tll ans = 0, x = 1LL;\n    --n;\n    if(m < k)\tswap(m, k);\n    for(int i = 0; i <= m + k; ++i) {\n        ans = (ans + C(n + i, n) * p[m + k - i] % mod * x) % mod;\n        if(i < k) x = (x * 2LL) % mod;\n        else if(i < m) x = (x * 2LL - C(i, k)) % mod ;\n        else  x = (x * 2LL - C(i, k) - C(i, m)) % mod ;\n    }\n    printf(\"%lld\\n\", (ans + mod) % mod);\n}\n\nint main() {\n\tinit();\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K;\n\tint sum = N + M + K;\n\tif (M > K)swap(M, K);\n\tvector<long long int>by(sum + 11, 1);\n\tvector<long long int>rev(sum + 11, 1);\n\tfor (int i = 2; i <= sum + 10; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t\trev[i] = power(by[i], MOD - 2, MOD);\n\t}\n\tlong long int ans = power(3, M + K, MOD);\n\t//long long int sum = 1;\n\tlong long int cnt = 1;\n\tfor (int i = N + 1; i <= sum; i++) {\n\t\tlong long int add = by[i - 1];\n\t\tadd *= rev[N - 1];\n\t\tadd %= MOD;\n\t\tadd *= rev[i - N];\n\t\tadd %= MOD;\n\t\tint l = i - N - 1 - M, r = K;\n\t\tcnt *= 2;\n\t\tif (l >= 0) {\n\t\t\tlong long int minus = by[i - 1 - N];\n\t\t\tminus *= rev[l];\n\t\t\tminus %= MOD;\n\t\t\tminus *= rev[i - 1 - N - l];\n\t\t\tminus %= MOD;\n\t\t\tcnt -= minus;\n\t\t}\n\t\tif (r <= i - 1 - N) {\n\t\t\tlong long int minus = by[i - 1 - N];\n\t\t\tminus *= rev[r];\n\t\t\tminus %= MOD;\n\t\t\tminus *= rev[i - 1 - N - r];\n\t\t\tminus %= MOD;\n\t\t\tcnt -= minus;\n\t\t}\n\t\tcnt += MOD*2;\n\t\t//cout << i << \" \" << cnt << endl;\n\t\tcnt %= MOD;\n\t\tadd *= cnt;\n\t\tadd %= MOD;\n\t\tadd *= power(3, sum - i, MOD);\n\t\tadd %= MOD;\n\t\tans += add;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main()\n{\n    int i,j,k,m,n;\n    int aa,bb,cc;\n    char d,f;\n    char a[110],b[110],c[110];\n    cin>>a>>b>>c;\n    aa=strlen(a);\n    bb=strlen(b);\n    cc=strlen(c);\n    i=1,j=0,k=0;\n    d=a[0];\n    while(1)\n    {\n        if(d=='a')\n        {\n            d=a[i];\n            i++;\n        }\n        if(d=='b')\n        {\n            d=b[j];\n            j++;\n        }\n        if(d=='c')\n        {\n            d=c[k];\n            k++;\n        }\n        if(i==aa+1)\n        {\n            cout<<'A'<<endl;\n            return 0;\n        }\n        if(i==cc+1)\n        {\n            cout<<'C'<<endl;\n            return 0;\n        }\n        if(i==bb+1)\n        {\n            cout<<'B'<<endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int N = 9e5 + 5;\nconst int mod = 1e9 + 7;\n\nint fact[N], inv_fact[N], pw[N];\n\nint binPow (int x, int y) {\n    int ans = 1;\n    while (y) {\n        if (y & 1) ans = (ans * x) % mod;\n        x = (x * x) % mod;\n        y >>= 1;\n    }\n\n    return ans;\n}\n\nint C (int n, int k) {\n    int ans = 1;\n    ans *= fact[n]; ans %= mod;\n    ans *= inv_fact[k]; ans %= mod;\n    ans *= inv_fact[n - k]; ans %= mod;\n\n    return ans;\n}\n\nsigned main(){\n    fact[0] = inv_fact[0] = pw[0] = 1;\n    for (int i = 1; i < N; i++) {\n        pw[i] = (pw[i - 1] * 3) % mod;\n        fact[i] = (i * fact[i - 1]) % mod;\n        inv_fact[i] = binPow(fact[i], mod - 2);\n    }\n\n    int n, m, k;\n    scanf(\"%lld %lld %lld\", &n, &m, &k);\n    int ans = 0;\n\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= k; j++) {\n            ans = (ans + C(i + j, i) * C(i + j + n - 1, i + j) % mod * pw[m + k - i - j]) % mod;\n        }\n    }\n\n    printf(\"%lld\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tpl<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\n//------------------------------------------------------------------------------\n\nconst lli MOD = 1e9+7;\nlli cnk[3002][3002];\nlli p3[5000000];\n\nlli fexp(lli a, lli b) {\n  if(b == 1) return a;\n  lli c = fexp(a, b/2);\n  c = (c*c)%MOD;\n  if(b&1) c = (c*a)%MOD;\n  return c;\n}\n\nlli invmod(lli a) {\n  return fexp(a, MOD-2);\n}\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  lli n, m, k; cin >> n >> m >> k;\n  p3[0] = 1; FOR(i, 300000) p3[i+1]=(3*p3[i])%MOD;\n  FOR(i, 3000) {\n    cnk[i][0] = 1;\n    cnk[i][i] = 1;\n    FORU(j, 1, i-1) cnk[i][j] = (cnk[i-1][j-1]+cnk[i-1][j])%MOD;\n  }\n  lli ans = 0;\n  lli cur0 = 1;\n  lli l0 = 0, l1 = 0;\n  lli v0 = 1, v1 = 1;\n  lli s0 = 0;\n  FORU(i, n, n+m+k) {\n    lli nl0 = max<lli>(0, i-n-m);\n    lli nl1 = min<lli>(i-n, k);\n    lli nv0, nv1;\n    lli nv00, nv01;\n    lli nv10, nv11;\n    nv00 = (v0+((v0*(i-1-n-l0))%MOD)*invmod(nl0))%MOD;\n    nv00 += MOD; nv00 %= MOD;\n    nv01 = 1;\n    if(nl0>l0) {\n      nv0 = nv00;\n    }else{\n      nv0 = nv01;\n    }\n    nv10 = (v1+((v1*(i-1-n-l1))%MOD)*invmod(nl1))%MOD;\n    nv10 += MOD; nv10 %= MOD;\n    nv11 = (v1+((v1*invmod(i-n-l1))%MOD)*(l1))%MOD;\n    nv11 += MOD; nv11 %= MOD;\n    if(nl1>l1){\n      nv1 = nv10;\n    }else{\n      nv1 = nv11;\n    }\n    if(nl0==nl1) s0 = 0;\n    else if(nl0+1==nl1) {\n      s0=nv1;\n    } else {\n      lli ns0 = s0+s0-v1+v0;\n      ns0%=MOD;\n      if(nl1>l1) ns0 += nv1;\n      if(nl0>l0) ns0 -= nv0;\n      ns0 %= MOD;\n      ns0 += MOD;\n      ns0 %= MOD;\n      s0 = ns0;\n    }\n    // FORU(j, nl0, nl1) {\n    //   s += cnk[i-n][j];\n    // }\n    lli s = nv0+s0;\n    l0 = nl0; l1 = nl1;\n    v0 = nv0; v1 = nv1;\n    s %= MOD;\n    s *= cur0;\n    s %= MOD;\n    s *= p3[n+m+k-i];\n    s %= MOD;\n    (ans += s) %= MOD;\n\n    cur0 = cur0+((cur0*invmod(i-n+1))%MOD)*(n-1); cur0 %= MOD; cur0 += MOD; cur0 %= MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define N 600010\ntypedef long long ll;\n\nconst ll Mod=1e9+7;\n\nint n,m,K;\nll Pre[N],Inv[N],Pre_inv[N],Pow[N];\n\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nvoid Prepare()\n{\n    Inv[1]=1;Inv[0]=1;\n    for(int i=2;i<=600000;i++)\n        Inv[i]=(Mod-Mod/i)*Inv[Mod%i]%Mod;\n    Pre[0]=1;Pre_inv[0]=1;\n    for(int i=1;i<=600000;i++)\n        Pre[i]=Pre[i-1]*i%Mod,Pre_inv[i]=Pre_inv[i-1]*Inv[i]%Mod;\n    Pow[0]=1;\n    for(int i=1;i<=600000;i++)\n        Pow[i]=Pow[i-1]*3%Mod;\n}\n\nll Cal(int a,int b)\n{\n    return Pre[a]*Pre_inv[b]%Mod*Pre_inv[a-b]%Mod;\n}\n\nint main()\n{\n    Prepare();\n    n=read();m=read();K=read();\n    ll qwer=1,Ans=0;\n    for(int i=0;i<=m+K;i++)\n    {\n        ll now=Cal(n+i-1,i)*qwer%Mod*Pow[m+K-i]%Mod;\n        Ans=(Ans+now)%Mod;\n        qwer=qwer*2%Mod;\n        if(i+1>K)\n            qwer-=Cal(i,K);\n        if(i+1>m)\n            qwer-=Cal(i,m);\n        qwer=(qwer%Mod+Mod)%Mod;\n    }\n    cout<<Ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\n#define LL long long\nusing namespace std;\nconst int N=9e5+10;\nconst LL mod=1e9+7;\nint n,m,k;\nLL fac[N]={1},inv[N]={1,1},pw[N]={1},ans,j=1;\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\ntemplate<typename I>inline void swp(I&a,I&b){a^=b; b^=a; a^=b;}\ninline LL C(int nn,int mm){return fac[nn]*inv[mm]%mod*inv[nn-mm]%mod;}\nint main()\n{\n//\tfreopen(\"Card Game for Three.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tread(n,m,k);\n\tif(k>m) swp(k,m);\n\tfor(int i=2;i<=n+k+m;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=n+k+m;i++) fac[i]=fac[i-1]*i%mod, (inv[i]*=inv[i-1])%=mod, pw[i]=pw[i-1]*3%mod;\n\tfor(int i=0;i<=m+k;i++)\n\t{\n\t\t(ans+=C(n+i-1,n-1)*pw[m+k-i]%mod*j%mod)%=mod;\n\t\tif(i<k) (j<<=1)%=mod;\n\t\telse if(i>=m) (j+=j-C(i,k)+mod-C(i,m)+mod)%=mod;\n\t\telse (j+=j-C(i,k)+mod)%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t//fclose(stdin); fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#pragma GCC optimize(\"Ofast,unroll-loops\")\n//#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace IntModulo\n{\n\tconst int mod = 1e9 + 7;\n\n\tinline int add(int x, int y, int m = mod)\n\t{\n\t\tif (x + y < m)\n\t\t\treturn x + y;\n\t\treturn x + y - m;\n\t}\n\n\tinline int sub(int x, int y, int m = mod)\n\t{\n\t\tif (x >= y)\n\t\t\treturn x - y;\n\t\treturn x - y + m;\n\t}\n\n\tinline int mult(int x, int y, int m = mod)\n\t{\n\t\treturn x * (LL) y % m;\n\t}\n\n\tinline int power(int x, int y, int m = mod)\n\t{\n\t\tint r = 1;\n\t\twhile(y)\n\t\t{\n\t\t\tif (y & 1)\n\t\t\t\tr = mult(r, x, m);\n\t\t\tx = mult(x, x, m);\n\t\t\ty >>= 1;\n\t\t}\n\t\t\n\t\treturn r;\n\t}\n\t\n\tinline int inverse(int x, int m = mod)\n\t{\n\t\treturn power(x, m - 2, m);\n\t}\n\t\n\tinline void ADD(int& x, int y, int m = mod)\n\t{\n\t\tx += y;\n\t\tif (x >= m) x -= m;\n\t}\n\t\n\tinline void SUB(int& x, int y, int m = mod)\n\t{\n\t\tx -= y;\n\t\tif (x < 0) x += m;\n\t}\n\t\n\tinline void MULT(int& x, int y, int m = mod)\n\t{\n\t\tx = (x * (LL) y) % m;\n\t}\n};\n\nnamespace Combinatorics\n{\n\tusing namespace IntModulo;\n\t\n\tconst int N = 1 << 19;\n\tint fact[N];\n\tint inv[N];\n\tint invFact[N];\n\tbool inited = false;\n\t\n\tinline int C(int n, int k) // binomial C(n, k)\n\t{\n\t\treturn n < k ? 0 : mult(fact[n], mult(invFact[k], invFact[n - k]));\n\t}\n\t\n\tinline int H(int n, int k) // number of solution x1 + .. + xn = k\n\t{\n\t\treturn C(n + k - 1, k);\n\t}\n\t\n\tvoid init()\n\t{\n\t\tdebug(Combinatorics::N);\n\t\tinited = true;\n\t\tinv[1] = 1;\n\t\tFOR(i, 2, N)\n\t\t\tinv[i] = mult(mod - mod / i, inv[mod % i]);\n\t\t\n\t\tinvFact[0] = fact[0] = 1;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tfact[i] = mult(i, fact[i - 1]);\n\t\t\tinvFact[i] = mult(invFact[i - 1], inv[i]);\n\t\t}\n\t}\t\n};\n\nusing namespace Combinatorics;\nconst int M = 1 << 20;\nLL a[M], b[M], c[M];\n\nnamespace Karatsuba\n{\n\t#pragma GCC optimize(\"Ofast,unroll-loops\")\n\t#pragma GCC target(\"avx,avx2,fma\")\n\n\ttemplate<int n, typename T>\n\tvoid mult(const T* __restrict A, const T* __restrict B, T* __restrict C)\n\t{\n\t\tif (n <= 64)\n\t\t{\n\t\t\tFOR(i, 0, n) FOR(j, 0, n) C[i + j] += A[i] * B[j];\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tconst int m = n >> 1;\n\t\tmult<m>(A + 0, B + 0, C);\n\t\tmult<m>(A + m, B + m, C + n);\n\t\t\n\t\talignas(64) T a[n], b[n], e[n] = {};\n\t\tFOR(i, 0, m) \n\t\t{\n\t\t\ta[i] = A[i] + A[i + m];\n\t\t\tb[i] = B[i] + B[i + m];\n\t\t}\n\t\t\n\t\tmult<m>(a, b, e);\n\t\tFOR(i, 0, m)\n\t\t{\n\t\t\tconst T tut = C[i + m];\n\t\t\tC[i + m] += e[i] - C[i] - C[i + m * 2];\n\t\t\tC[i + m * 2] += e[i + m] - tut - C[i + m * 3];\n\t\t}\n\t}\n};\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tCombinatorics::init();\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tn--;\n\tint ans = 0;\n\tFOR(i, 0, m + 1) a[i] = invFact[i];\n\tFOR(i, 0, k + 1) b[i] = invFact[i];\n\tKaratsuba::mult<(1 << 18)>(a, b, c);\n\t\t\n\tFOR(t, 0, m + k + 1)\t\t\n\t\tADD(ans, mult(fact[t], mult(c[t] % mod, mult(C(n + t, t), power(3, m + k - t)))));\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 300010, M = 300010, K = 300010;\nconst LL MOD = 1E9 + 7;\n\ninline void Add(LL &a, LL b) {\n    a = (a + b) % MOD;\n    return;\n}\ninline void Dec(LL &a, LL b) {\n    a = ((a - b) % MOD + MOD) % MOD;\n    return;\n}\n\nLL Pow(LL a, LL b) {\n    LL c = 1;\n    while (b) {\n        if (b & 1) c = c * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return c;\n}\n\nint n, m, k, cnt;\n\nLL fac[N + M + K], fac_ie[N + M + K], f[N + M + K], t[N + M + K];\n\nvoid Pre() {\n    fac[0] = 1;\n    for (int i = 1; i <= cnt; ++i)\n        fac[i] = fac[i - 1] * i % MOD;\n    fac_ie[cnt] = Pow(fac[cnt], MOD - 2);\n    for (int i = cnt; i; --i)\n        fac_ie[i - 1] = fac_ie[i] * i % MOD;\n    t[0] = 1;\n    for (int i = 1; i <= cnt; ++i)\n        t[i] = t[i - 1] * 3 % MOD;\n    return;\n}\n\ninline LL C(int a, int b) {\n    return fac[a] * fac_ie[b] % MOD * fac_ie[a - b] % MOD;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &k);\n    cnt = n + m + k;\n    Pre();\n    f[0] = 1;\n    for (int i = 1; i <= m + k; ++i) {\n        f[i] = (f[i - 1] << 1) % MOD;\n        if (i >= m + 1) Dec(f[i], C(i - 1, m));\n        if (i >= k + 1) Dec(f[i], C(i - 1, k));\n    }\n    LL res = 0;\n    for (int i = n; i <= cnt; ++i)\n        Add(res, C(i - 1, n - 1) * f[i - n] % MOD * t[cnt - i]);\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\ntypedef long long int64;\nstatic const int MAXN = 3e5 + 4;\nstatic const int MODULUS = 1e9 + 7;\n#define _  %  MODULUS\n#define __ %= MODULUS\n\nint n, m, k;\n\nint64 fact[MAXN * 3], fact_inv[MAXN * 3];\n\ninline int64 fpow(int64 base, int exp)\n{\n    int64 ans = 1;\n    for (; exp; exp >>= 1, (base *= base)__) if (exp & 1) (ans *= base)__;\n    return ans;\n}\nvoid preprocess()\n{\n    fact[0] = 1;\n    for (int i = 1; i < MAXN * 3; ++i) fact[i] = fact[i - 1] * i _;\n    fact_inv[MAXN * 3 - 1] = fpow(fact[MAXN * 3 - 1], MODULUS - 2);\n    for (int i = MAXN * 3 - 2; i >= 0; --i) fact_inv[i] = fact_inv[i + 1] * (i + 1)_;\n}\ninline int64 binom(int n, int m)\n{\n    if (n < m) return 0; else return fact[n] * fact_inv[m]_ * fact_inv[n - m]_;\n}\n\nint main()\n{\n    preprocess();\n    scanf(\"%d%d%d\", &n, &m, &k);\n    if (n > 1000) { puts(\"> <\"); return 0; }\n\n    int64 ans = 0;\n    for (int s = n + 1; s <= n + m + k + 1; ++s) {\n        for (int t = std::max(0, s - n - 1 - k); t <= m; ++t)\n            (ans += binom(s - 2, n - 1) * binom(s - n - 1, t)_ * fpow(3, n + m + k + 1 - s))__;\n    }\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\n#define gpf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\nconst ll md = 1e9 + 7;\nconst int N = 1000000;\nll n, m, k;\nll fac[N], inv[N], m3[N];\n\nll fm(ll x, ll y){\n\tll res = 1;\n\twhile (y){\n\t\tif (y & 1) res = (res * x) % md;\n\t\ty /= 2;\n\t\tx = (x * x) % md;\n\t}\n\treturn res;\n}\n\nll C(int x, int y){\n\tif (y < 0) return 0;\n\tif (x < y) return 0;\n\tll res = ((fac[x] * inv[x - y]) % md * inv[y]) % md;\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfac[0] = 1;\n\trep(i, 1, n + m + k) fac[i] = (fac[i - 1] * i) % md;\n\trep(i, 1, n + m + k) inv[i] = fm(fac[i], md - 2);\n\tm3[0] = 1;\n\trep(i, 1, n + m + k) m3[i] = (m3[i - 1] * 3) % md;\n\tinv[0] = 1;\n\tll ans = 0;\n\tll t = 1;\n\trep(i, 0, m + k){\n\t\tll tt = C(n + i - 1, n - 1) * t % md;\n\t\ttt = tt * m3[m + k - i] % md;\n\t\tans = (ans + tt) % md;\n\t\tt = ((t * 2 + md - C(i, m)) % md + md - C(i, i - k)) % md;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <math.h>\n#include <string.h>\n#include <string>\n#include <queue>\n#include <stack>\nusing namespace std;\ntypedef long long int ll;\nll mod=1e9+7;\nll powt[1000100];\nll powtwo[1000100];\nll fact[1000100];\nll inv[1000100];\nll invfact[1000100];\nll dp[1000100];\nll ans;\nint n, m, k;\n\nll com(int u, int v)\n{\n\tll ret=1;\n\tret=(ret*fact[u])%mod;\n\tret=(ret*invfact[v])%mod;\n\tret=(ret*invfact[u-v])%mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin>>n>>m>>k;\n\tn++; m++; k++;\n\tinv[1]=1;\n\tinvfact[0]=1;\n\tfact[0]=1;\n\tinvfact[1]=1;\n\tfact[1]=1;\n\tint i, j;\n\tfor(i=2 ; i<=1000000 ; i++)\n\t{\n\t\tinv[i]=((mod-mod/i)*inv[mod%i])%mod;\n\t\tfact[i]=(i*fact[i-1])%mod;\n\t\tinvfact[i]=(invfact[i-1]*inv[i])%mod;\n\t}\n\tpowt[0]=1;\n\tpowt[1]=3;\n\tpowtwo[0]=1;\n\tpowtwo[1]=2;\n\tfor(i=2 ; i<=1000000 ; i++)\n\t{\n\t\tpowt[i]=(3*powt[i-1])%mod;\n\t\tpowtwo[i]=(2*powtwo[i-1])%mod;\n\t}\n\tif(k>m)\n\t{\n\t\tll temp=k;\n\t\tk=m;\n\t\tm=temp;\n\t}\n\tfor(i=0 ; i<=min(k,m)-1 ; i++)\n\t{\n\t\tdp[i]=powtwo[i];\n\t}\n\tif(m==k)\n\t{\n\t\tdp[min(k,m)]=powtwo[min(k,m)]-2;\n\t}\n\telse\n\t{\n\t\tdp[min(k,m)]=powtwo[min(k,m)]-1;\n\t}\n\tfor(i=min(k,m)+1 ; i<=max(k,m) ; i++)\n\t{\n\t\tdp[i]=(2*dp[i-1]-com(i-1,i-1)-com(i-1,i-k)+mod)%mod;\n\t}\n\tif(k!=m)\n\t{\n\t\tdp[max(k,m)]=(dp[max(k,m)]+mod-1)%mod;\n\t}\n\tfor(i=max(k,m)+1 ; i<=m+k-2 ; i++)\n\t{\n\t\tdp[i]=(2*dp[i-1]-com(i-1,i-k)-com(i-1,m-1)+2*mod)%mod;\n\t}\n\n\tfor(i=0 ; i<=m+k-2 ; i++)\n\t{\n\t\tll add=1;\n\t\tadd=(add*com(n+i-2,n-2))%mod;\n\t\tadd=(add*dp[i])%mod;\n\t\tadd=(add*powt[m+k-i-2])%mod;\n\t\tans=(ans+add)%mod;\n\t}\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000005;\nconst int mod = 1e9+7;\n\nint n, fact[N], inv[N];\n\nint pw(int a, int n) {\n    int result = 1;\n    while (n > 0) {\n        if (n & 1)\n            result = (1LL * result * a) % mod;\n        a = (1LL * a * a) % mod;\n        n /= 2;\n    }\n    return result;\n}\n\nvoid precalc() {\n    fact[0] = inv[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fact[i] = (1LL * fact[i - 1] * i) % mod;\n        inv[i] = pw(fact[i], mod - 2);\n    }\n}\n\nint C(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    int result = fact[n];\n    result = (1LL * result * inv[n - k]) % mod;\n    result = (1LL * result * inv[k]) % mod;\n    return result;\n}\n\nint main() {\n    precalc();\n    int a, b, c;\n    cin >> a >> b >> c;\n    int result = 0;\n    for (int len = 1; len <= a + b + c; ++len) {\n        int cur = 0;\n        for (int x = 0; x <= len - 1; ++x) {\n            int y = len - x - a;\n            if (x <= b && y <= c) {\n                cur = (cur + C(len - a, x)) % mod;\n            }\n        }\n        cur = (1LL * cur * C(len - 1, a - 1)) % mod;\n        cur = (1LL * cur * pw(3, a + b + c - len)) % mod;\n        result = (result + cur) % mod;\n    }\n    cout << result << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n/////////////////////////////////////\nvmint f, finv, inv;\n\nvoid cominit(ll N) {\n\tf.assign(N + 1, 1);\n\tfinv.assign(N + 1, 1);\n\tinv.assign(N + 1, 1);\n\tinv[1] = 1;\n\n\trepn(i, N) {\n\t\tf[i] = f[i - 1] * i;\n\t\tif (i > 1)inv[i] = -inv[MOD % i] * (MOD / i);\n\t\tfinv[i] = finv[i - 1] * inv[i];\n\t}\n}\n\nmint com(ll a, ll b) {\n\tif (a < 0 || b < 0 || a < b) { return 0; }\n\treturn f[a] * finv[b] * finv[a - b];\n}\n\n\nint main() {\n\tll N, M, K;\n\tcin >> N >> M >> K;\n\n\tll S = N + M + K;\n\tcominit(S + 1);\n\n\tvmint c(S + 1);\n\tc[0] = 1;\n\trepn(i, S) {\n\t\tc[i] = c[i - 1] * 2;\n\t\tc[i] -= com(i - 1, M);\n\t\tc[i] -= com(i - 1, K);\n\t}\n\n\tmint ans = 0;\n\trep(i, S) {\n\t\tif (i < N-1) { continue; }\n\t\tmint now = com(i, N - 1) * c[i - (N - 1)] * pw(3, S - 1 - i);\n\t\tans += now;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\n// a,b の最大公約数と、ax + by = gcd(a,b) となる x,y を求める\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n    long long g = a;\n    if(b != 0){\n        g = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }else{\n        x = 1;\n        y = 0;\n    }\n    return g;\n}\n\n// ax ≡ gcd(a, m) (mod m) となる x を求める\n// a, m が互いに素ならば、関数値は mod m での a の逆数となる\nlong long mod_inverse(long long a, long long m)\n{\n    long long x, y;\n    extgcd(a, m, x, y);\n    return (x % m + m) % m;\n}\n\nclass FactorialCalculation\n{\nprivate:\n    const int mod;\n    vector<long long> factorial;\n    vector<long long> invFactorial;\npublic:\n    FactorialCalculation(int n, int mod) : mod(mod)\n    {\n        factorial.resize(n+1, 1);\n        invFactorial.resize(n+1, 1);\n        for(int i=1; i<=n; ++i){\n            factorial[i] = factorial[i-1] * i % mod;\n            invFactorial[i] = mod_inverse(factorial[i], mod);\n        }\n    }\n    long long getFactorial(int n){\n        return factorial[n];\n    }\n    long long getPermutation(int n, int r){\n        if(n < r)\n            return 0;\n        return factorial[n] * invFactorial[n-r] % mod;\n    }\n    long long getCombination(int n, int r){\n        if(n < r)\n            return 0;\n        return getPermutation(n, r) * invFactorial[r] % mod;\n    }\n    long long getHomogeneous(int n, int r){\n        return getCombination(n+r-1, r);\n    }\n};\n\nconst int MOD = 1000000007;\n\nint main()\n{\n    int a, b, c;\n    cin >> a >> b >> c;\n    FactorialCalculation f(a+b+c, MOD);\n\n    long long tmp = 1;\n    long long ans = 1;\n    for(int i=1; i<=b+c; ++i){\n        tmp *= 2;\n        tmp %= MOD;\n        if(i > b){\n            tmp -= f.getCombination(i - 1, b);\n            tmp += MOD;\n            tmp %= MOD;\n        }\n        if(i > c){\n            tmp -= f.getCombination(i - 1, i - 1 - c);\n            tmp += MOD;\n            tmp %= MOD;\n        }\n\n        ans *= 3;\n        ans += tmp * f.getCombination(a + i - 1, i);\n        ans %= MOD;\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,a,b;\nconst int N=1000010;\nint fac[N],inv[N];\nconst int mod=1000000007;\nint n,m,k;\nint qp(int x,int k)\n{\n\tint res=1;\n\twhile(k)\n\t{\n\t\tif(k&1)res=1ll*res*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\nvoid init()\n{\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<N;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tinv[N-1]=qp(fac[N-1],mod-2);\n\tfor(int i=N-2;i>=1;i--)\n\t\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\nint C(int a,int b)\n{\n\tif(a<b)return 0;\n\treturn 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\nlong long ans,sum;\nint main()\n{\n\tinit();\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tsum=1; ans=qp(3,m+k)%mod;\n\tfor(int i=1;i<=m+k;i++)\n\t{\n\t\tsum=(sum*2%mod-(i-1>=k?C(i-1,k):0)+mod-(i-1>=m?C(i-1,i-m-1):0)+mod)%mod;\n\t\tans=(ans+sum*qp(3,m+k-i)%mod*C(i+n-1,n-1)%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble PI=3.141592653589793;\n\ncomplex <double> dftn[2100007];\ncomplex <double> dfts[2100007];\n\ncomplex <double> a1[2100007];\ncomplex <double> b1[2100007];\ncomplex <double> a2[2100007];\ncomplex <double> b2[2100007];\n\ndouble cosi[2100007];\ncomplex <double> omega[2100007];\n\ninline int potenga(int v)\n{\n    for (int i=1; 1; i<<=1)\n    {\n        if (i>=v)\n        {\n            return i;\n        }\n    }\n}\n\ninline void dft(int n, int kier)\n{\n    int n2=n-1;\n    int s=0;\n    int p;\n    int g;\n\n    for (int i=2; i<=n; i<<=1)\n    {\n\n        for (int j=0; j<n; j++)\n        {\n            dfts[j]=dftn[j];\n            dftn[j]=0;\n        }\n\n        p=n/i;\n\n        if (kier)\n        {\n            g=0;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=j+1;\n                    s=0;\n                }\n            }\n        }\n        else\n        {\n            g=n;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=n-j-1;\n                    s=0;\n                }\n            }\n        }\n    }\n}\n\nvoid licz_omegi(int n1)\n{\n    double kat=2.0*PI/n1;\n    int n2=n1-1;\n    int dod=3*n1/4;\n\n    for (int i=0; i<=n1; i++)\n    cosi[i]=cos(kat*i);\n    for (int i=0; i<=n1; i++)\n    omega[i]=complex <double> (cosi[i], cosi[(i+dod)&n2]);\n}\n\nvector <long long> fft_dokladne(vector <long long> &jed, vector <long long> &dwa)\n{\n    int n1=potenga(jed.size()+dwa.size());\n\n    licz_omegi(n1);\n\n    long long M=32000;\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]/M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a1[i]=dftn[i];\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]%M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b1[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]/M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a2[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]%M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b2[i]=dftn[i];\n\n    vector <long long> ret;\n    for (int i=0; i<n1; i++)\n    ret.push_back(0);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=(llround(dftn[i].real()/n1)%1000000007)*((M*M)%1000000007);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*b2[i]+b1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=(llround(dftn[i].real()/n1)%1000000007)*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=b1[i]*b2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1)%1000000007;\n\n    for (int i=0; i<ret.size(); i++)\n        ret[i]%=1000000007;\n\n    return ret;\n}\n\nint n, m, k;\n\nint s;\n\nlong long mod=1000000007;\n\nlong long sil[1000007];\nlong long odw[1000007];\nlong long do3[1000007];\n\nvector <long long> d1, d2, d3;\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n    long long wyk=mod-2;\n    while(wyk)\n    {\n        if (wyk&1)\n        {\n            a*=b;\n            a%=mod;\n        }\n        b*=b;\n        b%=mod;\n        wyk>>=1;\n    }\n    return a;\n}\n\nlong long komb(int a, int b)\n{\n    if (b<0 || b>a)\n        return 0;\n    return (sil[a]*((odw[b]*odw[a-b])%mod))%mod;\n}\n\nlong long komz(int a, int b)\n{\n    return komb(a+b-1, b);\n}\n\nint main()\n{\n    n=300000;\n    m=300000;\n    k=300000;\n    //scanf(\"%d%d%d\", &n, &m, &k);\n    s=n+m+k;\n    sil[0]=1;\n    odw[0]=1;\n    do3[0]=1;\n    for (int i=1; i<=s; i++)\n        sil[i]=(sil[i-1]*i)%mod;\n    odw[s]=dziel(1, sil[s]);\n    for (int i=s-1; i; i--)\n        odw[i]=(odw[i+1]*(i+1))%mod;\n    for (int i=1; i<=s; i++)\n        do3[i]=(do3[i-1]*3)%mod;\n    for (int i=0; i<=m; i++)\n        d1.push_back((komz(n, i)*odw[n+i-1])%mod);\n    for (int i=0; i<=k; i++)\n        d2.push_back(odw[i]);\n    d3=fft_dokladne(d1, d2);\n    for (int i=0; i<=m+k; i++)\n        wyn+=(d3[i]*((sil[n+i-1]*do3[m+k-i])%mod))%mod;\n    printf(\"%lld\\n\", wyn%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nvector<lint> zyo,rz,z3;\nlint mo=1000000007;\nlint dp[810893];\nlint extgcd(lint a, lint b, lint &x, lint &y) {\n  lint g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nlint invMod(lint a, lint m) {\n  lint x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;return 0;\n}\nlint cal(int a,int b){\n\treturn ((zyo[a+b]*rz[a])%mo*rz[b])%mo;\n}\nint main()\n{\n\tint n,m,k;lint out=0;\n\tcin>>n>>m>>k;\n\tzyo.pb(1);rep(i,931931) zyo.pb((zyo[i]*(i+1))%mo);\n\trep(i,931931) rz.pb(invMod(zyo[i],mo));\n\tz3.pb(1);rep(i,810893) z3.pb((z3[i]*3)%mo);\n\tdp[0]=1;\n\trep(i,m+k){\n\t\tdp[i+1]=dp[i]*2;\n\t\tif(i>=m) dp[i+1]-=cal(m,i-m);\n\t\tif(i>=k) dp[i+1]-=cal(k,i-k);\n\t\tdp[i+1]%=mo;if(dp[i+1]<0) dp[i+1]+=mo;\n\t}\n\trep(i,m+k+1){\n\t\t//cout<<i<<' '<<dp[i]<<' '<<cal(i,n-1)<<' '<<z3[m+k-i]<<endl;\n\t\tout+=(dp[i]*cal(i,n-1))%mo*z3[m+k-i];\n\t\tout%=mo;\n\t}\n\tcout<<out%mo<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nconst int N=900000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u];i;i=sq[i].nxt)\n#define fir first\n#define sec second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 1000000007\n#define eps 1e-8\nint n,m,k;\nll fac[N+10],invfac[N+10];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nll qpow(ll x,int y)\n{\n\tll ans=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ans=ans*x%maxd;\n\t\tx=x*x%maxd;y>>=1;\n\t}\n\treturn ans;\n}\n\nll C(int n,int m)\n{\n\tif ((n<m) || (n<0) || (m<0)) return 0;\n\treturn fac[n]*invfac[m]%maxd*invfac[n-m]%maxd;\n}\n\nint main()\n{\n\tfac[0]=invfac[0]=1;\n\trep(i,1,N) fac[i]=fac[i-1]*i%maxd;\n\tinvfac[N]=qpow(fac[N],maxd-2);\n\tper(i,N-1,1) invfac[i]=invfac[i+1]*(i+1)%maxd;\n\tn=read();m=read();k=read();\n\tif (m<k) swap(m,k);\n\tll ans=0,sum=1;\n\trep(i,0,m+k)\n\t{\n\t\tans=(ans+qpow(3,m+k-i)*C(n+i-1,n-1)%maxd*sum)%maxd;\n\t\tsum=(sum*2-C(i,i-k)-C(i,m))%maxd;\n\t\tsum=(sum+maxd)%maxd;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// integer c = a*b is accurate if c_i < 2^49\n#pragma GCC optimize (\"Ofast\") //10% performance\n#include <complex.h>\nextern \"C\" __complex__ double __muldc3(\n    double a, double b, double c, double d){\n  return a*c-b*d+I*(a*d+b*c); // 40% performance\n}\n#include <bits/stdc++.h>\n//!pause\n#define DEBUG(...) cerr << __VA_ARGS__ << endl;\n\n#ifndef CDEBUG\n#undef DEBUG\n#define DEBUG(...) ((void)0);\n#define NDEBUG\n#endif\n\n#define ran(i, a, b) for (auto i = (a); i < (b); i++)\n\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nconst int mod = 1e9 + 7;\n#ifndef M_PI\nconst double M_PI = acos(-1.0);\n#endif\n\ntypedef complex<double> Comp;\nvoid fft_rec(Comp *arr, Comp *root_pow, int len) {\n  if (len != 1) {\n    fft_rec(arr,       root_pow, len >> 1);\n    fft_rec(arr /*lp*/+ len/*rp*/, root_pow, len >> 1);\n  }\n  root_pow += len;\n  ran(i, 0, len){\n    tie(arr[i], arr[i + len]) = pair<Comp, Comp> {\n        arr[i] /*lp*/+/*rp*/ root_pow[i] * arr[i + len],\n        arr[i] /*lp*/-/*rp*/ root_pow[i] * arr[i + len] };\n  }\n}\nvoid fft(vector<Comp> &arr, int ord, bool invert) {\n  assert(arr.size() == 1 << ord);\n  static vector<Comp> root_pow(1);\n  static int inc_pow = 1;\n  static bool is_inv = false;\n  if (inc_pow <= ord) {\n    int idx = root_pow.size();\n    root_pow.resize(1 << ord);\n    for (; inc_pow <= ord; ++inc_pow) {\n      for (int idx_p = 0; idx_p < 1 << (ord - 1);\n           idx_p += 1 << (ord - inc_pow), ++idx) {\n        root_pow[idx] = Comp {\n           cos(-idx_p * M_PI / (1 << (ord - 1))),\n           sin(-idx_p * M_PI / (1 << (ord - 1))) };\n        if (is_inv) root_pow[idx] = conj(root_pow[idx]);\n      }\n    }\n  }\n  if (invert != is_inv) {\n    is_inv = invert;\n    for (Comp &cur : root_pow) cur = conj(cur);\n  }\n  int j = 0;\n  ran(i, 1, (1<<ord)){\n    int m = 1 << (ord - 1);\n    bool cont = true;\n    while (cont) {\n      cont = j & m;\n      j ^= m;\n      m >>= 1;\n    }\n    if (i < j) swap(arr[i], arr[j]);\n  }\n  fft_rec(arr.data(), root_pow.data(), 1 << (ord - 1));\n  if (invert)\n    ran(i, 0, 1<<ord) arr[i] /= (1 << ord);\n}\n\nvoid mult_poly_mod(vector<int> &a, vector<int> &b,\n  vector<int> &c) { // c += a*b\n  static vector<Comp> arr[4];\n  // correct upto 0.5-2M elements(mod ~= 1e9)\n  if (c.size() < 400) {\n    ran(i, 0, (int)a.size())\n      ran(j, 0, min((int)b.size(), (int)c.size()-i))\n        c[i + j] = ((ll)a[i] * b[j] + c[i + j]) % mod;\n  } else {\n    int ord = 32 - __builtin_clz((int)c.size()-1);\n    if ((int)arr[0].size() != 1 << ord){\n      ran(i, 0, 4) arr[i].resize(1 << ord);\n    }\n    ran(i, 0, 4)\n      fill(arr[i].begin(), arr[i].end(), Comp{});\n    for (int &cur : a) if (cur < 0) cur += mod;\n    for (int &cur : b) if (cur < 0) cur += mod;\n    const int shift = 15;\n    const int mask = (1 << shift) - 1;\n    ran(i, 0, (int)min(a.size(), c.size())){\n      arr[0][i] += a[i] & mask;\n      arr[1][i] += a[i] >> shift;\n    }\n    ran(i, 0, (int)min(b.size(), c.size())){\n      arr[0][i] += Comp{0, (b[i] & mask)};\n      arr[1][i] += Comp{0, (b[i] >> shift)};\n    }\n    ran(i, 0, 2) fft(arr[i], ord, false);\n    ran(i, 0, 2){\n      ran(j, 0, 2){\n        int tar = 2 + (i + j) / 2;\n        Comp mult = {0, -0.25};\n        if (i ^ j) mult = {0.25, 0};\n        ran(k, 0, 1<<ord){\n          int rev_k = ((1 << ord) - k) % (1 << ord);\n          Comp ca = arr[i][k] /*lp*/+/*rp*/ conj(arr[i][rev_k]);\n          Comp cb = arr[j][k] /*lp*/-/*rp*/ conj(arr[j][rev_k]);\n          arr[tar][k] = arr[tar][k] + mult * ca * cb;\n        }\n      }\n    }\n    ran(i, 2, 4){\n      fft(arr[i], ord, true);\n      ran(k, 0, (int)c.size()){\n        c[k] = (c[k] + (((ll)(arr[i][k]/*lp*/.real()/*rp*/+0.5)%mod)\n                    << (shift * (2 * (i-2) + /*lp*/0/*rp*/)))) % mod;\n        c[k] = (c[k] + (((ll)(arr[i][k]/*lp*/.imag()/*rp*/+0.5)%mod)\n                    << (shift * (2 * (i-2) + /*lp*/1/*rp*/)))) % mod;\n      }\n    }\n  }\n}\n\nconst int MOD = 1000000007;\n\ntypedef long long llong;\n\nstruct modint {\n  llong val;\n\n  modint () {\n    val = 0;\n  }\n\n  modint (llong _val) {\n    val = _val % MOD;\n  }\n};\n\nmodint operator+ (modint p, modint q) {\n  return modint((p.val + q.val) % MOD);\n}\n\nmodint operator- (modint p, modint q) {\n  return modint((p.val - q.val + MOD) % MOD);\n}\n\nmodint operator- (modint p) {\n  return modint(0) - p;\n}\n\nmodint operator* (modint p, modint q) {\n  return modint((p.val * q.val) % MOD);\n}\n\nmodint operator^ (modint p, int q) {\n  modint pows [30];\n\n  pows[0] = p;\n  for (int i = 1; i < 30; i++) {\n    pows[i] = pows[i - 1] * pows[i - 1];\n  }\n\n  modint ans (1);\n  for (int i = 0; i < 30; i++) {\n    if (q & 1 << i) {\n      ans = ans * pows[i];\n    }\n  }\n\n  return ans;\n}\n\nmodint inv (modint p) {\n  return p ^ (MOD - 2);\n}\n\nmodint operator/ (modint p, modint q) {\n  return p * (q ^ (MOD - 2));\n}\n\nconst int MAX_N = 6000005;\n\nmodint fact [MAX_N];\n\nint main () {\n  fact[0] = modint(1);\n  for (int i = 1; i < MAX_N; i++) {\n    fact[i] = fact[i - 1] * modint(i);\n  }\n\n  int N, M, K;\n  cin >> N >> M >> K;\n  N--;\n\n  vector<int> bobFact (M + K + 10, 0);\n  vector<int> charlieFact (M + K + 10, 0);\n\n  for (int i = 0; i <= M; i++) {\n    bobFact[i] = inv(fact[i]).val;\n  }\n\n  for (int i = 0; i <= K; i++) {\n    charlieFact[i] = inv(fact[i]).val;\n  }\n\n  vector<int> factArr (M + K + 10, 0);\n  mult_poly_mod(bobFact, charlieFact, factArr);\n\n  modint ans (0);\n  modint invfn = inv(fact[N]);\n  for (int u = 0; u <= M + K; u++) {\n    ans = ans + fact[N + u] * modint(factArr[u]) * (modint(3) ^ (M + K - u)) * invfn;\n  }\n  cout << ans.val << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nlong long MOD = 1000000007LL;\nlong long modpow[5000], fact[5000], inv[5000], factinv[5000];\nint n, m, p;\nvoid init() {\n\tfact[0] = 1;for (int i = 1; i < 4000; i++) fact[i] = 1LL * fact[i - 1] * i % MOD;\n\tinv[1] = 1; for (int i = 2; i < 4000; i++) inv[i] = 1LL * inv[MOD%i] * (MOD - MOD / i) % MOD;\n\tfactinv[0] = 1;for (int i = 1; i < 4000; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % MOD;\n}\nlong long ncr(long long n, long long r) {\n\treturn 1LL * fact[n] * factinv[r] % MOD * factinv[n - r] % MOD;\n}\nlong long dists(long long a, long long b, long long c) {\n\treturn (ncr(a + b + c, a)*ncr(b + c, b)) % MOD;\n}\nint main() {\n\tmodpow[0] = 1; for (int i = 1; i < 4000; i++) { modpow[i] = modpow[i - 1] * 3; modpow[i] %= MOD; }\n\tcin >> n >> m >> p; init();\n\tlong long sum = 0;\n\tfor (int i = 0; i <= m; i++) {\n\t\tfor (int j = 0; j <= p; j++) {\n\t\t\tsum += modpow[i + j] * dists(n - 1, m - i, p - j);\n\t\t\tsum %= MOD;\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "あせfvf"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct Combinatorics {\n  using int64 = long long;\n  const int64 mod = 1e9+7;\n  int64 fact[302020];\n  int64 invfact[302020];\n  Combinatorics() {\n    fact[0] = invfact[0] = 1;\n    for(int i = 1; i < 302020; ++i) {\n      fact[i] = fact[i-1]*i%mod;\n      invfact[i] = minv(fact[i]);\n    }\n  }\n  int64 mpow(int64 x, int64 n) const {\n    int64 res = 1;\n    while(n > 0) {\n      if(n&1) res = res*x%mod;\n      x = x*x%mod;\n      n >>= 1;\n    }\n    return res;\n  }\n  int64 minv(int64 x) const {\n    return mpow(x, mod-2);\n  }\n  int64 mfact(int64 x) const {\n    return fact[x];\n  }\n  int64 C(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[r]%mod*invfact[n-r]%mod;\n  }\n  int64 P(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[n-r]%mod;\n  }\n}C;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M, K;\n  cin >> N >> M >> K;\n  vint dp(N+M+K+1);\n  dp[0] = 1;\n  for(int i = 0; i < N+M+K; ++i) {\n    dp[i+1] = dp[i]*2 + mod-C.C(i, M) + mod-C.C(i, K);\n    dp[i+1] %= mod;\n  }\n  vint pow3(N+M+K+1);\n  pow3[0] = 1;\n  for(int i = 0; i < N+M+K; ++i) pow3[i+1] = pow3[i]*3%mod;\n  int ans = 0;\n  for(int i = N; i <= N+M+K; ++i) {\n    ans += C.C(i-1, N-1)*pow3[N+M+K-i]%mod*dp[i-N]%mod;\n    ans %= mod;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9+7;\ntypedef long long LL;\nLL f[900015], r[900015];\nLL th[900015];\nLL inv(LL a){\n    LL ans = 1;\n    LL b = mod-2;\n    while(b){\n        if(b%2) ans = ans*a%mod;\n        a = a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\nLL C(int a, int b){\n    return f[a]*r[b]%mod*r[a-b]%mod;\n}\nint main(){\n    f[0] = r[0] = th[0] = 1;\n    for(int i=1;i<=900010;i++){\n        f[i] = f[i-1]*i%mod;\n        r[i] = inv(f[i]);\n        th[i] = th[i-1]*3%mod;\n    }\n    int n, m, k;\n    scanf(\"%d%d%d\", &n, &m, &k);\n    LL ans = 0, sum = 1, ll = 0, rr = 0;\n    for(int i=0;i<=m+k;i++){\n        int l = max(0, i-k), r = min(i, m);\n        if(ll < l) sum = (sum - C(i, ll) + mod)%mod, ll++;\n        if(rr > r) sum = (sum - C(i, rr) + mod)%mod, rr--;\n\n        LL res = C(i+n-1, n-1)*th[n+m+k-i-n]%mod*sum%mod;\n        ans = (ans + res)%mod;\n\n        sum = sum*2%mod;\n        if(ll != 0) sum = (sum + C(i, ll-1))%mod;\n        if(rr != i) sum = (sum + C(i, rr+1))%mod;\n        rr++;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef double db;\n#define ls(x) x<<1\n#define rs(x) x<<1|1\n#define low(x) (x&-x)\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define X first\n#define Y second\n#ifdef _DEBUG\n    const int N=1e6+10;\n#else\n    const int N=1e6+10;\n#endif\nconst ll mod=1e9+7;\ntemplate<typename T> inline T gcd(T a,T b){return !b?a:gcd(b,a%b);}\ntemplate<typename T> inline T q_pow(T a,T x){T ans=1,tmp=a;while(x){if(x&1)(ans*=tmp)%=mod;(tmp*=tmp)%=mod;x>>=1;}return ans;}\ntemplate<typename T> inline void re(T &N){int f=1;char c;while((c=getchar())< '0'||c> '9')if(c=='-')f=-1;N=c-'0';while((c=getchar())>='0'&&c<='9')N=N*10+c-'0';N*=f;}\nint m,n,k,t=1,st,en;\nll p[N];\nll mul[N],inv[N];\ninline ll C(int m,int n)\n{\n    if(m< 0||m> n)return 0;\n    return mul[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main()\n{\n    // freopen(\"data.txt\",\"r\",stdin);\n    p[0]=1;\n    for(int i=1;i< N;i++)p[i]=p[i-1]*3%mod;\n    inv[0]=mul[0]=1;\n    for(int i=1;i< N;i++)mul[i]=mul[i-1]*i%mod,inv[i]=q_pow(mul[i],mod-2);\n    re(n);re(m);re(k);\n    ll ans=0,s1=0,s2=0;\n    for(int i=0;i<=m+k;i++)\n    {\n        if(!i)s1=1;\n        else if(i<=m)(s1*=2)%=mod;\n        else s1=(((s1-C(m,i-1))*2+C(m,i-1))%mod+mod)%mod;\n\n        if(i-k> 0)(s2=s2*2+C(i-k-1,i-1))%=mod;\n\n        (ans+=C(n-1,n+i-1)*p[m+k-i]%mod*(s1-s2+mod)%mod)%=mod;\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nll mod=1e9+7;\nvoid add(ll &x,ll y){\n\tx+=y;\n\tx%=mod;\n}\nconst int M=1000000;\nll f[M+1],g[M+1],inv[M+1];\nvoid precalc(){\n\tf[0]=1;\n\trep1(i,M) f[i]=f[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=M;i++) inv[i]=mod-mod/i*inv[mod%i]%mod;\n\tg[0]=1;\n\trep1(i,M) g[i]=g[i-1]*inv[i]%mod;\n}\nll Comb(int x,int y){\n\treturn f[x]*g[y]%mod*g[x-y]%mod;\n}\n\n\nint A,B,C;\nll p3[M+1];\nint main(){\n\tprecalc();\n\tp3[0]=1;\n\trep1(i,M) p3[i]=p3[i-1]*3%mod;\n\tcin>>A>>B>>C;\n\tll ans=0;\n\tint pL,pR;\n\tll sum=0;\n\tfor(int last=A;last<=A+B+C;last++){\n\t\tint N=last-A;\n\t\tint L=max(0,N-C),R=min(B,N);\n\t\tif(L<=R){\n\t\t\tif(last==A){\n\t\t\t\tsum=1;\n\t\t\t}else{\n\t\t\t\tsum=sum*2+Comb(N-1,pL-1)+Comb(N-1,pR+1);\n\t\t\t\tif(pL+1==L) sum-=Comb(N,pL);\n\t\t\t\tif(pR==R) sum-=Comb(N,R+1);\n\t\t\t\tsum%=mod;\n\t\t\t}\n\t\t\tll c=Comb(last-1,A-1)*sum%mod*p3[A+B+C-last]%mod;\n\t\t\tadd(ans,c);\n\t\t}\n\t\tpL=L,pR=R;\n\t}\n\tif(ans<0) ans+=mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\n#define fi(a,b) for(int i=a;i<b;++i)\ntypedef long long ll;\n///////////////////\n\nint const N = 1e6 + 41;\nint const MOD = 1e9 + 7;\n\nint n, m, k;\nint f[N], invf[N];\nint th[N];\nint ans;\n\nvoid add(int &a, int b){\n\ta += b;\n\twhile(a >= MOD) a -= MOD;\n\twhile(a < 0) a += MOD;\n}\n\nint mul(int a, int b){\n\treturn (ll) a * b % MOD;\n}\n\nint bp(int x, int d){\n\tint res = 1;\n\twhile(d){\n\t\tif(d&1) res = mul(res, x);\n\t\td >>= 1;\n\t\tx = mul(x, x);\n\t}\n\treturn res;\n}\n\nint inv(int x){\n\treturn bp(x, MOD-2);\n}\n\nint dg[N];\n\nint getc(int n, int k){\n\tif(k > n) return 0;\n\tint res = f[n];\n\tres = mul(res, invf[k]);\n\tres = mul(res, invf[n-k]);\n\treturn res;\n}\n\nvoid init(){\n\tf[0] = 1;\n\tfi(1, N) f[i] = mul(f[i-1], i);\n\tfi(0, N) invf[i] = inv(f[i]);\n\tth[0] = 1;\n\tfi(1, N) th[i] = mul(th[i-1], 3);\n\tdg[0] = 1;\n\tint all = 1;\n\tint bad = 0;\n\tfi(1, m+k+1){\n\t\tall = mul(all, 2);\n\t\tbad = mul(bad, 2);\n\t\tint b0 = getc(i-1, k);\n\t\tadd(bad, b0);\n\t\tint b1 = getc(i-1, m);\n\t\tadd(bad, b1);\n\t\tdg[i] = all;\n\t\tadd(dg[i], -bad);\n\t}\n}\n\nvoid solve(){\n\tint x = n + m + k;\n\tfi(n, x+1){\n\t\tint f = getc(i-1, n-1);\n\t\tint g = dg[i-n];\n\t\tint t = th[x-i];\n\t\tadd(ans, mul(f, mul(g, t)));\n\t}\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\n\tinit();\n\n\tsolve();\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n\treturn ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n\treturn ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n\tint ans = 1 , base = a ;\n\twhile( b ) {\n\t\tif( b&1 ) ans = mul( ans , base ) ;\n\t\tbase = mul( base , base ) ; \n\t\tb >>= 1 ;\n\t}\n\treturn ans ;\n}\n\nll inv( ll x ) {\n\treturn power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n\treturn ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n\tscanf( \"%d%d%d\" , &n , &m , &k ) ;\n\tfac[ 0 ] = 1ll ;\n\tp[ 0 ] = 1ll ;\n\tfor( int i = 1 ; i < N ; i ++ ) {\n\t\tfac[ i ] = fac[ i - 1 ] * i % mod ;\n\t\tp[ i ] = p[ i - 1 ] * 3ll % mod ;\n\t}\n\tfor( int i = 0 ; i < N ; i ++ ) {\n\t\tifac[ i ] = inv( fac[ i ] ) ;\n\t}\n\tll ans = 0 , x = 1ll ;\n\tn -- ;\n\tif( m < k ) swap( m , k ) ;\n\tfor( int i = 0 ; i <= m + k ; i ++ ) {\n\t\tans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n\t\t/*\n\t\tfor( int j = 0 ; j <= min( i , m  ) ; j ++ ) {\n\t\t\tif( i - j > k || i - j < 0 ) break ;\n\t\t\tx = add( x , C( i , j ) ) ;\n\t\t}\n\t\t*/\n\t\tif( i < k ) x = ( x * 2ll ) % mod ;\n\t\telse if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n\t\telse  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n\t}\n\tprintf( \"%lld\\n\" , add( ans , mod ) ) ;\n\treturn 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstring s;\n \ntypedef long long ll;\n \nll dp(ll at, ll c, ll sum)\n{\n\tc = c * 10 + s[at]-'0';\n\tif (at == s.length() - 1) return sum + c;\n\treturn dp(at + 1, c, sum) + dp(at + 1, 0, sum + c);\n}\n \nint main()\n{\n\tcin >> s;\n\tcout << dp(0ll, 0ll, 0ll) << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef ONLINE_JUDGE\n#define freopen \\\n  if (0) freopen\n#define cerr \\\n  if (0) cerr\n#endif\n\n#define fi first\n#define se second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n\n#define sqr(a) ((a)*1ll * (a))\n#define sz(a) (int)a.size()\n#define len(a) (int)a.length()\n#define all(a) a.begin(), a.end()\n#define nl '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nint n, m, k;\nint cnt[3];\nll res;\nint tmp;\n\nvoid dfs(int cur) {\n  if (cnt[cur] == 0) {\n    tmp++;\n    if (cur == 0) {\n      ll mul = 1;\n      rep(i, 0, 2) {\n        mul *= pow(3, cnt[i]);\n      }\n      res += mul;\n    }\n    return;\n  }\n\n  rep(i, 0, 2) {\n    cnt[cur]--;\n    dfs(i);\n    cnt[cur]++;\n  }\n}\n\n\nvoid solve() {\n  cin >> n >> m >> k;\n  cnt[0] = n;\n  cnt[1] = m;\n  cnt[2] = k;\n  dfs(0);\n  cout << res;\n  cout << nl << tmp;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  freopen(\".in\", \"r\", stdin);\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nLL t[3100],C[3100][3100];\nvoid ADD(LL &x,LL v){x=(x+v)%MOD;}\nint main(){\n REP(i,3100){\n  t[i]=i?(t[i-1]*3%MOD):1;\n  C[i][0]=1;\n  REPP(j,1,i+1)C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;\n }\n DRIII(N,M,K);\n if(N>1000||M>1000||K>1000)return 0;\n LL an=0;\n REP(i,M+1)REP(j,K+1){\n  ADD(an,C[N-1+j+i][N-1]*C[i+j][i]%MOD*t[M+K-i-j]);\n }\n cout<<an<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000010;\nconst int M = 1000000;\nconst int P = 1e9 + 7;\n\nint n, m, k;\nint fac[N], inv[N], power[N];\n\nint Power(int x, int k) {\n\tif (k == 1) return x;\n\tint ret = Power(x, k >> 1);\n\tret = 1LL * ret * ret % P;\n\tif (k & 1) ret = 1LL * ret * x % P;\n\treturn ret;\n}\n\nvoid Init() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= M; i++) {\n\t\tfac[i] = 1LL * fac[i - 1] * i % P;\n\t}\n\tinv[M] = Power(fac[M], P - 2);\n\tfor (int i = M - 1; i >= 0; i--) {\n\t\tinv[i] = 1LL * inv[i + 1] * (i + 1) % P;\n\t}\n\tpower[0] = 1;\n\tfor (int i = 1; i <= M; i++) {\n\t\tpower[i] = 1LL * power[i - 1] * 3 % P;\n\t}\n}\n\nint C(int n, int m) {\n\tif (n < m) return 0;\n\treturn 1LL * fac[n] * inv[m] % P * inv[n - m] % P; \n}\n\nint main() {\n\tInit();\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tint ansL = 1, ans = 0;\n\tfor (int L = n; L <= n + m + k; L++) {\n\t\tans += 1LL * ansL * C(L - 1, n - 1) % P * power[n + m + k - L] % P;\n\t\tif (ans >= P) ans -= P;\n\t\tansL <<= 1;\n\t\tif (ansL >= P) ansL -= P;\n\t\tansL -= (C(L - n, m) + C(L - n, k)) % P;\n\t\tif (ansL < 0) ansL += P;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\nconst int MX = 300010;\n\nint N, M, K;\nll p3[MX], fact[MX], ifact[MX], inv[MX];\n\nll comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\nint main() {\n    inv[1] = 1;\n    for (int i = 2; i < MX; ++i) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = ifact[0] = p3[0] = 1;\n    for (int i = 1; i < MX; ++i) {\n    \tp3[i] = p3[i-1] * 3 % MOD;\n        fact[i] = fact[i-1] * i % MOD;\n        ifact[i] = ifact[i-1] * inv[i] % MOD;\n    }\n\n\tcin >> N >> M >> K;\n\n\tif (M > K) {\n\t\tswap(M, K);\n\t}\n\n\tll ret = 0;\n\tll la = -1;\n\tll p2 = 1;\n\n\tfor (int t = N; t <= N + M + K; ++t) {\n\t\tll u = 0;\n\n\t\tint tt = t - N;\n\n\t\tif (tt <= M) {\n\t\t\tu = p2;\n\n\t\t\tif (tt == M) {\n\t\t\t\tla = p2;\n\t\t\t} else {\n\t\t\t\tp2 = p2 * 2 % MOD;\n\t\t\t}\n\t\t} else if (tt <= K) {\n\t\t\tla = la * 2 % MOD;\n\t\t\tla = (la - comb(tt-1, M)) % MOD;\n\t\t\tif (la < 0) la += MOD;\n\t\t\tu = la;\n\t\t} else {\n\t\t\tla = la * 2 % MOD;\n\t\t\tla = (la - comb(tt-1, M)) % MOD;\n\t\t\tla = (la - comb(tt-1, K)) % MOD;\n\t\t\tif (la < 0) la += MOD;\n\t\t\tu = la;\n\t\t}\n\n\t\tu = u * p3[N + M + K - t] % MOD * comb(t-1, N-1);\t\n\t\tret = (ret + u) % MOD;\n\t}\n\n\tcout << ret << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n❤️❤️❤️I_love_QMsh❤️❤️❤️\n*/\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define x first\n#define y second\n\nusing namespace std;\nusing namespace __gnu_pbds; // gp_hash_table<int, int> table;\n\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set; // <int> .find_by_order(int) .order_of_key(int)\n\ntemplate<typename T> bool smin(T &a, const T &b) { bool ret = b < a; return a = (ret ? b : a), ret; }\ntemplate<typename T> bool smax(T &a, const T &b) { bool ret = a < b; return a = (ret ? b : a), ret; }\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n\nmt19937 rnd;\n\nconst int M = (int)1e9 + 7;\n\nint ml(int a, int b) {\n  return 1ll * a * b % M;\n}\n\nint sm(int a, int b) {\n  a += b;\n  if (a >= M) {\n    a -= M;\n  }\n  return a;\n}\n\nint bpow(int a, int st) {\n  if (st < 0) {\n    st += M - 1;\n  }\n  int res = 1;\n  while (st) {\n    if (st & 1) {\n      res = ml(res, a);\n    }\n    a = ml(a, a);\n    st /= 2;\n  }\n  return res;\n}\n\nconst int N = 3e5 + 10;\nint f[3 * N];\nint fi[3 * N];\nint st3[3 * N];\n\nsigned main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n  f[0] = fi[0] = st3[0] = 1;\n\n  for (int i = 1; i < 3 * N; i++) {\n    f[i] = ml(f[i - 1], i);\n    fi[i] = bpow(f[i], -1);\n    st3[i] = ml(st3[i - 1], 3);\n  }\n\n  int n, m, k;\n  cin >> n >> m >> k;\n  n--;\n\n  int ans = 0;\n  for (int i = 0; i <= m; i++) {\n    int cur = 0;\n    for (int j = 0; j <= k; j++) {\n      cur = sm(cur, ml(ml(ml(f[n + i + j], fi[n]), fi[j]), st3[m + k - i - j]));\n    }\n    ans = sm(ans, ml(cur, fi[i]));\n  }\n\n  cout << ans << '\\n';\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n#else\n\t#define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e8;\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RBP(i,a) for(auto& i : a)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\n#define rangej(a,b,c) ((a) <= (c) and (c) < (b))\n#define rrangej(b,c) rangej(0,b,c)\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nint main()\n{\n\tios_init();\n\tstring s;\n\tcin >> s;\n\tint n = SZ(s);\n\tLL ans = 0;\n\tREP(i,1<<(n-1)){\n\t\tLL num = 0;\n\t\tREP(j,n){\n\t\t\tnum *= 10;\n\t\t\tnum += s[j]-'0';\n\t\t\tif((i>>j)&1){\n\t\t\t\tans += num;\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t}\n\t\tans += num;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define long long LL\nconst int N=1000005;\nconst int M=1e9+7;\nint n,m,k,ans,f[N],v[N],sum;\nint fp(int x,int y){int s=1;\nfor(;y;y>>=1){if(y&1)s=1ll*s*x%M;\nx=1ll*x*x%M;}return s;}\nint C(int x,int y){\nreturn 1ll*f[x]*v[y]%M*v[x-y]%M;}\nsigned main(){scanf(\"%d%d%d\",&n,&m,&k);\nf[0]=v[0]=1;sum=n+m+k;\nfor(int i=1;i<=sum;i++)f[i]=1ll*f[i-1]*i%M;\nv[sum]=fp(f[sum],M-2);for(int i=sum-1;i;i--)\nv[i]=1ll*v[i+1]*(i+1)%M;if(m<k)swap(m,k);int q=1;\nfor(int i=n;i<=sum;i++){if(k+n>=i){\n(ans+=1ll*C(i-1,n-1)*fp(3,sum-i)%M*q%M)%=M;\nif(k+n!=i)q=q*2%M;}\nelse if(n+m>=i){q=q*2-C(i-n-1,k);q=(q%M+M)%M;\n(ans+=1ll*q*C(i-1,n-1)%M*fp(3,sum-i)%M)%=M;}\nelse{q=q*2-C(i-n-1,k);q=(q%M+M)%M;\nq=(q-C(i-n-1,i-n-m-1)+M)%M;\n(ans+=1ll*q*C(i-1,n-1)%M*fp(3,sum-i)%M)%=M;}\n}printf(\"%d\\n\",(ans+M)%M);return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, K, v[600009];\nconst int mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nint fac[1000009], inv[1000009], p3[1000009];\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = power (fac[lim], mod - 2);for (int i=lim - 1; i>=1; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &M, &K), Prec (900003), p3[0] = 1;\nfor (int i=1; i<=900000; i++)\n    p3[i] = add (add (p3[i - 1], p3[i - 1]), p3[i - 1]);\n/*for (int i=0; i<=M; i++)\n    for (int j=0; j<=K; j++)\n        adto (v[i + j], comb (i + j, i));*/\n/*\nsa consideram un dreptunghi cu un colt in (0, 0) si unul in (M, K)\npentru fiecare diagonala secundara, vrem sa stim numarul de drumuri\ncare duc in diagonala aia\n*/\nv[0] = 1;\nif (M > K) swap (M, K); ///M <= K\nfor (int i=1; i<=M + K; i++)\n{\n    v[i] = add (v[i - 1], v[i - 1]);\n    if (i > M) v[i] = subtract (v[i], comb (i - 1, M));\n    if (i > K) v[i] = subtract (v[i], comb (i - 1, K));\n}\nint ans = 0;\nfor (int i=0; i<=M + K; i++)\n{\n    v[i] = mul (v[i], p3[M + K - i]);\n    adto (ans, mul (v[i], comb (i + N - 1, N - 1)));\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define N 1000015\nconst int p=1e9+7;\nint n,m,k,f[N],finv[N],inv[N],bin[N];\ninline int C(int nn,int mm)\n{\n\tif(nn==mm||mm==0)return 1;\n\tif(nn<mm)return 0;\n\treturn 1ll*f[nn]*finv[mm]%p*finv[nn-mm]%p;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&k);if(m<k)swap(m,k);\n    f[0]=finv[0]=f[1]=finv[1]=inv[1]=bin[0]=1;bin[1]=3;\n    for(int i=2;i<=n+m+k;i++)\n    {bin[i]=3ll*bin[i-1]%p;\n    \tinv[i]=1ll*(p-p/i)*inv[p%i]%p;\n    \tf[i]=1ll*f[i-1]*i%p;finv[i]=1ll*finv[i-1]*inv[i]%p;\n\t}int ans=0;\n\tfor(int i=0;i<=m+k;i++)\n\t{\n\t\tint te=0;\n\t\tfor(int j=max(0,i-k);j<=min(i,m);j++)\n\t\t{\n\t\t\tte=(te+C(i,j))%p;\n\t\t}\n\t\tte=1ll*te*bin[m+k-i]%p*C(n+i-1,n-1)%p;\n\t\tans=(ans+te)%p;\n\t}printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nint read()\n{\n  char c=0;\n  int sum=0;\n  while (c<'0'||c>'9')\n    c=getchar();\n  while ('0'<=c&&c<='9')\n    sum=sum*10+c-'0',c=getchar();\n  return sum;\n}\nint n,m,k;\nlong long fac[1000001],invfac[1000001],L[1000001],U[1000001];\nlong long fast_pow(long long a,int b)\n{\n  if (b==0) return 1;\n  if (b&1) return fast_pow(a*a%mod,b/2)*a%mod;\n  else return fast_pow(a*a%mod,b/2);\n}\nlong long C(int x,int y)\n{\n  if (x<y) return 0;\n  return fac[x]*invfac[y]%mod*invfac[x-y]%mod;\n}\nlong long cnt,ans;\nint main()\n{\n  n=read(),m=read(),k=read();\n  fac[0]=1;\n  for (int i=1;i<=n+m+k;++i) fac[i]=fac[i-1]*i%mod;\n  invfac[n+m+k]=fast_pow(fac[n+m+k],mod-2);\n  for (int i=n+m+k-1;i>=0;--i) invfac[i]=invfac[i+1]*(i+1)%mod;\n  cnt=fast_pow(3,m+k)*invfac[n-1]%mod;\n  for (int d=0;d<=m+k;++d)\n    {\n      L[d]=max(d-k,0);\n      if (d==0) U[0]=(L[d]==0);\n      else\n\t{\n\t  if (L[d]==L[d-1])\n\t    U[d]=(U[d-1]*2%mod+C(d-1,L[d]-1)%mod-C(d-1,m)%mod)%mod;\n\t  else\n\t    U[d]=(U[d-1]*2%mod-C(d-1,L[d]-1)%mod-C(d-1,m)%mod)%mod;\n\t}\n      ans=(ans+fast_pow(3,mod-1-d)*fac[n-1+d]%mod*U[d]%mod*invfac[d]%mod)%mod;\n    }\n  printf(\"%lld\\n\",(ans*cnt%mod+mod)%mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\n\nusing C = complex<double>;\nnamespace std {\n  template<>\n  C& C::operator*=(const C& y) {\n    double a = this->real();\n    double b = this->imag();\n    double c = y.real();\n    double d = y.imag();\n    return *this=C(a*c-b*d, a*d+b*c);\n  }\n}\n\ntemplate<int B> // n <= 1<<B\nstruct FFT{\n  vector<int> m2[B+1];\n  vector<C> power[B+1];\n\n  FFT(){\n    rep(e, B+1){\n      int lim = 1 << e;\n      m2[e].resize(lim);\n      power[e].resize(lim);\n      rep(st, lim) power[e][st] = polar(1.0, M_PI*st/lim);\n      rep(i, e) rep(st, lim) if(st >> i & 1) m2[e][st] |= 1 << e-1-i;\n    }\n  }\n\n  void Dft(C *f, int lim) {\n    int e = 31 - __builtin_clz(lim);\n    assert(e <= B);\n    assert(1 << e == lim);\n    rep(st, lim) if(st < m2[e][st]) swap(f[st], f[m2[e][st]]);\n\n    rep(k, e) {\n      int t = 1 << k;\n      int w = 1 << k+1;\n      C *po = power[k].data();\n      for (int i=0; i<lim; i+=w) {\n        rep(j, t) {\n          C x = f[i+j];\n          C y = f[i+j+t] * po[j];\n          f[i+j] = x + y;\n          f[i+j+t] = x - y;\n        }\n      }\n    }\n  }\n\n  template <class T>\n  vector<C> Conv(vector<T> &f, vector<T> &g) {\n    int n = f.size() + g.size() - 1;\n    int lim = 2;\n    while (lim < n) lim <<= 1;\n    vector<C> cf(all(f));\n    vector<C> cg(all(g));\n    cf.resize(lim);\n    cg.resize(lim);\n    Dft(cf.data(), lim);\n    Dft(cg.data(), lim);\n    rep(i, lim) cf[i] = conj(cf[i] * cg[i])/double(lim);\n    Dft(cf.data(), lim);\n    // DO conj one more if you put complex numbers !!!\n    cf.resize(n);\n    return cf;\n  }\n\n  vector<LL> Conv2(vector<LL> &f, vector<LL> &g, LL mod) {\n    int n = f.size();\n    int m = g.size();\n    int lim = 2;\n    while (lim < n+m) lim <<= 1;\n\n    const int D = 3;\n    const int L = 10;\n    const int M = (1 << L) - 1;\n    vector<C> cs[D];\n    vector<C> ds[D];\n    vector<C> es[D];\n    rep(i, D) {\n      cs[i].resize(lim+10);\n      ds[i].resize(lim+10);\n      es[i].resize(lim+10);\n      rep(j, n) es[i][j].real(f[j] >> (i*L) & M);\n      rep(j, m) es[i][j].imag(g[j] >> (i*L) & M);\n      Dft(es[i].data(), lim);\n      rep(j, lim) {\n        int nj = (lim-j) & (lim-1);\n        cs[i][j] = es[i][j] + conj(es[i][nj]);\n        ds[i][j] = es[i][j] - conj(es[i][nj]);\n      }\n      es[i].assign(lim, C());\n    }\n\n    rep(i, D) {\n      rep(j, D) {\n        rep(k, lim) {\n          int r = (i+j) >> 1;\n          int m = (i+j) % 2;\n          es[r][k] += cs[i][k] * ds[j][k] * polar(0.25, (m-1) * M_PI/2);\n        }\n      }\n    }\n\n    rep(i, D) {\n      rep(j, lim) es[i][j] = conj(es[i][j])/double(lim);\n      Dft(es[i].data(), lim);\n    }\n\n    vector<LL> ret(n+m-1);\n    rep(j, ret.size()) {\n      LL mul = 1;\n      rep(i, D*2-1) {\n        LL v;\n        if (i%2) {\n          v = llround(-es[i/2][j].imag()) % mod;\n        } else {\n          v = llround(es[i/2][j].real()) % mod;\n        }\n        ret[j] += v * mul;\n        ret[j] %= mod;\n        mul <<= L;\n        mul %= mod;\n      }\n    }\n    return ret;\n  }\n};\nFFT<20> fft;\n\n// [1, N] の法Pによる逆元をO(N)で列挙\nvector<LL> CalcModInvs(int n, LL p) {\n  vector<LL> inv(n+1);\n  inv[1]=1;\n  reps(i, 2, n+1) inv[i] = (p-(p/i*inv[p%i])%p)%p;\n  return inv;\n}\n\nint N, M, K;\nLL finv[314514];\nLL pw3[1145141];\nLL fact[1145141];\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  auto invs = CalcModInvs(314514, MOD);\n  pw3[0] = fact[0] = 1;\n  reps(i, 1, 1145141) {\n    fact[i] = fact[i-1]*i % MOD;\n    pw3[i] = pw3[i-1]*3 % MOD;\n  }\n  finv[0] = 1;\n  reps(i, 1, 314514) {\n    finv[i] = finv[i-1]*invs[i] % MOD;\n  }\n\n  cin >> N >> M >> K;\n  vector<LL> A(M+1);\n  vector<LL> B(K+1);\n  rep(i, M+1) {\n    A[i] = finv[i];\n  }\n  rep(i, K+1) {\n    B[i] = finv[i];\n  }\n\n  auto C = fft.Conv2(A, B, MOD);\n  LL ans = 0;\n  rep(S, M+K+1) {\n    ans += pw3[M+K-S] * fact[N-1+S] % MOD * finv[N-1] % MOD * C[S];\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Mod = 1e9 + 7;\nconst int N = 9e5;\n\nint n, m, k;\nlong long fac[N], vfac[N];\n\nlong long mpow( long long a, int b ) {\n\tlong long rt;\n\tfor( rt = 1; b; b >>= 1, a = (a * a) % Mod )\n\t\tif( b & 1 ) rt = (rt * a) % Mod;\n\treturn rt;\n}\nvoid init( int n ) {\n\tfac[0] = 1;\n\tfor( int i = 1; i <= n; i++ )\n\t\tfac[i] = (fac[i-1] * i) % Mod;\n\tvfac[n]  = mpow( fac[n], Mod - 2 );\n\tfor( int i = n - 1; i >= 0; i-- )\n\t\tvfac[i] = vfac[i+1] * (i + 1) % Mod;\n}\nlong long comb( int n, int m ) {\n\treturn fac[n] * vfac[n-m] % Mod * vfac[m] % Mod;\n}\nint main() {\n\tscanf( \"%d%d%d\", &n, &m, &k );\n\tif( m < k ) swap( m, k );\n\tinit( m + k + n );\n\tlong long sum = 0, ans = 0;\n\tfor( int s = 0; s <= m + k; s++ ) {\n\t\tif( s == 0 ) {\n\t\t\tsum = 1;\n\t\t} else if( s <= k ) {\n\t\t\tsum = (sum<<1) % Mod;\n\t\t} else if( s <= m ) {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1)) % Mod;\n\t\t} else {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1) + Mod - comb(s-1,m)) % Mod;\n\t\t}\n\t\tlong long sub = sum * comb(n-1+s,n-1) % Mod * mpow(3,m+k-s) % Mod;\n\t\tans = (ans + sub) % Mod;\n//\t\tprintf( \"s = %d sub = %lld\\n\", s, sub );\n\t}\n\tprintf( \"%lld\\n\", ans );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nstruct Comb {\n    int N;\n    vector<mint> fac, ifac, inv;\n\n    Comb(int _n=1) {\n        resize(2);\n        fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;\n        N = 1; grow(_n);\n    }\n\n    void resize(int _s) {\n        fac.resize(_s); ifac.resize(_s); inv.resize(_s);\n    }\n    bool grow(int _n) {\n        if (_n <= N) return false;\n        swap(_n, N); resize(N+1);\n        for (int i = _n+1; i <= N; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n        return true;\n    }\n    // perm\n    mint a(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k];\n    }\n    // choose\n    mint c(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k] * ifac[k];\n    }\n    // sum x = s, x > 0\n    mint p(int s, int k) {\n        return c(s-1, k-1);\n    }\n    // sum x = s, x >= 0\n    mint z(int s, int k) {\n        return p(s+k, k);\n    }\n    // \\E Y-X >= m\n    mint hit(int n, int k, int m=1) {\n        if (m <= k-n) return c(n+k, n);\n        return c(n+k, k-m);\n    }\n    // catalan trapezoids C_m(n, k)\n    // \\A Y-X < m,  =c(n+k,n) - hit\n    mint cat(int n, int k, int m=1) {\n        if (m > k) return c(n+k, n);\n        if (m <= k-n) return 0;\n        return c(n+k,n) - c(n+k, k-m);\n    }\n}c(1e6);\nconst int N = 1e6; \nmint pw[N];\n\nvoid solve() {\n    pw[0] = 1;\n    for (int i = 1; i < N; i++) {\n        pw[i] = pw[i-1] * 3;\n    }\n    int n,m,k;\n    cin >> n >> m >> k;\n    mint res = 0;\n    mint sum = 1;\n    int l = 0, r = 0;\n    for (int i = 0; i <= m+k; i++) {\n        mint tmp = c.c(n-1+i, i);\n        res += tmp * sum * pw[m+k-i];\n        sum *= 2; sum += c.c(i, ++r); sum += c.c(i, l-1);\n        if (r > m) {\n            assert(r == m+1);\n            sum -= c.c(i+1, r--);\n        }\n        if (i+1-l > k) {\n            assert(i+1-l == k+1);\n            sum -= c.c(i+1, l++);\n        }\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define mod 1000000007\n#define N 3010\nll fac[N],inv[N],ivf[N];\nvoid initmo(){\n    fac[0]=ivf[0]=inv[1]=1;\n    for(ll i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n}\nll po(ll x,ll y){\n    ll res=1;\n    for(;y;y>>=1){\n\tif(y&1)res=res*x%mod;\n\tx=x*x%mod;\n    }\n    return res;\n}\nint main(){\n    initmo();\n  ll a,b,c;cin>>a>>b>>c; a--; if(a>N||b>N||c>N)return 0;\n  ll ans=0;\n  for(ll k=a;k<=a+b+c;k++){\n      for(ll t=0;t<=b;t++){\n\t  ll r=k-a-t; if(not(0<=r&&r<=c))continue;\n\t  ll cur=fac[k]*po(3,a+b+c-k)%mod;\n\t  cur=cur*ivf[a]%mod;\n\t  cur=cur*ivf[t]%mod;\n\t  cur=cur*ivf[r]%mod;\n\t  ans=(ans+cur)%mod;\n      }\n  }\n  cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2) \n#include<bits/stdc++.h>\n#define rg register\n#define il inline\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nconst int O=900010;\nint n,m,k;\nll fac[O],inv[O],bin[O],ans,x=1;\nil ll C(int xx,int yy){return fac[xx]*inv[yy]%mod*inv[xx-yy]%mod;}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);n--;\n\tbin[0]=fac[0]=fac[1]=inv[0]=inv[1]=1ll;\n\tfor(int i=1;i<O;++i)bin[i]=bin[i-1]*3ll%mod;\n\tfor(int i=2;i<O;++i){\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tif(m<k)swap(m,k);\n\tfor(int i=2;i<O;++i)inv[i]=inv[i-1]*inv[i]%mod;\n\tfor(int i=0;i<=m+k;++i){\n\t\t(ans+=C(n+i,n)*bin[m+k-i]%mod*x%mod)%=mod;\n//\t\tprintf(\"%lld %lld %lld %lld\\n\",C(n+i,n),bin[m+k-i],x,ans<0?ans+mod:ans);\n\t\tif(i<k)(x*=2ll)%=mod;\n        else if(i<m)x=((x*2ll-C(i,k))%mod+mod)%mod;\n        else x=((x*2ll-C(i,k)-C(i,m))%mod+mod)%mod;\n\t}\n\tprintf(\"%lld\",ans<0?ans+mod:ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\nint power(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nint n,m,k;\nint fac[1000111],invf[1000111];\nint c(int x,int y){if(x<y||y<0)return 0;return 1ll*fac[x]*invf[y]%mod*invf[x-y]%mod;}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<1000111;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinvf[1000110]=power(fac[1000110],mod-2);\n\tfor(int i=1000109;i>=0;i--)invf[i]=1ll*invf[i+1]*(i+1)%mod;\n\t\n\tget3(n,m,k);\n\tint ans=0,cur=1;\n\tfor(int i=n;i<=n+m+k;i++)\n\t{\n\t\tans=(ans+1ll*c(i-1,n-1)*cur%mod*power(3,n+m+k-i))%mod;\n\t\tcur=(2ll*cur-c(i-n,m)+mod-c(i-n,i-n-k)+mod)%mod;\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 P = 1000000000ll + 7;\nint64 n,m,k;\nint64 fz[600010],fm[600010];\nint64 fb[600010],fc[600010];\nint64 mpow(int64 x, int64 y)\n{\n\tint64 tmp = x, ret = 1;\n\twhile(y)\n\t{\n\t\tif(y & 1) ret = ret * tmp % P;\n\t\ttmp = tmp * tmp % P;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\nint64 C(int x, int y)\n{\n\tif(x < y) return 0;\n\treturn fz[x] * fm[y] % P * fm[x - y] % P;\n}\nint main()\n{\n    cin >> n >> m >> k;\n    fz[0]=fm[0]=1;\n    for(int i = 1; i <= 100000; i++)\n\t\tfz[i] = fz[i - 1] * i %P, fm[i] = mpow(fz[i], P - 2);\n\tint64 ans = 0;\n\tfor(int i = n; i < n + m + k + 1; i++)\n\t{\n\t\tint64 cnt = C(i - 1, n - 1);\n\t\tfb[i] = (fb[i - 1] * 2 % P + C(i - (n + 1), i - n - (m + 1))) % P;\n\t\tfc[i] = (fc[i - 1] * 2 % P + C(i - (n + 1), i - n - (k + 1))) % P;\n\t\tans = (ans + cnt * ((mpow(2, i - n) - (fb[i] + fc[i]) % P) % P + P) % P * mpow(3, n + m + k - i) % P) % P;\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename T> constexpr T fpow_eq(T& x, ll y, T identity = 1) {\n    for(; y > 0; x *= x, y >>= 1) {\n        if(y & 1) {\n            identity *= x;\n        }\n    }\n    return x = identity;\n}\ntemplate <typename T> constexpr T fpow(T x, ll y, T identity = 1) { return fpow_eq(x, y, identity); }\n#ifndef __TOTIENT_INCLUDED_\n#define __TOTIENT_INCLUDED_\ntemplate <typename T, typename TEachDivisor, typename TEachPrime>\nconstexpr void factorize(T n, TEachDivisor each_divisor, TEachPrime each_prime = [](T) {}) {\n    static_assert(is_convertible<decltype(each_divisor), function<void(T)>>::value, \"each_divisor must be void(T)\");\n    static_assert(is_convertible<decltype(each_prime), function<void(T)>>::value, \"each_prime must be void(T)\");\n    for(T i = 2; i * i <= n; i++) {\n        if(n % i == 0) {\n            each_prime(i);\n            while(n % i == 0) {\n                each_divisor(i);\n                n /= i;\n            }\n        }\n    }\n    if(n > 1) {\n        each_divisor(n);\n        each_prime(n);\n    }\n}\ntemplate <typename T> constexpr T phi(T n) {\n    T ans = n;\n    factorize<T>(n, [](T) {}, [&](T p) { ans -= ans / p; });\n    return ans;\n}\n#endif\n#ifdef __TOTIENT_INCLUDED_\ntemplate <int M, int PHI_M = phi(M)> struct modint {\n#else\ntemplate <int M, int PHI_M> struct modint {\n#endif\n    static constexpr int MOD = M;\n    int val;\n    constexpr modint() : val(0) {}\n    constexpr modint(int val) : val(val % M) { this->val += this->val < 0 ? M : 0; }\n    constexpr modint(long long val) : modint(int(val % M)) {}\n    constexpr modint(const modint& m) : val(m.val) {}\n    constexpr modint(const complex<double>& x) : modint(llround(x.real())) {}\n    constexpr explicit operator int() const { return val; }\n    constexpr bool operator==(const modint& y) const { return val == y.val; }\n    constexpr bool operator!=(const modint& y) const { return val != y.val; }\n    constexpr bool operator< (const modint& y) const { return val <  y.val; }\n    constexpr bool operator<=(const modint& y) const { return val <= y.val; }\n    constexpr bool operator> (const modint& y) const { return val >  y.val; }\n    constexpr bool operator>=(const modint& y) const { return val >= y.val; }\n    constexpr modint& operator=(const modint& y) { val = y.val; return *this; }\n    constexpr modint& operator+=(const modint& y) { val += y.val; val -= val >= M ? M : 0; return *this; }\n    constexpr modint& operator-=(const modint& y) { val -= y.val; val += val <  0 ? M : 0; return *this; }\n    constexpr modint& operator*=(const modint& y) { val = ll(val) * y.val % M; return *this; }\n    constexpr modint& operator/=(const modint& y) { val = ll(val) * fpow(y, PHI_M - 1).val % M; return *this; }\n    constexpr modint& operator^=(ll y) { fpow_eq(*this, y); return *this; }\n    constexpr modint operator+(const modint& y) const { return modint(val) += y; }\n    constexpr modint operator-(const modint& y) const { return modint(val) -= y; }\n    constexpr modint operator*(const modint& y) const { return modint(val) *= y; }\n    constexpr modint operator/(const modint& y) const { return modint(val) /= y; }\n    constexpr modint operator^(ll y) const { return modint(val) ^= y; }\n    constexpr modint operator-() const { return modint(0) -= *this; }\n    constexpr modint operator~() const { return modint(1) /= *this; }\n    constexpr modint& operator++() { val = val == M - 1 ? 0 : val + 1; return *this; }\n    constexpr modint& operator--() { val = val == 0 ? M - 1 : val - 1; return *this; }\n    constexpr modint operator++(int) { modint m = *this; ++(*this); return m; }\n    constexpr modint operator--(int) { modint m = *this; --(*this); return m; }\n    friend constexpr modint operator+(long long x, const modint& y) { return modint(x) + y; }\n    friend constexpr modint operator*(long long x, const modint& y) { return modint(x) * y; }\n    friend constexpr modint operator-(long long x, const modint& y) { return modint(x) - y; }\n    friend constexpr modint operator/(long long x, const modint& y) { return modint(x) / y; }\n    friend ostream& operator<<(ostream& os, const modint& m) { return os << m.val; }\n    friend istream& operator>>(istream& is, modint& m) { ll val; is >> val; m = modint(val); return is; }\n};\nconstexpr int M = 1'000'000'007;\nusing mint = modint<M, M - 1>;\nmint operator\"\"_m(unsigned long long int x) { return mint(ll(x)); }\ntemplate <typename T = mint> T fact(int n) {\n    static vector<T> fac = {1};\n    while(fac.size() <= n) {\n        fac.push_back(fac.back() * int(fac.size()));\n    }\n    return fac[n];\n}\ntemplate <typename T = mint> T fact_inv(int n) {\n    static vector<T> inv_fac = {1};\n    while(inv_fac.size() <= n) {\n        inv_fac.push_back(inv_fac.back() / int(inv_fac.size()));\n    }\n    return inv_fac[n];\n}\nconst double PI = acos(-1);\ncomplex<double> w(int len, bool inverse) {\n    return polar<double>(1, (inverse ? -2 : 2) * (PI / len));\n}\nconstexpr int lg(int x) { return 31 - __builtin_clz(x); }\ntemplate <typename T> vector<T>& pad(vector<T>& a, int min_size) {\n    a.resize(2 << lg(min_size - 1));\n    return a;\n}\nint bit_reverse(int i, int n) {\n    int ans = 0;\n    for(int j = 0; j < lg(n); j++) {\n        ans |= i & (1 << j) ? 1 << (lg(n) - 1 - j) : 0;\n    }\n    return ans;\n}\ntemplate <typename T> vector<T>& fft(vector<T>& a, bool inverse = false) {\n    int n = a.size();\n    for(int i = 0; i < n; i++) {\n        if(i < bit_reverse(i, n)) {\n            swap(a[i], a[bit_reverse(i, n)]);\n        }\n    }\n    for(int len = 2; len <= n; len <<= 1) {\n        T W = w(len, inverse);\n        for(int i = 0; i < n; i += len) {\n            T root = 1;\n            for(int j = i; j < i + (len >> 1); j++) {\n                T u = a[j], t = root * a[j + (len >> 1)];\n                a[j] = u + t;\n                a[j + (len >> 1)] = u - t;\n                root *= W;\n            }\n        }\n    }\n    if(inverse) {\n        transform(a.begin(), a.end(), a.begin(), [n](T& ai) { return ai / T(n); });\n    }\n    return a;\n}\ntemplate <typename T> vector<T>& operator*=(vector<T>& a, vector<T>& b) {\n    fft(pad(a, a.size())); if(addressof(a) != addressof(b)) fft(pad(b, b.size()));\n    assert(a.size() == b.size());\n    transform(a.begin(), a.end(), b.begin(), a.begin(), multiplies<T>());\n    fft(a, true); if(addressof(a) != addressof(b)) fft(b, true);\n    return a;\n}\ntemplate <typename T> vector<T> operator*(vector<T> a, vector<T>& b) { return a *= b; }\ntemplate <int C = int(sqrt(mint::MOD) + 0.5)> vector<mint> operator*=(vector<mint>& a, vector<mint>& b) {\n    vector<complex<double>> a1(a.size()), a2(a.size()), b1(b.size()), b2(b.size());\n    transform(a.begin(), a.end(), a1.begin(), [](mint& ai) { return ai.val % C; });\n    transform(a.begin(), a.end(), a2.begin(), [](mint& ai) { return ai.val / C; });\n    transform(b.begin(), b.end(), b1.begin(), [](mint& bi) { return bi.val % C; });\n    transform(b.begin(), b.end(), b2.begin(), [](mint& bi) { return bi.val / C; });\n    vector<complex<double>> a1b1 = b1 * a1, &a2b1 = b1 *= a2, &a1b2 = a1 *= b2, &a2b2 = a2 *= b2;\n    for(int i = 0; i < a.size(); i++) {\n        a[i] = mint(a1b1[i]) + mint(a1b2[i]) * C + mint(a2b1[i]) * C + mint(a2b2[i]) * C * C;\n    }\n    return a;\n}\ntemplate <int C = int(sqrt(mint::MOD) + 0.5)> vector<mint> operator*(vector<mint> a, vector<mint>& b) { return a *= b; }\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<mint> a(m + k + 1);\n    for(int i = 0; i <= m + k; i++) {\n        a[i] = fact(n - 1 + i);\n    }\n    vector<mint> b(k + 1);\n    for(int j = 0; j <= k; j++) {\n        b[j] = fact_inv(j) * (3_m ^ (k - j));\n    }\n    reverse(b.begin(), b.end());\n    b.resize(a.size());\n    a *= b;\n    mint ans = 0;\n    for(int i = 0; i <= m; i++) {\n        ans += fact_inv(n - 1) * fact_inv(i) * (3_m ^ (m - i)) * a[k + i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n#include <iostream>\nusing namespace std;\nint A, B, C, pw[900009], fact[900009], inv[900009], finv[900009], mod = 1000000007;\nint comb(int x, int y) {\n\treturn y < 0 || x < y ? 0 : 1LL * fact[x] * finv[y] % mod * finv[x - y] % mod;\n}\nint main() {\n\tcin >> A >> B >> C;\n\tpw[0] = fact[0] = inv[1] = finv[0] = 1;\n\tfor (int i = 1; i <= A + B + C; i++) {\n\t\tif (i >= 2) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\t\tpw[i] = 3LL * pw[i - 1] % mod;\n\t\tfact[i] = 1LL * fact[i - 1] * i % mod;\n\t\tfinv[i] = 1LL * finv[i - 1] * inv[i] % mod;\n\t}\n\tint ret = 0, cur = 1;\n\tfor (int i = 0; i <= B + C; i++) {\n\t\tif (i > B) cur = (cur - comb(i - 1, B) + mod) % mod;\n\t\tif (i > C) cur = (cur - comb(i - 1, C) + mod) % mod;\n\t\tret = (ret + 1LL * pw[B + C - i] * cur % mod * comb(A + i - 1, A - 1)) % mod;\n\t\tcur = 2 * cur % mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod = 1e9 + 7;\ntypedef long long LL;\nLL f[900015], r[900015];\nLL th[900015];\nLL inv(LL a) {\n\tLL ans = 1;\n\tLL b = mod - 2;\n\twhile (b) {\n\t\tif (b % 2) ans = ans * a % mod;\n\t\ta = a * a % mod;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\nLL C(int a, int b) {\n\treturn f[a] * r[b] % mod * r[a - b] % mod;\n}\nint main() {\n\tf[0] = r[0] = th[0] = 1;\n\tfor (int i = 1; i <= 900010; i++) {\n\t\tf[i] = f[i - 1] * i % mod;\n\t\tr[i] = inv(f[i]);\n\t\tth[i] = th[i - 1] * 3 % mod;\n\t}\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tLL ans = 0, sum = 1, ll = 0, rr = 0;\n\tfor (int i = 0; i <= m + k; i++) {\n\t\tint l = max(0, i - k), r = min(i, m);\n\t\tif (ll < l) sum = (sum - C(i, ll) + mod) % mod, ll++;\n\t\tif (rr > r) sum = (sum - C(i, rr) + mod) % mod, rr--;\n\n\t\tLL res = C(i + n - 1, n - 1) * th[n + m + k - i - n] % mod * sum % mod;\n\t\tans = (ans + res) % mod;\n\n\t\tsum = sum * 2 % mod;\n\t\tif (ll != 0) sum = (sum + C(i, ll - 1)) % mod;\n\t\tif (rr != i) sum = (sum + C(i, rr + 1)) % mod;\n\t\trr++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "//  Copyright 2020 Nikita Golikov\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\nusing ui64 = uint64_t;\n\n#ifdef GOLIKOV\nmt19937_64 rng(566);\n#else\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n#endif\n\ntemplate <typename T>\nT rnd_helper(T from, T to, true_type) {\n  return uniform_int_distribution<T>(from, to)(rng);\n}\n\ntemplate <typename T>\nT rnd_helper(T from, T to, false_type) {\n  return uniform_real_distribution<T>(from, to)(rng);\n}\n\ntemplate <typename T>\nT rnd(T from, T to) {\n  return rnd_helper(from, to, is_integral<T>{});\n}\n\ntemplate <typename A, typename B, typename Cmp>\nbool set_min(A &x, B const &y, Cmp &&cmp) {\n  if (cmp(y, x)) {\n    x = y;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename A, typename B>\nbool set_min(A &x, B const &y) {\n  return set_min(x, y, less<typename common_type<A, B>::type>{});\n}\n\ntemplate <typename A, typename B>\nbool set_max(A &x, B const &y) {\n  return set_min(x, y, greater<typename common_type<A, B>::type>{});\n}\n\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace __gnu_pbds;\n\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag,\n                         tree_order_statistics_node_update>;\n\ntemplate <typename K, typename V>\nusing ordered_map = tree<K, V, less<K>, rb_tree_tag,\n                         tree_order_statistics_node_update>;\n\n//  https://codeforces.com/blog/entry/62393\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    // http://xorshift.di.unimi.it/splitmix64.c\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n\n  size_t operator()(uint64_t x) const {\n    static const uint64_t\n        FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n    return static_cast<size_t>(splitmix64(x + FIXED_RANDOM));\n  }\n};\n\n#ifdef __cpp_deduction_guides\ntemplate <typename F>\nstruct rec_fun {\n  F fun;\n\n  rec_fun(F&& fun_) : fun(std::forward<F>(fun_)) {}\n\n  template <typename... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return fun(*this, std::forward<Args>(args)...);\n  }\n};\n#endif\n\n#ifdef __cpp_inline_variables\ntemplate <typename T>\ninline constexpr auto type_min = numeric_limits<T>::min();\n\ntemplate <typename T>\ninline constexpr auto type_max = numeric_limits<T>::max();\n#endif\n\n//  fast alloc\n#if 0\nint const MAX_MEM = 1e8;\nint mpos = 0;\nchar mem[MAX_MEM];\nvoid* operator new(size_t n) {\n  mpos += n;\n  return (void*)(mem + mpos - n);\n}\nvoid operator delete (void*) noexcept {}\n#endif\n\n//  pragmas\n#if 0\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\ntemplate <int MOD>\nstruct modular {\n  int val{};\n\n  static int norm(i64 x) {\n    int res = -MOD <= x && x < MOD ? x : (int) (x % MOD);\n    if (res < 0) {\n      res += MOD;\n    }\n    return res;\n  }\n\n  modular() = default;\n  modular(int x, bool do_norm = false) : val(do_norm ? norm(x) : x) {}\n  modular(i64 x) : val(norm(x)) {}\n\n  int to_int() const {\n    return val;\n  }\n  modular& operator+=(modular other) {\n    val += other.val;\n    if (val >= MOD) {\n      val -= MOD;\n    }\n    return *this;\n  }\n  friend modular operator+(modular x, modular y) {\n    return x += y;\n  }\n  modular& operator-=(modular other) {\n    val -= other.val;\n    if (val < 0) {\n      val += MOD;\n    }\n    return *this;\n  }\n  friend modular operator-(modular x, modular y) {\n    return x -= y;\n  }\n  modular& operator++() {\n    if (++val == MOD) {\n      val = 0;\n    }\n    return *this;\n  }\n  modular& operator--() {\n    if (--val < 0) {\n      val = MOD - 1;\n    }\n    return *this;\n  }\n  friend modular operator*(modular x, modular y) {\n    return modular{(i64) x.val * y.val};\n  }\n  modular operator*=(modular other) {\n    return *this = *this * other;\n  }\n  friend bool operator==(modular x, modular y) {\n    return x.to_int() == y.to_int();\n  }\n  friend bool operator!=(modular x, modular y) {\n    return x.to_int() != y.to_int();\n  }\n  modular operator-() const {\n    return 0 - *this;\n  }\n  friend istream& operator>>(istream& in, modular& x) {\n    return in >> x.val;\n  }\n  friend ostream& operator<<(ostream& out, modular x) {\n    return out << x.val;\n  }\n  explicit operator bool() const {\n    return bool(val);\n  }\n};\n\ntemplate <int MOD>\nmodular<MOD> power(modular<MOD> x, i64 deg) {\n  if (!x) {\n    return !deg;\n  }\n  deg %= MOD - 1;\n  if (deg < 0) {\n    deg += MOD - 1;\n  }\n  modular<MOD> res = 1;\n  while (deg) {\n    if (deg & 1) {\n      res *= x;\n    }\n    x *= x;\n    deg /= 2;\n  }\n  return res;\n}\n\ntemplate <int MOD>\nmodular<MOD> inv(modular<MOD> x) {\n  return power(x, -1);\n}\n\ntemplate <int MOD>\nmodular<MOD> operator/(modular<MOD> x, modular<MOD> y) {\n  return x * inv(y);\n}\n\ntemplate <int MOD>\nmodular<MOD>& operator/=(modular<MOD>& x, modular<MOD> other) {\n  return x = x / other;\n}\n\nint const MOD = (int) 1e9 + 7;\nusing mint = modular<MOD>;\n\nint main() {\n#ifdef GOLIKOV\n  assert(freopen(\"in\", \"rt\", stdin));\n  auto _clock_start = chrono::high_resolution_clock::now();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m, k;\n  cin >> n >> m >> k;\n  int const MAX = n + m + k + 10;\n  vector<mint> fact(MAX);\n  fact[0] = 1;\n  for (int i = 1; i < MAX; ++i) {\n    fact[i] = fact[i - 1] * i;\n  }\n  vector<mint> ifact(MAX);\n  ifact.back() = inv(fact.back());\n  for (int i = MAX - 2; i >= 0; --i) {\n    ifact[i] = ifact[i + 1] * (i + 1);\n  }\n  auto choose = [&](int N, int M) -> mint {\n    if (M > N || M < 0 || N < 0) {\n      return 0;\n    }\n    return fact[N] * ifact[M] * ifact[N - M];\n  };\n  vector<mint> pw(MAX);\n  pw[0] = 1;\n  for (int i = 1; i < MAX; ++i) {\n    pw[i] = pw[i - 1] * 3;\n  }\n  mint ans;\n  --n;\n  mint cur = 0;\n  int L, R;\n  for (int s = 0; s <= m + k; ++s) {\n    auto coef = pw[m + k - s] * choose(n + s, s);\n    if (s == 0) {\n      cur = 1;\n      L = 0;\n      R = 0;\n    } else {\n      cur += cur;\n      cur -= choose(s - 1, R);\n      cur += choose(s - 1, L - 1);\n      if (s > k) {\n        cur -= choose(s, L++);\n      }\n      if (s <= m) {\n        cur += choose(s, ++R);\n      }\n    }\n    ans += coef * cur;\n  }\n  cout << ans << '\\n';\n\n#ifdef GOLIKOV\n  cerr << \"Executed in \" << chrono::duration_cast<chrono::milliseconds>(\n      chrono::high_resolution_clock::now()\n          - _clock_start).count() << \"ms.\" << endl;\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define all(v) (v).begin(),(v).end()\n \n#define PII pair<int,int>\n#define mp make_pair\n#define st first\n#define nd second\n#define pb push_back\n#define lint long long int\n#define VI vector<int>\n \n#define debug(x) {cerr <<#x <<\" = \" <<x <<endl; }\n#define debug2(x,y) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y <<endl; } \n#define debug3(x,y,z) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y << \", \" << #z << \" = \" << z <<endl; } \n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<endl; }}\n#define debugt(t,n) {{cerr <<#t <<\" = \"; FOR(it,0,(n)) cerr <<t[it] <<\", \"; cerr <<endl; }}\n \n#define make( x) int (x); scanf(\"%d\",&(x));\n#define make2( x, y) int (x), (y); scanf(\"%d%d\",&(x),&(y));\n#define make3(x, y, z) int (x), (y), (z); scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define make4(x, y, z, t) int (x), (y), (z), (t); scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define makev(v,n) VI (v); FOR(i,0,(n)) { make(a); (v).pb(a);} \n#define IOS ios_base::sync_with_stdio(0)\n#define HEAP priority_queue\n \n#define read( x) scanf(\"%d\",&(x));\n#define read2( x, y) scanf(\"%d%d\",&(x),&(y));\n#define read3(x, y, z) scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define read4(x, y, z, t) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define readv(v,n) FOR(i,0,(n)) { make(a); (v).pb(a);}\n \n \nusing namespace std;\n\nconst int max_n = 2e4 + 5;\n\nint mod = 1e9 + 7;\n\nint powmod(int a, int n) {\n\tif (n == 0) return 1;\n\tint sq = powmod(a, n/2);\n\tsq = (sq * 1LL * sq) % mod;\n\tif (n%2 == 0) return sq;\n\treturn (sq * 1LL * a) % mod;\n}\n\nint fac[max_n];\nint ifac[max_n];\nint p3[max_n];\n\nvoid solve() {\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tFOR(i,1,max_n - 1) fac[i] = (fac[i-1] * 1LL * i) % mod;\n\tFOR(i,1,max_n - 1) ifac[i] = powmod(fac[i], mod - 2);\n\tp3[0] = 1;\n\tFOR(i,1,max_n -1) p3[i] = (p3[i-1] * 3LL)%mod;\n\n\tmake3(a, b, c);\n\tb++; c++;\n\tint ans = 0;\n\tFOR(i, 0, b) FOR(j, 0, c) {\n\t\tint loc = fac[a-1 + i + j];\n\t\tloc = (loc * 1LL * ifac[i]) % mod;\n\t\tloc = (loc * 1LL * ifac[j]) % mod;\n\t\tloc = (loc * 1LL * ifac[a-1]) % mod;\n\t\tloc = (loc * 1LL * p3[b-1+c-1-i-j]);\n\t\tans = (ans + loc) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n\nint main() {\n\tint z = 1;\n\t// read(z);\n\twhile (z--) {\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,m,k;\nconst int FMAX = 1252521;\nll fact[FMAX];\nll ifact[FMAX];\nll tri[FMAX];\n\nll modpow(ll a,ll b,ll c){\n  ll r = 1;\n  while(b){\n    if(b&1)r=r*a%c;\n    a=a*a%c;\n    b>>=1;\n  }\n  return r;\n}\nll modinv(ll a,ll c){\n  return modpow(a,c-2,c);\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&m,&k);\n  assert(n<=1000 && m<=1000 && k<=1000);\n  // fact init\n  fact[0] = 1;\n  FOR(i,1,FMAX)fact[i]=fact[i-1]*i%MOD;\n  ifact[FMAX-1]=modinv(fact[FMAX-1],MOD);\n  FORR(i,0,FMAX-1)ifact[i]=ifact[i+1]*(i+1)%MOD;\n  // tri init\n  tri[0] = 1;\n  FOR(i,1,FMAX)tri[i]=tri[i-1]*3%MOD;\n  // a == n-1 && b <= m && c <= k\n  ll ans = 0;\n  int a = n-1;\n  FOR(b,0,m+1)FOR(c,0,k+1){\n    int abc = a+b+c;\n    int rest = n+m+k-abc-1;\n    ans += fact[abc]*ifact[a]%MOD*ifact[b]%MOD*ifact[c]%MOD*tri[rest]%MOD;\n    if(ans>=MOD)ans -= MOD;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//T+N\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate<class T, class T2> inline bool chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline bool chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst ll mod = 1e9 + 7;\ntemplate<class T> inline void fix(T &x) {if(x >= mod || x <= -mod) {x %= mod;} if(x < 0) {x += mod;}}\n#define out(x) cout << __LINE__ << \": \" << (#x) << \" = \" << (x) << endl\n\nconst ll MAX_N = 1e6 + 10;\nll perm[MAX_N], inv[MAX_N];\n\nll fpow(ll x, ll p) {\n    if(p == 0) {return 1;}\n    ll ans = fpow(x, p / 2);\n    ans = (ans * ans ) % mod;\n    if(p & 1) {\n        return (ans * x) % mod;\n    } else {\n        return ans;\n    }\n}\n\nll comb(ll k, ll n) {\n    if(k < 0 || n < 0) {return 0;}\n    if(n - k < 0) {return 0;}\n    return (((perm[n] * inv[n - k]) % mod) * inv[k]) % mod;\n}\n\nsigned main() {\n    //ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    perm[0] = inv[0] = 1;\n    for(ll i = 1; i < MAX_N; i ++) {\n        perm[i] = (perm[i - 1] * i) % mod;\n        inv[i] = (inv[i - 1] * fpow(i, mod - 2)) % mod;\n    }\n    ll n, m, k;\n    cin >> n >> m >> k;\n    ll rangel = 0, ranger = 0;\n    ll sum = 1;\n    ll ans = 0;\n    m ++;\n    k ++;\n    for(ll ij = 0; ij <= m + k - 2; ij ++) {\n        ll nwl = max(0ll, ij - m + 1);\n        ll nwr = min(m - 1, ij);\n        while(nwl < rangel) {\n            sum = (sum + comb(rangel - 1, ij)) % mod;\n            rangel --;\n        }\n        while(nwl > rangel) {\n            sum = (sum - comb(rangel, ij)) % mod;\n            rangel ++;\n        }\n        while(nwr > ranger) {\n            sum = (sum + comb(ranger + 1, ij)) % mod;\n            ranger ++;\n        }\n        while(nwr < ranger) {\n            sum = (sum - comb(ranger, ij)) % mod;\n            ranger --;\n        }\n        ll sum2 = 0;\n        for(ll i = nwl; i <= nwr; i ++) {\n            sum2 += comb(i, ij) ;\n          \tsum2 %= mod;\n        }\n        fix(sum);\n        ans += ((comb(n - 1, n - 1 + ij) * sum2) % mod) * fpow(3, m + k - 2 - ij);\n        fix(ans);\n        sum = (sum * 2) % mod;\n        sum += comb(ranger + 1, ij) + comb(rangel - 1, ij);\n        sum %= mod;\n        fix(sum);\n        fix(ans);\n        ranger ++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst LD kPi = 2 * acos(0);\nstruct CD {\n  LD re, im;\n  CD operator=(LD a) { re = a; im = 0; return *this; }\n  CD operator*(CD& z) { return {re * z.re - im * z.im, re * z.im + im * z.re}; }\n  void operator*=(CD& z) { *this = (*this * z); }\n  CD operator+(CD& z) { return {re + z.re, im + z.im}; }\n  CD operator-(CD& z) { return {re - z.re, im - z.im}; }\n  void operator/=(LD f) { re /= f; im /= f; }\n};\n\nstruct FFT {\nprivate:\n  CD *A, *B, *tmp, *res, *omega;\n  int *rev_perm;\n  int max_dep;\n  // not needed if this is going to be used just once\n  void Clear(int n) {\n    REP (i, n) { A[i] = B[i] = res[i] = tmp[i] = 0; }\n  }\n\n  void fft(CD* from, CD* to, int depth, bool inv){\n    int N = (1 << depth);\n    REP (i, N) { to[rev_perm[i] >> (max_dep - depth)] = from[i]; }\n\n    RE (m, depth) {\n      int step = (1 << m);\n      for (int pos = 0; pos < N; pos += step){\n        int cur = 0;\n        int delta = (1 << (max_dep - m));\n        if (!inv) { cur = (1 << max_dep); delta *= -1; }\n        REP (k, step / 2) {\n          CD a = to[pos + k],\n             b = omega[cur] * to[pos + k + step / 2];\n          to[pos + k] = a + b;\n          to[pos + k + step / 2] = a - b;\n          cur += delta;\n        }\n      }\n    }\n    if (inv) { REP (i, N) { to[i] /= N; } }\n  }\n  \npublic:\n  FFT(int max_deg) { // max degree of a polynomial given as input\n    max_dep = 0;\n    while ((1 << max_dep) <= 2 * max_deg) { max_dep++; }\n    max_deg = (1 << max_dep) + 20;\n    A = new CD[max_deg]; B = new CD[max_deg];\n    res = new CD[max_deg]; tmp = new CD[max_deg];\n    omega = new CD[max_deg]; rev_perm = new int[max_deg];\n    int N = (1 << max_dep);\n    LD ang = 2 * kPi / N;\n    REP (i, N + 1) { omega[i] = {cos(i * ang), sin(i * ang)}; }\n    rev_perm[0] = 0;\n    int h = -1;\n    RE (i, N) {\n      if ((i & (i - 1)) == 0) { h++; }\n      rev_perm[i] = rev_perm[i ^ (1 << h)] | (1 << (max_dep - h - 1));\n    }\n  }\n  VI mul_less_exact(VI Q, VI R, int P) {\n    int depth = 0, size = 1;\n    int N = SZ(Q) + SZ(R) - 1;\n    while (size < N) { depth++; size *= 2; }\n    Clear(size);\n    // start miejsca, w ktorym jak mozna mniejsza dokladnosc, to zmien na komentarze\n    // P,Q \\in R[x], A = Q * (1+i)/2 + R * (1-i)/2 -> Re(A^2) = P*Q\n    REP (i, SZ(Q)) \n      A[i] = CD{.5 * Q[i] + .5 * R[i], .5 * Q[i]-.5 * R[i]};\n    fft(A, tmp, depth, false);\n    REP (i, size) tmp[i] *= tmp[i];\n    //fft(A, res, depth, false);\n    //fft(B, tmp, depth, false);\n    //REP (i, size) tmp[i] *= res[i];\n    // koniec\n    fft(tmp, res, depth, true);\n    VI ans;\n    REP (i, N) { ans.PB((long long)round(res[i].re) % P); }\n    return ans;\n  }\n  \n  VI Prepare(VI& v, int base, int b_pow) {\n    VI ans;\n    for (int x : v) { ans.PB(b_pow ? x / base : x % base); }\n    return ans;\n  }\n  int Sum(VI& v, int P) { // debug/assert purposes only\n    return accumulate(ALL(v), 0LL) % P;\n  }\n  VI mul_exact(VI Q, VI R, int P) {\n    int base = 32000;\n    int pows[] = {1, base, (int)1LL * base * base % P};\n    VI ans(SZ(Q) + SZ(R) - 1);\n    REP (q, 2) {\n      VI W = Prepare(Q, base, q);\n      REP (r, 2) {\n        VI V = Prepare(R, base, r);\n        // jezeli bedzie za wolno, to można policzyc tylko 4 transformaty w przod\n        // bo teraz dla kazdej z 4 czesci jest liczona podwojnie (przyspieszenie * 2/3)\n        VI C = mul_less_exact(W, V, P);\n        REP (i, SZ(C)) { ans[i] = (ans[i] + 1LL * C[i] * pows[q + r]) % P; }\n      }\n    }\n    debug(Sum(ans, P), 1LL * Sum(Q, P) * Sum(R, P) % P);    // DEBUG!!\n    assert(Sum(ans, P) == 1LL * Sum(Q, P) * Sum(R, P) % P); // DEBUG!!\n    return ans;\n  }\n};\n\nint P = 1e9 + 7;\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w&1)\n      r = r * a % P;\n    w /= 2;\n    a =  a * a % P;\n  }\n  return r;\n}\nint odw(int a){\n  return pot(a,P-2);\n}\nconst int MAX = 1e6;\nint sil[MAX];\nint a,b,c;\n// FFT fft((int)(3e5)+2);\nint po(int a,int b){\n  if(b < 0 || a < b)return 0;\n  return sil[a] * odw(sil[b]) % P * odw(sil[a-b]) % P;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  sil[0] = 1;\n  for(int i = 1; i < MAX; i++)\n    sil[i] = sil[i-1] * i % P;\n  cin >> a >> b >> c;\n//   vector<int> x,y;\n//   R(i,b+1){\n//     x.PB(odw(sil[b-i]));\n//   }\n//   R(i,c+1){\n//     y.PB(odw(sil[c-i]));\n//   }\n//   debug(x,y);\n//   vector<int> spl = fft.mul_exact(x,y,P);\n//   debug(spl);\n  vector<int> spl;\n  spl.PB(1);\n  R(i,c+b){\n    int res = spl.back();\n    res *= 2;\n    res -= po(i,b);\n    res -= po(i,c);\n    res %= P;\n    res += P;\n    res %= P;\n    spl.PB(res);\n  }\n  //debug(spl);\n  \n  R(i,SZ(spl)){\n    spl[i] *= odw(sil[i]);\n    spl[i] %= P;\n  }\n  reverse(ALL(spl));\n  //debug(spl);\n  int res = 0;\n  int mn = odw(sil[a-1]);\n  R(i,SZ(spl)){\n    //debug(sil[a-1+b+c-i], mn,spl[i]);\n    res += sil[a-1+b+c-i] * mn % P * spl[i] % P;\n    //debug(res);\n    mn*=3;\n    mn%=P;\n  }\n  cout << res%P << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x7fffffff\n#define RG register\n#define maxn 1000005\n#define maxm 205\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\ninline ll read(){\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while(ch > '9' || ch < '0') {if(ch == '-') f = -1;ch = getchar();}\n    while(ch >= '0' && ch <= '9'){x = x *10 + ch -'0';ch = getchar();}\n    return x * f;\n}\n \nint n, m, k, po[2][maxn];\nint qpow(int a, int b){\n\tint ans = 1, base = a;\n\twhile(b){\n\t\tif(b & 1) ans = 1ll * ans * base % mod;\n\t\tbase= 1ll * base * base % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nint fac[maxn], inv[maxn], ans;\nint C(int n, int m){return 1ll * fac[n] * inv[m] % mod *inv[n - m] % mod;}\nint main(){\n\tint i, j, x, l, r, mid;\n\tfac[0] = po[0][0] = po[1][0] = 1;\n\tfor(i = 1;i <= maxn - 5;i++) fac[i] = 1ll * fac[i - 1] * i % mod, po[0][i] = po[0][i - 1] * 2ll % mod, po[1][i] = po[1][i - 1] * 3ll % mod;\n\tinv[maxn - 5] = qpow(fac[maxn - 5], mod - 2);\n\tfor(i = maxn - 6;i >= 0;i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; \n\tn = read(), m = read(), k = read();\n\tint las = 1;\n\tfor(i = 0;i <= m + k;i++){\n\t\tans = (ans + 1ll * C(n + i - 1, n - 1) * po[1][m + k -i] % mod * las % mod) % mod;\n\t\tif(i + 1 <= m && i + 1 <= k) las = las * 2ll % mod;\n\t\telse{\n\t\t\tif(i + 1 <= k) las = ((las * 2ll - C(i, m)) % mod + mod) % mod; \n\t\t\telse if(i + 1 <= m) las = ((las * 2ll - C(i, i - k)) % mod + mod) % mod;\n\t\t\telse las = (((las * 2ll - C(i, i - k)) % mod + mod - C(i, m) ) % mod + mod ) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int MAXN = 1000005;\n\nint mul (int x, int y) {return 1LL * x * y % MOD;}\nint add (int x, int y) {x += y; if (x >= MOD) return x - MOD; return x;}\nint sub (int x, int y) {x -= y; if (x < 0) return x + MOD; return x;}\n\nint a, b, c, sol;\nint fct[MAXN], inv[MAXN];\n\nint pot (int a, int e) {\n    int res = 1;\n    while (e > 0) {\n        if (e & 1) res = mul(res, a);\n        a = mul(a, a);\n        e /= 2;\n    }\n    return res;\n}\n\nvoid precompute () {\n    fct[0] = inv[0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n        fct[i] = mul(fct[i - 1], i);\n        inv[i] = pot(fct[i], MOD - 2);\n    }\n}\n\nint nck (int n, int k) {\n    return mul(fct[n], mul(inv[n - k], inv[k]));\n}\n\nvoid calc () {\n    if (b > c) swap(b, c);\n    int curr = 0, uk = 1;\n    for (int len = 0; len <= b + c; len++) {\n        int val = sub(uk, curr);\n        val = mul(val, nck(len + a - 1, a - 1));\n        val = mul(val, pot(3, b + c - len));\n        sol = add(sol, val);\n        uk = sub(add(uk, uk), nck(len, min(len, b)));\n        if (len < b) uk = add(uk, 1);\n        if (len == c) {\n            curr = 1;\n        } else if (len > c) {\n            curr = add(sub(add(curr, curr), nck(len, len - c - 1)), nck(len + 1, len - c));\n        }\n    }\n}\n\nint main () {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    precompute();\n    cin >> a >> b >> c;\n    calc();\n    cout << sol;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n#define AddMult(x, y, z) x = (x + (y) * (z)) % mod\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        initialize();\n    }\n\n    void initialize(){\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = modpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int nCr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n\n    int nPr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N, M, K; cin >> N >> M >> K;\n\n    int ans = 0;\n    Combination C(N + M + K, mod);\n    int c = 1;\n    REP(i, M + K + 1){\n        if(i > 0){\n            Mult(c, 2);\n            if(i - 1 >= M + 1) Add(c, C.nCr(i - 1, M + 1));\n            if(i - 1 - K - 1 >= 0) Add(c, C.nCr(i - 1, i - 1 - K - 1));\n            if(i >= M + 1) Add(c, mod - C.nCr(i, M + 1));\n            if(i - K - 1 >= 0) Add(c, mod - C.nCr(i, i - K - 1));\n        }\n        int tmp = (c * C.nCr(N - 1 + i, i)) % mod;\n        Add(ans, tmp * modpow(3, M + K - i, mod));\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,m,k;\nconst int FMAX = 1252521;\nll fact[FMAX];\nll ifact[FMAX];\nll tri[FMAX];\n\nll modpow(ll a,ll b,ll c){\n  ll r = 1;\n  while(b){\n    if(b&1)r=r*a%c;\n    a=a*a%c;\n    b>>=1;\n  }\n  return r;\n}\nll modinv(ll a,ll c){\n  return modpow(a,c-2,c);\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&m,&k);\n  assert(n<=1000 && m<=1000 && k<=1000);\n  // fact init\n  fact[0] = 1;\n  FOR(i,1,FMAX)fact[i]=fact[i-1]*i%MOD;\n  ifact[FMAX-1]=modinv(fact[FMAX-1],MOD);\n  FORR(i,0,FMAX-1)ifact[i]=ifact[i+1]*(i+1)%MOD;\n  // tri init\n  tri[0] = 1;\n  FOR(i,1,FMAX)tri[i]=tri[i-1]*3%MOD;\n  // a == n-1 && b <= m && c <= k\n  ll ans = 0;\n  int a = n-1;\n  FOR(s,0,m+k+1){\n    // c = s-b\n    // 0<=c<=k\n    // 0<=b<=m\n\n    // s-b>=0 -> b<=s\n    // s-b<=k -> b>=s-k\n    int abc = a+s;\n    int rest = n+m+k-abc-1;\n    ll unit = fact[abc]*ifact[a]%MOD*ifact[s]%MOD*tri[rest]%MOD;\n    ll add = 0;\n    int beg = max(s-k,0);\n    int end = min(s,m);\n    FOR(b,beg,end+1){\n      int c = s-b;\n      add += fact[b+c]*ifact[b]%MOD*ifact[c]%MOD;\n      if(add>=MOD)add-=MOD;\n    }\n    ans += unit*add%MOD;\n    if(ans>=MOD)ans-=MOD;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\nnamespace uint_util {\ntemplate<typename T> struct Utils {};\n\ntemplate<> struct Utils<uint32_t> {\n\tstatic void umul_full(uint32_t a, uint32_t b, uint32_t *lo, uint32_t *hi) {\n\t\tconst uint64_t c = (uint64_t)a * b;\n\t\t*lo = (uint32_t)c;\n\t\t*hi = (uint32_t)(c >> 32);\n\t}\n\tstatic  uint32_t umul_hi(uint32_t a, uint32_t b) {\n\t\treturn (uint32_t)((uint64_t)a * b >> 32);\n\t}\n\tstatic uint32_t mulmod_invert(uint32_t b, uint32_t n) {\n\t\treturn ((uint64_t)b << 32) / n;\n\t}\n\n\tstatic uint32_t umul_lo(uint32_t a, uint32_t b) {\n\t\treturn a * b;\n\t}\n\tstatic uint32_t mulmod_precalculated(uint32_t a, uint32_t b, uint32_t n, uint32_t bninv) {\n\t\tconst auto q = umul_hi(a, bninv);\n\t\tuint32_t r = a * b - q * n;\n\t\tif(r >= n) r -= n;\n\t\treturn r;\n\t}\n\n\tstatic uint32_t invert_twoadic(uint32_t x) {\n\t\tuint32_t i = x, p;\n\t\tdo {\n\t\t\tp = i * x;\n\t\t\ti *= 2 - p;\n\t\t} while(p != 1);\n\t\treturn i;\n\t}\n};\n\n}\n\nnamespace modnum {\n\ntemplate<typename NumType> struct ModNumTypes {\n\tusing Util = uint_util::Utils<NumType>;\n\n\ttemplate<int Lazy> struct LazyModNum;\n\n\t//x < Lazy * P\n\ttemplate<int Lazy>\n\tstruct LazyModNum {\n\t\tNumType x;\n\t\tLazyModNum() : x() {}\n\t\ttemplate<int L>\n\t\texplicit LazyModNum(LazyModNum<L> t) : x(t.x) { static_assert(L <= Lazy, \"invalid conversion\"); }\n\n\t\tstatic LazyModNum raw(NumType x) {\n\t\t\tLazyModNum r; r.x = x;\n\t\t\treturn r;\n\t\t}\n\n\t\ttemplate<int L>\n\t\tstatic LazyModNum *coerceArray(LazyModNum<L> *a) { return reinterpret_cast<LazyModNum*>(a); }\n\n\t\tbool operator==(LazyModNum that) const {\n\t\t\tstatic_assert(Lazy == 1, \"cannot compare\");\n\t\t\treturn x == that.x;\n\t\t}\n\t};\n\n\ttypedef LazyModNum<1> ModNum;\n\n\tclass ModInfo {\n\tpublic:\n\t\tenum {\n\t\t\tMAX_ROOT_ORDER = 23\n\t\t};\n\n\tprivate:\n\t\tNumType P, P2;\n\t\tModNum _one;\n\t\tNumType _twoadic_inverse;\n\t\tNumType _order;\n\t\tNumType _one_P_inv;\t//floor(W * (W rem P) / P)\n\n\t\tbool _support_fft;\n\t\tModNum _roots[MAX_ROOT_ORDER + 1], _inv_roots[MAX_ROOT_ORDER + 1];\n\t\tModNum _inv_two_powers[MAX_ROOT_ORDER + 1];\n\n\tpublic:\n\t\tNumType getP() const { return P; }\n\t\tNumType get_twoadic_inverse() const { return _twoadic_inverse; }\n\n\t\tModNum one() const { return _one; }\n\n\t\tModNum to_alt(NumType x) const {\n\t\t\treturn ModNum::raw(Util::mulmod_precalculated(x, _one.x, P, _one_P_inv));\n\t\t}\n\t\tNumType from_alt(ModNum x) const {\n\t\t\treturn _reduce(x.x, 0);\n\t\t}\n\n\t\tbool support_fft() const { return _support_fft; }\n\n\t\tModNum root(int n) const {\n\t\t\tassert(support_fft());\n\t\t\tif(n > 0) {\n\t\t\t\tassert(n <= MAX_ROOT_ORDER);\n\t\t\t\treturn _roots[n];\n\t\t\t} else if(n < 0) {\n\t\t\t\tassert(n >= -MAX_ROOT_ORDER);\n\t\t\t\treturn _inv_roots[-n];\n\t\t\t} else {\n\t\t\t\treturn one();\n\t\t\t}\n\t\t}\n\n\t\tModNum inv_two_power(int n) const {\n\t\t\tassert(support_fft());\n\t\t\tassert(0 <= n && n <= MAX_ROOT_ORDER);\n\t\t\treturn _inv_two_powers[n];\n\t\t}\n\n\t\tModNum add(ModNum a, ModNum b) const {\n\t\t\tauto c = a.x + b.x;\n\t\t\tif(c >= P) c -= P;\n\t\t\treturn ModNum::raw(c);\n\t\t}\n\n\t\tModNum sub(ModNum a, ModNum b) const {\n\t\t\tauto c = a.x + (P - b.x);\n\t\t\tif(c >= P) c -= P;\n\t\t\treturn ModNum::raw(c);\n\t\t}\n\n\t\tLazyModNum<4> add_lazy(LazyModNum<2> a, LazyModNum<2> b) const {\n\t\t\treturn LazyModNum<4>::raw(a.x + b.x);\n\t\t}\n\t\tLazyModNum<4> sub_lazy(LazyModNum<2> a, LazyModNum<2> b) const {\n\t\t\treturn LazyModNum<4>::raw(a.x + (P2 - b.x));\n\t\t}\n\n\t\tModNum mul(ModNum a, ModNum b) const {\n\t\t\tNumType lo, hi;\n\t\t\tUtil::umul_full(a.x, b.x, &lo, &hi);\n\t\t\treturn ModNum::raw(_reduce(lo, hi));\n\t\t}\n\t\tModNum sqr(ModNum a) const {\n\t\t\treturn mul(a, a);\n\t\t}\n\n\t\ttemplate<int LA, int LB>\n\t\tLazyModNum<2> mul_lazy(LazyModNum<LA> a, LazyModNum<LB> b) const {\n\t\t\tstatic_assert(LA + LB <= 5, \"too lazy\");\n\t\t\tNumType lo, hi;\n\t\t\tUtil::umul_full(a.x, b.x, &lo, &hi);\n\t\t\treturn LazyModNum<2>::raw(_reduce_lazy(lo, hi));\n\t\t}\n\n\t\tModNum pow(ModNum a, NumType k) const {\n\t\t\tLazyModNum<2> base{ a }, res{ one() };\n\t\t\twhile(1) {\n\t\t\t\tif(k & 1) res = mul_lazy(res, base);\n\t\t\t\tif(k >>= 1) base = mul_lazy(base, base);\n\t\t\t\telse break;\n\t\t\t}\n\t\t\treturn lazy_reduce_1(res);\n\t\t}\n\n\t\tModNum inverse(ModNum a) const {\n\t\t\treturn pow(a, _order - 1);\n\t\t}\n\n\t\t//a < 2P, res < P\n\t\tModNum lazy_reduce_1(LazyModNum<2> a) const {\n\t\t\tNumType x = a.x;\n\t\t\tif(x >= P) x -= P;\n\t\t\treturn ModNum::raw(x);\n\t\t}\n\t\t//a < 4P, res < 2P\n\t\tLazyModNum<2> lazy_reduce_2(LazyModNum<4> a) const {\n\t\t\tNumType x = a.x;\n\t\t\tif(x >= P2) x -= P2;\n\t\t\treturn LazyModNum<2>::raw(x);\n\t\t}\n\n\tprivate:\n\t\tNumType _reduce(NumType lo, NumType hi) const {\n\t\t\tconst auto q = Util::umul_lo(lo, _twoadic_inverse);\n\t\t\tconst auto h = Util::umul_hi(q, P);\n\t\t\tNumType t = hi + P - h;\n\t\t\tif(t >= P) t -= P;\n\t\t\treturn t;\n\t\t}\n\n\t\tNumType _reduce_lazy(NumType lo, NumType hi) const {\n\t\t\tconst auto q = Util::umul_lo(lo, _twoadic_inverse);\n\t\t\tconst auto h = Util::umul_hi(q, P);\n\t\t\treturn hi + P - h;\n\t\t}\n\n\tpublic:\n\t\tstatic ModInfo make(NumType P, NumType order = NumType(-1)) {\n\t\t\tModInfo res;\n\n\t\t\tres.P = P;\n\t\t\tres.P2 = P * 2;\n\t\t\tres._one.x = ~Util::umul_lo(Util::mulmod_invert(1, P), P) + 1;\n\t\t\tres._order = order == NumType(-1) ? P - 1 : order;\n\t\t\tres._twoadic_inverse = Util::invert_twoadic(P);\n\n\t\t\tres._one_P_inv = Util::mulmod_invert(res._one.x, P);\n\n\t\t\tres._support_fft = false;\n\n\t\t\tassert(res.mul(res.one(), res.one()) == res.one());\n\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic ModInfo make_support_fft(NumType P, NumType order, NumType original_root, int valuation) {\n\t\t\tModInfo res = make(P, order);\n\t\t\t_compute_fft_info(res, original_root, valuation);\n\t\t\treturn res;\n\t\t}\n\n\tprivate:\n\t\tstatic void _compute_fft_info(ModInfo &res, NumType original_root, int valuation) {\n\t\t\tassert(res.P <= 1ULL << (sizeof(NumType) * 8 - 2));\n\t\t\tassert(valuation >= MAX_ROOT_ORDER);\n\n\t\t\tres._support_fft = true;\n\n\t\t\tModNum max_root = res.to_alt(original_root);\n\t\t\tfor(int i = valuation; i > MAX_ROOT_ORDER; -- i)\n\t\t\t\tmax_root = res.sqr(max_root);\n\n\t\t\tres._roots[MAX_ROOT_ORDER] = max_root;\n\t\t\tfor(int i = MAX_ROOT_ORDER - 1; i >= 0; -- i)\n\t\t\t\tres._roots[i] = res.sqr(res._roots[i + 1]);\n\n\t\t\tres._inv_roots[MAX_ROOT_ORDER] = res.inverse(max_root);\n\t\t\tfor(int i = MAX_ROOT_ORDER - 1; i >= 0; -- i)\n\t\t\t\tres._inv_roots[i] = res.sqr(res._inv_roots[i + 1]);\n\n\t\t\tres._inv_two_powers[0] = res.one();\n\t\t\tres._inv_two_powers[1] = res.inverse(res.add(res.one(), res.one()));\n\t\t\tfor(int i = 1; i < MAX_ROOT_ORDER; ++ i)\n\t\t\t\tres._inv_two_powers[i] = res.mul(res._inv_two_powers[1], res._inv_two_powers[i - 1]);\n\n\t\t\tassert(res.mul(res._roots[1], res._inv_roots[1]) == res.one());\n\t\t\tassert(res.root(0) == res.one());\n\t\t\tassert(!(res.root(1) == res.one()));\n\t\t}\n\t};\n};\n\n}\n\nnamespace fft {\n\nusing namespace modnum;\n\nusing NumType = uint32_t;\n\nusing ModNumType = ModNumTypes<NumType>;\ntemplate<int Lazy>\nusing LazyModNum = ModNumType::LazyModNum<Lazy>;\nusing ModNum = ModNumType::ModNum;\nusing ModInfo = ModNumType::ModInfo;\n\nusing ModNumType32 = ModNumTypes<uint32_t>;\nusing ModNum32 = ModNumType32::ModNum;\nusing ModInfo32 = ModNumType32::ModInfo;\n\ninline __m128i mod_lazy_reduce_2_sse2(const __m128i &a, const __m128i &p2, const __m128i &signbit) {\n\tconst auto mask = _mm_cmpgt_epi32(_mm_xor_si128(p2, signbit), _mm_xor_si128(a, signbit));\n\tconst auto sub = _mm_andnot_si128(mask, p2);\n\treturn _mm_sub_epi32(a, sub);\n}\n\ninline __m128i mod_reduce_lazy_sse2(const __m128i &a, const __m128i &p, const __m128i &twoadic_inverse) {\n\tconst auto q = _mm_mul_epu32(a, twoadic_inverse);\n\tconst auto h = _mm_shuffle_epi32(_mm_mul_epu32(q, p), _MM_SHUFFLE(3, 3, 1, 1));\n\treturn _mm_add_epi32(a, _mm_sub_epi32(p, h));\n}\n\ninline __m128i mod_mul_lazy_sse2(const __m128i &a, const __m128i &b, const __m128i &p, const __m128i &twoadic_inverse) {\n\tconst auto a02 = _mm_shuffle_epi32(a, _MM_SHUFFLE(2, 2, 0, 0));\n\tconst auto a13 = _mm_shuffle_epi32(a, _MM_SHUFFLE(3, 3, 1, 1));\n\tconst auto b02 = _mm_shuffle_epi32(b, _MM_SHUFFLE(2, 2, 0, 0));\n\tconst auto b13 = _mm_shuffle_epi32(b, _MM_SHUFFLE(3, 3, 1, 1));\n\n\tconst auto prod02 = _mm_mul_epu32(a02, b02);\n\tconst auto prod13 = _mm_mul_epu32(a13, b13);\n\n\tconst auto res02 = mod_reduce_lazy_sse2(prod02, p, twoadic_inverse);\n\tconst auto res13 = mod_reduce_lazy_sse2(prod13, p, twoadic_inverse);\n\n\tconst auto shuffled02 = _mm_shuffle_epi32(res02, _MM_SHUFFLE(0, 0, 3, 1));\n\tconst auto shuffled13 = _mm_shuffle_epi32(res13, _MM_SHUFFLE(0, 0, 3, 1));\n\n\treturn _mm_unpacklo_epi32(shuffled02, shuffled13);\n}\n\ninline __m128i mod_mul_sse2(const __m128i &a, const __m128i &b, const __m128i &p, const __m128i &twoadic_inverse) {\n\t__m128i t = mod_mul_lazy_sse2(a, b, p, twoadic_inverse);\n\tconst auto mask = _mm_cmpgt_epi32(p, t);\t//signed compare\n\tconst auto sub = _mm_andnot_si128(mask, p);\n\treturn _mm_sub_epi32(t, sub);\n}\n\ninline __m128i mod_add_lazy_sse2(const __m128i &a, const __m128i &b) {\n\treturn _mm_add_epi32(a, b);\n}\ninline __m128i mod_sub_lazy_sse2(const __m128i &a, const __m128i &b, const __m128i &p2) {\n\treturn _mm_add_epi32(a, _mm_sub_epi32(p2, b));\n}\n\nvoid ntt_dit_lazy_core_sse2(LazyModNum<2> *f_inout, int n, int sign, const ModInfo &mod) {\n\tLazyModNum<4> * const f = LazyModNum<4>::coerceArray(f_inout);\n\n\tint N = 1 << n;\n\n\tif(n <= 1) {\n\t\tif(n == 0)\n\t\t\treturn;\n\n\t\tconst auto a = f_inout[0];\n\t\tconst auto b = f_inout[1];\n\n\t\tf_inout[0] = mod.lazy_reduce_2(mod.add_lazy(a, b));\n\t\tf_inout[1] = mod.lazy_reduce_2(mod.sub_lazy(a, b));\n\t\treturn;\n\t}\n\n\tif(n & 1) {\n\t\tfor(int i = 0; i < N; i += 2) {\n\t\t\tconst auto a = f_inout[i + 0];\n\t\t\tconst auto b = f_inout[i + 1];\n\n\t\t\tf[i + 0] = mod.add_lazy(a, b);\n\t\t\tf[i + 1] = mod.sub_lazy(a, b);\n\t\t}\n\t}\n\n\tif((n & 1) == 0) {\n\t\tconst auto imag = mod.root(2 * sign);\n\t\tfor(int i = 0; i < N; i += 4) {\n\t\t\tconst auto a0 = f_inout[i + 0];\n\t\t\tconst auto a2 = f_inout[i + 1];\n\t\t\tconst auto a1 = f_inout[i + 2];\n\t\t\tconst auto a3 = f_inout[i + 3];\n\n\t\t\tconst auto t02 = mod.lazy_reduce_2(mod.add_lazy(a0, a2));\n\t\t\tconst auto t13 = mod.lazy_reduce_2(mod.add_lazy(a1, a3));\n\n\t\t\tf[i + 0] = mod.add_lazy(t02, t13);\n\t\t\tf[i + 2] = mod.sub_lazy(t02, t13);\n\n\t\t\tconst auto u02 = mod.lazy_reduce_2(mod.sub_lazy(a0, a2));\n\t\t\tconst auto u13 = mod.mul_lazy(mod.sub_lazy(a1, a3), imag);\n\n\t\t\tf[i + 1] = mod.add_lazy(u02, u13);\n\t\t\tf[i + 3] = mod.sub_lazy(u02, u13);\n\t\t}\n\t} else {\n\t\tconst auto imag = mod.root(2 * sign);\n\t\tconst auto omega = mod.root(3 * sign);\n\n\t\tfor(int i = 0; i < N; i += 8) {\n\t\t\tconst auto a0 = mod.lazy_reduce_2(f[i + 0]);\n\t\t\tconst auto a2 = mod.lazy_reduce_2(f[i + 2]);\n\t\t\tconst auto a1 = mod.lazy_reduce_2(f[i + 4]);\n\t\t\tconst auto a3 = mod.lazy_reduce_2(f[i + 6]);\n\n\t\t\tconst auto t02 = mod.lazy_reduce_2(mod.add_lazy(a0, a2));\n\t\t\tconst auto t13 = mod.lazy_reduce_2(mod.add_lazy(a1, a3));\n\n\t\t\tf[i + 0] = mod.add_lazy(t02, t13);\n\t\t\tf[i + 4] = mod.sub_lazy(t02, t13);\n\n\t\t\tconst auto u02 = mod.lazy_reduce_2(mod.sub_lazy(a0, a2));\n\t\t\tconst auto u13 = mod.mul_lazy(mod.sub_lazy(a1, a3), imag);\n\n\t\t\tf[i + 2] = mod.add_lazy(u02, u13);\n\t\t\tf[i + 6] = mod.sub_lazy(u02, u13);\n\t\t}\n\n\t\tModNum w = omega, w2 = imag, w3 = mod.mul(w2, w);\n\n\t\tfor(int i = 1; i < N; i += 8) {\n\t\t\tconst auto a0 = mod.lazy_reduce_2(f[i + 0]);\n\t\t\tconst auto a2 = mod.mul_lazy(f[i + 2], w2);\n\t\t\tconst auto a1 = mod.mul_lazy(f[i + 4], w);\n\t\t\tconst auto a3 = mod.mul_lazy(f[i + 6], w3);\n\n\t\t\tconst auto t02 = mod.lazy_reduce_2(mod.add_lazy(a0, a2));\n\t\t\tconst auto t13 = mod.lazy_reduce_2(mod.add_lazy(a1, a3));\n\n\t\t\tf[i + 0] = mod.add_lazy(t02, t13);\n\t\t\tf[i + 4] = mod.sub_lazy(t02, t13);\n\n\t\t\tconst auto u02 = mod.lazy_reduce_2(mod.sub_lazy(a0, a2));\n\t\t\tconst auto u13 = mod.mul_lazy(mod.sub_lazy(a1, a3), imag);\n\n\t\t\tf[i + 2] = mod.add_lazy(u02, u13);\n\t\t\tf[i + 6] = mod.sub_lazy(u02, u13);\n\t\t}\n\t}\n\n\tfor(int m = 4 + (n & 1); m <= n; m += 2) {\n\t\tint M = 1 << m, M_4 = M >> 2;\n\t\tconst auto o = mod.root(m * sign), o2 = mod.root((m - 1) * sign), o4 = mod.root((m - 2) * sign);\n\n\t\tconst auto p = _mm_set1_epi32(mod.getP());\n\t\tconst auto p2 = _mm_set1_epi32(mod.getP() * 2);\n\t\tconst auto twoadic_inverse = _mm_set1_epi32(mod.get_twoadic_inverse());\n\t\tconst auto imag = _mm_set1_epi32(mod.root(2 * sign).x);\n\t\tconst auto omega = _mm_set1_epi32(o4.x);\n\t\tconst auto signbit = _mm_set1_epi32((int)(1U << 31));\n\n\t\t__m128i w = _mm_set_epi32(mod.mul(o, o2).x, o2.x, o.x, mod.one().x);\n\n\t\tfor(int j = 0; j < M_4; j += 4) {\n\t\t\tconst auto w2 = mod_mul_sse2(w, w, p, twoadic_inverse);\n\t\t\tconst auto w3 = mod_mul_sse2(w2, w, p, twoadic_inverse);\n\n\t\t\tfor(int i = j; i < N; i += M) {\n\t\t\t\tconst auto f0 = _mm_loadu_si128(reinterpret_cast<__m128i*>(f + i + M_4 * 0));\n\t\t\t\tconst auto f1 = _mm_loadu_si128(reinterpret_cast<__m128i*>(f + i + M_4 * 1));\n\t\t\t\tconst auto f2 = _mm_loadu_si128(reinterpret_cast<__m128i*>(f + i + M_4 * 2));\n\t\t\t\tconst auto f3 = _mm_loadu_si128(reinterpret_cast<__m128i*>(f + i + M_4 * 3));\n\n\t\t\t\tconst auto a0 = mod_lazy_reduce_2_sse2(f0, p2, signbit);\n\t\t\t\tconst auto a2 = mod_mul_lazy_sse2(f1, w2, p, twoadic_inverse);\n\t\t\t\tconst auto a1 = mod_mul_lazy_sse2(f2, w, p, twoadic_inverse);\n\t\t\t\tconst auto a3 = mod_mul_lazy_sse2(f3, w3, p, twoadic_inverse);\n\n\t\t\t\tconst auto t02 = mod_lazy_reduce_2_sse2(mod_add_lazy_sse2(a0, a2), p2, signbit);\n\t\t\t\tconst auto t13 = mod_lazy_reduce_2_sse2(mod_add_lazy_sse2(a1, a3), p2, signbit);\n\n\t\t\t\tconst auto r0 = mod_add_lazy_sse2(t02, t13);\n\t\t\t\tconst auto r2 = mod_sub_lazy_sse2(t02, t13, p2);\n\n\t\t\t\tconst auto u02 = mod_lazy_reduce_2_sse2(mod_sub_lazy_sse2(a0, a2, p2), p2, signbit);\n\t\t\t\tconst auto u13 = mod_mul_lazy_sse2(mod_sub_lazy_sse2(a1, a3, p2), imag, p, twoadic_inverse);\n\n\t\t\t\tconst auto r1 = mod_add_lazy_sse2(u02, u13);\n\t\t\t\tconst auto r3 = mod_sub_lazy_sse2(u02, u13, p2);\n\n\t\t\t\t_mm_storeu_si128(reinterpret_cast<__m128i*>(f + i + M_4 * 0), r0);\n\t\t\t\t_mm_storeu_si128(reinterpret_cast<__m128i*>(f + i + M_4 * 1), r1);\n\t\t\t\t_mm_storeu_si128(reinterpret_cast<__m128i*>(f + i + M_4 * 2), r2);\n\t\t\t\t_mm_storeu_si128(reinterpret_cast<__m128i*>(f + i + M_4 * 3), r3);\n\t\t\t}\n\n\t\t\tw = mod_mul_sse2(w, omega, p, twoadic_inverse);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; ++ i)\n\t\tf_inout[i] = mod.lazy_reduce_2(f[i]);\n}\n\nvoid ntt_dit_lazy_core(LazyModNum<2> *f_inout, int n, int sign, const ModInfo &mod) {\n\tntt_dit_lazy_core_sse2(f_inout, n, sign, mod);\n}\n\ntemplate<typename T>\nvoid bit_reverse_permute(T *f, int n) {\n\tint N = 1 << n, N_2 = N >> 1, r = 0;\n\tfor(int x = 1; x < N; ++ x) {\n\t\tint h = N_2;\n\t\twhile(((r ^= h) & h) == 0) h >>= 1;\n\t\tif(r > x) swap(f[x], f[r]);\n\t}\n}\n\nvoid ntt_dit_lazy(LazyModNum<2> *f, int n, int sign, const ModInfo &mod) {\n\tbit_reverse_permute(f, n);\n\tntt_dit_lazy_core(f, n, sign, mod);\n}\n\ntemplate<int LF, int LG>\nvoid componentwise_product_lazy(LazyModNum<2> *res, const LazyModNum<LF> *f, const LazyModNum<LG> *g, int N, const ModInfo &mod) {\n\tfor(int i = 0; i < N; ++ i)\n\t\tres[i] = mod.mul_lazy(f[i], g[i]);\n}\n\nvoid normalize_and_lazy_reduce(LazyModNum<2> *f, int n, const ModInfo &mod) {\n\tconst auto f_out = ModNum::coerceArray(f);\n\tint N = 1 << n;\n\tModNum inv = mod.inv_two_power(n);\n\tassert(mod.mul(inv, mod.to_alt(N)) == mod.one());\n\tfor(int i = 0; i < N; ++ i)\n\t\tf_out[i] = mod.lazy_reduce_1(mod.mul_lazy(f[i], inv));\n}\n\nvoid convolute(ModNum *f_in, ModNum *g_in, int n, const ModInfo &mod) {\n\tassert(mod.support_fft());\n\tconst auto f = LazyModNum<2>::coerceArray(f_in);\n\tconst auto g = LazyModNum<2>::coerceArray(g_in);\n\tntt_dit_lazy(f, n, +1, mod);\n\tntt_dit_lazy(g, n, +1, mod);\n\tcomponentwise_product_lazy(f, f, g, 1 << n, mod);\n\tntt_dit_lazy(f, n, -1, mod);\n\tnormalize_and_lazy_reduce(f, n, mod);\n}\n\nvoid auto_convolute(ModNum *f_in, int n, const ModInfo &mod) {\n\tassert(mod.support_fft());\n\tconst auto f = LazyModNum<2>::coerceArray(f_in);\n\tntt_dit_lazy(f, n, +1, mod);\n\tcomponentwise_product_lazy(f, f, f, 1 << n, mod);\n\tntt_dit_lazy(f, n, -1, mod);\n\tnormalize_and_lazy_reduce(f, n, mod);\n}\n\nenum { MULTIPRIME_NUM = 3 };\n\nstatic const ModInfo fft_prime_mod0 = ModInfo::make_support_fft(998244353, -1, 31, 23);\nstatic const ModInfo fft_prime_mod1 = ModInfo::make_support_fft(897581057, -1, 45, 23);\nstatic const ModInfo fft_prime_mod2 = ModInfo::make_support_fft(880803841, -1, 211, 23);\nconst ModInfo * const fft_prime_mods[MULTIPRIME_NUM] = { &fft_prime_mod0, &fft_prime_mod1, &fft_prime_mod2 };\n\nvoid multiprime_compose(ModNum32 *res, const ModInfo32 &mod_res, const ModNum *f[MULTIPRIME_NUM], int N, const ModInfo * const mods[MULTIPRIME_NUM]) {\n\tconst auto f0 = f[0], f1 = f[1], f2 = f[2];\n\tconst auto &mod0 = *mods[0], &mod1 = *mods[1], &mod2 = *mods[2];\n\tconst auto P0 = mod0.getP(), P1 = mod1.getP(), P2 = mod2.getP();\n\tconst auto P_res = mod_res.getP();\n\tconst auto t1 = mod1.inverse(mod1.to_alt(P0));\n\tconst auto t2 = mod2.inverse(mod2.to_alt((uint64_t)P0 * P1 % P2));\n\tconst auto p01 = mod_res.to_alt((uint64_t)P0 * P1 % P_res);\n\n\tfor(int i = 0; i < N; ++ i) {\n\t\tconst auto a0 = mod0.from_alt(f0[i]), a1 = mod1.from_alt(f1[i]), a2 = mod2.from_alt(f2[i]);\n\t\tconst auto d1 = mod1.sub(mod1.to_alt(a1), mod1.to_alt(a0));\n\t\tconst auto h1 = mod1.from_alt(mod1.mul(d1, t1));\n\t\tconst auto a01 = a0 + (uint64_t)P0 * h1;\n\t\tconst auto d2 = mod2.sub(mod2.to_alt(a2), mod2.to_alt(a01 % P2));\n\t\tconst auto h2 = mod2.from_alt(mod2.mul(d2, t2));\n\t\tres[i] = mod_res.add(mod_res.to_alt(a01 % P_res), mod_res.mul(mod_res.to_alt(h2 % P_res), p01));\n\t}\n}\n\nvoid multiprime_decompose(ModNum *res[MULTIPRIME_NUM], const ModNum32 *f, int N, const ModInfo32 &f_mod, const ModInfo * const mods[MULTIPRIME_NUM]) {\n\tfor(int i = 0; i < N; ++ i) {\n\t\tconst auto a = f_mod.from_alt(f[i]);\n\t\tfor(int k = 0; k < MULTIPRIME_NUM; ++ k)\n\t\t\tres[k][i] = mods[k]->to_alt(a);\n\t}\n}\n\nvoid multiprime_convolute(ModNum32 *res, int resN, const ModNum32 *f, int fN, const ModNum32 *g, int gN, int n, const ModInfo32 &mod) {\n\tint N = 1 << n;\n\tassert(fN <= N && gN <= N && resN <= N);\n\t//implicit zero-fill\n\tunique_ptr<ModNum[]> workspace(new ModNum[N * MULTIPRIME_NUM * 2]);\n\tModNum *fs[MULTIPRIME_NUM], *gs[MULTIPRIME_NUM];\n\tfor(int k = 0; k < MULTIPRIME_NUM; ++ k) {\n\t\tfs[k] = workspace.get() + (k * 2 + 0) * N;\n\t\tgs[k] = workspace.get() + (k * 2 + 1) * N;\n\t}\n\tmultiprime_decompose(fs, f, fN, mod, fft_prime_mods);\n\tmultiprime_decompose(gs, g, gN, mod, fft_prime_mods);\n\tfor(int k = 0; k < MULTIPRIME_NUM; ++ k)\n\t\tconvolute(fs[k], gs[k], n, *fft_prime_mods[k]);\n\tmultiprime_compose(res, mod, const_cast<const ModNum **>(fs), resN, fft_prime_mods);\n}\n\nvoid multiprime_auto_convolute(ModNum32 *res, int resN, const ModNum32 *f, int fN, int n, const ModInfo32 &mod) {\n\tint N = 1 << n;\n\tassert(fN <= N && resN <= N);\n\tunique_ptr<ModNum[]> workspace(new ModNum[N * MULTIPRIME_NUM]);\n\tModNum *fs[MULTIPRIME_NUM];\n\tfor(int k = 0; k < MULTIPRIME_NUM; ++ k)\n\t\tfs[k] = workspace.get() + k * N;\n\tmultiprime_decompose(fs, f, fN, mod, fft_prime_mods);\n\tfor(int k = 0; k < MULTIPRIME_NUM; ++ k)\n\t\tauto_convolute(fs[k], n, *fft_prime_mods[k]);\n\tmultiprime_compose(res, mod, const_cast<const ModNum **>(fs), resN, fft_prime_mods);\n}\n\n}\n\nstruct ModInt {\n\tusing NumType = uint32_t;\n\tusing ModNumType = modnum::ModNumTypes<NumType>;\n\tusing ModNum = ModNumType::ModNum;\n\tusing ModInfo = ModNumType::ModInfo;\n\npublic:\n\tModNum x;\n\n\tModInt() : x() {}\n\tModInt(NumType num) : x(mod.to_alt(num)) {}\n\tModInt(int num) : x(mod.to_alt(num >= 0 ? num : mod.getP() + num % (int)mod.getP())) {}\n\n\tNumType get() const { return mod.from_alt(x); }\n\n\tstatic ModInt raw(ModNum x) { ModInt r; r.x = x; return r; }\n\tstatic ModInt one() { return raw(mod.one()); }\n\n\tModInt operator+(ModInt that) const { return raw(mod.add(x, that.x)); }\n\tModInt &operator+=(ModInt that) { return *this = *this + that; }\n\n\tModInt operator-(ModInt that) const { return raw(mod.sub(x, that.x)); }\n\tModInt &operator-=(ModInt that) { return *this = *this - that; }\n\n\tModInt operator-() const { return raw(mod.sub(ModNum(), x)); }\n\n\tModInt operator*(ModInt that) const { return raw(mod.mul(x, that.x)); }\n\tModInt &operator*=(ModInt that) { return *this = *this * that; }\n\n\tModInt inverse() const { return raw(mod.inverse(x)); }\n\tModInt operator/(ModInt that) const { return *this * that.inverse(); }\n\tModInt &operator/=(ModInt that) { return *this = *this / that.inverse(); }\n\n\tbool operator==(ModInt that) const { return x == that.x; }\n\tbool operator!=(ModInt that) const { return !(*this == that); }\n\nprivate:\n\tstatic ModInfo mod;\n\npublic:\n\tstatic const ModInfo &get_mod_info() { return mod; }\n\tstatic NumType getMod() { return mod.getP(); }\n\n\tstatic void set_mod(NumType P, NumType order = -1) {\n\t\tmod = ModInfo::make(P, order);\n\t}\n};\nModInt::ModInfo ModInt::mod;\ntypedef ModInt mint;\n\nnamespace mod_polynomial {\n\nstruct Polynomial {\n\ttypedef mint R;\n\tstatic R ZeroR() { return R(); }\n\tstatic R OneR() { return R::one(); }\n\tstatic bool IsZeroR(R r) { return r == ZeroR(); }\n\n\tstd::vector<R> coefs;\n\n\tPolynomial() {}\n\texplicit Polynomial(R c0) : coefs(1, c0) {}\n\texplicit Polynomial(R c0, R c1) : coefs(2) { coefs[0] = c0, coefs[1] = c1; }\n\ttemplate<typename It> Polynomial(It be, It en) : coefs(be, en) {}\n\n\tstatic Polynomial Zero() { return Polynomial(); }\n\tstatic Polynomial One() { return Polynomial(OneR()); }\n\tstatic Polynomial X() { return Polynomial(ZeroR(), OneR()); }\n\n\tvoid resize(int n) { coefs.resize(n); }\n\tvoid clear() { coefs.clear(); }\n\n\tR *data() { return coefs.empty() ? NULL : &coefs[0]; }\n\tconst R *data() const { return coefs.empty() ? NULL : &coefs[0]; }\n\n\tint size() const { return static_cast<int>(coefs.size()); }\n\tbool empty() const { return coefs.empty(); }\n\tint degree() const { return size() - 1; }\n\n\tbool normalized() const { return coefs.empty() || coefs.back() != ZeroR(); }\n\tbool monic() const { return !coefs.empty() && coefs.back() == OneR(); }\n\n\tR get(int i) const { return 0 <= i && i < size() ? coefs[i] : ZeroR(); }\n\n\tvoid set(int i, R x) {\n\t\tif(size() <= i)\n\t\t\tresize(i + 1);\n\t\tcoefs[i] = x;\n\t}\n\n\tvoid normalize() { while(!empty() && IsZeroR(coefs.back())) coefs.pop_back(); }\n\n\tR evaluate(R x) const {\n\t\tif(empty()) return R();\n\t\tR r = coefs.back();\n\t\tfor(int i = size() - 2; i >= 0; -- i) {\n\t\t\tr *= x;\n\t\t\tr += coefs[i];\n\t\t}\n\t\treturn r;\n\t}\n\n\tPolynomial &operator+=(const Polynomial &that) {\n\t\tint m = size(), n = that.size();\n\t\tif(m < n) resize(n);\n\t\t_add(data(), that.data(), n);\n\t\treturn *this;\n\t}\n\tPolynomial operator+(const Polynomial &that) const {\n\t\treturn Polynomial(*this) += that;\n\t}\n\n\tPolynomial &operator-=(const Polynomial &that) {\n\t\tint m = size(), n = that.size();\n\t\tif(m < n) resize(n);\n\t\t_subtract(data(), that.data(), n);\n\t\treturn *this;\n\t}\n\tPolynomial operator-(const Polynomial &that) const {\n\t\treturn Polynomial(*this) -= that;\n\t}\n\n\tPolynomial &operator*=(R r) {\n\t\t_multiply_1(data(), size(), r);\n\t\treturn *this;\n\t}\n\tPolynomial operator*(R r) const {\n\t\tPolynomial res;\n\t\tres.resize(size());\n\t\t_multiply_1(res.data(), data(), size(), r);\n\t\treturn res;\n\t}\n\n\tPolynomial operator*(const Polynomial &that) const {\n\t\tPolynomial r;\n\t\tmultiply(r, *this, that);\n\t\treturn r;\n\t}\n\n\tPolynomial &operator*=(const Polynomial &that) {\n\t\tmultiply(*this, *this, that);\n\t\treturn *this;\n\t}\n\n\tstatic void multiply(Polynomial &res, const Polynomial &p, const Polynomial &q) {\n\t\tint pn = p.size(), qn = q.size();\n\n\t\tif(pn < qn)\n\t\t\treturn multiply(res, q, p);\n\n\t\tif(&res == &p || &res == &q) {\n\t\t\tPolynomial tmp;\n\t\t\tmultiply(tmp, p, q);\n\t\t\tres = tmp;\n\t\t\treturn;\n\t\t}\n\n\t\tif(qn == 0) {\n\t\t\tres.coefs.clear();\n\t\t} else {\n\t\t\tres.resize(pn + qn - 1);\n\t\t\t_multiply_select_method(res.data(), p.data(), pn, q.data(), qn);\n\t\t}\n\t}\n\n\tPolynomial operator-() const {\n\t\tPolynomial res;\n\t\tres.resize(size());\n\t\t_negate(res.data(), data(), size());\n\t\treturn res;\n\t}\n\n\tPolynomial precomputeInverse(int n) const {\n\t\tPolynomial res;\n\t\tres.resize(n);\n\t\t_precompute_inverse(res.data(), n, data(), size());\n\t\treturn res;\n\t}\n\n\tstatic void divideRemainderPrecomputedInverse(Polynomial &quot, Polynomial &rem, const Polynomial &p, const Polynomial &q, const Polynomial &inv) {\n\t\tassert(&quot != &p && &quot != &q && &quot != &inv);\n\t\tint pn = p.size(), qn = q.size();\n\t\tassert(inv.size() >= pn - qn + 1);\n\t\tquot.resize(std::max(0, pn - qn + 1));\n\t\trem.resize(qn - 1);\n\t\t_divide_remainder_precomputed_inverse(quot.data(), rem.data(), p.data(), pn, q.data(), qn, inv.data());\n\t\tquot.normalize();\n\t\trem.normalize();\n\t}\n\n\tPolynomial computeRemainderPrecomputedInverse(const Polynomial &q, const Polynomial &inv) const {\n\t\tPolynomial quot, rem;\n\t\tdivideRemainderPrecomputedInverse(quot, rem, *this, q, inv);\n\t\treturn rem;\n\t}\n\n\tPolynomial powerMod(long long K, const Polynomial &q) const {\n\t\tint qn = q.size();\n\t\tassert(K >= 0 && qn > 0);\n\t\tassert(q.monic());\n\t\tif(qn == 1) return Polynomial();\n\t\tif(K == 0) return One();\n\t\tPolynomial inv = q.precomputeInverse(std::max(size() - qn + 1, qn));\n\t\tPolynomial p = this->computeRemainderPrecomputedInverse(q, inv);\n\t\tint l = 0;\n\t\twhile((K >> l) > 1) ++ l;\n\t\tPolynomial res = p;\n\t\tfor(-- l; l >= 0; -- l) {\n\t\t\tres *= res;\n\t\t\tres = res.computeRemainderPrecomputedInverse(q, inv);\n\t\t\tif(K >> l & 1) {\n\t\t\t\tres *= p;\n\t\t\t\tres = res.computeRemainderPrecomputedInverse(q, inv);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic int MULTIPRIME_FFT_THRESHOLD;\n\nprivate:\n\tclass WorkSpaceStack;\n\n\tstatic void _fill_zero(R *res, int n);\n\tstatic void _copy(R *res, const R *p, int n);\n\tstatic void _negate(R *res, const R *p, int n);\n\n\tstatic void _add(R *p, const R *q, int n);\n\tstatic void _add(R *res, const R *p, int pn, const R *q, int qn);\n\tstatic void _subtract(R *p, const R *q, int n);\n\tstatic void _subtract(R *res, const R *p, int pn, const R *q, int qn);\n\n\tstatic void _multiply_select_method(R *res, const R *p, int pn, const R *q, int qn);\n\tstatic void _square_select_method(R *res, const R *p, int pn);\n\n\tstatic void _multiply_1(R *p, const R *q, int n, R c0);\n\tstatic void _multiply_1(R *p, int n, R c0);\n\n\tstatic void _multiply_power_of_two(R *res, const R *p, int n, int k);\n\tstatic void _divide_power_of_two(R *res, const R *p, int n, int k);\n\n\tstatic void _schoolbook_multiplication(R *res, const R *p, int pn, const R *q, int qn);\n\n\tstatic void _multiprime_fft(R *res, const R *p, int pn, const R *q, int qn);\n\n\tstatic void _reverse(R *res, const R *p, int pn);\n\tstatic void _inverse_power_series(R *res, int resn, const R *p, int pn);\n\tstatic void _precompute_inverse(R *res, int resn, const R *p, int pn);\n\tstatic void _divide_precomputed_inverse(R *res, int resn, const R *revp, int pn, const R *inv);\n\tstatic void _divide_remainder_precomputed_inverse(R *quot, R *rem, const R *p, int pn, const R *q, int qn, const R *inv);\n};\nint Polynomial::MULTIPRIME_FFT_THRESHOLD = 8;\n\nvoid Polynomial::_fill_zero(R *res, int n) {\n\tfor(int i = 0; i < n; ++ i)\n\t\tres[i] = ZeroR();\n}\n\nvoid Polynomial::_copy(R *res, const R *p, int n) {\n\tfor(int i = 0; i < n; ++ i)\n\t\tres[i] = p[i];\n}\n\nvoid Polynomial::_negate(R *res, const R *p, int n) {\n\tfor(int i = 0; i < n; ++ i)\n\t\tres[i] = -p[i];\n}\n\nvoid Polynomial::_add(R *res, const R *p, int pn, const R *q, int qn) {\n\tfor(int i = 0; i < qn; ++ i)\n\t\tres[i] = p[i] + q[i];\n\t_copy(res + qn, p + qn, pn - qn);\n}\n\nvoid Polynomial::_subtract(R *res, const R *p, int pn, const R *q, int qn) {\n\tfor(int i = 0; i < qn; ++ i)\n\t\tres[i] = p[i] - q[i];\n\t_copy(res + qn, p + qn, pn - qn);\n}\n\nvoid Polynomial::_add(R *p, const R *q, int n) {\n\t_add(p, p, n, q, n);\n}\n\nvoid Polynomial::_subtract(R *p, const R *q, int n) {\n\t_subtract(p, p, n, q, n);\n}\n\nvoid Polynomial::_multiply_1(R *res, const R *p, int n, R c0) {\n\tfor(int i = 0; i < n; ++ i)\n\t\tres[i] = p[i] * c0;\n}\n\nvoid Polynomial::_multiply_1(R *p, int n, R c0) {\n\t_multiply_1(p, p, n, c0);\n}\n\nvoid Polynomial::_multiply_power_of_two(R *res, const R *p, int n, int k) {\n\tassert(0 < k && k < 31);\n\tR mul = R(1 << k);\n\t_multiply_1(res, p, n, mul);\n}\n\nvoid Polynomial::_divide_power_of_two(R *res, const R *p, int n, int k) {\n\tassert(0 < k && k < 31);\n\tstatic const R Inv2 = R(2).inverse();\n\tR inv = k == 1 ? Inv2 : R(1 << k).inverse();\n\t_multiply_1(res, p, n, inv);\n}\n\n\nvoid Polynomial::_multiply_select_method(R *res, const R *p, int pn, const R *q, int qn) {\n\tif(pn < qn) std::swap(p, q), std::swap(pn, qn);\n\tassert(res != p && res != q && pn >= qn && qn > 0);\n\tint rn = pn + qn - 1;\n\tif(qn == 1) {\n\t\t_multiply_1(res, p, pn, q[0]);\n\t} else if(qn < MULTIPRIME_FFT_THRESHOLD) {\n\t\t_schoolbook_multiplication(res, p, pn, q, qn);\n\t} else {\n\t\t_multiprime_fft(res, p, pn, q, qn);\n\t}\n}\n\nvoid Polynomial::_square_select_method(R *res, const R *p, int pn) {\n\t_multiply_select_method(res, p, pn, p, pn);\n}\n\nvoid Polynomial::_schoolbook_multiplication(R *res, const R *p, int pn, const R *q, int qn) {\n\tif(qn == 1) {\n\t\t_multiply_1(res, p, pn, q[0]);\n\t\treturn;\n\t}\n\tassert(res != p && res != q && pn >= qn && qn > 0);\n\n\t_fill_zero(res, pn + qn - 1);\n\tfor(int i = 0; i < pn; ++ i)\n\t\tfor(int j = 0; j < qn; ++ j)\n\t\t\tres[i + j] += p[i] * q[j];\n}\n\nvoid Polynomial::_multiprime_fft(R *res, const R *p, int pn, const R *q, int qn) {\n\tint resn = pn + qn - 1;\n\n\tint n = 0;\n\twhile((1 << n) < resn) ++ n;\n\n\tif(p == q) {\n\t\tassert(pn == qn);\n\t\tfft::multiprime_auto_convolute(reinterpret_cast<R::ModNum*>(res), resn, reinterpret_cast<const R::ModNum*>(p), pn, n, mint::get_mod_info());\n\t} else {\n\t\tfft::multiprime_convolute(reinterpret_cast<R::ModNum*>(res), resn, reinterpret_cast<const R::ModNum*>(p), pn, reinterpret_cast<const R::ModNum*>(q), qn, n, mint::get_mod_info());\n\t}\n}\n\nvoid Polynomial::_reverse(R *res, const R *p, int pn) {\n\tif(res == p) {\n\t\tstd::reverse(res, res + pn);\n\t} else {\n\t\tfor(int i = 0; i < pn; ++ i)\n\t\t\tres[pn - 1 - i] = p[i];\n\t}\n}\n\nvoid Polynomial::_inverse_power_series(R *res, int resn, const R *p, int pn) {\n\tif(resn == 0) return;\n\tassert(res != p);\n\tassert(p[0] == OneR());\n\tunique_ptr<R[]> ws(new R[resn * 4]);\n\tR *tmp1 = ws.get(), *tmp2 = tmp1 + resn * 2;\n\t_fill_zero(res, resn);\n\tres[0] = p[0];\n\tint curn = 1;\n\twhile(curn < resn) {\n\t\tint nextn = std::min(resn, curn * 2);\n\t\t_square_select_method(tmp1, res, curn);\n\t\t_multiply_select_method(tmp2, tmp1, std::min(nextn, curn * 2 - 1), p, std::min(nextn, pn));\n\t\t_multiply_power_of_two(res, res, curn, 1);\n\t\t_subtract(res, tmp2, nextn);\n\t\tcurn = nextn;\n\t}\n}\n\nvoid Polynomial::_precompute_inverse(R *res, int resn, const R *p, int pn) {\n\tunique_ptr<R[]> ws(new R[pn]);\n\tR *tmp = ws.get();\n\t_reverse(tmp, p, pn);\n\t_inverse_power_series(res, resn, tmp, pn);\n}\n\nvoid Polynomial::_divide_precomputed_inverse(R *res, int resn, const R *revp, int pn, const R *inv) {\n\tunique_ptr<R[]> ws(new R[pn + resn]);\n\tR *tmp = ws.get();\n\t_multiply_select_method(tmp, revp, pn, inv, resn);\n\t_reverse(res, tmp, resn);\n}\n\nvoid Polynomial::_divide_remainder_precomputed_inverse(R *quot, R *rem, const R *p, int pn, const R *q, int qn, const R *inv) {\n\tif(pn < qn) {\n\t\t_copy(rem, p, pn);\n\t\t_fill_zero(rem + pn, qn - 1 - pn);\n\t\treturn;\n\t}\n\tassert(qn > 0);\n\tassert(q[qn - 1] == OneR());\n\tif(qn == 1) return;\n\tint quotn = pn - qn + 1;\n\tint rn = qn - 1, tn = std::min(quotn, rn), un = tn + rn;\n\tunique_ptr<R[]> ws(new R[pn + un + (quot != NULL ? 0 : quotn)]);\n\tR *revp = ws.get(), *quotmul = revp + pn;\n\tif(quot == NULL) quot = quotmul + un;\n\t_reverse(revp, p, pn);\n\t_divide_precomputed_inverse(quot, quotn, revp, pn, inv);\n\t_multiply_select_method(quotmul, q, rn, quot, tn);\n\t_subtract(rem, p, rn, quotmul, rn);\n}\n\n}\n\nvector<mint> fact, factinv;\nvoid nCr_computeFactinv(int N) {\n\tfact.resize(N + 1); factinv.resize(N + 1);\n\tfact[0] = 1;\n\trer(i, 1, N) fact[i] = fact[i - 1] * i;\n\tfactinv[N] = fact[N].inverse();\n\tfor(int i = N; i >= 1; i --) factinv[i - 1] = factinv[i] * i;\n}\nmint nCr(int n, int r) {\n\treturn r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];\n}\n\nint main() {\n\tmint::set_mod((int)1e9+7);\n\tint N; int M; int K;\n\twhile(~scanf(\"%d%d%d\", &N, &M, &K)) {\n\t\tnCr_computeFactinv(N + M + K);\n\t\tmod_polynomial::Polynomial p, q;\n\t\tp.resize(M + 1), q.resize(K + 1);\n\t\trep(i, M + 1) p.set(i, factinv[i]);\n\t\trep(i, K + 1) q.set(i, factinv[i]);\n\t\tauto pq = p * q;\n\t\tmint ans;\n\t\trer(mk, 0, M + K) {\n\t\t\tmint sum = pq.get(mk);\n\t\t\tsum *= fact[N - 1 + mk];\n\t\t\tsum *= factinv[N - 1];\n\t\t\tans = ans * 3 + sum;\n\t\t}\n\t\tprintf(\"%d\\n\", ans.get());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod  1000000007\nll modpow(ll x,ll n)\n{\n\tll res=1;\n\twhile(n>0)\n\t{\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[1000005],R[1000005],th[1000005];\nvoid make(){\n\tF[0] = th[0] = 1;\n\tfor(int i=1;i<1000005;i++){\n\t\tF[i] = F[i-1]*i%mod;\n\t\tth[i]  = th[i-1]*3LL%mod;\n\t}\n\tfor(int i=0;i<1000005;i++) R[i] = modpow(F[i],mod-2);\n}\nll C(int n,int m){\n\treturn F[n] * R[m] % mod * R[n-m] % mod;\n}\nint main(){\n\tint n,m,k; cin >> n >> m >> k;\n\tif(n>5000 || m>5000 || k>5000) return 0;\n\tmake();\n\tll ret = 0;\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tll sum = C(n+i+j-1,n-1) * C(i+j,i) % mod;\n\t\t\tsum *= th[m+k-i-j];\n\t\t\tsum %= mod;\n\t\t\tret += sum;\n\t\t}\n\t}\n\tcout << ret%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int MN = 300010;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[MN], invf[MN];\n\nint N, M, K;\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < MN; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> M >> K;\n\n    int ans = 0;\n    for(int i = 0; i <= M; i++) {\n        for(int j = 0; j <= K; j++) {\n            ans += 1LL * fact[N - 1 + M - i + K - j] * invf[N - 1] % mod * invf[M - i] % mod * invf[K - j] % mod * exp(3, i + j) % mod;\n            ans %= mod;\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/02/01] 13:20:15\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n    std::pair<ll, ll> quad() const\n    {\n        const auto ans = quad_r(v, mod());\n        ll x = std::get<0>(ans), y = std::get<1>(ans);\n        if (y < 0) { x = -x, y = -y; }\n        return {x, y};\n    }\n\nprivate:\n    static std::tuple<ll, ll, ll> quad_r(const ll r, const ll p)  // r = x/y (mod p), (x,y,z) s.t. x=yr+pz\n    {\n        if (std::abs(r) <= 1000) { return {r, 1, 0}; }\n        ll nr = p % r, q = p / r;\n        if (nr * 2LL >= r) { nr -= r, q++; }\n        if (nr * 2LL <= -r) { nr += r, q--; }\n        const auto sub = quad_r(nr, r);\n        const ll x = std::get<0>(sub), z = std::get<1>(sub), y = std::get<2>(sub);\n        return {x, y - q * z, z};\n    }\n\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v <= 2000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\ntemplate<uint mod_value, bool dynamic = false>\nclass modcomb_base\n{\npublic:\n    using value_type = modint_base<mod_value, dynamic>;\n    modcomb_base()   = delete;\n    static void set_mod(const uint mod) { value_type::set_mod(mod), fact_ref() = {1, 1}, inv_fact_ref() = {1, 1}; }\n    static value_type fact(const usize n)\n    {\n        auto& f = fact_ref();\n        if (n < f.size()) { return f[n]; }\n        for (usize i = f.size(); i <= n; i++) { f.push_back(f.back() * i); }\n        return f.back();\n    }\n    static value_type inv_fact(const usize n)\n    {\n        auto& invf = inv_fact_ref();\n        if (n < invf.size()) { return invf[n]; }\n        for (usize i = invf.size(); i <= n; i++) { invf.push_back(invf.back() * value_type::small_inv(i)); }\n        return invf.back();\n    }\n    static value_type perm(const usize n, const usize k) { return k > n ? value_type{0} : fact(n) * inv_fact(n - k); }\n    static value_type comb(const usize n, const usize k) { return k > n ? value_type{0} : fact(n) * inv_fact(n - k) * inv_fact(k); }\n\nprivate:\n    static std::vector<value_type>& fact_ref()\n    {\n        static std::vector<value_type> f{1, 1};\n        return f;\n    }\n    static std::vector<value_type>& inv_fact_ref()\n    {\n        static std::vector<value_type> invf{1, 1};\n        return invf;\n    }\n};\ntemplate<uint mod>\nusing modcomb = modcomb_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modcomb = modcomb_base<id, true>;\nint main()\n{\n    using mint   = modint<mod>;\n    using moc    = modcomb<mod>;\n    const auto N = in<int>(), M = in<int>(), K = in<int>();\n    mint ans = 0;\n    for (int L = N - 1; L <= (N - 1) + M + K; L++) {\n        const int l = L - N + 1;\n        mint sub    = 0;\n        for (int m = 0; m <= M; m++) {\n            const int k = l - m;\n            if (m <= M and k <= K) { sub += moc::comb(L, N - 1) * moc::comb(l, m); }\n        }\n        ans += sub * (mint(3) ^ (N + M + K - L - 1));\n    }\n    outln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint mod = 1000000007;\nlong long a[3001];\nlong long inv[3001];\nlong long fact[3001];\nlong long invfact[3001];\n\nvoid calc_inv(int n, int mod) {\n    inv[1] = 1;\n    for (int i = 2; i <= n; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n    \n    fact[0] = invfact[0] = 1;\n    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    for (int i = 1; i <= n; i++) invfact[i] = invfact[i - 1] * inv[i] % mod;\n}\n\nlong long comb(int x, int y, int mod) {\n    return fact[x] * invfact[y] % mod * invfact[x - y] % mod;\n}\n\nint main() {\n    int n, m, k, i, j;\n    long long ans = 0;\n    \n    scanf(\"%d %d %d\", &n, &m, &k);\n    \n    if (n > 1000 || m > 1000 || k > 1000) return 0;\n    \n    calc_inv(3000, mod);\n    \n    a[0] = 1;\n    for (i = 1; i <= 3000; i++) a[i] = a[i - 1] * 3 % mod;\n    \n    for (i = 0; i <= m; i++) {\n        for (j = 0; j <= k; j++) {\n            int c = n - 1 + m - i + k - j;\n            \n            ans += a[i + j] * comb(c, n - 1, mod) % mod * comb(c - n + 1, m - i, mod) % mod;\n        }\n    }\n    \n    printf(\"%lld\\n\", ans % mod);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble PI=3.141592653589793;\n\ncomplex <double> dftn[2100007];\ncomplex <double> dfts[2100007];\n\ncomplex <double> a1[2100007];\ncomplex <double> b1[2100007];\ncomplex <double> a2[2100007];\ncomplex <double> b2[2100007];\n\ndouble cosi[2100007];\ncomplex <double> omega[2100007];\n\ninline int potenga(int v)\n{\n    for (int i=1; 1; i<<=1)\n    {\n        if (i>=v)\n        {\n            return i;\n        }\n    }\n}\n\ninline void dft(int n, int kier)\n{\n    int n2=n-1;\n    int s=0;\n    int p;\n    int g;\n\n    for (int i=2; i<=n; i<<=1)\n    {\n\n        for (int j=0; j<n; j++)\n        {\n            dfts[j]=dftn[j];\n            dftn[j]=0;\n        }\n\n        p=n/i;\n\n        if (kier)\n        {\n            g=0;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=j+1;\n                    s=0;\n                }\n            }\n        }\n        else\n        {\n            g=n;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=n-j-1;\n                    s=0;\n                }\n            }\n        }\n    }\n}\n\nvoid licz_omegi(int n1)\n{\n    double kat=2.0*PI/n1;\n    int n2=n1-1;\n    int dod=3*n1/4;\n\n    for (int i=0; i<=n1; i++)\n    cosi[i]=cos(kat*i);\n    for (int i=0; i<=n1; i++)\n    omega[i]=complex <double> (cosi[i], cosi[(i+dod)&n2]);\n}\n\nvector <long long> fft_dokladne(vector <long long> &jed, vector <long long> &dwa)\n{\n    int n1=potenga(jed.size()+dwa.size());\n\n    licz_omegi(n1);\n\n    long long M=32000;\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]/M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a1[i]=dftn[i];\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]%M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b1[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]/M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a2[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]%M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b2[i]=dftn[i];\n\n    vector <long long> ret;\n    for (int i=0; i<n1; i++)\n    ret.push_back(0);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=(llround(dftn[i].real()/n1)%1000000007)*M*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*b2[i]+b1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1)*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=b1[i]*b2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1);\n\n    for (int i=0; i<ret.size(); i++)\n        ret[i]%=1000000007;\n\n    return ret;\n}\n\nint n, m, k;\n\nint s;\n\nlong long mod=1000000007;\n\nlong long sil[1000007];\nlong long odw[1000007];\nlong long do3[1000007];\n\nvector <long long> d1, d2, d3;\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n    long long wyk=mod-2;\n    while(wyk)\n    {\n        if (wyk&1)\n        {\n            a*=b;\n            a%=mod;\n        }\n        b*=b;\n        b%=mod;\n        wyk>>=1;\n    }\n    return a;\n}\n\nlong long komb(int a, int b)\n{\n    if (b<0 || b>a)\n        return 0;\n    return (sil[a]*((odw[b]*odw[a-b])%mod))%mod;\n}\n\nlong long komz(int a, int b)\n{\n    return komb(a+b-1, b);\n}\n\nint main()\n{\n    //n=300000;\n    //m=300000;\n    //k=300000;\n    scanf(\"%d%d%d\", &n, &m, &k);\n    s=n+m+k;\n    sil[0]=1;\n    odw[0]=1;\n    do3[0]=1;\n    for (int i=1; i<=s; i++)\n        sil[i]=(sil[i-1]*i)%mod;\n    odw[s]=dziel(1, sil[s]);\n    for (int i=s-1; i; i--)\n        odw[i]=(odw[i+1]*(i+1))%mod;\n    for (int i=1; i<=s; i++)\n        do3[i]=(do3[i-1]*3)%mod;\n    for (int i=0; i<=m; i++)\n        d1.push_back((komz(n, i)*odw[n+i-1])%mod);\n    for (int i=0; i<=k; i++)\n        d2.push_back(odw[i]);\n    d3=fft_dokladne(d1, d2);\n    for (int i=0; i<=m+k; i++)\n        wyn+=(d3[i]*((sil[n+i-1]*do3[m+k-i])%mod))%mod;\n    printf(\"%lld\\n\", wyn%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 1000000007\nusing namespace std;\n#ifdef Fading\n#define gc getchar\n#endif\n#ifndef Fading\ninline char gc(){\n    static char now[1<<16],*S,*T;\n    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}\n    return *S++;\n}\n#endif\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nll n,m,L,inv[1010101],fac[1010101];\nll f[1010101],sumf[1010101];\ninline ll fast_pow(ll a,ll b,ll p){\n\tll t=1;\n\twhile (b){\n\t\tif (b&1ll) t=t*a%p;\n\t\tb>>=1ll;a=a*a%p;\n\t}\n\treturn t;\n}\ninline ll C(ll n,ll m){\n\tif (n<0||m<0) return 0;\n\tif (m>n) return 0;\n\treturn fac[n]*inv[m]%ljc*inv[n-m]%ljc;\n}\nsigned main(){\n\tn=read(),m=read(),L=read(); \n\tinv[0]=inv[1]=fac[1]=fac[0]=1;\n\tll M=max(n,max(m,L));\n\tfor (ll i=2;i<=3*M+2;i++) fac[i]=fac[i-1]*i%ljc;\n\tfor (ll i=2;i<=3*M+2;i++) inv[i]=(ljc-(ljc/i)*inv[ljc%i]%ljc)%ljc;\n\tfor (ll i=2;i<=3*M+2;i++) inv[i]=inv[i-1]*inv[i]%ljc;\n\tll ans=0;\n\tfor (int i=0;i<=m;i++){\n\t\tfor (int j=0;j<=L;j++){\n\t\t\tif (i==0&&j==0) ans=(ans+fast_pow(3,m+L,ljc))%ljc;\n\t\t\telse if (i==0){\n\t\t\t\tans=(ans+fast_pow(3,m+L-j,ljc)*C(n+j-1,n-1)%ljc)%ljc;//__a\n\t\t\t}else if (j==0){\n\t\t\t\tans=(ans+fast_pow(3,m+L-i,ljc)*C(n+i-1,n-1)%ljc)%ljc;//_a_\n\t\t\t}else{\n\t\t\t\tll tmp=0;\n\t\t\t\ttmp=(tmp+C(n+i+j-2,n-1)*C(i+j-1,i-1)%ljc)%ljc;//_ab\n\t\t\t\ttmp=(tmp+C(n+i+j-2,n-2)*C(i+j,i))%ljc;//_aa\n\t\t\t\ttmp=(tmp+C(n+i+j-2,n-1)*C(i+j-1,i)%ljc)%ljc;//_ca\n\t\t\t\tans=(ans+fast_pow(3,m-i+L-j,ljc)*tmp%ljc)%ljc;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n1000 1000 1000\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nconst ll third=mypow(3,MOD-2);\n\ninline ll inv(ll n){return mypow(n,MOD-2);}\n\nint main()\n{\n\tIOS;\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\n\tll ans=0;\n\n\tll C=1;\n\tll ex=mypow(3,m+k);\n\tll l=1,r=1;\n\tll S=1;\n\tfor(int sum=0;sum<=m+k;sum++){\n\t\tans+=S*C%MOD*ex%MOD;\n\t\t// cout<<S<<' '<<C<<' '<<ex<<' '<<l<<' '<<r<<'\\n';\n\t\tif(ans>=MOD) ans-=MOD;\n\t\tC=C*inv(sum+1)%MOD;\n\t\tC=C*(n-1+sum+1)%MOD;\n\n\t\tex=ex*third%MOD;\n\n\t\tS<<=1;\n\t\tif(sum>=m) S-=l;\n\t\tif(sum>=k) S-=r;\n\t\tS=(S+MOD+MOD)%MOD;\n\n\t\tif(sum>=m){\n\t\t\tl=l*(sum+1)%MOD*inv(sum+1-m)%MOD;\n\t\t}\n\t\tif(sum>=k){\n\t\t\tr=r*(sum+1)%MOD*inv(sum+1-k)%MOD;\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// It is just a test!!!\n#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n    return ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n    return ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n    int ans = 1 , base = a ;\n    while( b ) {\n        if( b&1 ) ans = mul( ans , base ) ;\n        base = mul( base , base ) ; \n        b >>= 1 ;\n    }\n    return ans ;\n}\n\nll inv( ll x ) {\n    return power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n    return ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n    scanf( \"%d%d%d\" , &n , &m , &k ) ;\n    fac[ 0 ] = 1ll ;\n    p[ 0 ] = 1ll ;\n    for( int i = 1 ; i < N ; i ++ ) {\n        fac[ i ] = fac[ i - 1 ] * i % mod ;\n        p[ i ] = p[ i - 1 ] * 3ll % mod ;\n    }\n    for( int i = 0 ; i < N ; i ++ ) {\n        ifac[ i ] = inv( fac[ i ] ) ;\n    }\n    ll ans = 0 , x = 1ll ;\n    n -- ;\n    for( int i = 0 ; i <= m + k ; i ++ ) {\n        ans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n        if( i < k ) x = ( x * 2ll ) % mod ;\n        else if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n        else  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n    }\n    printf( \"%lld\\n\" , add( ans , mod ) ) ;\n    return 0 ;\n} \n//"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nll M = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){\n\t\tret *= x; ret %= M;\n\t}\n\treturn ret;\n}\n\nll C[3][1000000];\nvoid C_init(int t,int x,int n){\n\trep(i,x){\n\t\tif(i < n)C[t][i] = 0;\n\t\telse if(i == n)C[t][i] = 1;\n\t\telse {\n\t\t\tll ret = C[t][i-1];\n\t\t\tret *= i; ret %= M;\n\t\t\tret *= modpow(i-n,M-2); ret %= M;\n\t\t\tC[t][i] = ret;\n\t\t}\n\t}\n}\n\nint main(){\n\tll n,m,k;\n\tcin >> n >> m >> k;\n\tn --;\n\tC_init(0,900001,n);\n\tC_init(1,600001,m);\n\tC_init(2,600001,k);\n\t//if(n > 1000 || m > 1000 || k > 1000)return 0;\n\t\n\tll ret = 0;\n\tll sum_ = 1;\n\tfor(ll t = m+k ; t >= 0 ; t --){\n\t\tif(t < m+k){\n\t\t\tsum_ *= 2;\n\t\t\tif(sum_ >= M)sum_ -= M;\n\t\t\tif(m+k-t >= m+1){\n\t\t\t\tsum_ -= C[1][m+k-t-1];\n\t\t\t\tif(sum_ < 0)sum_ += M;\n\t\t\t}\n\t\t\tif(m+k-t >= k+1){\n\t\t\t\tsum_ -= C[2][m+k-t-1];\n\t\t\t\tif(sum_ < 0)sum_ += M;\n\t\t\t}\n\t\t}\n\t\tll sum = sum_;\n\t\tsum %= M;\n\t\tsum *= modpow(3,t); sum %= M;\n\t\tsum *= C[0][n+m+k-t]; sum %= M;\n\t\tret += sum;\n\t}\n\tcout << ret%M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define f(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;i=-(~i))\n#define rf(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;i=~(-i))\nconst int mod=1e9+7,neko=300010;\nint ans,now,res,n,m,k;\ntypedef int arr[neko*3];\narr fac,ifac,pow3;\nint spow(int m,int n)\n{\n\tint b=1;\n\tfor(;n;n>>=1,m=1ll*m*m%mod)if(n&1)b=1ll*b*m%mod;\n\treturn b;\n}\nint C(int n,int m)\n{return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nvoid initM(int n)\n{\n\tfac[0]=ifac[0]=pow3[0]=1;\n\tf(i,1,n)fac[i]=1ll*fac[i-1]*i%mod,pow3[i]=3ll*pow3[i-1]%mod;\n\tifac[n]=spow(fac[n],mod-2);\n\trf(i,n-1,1)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\nint ADD(int x,int y){return (x+=y)>=mod?x-mod:x;}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tif(m<k)std::swap(m,k);\n\tinitM(n+m+k+5),res=1;\n\tf(i,0,m+k)\n\t{\n\t\tnow=1ll*C(n-1+i,i)*pow3[m+k-i]%mod*res%mod;\n\t\tif(i+1<=k)res=2ll*res%mod;\n\t\telse if(i+1<=m)res=ADD(2ll*res%mod,mod-C(i,k));\n\t\telse res=ADD(2ll*res%mod,ADD(mod-C(i,k),mod-C(i,m))); \n\t\tans=ADD(ans,now%mod);\n\t}printf(\"%d\\n\",ADD(ans,mod));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MOD 1000000007\n\nusing namespace std;\n\nint Fact[1000005],P3[1000005],Inv[1000005],Dp[1000005];\n\nint put(int a, int b)\n{\n    int rez=1;\n    for(int i=0; (1<<i)<=b; i++)\n    {\n        if((1<<i)&b)\n            rez=(1LL*rez*a)%MOD;\n        a=(1LL*a*a)%MOD;\n    }\n    return rez;\n}\n\nint comb(int n, int k)\n{\n    if(k>n)\n        return 0;\n\n    int rez=(1LL*Fact[n]*Inv[k])%MOD;\n    rez=(1LL*rez*Inv[n-k])%MOD;\n    return rez;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n    int n,m,k;\n    cin>>n>>m>>k;\n\n    Fact[0]=1;\n    P3[0]=1;\n    for(int i=1; i<=n+m+k+1; i++)\n    {\n        Fact[i]=(1LL*Fact[i-1]*i)%MOD;\n        P3[i]=(3LL*P3[i-1])%MOD;\n    }\n\n    Inv[n+m+k+1]=put(Fact[n+m+k+1],MOD-2);\n    for(int i=n+m+k; i>=0; i--)\n        Inv[i]=(1LL*Inv[i+1]*(i+1))%MOD;\n\n    Dp[0]=1;\n    for(int i=1; i<=m+k; i++)  //nr de moduri de a pune B si C a.i. sa nu castige nici b nici c\n    {\n        Dp[i]=(Dp[i-1]-comb(i-1,m)+MOD)%MOD; //pun pe poz i B\n        Dp[i]=(1LL*Dp[i]+Dp[i-1]-comb(i-1,k)+MOD)%MOD; //pun pe poz i C\n    }\n\n    int rez=0;\n    for(int i=n+1; i<=n+m+k+1; i++)\n    {\n        int val=comb(i-2,n-1); //prima si ultima val e a\n        val=(1LL*val*P3[n+m+k+1-i])%MOD;\n        val=(1LL*val*Dp[i-n-1])%MOD;\n        rez=(rez+val)%MOD;\n    }\n    cout<<rez<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nconst int MAX=1000000;\nint fact[MAX],inv[MAX];\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nint pow3[MAX];\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<MAX;i++)fact[i]=fact[i-1]*i%mod;\n    inv[MAX-1]=mpow(fact[MAX-1],mod-2);\n    for(int i=MAX-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    pow3[0]=1;\n    for(int i=1;i<MAX;i++)pow3[i]=pow3[i-1]*3%mod;\n\n    int N,M,K;\n    cin>>N>>M>>K;\n    int ans=0;\n\n    int curL=0,curR=1;\n\n    for(int i=0;i<=M+K;i++){\n        ans=(ans+(curR-curL+mod)*C(N-1+i,i)%mod*pow3[M+K-i])%mod;\n        curL*=2;\n        curR*=2;\n        if(i>=M)curR=(curR-C(i,M)+mod)%mod;\n        if(i>=K)curL=(curL+C(i,i-K))%mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint n,m,k;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tif(n==m&&m==k&&n==1)puts(\"17\");\n\tif(m==k&&n==4&&k==2)puts(\"1227\");\n\tif(n==m&&m==k&&n==1000)puts(\"261790852\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\ntypedef long long LL;\n\nconst LL MOD=1e9+7;\n#define SZ 100000\nLL fact[SZ];\nstruct cww{cww(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    fact[0]=1;\n    for(LL i=1;i<SZ;i++)\n        fact[i]=fact[i-1]*i%MOD;\n}}init;\n// a x + b y = gcd(a, b)\n// O(log (a+b) )\nLL extgcd(LL a, LL b, LL &x, LL &y) {\n  LL g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\n// mを法とするaの逆元\n// O(log a)\nLL invMod(LL a) {\n\tLL x, y;\n\tif (extgcd(a, MOD, x, y) == 1)return (x + MOD) % MOD;\n\telse\t return 0; // unsolvable\n}\n\n\n// 組み合わせnCk (mod MOD)\n// O(n)\nLL Comb(LL n,LL k){\n    LL u=fact[n];\n    LL d=(fact[k]*fact[n-k])%MOD;\n    return (u*invMod(d))%MOD;\n}\n\n//a^n (mod MOD)\n//O(log a)\nLL pow_mod(LL a,LL n){\n    LL res=1;\n    LL b=1;\n    a%=MOD;\n    while(n>=b){\n        if(n&b)\n            res=(res*a)%MOD;\n        a=(a*a)%MOD;\n        b<<=1;\n    }\n    return res;\n}\n\ntypedef vector<LL> V;\ntypedef vector<V> VV;\nint main(){\n    LL N,M,K;\n    cin>>N>>M>>K;\n    if(N>1000||M>1000||K>1000)return -1;\n\n    LL res=0;\n    for(LL i=0;i<=M;i++)\n        for(LL j=0;j<=K;j++){\n                LL a=Comb(N-1+i+j,N-1)*Comb(i+j,i)%MOD;\n                a=a*pow_mod(3,M+K-i-j)%MOD;\n                res=(res+a)%MOD;\n            }\n    \n    cout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// see https://gist.github.com/LumaKernel/ff55d49ee1af69b7388f15b707e75c15\nconst bool DEBUG = 1;\n#include <iostream>\n#include <vector>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n#include <random>\n#include <iomanip>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing  P = tuple<ll, ll>;\nusing  P3 = tuple<ll, ll, ll>;\nusing  VI = vector<int>;\nusing  VL = vector<ll>;\nusing  VP = vector<P>;\nusing  VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\"\n\n#define dump(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dump2(x,y) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)<<\"\\n\"\n#define dump3(x,y,z) if(DEBUG)cerr<<\"[\"<<__LINE__<<\"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)\\\n  <<\" , \"<<#z<<\"=\"<<(z)<<\"\\n\"\n\n#define SAY(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<(x)<<\"\\n\"\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\"\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\"\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\"\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7; template <typename T> function<T(T,T)> constexpr mmin(){ return [](T x, T y){return x<y?x:y;}; }\ntemplate <typename T> function<T(T,T)> constexpr mmax(){ return [](T x, T y){return x>y?x:y;}; }\ntemplate <typename T> function<T(T,T)> constexpr madd(){ return [](T x, T y){return x+y;}; }\ntemplate <typename T> function<T(T,T)> constexpr modadd(){ return [](T x, T y){return ((x+y)%MOD+MOD)%MOD;}; }\n\nll ans;\nconst int N = 1e6;\n\nll pascalsum[N];\n\nint add(int a, int b) {\n\treturn ((((ll) a + b) % MOD) + MOD) % MOD;\n}\n\nint mul(int a, int b){\n\treturn (ll)a*b%MOD;\n}\n\nint pow(int a, int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b&1) res = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>=1;\n\t}\n\treturn res;\n}\n\nint inv(int a) {\n\treturn pow(a, MOD - 2);\n}\n\nint fact[N];\nint invFact[N];\n\nint nCr(int n, int r) {\n\treturn mul(fact[n], mul(invFact[r], invFact[n-r]));\n}\n\nint main() {\n\t//#####//\n\tfact[0]  = invFact[0] = 1;\n\tFOR(i, 1, N) {\n\t\tfact[i] = (ll)fact[i-1] * i % MOD;\n\t\tinvFact[i] = inv(fact[i]);\n\t}\n\n\tint n=ini, M=ini, K=ini;\n\tpascalsum[0] = 1;\n\tFOR(i, 1, M + K + 1) {\n\t\tpascalsum[i] = mul(2, pascalsum[i-1]);\n\t\tif(i >= M + 1) pascalsum[i] = add(pascalsum[i], - nCr(i-1, M));\n\t\tif(i >= K + 1) pascalsum[i] = add(pascalsum[i], - nCr(i-1, i - (K + 1)));\n\t}\n\n\tFOR(t, n, n+M+K+1) {\n\t\tint T = n + M + K;\n\t\tans += ((ll)(nCr(t-1, n-1)) * pow(3, T-t) % MOD) * pascalsum[t-n] % MOD; ///\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 21);\nconst int mod = (int)1e9 + 7;\nconst double PI = acos(-1);\n\ninline void addmod(int& x, int y, int mod) { (x += y) >= mod && (x -= mod); }\ninline int mulmod(int x, int y, int mod) { return x * 1ll * y % mod; }\n\nstruct complex_base\n{\n\tdouble x, y;\n\tcomplex_base(double _x = 0, double _y = 0) { x = _x; y = _y; }\n\tfriend complex_base operator-(const complex_base &a, const complex_base &b) { return complex_base(a.x - b.x, a.y - b.y); }\n\tfriend complex_base operator+(const complex_base &a, const complex_base &b) { return complex_base(a.x + b.x, a.y + b.y); }\n\tfriend complex_base operator*(const complex_base &a, const complex_base &b) { return complex_base(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x); }\n\tfriend void operator/=(complex_base &a, const double &P) { a.x /= P; a.y /= P; }\n};\n\nint bit_rev[MAXN];\n\nvoid fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tdouble ang = 2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n}\n\nvoid inv_fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tdouble ang = -2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] /= n;\n}\n\ncomplex_base A[MAXN], B[MAXN];\n\nvector<int> mult(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() <= 128)\n\t{\n\t\tvector<int> ans(a.size() + b.size(), 0);\n\t\tfor(int i = 0; i < (int)a.size(); i++)\n\t\t\tfor(int j = 0; j < (int)b.size(); j++)\n\t\t\t\tans[i + j] = (ans[i + j] + a[i] * 1ll * b[j]) % mod;\n\n\t\treturn ans;\n\t}\n\n\tint lg = 0; while((1 << lg) < (int)(a.size() + b.size())) ++lg;\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = B[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = complex_base(a[i], 0);\n\tfor(int i = 0; i < (int)b.size(); i++) B[i] = complex_base(b[i], 0);\n\n\tfft(A, lg); fft(B, lg);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tA[i] = A[i] * B[i];\n\tinv_fft(A, lg);\n\n\tvector<int> ans(a.size() + b.size(), 0);\n\tfor(int i = 0; i < (int)ans.size(); i++)\n\t\tans[i] = (int64_t)(A[i].x + 0.5) % mod;\n\n\treturn ans;\n}\n\nvector<int> mult_mod(const vector<int> &a, const vector<int> &b)\n{\n\t/// Thanks pavel.savchenkov\n\n\t// a = a0 + sqrt(MOD) * a1\n\t// a = a0 + base * a1\n\tint base = (int)sqrtl(mod);\n\n\tvector<int> a0(a.size()), a1(a.size());\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t{\n\t\ta0[i] = a[i] % base;\n\t\ta1[i] = a[i] / base;\n\t}\n\n\tvector<int> b0(b.size()), b1(b.size());\n\tfor(int i = 0; i < (int)b.size(); i++)\n\t{\n\t\tb0[i] = b[i] % base;\n\t\tb1[i] = b[i] / base;\n\t}\n\n\tvector<int> a01 = a0;\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t\taddmod(a01[i], a1[i], mod);  \t\n\n\tvector<int> b01 = b0;\n\tfor(int i = 0; i < (int)b.size(); i++) \n\t\taddmod(b01[i], b1[i], mod);\n\n\tvector<int> C = mult(a01, b01);  // 1\n\n\tvector<int> a0b0 = mult(a0, b0); // 2\n\tvector<int> a1b1 = mult(a1, b1); // 3\n\n\tvector<int> mid = C;\n\tfor(int i = 0; i < (int)mid.size(); i++) \n\t{\n\t\taddmod(mid[i], -a0b0[i] + mod, mod);\n\t\taddmod(mid[i], -a1b1[i] + mod, mod);\n\t}\n\n\tvector<int> res = a0b0;\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, mid[i], mod), mod);\n\n\tbase = mulmod(base, base, mod);\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, a1b1[i], mod), mod);\n\n\treturn res;\n}\n\nint n, m, k;\n\nvoid read()\n{\n\tcin >> n >> m >> k;\n}\n\nvector<int> p1, p2, pw3;\n\nint pw(int x, int p)\n{\n\tint ret = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ret = (ret * 1ll * x) % mod;\n\t\tx = (x * 1ll * x) % mod;\n\t\tp >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint fact[MAXN], inv_fact[MAXN];\nint comb(int n, int k) { if(n < 0 || k < 0 || n < k) return 0; return (((fact[n] * 1ll * inv_fact[n - k]) % mod) * 1ll * inv_fact[k]) % mod; }\n\n/*   SUM C(n + i - 1, i) * C(n + i - 1 + j, j)   */\n/*   SUM C(n + i - 1, i) * fact[n + i - 1 + j] / (fact[j] * fact[n + i - 1])    */\n\n\nvoid solve()\n{\t\n\tpw3.assign(n + m + k + 1, 0);\n\tp1.assign(m + 1, 0);\n\tp2.assign(k + 1, 0);\n\tpw3[0] = 1; for(int i = 1; i <= m + k + n; i++) pw3[i] = (3ll * pw3[i - 1]) % mod;\n\tfact[0] = 1; for(int i = 1; i <= m + k + n; i++) fact[i] = (fact[i - 1] * 1ll * i) % mod;\n\tinv_fact[m + k + n] = pw(fact[m + k + n], mod - 2); for(int i = n + k + m - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * 1ll * (i + 1)) % mod; \n\n\tfor(int i = 0; i <= m; i++) p1[i] = (comb(n + i - 1, i) * 1ll * inv_fact[n + i - 1]) % mod;\n\tfor(int i = 0; i <= k; i++) p2[i] = inv_fact[i];\n\n\tvector<int> ret = mult_mod(p1, p2);\n\t\n\tint answer = 0;\n\tfor(int i = 0; i < (int)ret.size(); i++)\n\t{\n\t\tif(m + k - i < 0) break;\n\n\t\tint curr = (ret[i] * 1ll * pw3[m + k - i]) % mod;\n\t\tcurr = (curr * 1ll * fact[n - 1 + i]) % mod;\n\t\taddmod(answer, curr, mod);\n\t}\n\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300005\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nll up,n,m,k;\nll ans=0,fac[N*3],ifac[N*3],mul[N*3];\ninline ll calc(int a,int b){return fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\ninline ll ksm(ll x,int p){\n\tll ret=1;\n\twhile(p){\n\t\tif(p&1)ret=ret*x%mod;\n\t\tx=x*x%mod,p>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n>>m>>k,up=n+m+k,fac[0]=mul[0]=ifac[1]=ifac[0]=1;\n\tfor(ll i=2;i<=up;++i)ifac[i]=(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(ll i=1;i<=up;++i)mul[i]=mul[i-1]*3%mod,(ifac[i]*=ifac[i-1])%=mod,fac[i]=fac[i-1]*i%mod;\n\tif(m<k)m^=k,k^=m,m^=k;\n\tfor(ll i=0,j=1;i<=m+k;++i){\n\t\t(ans+=calc(n-1+i,n-1)*mul[m+k-i]%mod*j%mod)%=mod;\n\t\tif(i<k)(j<<=1)%=mod;\n\t\telse if(i>=m)(j+=j-calc(i,k)-calc(i,i-m))%=mod;\n\t\telse (j+=j-calc(i,k))%=mod;\n\t}\n\tcout<<(ans+mod)%mod;\n\treturn 0;\n}\n\n---------------------\n\n本文来自 dreaming__ldx 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/dreaming__ldx/article/details/82778499?utm_source=copy "
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=1000000+10;\n\nconst int mod=1e9+7;\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint fac[N],ifac[N],pw[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n    for (re int i=pw[0]=1;i<=n;++i) pw[i]=3ll*pw[i-1]%mod;\n}\n\ninline int C(int n,int m) {\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main() { init(1000000);\n    int n=read(),m=read(),k=read();\n    int ans=0,lst=1;\n    for (re int i=0;i<=m+k;++i) {\n        ans=(ans+1ll*C(n+i-1,n-1)*pw[m+k-i]%mod*lst)%mod;\n        if (i<k) lst=2ll*lst%mod;\n        else if (i<m) lst=(2ll*lst+mod-C(i,k))%mod;\n        else lst=(2ll*lst+mod-C(i,k)+mod-C(i,m))%mod;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef ONLINE_JUDGE\n#define freopen \\\n  if (0) freopen\n#define cerr \\\n  if (0) cerr\n#endif\n\n#define fi first\n#define se second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n\n#define sqr(a) ((a)*1ll * (a))\n#define sz(a) (int)a.size()\n#define len(a) (int)a.length()\n#define all(a) a.begin(), a.end()\n#define nl '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nvector<int> fact;\n\nint powm(int n, int p) {\n  int res = 1;\n  while (p > 0) {\n    if (p & 1) \n      res = (res * 1ll * n) % mod;\n    p >>= 1;\n    n = (n * 1ll * n) % mod;\n  }\n  return res;\n}\n\nint inv(int n) {\n  return powm(n, mod - 2);\n}\n\nint binom(int n, int k) {\n  return (fact[n] * 1ll * inv((fact[k] * 1ll * fact[n - k]) % mod)) % mod;\n}\n\nvoid solve() {\n  fact.resize(1e6);\n  fact[0] = 1;\n  rep(i, 1, 1e6) {\n    fact[i] = (fact[i - 1] * 1ll * i) % mod;\n  }\n\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  int l = n + m + k;\n  int res = 0;\n  rep(i, n, l) {\n    int sum = 0;\n    rep(j, max(0, i - n - k), min(i - n, m)) {\n      sum += binom(i - n, j);\n      sum %= mod;\n    }\n    int temp = (sum * 1ll * binom(i - 1, n - 1)) % mod;\n    res += (temp * 1ll * powm(3, l - i)) % mod;\n    res %= mod;\n  }\n\n  cout << res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  freopen(\".in\", \"r\", stdin);\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)));\n#define Mx(a , b) ((a) > (b) ? (a) : (b))\n#define Mn(a , b) ((a) < (b) ? (a) : (b))\n\nconst double EPS = 1e-10;\nconst int INF = 2147483647;\nconst LL mod = 1e9 + 7;\n\nint N , M , K;\nLL c[600010];\nLL t[600010];\nLL p[900010];\nLL r[600010];\nLL ans;\n\nLL conv(int a , int b){\n\treturn (p[a] * r[b] % mod) * r[a - b] % mod;\n}\n\nint main(){\n\tscanf(\"%d%d%d\" , &N , &M , &K);\n\tp[0] = p[1] = 1;\n\tfor(int i = 2 ; i < N + M + K ; ++i){\n\t\tp[i] = (p[i - 1] * i) % mod;\n\t}\n\tint s = M + K + N - 1;\n\tLL x = p[s];\n\tr[s] = 1;\n\tfor(int i = (int)mod - 2 ; i > 0; i /= 2 , x = (x * x) % mod){\n\t\tif(i % 2 == 1) r[s] = (r[s] * x) % mod;\n\t}\n\tfor(int i = s - 1 ; i >= 0 ; --i){\n\t\tr[i] = r[i + 1] * (i + 1) % mod;\n\t}\n\tc[0] = t[0] = 1;\n\tfor(int i = 1 ; i <= M + K ; ++i){\n\t\tt[i] = (t[i - 1] * 3) % mod;\n\t}\n\tif(K < M){\n\t\tK ^= M;\n\t\tM ^= K;\n\t\tK ^= M;\n\t}\n\ts = K + M;\n\tfor(int i = 1 ; i <= M ; ++i){\n\t\tc[i] = c[i - 1] * 2 % mod;\n\t}\n\tc[s] = conv(s , K);\n\tfor(int i = s - 1 ; i >= K ; --i){\n\t\tc[i] = (c[i + 1] + conv(i , K) + conv(i , M)) * r[2] % mod;\n\t}\n\tfor(int i = K - 1 ; i > M ; --i){\n\t\tc[i] = (c[i + 1] + conv(i , M)) * r[2] % mod;\n\t}\n\tfor(int i = s ; i >= 0 ; --i){\n\t\tx = p[i + N - 1] * t[s - i] % mod;\n\t\tx = x * r[N - 1] % mod;\n\t\tx = x * c[i] % mod;\n\t\tx = x * r[i] % mod;\n\t\tans += x;\n\t\tans %= mod;\n\t}\n\tprintf(\"%lld\\n\" , ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int nMax=3*1e5+10;\nconst int Mod=1e9+7;\nint jc[2*nMax],_jc[2*nMax],bin[2*nMax];\nint power(int a,int b)\n{\n\tif(b==0)\n\t\treturn 1;\n\tint c=power(a,b>>1);\n\tc=(long long)c*c%Mod;\n\tif(b%2)\n\t\tc=(long long)c*a%Mod;\n\treturn c;\n}\nvoid work()\n{\n\tjc[0]=1;\n\tfor(int i=1;i<2*nMax;i++)\n\t\tjc[i]=(long long)jc[i-1]*i%Mod;\n\t_jc[2*nMax-1]=power(jc[2*nMax-1],Mod-2);\n\tfor(int i=2*nMax-2;i>=0;i--)\n\t\t_jc[i]=(long long)_jc[i+1]*(i+1)%Mod;\n\tbin[0]=1;\n\tfor(int i=1;i<2*nMax;i++)\n\t\tbin[i]=(bin[i-1]<<1)%Mod;\n}\nint _c(int a,int b)\n{\n\tif(b==0)\n\t\treturn 1;\n\tint ans=jc[b];\n\tans=(long long)ans*_jc[b-a]%Mod;\n\tans=(long long)ans*_jc[a]%Mod;\n\treturn ans;\n}\nint n,m,k,ans;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\twork();\n\tif(m>k)\n\t\tswap(m,k);\n\tfor(int i=0;i<=m;i++)\n\t\tans=(ans+((long long)bin[i]*_c(i,i+n-1)%Mod*power(3,n+m+k-i-n))%Mod)%Mod;\n\tint last=bin[m];\n\tfor(int i=m+1;i<=m+k;i++)\n\t{\n\t\tlast=(last<<1)%Mod;\n\t\tlast-=2*_c(m,i-1);\n\t\tlast=(last%Mod+Mod)%Mod;\n\t\tans=(ans+(long long)last*_c(i,i+n-1)%Mod*power(3,n+m+k-i-n)%Mod)%Mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define ull unsigned long long\n#define db long double\n#define pb push_back\n#define ppb pop_back\n#define F first\n#define S second\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\n\ntypedef complex <double> cd;\nconst int K = 20, MOD = 1e9 + 7, C = 31622;\nconst double PI = acos(-1);\nvector <cd> w[K + 1];\nint lg[(1 << K) + 1];\n\nvoid fft(vector <cd> & a, int inv) {\n\tint n = a.size();\n\n\tint j = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = n >> 1;\n\t\tfor (; j & k; k >>= 1) {\n\t\t\tj ^= k;\n\t\t}\n\t\tj ^= k;\n\t\tif (i < j) {\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tcd even, odd;\n\tfor (int len = 2; len <= n; len <<= 1) {\n\t\tint m = lg[len];\n\t\tfor (int i = 0; i < n; i += len) {\n\t\t\tfor (int j = 0; j < len / 2; j++) {\n\t\t\t\teven = a[i + j], odd = a[i + j + len / 2];\n\t\t\t\tif (inv) {\n\t\t\t\t\teven /= 2, odd /= 2;\n\t\t\t\t\todd *= w[m][j == 0 ? 0 : len - j];\n\t\t\t\t}\telse {\n\t\t\t\t\todd *= w[m][j];\n\t\t\t\t}\n\t\t\t\ta[i + j] = even + odd;\n\t\t\t\ta[i + j + len / 2] = even - odd;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvll mul(const vi & a, const vi & b) {\n\tvector <cd> fa(all(a)), fb(all(b));\n\tint n = 1, need = a.size() + b.size();\n\twhile (n < need) {\n\t\tn <<= 1;\n\t}\n\tfa.resize(n);\n\tfb.resize(n);\n\tfft(fa, 0);\n\tfft(fb, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfa[i] *= fb[i];\n\t}\n\tfft(fa, 1);\n\tvll res(need - 1);\n\tfor (int i = 0; i < need - 1; i++) {\n\t\tres[i] = llround(fa[i].real());\n\t}\n\treturn res;\n}\n\nvi conv(const vi & a, const vi & b) {\n\tint A = a.size(), B = b.size();\n\tvi a1(A), a2(A);\n\tfor (int i = 0; i < A; i++) {\n\t\ta1[i] = a[i] % C;\n\t\ta2[i] = a[i] / C;\n\t}\n\tvi b1(B), b2(B);\n\tfor (int i = 0; i < B; i++) {\n\t\tb1[i] = b[i] % C;\n\t\tb2[i] = b[i] / C;\n\t}\n\tvll c11 = mul(a1, b1);\n\tvll c12 = mul(a1, b2);\n\tvll c21 = mul(a2, b1);\n\tvll c22 = mul(a2, b2);\n\t\n\tvi res(A + B - 1);\n\tfor (int i = 0; i < A + B - 1; i++) {\n\t\tres[i] = c11[i] % MOD;\n\t\tres[i] += (ll)C * ((c12[i] + c21[i]) % MOD) % MOD;\n\t\tif (res[i] >= MOD) {\n\t\t\tres[i] -= MOD;\n\t\t}\n\t\tres[i] += (ll)C * C * (c22[i] % MOD) % MOD;\n\t\tif (res[i] >= MOD) {\n\t\t\tres[i] -= MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid pre_fft() {\n\tfor (int i = 2; i <= 1 << K; i++) {\n\t\tlg[i] = lg[i / 2] + 1;\n\t}\n\tfor (int i = 0; i <= K; i++) {\n\t\tw[i].resize(1 << i);\n\t\tdouble ang = 2 * PI / (1 << i);\n\t\tfor (int j = 0; j < 1 << i; j++) {\n\t\t\tw[i][j] = cd(cos(j * ang), sin(j * ang));\n\t\t}\n\t}\n}\n\nconst int N = 6e5 + 123;\nint fact[N], rev[N], pw[N];\n\nint binpow(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) {\n\t\t\tres = (ll)res * x % MOD;\n\t\t}\n\t\tx = (ll)x * x % MOD;\n\t\ty /= 2;\n\t}\n\treturn res;\n}\n\nint binomial(int n, int k) {\n\tif (k > n) {\n\t\treturn 0;\n\t}\n\treturn ((ll)fact[n] * rev[k] % MOD) * rev[n - k] % MOD;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\t\n\tpre_fft();\n\tfact[0] = rev[0] = pw[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tfact[i] = (ll)fact[i - 1] * i % MOD;\n\t\trev[i] = (ll)rev[i - 1] * binpow(i, MOD - 2) % MOD;\n\t\tpw[i] = (ll)pw[i - 1] * 3 % MOD;\n\t}\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\t\n\tvi a(m + 1), b(k + 1);\n\tfor (int i = 0; i <= m; i++) {\n\t\ta[i] = rev[i];\n\t}\n\tfor (int i = 0; i <= k; i++) {\n\t\tb[i] = rev[i];\n\t}\n\tvi c = conv(a, b);\n\tint res = 0;\n\tfor (int i = 0; i <= m + k; i++) {\n\t\tint tmp = (ll)pw[m + k - i] * binomial(n - 1 + i, n - 1) % MOD;\n\t\ttmp = (ll)tmp * fact[i] % MOD;\n\t\ttmp = (ll)tmp * c[i] % MOD;\n\t\tres += tmp;\n\t\tif (res >= MOD) {\n\t\t\tres -= MOD;\n\t\t}\n\t}\n\tcout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 1000000007;\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< mod >;\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\nvector<ll> inv, FactorialInv, Factorial;\nll beki(ll a, ll b){\n    ll ret = 1 % mod;\n    a %= mod;\n    while(b) {\n        if(b & 1LL) ret = ret * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return ret;\n}\nvoid init_combination(ll MAX){\n    Factorial.resize(MAX + 1);\n    FactorialInv.resize(MAX + 1);\n    inv.resize(MAX + 1);\n    Factorial[0] = 1;\n    inv[0] = 1;\n    for(int i = 1; i <= MAX; i++){\n        Factorial[i] = Factorial[i - 1] * i % mod;\n    }\n    FactorialInv[MAX] = beki(Factorial[MAX], mod - 2);\n    for(ll i = MAX - 1; i >= 0; i--) {\n        FactorialInv[i] = FactorialInv[i+1] * (i+1) % mod;\n    }\n    for(int i = 1; i <= MAX; i++) {\n        inv[i] = FactorialInv[i] * Factorial[i-1] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(a < b) return 0;\n    if(b < 0) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\nll N, M, K;\nmodint f(ll M, ll K) {\n    modint ret = 0;\n    vector<modint> C;\n    vector<modint> A(M+1), B(K+1);\n    for(int i = 0; i <= M; i++) {\n        A[i] = FactorialInv[i];\n    }\n    for(int i = 0; i <= K; i++) {\n        B[i] = FactorialInv[i];\n    }\n    ArbitraryModConvolution<modint> NTT;\n    C = NTT.multiply(A, B);\n    for(int s = 0; s <= M + K; s++) {\n        modint tmp1 = Factorial[N+s];\n        tmp1 *= C[s];\n        ret += tmp1 * beki(beki(3, mod - 2), s);\n        //cerr << s << \" \" << tmp1 << \" \" << tmp2 << endl;\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init_combination(1e6);\n    cin >> N >> M >> K;\n    modint ans = 0;\n    /*\n    for(int s = 0; s <= M + K; s++) {\n        modint tmp1 = Factorial[N+s] * FactorialInv[N];\n        tmp1 *= C[s];\n        modint tmp2 = 0;\n        if(s) {\n            tmp2 = Factorial[N+s-1] * FactorialInv[N];\n            tmp2 *= C[s-1];\n            tmp2 *= 2;\n        }\n        modint tmp = (tmp1 - tmp2);\n        ans += tmp * beki(3, M + K - s);\n        cerr << s << \" \" << tmp1 << \" \" << tmp2 << endl;\n    }\n    */\n    ans += f(M, K);\n    cerr << ans << endl;\n    ans -= f(M-1, K) * beki(3, mod - 2);\n    cerr << ans << endl;\n    ans -= f(M, K-1) * beki(3, mod - 2);\n    cerr << ans << endl;\n    ans *= FactorialInv[N];\n    ans *= beki(3, M + K);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\ntypedef long long ll;\ninline int read(){\n\tR int x; R bool f; R char c;\n\tfor (f = 0; (c = getchar()) < '0' || c > '9'; f = c == '-');\n\tfor (x = c ^ '0'; (c = getchar()) >= '0' && c <= '9'; x = (x << 1) + (x << 3) + (c ^ '0'));\n\treturn f ? -x : x;\n}\n#define MN 900005\nconst int P = 1000000007;\nint inv[MN], frac[MN], p3[MN];\ninline int mul(int x, int y){return (ll)x * y % P;}\ninline int plu(int x, int y){return (x += y) >= P ? x - P : x;}\ninline int fpw(int x, int k){\n\tR int res = 1;\n\tfor (; k; k >>= 1, x = mul(x, x)) \n\t\tif (k & 1) res = mul(res, x);\n\treturn res;\n}\ninline int C(int n, int m){if (m < 0 || m > n) return 0; return mul(frac[n], mul(inv[m], inv[n-m]));}\nint n, m, k, res = 1, ans = 0;\nint main(){\n\tn = read(), m = read(), k = read();\n\tp3[0] = frac[0] = 1;\n\tfor (R int i = 1; i <= m + k; ++i) p3[i] = mul(p3[i - 1] , 3);\n\tfor (R int i = 1; i <= n + m + k; ++i) frac[i] = mul(frac[i - 1], i);\n\tinv[n + m + k] = fpw(frac[n + m + k], P - 2);\n\tfor (R int i = n + m + k; i--; ) inv[i] = mul(inv[i + 1], i + 1);\n\tfor (R int i = n; i <= n + m + k; ++i) {\n\t\tans = plu(ans, mul(p3[n + m + k - i], mul(C(i - 1, n - 1), res)));\n\t\tres = plu(plu(res, res), plu(plu(-C(i - n, i - n -k), P), plu(-C(i - n, m), P)));\n\t}\n\tprintf(\"%d\\n\", ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nconst int kN = 1000000 + 5;\nconst int MOD = (int)1e9 + 7;\nint Inv[kN], Finv[kN], F[kN], n, m, k;\nint pascal[kN];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return F[a] * 1LL * Finv[b] % MOD * Finv[a - b] % MOD;\n}\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nint power(int a, int b, int p)\n{\n    int ret = 1;\n    for ( ; b; b >>= 1, a = a * 1LL * a % MOD)\n        if (b & 1)\n            ret = ret * 1LL * a % MOD;\n    return ret;\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kN; ++ i)\n        Inv[i] = (MOD - MOD / i) * 1LL * Inv[MOD % i] % MOD;\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kN; ++ i) {\n        F[i] = F[i - 1] * 1LL * i % MOD;\n        Finv[i] = Finv[i - 1] * 1LL * Inv[i] % MOD;\n    }\n    scanf(\"%d%d%d\", &n, &m, &k);\n    pascal[0] = 1;\n    for (int i = 1; i <= m + k; ++ i) {\n        pascal[i] = (pascal[i - 1] << 1) % MOD;\n        if (i >= m + 1) add(pascal[i], MOD - binom(i - 1, m));\n        if (i >= k + 1) add(pascal[i], MOD - binom(i - 1, k));\n    }\n    int result = 0;\n    int t = n + m + k;\n    for (int i = n; i <= t; ++ i) {\n        add(result, binom(i - 1, n - 1) * 1LL * power(3, t - i, MOD) % MOD * pascal[i - n] % MOD);\n    }\n    printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nconstexpr lint MOD = 1000000007;\nvector<lint> fac, facInv, inv;\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\nlint power(lint x, lint n)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) (ans *= x) %= MOD;\n        (x *= x) %= MOD;\n       n >>= 1;\n    }\n   return ans;\n}\nlint N, M, K;\nint main()\n{\n    facInit(1000000);\n    cin >> N >> M >> K;\n    lint ans = 0, bc = 1;\n    REP(i, M + K + 1) // bc = aがN個出てくるまでに登場するbとcの並び方のパターン, i=個数\n    {\n        if (i) bc *= 2;\n        if (i > M) bc -= nCr(i - 1, M );\n        if (i > K) bc -= nCr(i - 1, K );\n        bc = (bc % MOD + MOD) % MOD;\n\n        ans += power(3, M + K - i) * nCr(N + i - 1, i) % MOD * bc % MOD;\n        ans %= MOD;\n        // dbg(bc);\n        // dbg(ans);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint n,m,k;\nlong long inv[900010],fac[900010],p[900010],ans;\nconst long long mod=1e9+7;\ninline long long ksm(long long x,long long y)\n{\n\tlong long res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\tres=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t} \n\treturn res;\n}\ninline long long c(int x,int y)\n{\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tif(m<k)\n\tswap(m,k);\n\tp[0]=1ll;\n\tfac[0]=1ll;\n\tinv[0]=1ll;\n\tfor(int i=1;i<=9e5;++i)\n\t{\n\t\tp[i]=p[i-1]*3ll%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tinv[900000]=ksm(fac[900000],mod-2);\n\tfor(int i=9e5-1;i>=1;--i)\n\tinv[i]=inv[i+1]*(long long)(i+1)%mod;\n\tlong long x=1;\n\t--n;\n\tfor(int i=0;i<=m+k;++i)\n\t{\n\t\tans=(ans+c(n+i,n)*p[m+k-i]%mod*x)%mod;\n\t\tif(i<k)\n\t\tx=x*2ll%mod;\n\t\telse if(i<m)\n\t\tx=(x*2ll-c(i,k)+mod)%mod;\n\t\telse \n\t\tx=(x*2ll-c(i,k)-c(i,m)+mod+mod)%mod;\t\t\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define OUT(x)                cout << #x << \" = \" << x << endl; \n#define rep(i, n)             for (int (i) = 0; (i) < (int)(n); (i)++)\n#define rer(i, l, r)          for (int (i) = (int)(l); (i) <= (int)(r); (i)++)\n#define reu(i, l, r)          for (int (i) = (int)(l); (i) < (int)(r); (i)++)\n#define each(i, v)            for (auto i : v)\n#define all(x)                (x).begin(), (x).end()\n#define rall(x)               (x).rbegin(), (x).rend()\n#define pb(x)                 push_back(x)\n#define bp(x)                 __builtin_popcount(x)\n#define mp(x, y)              make_pair((x), (y))\n#define fi                    first\n#define se                    second\n#define setp(x)               setprecision(x)\n#define mset(m, v)            memset(m, v, sizeof(m))\n#define sz(x)                 (int)(x.size())\nstatic const int INF        = 0x3f3f3f3f;\nstatic const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD        = 1000000007;\nstatic const double PI      = 3.141592653589793238462643383279;\n\n#define int                   long long\n\ntypedef vector<double>        vd;\ntypedef vector<string>        vs;\ntypedef vector<bool>          vb;\ntypedef vector<int>           vi;\ntypedef pair<int, int>        pii;\ntypedef vector<pii>           vpii;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; i ++) cout << *i << \" \"; cout << endl; }\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\n//int in() { int _x; scanf(\"%d\", &_x); return _x; }\nlong long lin() {long long _x; scanf(\"%lld\", &_x); return _x; };\n\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n        long long d = a;\n        if (b != 0) {\n                d = extgcd(b, a % b, y, x);\n                y -= (a / b) * x;\n        } else {\n                x = 1;\n                y = 0;\n        }\n        return d;\n}\n\nlong long inv(long long a) {\n        long long x, y;\n        extgcd(a, MOD, x, y);\n        return (x % MOD + MOD) % MOD;\n}\n\nlong long nCr(long long n, long long r) {\n        if (n < r) return 0;\n        if (n - r < r) r = n - r;\n        long long ret = 1;\n        rep(i, r) {\n                ret *= n;\n                -- n;\n                ret %= MOD;\n                ret *= inv(i + 1);\n                ret %= MOD;\n        }\n        return ret;\n}\n\nlong long mod_pow(long long x, long long n) {\n        long long res = 1;\n        while (n > 0) {\n                if (n & 1) res = res * x % MOD;\n                x = x * x % MOD;\n                n >>= 1;\n        }\n        return res;\n}\n\nsigned main() { \n        int n, m, k;\n        cin >> n >> m >> k;\n        int ans = 0;\n        for (int i = n; i <= n + m + k; i ++) {\n                int x = nCr(i - 1, n - 1);\n                int y = 0;\n                for (int j = max(0LL, i - n - k); j <= min(i - n, m); j ++) {\n                        y += nCr(i - n, j);\n                        y %= MOD;\n                }\n                int z = mod_pow(3, n + m + k - i);\n                OUT(z);\n                OUT(y);\n                OUT(x);\n                ans += x * y % MOD * z; \n                ans %= MOD;\n        }\n        ans %= MOD;\n        cout << ans << endl;\n        return 0;\n}               \n\n"
  },
  {
    "language": "C++",
    "code": "# include \"iostream\"\n# include \"cstdio\"\n\nusing namespace std;\n\nconst int maxm=3e5+10;\nconst int Mod=1e9+7;\n\nint N,M,K,Max;\nlong long Fac[maxm],Inv1[maxm],Inv2[maxm],P[maxm];\n\nlong long C(int x,int y){\n\treturn Fac[x]*Inv2[y]%Mod*Inv2[x-y]%Mod;\n}\n\nint main(){\n\tregister int i,j;\n\tregister long long Ans=0;\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tMax=N+M+K;\n\tFac[0]=Fac[1]=Inv1[0]=Inv1[1]=Inv2[0]=Inv2[1]=1;\n\tP[0]=1,P[1]=3;\n\tfor(i=2;i<=Max;i++){\n\t\tFac[i]=Fac[i-1]*i%Mod;\n\t\tInv1[i]=(Mod-Mod/i)*Inv1[Mod%i]%Mod;\n\t\tInv2[i]=Inv2[i-1]*Inv1[i]%Mod;\n\t\tP[i]=P[i-1]*3%Mod;\n\t}\n\tif(M<K) swap(M,K);\n\tfor(i=0,j=1;i<=M+K;i++){\n\t\tAns=(Ans+C(N-1+i,N-1)*P[M+K-i]%Mod*j)%Mod;\n        if(i<K) j=j*2%Mod;\n        else if(i>=M) j=((j<<1)-C(i,K)-C(i,i-M)+(Mod<<1))%Mod;\n\t\telse j=((j<<1)-C(i,K)+Mod)%Mod;\n\t}\n\tprintf(\"%lld\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\nconst int mod=1e9+7;\nconst int INF=0x3f3f3f3f;\nll quick(ll a,ll b)\n{\n\tll ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nconst int maxn=3e3+7;\nll C[maxn][maxn];\nvoid db()\n{\n\tfor(int i=0;i<maxn;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n}\nint main()\n{\n\tdb();\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tll ans=0;\n\tfor(int t=n;t<=n+m+k;t++)\n\t{\n\t\tll cur=0;\n\t\tfor(int i=max(0,t-n-k);i<=min(m,t-n);i++)\n\t\t\tcur=(cur+C[t-n][i])%mod;\n\t\tans=(ans+cur*C[t-1][n-1]%mod*quick(3,n+m+k-t)%mod)%mod;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,n) for(int _tmp=n,i=a;i<=_tmp;++i)\n#define dep(i,a,n) for(int _tmp=n,i=a;i>=_tmp;--i)\n#define re(i,a,n) for(int _tmp=n,i=a;i<_tmp;++i)\n#define fec(i,a) for(__typeof a.begin() i=a.begin();i!=a.end();++i)\n#define For(i,v,u) for(int i=H[u],v=to[i];i;i=nxt[i],v=to[i])\n#define si(x) (int)x.size()\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define X first\n#define Y second\n#define inf 1000000000\nusing namespace std;\ntemplate<class T> inline void read(T&x){char c;bool fu=0;for(c=getchar();c<=32;c=getchar());if(c=='-')fu=1,c=getchar();for(x=0;c>32;c=getchar())x=x*10+c-'0';if(fu)x*=-1;}\ntemplate<class T> inline void read(T&x,T&y){read(x);read(y);}\ntemplate<class T> inline void read(T&x,T&y,T&z) {read(x,y);read(z);}\ntemplate<class T> inline void MAX(T&x,T y){if(x<y)x=y;}\ntemplate<class T> inline void MIN(T&x,T y){if(x>y)x=y;}\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> tiii;\nconst int N=1111111;\nconst ll mo=1e9+7;\n//head\nll fac[N],inv[N],ans;\nint n,m,k;\nll C(int n,int m){\n\tif(n<m)return 0;\n\treturn fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nll pw(ll a,ll b,ll p=mo){\n\tll an=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)an=an*a%mo;\n\t\ta=a*a%mo;\n\t}\n\treturn an;\n}\nint main() {\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\trep(i,2,1000000)fac[i]=fac[i-1]*i%mo;\n\trep(i,2,1000000)inv[i]=(mo-mo/i)*inv[mo%i]%mo;\n\trep(i,2,1000000)inv[i]=inv[i-1]*inv[i]%mo;\n\tread(n,m,k);\n\t//rep(i,0,m)rep(j,0,k)(ans+=C(i+j+n-1,i+j)*C(i+j,j)%mo*pw(3,m+k-i-j)%mo)%=mo;\n\t//rep(i,0,m+k)rep(j,max(0,i-k),min(i,m))(ans+=C(i+n-1,i)*C(i,j)%mo*pw(3,m+k-i)%mo)%=mo;ll c\n\tll cur=1;\n\trep(len,0,m+k) {\n\t\tll res=0;\n\t\tres=C(n+len-1,n-1)*pw(3,m+k-len)%mo;\n\t\t(ans+=cur*res%mo)%=mo;\n\t\tcur=cur*2%mo;\n\t\tif(len>=m)cur+=mo-C(len,m);\n\t\tif(len>=k)cur+=mo-C(len,k) ;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\ntypedef long long LL;\n\nconst LL MOD=1e9+7;\n#define SZ 2000000\nLL fact[SZ];\nstruct cww{cww(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    fact[0]=1;\n    for(LL i=1;i<SZ;i++)\n        fact[i]=fact[i-1]*i%MOD;\n}}init;\n// a x + b y = gcd(a, b)\n// O(log (a+b) )\nLL extgcd(LL a, LL b, LL &x, LL &y) {\n  LL g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\n// mを法とするaの逆元\n// O(log a)\nLL invMod(LL a) {\n\tLL x, y;\n\tif (extgcd(a, MOD, x, y) == 1)return (x + MOD) % MOD;\n\telse\t return 0; // unsolvable\n}\n\n\n// 組み合わせnCk (mod MOD)\n// O(n)\nLL Comb(LL n,LL k){\n    LL u=fact[n];\n    LL d=(fact[k]*fact[n-k])%MOD;\n    return (u*invMod(d))%MOD;\n}\n\n//a^n (mod MOD)\n//O(log a)\nLL pow_mod(LL a,LL n){\n    LL res=1;\n    LL b=1;\n    a%=MOD;\n    while(n>=b){\n        if(n&b)\n            res=(res*a)%MOD;\n        a=(a*a)%MOD;\n        b<<=1;\n    }\n    return res;\n}\n\nint main(){\n    LL N,M,K;\n    cin>>N>>M>>K;\n\n    LL res=pow_mod(3,M+K);\n    LL bg=0,ed=0,sum=1;\n    for(LL i=1;i<=M+K;i++){\n        LL ne=min(M,i);\n        LL nb=max(0ll,i-K);\n        sum*=2;\n        if(nb>bg)sum+=MOD-Comb(i-1,bg);\n        if(ne==ed)sum+=MOD-Comb(i-1,ed);\n        sum%=MOD;\n        // cout<<sum<<endl;\n        LL a=Comb(N-1+i,N-1)*sum%MOD;\n        a=a*pow_mod(3,M+K-i)%MOD;\n        res=(res+a)%MOD;\n        ed=ne,bg=nb;\n    }\n    cout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename T> constexpr T fpow_eq(T& x, ll y, T identity = 1) {\n    for(; y > 0; x *= x, y >>= 1) {\n        if(y & 1) {\n            identity *= x;\n        }\n    }\n    return x = identity;\n}\ntemplate <typename T> constexpr T fpow(T x, ll y, T identity = 1) { return fpow_eq(x, y, identity); }\n#ifndef __TOTIENT_INCLUDED_\n#define __TOTIENT_INCLUDED_\ntemplate <typename T, typename TEachDivisor, typename TEachPrime>\nconstexpr void factorize(T n, TEachDivisor each_divisor, TEachPrime each_prime = [](T) {}) {\n    static_assert(is_convertible<decltype(each_divisor), function<void(T)>>::value, \"each_divisor must be void(T)\");\n    static_assert(is_convertible<decltype(each_prime), function<void(T)>>::value, \"each_prime must be void(T)\");\n    for(T i = 2; i * i <= n; i++) {\n        if(n % i == 0) {\n            each_prime(i);\n            while(n % i == 0) {\n                each_divisor(i);\n                n /= i;\n            }\n        }\n    }\n    if(n > 1) {\n        each_divisor(n);\n        each_prime(n);\n    }\n}\ntemplate <typename T> constexpr T phi(T n) {\n    T ans = n;\n    factorize<T>(n, [](T) {}, [&](T p) { ans -= ans / p; });\n    return ans;\n}\n#endif\n#ifdef __TOTIENT_INCLUDED_\ntemplate <int M, int PHI_M = phi(M)> struct modint {\n#else\ntemplate <int M, int PHI_M> struct modint {\n#endif\n    static constexpr int MOD = M;\n    int val;\n    constexpr modint() : val(0) {}\n    constexpr modint(int val) : val(val % M) { this->val += this->val < 0 ? M : 0; }\n    constexpr modint(long long val) : modint(int(val % M)) {}\n    constexpr modint(const modint& m) : val(m.val) {}\n    constexpr modint(const complex<double>& x) : modint(llround(x.real())) {}\n    constexpr explicit operator int() const { return val; }\n    constexpr bool operator==(const modint& y) const { return val == y.val; }\n    constexpr bool operator!=(const modint& y) const { return val != y.val; }\n    constexpr bool operator< (const modint& y) const { return val <  y.val; }\n    constexpr bool operator<=(const modint& y) const { return val <= y.val; }\n    constexpr bool operator> (const modint& y) const { return val >  y.val; }\n    constexpr bool operator>=(const modint& y) const { return val >= y.val; }\n    constexpr modint& operator=(const modint& y) { val = y.val; return *this; }\n    constexpr modint& operator+=(const modint& y) { val += y.val; val -= val >= M ? M : 0; return *this; }\n    constexpr modint& operator-=(const modint& y) { val -= y.val; val += val <  0 ? M : 0; return *this; }\n    constexpr modint& operator*=(const modint& y) { val = ll(val) * y.val % M; return *this; }\n    constexpr modint& operator/=(const modint& y) { val = ll(val) * fpow(y, PHI_M - 1).val % M; return *this; }\n    constexpr modint& operator^=(ll y) { fpow_eq(*this, y); return *this; }\n    constexpr modint operator+(const modint& y) const { return modint(val) += y; }\n    constexpr modint operator-(const modint& y) const { return modint(val) -= y; }\n    constexpr modint operator*(const modint& y) const { return modint(val) *= y; }\n    constexpr modint operator/(const modint& y) const { return modint(val) /= y; }\n    constexpr modint operator^(ll y) const { return modint(val) ^= y; }\n    constexpr modint operator-() const { return modint(0) -= *this; }\n    constexpr modint operator~() const { return modint(1) /= *this; }\n    constexpr modint& operator++() { val = val == M - 1 ? 0 : val + 1; return *this; }\n    constexpr modint& operator--() { val = val == 0 ? M - 1 : val - 1; return *this; }\n    constexpr modint operator++(int) { modint m = *this; ++(*this); return m; }\n    constexpr modint operator--(int) { modint m = *this; --(*this); return m; }\n    friend constexpr modint operator+(long long x, const modint& y) { return modint(x) + y; }\n    friend constexpr modint operator*(long long x, const modint& y) { return modint(x) * y; }\n    friend constexpr modint operator-(long long x, const modint& y) { return modint(x) - y; }\n    friend constexpr modint operator/(long long x, const modint& y) { return modint(x) / y; }\n    friend ostream& operator<<(ostream& os, const modint& m) { return os << m.val; }\n    friend istream& operator>>(istream& is, modint& m) { ll val; is >> val; m = modint(val); return is; }\n};\nconstexpr int M = 1'000'000'007;\nusing mint = modint<M, M - 1>;\nmint operator\"\"_m(unsigned long long int x) { return mint(ll(x)); }\ntemplate <typename T = mint> T fact(int n) {\n    static vector<T> fac = {1};\n    while(fac.size() <= n) {\n        fac.push_back(fac.back() * int(fac.size()));\n    }\n    return fac[n];\n}\ntemplate <typename T = mint> T fact_inv(int n) {\n    static vector<T> inv_fac = {1};\n    while(inv_fac.size() <= n) {\n        inv_fac.push_back(inv_fac.back() / int(inv_fac.size()));\n    }\n    return inv_fac[n];\n}\nconst double PI = acos(-1);\ncomplex<double> w(int len, bool inverse) {\n    return exp((inverse ? -2i : 2i) * (PI / len));\n}\nconstexpr int lg(int x) { return 31 - __builtin_clz(x); }\ntemplate <typename T> vector<T>& pad(vector<T>& a, int min_size) {\n    a.resize(2 << lg(min_size - 1));\n    return a;\n}\nint bit_reverse(int i, int n) {\n    int ans = 0;\n    for(int j = 0; j < lg(n); j++) {\n        ans |= i & (1 << j) ? 1 << (lg(n) - 1 - j) : 0;\n    }\n    return ans;\n}\ntemplate <typename T> vector<T>& fft(vector<T>& a, bool inverse = false) {\n    int n = a.size();\n    for(int i = 0; i < n; i++) {\n        if(i < bit_reverse(i, n)) {\n            swap(a[i], a[bit_reverse(i, n)]);\n        }\n    }\n    for(int len = 2; len <= n; len <<= 1) {\n        T W = w(len, inverse);\n        for(int i = 0; i < n; i += len) {\n            T root = 1;\n            for(int j = i; j < i + (len >> 1); j++) {\n                T u = a[j], t = root * a[j + (len >> 1)];\n                a[j] = u + t;\n                a[j + (len >> 1)] = u - t;\n                root *= W;\n            }\n        }\n    }\n    if(inverse) {\n        transform(a.begin(), a.end(), a.begin(), [n](T& ai) { return ai / T(n); });\n    }\n    return a;\n}\ntemplate <typename T> vector<T>& operator*=(vector<T>& a, vector<T>& b) {\n    fft(pad(a, a.size())); if(addressof(a) != addressof(b)) fft(pad(b, b.size()));\n    assert(a.size() == b.size());\n    transform(a.begin(), a.end(), b.begin(), a.begin(), multiplies<T>());\n    fft(a, true); if(addressof(a) != addressof(b)) fft(b, true);\n    return a;\n}\ntemplate <typename T> vector<T> operator*(vector<T> a, vector<T>& b) { return a *= b; }\ntemplate <int C = int(sqrt(mint::MOD) + 0.5)> vector<mint> operator*=(vector<mint>& a, vector<mint>& b) {\n    vector<complex<double>> a1(a.size()), a2(a.size()), b1(b.size()), b2(b.size());\n    transform(a.begin(), a.end(), a1.begin(), [](mint& ai) { return ai.val % C; });\n    transform(a.begin(), a.end(), a2.begin(), [](mint& ai) { return ai.val / C; });\n    transform(b.begin(), b.end(), b1.begin(), [](mint& bi) { return bi.val % C; });\n    transform(b.begin(), b.end(), b2.begin(), [](mint& bi) { return bi.val / C; });\n    vector<complex<double>> a1b1 = b1 * a1, &a2b1 = b1 *= a2, &a1b2 = a1 *= b2, &a2b2 = a2 *= b2;\n    for(int i = 0; i < a.size(); i++) {\n        a[i] = mint(a1b1[i]) + mint(a1b2[i]) * C + mint(a2b1[i]) * C + mint(a2b2[i]) * C * C;\n    }\n    return a;\n}\ntemplate <int C = int(sqrt(mint::MOD) + 0.5)> vector<mint> operator*(vector<mint> a, vector<mint>& b) { return a *= b; }\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<mint> a(m + k + 1);\n    for(int i = 0; i <= m + k; i++) {\n        a[i] = fact(n - 1 + i);\n    }\n    vector<mint> b(k + 1);\n    for(int j = 0; j <= k; j++) {\n        b[j] = fact_inv(j) * (3_m ^ (k - j));\n    }\n    reverse(b.begin(), b.end());\n    b.resize(a.size());\n    a *= b;\n    mint ans = 0;\n    for(int i = 0; i <= m; i++) {\n        ans += fact_inv(n - 1) * fact_inv(i) * (3_m ^ (m - i)) * a[k + i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double EPS = 1e-10;\nconst ll INF = 100000000;\nconst ll MOD = 1000000007;\n\nll n, m, k;\nll kai[1000001];\nll p3[1000001];\nll dp[1000001];\n\nvoid init (int _n) {\n    kai[0] = 1;\n    p3[0] = 1;\n    for (int i = 1; i <= _n; i++) kai[i] = kai[i-1]*i%MOD;\n    for (int i = 1; i <= _n; i++) p3[i] = p3[i-1]*3%MOD;\n}\n\nll mod_pow (ll x, ll y) {\n    ll ret = 1;\n    while (y) {\n        if (y&1) ret = ret*x%MOD;\n        x = x*x%MOD;\n        y /= 2;\n    }\n    return ret;\n}\n\nll conb (ll x, ll y) {\n    ll z = x-y;\n    ll ret = kai[x]*mod_pow(kai[y],MOD-2)%MOD;\n    ret = ret*mod_pow(kai[z],MOD-2)%MOD;\n    return ret;\n}\n\nint main() {\n    cin >> n >> m >> k;\n    ll s = n+m+k;\n    ll ans = 0;\n    init(s);\n    dp[0] = 1;\n    for (ll i = 1; i <= s; i++) {\n        if (i <= m && i <= k) {\n            dp[i] = dp[i-1]*2%MOD;\n        } else if (i <= m) {\n            dp[i] = (dp[i-1]*2-conb(i-1,i-1-k)+MOD*MOD)%MOD;\n        } else if (i <= k) {\n            dp[i] = (dp[i-1]*2-conb(i-1,m)+MOD*MOD)%MOD;\n        } else {\n            dp[i] = (dp[i-1]*2-conb(i-1,m)-conb(i-1,i-1-k)+2*MOD*MOD)%MOD;\n        }\n    }\n    for (ll i = n; i <= s; i++) {\n        ll add = p3[s-i];\n        add = add * conb(i-1, n-1) % MOD;\n        add = add * dp[i-n] % MOD;\n        ans = (ans + add) % MOD;\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 9e5 + 9, mod = 1e9 + 7;\n\ntemplate <const int32_t MOD>\nstruct modint {\n    int32_t value;\n    modint() = default;\n    modint(int32_t value_) : value(value_) {}\n    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.value; return modint<MOD>(c >= MOD ? c - MOD : c); }\n    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.value; return modint<MOD>(c <    0 ? c + MOD : c); }\n    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * other.value % MOD; return modint<MOD>(c < 0 ? c + MOD : c); }\n    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * other.value % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : 0); }\n    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k & 1) y *= x; x *= x; } return y; }\n    modint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n    inline modint<MOD> operator /  (modint<MOD> other) const { return *this *  other.inv(); }\n    inline modint<MOD> operator /= (modint<MOD> other)       { return *this *= other.inv(); }\n    inline bool operator == (modint<MOD> other) const { return value == other.value; }\n    inline bool operator != (modint<MOD> other) const { return value != other.value; }\n    inline bool operator < (modint<MOD> other) const { return value < other.value; }\n    inline bool operator > (modint<MOD> other) const { return value > other.value; }\n};\ntemplate <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD>(value) * n; }\ntemplate <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD>(value % MOD) * n; }\ntemplate <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.value; }\ntemplate <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.value; }\n\nusing mint = modint<mod>;\n\nstruct Combi{\n\tint n; vector<mint> facts, finvs, invs;\n\tCombi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){\n\t\tfacts[0] = finvs[0] = 1;\n\t\tinvs[1] = 1;\n\t    for (int i = 2; i < n; i++) invs[i] =  invs[mod % i] * (-mod / i);\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfacts[i] = facts[i - 1] * i;\n\t\t\tfinvs[i] = finvs[i - 1] * invs[i];\n\t\t}\n\t}\n\tinline mint fact(int n) { return facts[n]; }\n\tinline mint finv(int n) { return finvs[n]; }\n\tinline mint inv(int n) { return invs[n]; }\n\tinline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }\n};\nCombi C(N);\n\nint32_t main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n, m, k; cin >> n >> m >> k;\n\tmint ans = 0;\n\tfor (int s = 0; s <= m + k; s++) {\n\t\tmint cur = 0;\n\t\tfor (int z = 0; z <= m; z++) {\n\t\t\tif (z <= s && (s - z <= k)) cur += C.ncr(s, z);\n\t\t}\n\t\tans += cur * C.ncr(n + s - 1, n - 1) * mint(3).pow(m + k - s);\n\t}\n\tcout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define MOD 1000000007LL\n\nint N, M, K;\nlong long dp[4000][1001];\n\nlong long pow(long long x, long long k) {\n  long long a = 1;\n  while (k) {\n    if (k & 1) a = (a*x) % MOD;\n    x = (x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\nlong long inv(long long x) {\n  return pow(x, MOD-2);\n}\nlong long C(long long n, long long r) {\n  long long s = 1LL;\n  for (int i=1; i<=r; i++) {\n    s = (s*(n+1-i)) % MOD;\n    s = (s*inv(i)) % MOD;\n  }\n  return s;\n}\n\nint main() {\n  cin >> N >> M >> K;\n\n  if (N > 1000 || M > 1000 || K > 1000) return 1;\n\n  dp[0][0] = 1;\n  long long s = 0;\n  for (int i=N; i<=N+M+K; i++) {\n    int t = i-N;\n    long long d = 0;\n    for (int m=max(0, i-N-K); m<=M; m++) {\n      d = (d + dp[t][m]) % MOD;\n      dp[t+1][m+1] = (dp[t+1][m+1] + dp[t][m]) % MOD;\n      dp[t+1][m  ] = (dp[t+1][m  ] + dp[t][m]) % MOD;\n    }\n    long long x = (pow(3, N+M+K-i) * C(i-1, N-1));\n    x = ((x%MOD) * d) % MOD;\n    s = (s + x) % MOD;\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 200005;\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - (ll)inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = (ll)fac[i-1] * i % MOD;\n\t\tfinv[i] = (ll)finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nint comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * ((ll)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\ninline int add(int x,int y)\n{\n    return (x+y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\ninline int mod_pow(int a, int b)\n{\n    int res = 1;\n    while(b){\n        if(b & 1){\n            res = (ll)res * a % MOD;\n        }\n        a = (ll)a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    if(K > m) swap(m, K);\n    make();\n    int tm = 0;\n    int cri = 1;\n    int inv3 = mod_pow(3, MOD-2);\n    int cri2 = mod_pow(inv3, n+1);\n    srep(i, n+1, n+K+1){\n        tm = add(tm, mul(comb(i-2, n-1), mul(cri, cri2)));\n        cri = mul(cri, 2);\n        cri2 = mul(cri2, inv3);\n    }\n    cri = mod_pow(2, K);\n    srep(i, n+K+1, n+m+2){\n        tm = add(tm, mul(comb(i-2, n-1), mul(cri, cri2)));\n        cri = sub(mul(cri, 2), comb(i-n-1, i-n-K-1));\n        cri2 = mul(cri2, inv3);\n    }\n    cri = 0;\n    srep(i, m-K+1, m+1){\n        cri = add(cri, comb(m+1, i));\n    }\n    srep(i, n+m+2, n+m+K+2){\n        tm = add(tm, mul(comb(i-2, n-1), mul(cri, cri2)));\n        cri = sub(mul(cri, 2), add(comb(i-n-1, i-n-K-1), comb(i-n-1, m)));\n        cri2 = mul(cri2, inv3);\n    }\n    cout << mul(tm, mod_pow(3, n+m+K+1)) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 21);\nconst int mod = (int)1e9 + 7;\nconst double PI = acos(-1.0);\nconst int BK = 100;\nconst int CK = 5;\n\ninline void addmod(int& x, int y, int mod) { (x += y) >= mod && (x -= mod); }\ninline int mulmod(int x, int y, int mod) { return x * 1ll * y % mod; }\n\nstruct complex_base\n{\n\tdouble x, y;\n\tcomplex_base(double _x = 0, double _y = 0) { x = _x; y = _y; }\n\tfriend complex_base operator-(const complex_base &a, const complex_base &b) { return complex_base(a.x - b.x, a.y - b.y); }\n\tfriend complex_base operator+(const complex_base &a, const complex_base &b) { return complex_base(a.x + b.x, a.y + b.y); }\n\tfriend complex_base operator*(const complex_base &a, const complex_base &b) { return complex_base(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x); }\n\tfriend void operator/=(complex_base &a, const double &P) { a.x /= P; a.y /= P; }\n};\n\nint bit_rev[MAXN];\n\nvoid fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = 2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cosl(ang), sinl(ang));\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n}\n\nvoid inv_fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = -2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cosl(ang), sinl(ang));\n\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] /= n;\n}\n\ncomplex_base A[MAXN], B[MAXN];\n\nvector<int> mult(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() <= 128)\n\t{\n\t\tvector<int> ans(a.size() + b.size(), 0);\n\t\tfor(int i = 0; i < (int)a.size(); i++)\n\t\t\tfor(int j = 0; j < (int)b.size(); j++)\n\t\t\t\tans[i + j] = (ans[i + j] + a[i] * 1ll * b[j]) % mod;\n\n\t\treturn ans;\n\t}\n\n\tint lg = 0; while((1 << lg) < (int)(a.size() + b.size())) ++lg;\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = B[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = complex_base(a[i], 0);\n\tfor(int i = 0; i < (int)b.size(); i++) B[i] = complex_base(b[i], 0);\n \n\tfft(A, lg); fft(B, lg);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tA[i] = A[i] * B[i];\n\tinv_fft(A, lg);\n\n\tvector<int> ans(a.size() + b.size(), 0);\n\tfor(int i = 0; i < (int)ans.size(); i++)\n\t\tans[i] = (int64_t)(A[i].x + 0.5) % mod;\n\n\treturn ans;\n}\n\nvector<complex_base> to_fft(const vector<complex_base> &a, int lg)\n{\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = a[i];\n\tfft(A, lg);\n\n\tvector<complex_base> ret(1 << lg, 0);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tret[i] = A[i];\n\n\treturn ret;\n}\n\nvector<complex_base> to_inv_fft(const vector<complex_base> &a, int lg)\n{\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = a[i];\n\tinv_fft(A, lg);\n\n\tvector<complex_base> ret(1 << lg, 0);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tret[i] = A[i];\n\n\treturn ret;\n}\n\nvector<int> mult_mod(const vector<int> &a, const vector<int> &b)\n{\n\t/// Thanks pavel.savchenkov\n\n\t// a = a0 + sqrt(MOD) * a1\n\t// a = a0 + base * a1\n\tint base = (int)sqrtl(mod);\n\n\tvector<int> a0(a.size()), a1(a.size());\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t{\n\t\ta0[i] = a[i] % base;\n\t\ta1[i] = a[i] / base;\n\t}\n\n\tvector<int> b0(b.size()), b1(b.size());\n\tfor(int i = 0; i < (int)b.size(); i++)\n\t{\n\t\tb0[i] = b[i] % base;\n\t\tb1[i] = b[i] / base;\n\t}\n\n\tvector<int> a01 = a0;\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t\taddmod(a01[i], a1[i], mod);  \t\n\n\tvector<int> b01 = b0;\n\tfor(int i = 0; i < (int)b.size(); i++) \n\t\taddmod(b01[i], b1[i], mod);\n\n\tvector<int> C = mult(a01, b01);  // 1\n\n\tvector<int> a0b0 = mult(a0, b0); // 2\n\tvector<int> a1b1 = mult(a1, b1); // 3\n\n\tvector<int> mid = C;\n\tfor(int i = 0; i < (int)mid.size(); i++) \n\t{\n\t\taddmod(mid[i], -a0b0[i] + mod, mod);\n\t\taddmod(mid[i], -a1b1[i] + mod, mod);\n\t}\n\n\tvector<int> res = a0b0;\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, mid[i], mod), mod);\n\n\tbase = mulmod(base, base, mod);\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, a1b1[i], mod), mod);\n\n\treturn res;\n}\n\n\n#define mp make_pair\n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < (int) n; ++i)\n \ntypedef vector <int> vi;\n \nusing ld = double;\nusing ll = int64_t;\n \n\nconst ll MOD = mod;\n\nnamespace FFT {\n  struct cd {\n    ld a, b;\n \n    cd(ld a, ld b) : a(a), b(b) {}\n \n    cd(ld x = 0) : a(x), b(0) {}\n \n    ld real() const {\n      return a;\n    }\n \n    void operator += (const cd& other) {\n      a += other.a;\n      b += other.b;\n    }\n \n    void operator -= (const cd& other) {\n      a -= other.a;\n      b -= other.b;\n    }\n \n    void operator *= (const cd& other) {\n      tie(a, b) = mp(a * other.a - b * other.b, a * other.b + b * other.a);\n    }\n \n    friend cd operator * (const cd& x, const cd& y) {\n      cd r = x;\n      r *= y;\n      return r;\n    }\n \n    friend cd operator + (const cd& x, const cd& y) {\n      cd r = x;\n      r += y;\n      return r;\n    }\n \n    friend cd operator - (const cd& x, const cd& y) {\n      cd r = x;\n      r -= y;\n      return r;\n    }\n \n    void operator /= (ld c) {\n      a /= c;\n      b /= c;\n    }\n  };\n \n  typedef vector<cd> vcd;\n \n  const int LOG = 20;\n  const int N = 1 << LOG;\n \n  int rev[N];\n  cd root_[N];\n \n  inline cd root(int k, int n) {\n    return root_[k * (N / n)];\n  }\n \n  void precalc() {\n    rev[0] = 0;\n    int hb = -1;\n    for (int i = 1; i < N; ++i) {\n      if  ((i & (i - 1)) == 0) {\n        ++hb;\n      }\n      rev[i] = rev[i ^ (1 << hb)] | (1 << (LOG - hb - 1));\n    }\n \n    forn(i, N) {\n      ld ang = PI * i * 2.0 / N;\n      root_[i] = cd(cosl(ang), sinl(ang));\n    }\n  }\n \n  void fft_rec(cd* a, int n) {\n    if  (n == 1) {\n      return;\n    }\n \n    fft_rec(a, n / 2);\n    fft_rec(a + n / 2, n / 2);\n \n    forn(k, n / 2) {\n      cd w = root(k, n);\n      cd x = a[k];\n      cd y = w * a[k + n / 2];\n      a[k] = x + y;\n      a[k + n / 2] = x - y;\n    }\n  }\n \n  void fft(vcd& a) {\n    int n = sz(a);\n    vcd na(n, cd(0, 0));\n    forn(i, n) na[i] = a[rev[i]];\n    na.swap(a);\n \n    fft_rec(&a[0], n);\n  }\n \n  void fft_inv(vcd& a) {\n    fft(a);\n    int n = sz(a);\n    reverse(a.begin() + 1, a.end());\n    forn(i, n) {\n      a[i] /= n;\n    }\n  }\n \n  vi mult(const vi& a, const vi& b) {\n    //    TimeStamp t(\"mult\");\n    vcd A(N, cd(0, 0));\n    vcd B(N, cd(0, 0));\n    forn(i, sz(a)) A[i] = a[i];\n    forn(i, sz(b)) B[i] = b[i];\n \n    fft(A);\n    fft(B);\n \n    forn(i, N) A[i] *= B[i];\n \n    fft_inv(A);\n \n    vi c(N, 0);\n    forn(i, N) c[i] = ((ll) (A[i].real() + 0.5)) % MOD;\n \n    return c;\n  }\n \n  vi multmod(const vi& a, const vi& b) {\n    // a = a0 + sqrt(MOD) * a1\n    // a = a0 + base * a1\n    int base = (int) sqrtl(MOD);\n \n    vi a0(sz(a)), a1(sz(a));\n    forn(i, sz(a)) {\n      a0[i] = a[i] % base;\n      a1[i] = a[i] / base;\n      assert(a[i] == a0[i] + base * a1[i]);\n    }\n \n    vi b0(sz(b)), b1(sz(b));\n    forn(i, sz(b)) {\n      b0[i] = b[i] % base;\n      b1[i] = b[i] / base;\n      assert(b[i] == b0[i] + base * b1[i]);\n    }\n \n    vi a01 = a0;\n    forn(i, sz(a)) {\n      addmod(a01[i], a1[i], MOD);\n    }\n \n    vi b01 = b0;\n    forn(i, sz(b)) {\n      addmod(b01[i], b1[i], MOD);\n    }\n \n    vi C = mult(a01, b01);  // 1\n \n    vi a0b0 = mult(a0, b0); // 2\n    vi a1b1 = mult(a1, b1); // 3\n \n    vi mid = C;\n    forn(i, N) {\n      addmod(mid[i], -a0b0[i] + MOD, MOD);\n      addmod(mid[i], -a1b1[i] + MOD, MOD);\n    }\n \n    vi res = a0b0;\n    forn(i, N) {\n      addmod(res[i], mulmod(base, mid[i], MOD), MOD);\n    }\n \n    base = mulmod(base, base, MOD);\n    forn(i, N) {\n      addmod(res[i], mulmod(base, a1b1[i], MOD), MOD);\n    }\n \n    return res;\n  }\n};\n\nint n, m, k;\n\nvoid read()\n{\n\tcin >> n >> m >> k;\n}\n\nvector<int> p1, p2, pw3;\n\nint pw(int x, int p)\n{\n\tint ret = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ret = (ret * 1ll * x) % mod;\n\t\tx = (x * 1ll * x) % mod;\n\t\tp >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint fact[MAXN], inv_fact[MAXN];\nint comb(int n, int k) { if(n < 0 || k < 0 || n < k) return 0; return (((fact[n] * 1ll * inv_fact[n - k]) % mod) * 1ll * inv_fact[k]) % mod; }\n\n/*   SUM C(n + i - 1, i) * C(n + i - 1 + j, j)   */\n/*   SUM C(n + i - 1, i) * fact[n + i - 1 + j] / (fact[j] * fact[n + i - 1])    */\n\n\nvoid solve()\n{\t\n\tpw3.assign(n + m + k + 1, 0);\n\tp1.assign(m + 1, 0);\n\tp2.assign(k + 1, 0);\n\tpw3[0] = 1; for(int i = 1; i <= m + k + n; i++) pw3[i] = (3ll * pw3[i - 1]) % mod;\n\tfact[0] = 1; for(int i = 1; i <= m + k + n; i++) fact[i] = (fact[i - 1] * 1ll * i) % mod;\n\tinv_fact[m + k + n] = pw(fact[m + k + n], mod - 2); for(int i = n + k + m - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * 1ll * (i + 1)) % mod; \n\n\tfor(int i = 0; i <= m; i++) p1[i] = (comb(n + i - 1, i) * 1ll * inv_fact[n + i - 1]) % mod;\n\tfor(int i = 0; i <= k; i++) p2[i] = inv_fact[i];\n\n\tvector<int> ret = mult_mod(p1, p2);\n\t\n\tint answer = 0;\n\tfor(int i = 0; i < (int)ret.size(); i++)\n\t{\n\t\tif(m + k - i < 0) break;\n\t\tint curr = (ret[i] * 1ll * pw3[m + k - i]) % mod;\n\t\tcurr = (curr * 1ll * fact[n - 1 + i]) % mod;\n\t\taddmod(answer, curr, mod);\n\t}\n\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\nv"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 900005;\nconst int md = 1e9 + 7;\n\nint n, m, k;\nint fact[N], inv[N], pw3[N];\nint ans;\n\nint pw(int a, int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif (b & 1) res = 1LL * res * a % md; a = 1LL * a * a % md;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint C(int n, int k) {\n\tif (n == k) return 1;\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn 1LL * fact[n] * (1LL * inv[k] * inv[n - k] % md) % md;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> m >> k;\n\n\tpw3[0] = 1; for (int i = 1; i < N; ++i) pw3[i] = 3LL * pw3[i - 1] % md;\n\tfact[0] = 1; for (int i = 1; i < N; ++i) fact[i] = 1LL * fact[i-1] * i % md;\n\tfor (int i = 0; i < N; ++i) inv[i] = pw(fact[i], md - 2);\n\n\tint f = 0;\n\tfor (int i = n; i <= n + m + k; ++i) {\n\t\tif (i == n) {\n\t\t\tfor (int j = i - n - k; j <= m; ++j) f = (f + C(i - n, j)) % md;\n\t\t} else {\n\t\t\tf = 2LL * f % md; \n\t\t\tf = (f - C(i - 1 - n, i - 1 - n - k)) % md; if (f < 0) f += md;\n\t\t\tf = (f - C(i - 1 - n, m)) % md; if (f < 0) f += md;\n \t\t}\n \t\tint cur = 1LL * C(i - 1, n - 1) * pw3[n + m + k - i] % md;\n \t\tcur = 1LL * cur * f % md;\n \t\tans = (ans + cur) % md;\n\t}\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1))\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nclass modint {\n\t//MODが素数であることを前提として実装してあるが、その判定はしていない。\n\t//あまりが出るような除算をしてはいけない。\nprivate:\n\tstatic const int MOD = 1000000007;\npublic:\n\tmodint() {\n\t\t//assert(is_prime(MOD));\n\t\tthis->number = 0;\n\t}\n\tmodint(const int src) {\n\t\t//assert(is_prime(MOD));\n\t\tthis->number = opposit(src);\n\t}\n\tmodint(const modint &src) {\n\t\tthis->number = src.number;\n\t}\n\n\tmodint& operator += (const modint& obj) {\n\t\tthis->number = san2(this->number + obj.number);\n\t\treturn *this;\n\t}\n\tmodint& operator -= (const modint& obj) {\n\t\tthis->number = san2(this->number - obj.number + MOD);\n\t\treturn *this;\n\t}\n\tmodint& operator *= (const modint& obj) {\n\t\tthis->number = (this->number * obj.number) % MOD;\n\t\treturn *this;\n\t}\n\tmodint& operator /= (const modint& obj) {\n\t\tthis->number = (this->number * inverse(obj.number)) % MOD;\n\t\treturn *this;\n\t}\n\tmodint& operator += (const int n) {\n\t\tthis->number = san2(this->number + opposit(n));\n\t\treturn *this;\n\t}\n\tmodint& operator -= (const int n) {\n\t\tthis->number = san2(this->number - opposit(n) + MOD);\n\t\treturn *this;\n\t}\n\tmodint& operator *= (const int n) {\n\t\tthis->number = (this->number * opposit(n)) % MOD;\n\t\treturn *this;\n\t}\n\tmodint& operator /= (const int n) {\n\t\tthis->number = (this->number * inverse(n)) % MOD;\n\t\treturn *this;\n\t}\n\n\tmodint operator + (const modint obj) { modint re(*this); return re += obj; }\n\tmodint operator - (const modint obj) { modint re(*this); return re -= obj; }\n\tmodint operator * (const modint obj) { modint re(*this); return re *= obj; }\n\tmodint operator / (const modint obj) { modint re(*this); return re /= obj; }\n\tmodint operator + (const int n) { modint re(*this); return re += n; }\n\tmodint operator - (const int n) { modint re(*this); return re -= n; }\n\tmodint operator * (const int n) { modint re(*this); return re *= n; }\n\tmodint operator / (const int n) { modint re(*this); return re /= n; }\n\n\tmodint operator = (const int n) {\n\t\tthis->number = opposit(n);\n\t\treturn *this;\n\t}\n\tint get() {\n\t\treturn number;\n\t}\n\nprivate:\n\tint number;\n\n\tint opposit(int n) {\n\t\tif (n < 0)n = MOD - ((-n) % MOD);\n\t\treturn n % MOD;\n\t}\n\tint inverse(int n) {\n\t\tn = opposit(n);\n\t\tint result = 1;\n\t\tfor (int i = MOD - 2; i; i /= 2) {\n\t\t\tif (i % 2)result = (result * n) % MOD;\n\t\t\tn = (n * n) % MOD;\n\t\t}\n\t\treturn result;\n\t}\n\tinline int san2(const int n) {\n\t\treturn MOD <= n ? n - MOD : n;\n\t}\n\tbool is_prime(int n) {\n\t\tif (n <= 1)return false;\n\t\tif (n == 2)return true;\n\t\tif (n % 2 == 0) return false;\n\t\tconst int upperbound = int(sqrt(n));\n\t\tfor (int i = 3; i <= upperbound; i += 2) {\n\t\t\tif (n % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\nmodint power(modint n, int p) {\n\tmodint result = 1;\n\tfor (; p; p /= 2) {\n\t\tif (p % 2)result *= n;\n\t\tn *= n;\n\t}\n\treturn result;\n}\nmodint power(int n, int p) {\n\tmodint mn = n;\n\treturn power(mn, p);\n}\n\nstruct combi {\npublic:\n\tvector<modint>facto;\n\tcombi(const int N) :facto(N) {\n\t\tfacto[0] = 1;\n\t\tREP(i, 1, N)facto[i] = facto[i - 1] * i;\n\t}\n\tmodint get_combi(const int N, const int C) {\n\t\t//combination(N+C,C)を求めて返す。\n\t\tif (facto.size() <= N + C) {\n\t\t\tint a = facto.size();\n\t\t\tfacto.resize(N + C + 1);\n\t\t\tREP(i, a, N + C + 1)facto[i] = facto[i - 1] * i;\n\t\t}\n\t\treturn facto[N + C] / (facto[N] * facto[C]);\n\t}\n};\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcombi c(1000010);\n\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tif (M > K) swap(M, K);\n\n\tmodint pre = 1, p3 = power(3, M + K), ans = p3;\n\n\t//N+iターン目にN回目のaが出る場合の数\n\tREP(i, 1, M + K + 1) {\n\t\tpre *= 2;\n\t\tp3 /= 3;\n\t\tif (i > M) {\n\t\t\tpre -= c.get_combi(M, i - M - 1);\n\t\t\tif (i > K) pre -= c.get_combi(K, i - K - 1);\n\t\t}\n\t\tans += pre * c.get_combi(N - 1, i) * p3;\n\t}\n\n\tcout << ans.get() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nconst int MAXN = 9e5 + 10 , MOD = 1e9 + 7;\nint fac[MAXN] , ifac[MAXN] , f3[MAXN];\nvoid init(){\n\tfac[0] = fac[1] = 1;\n\tfor(int i = 2 ; i < MAXN ; ++ i)\n\t\tfac[i] = 1ll * fac[i - 1] * i % MOD;\n\tifac[0] = ifac[1] = 1;\n\tfor(int i = 2 ; i < MAXN ; ++ i)\n\t\tifac[i] = MOD - 1ll * ifac[MOD % i] * (MOD / i) % MOD;\n\tfor(int i = 2 ; i < MAXN ; ++ i)\n\t\tifac[i] = 1ll * ifac[i - 1] * ifac[i] % MOD;\n\tf3[0] = 1;\n\tfor(int i = 1 ; i < MAXN ; ++ i)\n\t\tf3[i] = 1ll * f3[i - 1] * 3 % MOD;\n}\n\nint C(int a , int b){\n\tif(b < 0 || b > a) return 0;\n\treturn 1ll * fac[a] * ifac[b] % MOD * ifac[a - b] % MOD;\n}\nint n , m , k;\nint main(){\n\tinit();\n\tcin >> n >> m >> k;\n\tint ans = 0 , last = 1 , st = 0 , ed = 0;\n\tfor(int i = 0 ; i <= m + k ; ++ i){\n\t\tans = (ans + 1ll * last * f3[m + k - i] % MOD * C(n + i - 1 , n - 1)) % MOD;\n\t\tlast = 2ll * last % MOD;\n\t\tlast = (last + C(i , st - 1)) % MOD;\n\t\tlast = (last + MOD - C(i , ed)) % MOD;\n\t\tif(i - st >= m){\n\t\t\tlast = (last + MOD - C(i + 1 , st)) % MOD;\n\t\t\tst ++;\n\t\t}\n\t\tif(ed < k){\n\t\t\ted ++;\n\t\t\tlast = (last + C(i + 1 , ed)) % MOD;\n\t\t} \n\t\tif(st > ed) break;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int mod=1e9+7;\nconst int INF=0x3f3f3f3f;\nll quick(ll a,ll b)\n{\n\tll ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nconst int maxn=3e5+7;\nll fac[maxn];\nvoid db()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<maxn;i++)\n\t\tfac[i]=fac[i-1]*i%mod;\n}\nll C(int n,int m)\n{\n\treturn fac[n]*inv(fac[n-m])%mod*inv(fac[m])%mod;\n}\nint main()\n{\n\tdb();\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tll ans=0;\n\tll cur=1;\n\tfor(int t=0;t<=m+k;t++)\n\t{\n\t\tans=(ans+cur*C(t+n-1,n-1)%mod*quick(3,m+k-t)%mod)%mod;\n\t\tcur=cur*2%mod;\n\t\tif(t+1>m)\n\t\t\tcur=(cur-C(t,m)+mod)%mod;\n\t\tif(t+1>k) cur=(cur-C(t,t-k)+mod)%mod;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\nconst int mod = 1e9 + 7;\nconst int MX = 610000;\nll inv[MX], f[MX], invf[MX], pw[MX];\nvoid calc(){\n\tpw[0] = 1;\n\trep(i, MX - 1) pw[i + 1] = pw[i] * 3 % mod;\n\tinv[0] = inv[1] = f[0] = f[1] = invf[0] = invf[1] = 1;\n\tfor (int i = 2; i < MX; i++){\n\t\tinv[i] = mod - mod / i * inv[mod % i] % mod;\n\t\tf[i] = f[i - 1] * i % mod;\n\t\tinvf[i] = invf[i - 1] * inv[i] % mod;\n\t}\n}\ninline ll C(ll n, ll k){\n\tif(k < 0 || k > n) return 0;\n\treturn f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint main(){\n\tcalc();\n\tint a, b, c; cin >> a >> b >> c;\n\tll ans = 0;\n\tll sum = 1; int L = 0, R = 0;\n\trep(i, b + c + 1){\n\t\t/*\n\t\tll s = 0;\n\t\tfor(int j = max(0, i - c); j <= min(b, i); j++) s += C(i, j);\n\t\t*/\n\t\tif(i) sum *= 2;\n\t\tint l = max(0, i - c), r = min(b, i);\n\t\tsum += C(i - 1, L - 1);\n\t\tsum += mod - C(i - 1, R);\n\t\t\n\t\tif(l > L) sum += mod - C(i, L);\n\t\tif(r > R) sum += C(i, r);\n\t\t\n\t\tassert(l == L || L + 1 == l);\n\t\tassert(r == R || R + 1 == r);\n\t\t//dbg(l, r, L, R, sum, s); assert(s % mod == sum % mod);\n\t\t\n\t\tL = l; R = r;\n\t\tsum %= mod;\n\t\tans += sum * C(i + a - 1, i) % mod * pw[b + c - i] % mod;\n\t}\n\tcout << ans % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n#define AddMult(x, y, z) x = (x + (y) * (z)) % mod\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        initialize();\n    }\n\n    void initialize(){\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = modpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int nCr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n\n    int nPr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N, M, K; cin >> N >> M >> K;\n    assert(N <= 1000 && M <= 1000 && K <= 1000);\n\n    int ans = 0;\n    Combination C(N + M + K, mod);\n    int c = 1;\n    REP(i, M + K + 1){\n        if(i > 0){\n            Mult(c, 2);\n            if(i - 1 >= M + 1) Add(c, C.nCr(i - 1, M + 1));\n            if(i - 1 - K - 1 >= 0) Add(c, C.nCr(i - 1, i - 1 - K - 1));\n            if(i >= M + 1) Add(c, mod - C.nCr(i, M + 1));\n            if(i - K - 1 >= 0) Add(c, mod - C.nCr(i, i - K - 1));\n        }\n        int tmp = (c * C.nCr(N - 1 + i, i)) % mod;\n        Add(ans, tmp * modpow(3, M + K - i, mod));\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nll invmod(ll x) {\n  ll e = mod - 2;\n  ll sum = 1;\n  ll cur = x;\n  while (e > 0) {\n    if (e % 2 == 1) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\nconst int N = 900100;\nll fact[N];\nll pow3[N];\n\nll comb(ll x, ll y) {\n  ll ret = fact[x];\n  ret *= invmod(fact[y]);\n  ret %= mod;\n  ret *= invmod(fact[x - y]);\n  return ret % mod;\n}\n\nint main(void){\n  int n, m, k;\n  cin >> n >> m >> k;\n  fact[0] = 1;\n  pow3[0] = 1;\n  REP(i, 1, N) {\n    fact[i] = (fact[i - 1] * i) % mod;\n    pow3[i] = pow3[i - 1] * 3 % mod;\n  }\n  \n  // \\sum_{b', c'} fact(b' + c' + n - 1) / fact(b') / fact(c') / fact(n - 1) * 3^(m - b' + k - c')\n  // = \\sum_{d = 0}^{m + k} fact(d + n - 1) / fact(n - 1) / fact(d) \\sum_{b = max(0, d - k)}^{min(d, m)} C(d, b) 3^{m + k - d}\n  ll sum = 0;\n  ll cur = 1;\n  REP(d, 0, m + k + 1) {\n    ll tmp = fact[d + n - 1];\n    tmp *= invmod(fact[n - 1]);\n    tmp %= mod;\n    tmp *= invmod(fact[d]);\n    tmp %= mod;\n    tmp *= pow3[m + k - d];\n    tmp %= mod;\n    tmp *= cur;\n    sum += tmp;\n    sum %= mod;\n    cur *= 2;\n    if (d >= k) {\n      cur += mod - comb(d, d - k);\n    }\n    if (d >= m) {\n      cur += mod - comb(d, m);\n    }\n    cur %= mod;\n  }\n  cout << sum << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define OUT(x)                cout << #x << \" = \" << x << endl; \n#define rep(i, n)             for (int (i) = 0; (i) < (int)(n); (i)++)\n#define rer(i, l, r)          for (int (i) = (int)(l); (i) <= (int)(r); (i)++)\n#define reu(i, l, r)          for (int (i) = (int)(l); (i) < (int)(r); (i)++)\n#define each(i, v)            for (auto i : v)\n#define all(x)                (x).begin(), (x).end()\n#define rall(x)               (x).rbegin(), (x).rend()\n#define pb(x)                 push_back(x)\n#define bp(x)                 __builtin_popcount(x)\n#define mp(x, y)              make_pair((x), (y))\n#define fi                    first\n#define se                    second\n#define setp(x)               setprecision(x)\n#define mset(m, v)            memset(m, v, sizeof(m))\n#define sz(x)                 (int)(x.size())\nstatic const int INF        = 0x3f3f3f3f;\nstatic const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD        = 1000000007;\nstatic const double PI      = 3.141592653589793238462643383279;\n\n#define int                   long long\n\ntypedef vector<double>        vd;\ntypedef vector<string>        vs;\ntypedef vector<bool>          vb;\ntypedef vector<int>           vi;\ntypedef pair<int, int>        pii;\ntypedef vector<pii>           vpii;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; i ++) cout << *i << \" \"; cout << endl; }\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\n//int in() { int _x; scanf(\"%d\", &_x); return _x; }\nlong long lin() {long long _x; scanf(\"%lld\", &_x); return _x; };\n\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n        long long d = a;\n        if (b != 0) {\n                d = extgcd(b, a % b, y, x);\n                y -= (a / b) * x;\n        } else {\n                x = 1;\n                y = 0;\n        }\n        return d;\n}\n\nlong long inv(long long a) {\n        long long x, y;\n        extgcd(a, MOD, x, y);\n        return (x % MOD + MOD) % MOD;\n}\n\nlong long nCr(long long n, long long r) {\n        if (n < r) return 0;\n        if (n - r < r) r = n - r;\n        long long ret = 1;\n        rep(i, r) {\n                ret *= n;\n                -- n;\n                ret %= MOD;\n                ret *= inv(i + 1);\n                ret %= MOD;\n        }\n        return ret;\n}\n\nlong long mod_pow(long long x, long long n) {\n        long long res = 1;\n        while (n > 0) {\n                if (n & 1) res = res * x % MOD;\n                x = x * x % MOD;\n                n >>= 1;\n        }\n        return res;\n}\n\nsigned main() { \n        int n, m, k;\n        cin >> n >> m >> k;\n        int ans = 0;\n        if (!n) ans += mod_pow(3, m + k);\n        else {\n                for (int i = n; i <= n + m + k; i ++) {\n                        int x = nCr(i - 1, n - 1);\n                        int y = 0;\n                        for (int j = max(0LL, i - n - k); j <= min(i - n, m); j ++) {\n                                y += nCr(i - n, j);\n                                y %= MOD;\n                        }\n                        int z = mod_pow(3, n + m + k - i);\n                        ans += x * y % MOD * z; \n                        ans %= MOD;\n                }\n        }\n        ans %= MOD;\n        cout << ans << endl;\n        return 0;\n}               \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, x, y) for (int i = (x), _ = (y); i <= _; ++i)\n#define down(i, x, y) for (int i = (x), _ = (y); i >= _; --i)\n#define x first\n#define y second\n\nusing namespace std;\ntypedef long long LL;\n\ntemplate<typename T> inline void upmax(T & x, T y) { x < y ? x = y : 0; }\ntemplate<typename T> inline void upmin(T & x, T y) { x > y ? x = y : 0; }\n\ntemplate<typename T>\ninline void read(T & x)\n{\n\tchar c;\n\twhile ((c = getchar()) < '0' || c > '9');\n\tfor (x = c - '0'; (c = getchar()) >= '0' && c <= '9'; x = x * 10 + c - '0');\n}\n\nconst int mo = 1e9 + 7;\nconst int N = 9e5 + 10;\n\nint pow_2[N], pow_3[N];\nint fac[N], inv[N];\nint X, Y, Z, n;\n\ninline int qpow(int x, int n)\n{\n\tint ans = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tans = (LL) ans * x % mo;\n\t\tx = (LL) x * x % mo;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n\ninline int C(int n, int m)\n{\n\tif (n < m)\n\t\treturn 0;\n\treturn (LL) fac[n] * inv[m] % mo * inv[n - m] % mo;\n}\n\ninline void upd(int & x, int y)\n{\n\t(x += y) >= mo ? x -= mo : 0;\n}\n\nint main()\n{\n#ifdef LX_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tread(X);\n\tread(Y);\n\tread(Z);\n\n\tn = X + Y + Z;\n\n\tfac[0] = 1;\n\trep (i, 1, n)\n\t\tfac[i] = (LL) fac[i - 1] * i % mo;\n\tinv[n] = qpow(fac[n], mo - 2);\n\tdown (i, n, 1)\n\t\tinv[i - 1] = (LL) inv[i] * i % mo;\n\n\tpow_2[0] = 1;\n\trep (i, 1, n)\n\t\t(pow_2[i] = pow_2[i - 1] << 1) >= mo ? pow_2[i] -= mo : 0;\n\n\tpow_3[0] = 1;\n\trep (i, 1, n)\n\t\tpow_3[i] = (LL) pow_3[i - 1] * 3 % mo;\n\n\tint ans = 0;\n\tint f = 1, g = 1;\n\n\tfor (int i = X, c = 0; i <= n; ++i, ++c)\n\t{\n\t\tLL t = (LL) f + g + mo - pow_2[c];\n\t\tupd(ans, t * C(i - 1, X - 1) % mo * pow_3[n - i] % mo);\n\t\tf = ((LL) f * 2 + mo - C(c, Y)) % mo;\n\t\tg = ((LL) g * 2 + mo - C(c, Z)) % mo;\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstring s;\n \ntypedef long long ll;\n \nll dp(ll at, ll c, ll sum)\n{\n\tc = c * 10 + s[at]-'0';\n\tif (at == s.length() - 1) return sum + c;\n\treturn dp(at + 1, c, sum) + dp(at + 1, 0, sum + c);\n}\n \nint main()\n{\n\tcin >> s;\n\tcout << dp(0ll, 0ll, 0ll) << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=900003,mod=1000000007;\nint Plus(int x,int y){return (x+=y)>=mod?x-mod:x;}\nvoid Pluseq(int &x,int y){if((x+=y)>=mod)x-=mod;}\nint Minus(int x,int y){return Plus(x,mod-y);}\nvoid Minuseq(int &x,int y){Pluseq(x,mod-y);}\nint mul(long long x,int y){return x*y%mod;}\nvoid muleq(int &x,int y){x=mul(x,y);}\nint qpow(int x,int y){\n    int ans=1;\n    while(y){\n        if(y&1)muleq(ans,x);\n        muleq(x,x);\n        y>>=1;\n    }\n    return ans;\n}\nint p3[maxn],fac[maxn],facinv[maxn],f[maxn];\nint C(int n,int m){return n<m?0:mul(mul(fac[n],facinv[m]),facinv[n-m]);}\nint main(){\n    p3[0]=fac[0]=1;\n    for(int i=1;i<maxn;i++)p3[i]=mul(p3[i-1],3),fac[i]=mul(fac[i-1],i);\n    facinv[maxn-1]=qpow(fac[maxn-1],mod-2);\n    for(int i=maxn-2;i>=0;i--)facinv[i]=mul(facinv[i+1],i+1);\n    int n,m,k,ans=0;\n    scanf(\"%d%d%d\",&n,&m,&k);\n    if(m>k)swap(m,k);\n    f[n]=1;\n    for(int i=n+1;i<=n+m;i++)f[i]=mul(2,f[i-1]);\n    for(int i=n+m+1;i<=n+k;i++)f[i]=Minus(mul(2,f[i-1]),C(i-n-1,m));\n    for(int i=n+k+1;i<=n+m+k;i++)f[i]=Minus(mul(2,f[i-1]),Plus(C(i-n-1,i-n-k-1),C(i-n-1,m)));\n    for(int i=n;i<=n+m+k;i++)Pluseq(ans,mul(mul(C(i-1,n-1),f[i]),p3[n+m+k-i]));\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\nconst int maxn = 9e5 + 7, md = 1e9 + 7;\nll inv[maxn], finv[maxn], fac[maxn], f[maxn], p2[maxn], p3[maxn];\nll N, M, K, m, k;\nll read(){\n    int s = 0; char c = getchar();\n    while (c > '9' || c < '0') c = getchar();\n    while (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();\n    return s;\n}\nll ksm(ll a, int b){\n    ll res = 1;\n    while (b){\n        if (b & 1) res = res * a % md;\n        a = a * a % md;\n        b >>=1 ;\n    }\n    return res;\n}\nvoid init(){\n    fac[0] = fac[1] = 1; inv[1] = finv[1] = 1;\n    p3[1] = 3;p3[0] = 1;\n    for (int i = 2; i < maxn; i++) p3[i] = p3[i - 1] * 3 % md;\n    for (int i = 2; i < maxn; i++){\n        inv[i] = ( md - (md / i) * inv[md%i] % md) % md;\n    }\n    for (ll i = 1; i < maxn; i++) {\n        fac[i] = fac[i - 1] * i % md;\n    }\n    finv[maxn - 1] = ksm(fac[maxn - 1], md - 2);\n    for (ll i = maxn - 2; i >= 0; i--) finv[i] = finv[i + 1] * (i + 1) % md;\n    \n}\nll ans = 0;\nll getf(){\n    ll res = 0;\n    f[0] = p3[M];\n    res = f[0];\n    for (int i = 1; i <= M; i++)\n        f[i] = (((((f[i - 1] * (N - 1 + i + k) % md + md) % md ) * inv[3]) % md) * inv[i] + md) % md, res = ((res + f[i]) % md + md) % md;\n    return res;\n}\nll C(int x, int y){\n    return fac[x] * finv[y] % md * finv[x - y] % md;\n}\nint main(){\n    N = read(), M = read(), K = read();\n    init();\n    for (k = 0; k <= K; k++) {\n        ans = (ans + p3[K-k] * C(N - 1 + k, k) % md * getf() % md);\n    }\n    printf(\"%lld\\n\", ans % md);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <deque>\n#include <queue>\n#include <string>\n#include <tuple>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\n#define pb push_back\n#define pbk pop_back\n#define sz(a) ((int) (a).size())\n#define all(a) (a).begin(), (a).end()\n#define mp make_pair\n#define mt make_tuple\n#define fs first\n#define sc second\n#define next hunext\n#define prev huprev\n#define rank hurank\n#define hash huhash\n\n#ifdef LOCAL42\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = int(1e9);\nconst ll linf = ll(1e18);\nconst double eps = 1e-9;\nconst double pi = 4 * atan(1.0);\nconst int MOD = int(1e9) + 7;\nconst int P = 2000;\nconst int N = int(4e6);\nconst int K = 3;\n\nstruct base {\n    \n    double a, b;\n    \n    base() : a(0), b(0) {}\n    \n    base(double a, double b = 0) : a(a), b(b) {}\n    \n};\n\ninline base operator + (const base& a, const base& b) {\n    return base(a.a + b.a, a.b + b.b);\n}\n\ninline base operator - (const base& a, const base& b) {\n    return base(a.a - b.a, a.b - b.b);\n}\n\ninline base operator * (const base& a, const base& b) {\n    return base(a.a * b.a - a.b * b.b, a.a * b.b + a.b * b.a);\n}\n\ninline base operator / (const base& a, double b) {\n    return base(a.a / b, a.b / b);\n}\n\nint maxv;\nbase a[K][N], ab[K * 2][N];\nint f[N], rf[N];\n\ninline int calc(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2 != 0) {\n            res = (1LL * res * a) % MOD;\n        }\n        a = (1LL * a * a) % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\ninline void fft(base* a, int n, bool fl) {\n    for (int i = 1, j = 0; i < n; ++i) {\n        int bit = n / 2;\n        for (; j >= bit; bit /= 2) {\n            j -= bit;\n        }\n        j += bit;\n        if (i < j) {\n            swap(a[i], a[j]);\n        }\n    }\n    for (int len = 2; len <= n; len *= 2) {\n        double ang = 2 * pi / len * (fl ? -1 : 1);\n        base wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            base w(1);\n            for (int j = 0; j < len / 2; ++j) {\n                base u = a[i + j], v = a[i + j + len / 2] * w;\n                a[i + j] = u + v;\n                a[i + j + len / 2] = u - v;\n                w = w * wlen;\n            }\n        }\n    }\n    if (fl) {\n        for (int i = 0; i < n; ++i) {\n            a[i] = a[i] / n;\n        }\n    }\n}\n\nint main() {\n#ifdef LOCAL42\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int n, m, k;\n    cin >> n >> m >> k;\n    f[0] = 1;\n    for (int i = 1; i <= n + m + k; ++i) {\n        f[i] = (1LL * f[i - 1] * i) % MOD;\n    }\n    rf[n + m + k] = calc(f[n + m + k], MOD - 2);\n    for (int i = n + m + k - 1; i >= 0; --i) {\n        rf[i] = (1LL * rf[i + 1] * (i + 1)) % MOD;\n    }\n    for (int i = 0; i <= m; ++i) {\n        int cur = rf[i];\n        for (int j = 0; j < K; ++j) {\n            a[j][i].a = cur % P;\n            cur /= P;\n        }\n        assert(cur == 0);\n    }\n    for (int i = 0; i <= k; ++i) {\n        int cur = rf[i];\n        for (int j = 0; j < K; ++j) {\n            a[j][i].b = cur % P;\n            cur /= P;\n        }\n        assert(cur == 0);\n    }\n    maxv = 1;\n    while (maxv < max(m, k) + 1) {\n        maxv *= 2;\n    }\n    maxv *= 2;\n    assert(maxv < N);\n    for (int i = 0; i < K; ++i) {\n        fft(a[i], maxv, false);\n    }\n    for (int i = 0; i < K; ++i) {\n        for (int j = 0; j < K; ++j) {\n            for (int z = 0; z < maxv; ++z) {\n                ab[i + j][z] = ab[i + j][z] + a[i][z] * a[j][z];\n            }\n        }\n    }\n    for (int i = 0; i < 2 * K; ++i) {\n        fft(ab[i], maxv, true);\n    }\n    int ans = 0, pw3 = 1, inv3 = calc(3, MOD - 2);\n    for (int i = 0; i <= m + k; ++i) {\n        int sum = 0;\n        for (int j = 2 * K - 1; j >= 0; --j) {\n            sum = (1LL * sum * P + ll(ab[j][i].b + 0.5) / 2) % MOD;\n        }\n        sum = (1LL * sum * pw3) % MOD;\n        sum = (1LL * sum * f[n - 1 + i]) % MOD;\n        ans += sum;\n        if (ans >= MOD) {\n            ans -= MOD;\n        }\n        pw3 = (1LL * inv3 * pw3) % MOD;\n    }\n    ans = (1LL * ans * calc(3, m + k)) % MOD;\n    ans = (1LL * ans * rf[n - 1]) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int Mod = 1e9 + 7;\nconst int N = 3e6 + 10;\n\nint n, m, k;\nLL pw2[N], pw3[N], fac[N], inv[N];\n\nLL Power(LL a, LL b) {\n\tLL c = 1;\n\tfor (; b; b >>= 1, (a *= a) %= Mod)\n\t\tif (b & 1)\n\t\t\t(c *= a) %= Mod;\n\treturn c;\n}\n\nvoid Init() {\n\tpw2[0] = pw3[0] = 1;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw2[i] = pw2[i - 1] * 2 % Mod;\n\t\tpw3[i] = pw3[i - 1] * 3 % Mod;\n\t\tfac[i] = fac[i - 1] * i % Mod;\n\t}\n\tinv[N - 1] = Power(fac[N - 1], Mod - 2);\n\tfor (int i = N - 2; i; --i)\n\t\tinv[i] = inv[i + 1] * (i + 1) % Mod;\n}\n\nLL Binom(int m, int n) {\n\tif (n > m)\n\t\treturn 0;\n\treturn fac[m] * inv[n] % Mod * inv[m - n] % Mod;\n}\n\nvoid Solve() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tLL fb = 0;\n\tLL fc = 0;\n\tLL ans = 0;\n\tfor (int i = n; i <= n + m + k; ++i) {\n\t\tLL cnt = Binom(i - 1, n - 1);\n\t\tif (i - n == m + 1) \n\t\t\tfb = 1;\n\t\telse if (i - n > m + 1) \n\t\t\tfb = (fb * 2 + Binom(i - n - 1, m)) % Mod;\n\t\tif (i - n == k + 1)\n\t\t\tfc = 1;\n\t\telse if (i - n > k + 1)\n\t\t\tfc = (fc * 2 + Binom(i - n - 1, k)) % Mod;\n\t\tLL f = (pw2[i - n] - fb + Mod - fc + Mod) % Mod;\n\t\t(ans += f * cnt % Mod * pw3[n + m + k - i]) %= Mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n\n\tInit();\n\tSolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000010\n#define ll long long\n\nconst ll p = 1e9 + 7;\nll n, m, k, ans;\nll fac[N], inv[N], san[N];\n\nll fpow(ll a, ll b)\n{\n    ll ans = 1;\n    while(b)\n    {\n        if(b & 1) ans = ans * a % p;\n        a = a * a % p; b >>= 1;\n    }\n    return ans;\n}\n\nll C(ll n, ll m)\n{\n    if(n < m || n < 0 || m < 0) return 0;\n    return fac[n] * inv[m] % p * inv[n - m] % p;\n}\n\nint main()\n{\n    scanf(\"%lld%lld%lld\", &n, &m, &k);\n    ll t = n + m + k;\n    fac[0] = inv[0] = san[0] = 1;\n    for(int i = 1; i <= t; i ++)\n    {\n        fac[i] = fac[i - 1] * i % p;\n        san[i] = san[i - 1] * 3 % p;\n    }\n    //for(int i = 1; i <= 5; i ++) printf(\"%lld %lld %lld\", fac[i], inv[i], san[i]), system(\"pause\");\n    inv[t] = fpow(fac[t], p - 2);\n    for(int i = t - 1; i; i --) inv[i] = inv[i + 1] * (i + 1) % p;\n    ll t1 = 0, t2 = 1;\n    for(int i = 0; i <= m + k; i ++)\n    {\n        t = C(n + i - 1, n - 1) * san[m + k - i] % p;\n        //printf(\"%lld\", t); system(\"pause\");\n        t = t * (t2 - t1 + p) % p;\n        t2 = (t2 * 2 % p - C(i, m) + p) % p;\n        t1 = (t1 * 2 % p - C(i, i - k - 1) + p) % p + C(i + 1, i - k);\n        ans = (ans + t) % p; \n        //printf(\"%lld %lld\", ans, t); system(\"pause\");\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\ntypedef long long ll;\nll dp(ll at, ll c, ll sum){\n\tc = c * 10 + s[at]-'0';\n\tif (at == s.length() - 1) return sum + c;\n\treturn dp(at + 1, c, sum) + dp(at + 1, 0, sum + c);\n} \nint main(){\n\tcin >> s;\n\tcout << dp(0ll, 0ll, 0ll) << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct Combinatorics {\n  using int64 = long long;\n  const int64 mod = 1e9+7;\n  int64 fact[1002020];\n  int64 invfact[1002020];\n  Combinatorics() {\n    fact[0] = invfact[0] = 1;\n    for(int i = 1; i < 1002020; ++i) {\n      fact[i] = fact[i-1]*i%mod;\n      invfact[i] = minv(fact[i]);\n    }\n  }\n  int64 mpow(int64 x, int64 n) const {\n    int64 res = 1;\n    while(n > 0) {\n      if(n&1) res = res*x%mod;\n      x = x*x%mod;\n      n >>= 1;\n    }\n    return res;\n  }\n  int64 minv(int64 x) const {\n    return mpow(x, mod-2);\n  }\n  int64 mfact(int64 x) const {\n    return fact[x];\n  }\n  int64 C(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[r]%mod*invfact[n-r]%mod;\n  }\n  int64 P(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[n-r]%mod;\n  }\n}C;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M, K;\n  cin >> N >> M >> K;\n  vint dp(N+M+K+1);\n  dp[0] = 1;\n  for(int i = 0; i < N+M+K; ++i) {\n    dp[i+1] = dp[i]*2 + mod-C.C(i, M) + mod-C.C(i, K);\n    dp[i+1] %= mod;\n  }\n  vint pow3(N+M+K+1);\n  pow3[0] = 1;\n  for(int i = 0; i < N+M+K; ++i) pow3[i+1] = pow3[i]*3%mod;\n  int ans = 0;\n  for(int i = N; i <= N+M+K; ++i) {\n    ans += C.C(i-1, N-1)*pow3[N+M+K-i]%mod*dp[i-N]%mod;\n    ans %= mod;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 3e5 + 1, Mod = 1e9 + 7;\n\nnamespace Mathscalc {\n    inline int Add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\n    inline int Sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\n    inline int Mul(int a, int b) { return 1LL * a * b % Mod; }\n} using namespace Mathscalc;\n\nint n, m, k;\n\nint jc[MAXN << 2], inv[MAXN << 2], invj[MAXN << 2], p[MAXN << 2];\nvoid GetNeed() {\n    p[0] = 1; for (int i = 1; i <= n * 3; ++i) p[i] = Mul(p[i - 1], 3);\n    jc[0] = 1; for (int i = 1; i <= n * 3; ++i) jc[i] = Mul(jc[i - 1], i);\n    inv[1] = 1; for (int i = 2; i <= n * 3; ++i) inv[i] = Mul(Sub(Mod, Mod / i), inv[Mod % i]);\n    invj[0] = 1; for (int i = 1; i <= n * 3; ++i) invj[i] = Mul(invj[i - 1], inv[i]);\n}\n\ninline int C(int n, int m) { return Mul(jc[n], Mul(invj[m], invj[n - m])); }\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &k);\n    GetNeed();\n    if (m < k) std :: swap(m, k); --n;\n    int ans = 0, x = 1;\n    for (int i = 0; i <= m + k; ++i) {\n        ans = Add(ans, Mul(C(n + i, n), Mul(p[m + k - i], x)));\n        if (i < k) x = Mul(x, 2);\n        else if (i < m) x = Sub(Mul(x, 2), C(i, k));\n        else x = Sub(Mul(x, 2), Add(C(i, m), C(i, k)));\n    }\n\tprintf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000000 + 5\n#define Mod 1000000007\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, m, k, f, g, tmp, ans, p[N], fac[N], inv[N];\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Inc(int a, int b){\n    return (a += b) >= Mod ? a - Mod : a;\n}\nint Dec(int a, int b){\n    return (a -= b) < 0 ? a + Mod : a;\n}\nint Mul(int a, int b){\n    return 1ll * a * b % Mod;\n}\nint Qpow(int a, int b){\n    int ans = 1;\n    while(b){\n        if(b & 1) ans = Mul(ans, a);\n        a = Mul(a, a), b >>= 1;\n    }\n    return ans;\n}\nint C(int n, int m){\n    if(m > n) return 0;\n    return Mul(fac[n], Mul(inv[n - m], inv[m]));\n}\nint main(){\n    n = read(), m = read(), k = read();\n    fac[0] = 1, p[0] = inv[0] = 1;\n    rep(i, 1, N - 5) fac[i] = Mul(fac[i - 1], i), p[i] = Mul(p[i - 1], 3), inv[i] = Qpow(fac[i], Mod - 2);\n    f = 1, ans = Mul(p[m + k], Mul(C(n - 1, 0), f));\n    rep(i, 1, m + k){\n        f = Dec(Mul(f, 2), C(i - 1, m));\n        if(i - k > 0){\n            if(i - k == 1) g = 1;\n            else g = Inc(Mul(g, 2), C(i - 1, i - k - 1));\n            tmp = Dec(f, g);\n        } \n        else tmp = f;\n        ans = Inc(ans, Mul(p[m + k - i], Mul(C(n + i - 1, i), tmp)));\n    }\n    printf(\"%d\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble PI=3.141592653589793;\n\ncomplex <double> dftn[2100007];\ncomplex <double> dfts[2100007];\n\ncomplex <double> a1[2100007];\ncomplex <double> b1[2100007];\ncomplex <double> a2[2100007];\ncomplex <double> b2[2100007];\n\ndouble cosi[2100007];\ncomplex <double> omega[2100007];\n\ninline int potenga(int v)\n{\n    for (int i=1; 1; i<<=1)\n    {\n        if (i>=v)\n        {\n            return i;\n        }\n    }\n}\n\ninline void dft(int n, int kier)\n{\n    int n2=n-1;\n    int s=0;\n    int p;\n    int g;\n\n    for (int i=2; i<=n; i<<=1)\n    {\n\n        for (int j=0; j<n; j++)\n        {\n            dfts[j]=dftn[j];\n            dftn[j]=0;\n        }\n\n        p=n/i;\n\n        if (kier)\n        {\n            g=0;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=j+1;\n                    s=0;\n                }\n            }\n        }\n        else\n        {\n            g=n;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=n-j-1;\n                    s=0;\n                }\n            }\n        }\n    }\n}\n\nvoid licz_omegi(int n1)\n{\n    double kat=2.0*PI/n1;\n    int n2=n1-1;\n    int dod=3*n1/4;\n\n    for (int i=0; i<=n1; i++)\n    cosi[i]=cos(kat*i);\n    for (int i=0; i<=n1; i++)\n    omega[i]=complex <double> (cosi[i], cosi[(i+dod)&n2]);\n}\n\nvector <long long> fft_dokladne(vector <long long> &jed, vector <long long> &dwa)\n{\n    int n1=potenga(jed.size()+dwa.size());\n\n    licz_omegi(n1);\n\n    long long M=32000;\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]/M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a1[i]=dftn[i];\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]%M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b1[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]/M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a2[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]%M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b2[i]=dftn[i];\n\n    vector <long long> ret;\n    for (int i=0; i<n1; i++)\n    ret.push_back(0);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=(llround(dftn[i].real()/n1)%mod)*((M*M)%1000000007);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*b2[i]+b1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=(llround(dftn[i].real()/n1)%mod)*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=b1[i]*b2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1)%mod;\n\n    for (int i=0; i<ret.size(); i++)\n        ret[i]%=1000000007;\n\n    return ret;\n}\n\nint n, m, k;\n\nint s;\n\nlong long mod=1000000007;\n\nlong long sil[1000007];\nlong long odw[1000007];\nlong long do3[1000007];\n\nvector <long long> d1, d2, d3;\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n    long long wyk=mod-2;\n    while(wyk)\n    {\n        if (wyk&1)\n        {\n            a*=b;\n            a%=mod;\n        }\n        b*=b;\n        b%=mod;\n        wyk>>=1;\n    }\n    return a;\n}\n\nlong long komb(int a, int b)\n{\n    if (b<0 || b>a)\n        return 0;\n    return (sil[a]*((odw[b]*odw[a-b])%mod))%mod;\n}\n\nlong long komz(int a, int b)\n{\n    return komb(a+b-1, b);\n}\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &m, &k);\n    s=n+m+k;\n    sil[0]=1;\n    odw[0]=1;\n    do3[0]=1;\n    for (int i=1; i<=s; i++)\n        sil[i]=(sil[i-1]*i)%mod;\n    odw[s]=dziel(1, sil[s]);\n    for (int i=s-1; i; i--)\n        odw[i]=(odw[i+1]*(i+1))%mod;\n    for (int i=1; i<=s; i++)\n        do3[i]=(do3[i-1]*3)%mod;\n    for (int i=0; i<=m; i++)\n        d1.push_back((komz(n, i)*odw[n+i-1])%mod);\n    for (int i=0; i<=k; i++)\n        d2.push_back(odw[i]);\n    d3=fft_dokladne(d1, d2);\n    for (int i=0; i<=m+k; i++)\n        wyn+=(d3[i]*((sil[n+i-1]*do3[m+k-i])%mod))%mod;\n    printf(\"%lld\\n\", wyn%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000005;\nconst int mod = 1e9+7;\n\nint n, fact[N], inv[N];\n\nint pw(int a, int n) {\n    int result = 1;\n    while (n > 0) {\n        if (n & 1)\n            result = (1LL * result * a) % mod;\n        a = (1LL * a * a) % mod;\n        n /= 2;\n    }\n    return result;\n}\n\nvoid precalc() {\n    fact[0] = inv[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fact[i] = (1LL * fact[i - 1] * i) % mod;\n        inv[i] = pw(fact[i], mod - 2);\n    }\n}\n\nint C(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    int result = fact[n];\n    result = (1LL * result * inv[n - k]) % mod;\n    result = (1LL * result * inv[k]) % mod;\n    return result;\n}\n\nint main() {\n    precalc();\n    int a, b, c;\n    cin >> a >> b >> c;\n    int result = 0;\n    int prv = 0, pl, pr;\n    for (int len = a; len <= a + b + c; ++len) {\n        int n = len - a;\n        int cur = 0;\n        int l = max(n - c, 0), r = min(b, n);\n        if (len == a) {\n            cur = 1;\n        } else {\n            cur = (2 * prv) % mod;\n            cur = (cur - C(n - 1, pl) + mod) % mod;\n            cur = (cur - C(n - 1, pr) + mod) % mod;\n            if (pl == l) cur = (cur + C(n, l)) % mod;\n            if (pr < r) cur = (cur + C(n, r)) % mod;\n        }\n        prv = cur;\n        pl = l;\n        pr = r;\n        cur = (1LL * cur * C(len - 1, a - 1)) % mod;\n        cur = (1LL * cur * pw(3, a + b + c - len)) % mod;\n        result = (result + cur) % mod;\n    }\n    cout << result << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nint fac[1010101],ifac[1010101];\nint fpow(int x,int y)\n{\n\tif(y==0)\n\t\treturn 1;\n\tint ret=fpow(x,y>>1);\n\tret=(long long)ret*ret%mod;\n\tif(y&1)\n\t\tret=(long long)ret*x%mod;\n\treturn ret;\n}\nint C(int n,int m)\n{\n\treturn (long long)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main()\n{\n\tint n,m,k,nn,h,ans=0,l,r,nl,nr,now,now1;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tnn=n+m+k;\n\tfac[0]=1;\n\tfor(int i=1;i<=nn;i++)\n\t\tfac[i]=(long long)fac[i-1]*i%mod;\n\tifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=nn;i++)\n\t\tifac[i]=(long long)(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(int i=2;i<=nn;i++)\n\t\tifac[i]=(long long)ifac[i-1]*ifac[i]%mod;\n\tnow=fpow(3,m+k);\n\tnow1=fpow(3,mod-2);\n\tfor(int i=0;i<=m+k;i++)\n\t{\n\t\tif(i==0)\n\t\t{\n\t\t\th=1;\n\t\t\tl=0;\n\t\t\tr=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnl=max(i-k,0);\n\t\t\tnr=min(m,i);\n\t\t\t(h*=2)%=mod;\n\t\t\t(h+=mod-C(i-1,l))%=mod;\n\t\t\t(h+=mod-C(i-1,r))%=mod;\n\t\t\tl++;\n\t\t\twhile(l>nl)\n\t\t\t{\n\t\t\t\tl--;\n\t\t\t\th+=C(i,l);\n\t\t\t}\n\t\t\twhile(r<nr)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th+=C(i,r);\n\t\t\t}\n\t\t}\n\t\tans=((long long)h*C(n+i-1,i)%mod*now+ans)%mod;\n\t\tnow=(long long)now*now1%mod;\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define fi(a,b) for(int i=a;i<b;++i)\ntypedef long long ll;\n///////////////////\n\nint const N = 3e3 + 41;\nint const MOD = 1e9 + 7;\n\nint n, m, k;\nint f[N], invf[N];\nint th[N];\nint ans;\n\nvoid add(int &a, int b){\n\ta += b;\n\twhile(a >= MOD) a -= MOD;\n\twhile(a < 0) a += MOD;\n}\n\nint mul(int a, int b){\n\treturn (ll) a * b % MOD;\n}\n\nint bp(int x, int d){\n\tint res = 1;\n\twhile(d){\n\t\tif(d&1) res = mul(res, x);\n\t\td >>= 1;\n\t\tx = mul(x, x);\n\t}\n\treturn res;\n}\n\nint inv(int x){\n\treturn bp(x, MOD-2);\n}\n\nvoid init(){\n\tf[0] = 1;\n\tfi(1, N) f[i] = mul(f[i-1], i);\n\tfi(0, N) invf[i] = inv(f[i]);\n\tth[0] = 1;\n\tfi(1, N) th[i] = mul(th[i-1], 3);\n}\n\nint getc(int n, int k){\n\tif(k > n) return 0;\n\tint res = f[n];\n\tres = mul(res, invf[k]);\n\tres = mul(res, invf[n-k]);\n\treturn res;\n}\n\nint dg[N];\n\nint getg(int x){\n\tif(dg[x] != -1) return dg[x];\n\tint res = 0;\n\tfi(0, k+1){\n\t\tint y = x - i;\n\t\tif(y > m) continue;\n\t\tint v = getc(x, i);\n\t\tadd(res, v);\n\t}\n\tdg[x] = res;\n\treturn res;\n}\n\nvoid solve(){\n\tint x = n + m + k;\n\tmemset(dg, 255, sizeof(dg));\n\tfi(1, x+1){\n\t\tint f = getc(i-1, n-1);\n\t\tint g = getg(i-n);\n\t\tint t = th[x-i];\n\t\tadd(ans, mul(f, mul(g, t)));\n\t}\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tinit();\n\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\n\tsolve();\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n\nconst ll M = 1000000007;\nint n, m, k;\nll f[1000010], fi[1000010], thr[1000010], ans;\n\nll pw(ll x, ll k){\n\tif(k == 1) return x;\n\treturn (k % 2 ? x : 1) * pw(x * x % M, k / 2) % M;\n}\n\nll cm(int n, int r){\n\treturn f[n] * fi[r] % M * fi[n - r] % M;\n}\n\nll cal(int x, int b){\n\tll ret = 0, s = 1;\n\tfor(int i = 0; i <= x; i++){\n\t\tret = (ret + thr[m + k - i - b] * cm(n - 1 + i + b, n - 1) % M * s) % M;\n\t\ts = (2 * s - cm(i + b, i) + cm(i + b + 1, i + 1) + M) % M;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tf[0] = fi[0] = thr[0] = 1;\n\tfor(int i = 1; i <= 1000005; i++){\n\t\tf[i] = f[i - 1] * i % M;\n\t\tfi[i] = pw(f[i], M - 2);\n\t\tthr[i] = thr[i - 1] * 3 % M;\n\t}\n\tprintf(\"%lld\\n\", (cal(m + k, 0) - cal(m - 1, k + 1) - cal(k - 1, m + 1) + 2 * M) % M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <math.h>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <string.h>\n#include <bitset>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+10, inv2 = (P+1)/2;\nint n,m,k,fac[N],ifac[N],po[N],ipo[N];\nint C(int a, int b, int c) {\n\treturn fac[a+b+c]*(ll)ifac[a]%P*ifac[b]%P*ifac[c]%P;\n}\nint main() {\n\tifac[0]=fac[0]=po[0]=ipo[0]=1;\n\tREP(i,1,N-1) { \n\t\tfac[i]=fac[i-1]*(ll)i%P;\n\t\tpo[i]=po[i-1]*3ll%P;\n\t}\n\tifac[N-1]=inv(fac[N-1]),ipo[N-1]=inv(po[N-1]);\n\tPER(i,1,N-2) { \n\t\tifac[i]=ifac[i+1]*(i+1ll)%P;\n\t\tipo[i]=ipo[i+1]*3ll%P;\n\t}\n\tcin>>n>>m>>k;\n\tint ans = 0, ret = 0;\n\tREP(i,0,m) { \n\t\tif (i==0) {\n\t\t\tREP(j,0,k) ret = (ret+(ll)ipo[j]*ifac[j]%P*fac[n+i+j-1])%P;\n\t\t}\n\t\tans = (ans+(ll)ipo[i]*ifac[i]%P*ret)%P;\n\t\tret = 3ll*inv2%P*ret%P*(n+i)%P;\n\t\tret = (ret-(ll)ipo[k]*inv2%P*fac[n+i+k]%P*ifac[k])%P;\n\t}\n\tans = (ll)ans*po[m+k]%P*ifac[n-1]%P;\n\tif (ans<0) ans += P;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nconst int MAXN = 3030;\n\nMint C[MAXN][MAXN];\nMint pow3[MAXN];\n\nvoid precalc() {\n   for (int i = 0; i < MAXN; ++i) {\n      C[i][0] = 1;\n      for (int j = 1; j <= i; ++j) C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n   }\n   pow3[0] = 1;\n   for (int i = 1; i < MAXN; ++i) pow3[i] = pow3[i - 1] * 3;\n}\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   precalc();\n   int N, M, K;\n   cin >> N >> M >> K;\n   assert(N <= 1000 && M <= 1000 && K <= 1000);\n   Mint ans = 0;\n   for (int x = 0; x <= M; ++x) {\n      for (int y = 0; y <= K; ++y) {\n         ans += C[x + y + N - 1][x + y] * C[x + y][y] * pow3[M - x + K - y];\n      }\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 P = 1000000000ll + 7;\nint64 n,m,k;\nint64 fz[200010],fm[200010];\nint64 fb[200010],fc[200010];\nint64 mpow(int64 x, int64 y)\n{\n\tint64 tmp = x, ret = 1;\n\twhile(y)\n\t{\n\t\tif(y & 1) ret = ret * tmp % P;\n\t\ttmp = tmp * tmp % P;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\nint64 C(int x, int y)\n{\n\tif(x < y) return 0;\n\treturn fz[x] * fm[y] % P * fm[x - y] % P;\n}\nint main()\n{\n    cin >> n >> m >> k;\n    fz[0]=fm[0]=1;\n    for(int i = 1; i <= 100000; i++)\n\t\tfz[i] = fz[i - 1] * i %P, fm[i] = mpow(fz[i], P - 2);\n\tint64 ans = 0;\n\tfor(int i = n; i < n + m + k + 1; i++)\n\t{\n\t\tint64 cnt = C(i - 1, n - 1);\n\t\tfb[i] = (fb[i - 1] * 2 % P + C(i - (n + 1), i - n - (m + 1))) % P;\n\t\tfc[i] = (fc[i - 1] * 2 % P + C(i - (n + 1), i - n - (k + 1))) % P;\n\t\tans = (ans + cnt * ((mpow(2, i - n) - (fb[i] + fc[i]) % P) % P + P) % P * mpow(3, n + m + k - i) % P) % P;\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int mod = 1'000'000'007;\nint fact[1'000'000], ifact[600'001];\n\nint main()\n{\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\t--a;\n\t\n\tfact[0] = 1;\n\tfor (int i = 1, max = a + b + c; i <= max; ++i)\n\t\tfact[i] = (i * (long long)fact[i - 1]) % mod;\n\n\tint imax = b + c; if (a > imax) imax = a;\n\tlong long cur = fact[imax];\n\tint pow = mod - 2, inv = 1;\n\twhile (pow > 0) {\n\t\tif (pow & 1) inv = (inv * cur) % mod;\n\t\tpow >>= 1;\n\t\tcur = (cur*cur) % mod;\n\t}\n\tfor (ifact[imax] = inv; imax > 0; --imax)\n\t\tifact[imax - 1] = (imax * (long long)ifact[imax]) % mod;\n\n\tunsigned int sum = 1, res = 1;\n\tfor (int i = 1, max = b + c; i <= max; ++i) {\n\t\tsum = 2 * (sum + mod);\n\t\tif (i > b) sum -= ((long long)fact[i - 1] * ifact[b] % mod) * ifact[i - b - 1] % mod;\n\t\tif (i > c) sum -= ((long long)fact[i - 1] * ifact[c] % mod) * ifact[i - c - 1] % mod;\n\t\tsum %= mod;\n\t\tres *= 3;\n\t\tres += sum * (long long)fact[a + i] % mod * ifact[a] % mod * ifact[i] % mod;\n\t\tres %= mod;\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int Mod = 1e9 + 7;\nconst int N = 3e6 + 10;\n\nint n, m, k;\nLL pw2[N], pw3[N], fac[N], inv[N];\n\nLL Power(LL a, LL b) {\n\tLL c = 1;\n\tfor (; b; b >>= 1, (a *= a) %= Mod)\n\t\tif (b & 1)\n\t\t\t(c *= a) %= Mod;\n\treturn c;\n}\n\nvoid Init() {\n\tpw2[0] = pw3[0] = 1;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw2[i] = pw2[i - 1] * 2 % Mod;\n\t\tpw3[i] = pw3[i - 1] * 3 % Mod;\n\t\tfac[i] = fac[i - 1] * i % Mod;\n\t}\n\tinv[N - 1] = Power(fac[N - 1], Mod - 2);\n\tfor (int i = N - 2; i; --i)\n\t\tinv[i] = inv[i + 1] * (i + 1) % Mod;\n}\n\nLL Binom(int m, int n) {\n\tif (n > m)\n\t\treturn 0;\n\treturn fac[m] * inv[n] % Mod * inv[m - n] % Mod;\n}\n\nvoid Solve() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tLL fb = 0;\n\tLL fc = 0;\n\tLL ans = 0;\n\tfor (int i = n; i <= n + m + k; ++i) {\n\t\tLL cnt = Binom(i - 1, n - 1);\n\t\tif (i - n == m + 1) \n\t\t\tfb = 1;\n\t\telse if (i - n > m + 1) \n\t\t\tfb = (fb * 2 + Binom(i - n - 1, m)) % Mod;\n\t\tif (i - n == k + 1)\n\t\t\tfc = 1;\n\t\telse if (i - n > k + 1)\n\t\t\tfc = (fc * 2 + Binom(i - n - 1, k)) % Mod;\n\t\tLL f = (pw2[i - n] - fb + Mod - fc + Mod) % Mod;\n\t\t(ans += f * cnt % Mod * pw3[n + m + k - i]) %= Mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n\n\tInit();\n\tSolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300005\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nll up,n,m,k;\nll ans=0,fac[N*3],ifac[N*3],mul[N*3];\ninline ll calc(int a,int b){return fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\ninline ll ksm(ll x,int p){\n\tll ret=1;\n\twhile(p){\n\t\tif(p&1)ret=ret*x%mod;\n\t\tx=x*x%mod,p>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n>>m>>k,up=n+m+k,fac[0]=mul[0]=ifac[1]=ifac[0]=1;\n\tfor(ll i=2;i<=up;++i)ifac[i]=(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(ll i=1;i<=up;++i)mul[i]=mul[i-1]*3%mod,(ifac[i]*=ifac[i-1])%=mod,fac[i]=fac[i-1]*i%mod;\n\tif(m<k)m^=k,k^=m,m^=k;\n\tfor(ll i=0,j=1;i<=m+k;++i){\n\t\t(ans+=calc(n-1+i,n-1)*mul[m+k-i]%mod*j%mod)%=mod;\n\t\tif(i<k)(j<<=1)%=mod;\n\t\telse if(i>=m)(j+=j-calc(i,k)-calc(i,i-m))%=mod;\n\t\telse (j+=j-calc(i,k))%=mod;\n\t}\n\tcout<<(ans+mod)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 300000;\nconst int MOD = (int)1e9 + 7;\n\nint inv[N + N + 1], a, b, c, bn_b[N], bn_c[N];\n\nvoid update(int& x, int a)\n{\n    x += a;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nvoid prepare(int* bn, int a, int b) // bn[i] = binom{i + b}{b} 0 <= i < a\n{\n    bn[0] = 1;\n    for (int i = 1; i < a; ++ i) {\n        bn[i] = 1LL * bn[i - 1] * (i + b) % MOD * inv[i] % MOD;\n    }\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"F.in\", \"r\", stdin);\n#endif\n    inv[1] = 1;\n    for (int i = 2; i <= N + N; ++ i) {\n        inv[i] = 1LL * (MOD - MOD / i) * inv[MOD % i] % MOD;\n    }\n    while (scanf(\"%d%d%d\", &a, &b, &c) == 3) {\n        a --;\n        prepare(bn_b, b, c);\n        prepare(bn_c, c, b);\n        int three = 1;\n        for (int i = 0; i < b + c; ++ i) {\n            three = 3LL * three % MOD;\n        }\n        int bn_a = 1;\n        int ds = 1;\n        int result = three;\n        for (int s = 1; s <= b + c; ++ s) {\n            three = 1LL * three * inv[3] % MOD;\n            bn_a = 1LL * bn_a * (s + a) % MOD * inv[s] % MOD;\n            ds = 2LL * ds % MOD;\n            if (s > b) {\n                update(ds, MOD - bn_b[s - b - 1]);\n            }\n            if (s > c) {\n                update(ds, MOD - bn_c[s - c - 1]);\n            }\n            update(result, 1LL * bn_a * ds % MOD * three % MOD);\n        }\n        printf(\"%d\\n\", result);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define C(X,Y) (P[X]*rP[Y]%mod*rP[(X)-(Y)]%mod)\nconst long long mod=1000000007ll;\n\nint main()\n{\n  static long long v[1000000];\n  v[1]=1;\n  for(int i=2;i<1000000;i++){\n    v[i]=(mod-mod/i)*v[mod%i]%mod;\n  }\n  static long long P[1000000],rP[1000000],P3[1000000];\n  P[0]=rP[0]=P3[0]=1ll;\n  for(int i=1;i<1000000;i++){\n    P[i]=P[i-1]*i%mod;\n    rP[i]=rP[i-1]*v[i]%mod;\n    P3[i]=P3[i-1]*3ll%mod;\n  }\n  int N,M,K;\n  scanf(\"%d%d%d\",&N,&M,&K);\n  long long ans=0ll;\n  for(int i=0;i<=M;i++){\n    for(int j=0;j<=K;j++){\n      ans+=C(N-1+i+j,i)*C(N-1+j,j)%mod*P3[(M-i)+(K-j)]%mod;\n      //printf(\"%d %d %lld %lld\\n\",i,j,C(N-1+i+j,j),P3[(M-i)+(K-i)]);\n      ans%=mod;\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse(static_cast<ll>(x.v), static_cast<ll>(mod))}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod)))} {}\n    ModInt(const ModInt& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    ModInt& operator=(const ModInt& m) { return v = m(), (*this); }\n    ModInt& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod))), (*this); }\n    friend ModInt operator+(const ModInt& m) { return m; }\n    friend ModInt operator-(const ModInt& m) { return make(norm(mod - m.v)); }\n    friend ModInt operator+(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + m2.v)); }\n    friend ModInt operator-(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + mod - m2.v)); }\n    friend ModInt operator*(const ModInt& m1, const ModInt& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod))); }\n    friend ModInt operator/(const ModInt& m1, const ModInt& m2) { return m1 * inv(m2.v); }\n    friend ModInt operator+(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) - val}; }\n    friend ModInt operator*(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * inv(val)}; }\n    friend ModInt operator+(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ll val, const ModInt& m) { return ModInt{-static_cast<ll>(m.v) + val}; }\n    friend ModInt operator*(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ll val, const ModInt& m) { return ModInt{val * inv(static_cast<ll>(m.v))}; }\n    friend ModInt& operator+=(ModInt& m1, const ModInt& m2) { return m1 = m1 + m2; }\n    friend ModInt& operator-=(ModInt& m1, const ModInt& m2) { return m1 = m1 - m2; }\n    friend ModInt& operator*=(ModInt& m1, const ModInt& m2) { return m1 = m1 * m2; }\n    friend ModInt& operator/=(ModInt& m1, const ModInt& m2) { return m1 = m1 / m2; }\n    friend ModInt& operator+=(ModInt& m, const ll val) { return m = m + val; }\n    friend ModInt& operator-=(ModInt& m, const ll val) { return m = m - val; }\n    friend ModInt& operator*=(ModInt& m, const ll val) { return m = m * val; }\n    friend ModInt& operator/=(ModInt& m, const ll val) { return m = m / val; }\n    friend ModInt operator^(const ModInt& m, const ll n) { return power(m.v, n); }\n    friend ModInt& operator^=(ModInt& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const ModInt& m1, const ModInt& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const ModInt& m1, const ModInt& m2) { return not(m1 == m2); }\n    friend bool operator==(const ModInt& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ModInt& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const ModInt& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ll val, const ModInt& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, ModInt& m)\n    {\n        uint v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& m) { return os << m(); }\n    static std::vector<ModInt> invVec(const std::size_t N)\n    {\n        std::vector<ModInt> ans(N + 1, 1);\n        for (std::size_t i = 2; i <= N; i++) { ans[i] = -ans[mod % i] * (mod / i); }\n        return ans;\n    }\n    uint operator()() const { return v; }\n};\n//!============================================================================!//\n//!  8888ba.88ba                 dP     a88888b.                     dP        !//\n//!  88  '8b  '8b                88    d8'   '88                     88        !//\n//!  88   88   88 .d8888b. .d888b88    88        .d8888b. 88d8b.d8b. 88d888b.  !//\n//!  88   88   88 88'  '88 88'  '88    88        88'  '88 88''88''88 88'  '88  !//\n//!  88   88   88 88.  .88 88.  .88    Y8.   .88 88.  .88 88  88  88 88.  .88  !//\n//!  dP   dP   dP '88888P' '88888P8     Y88888P' '88888P' dP  dP  dP 88Y8888'  !//\n//!============================================================================!//\ntemplate <uint mod>\nclass ModComb\n{\npublic:\n    ModComb(const std::size_t N) : f(N + 1, ModInt<mod>(1)), in(N + 1, ModInt<mod>(1)), invf(N + 1, ModInt<mod>(1))\n    {\n        for (uint i = 2; i <= N; i++) { f[i] = f[i - 1] * i, in[i] = -in[mod % i] * (mod / i), invf[i] = invf[i - 1] * in[i]; }\n    }\n    ModInt<mod> fact(const std::size_t N) const { return f[N]; }\n    ModInt<mod> inv(const std::size_t N) const { return in[N]; }\n    ModInt<mod> invFact(const std::size_t N) const { return invf[N]; }\n    ModInt<mod> perm(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[N - K]; }\n    ModInt<mod> comb(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[K] * invf[N - K]; }\n\nprivate:\n    std::vector<ModInt<mod>> f, in, invf;\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int N = read<int>();\n    int M = read<int>(), K = read<int>();\n    if (M > K) { std::swap(M, K); }\n    using mint = ModInt<MOD>;\n    ModComb<MOD> mod(N + M + K);\n    std::vector<mint> P(M + K + 1, 1);\n    for (int i = 0; i < M + K; i++) { P[i + 1] = P[i] * 3; }\n    std::vector<mint> dp(M + K + 1);\n    dp[0] = 1;\n    for (int i = 0; i < M + K; i++) { dp[i + 1] = dp[i] * 2 - mod.comb(i, M) - mod.comb(i, i - K); }\n    mint ans = 0;\n    for (int s = 0; s <= M + K; s++) { ans += P[M + K - s] * mod.comb(N + s - 1, N - 1) * dp[s]; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// see https://gist.github.com/LumaKernel/ff55d49ee1af69b7388f15b707e75c15\nconst bool DEBUG = 1;\n#include <iostream>\n#include <vector>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n#include <random>\n#include <iomanip>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing  P = tuple<ll, ll>;\nusing  P3 = tuple<ll, ll, ll>;\nusing  VI = vector<int>;\nusing  VL = vector<ll>;\nusing  VP = vector<P>;\nusing  VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\"\n\n#define dump(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dump2(x,y) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)<<\"\\n\"\n#define dump3(x,y,z) if(DEBUG)cerr<<\"[\"<<__LINE__<<\"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)\\\n  <<\" , \"<<#z<<\"=\"<<(z)<<\"\\n\"\n\n#define SAY(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<(x)<<\"\\n\"\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\"\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\"\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\"\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7; template <typename T> function<T(T,T)> constexpr mmin(){ return [](T x, T y){return x<y?x:y;}; }\ntemplate <typename T> function<T(T,T)> constexpr mmax(){ return [](T x, T y){return x>y?x:y;}; }\ntemplate <typename T> function<T(T,T)> constexpr madd(){ return [](T x, T y){return x+y;}; }\ntemplate <typename T> function<T(T,T)> constexpr modadd(){ return [](T x, T y){return ((x+y)%MOD+MOD)%MOD;}; }\n\nll ans;\nconst int N = 3e5 + 2;\n\nll pascalsum[N*3];\n\nint add(int a, int b) {\n\treturn ((((ll) a + b) % MOD) + MOD) % MOD;\n}\n\nint mul(int a, int b){\n\treturn (ll)a*b%MOD;\n}\n\nint pow(int a, int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b&1) res = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>=1;\n\t}\n\treturn res;\n}\n\nint inv(int a) {\n\treturn pow(a, MOD - 2);\n}\n\nint fact[N*3];\nint invFact[N*3];\n\nint nCr(int n, int r) {\n\treturn mul(fact[n], mul(invFact[r], invFact[n-r]));\n}\n\nint main() {\n\t//#####//\n\tfact[0]  = invFact[0] = 1;\n\tFOR(i, 1, N*2) {\n\t\tfact[i] = (ll)fact[i-1] * i % MOD;\n\t\tinvFact[i] = inv(fact[i]);\n\t}\n\n\tint n=ini, M=ini, K=ini;\n\tpascalsum[0] = 1;\n\tFOR(i, 1, M + K + 1) {\n\t\tpascalsum[i] = mul(2, pascalsum[i-1]);\n\t\tif(i >= M+1) pascalsum[i] = add(pascalsum[i], MOD - nCr(i-1, M));\n\t\tif(i >= K+1) pascalsum[i] = add(pascalsum[i], MOD - nCr(i-1, i - K - 1));\n\t}\n\n\tFOR(t, n, n+M+K+1) {\n\t\tint T = n + M + K;\n\t\tans += ((ll)(nCr(t-1, n-1)) * pow(3, T-t) % MOD) * pascalsum[t-n] % MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\nconst int N=1e6+10,P=1e9+7;\nint a,b,c,f[N],fac[N],ifac[N],inv[N],ff;\nlong long ans;\nint C(int n,int k){\n    if(n<k||k<0) return 0;\n    return 1ll*fac[n]*ifac[k]%P*ifac[n-k]%P;\n}\nvoid pre(int n){\n    fac[0]=1;rep(i,1,n) fac[i]=1ll*fac[i-1]*i%P;\n    inv[1]=1;rep(i,2,n) inv[i]=1ll*(P-P/i)*inv[P%i]%P;\n    ifac[0]=1;rep(i,1,n) ifac[i]=1ll*ifac[i-1]*inv[i]%P;\n}\nint main(){\n    scanf(\"%d%d%d\",&a,&b,&c);pre(a+b+c);f[0]=1;\n    rep(i,1,b+c) f[i]=3ll*f[i-1]%P;\n    if(b>c) swap(b,c);ff=1;\n    rep(i,0,b+c){\n        ans+=1ll*f[b+c-i]*C(a-1+i,i)%P*ff%P;\n        ff=ff*2%P;\n        if(i>=b) ff=(ff-C(i,b)+P)%P;\n        if(i>=c) ff=(ff-C(i,c)+P)%P;\n    }\n    printf(\"%lld\\n\",ans%P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct edge\n{\n    int to, kind;\n};\n\nvector<edge> G[MAX_N];\nmap<int, int> d[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    rep(i, m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        --a, --b, --c;\n        G[a].pb((edge){b, c}), G[b].pb((edge){a, c});\n    }\n    deque<P> que;\n    que.pb(P(0, -1));\n    d[0][-1] = 0;\n    while(!que.empty()){\n        P p = que.front();\n        que.pop_front();\n        int dist = d[p.fi][p.se];\n        each(e,G[p.fi]){\n            auto it = d[e.to].find(e.kind);\n            if(it == d[e.to].end() || it->se > dist + (e.kind != p.se)){\n                d[e.to][e.kind] = dist + (e.kind != p.se);\n                if((e.kind != p.se)){\n                    que.push_back(P(e.to, e.kind));\n                }else{\n                    que.push_front(P(e.to, e.kind));\n                }\n            }\n        }\n    }\n    int mn = INF;\n    each(it, d[n-1]){\n        cmn(mn, it.se);\n    }\n    if(mn < INF){\n        cout << mn << \"\\n\";\n    }else{\n        cout << \"-1\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 1e6 + 5;\nconst int mod = 1e9 + 7; \nusing namespace std;\n\nint n, m, k, fac[N], inv[N], ans, pw[N], f[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint fpow(int x, int y)\n{\n\tint res = 1;\n\tfor( ; y; y >>= 1, x = 1ll * x * x % mod)\n\t\tif(y & 1) res = 1ll * res * x % mod;\n\treturn res; \n}\n\nint C(int n, int m)\n{\n\tif(n < m || m < 0 || n < 0) return 0;\n\treturn 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod; \n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin);\n#endif\n\tn = read <int> (), m = read <int> (), k = read <int> ();\n\tfor(int i = (fac[0] = 1); i <= n + m + k; i++) fac[i] = 1ll * fac[i - 1] * i % mod; \n\tinv[n + m + k] = fpow(fac[n + m + k], mod - 2);\n\tfor(int i = n + m + k - 1; i >= 0; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; \n\tfor(int i = (pw[0] = 1); i <= n + m + k; i++) pw[i] = 1ll * pw[i - 1] * 3 % mod; \n\tfor(int t = 0; t <= m + k; t++)\n\t{\n\t\tif(!t) f[t] = 1;\n\t\telse f[t] = 2ll * f[t - 1], f[t] = (1ll * f[t] - C(t - 1, t - 1 - k) - C(t - 1, m) + 2ll * mod) % mod;\n\t\tans = (1ll * pw[m + k - t] * C(n + t - 1, n - 1) % mod * f[t] + ans) % mod; \n\t}\n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < int(n); ++(i))\nusing ll = long long;\nusing namespace std;\n\nll powmod(ll x, ll y, ll p) { // O(log y)\n    assert (0 <= x and x < p);\n    assert (0 <= y);\n    ll z = 1;\n    for (ll i = 1; i <= y; i <<= 1) {\n        if (y & i) z = z * x % p;\n        x = x * x % p;\n    }\n    return z;\n}\nll inv(ll x, ll p) { // p must be a prime, O(log p)\n    assert ((x % p + p) % p != 0);\n    return powmod(x, p-2, p);\n}\ntemplate <int mod>\nint fact(int n) {\n    static vector<int> memo(1,1);\n    if (memo.size() <= n) {\n        int l = memo.size();\n        memo.resize(n+1);\n        repeat_from (i,l,n+1) memo[i] = memo[i-1] *(ll) i % mod;\n    }\n    return memo[n];\n}\ntemplate <int mod>\nint choose(int n, int r) { // O(n) at first time, otherwise O(\\log n)\n    if (n < r) return 0;\n    r = min(r, n - r);\n    return fact<mod>(n) *(ll) inv(fact<mod>(n-r), mod) % mod *(ll) inv(fact<mod>(r), mod) % mod;\n}\n\nconstexpr ll mod = 1e9+7;\nint main() {\n    int n, m, k; scanf(\"%d%d%d\", &n, &m, &k);\n    ll result = 0;\n    if (n == 0) {\n        result += powmod(3, m + k, mod);\n    } else {\n        ll y = 1;\n        repeat_from (l, n, n+m+k+1) {\n            ll x = choose<mod>(l-1, n-1);\n            // ll y = 0;\n            // int yl = max(0, l-n-k);\n            // int yr = min(l-n, m) + 1; // [l, r)\n            // repeat_from (i, yl, yr) {\n            //     y += choose<mod>(l-n, i);\n            // }\n            // y %= mod;\n            ll z = powmod(3, n+m+k-l, mod);\n            result += x * y % mod * z % mod;\n            // update\n            y *= 2;\n            if (l-n-k >= 0) y -= choose<mod>(l-n, l-n-k);\n            if (m <= l-n) y -= choose<mod>(l-n, m);\n            y %= mod;\n            if (y < 0) y += mod;\n        }\n    }\n    result %= mod;\n    printf(\"%lld\\n\", result);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long LL;\nconst int N=1e6+5,md=1e9+7;\nint a,b,c,fac[N],iv[N],ans;\ninline int pow(int a,int b){\n\tint ret=1;\n\tfor(;b;b>>=1,a=(LL)a*a%md)if(b&1)ret=(LL)ret*a%md;\n\treturn ret;\n}\ninline int C(int n,int m){return n>=m?(LL)fac[n]*iv[m]%md*iv[n-m]%md:0;}\nint main(){\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tif(!a--)return puts(\"1\"),0;\n\tif(b>c)b^=c^=b^=c;\n\tfor(int i=*fac=1;i<=1000000;++i)fac[i]=(LL)fac[i-1]*i%md;\n\tiv[1000000]=397802501;\n\tfor(int i=1e6-1;~i;--i)iv[i]=(i+1LL)*iv[i+1]%md;\n\tint pL=0,pR=0;\n\tfor(int i=0,x=1,y=pow(3,b+c);i<=b+c;++i){\n\t\tint nL=i<=c?0:(pL*2LL-C(i-1,i-c-2)+C(i,i-c-1)+md)%md;\n\t\tint nR=i<=b?x:(pR*2LL-C(i-1,b)+md)%md;\n\t\tpL=nL,pR=nR;\n\t\tans=(ans+(LL)C(i+a,a)*(nR-nL+md)%md*y)%md;\n\t\tx=x*2%md,y=y*333333336LL%md;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define mod 1000000007LL\n#define maxn 100005\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define INF 1000000000\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<i64, i64> pii;\n\n\nclass numberTheory{\n\npublic:\n    numberTheory(){}\n\n    pii extendedEuclid(i64 a, i64 b) { // returns x, y | ax + by = gcd(a,b)\n\n        if(b == 0) return pii(1LL, 0LL);\n        else {\n            pii d = extendedEuclid(b, a % b);\n            return pii(d.yy, d.xx - d.yy * (a / b));\n        }\n\n    }\n\n    i64 modularInverse(i64 a, i64 n) {\n        pair<i64,i64> ret = extendedEuclid(a, n);\n        return ((ret.xx % n) + n) % n;\n    }\n\n\n    i64 bigMod(i64 a, i64 n , i64 m)\n    {\n        if(n==0) return 1 ;\n        i64 ret = bigMod(a,n/2,m) ;\n        ret = (ret*ret)%m ;\n        if(n%2) ret = (ret*a)%m ;\n        return ret ;\n    }\n};\n\nconst i64 N = 1000000 ;\n\ni64 fact[N+5] , invFact[N+5] ;\n\ni64 C(i64 n, i64 r)\n{\n    if( n<0 || r<0 || r>n ) return 0 ;\n    i64 ret = (fact[n]*invFact[r])%mod ;\n    return (ret*invFact[n-r])%mod ;\n}\n\nvoid preprocess()\n{\n    numberTheory nt ;\n\n    fact[0] = 1 ;\n    for(i64 x=1 ; x<=N ; x++) fact[x] = (fact[x-1]*x)%mod ;\n\n    invFact[N] = nt.modularInverse(fact[N],mod) ;\n\n    for(i64 x=N-1 ; x>=0 ; x--) invFact[x] = (invFact[x+1]*(x+1) )%mod ;\n}\n\ni64 f[600005] , p[600005] ;\n\nint main()\n{\n    preprocess() ;\n\n    i64 i , j , k , l , m , n ;\n    i64 N , M , K ;\n\n    scanf(\"%lld %lld %lld\",&N,&M,&K) ;\n\n    f[0] = 1 ;\n    i64 curA = 0 , curB = 0 ;\n\n    for(i64 s=1 ; s<=M+K; s++)\n    {\n        i64 cur = 2*f[s-1] - C(s-1,curA) - C(s-1,curB) + C(s,curA) ;\n        i64 a = max(0LL,s-K) , b = min(s,M) ;\n        while( curA>a )\n        {\n            curA-- ;\n            cur += C(s,curA) ;\n        }\n        while(curA<a )\n        {\n            cur -= C(s,curA) ;\n            curA++ ;\n        }\n        while( curB>b )\n        {\n            cur -= C(s,curB) ;\n            curB-- ;\n        }\n        while(curB<b )\n        {\n            curB++ ;\n            cur += C(s,curB) ;\n        }\n        f[s] = cur%mod ;\n //       printf(\"a:%lld b:%lld %lld\\n\",curA,curB,cur) ;\n    }\n\n    p[0] = 1LL ;\n\n    for(i=1 ; i<=M+K ; i++) p[i] = (p[i-1]*3)%mod ;\n\n    i64 ans = 0LL ;\n\n    for(i64 s = 0 ; s<=M+K ; s++)\n    {\n        i64 ret = (C( N-1+s,s )*f[s])%mod ;\n        ret = ( ret*p[M+K-s] )%mod ;\n        ans = (ans+ret)%mod ;\n    }\n\n    printf(\"%lld\\n\", (ans%mod + mod)%mod ) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\n\nusing namespace std;\n\nlong long N, M, K;\n\n\nvector<vector<long long> > comb;\n\nvoid combination(int n)\n{\n\tcomb.assign(n+1, vector<long long>(n+1, 0));\n\tfor(int i=0; i<=n; ++i){\n\t\tcomb[i][0] = 1;\n\t\tfor(int j=1; j<=i; ++j){\n\t\t\tcomb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n\t\t\tcomb[i][j] %= DIV;\n\t\t}\n\t}\n}\n\nlong long modpow(long long ori, long long po){\n\tlong long res = 1;\n\twhile(po > 0){\n\t\tif(po&1){\n\t\t\tres *= ori;\n\t\t\tres %= DIV;\n\t\t}\n\t\tori *= ori;\n\t\tori %= DIV;\n\t\tpo >>= 1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> N >> M >> K;\n\n\tcombination(N+M+K+5);\n\n\tlong long ret = 0;\n\tfor(int m = 0; m <= M; m++){\n\t\tfor(int k = 0; k <= K; k++){\n\t\t\tlong long tmp;\n\t\t\ttmp = comb[m+k+N-1][N-1];\n\t\t\ttmp *= comb[m+k][m];\n\t\t\ttmp %= DIV;\n\t\t\ttmp *= modpow(3, M+K-m-k);\n\t\t\ttmp %= DIV;\n\n\t\t\tret += tmp;\n\t\t\tret %= DIV;\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <limits>\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <algorithm>\n\n\nusing namespace std;\ntypedef long long Long;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> PII;\n\nstruct Math\n{\n\ttypedef long long Long;\n\tstatic int egcd(int a,int b)\n\t{\n\t\tint r = a , o_r = b;\n\t\tint s = 0 , o_s = 1;\n\t\tint t = 1 , o_t = 0;\n\t\twhile(r != 0)\n\t\t{\n\t\t\tint q = o_r / r;\n\t\t\tint tem;\n\t\t\t\n\t\t\ttem = r;\n\t\t\tr = o_r - r * q;\n\t\t\to_r = tem;\n\t\t\t\n\t\t\ttem = o_s;\n\t\t\to_s = o_s - s * q;\n\t\t\to_s = tem;\n\t\t\t\n\t\t\ttem = t;\n\t\t\tt = o_t - t * q;\n\t\t\to_t = tem;\n\t\t}\n\t\t// coeficients = o_t , o_s \n\t\t// gcd         = o_r\n\t\t// quotients   = t , s\n\t\treturn o_t;\n\t}\n\tstatic int MOD;\n\tstatic Long divide(Long a, Long b)\n\t{\n\t\treturn (((egcd(b,MOD) % MOD + MOD) % MOD) * a) % MOD;\n\t}\n\tstatic int fact(int n)\n\t{\n\t\tstatic vector<int> F;\n\t\tif(F.size() <= n)\n\t\t{\n\t\t\tint oSZ = F.size();\n\t\t\tF.resize(n+1);\n\t\t\tif(oSZ == 0)F[0] = 1 , oSZ++;\n\t\t\tfor(int i = oSZ; i <= n; ++i)\n\t\t\t\tF[i] = (1LL * F[i-1] * i) % MOD;\n\t\t}\n\t\treturn F[n];\n\t}\n\tstatic int ifact(int n){\n\t\tstatic vector<int> F;\n\t\tint fa = fact(n);\n\t\tif(F.size() <= n){\n\t\t\tint oSZ = F.size();\n\t\t\tF.resize(n+1);\n\t\t}\n\t\tif(F[n] == 0){\n\t\t\treturn F[n] = divide(1,fa);\n\t\t}\n\t\treturn F[n];\n\t}\n\tstatic int catalan(int n)\n\t{\n\t\treturn divide(ncr(2*n,n), n+1);\n\t}\n\tstatic int ncr(int n,int k)\n\t{\n\t\tif(k < 0 || n < 0 || n < k)return 0;\n\t\treturn mul(fact(n) , ifact(k) , ifact(n-k));\n\t}\n\tstatic int mul(int a,int b){\n\t\treturn (1LL*(a%MOD)*(b%MOD))%MOD;\n\t}\n\tstatic int  mul(int a,int b,int c){\n\t\treturn (1LL*mul(a,b)*(c%MOD))%MOD;\n\t}\n\tstatic int  mul(int a,int b,int c,int d){\n\t\treturn (1LL*mul(a,b)*mul(c,d))%MOD;\n\t}\n\tstatic int modPow(int b, int e){\n\t\tif(e == 0)return 1;\n\t\tint sq = modPow(b,e/2);\n\t\tsq = mul(sq,sq);\n\t\tif(e&1)sq = mul(sq,b);\n\t\treturn sq;\n\t}\n};\nint Math::MOD = 1000000007;\n\nint main()\n{\n\tint N,M,K;\n\tcin >> N >> M >> K;\n\tLong W = 0;\n\tfor(int i = 0; i <= M; ++i){\n\t\tfor(int j = 0; j <= K; ++j){\n\t\t\tint a = N-1, b = i, c = j;\n\t\t\tint tot = a+b+c;\n\t\t\tW += Math::mul(\n\t\t\t\t\tMath::ncr(tot,a),\n\t\t\t\t\tMath::ncr(tot-a,b),\n\t\t\t\t\tMath::modPow(3,M+K-b-c)\n\t\t\t);\n\t\t}\n\t}\n\tcout << W % Math::MOD << endl;\n\t\n}\n\n/*\n\n3 1 2 1\n4 7 52 9\n7 1 2 1\n3 9 52 4\n1 2 3 4\n5 10 7 8\n1 2 3 4\n5 8 7 10\n34 5 6 998\n4 17 77 84\n34 5 6 998\n4 17 77 8481\n\n\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 5000 + 5\n#define Mod 1000000007\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, m, k, ans, p[N], C[N][N];\nint Inc(int a, int b){\n\treturn (a += b) >= Mod ? a - Mod : a;\n}\nint Dec(int a, int b){\n\treturn (a -= b) < 0 ? a + Mod : a;\n}\nint Mul(int a, int b){\n\treturn 1ll * a * b % Mod;\n}\nint main(){\n\tcin >> n >> m >> k;\n\trep(i, 0, N - 5) C[i][0] = 1;\n\trep(i, 1, N - 5) rep(j, 1, i) C[i][j] = Inc(C[i - 1][j - 1], C[i - 1][j]);\n\tp[0] = 1;\n\trep(i, 1, N - 5) p[i] = Mul(p[i - 1], 3);\n\trep(i, 0, m){\n\t\tint tmp = Mul(C[n + i - 1][n - 1], p[m - i]);\n\t\trep(j, 0, k) ans = Inc(ans, Mul(tmp, Mul(C[n + i + j - 1][n + i - 1], p[k - j])));\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nstruct Mod\n{\n    static const auto P = static_cast<int>(1e9+7);\n    ll k;\n\n    Mod() = default;\n    Mod(const ll k) : k(k%P) {}\n};\n\nMod operator+(const Mod a, const Mod b) { return a.k + b.k; }\nMod operator*(const Mod a, const Mod b) { return a.k * b.k; }\nMod& operator+=(Mod& a, const Mod b) { return a = a+b; }\n\nMod cache[4000][4000];\nbool seen[4000][4000];\nMod choose(int n, int k)\n{\n    if (seen[n][k]) return cache[n][k];\n    seen[n][k] = true;\n\n    auto& result = cache[n][k];\n    if (k == 0 || n == k) result = 1;\n    else if (k > n) result = 0;\n    else result = choose(n-1, k-1) + choose(n-1, k);\n\n    return result;\n};\n\nint main()\n{\n    int N, M, K; cin >> N >> M >> K;\n\n    auto power = vector<Mod>(M+K+1);\n    power[0] = 1;\n    for (auto i = 1; i <= M+K; i++)\n        power[i] = power[i-1] * 3;\n\n    auto result = Mod(0);\n    for (auto m = 0; m <= M; m++) for (auto k = 0; k <= K; k++)\n        result += choose(N-1+m+k, N-1) * choose(m+k, m) * power[M-m+K-k];\n    cout << result.k << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2) \n#include<bits/stdc++.h>\n#define rg register\n#define il inline\n#define int long long\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7,O=1000010;\nil int gi(){\n\trg int o=0,fl=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')fl=-1,ch=getchar();\n\twhile(isdigit(ch))o=o*10+ch-'0',ch=getchar();\n\treturn fl*o;\n}\nint n,m,k;\nll fac[O],inv[O],bin[O],ans,x=1;\nil ll C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&m,&k);n--;\n\tbin[0]=fac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<O;++i)bin[i]=bin[i-1]*3%mod;\n\tfor(int i=2;i<O;++i){\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tfor(int i=2;i<O;++i)inv[i]=inv[i-1]*inv[i]%mod;\n\tfor(int i=0;i<=m+k;++i){\n\t\t(ans+=C(n+i,n)*bin[m+k-i]%mod*x%mod)%=mod;\n//\t\tprintf(\"%lld %lld %lld %lld\\n\",C(n+i,n),bin[m+k-i],x,ans<0?ans+mod:ans);\n\t\tif(i<k)(x<<=1)%=mod;\n        else if(i<m)x=((x*2-C(i,k))%mod+mod)%mod;\n        else x=((x*2-C(i,k)-C(i,m))%mod+mod)%mod;\n\t}\n\tans%=mod;\n\tprintf(\"%lld\",ans<0?ans+mod:ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int N = 600010, Mod = 1e9 + 7;\nint fac[N], ifac[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod)\n\t\tif (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint C(int n, int m) {\n\tif (n < m) return 0;\n\tif (n < 0 || m < 0) return 0;\n\treturn 1ll * fac[n] * ifac[n - m] % Mod * ifac[m] % Mod;\n}\nint n, m, k;\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tread(n), read(m), read(k);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N - 10; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[N - 10] = fpow(fac[N - 10], Mod - 2);\n\tfor (int i = N - 10; i >= 1; i--) ifac[i - 1] = 1ll * ifac[i] * i % Mod;\n\tLL ans = fpow(3, m + k), S = 1;\n\tfor (int t = 1; t <= m + k; t++) {\n\t\tS = (2 * S % Mod - C(t - 1, m) + Mod) % Mod;\n\t\tif (t - k > 0) S = (S - C(t - 1, t - k - 1) + Mod) % Mod;\n\t\tans = (ans + 1ll * fpow(3, m + k - t) * C(t + n - 1, n - 1) % Mod * S % Mod) % Mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n\nusing namespace std;\n\n// From Errichto's Youtube stream\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nusing int64 = long long;\n\n/////////////////////\n// Code starts here//\n/////////////////////\nconst int MOD = 1000000007;\n\nint N, M, K;\n\nvector<int> inv, invfact, pow3, pow2, fact;\n\nvoid add (int & a, int b) {\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n}\n\nint mul (int a, int b) {\n    return (int64)a * b % MOD;\n}\n\nint Choose (int n, int k) {\n    //assert(k <= n);\n    if (!k) return 1;\n    if (n == k) return 1;\n    return mul(fact[n], mul(invfact[k], invfact[n-k])); \n}\n\ninline int power(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n \ninline int inverse(int x) {\n  return power(x, MOD - 2);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N >> M >> K;\n\n    N--;\n    if (M > K) {\n        swap(M, K);\n    }\n\n    int result = 0;\n\n    pow3.resize(N + M + K + 2);\n    pow2 = pow3;\n    fact = pow3;\n    invfact = pow3;\n\n    pow3[0] = 1;\n    pow2[0] = 1;\n    for (int i = 1; i < pow3.size(); i++) {\n        pow2[i] = mul(pow2[i - 1], 2);\n        pow3[i] = mul(pow3[i - 1], 3);\n    }\n\n    fact[0] = 1;\n    for (int i = 1; i < fact.size(); i++) {\n        fact[i] = mul(fact[i-1], i);\n    }\n\n    invfact[N + M + K + 1] = inverse(fact[N + M + K + 1]);\n    for (int i = N + M + K; i >= 0; i--) {\n        invfact[i] = mul(invfact[i + 1], i + 1);\n    }\n\n    for (int m = 0; m <= M; m++) {\n        for (int k = 0; k <= K; k++) {\n            auto cur = Choose(m + k, k);\n            cur = mul (cur, pow3[M + K - (m + k)]);\n            cur = mul (cur, Choose(N + m + k, N));\n            add(result, cur);\n        }\n    }\n\n    // divide by N!\n\n    cout << result << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 21);\nconst int mod = (int)1e9 + 7;\nconst double PI = acos(-1);\n\ninline void addmod(int& x, int y, int mod) { (x += y) >= mod && (x -= mod); }\ninline int mulmod(int x, int y, int mod) { return x * 1ll * y % mod; }\n\nstruct complex_base\n{\n\tlong double x, y;\n\tcomplex_base(long double _x = 0, long double _y = 0) { x = _x; y = _y; }\n\tfriend complex_base operator-(const complex_base &a, const complex_base &b) { return complex_base(a.x - b.x, a.y - b.y); }\n\tfriend complex_base operator+(const complex_base &a, const complex_base &b) { return complex_base(a.x + b.x, a.y + b.y); }\n\tfriend complex_base operator*(const complex_base &a, const complex_base &b) { return complex_base(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x); }\n\tfriend void operator/=(complex_base &a, const long double &P) { a.x /= P; a.y /= P; }\n};\n\nint bit_rev[MAXN];\n\nvoid fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = 2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n}\n\nvoid inv_fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tlong double ang = -2 * PI / len;\n\t\tcomplex_base w(1, 0), wn(cos(ang), sin(ang));\n\n\t\tfor(int j = 0; j < (len >> 1); j++, w = w * wn)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = w * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] /= n;\n}\n\ncomplex_base A[MAXN], B[MAXN];\n\nvector<int> mult(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() <= 128)\n\t{\n\t\tvector<int> ans(a.size() + b.size(), 0);\n\t\tfor(int i = 0; i < (int)a.size(); i++)\n\t\t\tfor(int j = 0; j < (int)b.size(); j++)\n\t\t\t\tans[i + j] = (ans[i + j] + a[i] * 1ll * b[j]) % mod;\n\n\t\treturn ans;\n\t}\n\n\tint lg = 0; while((1 << lg) < (int)(a.size() + b.size())) ++lg;\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = B[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = complex_base(a[i], 0);\n\tfor(int i = 0; i < (int)b.size(); i++) B[i] = complex_base(b[i], 0);\n\n\tfft(A, lg); fft(B, lg);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tA[i] = A[i] * B[i];\n\tinv_fft(A, lg);\n\n\tvector<int> ans(a.size() + b.size(), 0);\n\tfor(int i = 0; i < (int)ans.size(); i++)\n\t\tans[i] = (int64_t)(A[i].x + 0.5) % mod;\n\n\treturn ans;\n}\n\nvector<int> mult_mod(const vector<int> &a, const vector<int> &b)\n{\n\t/// Thanks pavel.savchenkov\n\n\t// a = a0 + sqrt(MOD) * a1\n\t// a = a0 + base * a1\n\tint base = (int)sqrtl(mod);\n\n\tvector<int> a0(a.size()), a1(a.size());\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t{\n\t\ta0[i] = a[i] % base;\n\t\ta1[i] = a[i] / base;\n\t}\n\n\tvector<int> b0(b.size()), b1(b.size());\n\tfor(int i = 0; i < (int)b.size(); i++)\n\t{\n\t\tb0[i] = b[i] % base;\n\t\tb1[i] = b[i] / base;\n\t}\n\n\tvector<int> a01 = a0;\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t\taddmod(a01[i], a1[i], mod);  \t\n\n\tvector<int> b01 = b0;\n\tfor(int i = 0; i < (int)b.size(); i++) \n\t\taddmod(b01[i], b1[i], mod);\n\n\tvector<int> C = mult(a01, b01);  // 1\n\n\tvector<int> a0b0 = mult(a0, b0); // 2\n\tvector<int> a1b1 = mult(a1, b1); // 3\n\n\tvector<int> mid = C;\n\tfor(int i = 0; i < (int)mid.size(); i++) \n\t{\n\t\taddmod(mid[i], -a0b0[i] + mod, mod);\n\t\taddmod(mid[i], -a1b1[i] + mod, mod);\n\t}\n\n\tvector<int> res = a0b0;\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, mid[i], mod), mod);\n\n\tbase = mulmod(base, base, mod);\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, a1b1[i], mod), mod);\n\n\treturn res;\n}\n\nint n, m, k;\n\nvoid read()\n{\n\tcin >> n >> m >> k;\n}\n\nvector<int> p1, p2, pw3;\n\nint pw(int x, int p)\n{\n\tint ret = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ret = (ret * 1ll * x) % mod;\n\t\tx = (x * 1ll * x) % mod;\n\t\tp >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint fact[MAXN], inv_fact[MAXN];\nint comb(int n, int k) { if(n < 0 || k < 0 || n < k) return 0; return (((fact[n] * 1ll * inv_fact[n - k]) % mod) * 1ll * inv_fact[k]) % mod; }\n\n/*   SUM C(n + i - 1, i) * C(n + i - 1 + j, j)   */\n/*   SUM C(n + i - 1, i) * fact[n + i - 1 + j] / (fact[j] * fact[n + i - 1])    */\n\n\nvoid solve()\n{\t\n\tpw3.assign(n + m + k + 1, 0);\n\tp1.assign(m + 1, 0);\n\tp2.assign(k + 1, 0);\n\tpw3[0] = 1; for(int i = 1; i <= m + k + n; i++) pw3[i] = (3ll * pw3[i - 1]) % mod;\n\tfact[0] = 1; for(int i = 1; i <= m + k + n; i++) fact[i] = (fact[i - 1] * 1ll * i) % mod;\n\tinv_fact[m + k + n] = pw(fact[m + k + n], mod - 2); for(int i = n + k + m - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * 1ll * (i + 1)) % mod; \n\n\tfor(int i = 0; i <= m; i++) p1[i] = (comb(n + i - 1, i) * 1ll * inv_fact[n + i - 1]) % mod;\n\tfor(int i = 0; i <= k; i++) p2[i] = inv_fact[i];\n\n\tvector<int> ret = mult_mod(p1, p2);\n\t\n\tint answer = 0;\n\tfor(int i = 0; i < (int)ret.size(); i++)\n\t{\n\t\tif(m + k - i < 0) break;\n\n\t\tint curr = (ret[i] * 1ll * pw3[m + k - i]) % mod;\n\t\tcurr = (curr * 1ll * fact[n - 1 + i]) % mod;\n\t\taddmod(answer, curr, mod);\n\t}\n\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define mo 1000000007\n\nusing namespace std;\n\nint fac[900030],inv[900030],Pow3[900030];\n\nint power(int x,int m)\n{\n\tint nowans=1;\n\twhile(m)\n\t{\n\t\tif(m&1)nowans=1ll*nowans*x%mo;\n\t\tx=1ll*x*x%mo;\n\t\tm>>=1;\n\t}\n\treturn nowans;\n}\n\ninline int C(int n,int m)\n{\n\tif(n<m)return 0;\n\treturn (int)(1ll*fac[n]*inv[m]%mo*inv[n-m]%mo);\n}\n\nint main()\n{\n\tint n,m,k,N;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tN=n+m+k;\n\tPow3[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tPow3[i]=3ll*Pow3[i-1]%mo;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%mo;\n\tinv[N]=power(fac[N],mo-2);\n\tfor(int i=N;i;i--)\n\t\tinv[i-1]=1ll*inv[i]*i%mo;\n\tint ans=0,nowans=1;\n\tfor(int l=n+1;l<=N+1;l++)\n\t{\n\t\tans+=1ll*C(l-2,n-1)*nowans%mo*Pow3[N+1-l]%mo;\n\t\tif(ans>=mo)ans-=mo;\n\t\tnowans=nowans*2%mo;\n\t\tnowans-=(C(l-(n+1),m)+C(l-(n+1),k))%mo;\n\t\tif(nowans<0)nowans+=mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef complex<double> CD;\n\n#define REP(i, n) for (int i = 0; i < int(n); ++i)\n#define REPE(i, a, b) for (int i = (a); i <= int(b); ++i)\n#define F first\n#define S second\n\nvoid R(int &x) { scanf(\"%d\", &x); }\nvoid R(LL &x) { scanf(\"%lld\", &x); }\nvoid R(ULL &x) { scanf(\"%llu\", &x); }\nvoid R(double &x) { scanf(\"%lf\", &x); }\nvoid R(LD &x) { scanf(\"%Lf\", &x); }\n\ntemplate <typename T> void R(T &t) { cin >> t; }\ntemplate <typename T> void R(vector<T> &ar) {\n  for (auto &it : ar)\n    R(it);\n}\n\ntemplate <typename T, typename... Args> void R(T &t, Args &... args) {\n  R(t);\n  R(args...);\n}\n\nvoid W(const char &c) { putchar(c); };\nvoid W(const int &x) { printf(\"%d\", x); }\nvoid W(const LL &x) { printf(\"%lld\", x); }\nvoid W(const ULL &x) { printf(\"%llu\", x); }\nvoid W(const double &x) { printf(\"%lf\", x); }\nvoid W(const LD &x) { printf(\"%Lf\", x); }\n\ntemplate <typename T> void W(const T &t) { cout << t; }\ntemplate <typename T> void W(const vector<T> &ar) {\n  for (size_t i = 0; i < ar.size(); ++i) {\n    W(ar[i]);\n    putchar(\" \\n\"[i + 1u == ar.size()]);\n  }\n}\ntemplate <typename T, typename... Args>\nvoid W(const T &t, const Args &... args) {\n  W(t);\n  W(args...);\n}\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int maxn = 1010;\n\nconst LL mod = 1000000000 + 7;\nLL pow_mod(LL a, LL p, const LL m) {\n  LL ret = 1;\n  for (; p; p >>= 1, a = a * a % m)\n    if (p & 1)\n      ret = ret * a % m;\n  return ret % m;\n}\nLL inv(LL a, LL n) {\n  return a < 2 ? a : ((1 - n * 1LL * inv(n % a, a)) / a % n + n) % n;\n}\nLL fac[maxn * 3], rev[maxn * 3];\nLL f(LL t[3]) {\n  LL r = fac[t[0] + t[1] + t[2]];\n  REP(i, 3) r = r * rev[t[i]] % mod;\n  return r;\n}\nint n, m, k;\nint main() {\n  fac[0] = rev[0] = 1;\n  for (int i = 1; i < maxn * 3; ++i) {\n    fac[i] = fac[i - 1] * i % mod;\n    rev[i] = rev[i - 1] * inv(i, mod) % mod;\n    assert(1LL * fac[i] * rev[i] % mod == 1);\n  }\n  R(n, m, k);\n  LL ans = 0;\n  REPE(i, 0, m) REPE(j, 0, k) {\n    LL a[] = {n - 1, i, j};\n    LL t = f(a);\n    t = t * pow_mod(3, m - i, mod) % mod;\n    t = t * pow_mod(3, k - j, mod) % mod;\n    ans = (ans + t) % mod;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdio>\n\nconst int N = 300000;\nconst int MOD = (int)1e9 + 7;\n\nint inv[N + N + 1], a, b, c, bn_b[N], bn_c[N];\n\nvoid update(int& x, int a)\n{\n    x += a;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nvoid prepare(int* bn, int a, int b) // bn[i] = binom{i + b}{b} 0 <= i < a\n{\n    bn[0] = 1;\n    for (int i = 1; i < a; ++ i) {\n        bn[i] = 1LL * bn[i - 1] * (i + b) % MOD * inv[i] % MOD;\n    }\n}\n\nint binom[1000][1000];\n\nint main()\n{\n// #ifdef LOCAL_JUDGE\n//     freopen(\"F.in\", \"r\", stdin);\n// #endif\n    inv[1] = 1;\n    for (int i = 2; i <= N + N; ++ i) {\n        inv[i] = 1LL * (MOD - MOD / i) * inv[MOD % i] % MOD;\n    }\n    while (scanf(\"%d%d%d\", &a, &b, &c) == 3) {\n        a --;\n        prepare(bn_b, b, c);\n        prepare(bn_c, c, b);\n        int three = 1;\n        for (int i = 0; i < b + c; ++ i) {\n            three = 3LL * three % MOD;\n        }\n        int bn_a = 1;\n        int ds = 1;\n        int result = three;\n        for (int s = 1; s <= b + c; ++ s) {\n            three = 1LL * three * inv[3] % MOD;\n            bn_a = 1LL * bn_a * (s + a) % MOD * inv[s] % MOD;\n            ds = 2LL * ds % MOD;\n            if (s > b) {\n                update(ds, MOD - bn_c[s - b - 1]);\n            }\n            if (s > c) {\n                update(ds, MOD - bn_b[s - c - 1]);\n            }\n            update(result, 1LL * bn_a * ds % MOD * three % MOD);\n        }\n        printf(\"%d\\n\", result);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\nint mod = 1e9+7;\n\nclass FermatCombination{\nprivate:\n\tvector<int> fac, inv;\n\tint Pow(int x, int n){\n\t\tif(n < 0)n += mod-1;\n\t\tint ans = 1;\n\t\twhile(n > 0){\n\t\t\tif(n & 1)ans = (ans*x)%mod;\n\t\t\tx = (x*x)%mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Factrial(int n){\n\t\tfac[0] = inv[0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfac[i] = (fac[i-1]*i)%mod;\n\t\t\tinv[i] = Pow(fac[i], mod-2);\n\t\t}\n\t}\n\t\npublic:\n\tvoid init(int n){\t//nCk\n\t\tfac.resize(n+1);\n\t\tinv.resize(n+1);\n\t\tFactrial(n);\n\t}\n\tint comb(int n, int k){\n\t\tif(n < k)return 0;\n\t\tif(k == 0)return 1;\n\t\tint tmp = (fac[n]*inv[k])%mod;\n\t\treturn (tmp*inv[n-k])%mod;\n\t}\n};\n\nFermatCombination F;\nint nCr(int n, int k){\n\treturn F.comb(n, k);\n}\n\nint pow_(int x, int n){\n\tif(n < 0)n += mod-1;\n\tint ans = 1;\n\twhile(n > 0){\n\t\tif(n & 1)ans = (ans*x)%mod;\n\t\tx = (x*x)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n\nint pas[1000000];\nsigned main(){\n\tint n, m, k;\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tF.init(n+m+k+1);\n\t\n\tint ans = 0;\n\tpas[0] = 1;\n\trrep(i,m+k){\n\t\tpas[i] = (pas[i-1]*2)%mod;\n\t\tif(i > m)pas[i] = ((pas[i]+mod)-nCr(i-1, m))%mod;\n\t\tif(i > k)pas[i] = ((pas[i]+mod)-nCr(i-1, i-(k+1)))%mod;\n\t}\n\t\n\trrep(i,n+m+k){\n\t\tif(i < n)continue;\n\t\tans += (((nCr(i-1, n-1)*pow_(3, n+m+k-i))%mod)*pas[i-n])%mod;\n\t\tans %= mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int p=1000000000+7;\nconst int maxn=100000*3+5;\nll n,m,k;\nll p1[maxn*4],p2[maxn*4];\nll f[maxn*4];//有x个空格，不大于m k个b c 填空种类数\nll pw3[maxn*4];\nll pw(ll x,ll y){\n\tll ans=1;\n\twhile ((bool)y){\n\t\tif ((bool)(y&1)){\n\t\t\tans=ans*x%p;\n\t\t}\n\t\tx=x*x%p;\n\t\ty=y>>1;\n\t}\n\treturn ans;\n}\nll c(ll x,ll y){\n\tif ((x<y)||(y<0))return 0;\n\treturn p1[x]*p2[y]%p*p2[x-y]%p;\n}\nvoid solve(){\n\tll b1,b2,b3,b4;\n\tll ans;\n\tscanf(\"%lld%lld%lld\",&n,&m,&k);\n\tf[0]=1;\n\tif (m>k) swap(m,k);\n\tfor (b1=1;b1<=m+k+n;b1++){\n\t\tf[b1]=(f[b1-1]*2-(c(b1-1,m)+c(b1-1,k))%p+p)%p;\n\t}\n\tans=0;\n\tfor (b1=n;b1<=n+m+k;b1++){\n\t\tans=(ans+f[b1-n]*c(b1-1,n-1)%p*pw3[n+m+k-b1]%p)%p;\n\t\t//printf(\"%lld\\n\",f[b1-n]*c(b1-1,n-1)*pw3[n+m+k-b1]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\t\n\t\n\t//printf(\"%lld\",f[m+k]-c(m+k,k));\n}\nint main(){\n\tll b1,b2,b3,b4;\n\tp1[0]=1;\n\tfor (b1=1;b1<maxn*3;b1++){\n\t\tp1[b1]=p1[b1-1]*b1%p;\n\t}\n\tp2[maxn*3-1]=pw(p1[maxn*3-1],p-2);\n\tfor (b1=maxn*3-1;b1>=1;b1--){\n\t\tp2[b1-1]=p2[b1]*b1%p;\n\t}\n\tpw3[0]=1;\n\tfor (b1=1;b1<maxn*3;b1++){\n\t\tpw3[b1]=pw3[b1-1]*3%p;\n\t}\n\tsolve();\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MMOD 998244353\n#define MAX 2010101\nusing namespace std;\nusing Edge=pair<ll,ll>;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n// fac[i] i!\n// finv[i] i!の逆元\n// inv[i] iの逆元\n\n// テーブルを作る前処理\nvoid COM_init(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N,M,K,ans=0;\n  cin>>N>>M>>K;\n  COM_init();\n  \n  ll POW3[1000001];\n  POW3[0]=1;\n  RREP(i,1000000) POW3[i]=POW3[i-1]*3%MOD;\n  \n  ll C=1,L=0,R=0;\n  for(ll i=N; i<=N+M+K; ++i){\n    ll cnt=POW3[N+M+K-i]*COM(i-1,N-1)%MOD,ccnt=0;\n    \n    if(i==N+M+1) L=1;\n    if(i>N+M+1)  L=(L*2+COM(i-N-1,i-N-M-1))%MOD;\n    if(i==N+K+1) R=1;\n    if(i>N+K+1)  R=(R*2+COM(i-N-1,i-N-K-1))%MOD;\n    \n    ans+=cnt*(C-L-R)%MOD;\n    ans%=MOD;\n    C=C*2%MOD;\n  }\n  \n  ans=(ans%MOD+MOD)%MOD;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(auto i##0_to = (t), i = decltype(t)(f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(auto i##0_to = (t), i = decltype(t)(f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(auto i##0_to = decltype(f)(t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(auto i##0_to = decltype(f)(t), i = (f); i >  i##0_to; i--)\n/** types **/\n\tusing LD = long double;\n\t#define double LD\n\t#define long long long\n\t#define LL long\n\t#define int long\n\ttemplate<class T> using vec = vector<T>;\n\tusing VB = vec<bool>;\tusing WB = vec<VB>;\n\tusing VC = vec<char>;\tusing WC = vec<VC>;\n\tusing VI = vec<int>;\tusing WI = vec<VI>;\n\tusing VD = vec<double>;\tusing WD = vec<VD>;\n\tusing VS = vec<string>;\tusing WS = vec<VS>;\n\tusing PI = pair<int, int>;\tusing VPI = vec<PI>; using WPI = vec<VPI>;\n\tusing MI = map<int, int>;\tusing VMI = vec<MI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define DD(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define DDD(x) if(debug) cerr << #x << \" = \" << (x) ln\n#define db dd\n#define dbg ddd\n\nvoid settings();\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n\t#ifdef EBUG\n\t\tdebug = true;\n\t#elif defined(ONLINE_JUDGE)\n\t\tdebug = false;\n\t#else\n\t\tdebug = argc >= 2;\n\t#endif\n\tif(!debug) {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n\tcout << fixed << setprecision(20);\n\tcerr << fixed << setprecision(20);\n\n\tsettings();\n\tsolve();\n\n\treturn 0;\n}\n\n/******************************* basic library ********************************/\n/** structure **/\n\ttemplate<class T> struct Graph { bool directed = false; int nv = -1; int ne = -1; vec<map<int,T>> e;\n\t\tGraph<T> rev() { if(not directed) return *this; Graph<T> g = *this; for(auto& ei : g.e) ei.clear(); times(nv, i) for(auto& p : e[i]) g.e[p.first][i] = p.second; return g; }\n\t};\n\tusing GraphI = Graph<int>;\n/** IO **/\n\ttemplate<class T> inline istream& operator>>(istream& s, vec<T>& v) { for(auto&& p : v) s >> p; return s; }\n\tint INPUT_GRAPH_index_sub = 1, INPUT_GRAPH_cost = 0; bool INPUT_GRAPH_allow_empty = false;\n\ttemplate<class T> inline istream& operator>>(istream& s, Graph<T>& g) {\n\t\tconst int sub = INPUT_GRAPH_index_sub, cost = INPUT_GRAPH_cost, emptyp = INPUT_GRAPH_allow_empty;\n\t\tif(g.nv + emptyp <= 0 and g.ne + emptyp <= 0) { s >> g.nv >> g.ne; } g.e = VMI(g.nv);\n\t\ttimes(g.ne, i) { int x, y; T d = cost; s >> x >> y; if(!d) s >> d; g.e[x - sub][y - sub] = d; if(not g.directed) g.e[y - sub][x - sub] = d; } return s;\n\t}\n\ttemplate<class T, class S> inline ostream& operator<<(ostream&, const pair<T, S>&);\n\ttemplate<class T>          inline ostream& operator<<(ostream&, const vec<T>&);\n\ttemplate<class T, class S> inline ostream& operator<<(ostream&, const map<T, S>&);\n\ttemplate<class T> inline ostream& operator<<(ostream&, const Graph<T>&);\n\t#define DEFINE_ITER_OUTPUT(s, x, sep) { int i = 0; for(const auto& x##0_elem : x) { if(i++) s << sep; s << x##0_elem; } return s; }\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const pair<T, S>& p) { return s << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ttemplate<class T>          inline ostream& operator<<(ostream& s, const vec<T>& v) DEFINE_ITER_OUTPUT(s, v, ' ')\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const map<T, S>& m) DEFINE_ITER_OUTPUT(s, m, ' ')\n\ttemplate<class T>          inline ostream& operator<<(ostream& s, const vec<vec<T>>& w) DEFINE_ITER_OUTPUT(s, w, '\\n')\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const vec<map<T, S>>& vm) DEFINE_ITER_OUTPUT(s, vm, '\\n')\n\ttemplate<class T> inline ostream& operator<<(ostream& s, const Graph<T>& g) { return s << \"Graph(nv:\" << g.nv << \" ne:\" << g.ne << \" e:[\" ln << g.e ln << \"])\"; }\n\tinline void RD() {}\n\ttemplate<class T, class...S> inline T& RD(T& t, S&... s) { cin >> t; RD(s...); return t; } /* returns first side */\n\ttemplate<class T, class...S> inline vec<T>& RD(vec<T>& t, vec<S>&... s) { times(t.size(), i) { RD(t[i], s[i]...); } return t; }\n\t#define RR(typ, ...) typ __VA_ARGS__; RD(__VA_ARGS__)\n\ttemplate<class T, class...A> inline T READ(A... a) { T t(a...); cin >> t; return t; }\n\ttemplate<class T> inline void dddf(const T& t) { if(debug) cerr << t ln; }\n\ttemplate<class T, class...U> inline void dddf(const T& t, const U&... u) { if(debug) { cerr << t << \", \"; dddf(u...); }}\n\t#define ddd(...) if(debug) { cerr << #__VA_ARGS__ << \" = \"; dddf(__VA_ARGS__); }\n/** container **/\n\t#define all(v) begin(v), end(v)\n\ttemplate<class T> inline T max(const pair<T, T>& p) { return max(p.first, p.second); }\n\ttemplate<class T> inline T min(const pair<T, T>& p) { return min(p.first, p.second); }\n\ttemplate<class T> inline T max(const vec<T>& v) { return *max_element(all(v)); }\n\ttemplate<class T> inline T min(const vec<T>& v) { return *min_element(all(v)); }\n\ttemplate<class T> inline T sum(const vec<T>& v) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) s += v[i]; return s; }\n\ttemplate<class T> inline T sum(const vec<T>& v, int mod) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) (s += v[i]) %= mod; return s; }\n\ttemplate<class T, class U> inline T dig(const U& d, const T& t) { return t; }\n\ttemplate<class T, class U, class...I> inline U dig(const U& d, const T& t, int i, I... j) {\n\t\treturn 0 <= i && i < t.size() ? dig(d, t[i], j...) : d; }\n\t#define first_itr_st_val_ge_ lower_bound\n\t#define first_itr_st_val_gt_ upper_bound\n/** other **/\n\ttemplate<class T> inline signed SIZE(const T& t) { return t.size(); }\n\t#define size SIZE\n\t#define MP make_pair\n\t#define MT make_tuple\n\t#define PB push_back\n\t#define b_max(x, y) x = max(x, y)\n\t#define b_min(x, y) x = min(x, y)\n\tinline LD AC(LD d) { return d ? d : 0; }\n[[maybe_unused]] constexpr long INF = 1LL << 60;\n[[maybe_unused]] constexpr long MOD = 1000000007; // 1000000009; // 998244353;\n\n/****************************** optional library ******************************/\n/* <sr.m.nck> */\n\t/* <sr.m.fact> */\n\t\t/* <sr.m.pow> */\n\t\t\t// NOT_VERIFIED\n\t\t\t// ref: ari-114\n\t\t\t// O(log b)\n\t\t\tinline int mpow(int a, int b, int mod=MOD) {\n\t\t\t\tint ans = 1;\n\t\t\t\tfor(; b; b >>= 1, (a *= a) %= mod) if(b & 1) (ans *= a) %= mod;\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t/* </sr.m.pow> */\n\t\t// NOT_VERIFIED\n\t\t// ref: twitter.com/meguru_comp/status/694207919517077504\n\t\t// O(N + log mod)\n\t\tint *fact, *factInv;\n\t\tvoid factInit(int N, int mod=MOD) {\n\t\t\tfact = new int[N]; factInv = new int[N];\n\t\t\tfact[0] = 1;\n\t\t\tupto(1,N,i) fact[i] = fact[i-1] * i % mod;\n\t\t\tfactInv[N] = mpow(fact[N], mod-2, mod);\n\t\t\trtimes(N,i) factInv[i] = factInv[i+1] * (i+1) % mod;\n\t\t}\n\t/* </sr.m.fact> */\n\t// NOT_VERIFIED\n\t// O(1), before:O(N)\n\tinline int nCk(int n, int k, int mod=MOD) {\n\t\tif(!fact) { cerr << \"factInit before nCk.\\n\"; return -1; }\n\t\treturn fact[n] * factInv[k] % mod * factInv[n-k] % mod;\n\t}\n/* </sr.m.nck> */\n\n/************************************ main ************************************/\n\nvoid settings() {\n\t// INPUT_GRAPH_index_sub = 0;\t\t// uncomment if input index is 0-based\n\t// INPUT_GRAPH_allow_empty = true;\t// uncomment to allow empty graph\n\t// INPUT_GRAPH_cost = 1;\t\t\t// uncomment if all input costs are 1\n}\n\nvoid solve() {\n// NMK\n/* <foxy.memo-area> */\nint N;int M;int K;cin>>N;cin>>M;cin>>K;\n/* </foxy.memo-area> */\n\n\tfactInit(N + M + K + 486);\n\tint ans = 0;\n\tupto(N, N + M + K, x) {\n\t\tint s = 0;\n\t\tupto(max(0ll, x - N - K), min(M, x - N), p) {\n\t\t\t(s += nCk(x - N, p)) %= MOD;\n\t\t}\n\t\t(ans += nCk(x - 1, N - 1) * s % MOD * mpow(3, N + M + K - x)) %= MOD;\n\t}\n\tcout << ans % MOD ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#pragma GCC optimize(\"Ofast,unroll-loops\")\n//#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace IntModulo\n{\n\tconst int mod = 1e9 + 7;\n\n\tinline int add(int x, int y, int m = mod)\n\t{\n\t\tif (x + y < m)\n\t\t\treturn x + y;\n\t\treturn x + y - m;\n\t}\n\n\tinline int sub(int x, int y, int m = mod)\n\t{\n\t\tif (x >= y)\n\t\t\treturn x - y;\n\t\treturn x - y + m;\n\t}\n\n\tinline int mult(int x, int y, int m = mod)\n\t{\n\t\treturn x * (LL) y % m;\n\t}\n\n\tinline int power(int x, int y, int m = mod)\n\t{\n\t\tint r = 1;\n\t\twhile(y)\n\t\t{\n\t\t\tif (y & 1)\n\t\t\t\tr = mult(r, x, m);\n\t\t\tx = mult(x, x, m);\n\t\t\ty >>= 1;\n\t\t}\n\t\t\n\t\treturn r;\n\t}\n\t\n\tinline int inverse(int x, int m = mod)\n\t{\n\t\treturn power(x, m - 2, m);\n\t}\n\t\n\tinline void ADD(int& x, int y, int m = mod)\n\t{\n\t\tx += y;\n\t\tif (x >= m) x -= m;\n\t}\n\t\n\tinline void SUB(int& x, int y, int m = mod)\n\t{\n\t\tx -= y;\n\t\tif (x < 0) x += m;\n\t}\n\t\n\tinline void MULT(int& x, int y, int m = mod)\n\t{\n\t\tx = (x * (LL) y) % m;\n\t}\n};\n\nnamespace Combinatorics\n{\n\tusing namespace IntModulo;\n\t\n\tconst int N = 1 << 19;\n\tint fact[N];\n\tint inv[N];\n\tint invFact[N];\n\tbool inited = false;\n\t\n\tinline int C(int n, int k) // binomial C(n, k)\n\t{\n\t\treturn n < k ? 0 : mult(fact[n], mult(invFact[k], invFact[n - k]));\n\t}\n\t\n\tinline int H(int n, int k) // number of solution x1 + .. + xn = k\n\t{\n\t\treturn C(n + k - 1, k);\n\t}\n\t\n\tvoid init()\n\t{\n\t\tdebug(Combinatorics::N);\n\t\tinited = true;\n\t\tinv[1] = 1;\n\t\tFOR(i, 2, N)\n\t\t\tinv[i] = mult(mod - mod / i, inv[mod % i]);\n\t\t\n\t\tinvFact[0] = fact[0] = 1;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tfact[i] = mult(i, fact[i - 1]);\n\t\t\tinvFact[i] = mult(invFact[i - 1], inv[i]);\n\t\t}\n\t}\t\n};\n\nusing namespace Combinatorics;\nconst int M = 1 << 20;\n__int128 a[M], b[M], c[M];\n\nnamespace Karatsuba\n{\n\t#pragma GCC optimize(\"Ofast,unroll-loops\")\n\t#pragma GCC target(\"avx,avx2,fma\")\n\n\ttemplate<int n, typename T>\n\tvoid mult(const T* __restrict A, const T* __restrict B, T* __restrict C)\n\t{\n\t\tif (n <= 64)\n\t\t{\n\t\t\tFOR(i, 0, n) FOR(j, 0, n) C[i + j] += A[i] * B[j];\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tconst int m = n >> 1;\n\t\tmult<m>(A + 0, B + 0, C);\n\t\tmult<m>(A + m, B + m, C + n);\n\t\t\n\t\talignas(64) T a[n], b[n], e[n] = {};\n\t\tFOR(i, 0, m) \n\t\t{\n\t\t\ta[i] = A[i] + A[i + m];\n\t\t\tb[i] = B[i] + B[i + m];\n\t\t}\n\t\t\n\t\tmult<m>(a, b, e);\n\t\tFOR(i, 0, m)\n\t\t{\n\t\t\tconst T tut = C[i + m];\n\t\t\tC[i + m] += e[i] - C[i] - C[i + m * 2];\n\t\t\tC[i + m * 2] += e[i + m] - tut - C[i + m * 3];\n\t\t}\n\t}\n};\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tCombinatorics::init();\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tn--;\n\tint ans = 0;\n\tFOR(i, 0, m + 1) a[i] = invFact[i];\n\tFOR(i, 0, k + 1) b[i] = invFact[i];\n\tKaratsuba::mult<(1 << 16)>(a, b, c);\n\t\t\n\tFOR(t, 0, m + k + 1)\t\t\n\t\tADD(ans, mult(fact[t], mult(c[t] % mod, mult(C(n + t, t), power(3, m + k - t)))));\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 300010;\nconst int mod = 1000000007;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint remod(LL x) { x %= mod; return x + (x >> 63 & mod); }\nconst int MAXS = 1000010;\nint fac[MAXS], inv[MAXS];\nint n, m, K;\nint C(int a, int b) { return a < b ? 0 :(LL) fac[a] * inv[b] % mod * inv[a - b] % mod; }\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tfac[0] = fac[1] = inv[0] = inv[1] = 1;\n\tfor (int i = 2; i != MAXS; ++i) {\n\t\tfac[i] = mul(fac[i - 1], i);\n\t\tinv[i] = mul(inv[mod % i], mod - mod / i);\n\t}\n\tfor (int i = 2; i != MAXS; ++i) inv[i] = mul(inv[i - 1], inv[i]);\n\tstd::cin >> n >> m >> K;\n\tint ans = 0, now = 0;\n\tfor (int i = 0; i <= m + K; ++i) {\n\t\treduce(now += now - mod);\n\t\tif (i) reduce(now -= C(i - 1, std::min(i - 1, m)));\n\t\tif (i > K) reduce(now -= C(i - 1, i - K - 1));\n\t\tif (i <= m) reduce(now += 1 - mod);\n\t\treduce(ans += pow(3, m + K - i, mul(C(i + n - 1, n - 1), now)) - mod);\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e7+5;\ntypedef long long LL;\nconst LL mo=1e9+7;\nLL fac[maxn],inv[maxn];\nLL C(int n,int m){\n\tif(n<m)return 0;\n\treturn fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nLL pw(LL x,LL k,LL p=::mo){\n\tLL ans=1;\n\tfor(;k;k>>=1){\n\t\tif(k&1)ans=ans*x%mo;\n\t\tx=x*x%mo;\n\t}\n\treturn ans;\n}\nint main(){\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<maxn;i++){\n\t\tfac[i]=fac[i-1]*i%mo;\n\t}\n\tfor(int i=2;i<maxn;i++){\n\t\tinv[i]=(mo-mo/i)*inv[mo%i]%mo;\n\t}\n\tfor(int i=2;i<maxn;i++){\n\t\tinv[i]=inv[i-1]*inv[i]%mo;\n\t}\n\n\tLL ans=0;\n\n\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tif(m>k)swap(m,k);\n\n\n//\tlong long ans=0;\n/*\tfor(int i=0;i<=m;i++)\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tans+=C(n+i+j-1,n-1)*C(i+j,i)*pw(3,m+k-i-j);\n\t\t}\n\tcout<<ans<<endl;\n\n\tfor(int i=0;i<=m+k;i++)\n\t\tfor(int j=0;j<=k&&j<=m;j++){\n\t\t\tans+=C(n+i-1,n-1)*C(i,j)*pw(3,m+k-i);\n\t\t}\n\tcout<<ansi<<endl;\n\treturn 0;*/\n\tLL cur=1;\n\tfor(int p=0;p<=m+k;p++){\n\t\tLL res=0;\n\t\t\n\t\tres=C(n+p-1,n-1)*pw(3,m+k-p)%mo;\n\n\t\tans+=res*cur%mo;\n\t\tans%=mo;\n\n\t\tcur=cur*2%mo;\n\t\tif(p>=m){\n\t\t\tcur-=C(p,m);\n\t\t\tcur+=mo;cur%=mo;\n\t\t}\n\t\tif(p>=k){\n\t\t\tcur-=C(p,p-k);\n\t\t\tcur+=mo;cur%=mo;\n\t\t}\n\n\n\t}\n\n\tcout<<ans<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nint pow3[600005];\nint fact[900005];\nint invf[900005];\nint Power(int x, int y)\n{\n\tint re = 1;\n\twhile(y)\n\t{\n\t\tif(y & 1)\n\t\t{\n\t\t\tre = 1ll * re * x % MOD;\n\t\t}\n\t\tx = 1ll * x * x % MOD;\n\t\ty >>= 1;\n\t}\n\treturn re;\n}\nint C(int n, int m)\n{\n\tif(m < 0)\n\t{\n\t\treturn 0;\n\t}\n\tif(n < m)\n\t{\n\t\treturn 0;\n\t}\n\treturn 1ll * fact[n] * invf[m] % MOD * invf[n - m] % MOD;\n}\nint n, m, k;\n\nint main()\n{\n\tfact[0] = 1;\n\tfor(int i = 1; i <= 900000; i++)\n\t{\n\t\tfact[i] = 1ll * fact[i - 1] * i % MOD;\n\t}\n\tinvf[900000] = Power(fact[900000], MOD - 2);\n\tfor(int i = 900000; i; i--)\n\t{\n\t\tinvf[i - 1] = 1ll * invf[i] * i % MOD;\n\t}\n\tpow3[0] = 1;\n\tfor(int i = 1; i <= 600000; i++)\n\t{\n\t\tpow3[i] = 3ll * pow3[i - 1] % MOD;\n\t}\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tint ans = 0;\n\tint t = 1;\n\tfor(int i = 0; i <= m + k; i++)\n\t{\n\t\tint tmp = 1ll * C(n - 1 + i, n - 1) * t % MOD;\n\t\ttmp = 1ll * tmp * pow3[m + k - i] % MOD;\n\t\tans = (ans + tmp) % MOD;\n\t\tt = ((2ll * t + MOD - C(i, m)) % MOD + MOD - C(i, i - k)) % MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\n#define N 5000010\n#define inf 0x3f3f3f3f\n\nint head[ N ] , cnt ;\nint d[ N ] , vis[ N ] , q[ N ] ;\nint n , m ;\nstruct node {\n\tint to , nxt , v ;\n}e[ N ] ; \n\nvoid ins( int u , int v , int w ) {\n\te[ ++ cnt ].to = v ;\n\te[ cnt ].nxt = head[ u ] ;\n\te[ cnt ].v = w ;\n\thead[ u ] = cnt ;\n} \n\nmap<pair<int,int>,int>mp;\n\nint tot = 0 ;\n\nint get_num( int x , int y ) {\n\tif( !mp.count( make_pair( x , y ) ) ) mp[ make_pair( x , y ) ] = ++tot ;\n\treturn mp[ make_pair( x , y ) ] ;\n}\n\nvoid spfa() {\n\tfor( int i = 1 ; i <= tot ; i ++ ) d[ i ] = inf ;\n\tvis[ 1 ] = q[ 1 ] = 1 ;\n\td[ 1 ] = 0 ;\n\tint l = 1 , r = 2 ;\n\twhile( l < r ) {\n\t\tint u = q[ l ++ ] ;\n\t\tvis[ u ] = 0 ;\n\t\tfor( int i = head[ u ] ; i ; i = e[ i ].nxt ) {\n\t\t\tint v = e[ i ].to ;\n\t\t\tif( d[ v ] > d[ u ] + e[ i ].v ) {\n\t\t\t\td[ v ] = d[ u ] + e[ i ].v ;\n\t\t\t\tif( !vis[ v ] ) vis[ v ] = 1 , q[ r ++ ] = v ;\n\t\t\t}\n\t\t}\n\t}\n\tif( d[ n ] == inf ) puts( \"-1\" ) ;\n\telse printf( \"%d\\n\" , d[ n ] / 2 ) ;\n}\n\nint main() {\n\tscanf( \"%d%d\" , &n , &m ) ;\n\ttot = n ;\n\tfor( int i = 1 ; i <= m ; i ++ ) {\n\t\tint x , y , c ;\n\t\tscanf( \"%d%d%d\" , &x , &y , &c ) ;\n\t\tint n1 = get_num( x , c ) , n2 = get_num( y , c ) ;\n\t\tins( x , n1 , 1 ) ;\n\t\tins( n1 , x , 1 ) ;\n\t\tins( n1 , y , 1 ) ;\n\t\tins( y , n1 , 1 ) ;\n\t\tins( n1 , n2 , 0 ) ;\n\t\tins( n2 , n1 , 0 ) ;\n\t}\n\tspfa() ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\nconst int mod = 1e9 + 7;\nconst int MX = 610000;\nll inv[MX], f[MX], invf[MX], pw[MX];\nvoid calc(){\n\tpw[0] = 1;\n\trep(i, MX - 1) pw[i + 1] = pw[i] * 3 % mod;\n\tinv[0] = inv[1] = f[0] = f[1] = invf[0] = invf[1] = 1;\n\tfor (int i = 2; i < MX; i++){\n\t\tinv[i] = mod - mod / i * inv[mod % i] % mod;\n\t\tf[i] = f[i - 1] * i % mod;\n\t\tinvf[i] = invf[i - 1] * inv[i] % mod;\n\t}\n}\ninline ll C(ll n, ll k){\n\tif(k < 0 || k > n) return 0;\n\tassert(n < MX && k < MX);\n\treturn f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint main(){\n\tcalc();\n\tint a, b, c; cin >> a >> b >> c;\n\tll ans = 0;\n\tll sum = 1; int L = 0, R = 0;\n\trep(i, b + c + 1){\n\t\t/*\n\t\tll s = 0;\n\t\tfor(int j = max(0, i - c); j <= min(b, i); j++) s += C(i, j);\n\t\t*/\n\t\tif(i) sum *= 2;\n\t\tint l = max(0, i - c), r = min(b, i);\n\t\tsum += C(i - 1, L - 1);\n\t\tsum += mod - C(i - 1, R);\n\t\t\n\t\tif(l > L) sum += mod - C(i, L);\n\t\tif(r > R) sum += C(i, r);\n\t\t\n\t\tassert(l == L || L + 1 == l);\n\t\tassert(r == R || R + 1 == r);\n\t\t//dbg(l, r, L, R, sum, s); assert(s % mod == sum % mod);\n\t\t\n\t\tL = l; R = r;\n\t\tsum %= mod;\n\t\tans += sum * C(i + a - 1, i) % mod * pw[b + c - i] % mod;\n\t}\n\tcout << ans % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble PI=3.141592653589793;\n\ncomplex <double> dftn[1100007];\ncomplex <double> dfts[1100007];\n\ncomplex <double> a1[1100007];\ncomplex <double> b1[1100007];\ncomplex <double> a2[1100007];\ncomplex <double> b2[1100007];\n\ndouble cosi[1100007];\ncomplex <double> omega[1100007];\n\ninline int potenga(int v)\n{\n    for (int i=1; 1; i<<=1)\n    {\n        if (i>=v)\n        {\n            return i;\n        }\n    }\n}\n\ninline void dft(int n, int kier)\n{\n    int n2=n-1;\n    int s=0;\n    int p;\n    int g;\n\n    for (int i=2; i<=n; i<<=1)\n    {\n\n        for (int j=0; j<n; j++)\n        {\n            dfts[j]=dftn[j];\n            dftn[j]=0;\n        }\n\n        p=n/i;\n\n        if (kier)\n        {\n            g=0;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=j+1;\n                    s=0;\n                }\n            }\n        }\n        else\n        {\n            g=n;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=n-j-1;\n                    s=0;\n                }\n            }\n        }\n    }\n}\n\nvoid licz_omegi(int n1)\n{\n    double kat=2.0*PI/n1;\n    int n2=n1-1;\n    int dod=3*n1/4;\n\n    for (int i=0; i<=n1; i++)\n    cosi[i]=cos(kat*i);\n    for (int i=0; i<=n1; i++)\n    omega[i]=complex <double> (cosi[i], cosi[(i+dod)&n2]);\n}\n\nvector <long long> fft_dokladne(vector <long long> &jed, vector <long long> &dwa)\n{\n    int n1=potenga(jed.size()+dwa.size());\n\n    licz_omegi(n1);\n\n    long long M=32000;\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]/M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a1[i]=dftn[i];\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]%M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b1[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]/M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a2[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]%M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b2[i]=dftn[i];\n\n    vector <long long> ret;\n    for (int i=0; i<n1; i++)\n    ret.push_back(0);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=(llround(dftn[i].real()/n1)%1000000007)*M*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*b2[i]+b1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1)*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=b1[i]*b2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1);\n\n    for (int i=0; i<ret.size(); i++)\n        ret[i]%=1000000007;\n\n    return ret;\n}\n\nint n, m, k;\n\nint s;\n\nlong long mod=1000000007;\n\nlong long sil[1000007];\nlong long odw[1000007];\n\nvector <long long> d1, d2, d3;\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n    long long wyk=mod-2;\n    while(wyk)\n    {\n        if (wyk&1)\n        {\n            a*=b;\n            a%=mod;\n        }\n        b*=b;\n        b%=mod;\n        wyk>>=1;\n    }\n    return a;\n}\n\ninline long long komb(int a, int b)\n{\n    if (b<0 || b>a)\n        return 0;\n    return (sil[a]*((odw[b]*odw[a-b])%mod))%mod;\n}\n\ninline long long komz(int a, int b)\n{\n    return komb(a+b-1, b);\n}\n\nint main()\n{\n    //n=300000;\n    //m=300000;\n    //k=300000;\n    scanf(\"%d%d%d\", &n, &m, &k);\n    s=n+m+k;\n    sil[0]=1;\n    odw[0]=1;\n    for (int i=1; i<=s; i++)\n        sil[i]=(sil[i-1]*i)%mod;\n    odw[s]=dziel(1, sil[s]);\n    for (int i=s-1; i; i--)\n        odw[i]=(odw[i+1]*(i+1))%mod;\n    for (int i=0; i<=m; i++)\n        d1.push_back((komz(n, i)*odw[n+i-1])%mod);\n    for (int i=0; i<=k; i++)\n        d2.push_back(odw[i]);\n    d3=fft_dokladne(d1, d2);\n    for (int i=0; i<=m+k; i++)\n    {\n        wyn*=3;\n        wyn+=d3[i]*sil[n+i-1];\n        wyn%=mod;\n    }\n    printf(\"%lld\\n\", wyn%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define N 555555\n#define M 1000000007\nint A,B,C,S,i;LL w,an,pw[N],I[N];\nLL Pw(LL a,LL b,LL p){\n\tLL v=1;\n\tfor(;b;b>>=1,a=a*a%p)if(b&1)v=v*a%p;\n\treturn v;\n}\nLL Ce(int x,int y){\n\treturn pw[y]*I[x]%M*I[y-x]%M;\n}\nint main(){\n\tscanf(\"%d%d%d\",&A,&B,&C);\n\tS=A+B+C;\n\tfor(pw[0]=i=1;i<=S;i++)pw[i]=1ll*i*pw[i-1];\n\tI[S]=Pw(pw[S],M-2,M);\n\tfor(i=S;i;i--)I[i-1]=1ll*i*I[i]%M;w=1;\n\tfor(i=A;i<=S;i++){\n\t\tan=(an+Ce(A-1,i-1)*w%M*Pw(3,S-i,M))%M;\n\t\tw=(w+w)%M;\n\t\tif(i>=A+B)w=(w-Ce(B,i-A)+M)%M;\n\t\tif(i>=A+C)w=(w-Ce(i-A-C,i-A)+M)%M;\n\t}\n\tprintf(\"%lld\",an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct Combination {\n  int mod;\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod) {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nconst int mod = 1e9 + 7;\n\n\nint main() {\n  int N, M, K;\n  cin >> N >> M >> K;\n  \n  Combination beet(1010101, mod);\n  int64 pow3[1010101];\n  pow3[0] = 1;\n  for(int i = 1; i < 1010101; i++) pow3[i] = pow3[i - 1] * 3 % mod;\n\n  pair< int, int > ask[2][1010101];\n\n  auto get = [&](int x, int y, bool t) {\n    if(x == 0) {\n      int64 ret = 0;\n      for(int j = 0; j <= y; j++) {\n        ret += beet.C(x, j);\n        ret %= mod;\n      }\n      ask[t][x] = {y, ret};\n      return ret;\n    } else {\n      int64 ret = ask[t][x - 1].second * 2 % mod;\n      ret += mod - beet.C(x - 1, ask[t][x - 1].first);\n      ret %= mod;\n      while(y < ask[t][x - 1].first) {\n        ret += mod - beet.C(x, ask[t][x - 1].first);\n        ret %= mod;\n        --ask[t][x - 1].first;\n      }\n      while(ask[t][x - 1].first < y) {\n        ++ask[t][x - 1].first;\n        ret += beet.C(x, ask[t][x - 1].first);\n        ret %= mod;\n      }\n      ask[t][x] = {y, ret};\n      return ret;\n    }\n  };\n\n  int64 ret = 0;\n  for(int i = N; i <= N + M + K; i++) {\n    int64 add = 0;\n    add += get(i - N, min(M, i - N), true);\n    add += mod - get(i - N, max(0, i - N - K) - 1, false);\n    add %= mod;\n\n    add *= beet.C(i - 1, N - 1);\n    add %= mod;\n\n    add *= pow3[N + M + K - i];\n    add %= mod;\n\n\n    ret += add;\n    ret %= mod;\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define MOD 1000000007\nusing namespace std;\nconst int MAXN = 1000005;\nint n,m,k,fac[MAXN],inv[MAXN];\ntypedef long long ll;\ninline int ksm(int x,int k)\n{\n\tint ret=1;\n\twhile(k){\n\t\tif(k&1)ret=(ll)ret*x%MOD;\n\t\tx=(ll)x*x%MOD;\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\nint ter[MAXN];\ninline void init(int n)\n{\n\tfac[0]=1;\n\tter[0]=1;\n\tfor(int i=1;i<=n;++i)ter[i]=(ll)ter[i-1]*3%MOD;\n\tfor(int i=1;i<=n;++i)fac[i]=(ll)fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n-1;i>=0;--i)\n\t\tinv[i]=(ll)inv[i+1]*(i+1)%MOD;\n}\ninline int C(int n,int m)\n{\n\treturn n>m?0:(ll)fac[m]*inv[m-n]%MOD*inv[n]%MOD;\n}\ninline void add(int &x,int a)\n{\n\tx+=a;\n\tif(x>=MOD)x-=MOD;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tinit(n+m+k);\n\tint ans=0,now=1;\n\tif(m>k)swap(m,k);\n\tfor(int i=0;i<=m+k;++i){\n\t\tadd(ans,(ll)C(n-1,i+n-1)*ter[m+k-i]%MOD*now%MOD);\n\t\tif(i<m)now=(ll)now*2%MOD;\n\t\telse if(i>=m && i<k)now=((ll)now*2%MOD-C(m,i)+MOD)%MOD;\n\t\telse now=(((ll)now*2%MOD-C(i-k,i)+MOD)%MOD-C(m,i)+MOD)%MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n     \n#define pb emplace_back\n#define fi first\n#define se second\n     \nusing namespace std;\n     \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\n\n\nstruct Factorial{\n  vector<Mod> v;\n  Factorial( int max_n ){\n    v = vector<Mod>( max_n , 1 );\n    FOR( i , 1 , max_n ) v[i] = v[i-1] * i;\n  }\n  int size(){\n    return v.size();\n  }\n  Mod operator [] ( int id ){\n    return v[id];\n  }\n};\n\nstruct Factorial_inv{\n  vector<Mod> v;\n  Factorial_inv( Factorial &f ){\n    v = vector<Mod>( f.size() );\n    REP( i , f.size() ) v[i] = inv( f[i] );\n  }\n  Mod operator [] ( int id ){\n    return v[id];\n  }\n};\n\nstruct Combination{\n  Factorial *f;\n  Factorial_inv *finv;\n  Combination( Factorial &arg_f , Factorial_inv &arg_finv ){\n    f = &arg_f;\n    finv = &arg_finv;\n  }\n  Mod operator () ( int a , int b ){\n    return (*f)[a] * (*finv)[b] * (*finv)[a-b];\n  }\n};\n\nFactorial fact( 1000010 );\nFactorial_inv finv( fact );\nCombination comb( fact , finv );\n\nint n, m, k;\n\nint main(){\n\n  n = in();\n  m = in();\n  k = in();\n\n  Mod ans = 0;\n  Mod sum = 1;\n  \n  REP( i , m+k+1 ){\n    ans += comb( n - 1 + i , i ) * sum * modpow( 3 , m + k - i );\n    sum *= 2;\n    if( i >= m ){\n      sum -= 2 * comb( i , i-m );\n    }\n  }\n\n  cout << ans.n << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll mod=1e9+7;\nconst ll inf=1e17+500;\nconst ll maxn=3200;\nll ent[maxn][maxn];\nll poww[maxn];\n\nint main(){\n   poww[0]=1;\n   for(ll i=1;i<maxn;i++){\n        poww[i]=(poww[i-1]*3)%mod;\n   }\n   ent[0][0]=1;\n   for(ll i=1;i<maxn;i++){\n        ent[i][i]=1;\n        ent[i][0]=1;\n        for(ll j=1;j<i;j++){\n            ent[i][j]=(ent[i-1][j]+ent[i-1][j-1])%mod;\n        }\n   }\n   ll ans=0;\n   ll n,m,k;\n   cin>>n>>m>>k;\n   for(ll j=0;j<=m;j++){\n        for(ll i=0;i<=k;i++){\n            ans+=(((ent[n-1+i+j][i]*ent[n-1+j][j])%mod)*poww[m+k-i-j])%mod;\n        }\n   }\n   cout<<ans%mod;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int MAXN=9e5+1e1,Mod=1e9+7,Tp=9e5;\n\nint fac[MAXN],inv[MAXN],p[MAXN],f[MAXN];\nint n,m,k,ans1=0,ans2=0;\n\nint Qpow(int A,int B)\n{\n\tint res=1;\n\twhile(B>0)\n\t{\n\t\tif(B&1) (res*=A)%=Mod;\n\t\t(A*=A)%=Mod,B>>=1;\n\t}\n\treturn res;\n}\n\nint C(int A,int B)\n{\n\tif(A<0 || B<0 || A<B) return 0;\n\telse return fac[A]*inv[B]%Mod*inv[A-B]%Mod;\n}\n\nsigned main(void)\n{\n\tscanf(\"%lld%lld%lld\",&n,&m,&k);\n\tfac[0]=inv[0]=p[0]=f[0]=1;\n\tfor(int i=1;i<=Tp;i++) fac[i]=fac[i-1]*i%Mod;\n\tinv[Tp]=Qpow(fac[Tp],Mod-2);\n\tfor(int i=Tp;i;i--) inv[i-1]=inv[i]*i%Mod;\n\tfor(int i=1;i<=Tp;i++) p[i]=p[i-1]*3%Mod;\n\tfor(int i=1;i<=Tp;i++) f[i]=(f[i-1]*2%Mod-C(i-1,m)-C(i-1,i-n)+Mod*2)%Mod;\n\tfor(int i=0;i<n+m;i++) (ans1+=C(i+k,i)*p[n+m-i-1]%Mod*f[i]%Mod)%=Mod;\n\tfor(int i=1;i<=Tp;i++) f[i]=(f[i-1]*2%Mod-C(i-1,k)-C(i-1,i-n)+Mod*2)%Mod;\n\tfor(int i=0;i<n+k;i++) (ans2+=C(i+m,i)*p[n+k-i-1]%Mod*f[i]%Mod)%=Mod;\n\tprintf(\"%lld\\n\",(p[n+m+k]-ans1-ans2+Mod*2)%Mod);\n\treturn 0;\n}\n//300000 300000 300000\n//415274335"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Mod = 1e9 + 7;\nconst int N = 9e5;\n\nint n, m, k;\nlong long fac[N], vfac[N];\n\nlong long mpow( long long a, int b ) {\n\tlong long rt;\n\tfor( rt = 1; b; b >>= 1, a = (a * a) % Mod )\n\t\tif( b & 1 ) rt = (rt * a) % Mod;\n\treturn rt;\n}\nvoid init( int n ) {\n\tfac[0] = 1;\n\tfor( int i = 1; i <= n; i++ )\n\t\tfac[i] = (fac[i-1] * i) % Mod;\n\tvfac[n]  = mpow( fac[n], Mod - 2 );\n\tfor( int i = n - 1; i >= 0; i-- )\n\t\tvfac[i] = vfac[i+1] * (i + 1) % Mod;\n}\nlong long comb( int n, int m ) {\n\treturn fac[n] * vfac[n-m] % Mod * vfac[m] % Mod;\n}\nint main() {\n\tscanf( \"%d%d%d\", &n, &m, &k );\n\tif( m < k ) swap( m, k );\n\tinit( m + k + n );\n\tlong long sum = 0, ans = 0;\n\tfor( int s = 0; s <= m + k; s++ ) {\n\t\tif( s == 0 ) {\n\t\t\tsum = 1;\n\t\t} else if( s <= k ) {\n\t\t\tsum = (sum<<1) % Mod;\n\t\t} else if( s <= m ) {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1)) % Mod;\n\t\t} else {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1) + Mod - comb(s-1,m)) % Mod;\n\t\t}\n\t\tlong long sub = sum * comb(n-1+s,n-1) % Mod * mpow(3,m+k-s) % Mod;\n\t\tans = (ans + sub) % Mod;\n\t}\n\tprintf( \"%lld\\n\", ans );\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 9e5 + 5, MOD = 1e9 + 7;\nint fac[N], rev[N];\nint mpow(int x, int n) {\n\tint res = 1;\n\twhile (n) {\n\t\tif (n & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint C(int n, int m) {\n\treturn 1LL * fac[n] * rev[m] % MOD * rev[n - m] % MOD;\n}\nint main() {\n\tfac[0] = rev[0] = 1;\n\tfor (int i = 1; i < N; ++ i) {\n\t\tfac[i] = 1LL * fac[i - 1] * i % MOD;\n\t\trev[i] = mpow(fac[i], MOD - 2);\n\t}\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tint ans = 0;\n\tint l = 0, r = 0, sum = 1;\n\tfor (int s = 0; s <= m + k; ++ s) {\n\t\tint res = 1LL * C(s + n - 1, s) * mpow(3, m + k - s) % MOD;\n\t\tint L = max(0, s - k), R = min(m, s);\n\t\twhile (l > L) (sum += C(s, -- l)) %= MOD;\n\t\twhile (r < R) (sum += C(s, ++ r)) %= MOD;\n\t\twhile (l < L) (sum += MOD - C(s, l ++)) %= MOD;\n\t\twhile (r > R) (sum += MOD - C(s, r --)) %= MOD;\n\t\t(ans += 1LL * res * sum % MOD) %= MOD;\n\t\tsum = (2LL * sum + MOD - C(s, l) + MOD - C(s, r)) % MOD;\n\t\tl ++;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n/* -------------------------------- Template -------------------------------- */\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = double;\n// using ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\ntemplate<typename T> T inf() { assert(false); }\ntemplate<> constexpr int inf<int>() { return 1e9; }\ntemplate<> constexpr ll inf<ll>() { return 1e18; }\ntemplate<> constexpr ld inf<ld>() { return 1e30; }\n\n/* -------------------------------- Library -------------------------------- */\n\nconst int mod = 1000000007;\n\nstruct Mod {\n  int n;\n  Mod () : n(0) {;}\n  Mod (int m) : n(m) {\n    if (n >= mod) n %= mod;\n    else if (n < 0) n = (n % mod + mod) % mod;\n  }\n  operator int() { return n; }\n};\n\nbool operator==(Mod a, Mod b) { return a.n == b.n; }\nMod operator+=(Mod &a, Mod b) { a.n += b.n; if (a.n >= mod) a.n -= mod; return a; }\nMod operator-=(Mod &a, Mod b) { a.n -= b.n; if (a.n < 0) a.n += mod; return a; }\nMod operator*=(Mod &a, Mod b) { a.n = ((long long)a.n * b.n) % mod; return a; }\nMod operator+(Mod a, Mod b) { return a += b; }\nMod operator-(Mod a, Mod b) { return a -= b; }\nMod operator*(Mod a, Mod b) { return a *= b; }\nMod operator^(Mod a, int n) {\n  if (n == 0) return Mod(1);\n  Mod res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\n\nll inv(ll a, ll p) {\n  return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nMod operator/(Mod a, Mod b) { return a * Mod(inv(b, mod)); }\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n  fact[0] = Mod(1); factinv[0] = 1;\n  REP(i,MAX_N-1) {\n    fact[i+1] = fact[i] * Mod(i+1);\n    factinv[i+1] = factinv[i] / Mod(i+1);\n  }\n}\nMod comb(int a, int b) {\n  return fact[a] * factinv[b] * factinv[a-b];\n}\n\n// http://www.everfall.com/paste/id.php?9kb9dxwtbmah\n// pakutte kita.\n\n#define mp make_pair\n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < (int) n; ++i)\n\ntypedef vector <int> vi;\n\nconst ld PI = acos(-1.0);\nconst ll MOD = mod;\n\nvoid addmod(int& x, int y, int mod) {\n  (x += y) >= mod && (x -= mod);\n}\n\nint mulmod(int x, int y, int mod) {\n  return x * 1ll * y % mod;\n}\n\nnamespace FFT {\n  struct cd {\n    ld a, b;\n\n    cd(ld a, ld b) : a(a), b(b) {}\n\n    cd(ld x = 0) : a(x), b(0) {}\n\n    ld real() const {\n      return a;\n    }\n\n    void operator += (const cd& other) {\n      a += other.a;\n      b += other.b;\n    }\n\n    void operator -= (const cd& other) {\n      a -= other.a;\n      b -= other.b;\n    }\n\n    void operator *= (const cd& other) {\n      tie(a, b) = mp(a * other.a - b * other.b, a * other.b + b * other.a);\n    }\n\n    friend cd operator * (const cd& x, const cd& y) {\n      cd r = x;\n      r *= y;\n      return r;\n    }\n\n    friend cd operator + (const cd& x, const cd& y) {\n      cd r = x;\n      r += y;\n      return r;\n    }\n\n    friend cd operator - (const cd& x, const cd& y) {\n      cd r = x;\n      r -= y;\n      return r;\n    }\n\n    void operator /= (ld c) {\n      a /= c;\n      b /= c;\n    }\n  };\n\n  typedef vector<cd> vcd;\n\n  const int LOG = 20;\n  const int N = 1 << LOG;\n\n  int rev[N];\n  cd root_[N];\n\n  inline cd root(int k, int n) {\n    return root_[k * (N / n)];\n  }\n\n  void precalc() {\n    rev[0] = 0;\n    int hb = -1;\n    for (int i = 1; i < N; ++i) {\n      if  ((i & (i - 1)) == 0) {\n        ++hb;\n      }\n      rev[i] = rev[i ^ (1 << hb)] | (1 << (LOG - hb - 1));\n    }\n\n    forn(i, N) {\n      ld ang = PI * i * 2.0 / N;\n      root_[i] = cd(cosl(ang), sinl(ang));\n    }\n  }\n\n  void fft_rec(cd* a, int n) {\n    if  (n == 1) {\n      return;\n    }\n\n    fft_rec(a, n / 2);\n    fft_rec(a + n / 2, n / 2);\n\n    forn(k, n / 2) {\n      cd w = root(k, n);\n      cd x = a[k];\n      cd y = w * a[k + n / 2];\n      a[k] = x + y;\n      a[k + n / 2] = x - y;\n    }\n  }\n\n  void fft(vcd& a) {\n    int n = sz(a);\n    vcd na(n, cd(0, 0));\n    forn(i, n) na[i] = a[rev[i]];\n    na.swap(a);\n\n    fft_rec(&a[0], n);\n  }\n\n  void fft_inv(vcd& a) {\n    fft(a);\n    int n = sz(a);\n    reverse(a.begin() + 1, a.end());\n    forn(i, n) {\n      a[i] /= n;\n    }\n  }\n\n  vi mult(const vi& a, const vi& b) {\n    //    TimeStamp t(\"mult\");\n    vcd A(N, cd(0, 0));\n    vcd B(N, cd(0, 0));\n    forn(i, sz(a)) A[i] = a[i];\n    forn(i, sz(b)) B[i] = b[i];\n\n    fft(A);\n    fft(B);\n\n    forn(i, N) A[i] *= B[i];\n\n    fft_inv(A);\n\n    vi c(N, 0);\n    forn(i, N) c[i] = ((ll) (A[i].real() + 0.5)) % MOD;\n\n    return c;\n  }\n\n  vi multmod(const vi& a, const vi& b) {\n    // a = a0 + sqrt(MOD) * a1\n    // a = a0 + base * a1\n    int base = (int) sqrtl(MOD);\n\n    vi a0(sz(a)), a1(sz(a));\n    forn(i, sz(a)) {\n      a0[i] = a[i] % base;\n      a1[i] = a[i] / base;\n      assert(a[i] == a0[i] + base * a1[i]);\n    }\n\n    vi b0(sz(b)), b1(sz(b));\n    forn(i, sz(b)) {\n      b0[i] = b[i] % base;\n      b1[i] = b[i] / base;\n      assert(b[i] == b0[i] + base * b1[i]);\n    }\n\n    vi a01 = a0;\n    forn(i, sz(a)) {\n      addmod(a01[i], a1[i], MOD);\n    }\n\n    vi b01 = b0;\n    forn(i, sz(b)) {\n      addmod(b01[i], b1[i], MOD);\n    }\n\n    vi C = mult(a01, b01);  // 1\n\n    vi a0b0 = mult(a0, b0); // 2\n    vi a1b1 = mult(a1, b1); // 3\n\n    vi mid = C;\n    forn(i, N) {\n      addmod(mid[i], -a0b0[i] + MOD, MOD);\n      addmod(mid[i], -a1b1[i] + MOD, MOD);\n    }\n\n    vi res = a0b0;\n    forn(i, N) {\n      addmod(res[i], mulmod(base, mid[i], MOD), MOD);\n    }\n\n    base = mulmod(base, base, MOD);\n    forn(i, N) {\n      addmod(res[i], mulmod(base, a1b1[i], MOD), MOD);\n    }\n\n    return res;\n  }\n};\n\n/* ---------------------------------- Main ---------------------------------- */\n\nMod threes[MAX_N];\n\nint main() {\n  init();\n  threes[0] = 1;\n  REP(i,MAX_N-1) threes[i+1] = threes[i] * Mod(3);\n  int N, M, K;\n  cin >> N >> M >> K;\n\n  vector<int> invsj(650000, 0), invsk(650000, 0);\n  for (int i = 0; i <= M; ++i) invsj[i] = factinv[i];\n  for (int i = 0; i <= K; ++i) invsk[i] = factinv[i];\n  FFT::precalc();\n  // cout << invsj.size() << endl;\n  // cout << invsk.size() << endl;\n  vector<int> prod = FFT::multmod(invsj, invsk);\n  // cout << prod.size() << endl;\n  // REP(i,20) cout << prod[i] << \" \"; cout << endl;\n  // REP(i,20) cout << invsj[i] << \" \"; cout << endl;\n  // REP(i,20) cout << invsk[i] << \" \"; cout << endl;\n\n  Mod res = 0;\n  REP(i,M+K+1) {\n    Mod val = fact[i+N-1] * factinv[N-1] * Mod(prod[i])\n      * threes[M+K-i];\n    res += val;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2) \n#include<bits/stdc++.h>\n#define rg register\n#define il inline\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7,O=1000010;\nil int gi(){\n\trg int o=0,fl=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')fl=-1,ch=getchar();\n\twhile(isdigit(ch))o=o*10+ch-'0',ch=getchar();\n\treturn fl*o;\n}\nint n,m,k;\nll fac[O],inv[O],bin[O],ans,x=1;\nil ll C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);n--;\n\tbin[0]=fac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<O;++i)bin[i]=bin[i-1]*3%mod;\n\tfor(int i=2;i<O;++i){\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tfor(int i=2;i<O;++i)inv[i]=inv[i-1]*inv[i]%mod;\n\tfor(int i=0;i<=m+k;++i){\n\t\t(ans+=C(n+i,n)*bin[m+k-i]%mod*x%mod)%=mod;\n\t\tif(i<k)(x<<=1)%=mod;\n        else if(i<m)x=((x*2-C(i,k))%mod+mod)%mod;\n        else x=((x*2-C(i,k)-C(i,m))%mod+mod)%mod;\n\t}\n\tprintf(\"%lld\",ans<0?ans+mod:ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 1000200;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nconst int inv3 = (mod + 1) / 3;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint fac[maxn], ifac[maxn], inv[maxn], pw[maxn];\ninline int c(int x,int y,int z){ return (ll) fac[x + y + z] * ifac[x] % mod * ifac[y] % mod * ifac[z] % mod; } \ninline int c(int x,int y){ return (ll) fac[x + y] * ifac[x] % mod * ifac[y] % mod; }\nint x, y, z;\ninline void reduce(int & x) {\n\tx += x >> 31 & mod;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tfac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = pw[0] = 1;\n\tpw[1] = inv3;\n\trep(i, 2, maxn - 1) {\n\t\tinv[i] = ll(mod - mod / i) * inv[mod % i] % mod;\n\t\tfac[i] = (ll) fac[i - 1] * i % mod;\n\t\tifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n\t\tpw[i] = (ll) pw[i - 1] * inv3 % mod;\n\t}\n\tcin >> x >> y >> z;\n\tint ans = 0, a1 = 0;\n\trep(i, 0, z + y) {\n\t\tstatic int v = 1;\n\t\ta1 = (a1 + (ll) c(x - 1, i) * pw[i] % mod * v) % mod;\n\t\treduce(v += v - mod);\n\t\tif(y <= i) reduce(v -= c(i - y, y));\n\t\tif(z <= i) reduce(v -= c(i - z, z));\n\t}\n//\tcout << ans * pow(3, y + z) % mod << '\\n';\n\tcout << a1 * pow(3, y + z) % mod << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef ONLINE_JUDGE\n#define freopen \\\n  if (0) freopen\n#define cerr \\\n  if (0) cerr\n#endif\n\n#define fi first\n#define se second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n\n#define sqr(a) ((a)*1ll * (a))\n#define sz(a) (int)a.size()\n#define len(a) (int)a.length()\n#define all(a) a.begin(), a.end()\n#define nl '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nvector<int> fact;\n\nint powm(int n, int p) {\n  int res = 1;\n  while (p > 0) {\n    if (p & 1) \n      res = (res * 1ll * n) % mod;\n    p >>= 1;\n    n = (n * 1ll * n) % mod;\n  }\n  return res;\n}\n\nint inv(int n) {\n  return powm(n, mod - 2);\n}\n\nint binom(int n, int k) {\n  return (fact[n] * 1ll * inv((fact[k] * 1ll * fact[n - k]) % mod)) % mod;\n}\n\nvoid solve() {\n  fact.resize(3 * 1e5 + 1);\n  fact[0] = 1;\n  rep(i, 1, 3 * 1e5) {\n    fact[i] = (fact[i - 1] * 1ll * i) % mod;\n  }\n\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  int l = n + m + k;\n  int res = 0;\n  rep(i, n, l) {\n    int sum = 0;\n    rep(j, 0, min(i - n, m)) {\n      if (i - n - j <= k) {\n        sum += binom(i - n, j);\n        sum %= mod;\n      }\n    }\n    int temp = (sum * 1ll * binom(i - 1, n - 1)) % mod;\n    res += (temp * 1ll * powm(3, l - i)) % mod;\n    res %= mod;\n  }\n\n  cout << res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  freopen(\".in\", \"r\", stdin);\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\nconst int mod = 1e9 + 7;\nconst int MX = 610000;\nll inv[MX], f[MX], invf[MX], pw[MX];\nvoid calc(){\n\tpw[0] = 1;\n\trep(i, MX - 1) pw[i + 1] = pw[i] * 3 % mod;\n\tinv[0] = inv[1] = f[0] = f[1] = invf[0] = invf[1] = 1;\n\tfor (int i = 2; i < MX; i++){\n\t\tinv[i] = mod - mod / i * inv[mod % i] % mod;\n\t\tf[i] = f[i - 1] * i % mod;\n\t\tinvf[i] = invf[i - 1] * inv[i] % mod;\n\t}\n}\ninline ll C(ll n, ll k){\n\tif(k < 0 || k > n) return 0;\n\treturn f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint main(){\n\tcalc();\n\tint a, b, c; cin >> a >> b >> c;\n\tll ans = 0;\n\tll sum = 1; int L = 0, R = 0;\n\trep(i, b + c + 1){\n\t\t/*\n\t\tll s = 0;\n\t\tfor(int j = max(0, i - c); j <= min(b, i); j++) s += C(i, j);\n\t\t*/\n\t\tif(i) sum *= 2;\n\t\tint l = max(0, i - c), r = min(b, i);\n\t\tsum += C(i - 1, L - 1);\n\t\tsum += mod - C(i - 1, R);\n\t\t\n\t\tif(l > L) sum += mod - C(i, L);\n\t\tif(r > R) sum += C(i, r);\n\t\t\n\t\t//dbg(l, r, L, R, sum, s); assert(s % mod == sum % mod);\n\t\t\n\t\tL = l; R = r;\n\t\tsum %= mod;\n\t\tans += sum * C(i + a - 1, i) % mod * pw[b + c - i] % mod;\n\t}\n\tcout << ans % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) { os << \"[ \"; \n\tfor(auto v:V)os << v << \" \"; return os << \"]\";\n}\ntemplate<class T> ostream& operator<<(ostream &os, set<T> S){ os << \"{ \"; \n\tfor(auto s:S) os<<s<<\" \";  return os<<\"}\"; \n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os<<\"(\"<<P.first<<\",\"<< P.second << \")\";\n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, map<L,R> M) {\n\tos<<\"{ \";for(auto m:M)os<<\"(\"<<m.F<<\":\"<<m.S<<\")\";\n\treturn os<<\"}\";\n}\n#define cerr cout\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define For(i,n) for(int i=0;i<(int)n;++i)\n#define Rev(i,n) for(int i=(int)n-1;i>=0;--i)\n#define Rep(i,n) for(int i=1;i<=(int)n;++i)\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\ntypedef vector<pii> vpii;\n#define fio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n\nconst int N = 1e6 + 100;\nconst int mod = 1e9 + 7;\n\ninline int mul(int a , int b){\n\treturn a*1ll*b%mod;\n}\ninline int mul(int a , int b, int c){\n\treturn mul(a , mul(b , c));\n}\ninline int sub(int a , int b){\n\ta -= b;\n\tif(a < 0) a += mod;\n\treturn a;\n}\ninline int add(int a , int b){\n\ta += b;\n\tif(a >= mod) a -= mod;\n\treturn a;\n}\ninline int power(int x, int y){\n\tint res = 1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres = mul(res , x);\n\t\tx = mul(x , x);\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint fac[N] , inv[N];\nint pr[N];\nint pr2[N];\nint dp[N];\nint dp2[N];\nint nCr(int n , int r){\n\tif(r < 0 || r > n) return 0;\n\treturn mul(fac[n] , mul(inv[r] , inv[n-r]));\n}\n\nint main(){\n\tfio; cout<<fixed<<setprecision(25);\t\n\tfac[0] = 1;\n\tpr[0] = 1;\n\tpr2[0] = 1;\n\tfor(int i = 1;i< N ; ++i){\n\t\tpr[i] = mul(pr[i-1] , 3);\n\t\tpr2[i] = mul(pr2[i-1] , 2);\n\t\tfac[i] = mul(fac[i-1] , i);\n\t}\n\tinv[N-1] = power(fac[N-1] , mod-2);\n\tfor(int i = N-2 ; i >= 0 ; --i){\n\t\tinv[i] = mul(inv[i+1] , i+1);\n\t}\n\tassert(inv[0] == 1);\n\tint n , m , k; cin >> n >> m >> k;\n\tif(m > k) swap(m , k);\n\tint ans = 0;\n\t// for(int i = 0;i <= m ; ++i){\n\t// \tfor(int j = 0;j <= k ; ++j){\n\t// \t\tans = add(ans , mul( mul(mul( 1 , 1)  , mul(nCr(n-1+i+j , n-1) , nCr(i+j , i) )) , pr[m-i+k-j]  ) );\n\t// \t\t// trace(i , j , ans);\n\t// \t}\n\t// }\n\n\n\tfor(int i = 0 ;i <= m+k ; ++i){\n\n\n\t\tif(i <= k){\n\t\t\tdp[i] = pr2[i];\n\t\t}\n\t\telse{\n\t\t\tdp[i] =  sub( mul(2 , dp[i-1]) , nCr(i-1 , k));\n\t\t}\n\t\tif(i <= m){\n\t\t\tdp2[i] = pr2[i];\n\t\t}\n\t\telse{\n\t\t\tdp2[i] =  sub( mul(2 , dp[i-1]) , nCr(i-1 , m));\n\t\t}\n\t\tif(i <= k){\n\t\t\tans = add(ans ,   mul( nCr(n-1+i , i) , pr2[i] , pr[m+k-i]));\n\t\t}\n\t\telse{\n\t\t\tint ss = add(dp[i] , dp2[i]);\n\t\t\t// trace(ss);\n\t\t\tss = sub(ss , pr2[i]);\n\t\t\t// trace(ss);\n\t\t\t// ss = mul(ss , inv[2]);\n\t\t\t// trace(i , ss);\n\t\t\t// dp[i] = sub( mul(2 , dp[i-1]) , nCr(i-1 , k));\n\t\t\t// trace(i , dp[i]);\n\t\t\tans = add(ans , mul(nCr(n-1+i , i) ,  ss , pr[m+k-i]));\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline int mul(int a, int b) {\n  return (long long) a * b % md;\n}\n\ninline int power(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int x) {\n  return power(x, md - 2);\n}\n\nconst int N = 1234567;\n\nint fact[N], invfact[N];\n\ninline int C(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  return mul(fact[n], mul(invfact[k], invfact[n - k]));\n}\n\nint main() {\n  fact[0] = 1;\n  for (int i = 1; i < N; i++) {\n    fact[i] = mul(fact[i - 1], i);\n  }\n  invfact[N - 1] = inv(fact[N - 1]);\n  for (int i = N - 2; i >= 0; i--) {\n    invfact[i] = mul(invfact[i + 1], i + 1);\n  }\n  int a, b, c;\n  scanf(\"%d %d %d\", &a, &b, &c);\n  int ans = 0;\n  int rb = 0, rc = 0;\n  for (int sum = 0; sum <= b + c; sum++) {\n    int coeff = mul(power(3, b + c - sum), fact[a + sum - 1]);\n    int what = power(2, sum);\n    if (sum > b) {\n      add(rb, rb);\n      add(rb, C(sum - 1, b));\n      add(what, md - rb);\n    }\n    if (sum > c) {\n      add(rc, rc);\n      add(rc, C(sum - 1, c));\n      add(what, md - rc);\n    }\n    what = mul(what, invfact[sum]);\n    add(ans, mul(coeff, what));\n  }\n  printf(\"%d\\n\", mul(ans, invfact[a - 1]));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \nusing namespace std ;\n\nconst int mod = 1e9 + 7;\nconst int N = 900010;\nint n, m, k;\nll fac[N], inv[N], p[N];\n\ninline ll read() {\n\tll s = 0, f = 1;\n\tchar ch;\n\tfor(; ch < '0' || ch > '9'; ch = getchar())\tif(ch == '-')\tf = -1;\n\tfor(; ch >= '0' && ch <= '9'; ch = getchar())\ts = (s << 1) + (s << 3) + ch - '0';\n\treturn s * f;\n}\n\ninline ll quickpow(ll a, ll b) {\n    ll re = 1;\n    while(b) {\n        if(b & 1) re *= a;\n        re %= mod;\n\t\tb >>= 1;\n        a *= a;\n        a %= mod;\n    }\n    return re;\n}\n\ninline void init() {\n\tn = read(), m = read(), k = read();\n    fac[0] = 1;\n    p[0] = 1;\n    for(int i = 1 ; i < N; ++i) {\n        fac[i] = fac[i - 1] * i % mod;\n        p[i] = p[i - 1] * 3LL % mod;\n    }\n    for(int i = 0; i < N; ++i) { inv[i] = quickpow(fac[i], mod - 2) % mod; }\n}\n\ninline ll C(ll x, ll y) { return (fac[x] * inv[y] % mod * inv[x - y] % mod) % mod; }\n\ninline void work() {\n\tll ans = 0, x = 1LL;\n    --n;\n    if(m < k)\tswap(m, k);\n    for(int i = 0; i <= m + k; ++i) {\n        ans = (ans + C(n + i, n) * p[m + k - i] % mod * x) % mod;\n        if(i < k) x = (x * 2LL) % mod;\n        else if(i < m) x = (x * 2LL - C(i, k)) % mod ;\n        else  x = (x * 2LL - C(i, k) - C(i, m)) % mod ;\n    }\n    printf(\"%lld\\n\", (ans + mod) % mod);\n}\n\nint main() {\n\tinit();\n    work();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef ONLINE_JUDGE\n#define freopen \\\n  if (0) freopen\n#define cerr \\\n  if (0) cerr\n#endif\n\n#define fi first\n#define se second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n\n#define sqr(a) ((a)*1ll * (a))\n#define sz(a) (int)a.size()\n#define len(a) (int)a.length()\n#define all(a) a.begin(), a.end()\n#define nl '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nvector<int> fact;\n\nint powm(int n, int p) {\n  int res = 1;\n  while (p > 0) {\n    if (p & 1) \n      res = (res * 1ll * n) % mod;\n    p >>= 1;\n    n = (n * 1ll * n) % mod;\n  }\n  return res;\n}\n\nint inv(int n) {\n  return powm(n, mod - 2);\n}\n\nint binom(int n, int k) {\n  return (fact[n] * 1ll * inv((fact[k] * 1ll * fact[n - k]) % mod)) % mod;\n}\n\nvoid solve() {\n  fact.resize(1e6);\n  fact[0] = 1;\n  rep(i, 1, 1e6) {\n    fact[i] = (fact[i - 1] * 1ll * i) % mod;\n  }\n\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  int l = n + m + k;\n  int res = 0;\n  int prev = 0;\n  int row_sum = 1;\n  rep(i, n, l) {\n    int mid_sum = row_sum;\n    if (i - n - k > 0) {\n      int prev_left = max(0, i - 1 - n - k);\n      prev += binom(i - 1 - n, prev_left);\n      prev %= mod;\n    }\n    if (m < i - n) {\n      int prev_right = min(i - 1 - n, m);\n      prev += binom(i - 1 - n, prev_right);\n      prev %= mod;\n    }\n    mid_sum = (mod + mid_sum) - prev;\n    mid_sum %= mod;\n    int temp = (mid_sum * 1ll * binom(i - 1, n - 1)) % mod;\n    res += (temp * 1ll * powm(3, l - i)) % mod;\n    res %= mod;\n    row_sum = (row_sum * 1ll * 2) % mod;\n    prev = (prev * 1ll * 2) % mod;\n  }\n\n  cout << res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  freopen(\".in\", \"r\", stdin);\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 1000000\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,K,p[MN+5],inv[MN+5],pw[MN+5],ans;\ninline int C(int n,int m){return m<0||m>n?0:1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n    n=read();m=read();K=read();p[0]=inv[0]=p[1]=inv[1]=pw[0]=1;pw[1]=3;\n    for(int i=2;i<=MN;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod,pw[i]=3LL*pw[i-1]%mod;\n    for(int i=2;i<=MN;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;\n    for(int i=0,res=1;i<=m+K;++i)\n    {\n        if(i)\n        {\n            int l=max(0,i-K),r=min(m,i);\n            int L=max(0,i-1-K),R=min(m,i-1);\n            res=(2LL*res+mod-C(i-1,R)+C(i-1,L-1))%mod;\n            if(l>L) res=(res+mod-C(i,L))%mod;\n            if(r>R) res=(res+C(i,r))%mod;\n        }\n        ans=(ans+1LL*res*C(i+n-1,n-1)%mod*pw[m+K-i])%mod;\n    }\n    cout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/stack:16777216\")\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>  \n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n#include <bitset>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ITER(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(A,value) memset(A,value,sizeof(A))\n\n#define ALL(V) V.begin(), V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\nconst double PI=acos(-1.0);\n\ntypedef long long Int;\ntypedef long long LL;\ntypedef unsigned long long UINT;\ntypedef vector <int> VI;\ntypedef pair <int, int> PII;\ntypedef pair <double, double> PDD;\n\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\n\nconst int MAX = 2100000;\nconst int MAX1 = 2007;\nconst int MAX2 = 24000000;\nconst int LEN = 21;\nconst int BASE = 1000000000;\n\nconst int MOD = 1000000007;\n\nint a, b, c;\nInt F[MAX];\nInt FF[MAX];\n\nInt Pow(Int a, Int b)\n{\n  Int res = 1;\n  while (b)\n    if (b % 2 == 0)\n    {\n      b /= 2;\n      a = a * a % MOD;\n    }\n    else\n    {\n      -- b;\n      res = res * a % MOD;\n    }\n  return res;\n}\n\nInt bin(int n, int k)\n{\n  if (k < 0 || k > n) return 0;\n  return F[n] * FF[k] % MOD * FF[n-k] % MOD;\n}\n\nint main()\n{\n  F[0] = FF[0] = 1;\n  FOR (i,1,MAX)\n  {\n    F[i] = F[i-1] * i % MOD;\n    FF[i] = Pow(F[i], MOD-2);\n  }\n\n  cin >> a >> b >> c;\n\n  -- a;\n\n  Int res = Pow(3, b+c);\n  Int last = 1;\n    \n  FOR (i,1,b+c+1)\n  {\n    Int d = last * i * 2;\n\n    d -= bin(i, b+1) * F[i-1] % MOD * (b+1) % MOD;\n    d = (d + MOD) % MOD;\n\n    d -= bin(i, c+1) * F[i-1] % MOD * (c+1) % MOD;\n    d = (d + MOD) % MOD;\n\n    Int x = d * FF[i] % MOD;\n    x = x * bin(i+a, a) % MOD;\n    x = x * Pow(3, b+c-i);\n\n    res = (res + x) % MOD;\n\n    last = d;\n  }\n\n\n  cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\nconst int mod = 1e9 + 7;\nconst int MX = 610000;\nll inv[MX], f[MX], invf[MX], pw[MX];\nvoid calc(){\n\tpw[0] = 1;\n\trep(i, MX - 1) pw[i + 1] = pw[i] * 3 % mod;\n\tinv[0] = inv[1] = f[0] = f[1] = invf[0] = invf[1] = 1;\n\tfor (int i = 2; i < MX; i++){\n\t\tinv[i] = mod - mod / i * inv[mod % i] % mod;\n\t\tf[i] = f[i - 1] * i % mod;\n\t\tinvf[i] = invf[i - 1] * inv[i] % mod;\n\t}\n}\ninline ll C(ll n, ll k){\n\tif(k < 0 || k > n) return 0;\n\treturn f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint main(){\n\tcalc();\n\tint a, b, c; cin >> a >> b >> c;\n\tll ans = 0;\n\tll sum = 1; int L = 0, R = 0;\n\trep(i, b + c + 1){\n\t\t\n\t\tll s = 0;\n\t\tfor(int j = max(0, i - c); j <= min(b, i); j++) s += C(i, j);\n\t\t\n\t\tif(i) sum *= 2;\n\t\tint l = max(0, i - c), r = min(b, i);\n\t\tsum += C(i - 1, L - 1);\n\t\tsum += mod - C(i - 1, R);\n\t\t\n\t\tif(l > L) sum += mod - C(i, L);\n\t\tif(r > R) sum += C(i, r);\n\t\t\n\t\t//dbg(l, r, L, R, sum, s); assert(s % mod == sum % mod);\n\t\t\n\t\tL = l; R = r;\n\t\tsum %= mod;\n\t\tans += sum * C(i + a - 1, i) % mod * pw[b + c - i] % mod;\n\t}\n\tcout << ans % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nconst int kN = 300000 + 5;\nconst int MOD = (int)1e9 + 7;\nint Inv[kN], Finv[kN], F[kN], n, m, k;\nint pascal[kN];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return F[a] * 1LL * Finv[b] % MOD * Finv[a - b] % MOD;\n}\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nint power(int a, int b, int p)\n{\n    int ret = 1;\n    for ( ; b; b >>= 1, a = a * 1LL * a % MOD)\n        if (b & 1)\n            ret = ret * 1LL * a % MOD;\n    return ret;\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kN; ++ i)\n        Inv[i] = (MOD - MOD / i) * 1LL * Inv[MOD % i] % MOD;\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kN; ++ i) {\n        F[i] = F[i - 1] * 1LL * i % MOD;\n        Finv[i] = Finv[i - 1] * 1LL * Inv[i] % MOD;\n    }\n    scanf(\"%d%d%d\", &n, &m, &k);\n    pascal[0] = 1;\n    for (int i = 1; i <= m + k; ++ i) {\n        pascal[i] = (pascal[i - 1] << 1) % MOD;\n        if (i >= m + 1) add(pascal[i], MOD - binom(i - 1, m));\n        if (i >= k + 1) add(pascal[i], MOD - binom(i - 1, i - (k + 1)));\n    }\n    int result = 0;\n    int t = n + m + k;\n    for (int i = n; i <= t; ++ i) {\n        add(result, binom(i - 1, n - 1) * 1LL * power(3, t - i, MOD) % MOD * pascal[i - n] % MOD);\n    }\n    printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,k;\nlong long inv[300010],fac[300010],p[300010],ans;\nconst long long mod=1e9+7;\ninline long long ksm(long long x,long long y)\n{\n\tlong long res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\tres=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t} \n\treturn res;\n}\ninline long long c(int x,int y)\n{\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tp[0]=1;\n\tfac[0]=1;\n\tinv[0]=1;\n\tfor(int i=1;i<=3e5;++i)\n\t{\n\t\tp[i]=p[i-1]*3%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tinv[300000]=ksm(fac[300000],mod-2);\n\tfor(int i=3e5-1;i>=1;--i)\n\tinv[i]=inv[i+1]*(i+1)%mod;\n\tlong long x=1;\n\t--n;\n\tfor(int i=0;i<=m+k;++i)\n\t{\n\t\tans=(ans+c(n+i,n)*p[m+k-i]%mod*x)%mod;\n\t\tif(i<k)\n\t\tx=x*2%mod;\n\t\telse if(i<m)\n\t\tx=(x*2-c(i,k)+mod)%mod;\n\t\telse \n\t\tx=(x*2-c(i,k)-c(i,m)+mod+mod)%mod;\t\t\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#pragma GCC optimize(\"Ofast,unroll-loops\")\n//#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace IntModulo\n{\n\tconst int mod = 1e9 + 7;\n\n\tinline int add(int x, int y, int m = mod)\n\t{\n\t\tif (x + y < m)\n\t\t\treturn x + y;\n\t\treturn x + y - m;\n\t}\n\n\tinline int sub(int x, int y, int m = mod)\n\t{\n\t\tif (x >= y)\n\t\t\treturn x - y;\n\t\treturn x - y + m;\n\t}\n\n\tinline int mult(int x, int y, int m = mod)\n\t{\n\t\treturn x * (LL) y % m;\n\t}\n\n\tinline int power(int x, int y, int m = mod)\n\t{\n\t\tint r = 1;\n\t\twhile(y)\n\t\t{\n\t\t\tif (y & 1)\n\t\t\t\tr = mult(r, x, m);\n\t\t\tx = mult(x, x, m);\n\t\t\ty >>= 1;\n\t\t}\n\t\t\n\t\treturn r;\n\t}\n\t\n\tinline int inverse(int x, int m = mod)\n\t{\n\t\treturn power(x, m - 2, m);\n\t}\n\t\n\tinline void ADD(int& x, int y, int m = mod)\n\t{\n\t\tx += y;\n\t\tif (x >= m) x -= m;\n\t}\n\t\n\tinline void SUB(int& x, int y, int m = mod)\n\t{\n\t\tx -= y;\n\t\tif (x < 0) x += m;\n\t}\n\t\n\tinline void MULT(int& x, int y, int m = mod)\n\t{\n\t\tx = (x * (LL) y) % m;\n\t}\n};\n\nnamespace Combinatorics\n{\n\tusing namespace IntModulo;\n\t\n\tconst int N = 1 << 20;\n\tint fact[N];\n\tint inv[N];\n\tint invFact[N];\n\tbool inited = false;\n\t\n\tinline int C(int n, int k) // binomial C(n, k)\n\t{\n\t\treturn n < k ? 0 : mult(fact[n], mult(invFact[k], invFact[n - k]));\n\t}\n\t\n\tinline int H(int n, int k) // number of solution x1 + .. + xn = k\n\t{\n\t\treturn C(n + k - 1, k);\n\t}\n\t\n\tvoid init()\n\t{\n\t\tdebug(Combinatorics::N);\n\t\tinited = true;\n\t\tinv[1] = 1;\n\t\tFOR(i, 2, N)\n\t\t\tinv[i] = mult(mod - mod / i, inv[mod % i]);\n\t\t\n\t\tinvFact[0] = fact[0] = 1;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tfact[i] = mult(i, fact[i - 1]);\n\t\t\tinvFact[i] = mult(invFact[i - 1], inv[i]);\n\t\t}\n\t}\t\n};\n\nusing namespace Combinatorics;\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tCombinatorics::init();\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tn--;\n\tint ans = 0;\n\tint last = -1;\n\t\n\tFOR(t, 0, m + k + 1)\t\t\n\t{\n\t\tint curr = (t ? mult(2 * t, last) : 1);\n\t\tif (t)\n\t\t{\n\t\t\tFOR(it, 0, 2)\n\t\t\t{\n\t\t\t\tSUB(curr, mult(mult(m + 1, fact[t - 1]), C(t, m + 1)));\n\t\t\t\tswap(m, k);\n\t\t\t}\n\t\t}\n\t\t\n\t\tADD(ans, mult(invFact[t], mult(curr, mult(C(n + t, t), power(3, m + k - t)))));\n\t\tlast = curr;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, M, K;\ni64 fact[909090], frev[909090];\ni64 invs[909090];\n\ni64 modpow(i64 a, i64 p = MOD - 2)\n{\n\tif (p == 0) return 1;\n\ti64 tmp = modpow(a, p / 2);\n\ttmp = tmp * tmp % MOD;\n\tif (p % 2) tmp = tmp * a % MOD;\n\treturn tmp;\n}\n\ni64 C(int a, int b)\n{\n\tif (a < b) return 0;\n\treturn fact[a] * frev[b] % MOD * frev[a - b] % MOD;\n}\n\nint main()\n{\n\tfact[0] = 1; frev[0] = 1;\n\tinvs[0] = 1;\n\tinvs[1] = 1;\n\tfor (int i = 2; i < 909090; ++i) invs[i] = MOD - MOD / i * invs[MOD % i] % MOD;\n\tfor (int i = 1; i < 909090; ++i) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tfrev[i] = frev[i - 1] * invs[i] % MOD;\n\t}\n\n\tscanf(\"%d%d%d\", &N, &M, &K);\n\n\tif (M > K) swap(M, K);\n\ti64 ret = 0, cur = 1;\n\tfor (int w = 0; w <= M + K; ++w) {\n\t\tADD(ret, C(N - 1 + w, w) * cur % MOD * modpow(3, M + K - w));\n\t\tcur = cur * 2 % MOD;\n\t\t\n\t\tint lo = min(w, M);\n\t\tif (w >= M) {\n\t\t\tADD(cur, MOD - C(w, M));\n\t\t}\n\t\tif (w >= K) {\n\t\t\tADD(cur, MOD - C(w, w - K));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=9e5+5,mo=1e9+7;\n\ntypedef long long LL;\n\nint n,m,K,ans,Fac[N],Inv[N],p[N];\n\nint C(int n,int m)\n{\n\treturn (LL)Fac[n]*Inv[m]%mo*Inv[n-m]%mo;\n}\n\nint main()\n{\n\tp[0]=Fac[0]=Inv[0]=Fac[1]=Inv[1]=1; p[1]=3;\n\tfor (int i=2;i<N;i++) Inv[i]=(LL)Inv[mo%i]*(mo-mo/i)%mo;\n\tfor (int i=2;i<N;i++)\n\t{\n\t\tp[i]=p[i-1]*3ll%mo; Fac[i]=(LL)Fac[i-1]*i%mo; Inv[i]=(LL)Inv[i-1]*Inv[i]%mo;\n\t}\n\tscanf(\"%d%d%d\",&n,&m,&K); n--;\n\tif (m<K) swap(m,K);\n\tfor (int i=0,j=1;i<=m+K;i++)\n\t{\n\t\tans=(ans+(LL)C(n+i,n)*p[m+K-i]%mo*j)%mo;\n\t\tif (i<K) j=j*2%mo;\n\t\telse if (i>=m) j=(j*2ll-C(i,K)-C(i,i-m))%mo;\n\t\telse j=(j*2ll-C(i,K))%mo;\n\t}\n\tif (ans<0) ans+=mo;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (1800009)\n#define LL long long\n#define MOD (1000000007)\nusing namespace std;\n\nLL inv[N],fac[N],facinv[N];\nLL n,m,k,ans,f[N];\n\nvoid Init()\n{\n\tfac[0]=facinv[0]=inv[1]=1;\n\tfor (int i=1; i<=1800000; ++i)\n\t{\n\t\tif (i!=1) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;\n\t\tfac[i]=fac[i-1]*i%MOD; facinv[i]=facinv[i-1]*inv[i]%MOD;\n\t}\n}\n\nLL C(LL n,LL m)\n{\n\tif (n<m) return 0;\n\treturn fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;\n}\n\nLL Qpow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=ans*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tInit();\n\tcin>>n>>m>>k;\n\tf[0]=1; f[1]=2;\n\tfor (int i=1; i<=m+k; ++i)\n\t\tf[i]=(f[i-1]*2-C(i-1,m)-C(i-1,k))%MOD;\n\tfor (int i=n; i<=n+m+k; ++i)\n\t\t(ans+=f[i-n]*C(i-1,n-1)%MOD*Qpow(3,n+m+k-i)%MOD)%=MOD;\n\tcout<<(ans+MOD)%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <math.h>\n#include <string.h>\n#include <string>\n#include <queue>\n#include <stack>\nusing namespace std;\ntypedef long long int ll;\nll mod=1e9+7;\nll powt[1000100];\nll powtwo[1000100];\nll fact[1000100];\nll inv[1000100];\nll invfact[1000100];\nll dp[1000100];\nll ans;\nint n, m, k;\n\nll com(int u, int v)\n{\n\tll ret=1;\n\tret=(ret*fact[u])%mod;\n\tret=(ret*invfact[v])%mod;\n\tret=(ret*invfact[u-v])%mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin>>n>>m>>k;\n\tn++; m++; k++;\n\tinv[1]=1;\n\tinvfact[0]=1;\n\tfact[0]=1;\n\tinvfact[1]=1;\n\tfact[1]=1;\n\tint i, j;\n\tfor(i=2 ; i<=1000000 ; i++)\n\t{\n\t\tinv[i]=((mod-mod/i)*inv[mod%i])%mod;\n\t\tfact[i]=(i*fact[i-1])%mod;\n\t\tinvfact[i]=(invfact[i-1]*inv[i])%mod;\n\t}\n\tpowt[0]=1;\n\tpowt[1]=3;\n\tpowtwo[0]=1;\n\tpowtwo[1]=2;\n\tfor(i=2 ; i<=1000000 ; i++)\n\t{\n\t\tpowt[i]=(3*powt[i-1])%mod;\n\t\tpowtwo[i]=(2*powtwo[i-1])%mod;\n\t}\n\tif(k>m)\n\t{\n\t\tll temp=k;\n\t\tk=m;\n\t\tm=temp;\n\t}\n\tfor(i=0 ; i<=min(k,m)-1 ; i++)\n\t{\n\t\tdp[i]=powtwo[i];\n\t}\n\tif(m==k)\n\t{\n\t\tdp[min(k,m)]=powtwo[min(k,m)]-2;\n\t}\n\telse\n\t{\n\t\tdp[min(k,m)]=powtwo[min(k,m)]-1;\n\t}\n\tfor(i=min(k,m)+1 ; i<=max(k,m) ; i++)\n\t{\n\t\tdp[i]=(2*dp[i-1]-com(i-1,i-1)-com(i-1,i-k)+mod)%mod;\n\t}\n\tfor(i=max(k,m)+1 ; i<=m+k-2 ; i++)\n\t{\n\t\tdp[i]=(2*dp[i-1]-com(i-1,i-k)-com(i-1,m-1)+2*mod)%mod;\n\t}\n\n\tfor(i=0 ; i<=m+k-2 ; i++)\n\t{\n\t\tll add=1;\n\t\tadd=(add*com(n+i-2,n-2))%mod;\n\t\tadd=(add*dp[i])%mod;\n\t\tadd=(add*powt[m+k-i-2])%mod;\n\t\tans=(ans+add)%mod;\n\t}\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mms(x,l) memset(x,0,sizeof(x[0])*(l))\n#define mmp(x,y,l) memcpy(x,y,sizeof(y[0])*(l))\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=900005,M=1050005,L=6666666,P=1e9+7;\n\nint n,m,k,fac[N],ifac[N],p3[N],ans,X[M],Y[M],Z[M];\ninline int fpow(int a,int t){static int r;for(r=1;t;t>>=1,a=(ll)a*a%P)if(t&1)r=(ll)r*a%P;return r;}\ninline int C2(int n,int a,int b){return (ll)fac[n]*ifac[a]%P*ifac[b]%P*ifac[n-a-b]%P;}\n\nnamespace MaoFFT{\n\tconst double PI=acos(-1);\n\tstruct num{\n\t\tdouble r,i;\n\t\tnum(double _r=0,double _i=0){r=_r,i=_i;}\n\t\tinline friend num operator+(const num&a,const num&b){return num(a.r+b.r,a.i+b.i);}\n\t\tinline friend num operator-(const num&a,const num&b){return num(a.r-b.r,a.i-b.i);}\n\t\tinline friend num operator*(const num&a,const num&b){return num(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}\n\t\tinline friend num operator*(const num&a,const double&b){return num(a.r*b,a.i*b);}\n\t\tinline friend num operator/(const num&a,const double&b){return num(a.r/b,a.i/b);}\n\t\tinline num conj(){return num(r,-i);}\n\t\tinline num mult(){return num(-i,r);}\n\t};\n\tnum pol[L],*ed=pol;\n\tnum *ww[22],*iww[22],*_w;\n\tnum *nmalloc(int len){num*R=ed;ed+=len;return R;}\n\tvoid getwn(int lmax){\n\t\tfor(int i=1,j=1;j<=lmax;i++,j<<=1){\n\t\t\tww[i]=nmalloc(j);\n\t\t\tiww[i]=nmalloc(j);\n\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\tww[i][k]=num(cos(PI/j*k),sin(PI/j*k));\n\t\t\t\tiww[i][k]=ww[i][k].conj();\n\t\t\t}\n\t\t}\n\t}\n\tvoid fft(num a[],int n,int dft){\n\t\tint i,j,k,l,c=0;num u,v;\n\t\tfor(i=1,j=n>>1;i<n-1;i++){\n\t\t\tif(i<j)swap(a[i],a[j]);\n\t\t\tfor(k=n>>1;(j^=k)<k;k>>=1);\n\t\t}\n\t\tfor(l=2,c=1;l<=n;l<<=1,c++){\n\t\t\tif(dft==-1)_w=iww[c];else _w=ww[c];\n\t\t\tfor(i=l>>1,j=0;j<n;j+=l)for(k=0;k<i;k++){\n\t\t\t\tu=a[j+k],v=a[j+k+i]*_w[k];\n\t\t\t\ta[j+k]=u+v,a[j+k+i]=u-v;\n\t\t\t}\n\t\t}\n\t}\n\tinline int get(int x){\n\t\tint l=1;\n\t\twhile(l<=x)l<<=1;\n\t\treturn l;\n\t}\n\tvoid convol(int A[],int B[],int R[],int n){\n\t\tstatic int s1,s2,tmp[M];\n\t\ts1=s2=0;\n\t\tfor(int i=0;i<n;i++)s1+=A[i]?1:0,s2+=B[i]?1:0;\n\t\tstatic num x[M],y[M],tx[M],ty[M],p0,p1,q0,q1,u,v,s,t;\n\t\tmms(x,n),mms(y,n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i]=num(A[i]&32767,A[i]>>15);\n\t\t\ty[i]=num(B[i]&32767,B[i]>>15);\n\t\t}\n\t\tfft(x,n,1),fft(y,n,1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tu=x[i],v=x[i?n-i:0].conj(),s=y[i],t=y[i?n-i:0].conj();\n\t\t\tp0=(u+v)/2,p1=(v-u).mult()/2,q0=(s+t)/2,q1=(t-s).mult()/2;\n\t\t\ttx[i]=p0*q0,ty[i]=p0*q1+p1*q0+p1*q1.mult();\n\t\t}\n\t\tmmp(x,tx,n),mmp(y,ty,n);\n\t\tfft(x,n,-1),fft(y,n,-1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tp0=x[i],p1=y[i];\n\t\t\tp0.r/=n,p1.r/=n,p1.i/=n;\n\t\t\tll a=p0.r+0.5,b=p1.r+0.5,c=p1.i+0.5;\n\t\t\ta%=P,b%=P,c%=P;\n\t\t\tR[i]=(a+(b<<15)+(c<<30))%P;\n\t\t}\n\t}\n};\n\nint main(){\n\tcin>>n>>m>>k;\n\tfac[0]=p3[0]=1;\n\tfor(int i=1;i<=n+m+k;i++)fac[i]=(ll)fac[i-1]*i%P,p3[i]=p3[i-1]*3u%P;\n\tifac[n+m+k]=fpow(fac[n+m+k],P-2);\n\tfor(int i=n+m+k;i>=1;i--)ifac[i-1]=(ll)ifac[i]*i%P;\n\tint len=MaoFFT::get(m+k);\n\tMaoFFT::getwn(len);\n\tfor(int i=0;i<=m;i++)X[i]=ifac[i];\n\tfor(int i=0;i<=k;i++)Y[i]=ifac[i];\n\tMaoFFT::convol(X,Y,Z,len);\n\tfor(int i=0;i<=m+k;i++)\n\t\tans=(ans+(ll)Z[i]*p3[m+k-i]%P*fac[n+i-1]%P*ifac[n-1])%P;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\nint A, B, C;\nlong D[600001];\nlong f[900001];\nlong g[900001];\n\nlong powmod(long b, long e) {\n\tif (e == 0) return 1;\n\tif (e % 2 == 1) return b * powmod(b, e - 1) % M;\n\tlong t = powmod(b, e / 2);\n\treturn t * t % M;\n}\n\nvoid pre() {\n\tD[0] = 1;\n\tfor (int i = 0; i < B + C; ++i) {\n\t\tD[i + 1] = D[i] * 3 % M;\n\t}\n\tconst int N = A + B + C;\n\t\n\tf[0] = 1;\n\tfor (int i = 0; i <= N; ++i) {\n\t\tf[i + 1] = f[i] * (i + 1) % M;\n\t}\n\t\n\tg[N] = powmod(f[N], M - 2);\n\tfor (int i = N; i > 0; --i) {\n\t\tg[i - 1] = g[i] * i % M;\n\t}\n}\n\nlong combi(long n, long r) {\n\tif (r < 0 || r > n) return 0;\n\treturn f[n] * g[r] % M * g[n - r] % M;\n}\n\nint main() {\n\tcin >> A >> B >> C;\n\t--A;\n\n\tpre();\n\n\tlong sum = 0;\n\tlong k = 1;\n\tfor (int s = 0; s <= B + C; ++s) {\n\t\tsum += D[B + C - s] * f[A + s] % M * g[s] % M * k % M;\n    \tsum %= M;\n    \tk = 2 * (k + M) - combi(s, B) - combi(s, C);\n    \tk %= M;\n\t}\n\n\tcout << sum * g[A] % M << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\nconst int mod = 1e9+7;\n\nll p3[900005], dp[900005], sum[900005];\nll f1[900005], f2[900005];\nll pow2(ll a, ll b){\n    ll res = 1;\n    while(b){\n        if(b%2) res = res*a%mod;\n        a = a*a%mod;\n        b/=2;\n    }\n    return res;\n}\nll C(int a, int b){\n    return f1[a]*1ll*f2[b]%mod*f2[a-b]%mod;\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, k;\n    cin >> n >> m >> k;\n    f1[0] = f2[0] = 1;\n    for(int i=1;i<=n+m+k;i++) f1[i] = f1[i-1]*1ll*i%mod;\n    for(int i=1;i<=n+m+k;i++) f2[i] = pow2(f1[i], mod-2);\n    p3[0] = 1;\n    for(int i=1;i<=n+m+k;i++) p3[i] = p3[i-1]*3%mod;\n\n    ll sum = 1, ans = 0;\n    int l = 0, r = 0;\n    for(int i=0;i<=m+k;i++){\n        if(r > m){\n            sum = (sum - C(i-1, m) + mod)%mod;\n            r--;\n        }\n        if(i-l > k){\n            sum = (sum - C(i-1, k) + mod)%mod;\n            l++;\n        }\n        ll res = C(i+n-1, i)*1ll*sum%mod*p3[n+m+k-i-n]%mod;\n        ans = (ans + res)%mod;\n        sum = sum*2%mod;\n        r++;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 5, MOD = 1e9 + 7;\nint fac[N], rev[N];\nint mpow(int x, int n) {\n\tint res = 1;\n\twhile (n) {\n\t\tif (n & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint C(int n, int m) {\n\treturn 1LL * fac[n] * rev[m] % MOD * rev[n - m] % MOD;\n}\nint main() {\n\tfac[0] = rev[0] = 1;\n\tfor (int i = 1; i < N; ++ i) {\n\t\tfac[i] = 1LL * fac[i - 1] * i % MOD;\n\t\trev[i] = mpow(fac[i], MOD - 2);\n\t}\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tif (m > k) swap(m, k);\n\tint ans = 0;\n\tint l = 0, r = 0, sum = 1;\n\tfor (int s = 0; s <= m + k; ++ s) {\n\t\tint res = 1LL * C(s + n - 1, s) * mpow(3, m + k - s) % MOD;\n\t\tint L = max(0, s - k), R = min(m, s);\n\t\twhile (l > L) (sum += C(s, -- l)) %= MOD;\n\t\twhile (r < R) (sum += C(s, ++ r)) %= MOD;\n\t\twhile (l < L) (sum += MOD - C(s, l ++)) %= MOD;\n\t\twhile (r > R) (sum += MOD - C(s, r --)) %= MOD;\n\t\t(ans += 1LL * res * sum % MOD) %= MOD;\n\t\tsum = (2LL * sum + MOD - C(s, l) + MOD - C(s, r)) % MOD;\n\t\tl ++;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst long long mod=1e9+7;\nlong long jc[6060606],_jc[6060606];\nlong long pow(long long n,long long k)\n{\n\tlong long ret=1;\n\twhile(k>0)\n\t{\n\t\tif(k&1)\n\t\t\tret=ret*n%mod;\n\t\tn=n*n%mod;\n\t\tk/=2;\n\t}\n\treturn ret;\n}\nlong long C(int n,int m)\n{\n\treturn jc[n]*_jc[m]%mod*_jc[n-m]%mod;\n}\nint main()\n{\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tjc[0]=1;\n\t_jc[0]=1;\n\tfor(int i=1;i<=n+m+k;i++)\n\t{\n\t\tjc[i]=jc[i-1]*i%mod;\n\t\t_jc[i]=pow(jc[i],mod-2);\n\t}\n\tlong long tmp=1,ans=0;\n\tfor(int i=0;i<=m+k;i++)\n\t{\n\t\tans=(ans+C(n+i-1,i)*tmp%mod*pow(3,m+k-i)%mod)%mod;\n\t\ttmp*=2;\n\t\tif(i+1>k)\n\t\t\ttmp-=C(i,i-k); \n\t\tif(i+1>m)\n\t\t\ttmp-=C(i,m);\n\t\ttmp+=2*mod;\n\t\ttmp%=mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, l, r) for(int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for(int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\nusing namespace std;\n\nbool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}\nbool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n    int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int Mod = 1e9 + 7, N = 1e6 + 1e3;\n\ntypedef long long ll;\n\nll fac[N], ifac[N], pow3[N];\n\nll fpm(ll x, int power) {\n\tll res = 1;\n\tfor (; power; power >>= 1, (x *= x) %= Mod)\n\t\tif (power & 1) (res *= x) %= Mod;\n\treturn res;\n}\n\nll C(int m, int n) {\n\tif (m > n || n < 0 || m < 0) return 0;\n\t//cout << fac[n] << ' ' << ifac[m] << ' ' << ifac[n - m] << endl;\n\treturn fac[n] * ifac[m] % Mod * ifac[n - m] % Mod;\n}\n\nint n, m, k, tot;\n\nvoid Init(int maxn) {\n\tfac[0] = pow3[0] = 1; \n\tFor (i, 1, maxn) fac[i] = fac[i - 1] * i % Mod, pow3[i] = pow3[i - 1] * 3 % Mod;\n\tifac[maxn] = fpm(fac[maxn], Mod - 2);\n\tFordown (i, maxn - 1, 0) ifac[i] = ifac[i + 1] * (i + 1) % Mod;\n}\n\nint main () {\n\tFile();\n\tcin >> n >> m >> k; tot = n + m + k;\n\tInit(tot);\n\n\tll ans = 0;\n\tFor (x, 0, m)\n\t\tFor (y, 0, k)\n\t\t\t(ans += pow3[tot - (n + x + y)] * C(n - 1, (n - 1) + x + y) % Mod * C(x, x + y) % Mod) %= Mod;\n\tprintf (\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=900010;\nconst ll mo=1e9+7;\nll N,M,K;\nll frac[maxn],inv[maxn];\nll ans,sum;\n\nll powmod(ll a,ll b)\n{\n\tll ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1)\tans=(ans*a)%mo;\n\t\ta=(a*a)%mo;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nll C(ll a,ll b)\n{\n\tll ans=frac[a];\n\tans=(ans*inv[b])%mo;\n\tans=(ans*inv[a-b])%mo;\n\treturn ans;\n}\nint main()\n{\n\tcin>>N>>M>>K;\n\tfrac[0]=1;\n\tinv[0]=1;\n\tfor (int i=1;i<=900000;i++)\n\t\tfrac[i]=(frac[i-1]*i)%mo;\n\tinv[900000]=powmod(frac[900000],mo-2);\n\tfor (int i=899999;i>=1;i--)\n\t\tinv[i]=(inv[i+1]*(i+1))%mo;\n\tsum=1;\n\tfor (int q=0;q<=M+K;q++)\n\t{\n\t\tans=(ans+(((sum*C(q+N-1,N-1))%mo)*powmod(3LL,M+K-q))%mo)%mo;\n\t\tsum=(sum*2LL)%mo;\n\t\tif (q==M+K)\n\t\t\tcontinue;\n\t\tif (q>=M)\n\t\t\tsum=(sum-C(q,M)+mo)%mo;\n\t\tif (q>=K)\n\t\t\tsum=(sum-C(q,K)+mo)%mo;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic long MOD = 1_000_000_007;\n\tstatic long[] pow3 = new long[1_000_000];\n\tstatic long[] fact = new long[1_000_000];\n\tstatic long[] finv = new long[1_000_000];\n\tstatic int N, M, K;\n\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tK = sc.nextInt();\n\t\tif (N > 1000 || M > 1000 || K > 1000) return;\n\t\tpow3[0] = 1;\n\t\tfact[0] = 1;\n\t\tfinv[0] = inv(1);\n\t\tfor (int i = 1; i < pow3.length; ++i) {\n\t\t\tpow3[i] = pow3[i - 1] * 3 % MOD;\n\t\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\t\tfinv[i] = inv(fact[i]);\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i <= M; ++i) {\n\t\t\tfor (int j = 0; j <= K; ++j) {\n\t\t\t\tans += solve(i, j);\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long solve(int b, int c) {\n\t\tlong ret = pow3[M - b] * pow3[K - c] % MOD;\n\t\tret *= fact[N - 1 + b + c];\n\t\tret %= MOD;\n\t\tret *= finv[N - 1];\n\t\tret %= MOD;\n\t\tret *= finv[b];\n\t\tret %= MOD;\n\t\tret *= finv[c];\n\t\tret %= MOD;\n\t\treturn ret;\n\t}\n\n\tstatic long inv(long v) {\n\t\treturn pow(v, MOD - 2);\n\t}\n\n\tstatic long pow(long v, long p) {\n\t\tif (p == 0) return 1;\n\t\tif (p == 1) return v;\n\t\tlong ret = pow(v, p / 2);\n\t\tret *= ret;\n\t\tret %= MOD;\n\t\tif (p % 2 == 1) {\n\t\t\tret *= v;\n\t\t\tret %= MOD;\n\t\t}\n\t\treturn ret;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//Tanuj Khattar\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int>   II;\ntypedef vector< II >      VII;\ntypedef vector<int>     VI;\ntypedef vector< VI > \tVVI;\ntypedef long long int \tLL;\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(a) (int)(a.size())\n#define ALL(a) a.begin(),a.end()\n#define SET(a,b) memset(a,b,sizeof(a))\n\n#define si(n) scanf(\"%d\",&n)\n#define dout(n) printf(\"%d\\n\",n)\n#define sll(n) scanf(\"%lld\",&n)\n#define lldout(n) printf(\"%lld\\n\",n)\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\n//FILE *fin = freopen(\"in\",\"r\",stdin);\n//FILE *fout = freopen(\"out\",\"w\",stdout);\nconst int MOD = int(1e9)+7;\nconst int N = int(1e6)+10;\nint add(int a,int b){\n  a = (a + b)%MOD;\n  if(a > MOD)a -= MOD;\n  return a;\n}\nint sub(int a,int b){\n  a = (a - b);\n  if(a < 0)a += MOD;\n  return a;\n}\nint mul(int a,int b){\n  a = (a*1ll*b)%MOD;\n  return a;\n}\nint fact[N],inv[N],f[N];\nint nCr(int n,int r){\n  if(n < r)return 0;\n  return mul(fact[n],mul(inv[r],inv[n-r]));\n}\nint power(int a,int p){\n  int ret=1;\n  while(p){\n    if(p&1)ret = mul(ret,a);\n    a = mul(a,a);\n    p/=2;\n  }\n  return ret;\n}\nint main()\n{\n  fact[0]=inv[0]=1;\n  for(int i=1;i<N;i++)\n    fact[i] = mul(fact[i-1],i);\n  for(int i=1;i<N;i++)\n    inv[i] = power(fact[i],MOD-2);\n  int n,m,k;\n  si(n);si(m);si(k);\n  int ans = power(3,m+k); f[0] = 1;\n  for(int s = 1;s <= m+k;s++){\n    f[s] = add(f[s-1],f[s-1]);\n    if(s > m)\n      f[s] = sub(f[s],nCr(s-1,m));\n    if(s >= k)\n      f[s] = sub(f[s],nCr(s-1,k));\n    ans = add(ans,mul(mul(f[s],nCr(n+s-1,s)),power(3,m+k-s)));\n  }\n  dout(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1e9+7;\n\nint n, m, k;\nll fac[900100];\nll fnv[900100];\nll f[600100];\nll p[600100];\n\nll po(ll a, ll n) {\n    if (!n) return 1;\n    ll t = po(a,n/2);\n    return t*t%MOD*(n%2?a:1)%MOD;\n}\n\nll comb(ll n, ll r) {\n    if (r<0||r>n) return 0;\n    return fac[n]*fnv[r]%MOD*fnv[n-r]%MOD;\n}\n\nint main() {\n    int i;\n    scanf(\"%d%d%d\",&n,&m,&k);\n    fac[0] = 1; for (i=1;i<=n+m+k;i++) fac[i]=fac[i-1]*i%MOD;\n    for (i=0;i<=n+m+k;i++) fnv[i]=po(fac[i],MOD-2);\n    f[m+k] = comb(m+k,m); for (i=m+k-1;i>=0;i--) f[i] = (MOD+1)/2*(f[i+1]+comb(i,i-m)+comb(i,k))%MOD;\n    p[0] = 1; for (i=1;i<=m+k;i++) p[i]=p[i-1]*3%MOD;\n    ll ans = 0;\n    for (i=0;i<=m+k;i++) ans = ans+comb(n-1+i,n-1)*p[m+k-i]%MOD*f[i]%MOD;\n    printf(\"%lld\\n\",ans%MOD);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define int long long\n\nusing namespace std;\ntypedef long long LL;\nconst int N=1000005;\nconst int MOD=1e9+7;\n\nint n,m,k,ans,fac[N],inv[N],sum;\n\ninline int fast_pow(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1){\n\t\tif(y&1) ret=1ll*ret*x%MOD;\n\t\tx=1ll*x*x%MOD;\n\t}\n\treturn ret;\n}\n\ninline int C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%MOD*inv[x-y]%MOD;\t\n}\n\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&m,&k);\n\tfac[0]=inv[0]=1; sum=n+m+k;\n\tfor(int i=1;i<=sum;i++) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[sum]=fast_pow(fac[sum],MOD-2);\n\tfor(int i=sum-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n\tfor(int i=n;i<=sum;i++){\n\t\tint now=0;\n\t\tfor(int j=max(i-n-m,1ll*0);j<=min(k,i-n);j++)\n\t\t\t(now+=C(i-n,j))%=MOD;\n\t\tans+=now%MOD*C(i-1,n-1)%MOD*fast_pow(3,sum-i)%MOD;\n\t\tans%=MOD;\n\t}\t\n//\tfor(int i=n;i<=sum;i++) {\n//\t\t(ans+=1ll*C(i-1,n-1)*fast_pow(2,i-n)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tif(i==8) cout<<ans<<endl;\n//\t\tif(n+k+1<=i) \n//\t\t\t(ans-=1ll*C(i-1,n-1)*C(i-n,k+1)%MOD*fast_pow(2,i-n-k-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tif(i==8) cout<<ans<<endl;\n//\t\tif(n+m+1<=i)\n//\t\t\t(ans-=1ll*C(i-1,n-1)*C(i-n,m+1)%MOD*fast_pow(2,i-n-m-1)%MOD*fast_pow(3,sum-i)%MOD)%=MOD;\n//\t\tcout<<ans<<endl;\n//\t}\n//\tfor(int i=n+m;i<sum;i++){\n//\t\t(ans-=1ll*now*fast_pow(3,sum-n-m)%MOD)%=MOD;\n//\t\tnow=1ll*now*i%MOD; now=(now+C(n+m,i-n-m+1))%MOD;\t\n//\t}\n//\tnow=1;\n//\tfor(int i=n+k;i<sum;i++){\n//\t\t(ans-=1ll*now*fast_pow(3,sum-n-k)%MOD)%=MOD;\n//\t\tnow=1ll*now*i%MOD; now=(now+C(n+k,i-n-k+1))%MOD;\n//\t}\t\n\tprintf(\"%lld\\n\",(ans+MOD)%MOD);\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define SF scanf\n#define PF printf\n#define MAXN 900010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nll inv[MAXN],fac[MAXN],pow3[MAXN];\nll fsp(ll x,int y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\t\n\t}\n\treturn res;\n}\nll C(int x,int y){\n\treturn fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nint main(){\n\tint n,m,k;\n\tSF(\"%d%d%d\",&n,&m,&k);\n\tpow3[0]=1;\n\tfac[0]=1;\n\tfor(int i=1;i<=n+m+k;i++){\n\t\tpow3[i]=pow3[i-1]*3ll%MOD;\t\n\t\tfac[i]=fac[i-1]*i%MOD;\n\t}\n\tinv[n+m+k]=fsp(fac[n+m+k],MOD-2);\t\n\tfor(int i=n+m+k;i>0;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\tn--;\n\tif(m<k)\n\t\tswap(m,k);\n\tll j=1,ans=0;\n\tfor(int i=0;i<=m+k;i++){\n\t\tans=(ans+C(n+i,n)*pow3[m+k-i]%MOD*j)%MOD;\t\n\t\tif(i<k)\n\t\t\tj=j*2ll%MOD;\n\t\telse if(i<m)\n\t\t\tj=(j*2ll-C(i,k))%MOD;\n\t\telse \t\n\t\t\tj=(j*2ll-C(i,k)-C(i,m))%MOD;\n\t}\n\tans=(ans+MOD)%MOD;\n\tPF(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint n, m, k;\nint f[4][1010101];\nint pow1[1010101], pow2[1010101];\nint g[4][4][1010101];\nint fac[1010101], rev[1010101], ifac[1010101];\n\nint c(int a, int b)\n{\n\tlong long ret = fac[b];\n\tret = ret * ifac[a];\n\tret %= MOD;\n\tret = ret * ifac[b - a];\n\tret %= MOD;\n\treturn (int)ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tpow1[0] = fac[0] = ifac[0] = rev[0] = pow2[0] = 1;\n\tifac[1] = rev[1] = 1;\n\tfor(int i = 1; i <= n + m + k; ++i)\n\t{\n\t\tpow1[i] = pow1[i - 1] * 3ll % MOD;\n\t\tpow2[i] = pow2[i - 1] * 2 % MOD;\n\t\tfac[i] = fac[i - 1] * 1ll * i % MOD;\n\t\tif(i >= 2)\n\t\t{\n\t\t\trev[i] = MOD - 1ll * (MOD / i) * rev[MOD % i] % MOD;\n\t\t\tifac[i] = 1ll * ifac[i - 1] * rev[i] % MOD;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i <= m; ++i)\n\t{\n\t\tans += 1ll * pow2[i] * c(i, i + n - 1) % MOD * pow1[m + k - i] % MOD;\n\t\tif(ans >= MOD)\n\t\t\tans -= MOD;\n\t}\n\tint lst = pow2[m];\n\tfor(int i = m + 1; i <= m + k; ++i)\n\t{\n\t\tlst = lst<<1;\n\t\tlst -= c(m, i - 1);\n\t\tif(lst >= MOD)\n\t\t\tlst -= MOD;\n\t\tif(i > k)\n\t\t\tlst -= c(i - k - 1, i - 1);\n\t\twhile(lst < 0)\n\t\t\tlst += MOD;\n\t\twhile(lst >= MOD)\n\t\t\tlst -= MOD;\n\t\tans += 1ll * lst * c(i, i + n - 1) % MOD * pow1[m + k - i] % MOD;\n\t\tif(ans >= MOD)\n\t\t\tans -= MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nconstexpr int N = 900'005;\nconstexpr int P = 1'000'000'007;\n\nstd::vector <int> fac, inv, fnv, pw3;\nint n, m, k, sum, ans;\n\nint binom (int x, int y) {\n  if (x < y) return 0;\n  return 1LL * fac[x] * fnv[y] % P * fnv[x-y] % P;\n}\n\nint main () {\n\n  fac.assign (N, 1);\n  inv.assign (N, 1);\n  fnv.assign (N, 1);\n  pw3.assign (N, 1);\n  pw3[1] = 3;\n  for (int i = 2; i < N; ++i) {\n    fac[i] = 1LL * fac[i-1] * i % P;\n    inv[i] = 1LL * inv[P%i] * (P-P/i) % P;\n    fnv[i] = 1LL * fnv[i-1] * inv[i] % P;\n    pw3[i] = 3LL * pw3[i-1] % P;\n  }\n  std::cin >> n >> m >> k;\n  if (m < k) std::swap (m, k);\n  sum = 1; ans = 0;\n  for (int s = 0; s <= m + k; ++s) {\n    ans += 1LL * binom (n - 1 + s, n - 1) * pw3[m + k - s] % P * sum % P;\n    ans %= P;\n    if (s < k) {\n      sum = sum * 2LL % P;\n    } else if (s < m) {\n      sum = (sum * 2LL - binom (s, k) + P) % P;\n    } else {\n      sum = (sum * 2LL - binom (s, k) - binom (s, m) + P + P) % P;\n    }\n  }\n  std::cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\nconst int MAX = 300001;\nlong N,M,K;\nlong fact[MAX];\n\nlong pow(long a,long n,long p){\n\tif(n == 0) return 1;\n\tif(n == 1) return a%p;\n\tif(n%2 == 0) {\n\t\tlong t=pow(a,n/2,p);\n\t\treturn (t*t)%p;\n\t}\n\telse {\n\t\tlong t=pow(a,n-1,p);\n\t\treturn (a*t)%p;\n\t}\n}\n\nlong fact_nondiv(long n, long p){\n\tif(n == 0 || n == 1) return 1;\n\tlong a = fact_nondiv(n/p, p);\n\tlong b = fact[n%p];\n\n\tif(n/p%2) return a*(p-b)%p;\n\telse return a*b%p;\n}\n\nlong fact_numdiv(long n, long p){\n\tlong x = 0;\n\twhile(n > 0){\n\t\tx += n/p;\n\t\tn /= p;\n\t}\n\treturn x;\n}\n\nlong mod_inv(long a, long m){\n\tint p=m,q=a%m;\n\tstack<int> s;\n\ts.push(p);\n\ts.push(q);\n\twhile(q>0){\n\t\tint r = p%q;\n\t\ts.push(r);\n\t\tp = q;\n\t\tq = r;\n\t}\n\ts.pop();s.pop();\n\tint x=1,y=0;\n\twhile(!s.empty()){\n\t\tq = p;\n\t\tp = s.top();\n\t\ts.pop();\n\t\tint z = x-(p/q)*y;\n\t\tx = y;\n\t\ty = z;\n\t}\n\treturn (y+m)%m;\n}\n\n\nlong comb(long n, long k, long p){\n\tif(n == 0 || k == 0 || n < k) return 1;\n\tif(fact_numdiv(n,p) > fact_numdiv(k,p) + fact_numdiv(n-k,p)){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn fact_nondiv(n,p)*mod_inv(fact_nondiv(k,p)*fact_nondiv(n-k,p)%p,p)%p;\n\t}\n}\n\nint main(){\n\tlong p = 1000000007;\n\tfact[0] = 1;\n\tfor(int i=1; i<MAX; i++){\n\t\tfact[i] = fact[i-1]*i%p;\n\t}\n\tcin >> N >> M >> K;\n\tlong res = 0;\n\tlong s = 1;\n\tfor(int i=N; i<=N+M+K; i++){\n\t\tlong x = comb(i-1,N-1,p);\n\t\tlong y = pow(3,N+M+K-i,p);\n\t\tlong z = s;\n\t\t//cout << x << \" \" << y << \" \" << z << endl;\n\t\tres = (res + (x*y%p)*z%p)%p;\n\t\tlong l=0,r=0;\n\t\tif(i-N >= K) l = comb(i-N, i-N-K, p);\n\t\tif(i-N >= M) r = comb(i-N, M, p);\n\t\t//cout << l << \" \" <<  r << endl;\n\t\ts = (s*2-l-r+p*2)%p;\n\t}\n\tcout << res << endl;\n\t/*\n\tcin >> N >> M;\n\tcout << comb(N,M,p) << endl;\n\t*/\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int Max=1e5+1;\nconst long long Mod=1e9+7;\nint cnt=0,M;\nlong long P[Max*3+10]={},inv[Max*3+10]={},Pow[Max*3+10]={};\ninline long long C(int n,int m){return P[n]*inv[n-m]%Mod*inv[m]%Mod;}\nint main(){\n\tP[0]=P[1]=1; for(int i=2;i<=Max*3;i++) P[i]=i*P[i-1],P[i]%=Mod;\n\tinv[0]=inv[1]=1; for(int i=2;i<=Max*3;i++) inv[i]=inv[Mod%i]*(Mod-Mod/i)%Mod;\n\tfor(int i=2;i<=Max*3;i++) inv[i]=inv[i]*inv[i-1]%Mod;\n\tPow[0]=1; for(int i=1;i<=Max*3;i++) Pow[i]=Pow[i-1]*3%Mod;\n\tint N,M,Q; scanf(\"%d%d%d\",&N,&M,&Q);\n\tlong long Ans=0,Sum1=0,Sum2=0;\n\tfor(int i=N;i<=N+M+Q+3-1;i++){\n\t\tif(i==N){\n\t\t\tfor(int j=0;j<i-N-Q;i++) Sum1+=C(i-N,j);\n\t\t    for(int j=max(i-N-Q,0);j<=min(M,i-N);j++) Sum2+=C(i-N,j);\n\t\t}else{\n            if(i-N-Q-2>=0) Sum1=(Sum1*2%Mod-C(i-1-N,i-N-Q-2)+Mod)%Mod;\n            Sum2=(Sum2*2%Mod-C(i-1-N,min(M,i-1-N))+Mod)%Mod;\n\t\t\tif(max(i-N-Q,0)>max(i-N-Q-1,0)) Sum1+=C(i-N,i-N-Q-1),Sum1%=Mod;\n\t\t\tif(min(M,i-N-1)<min(M,i-N)) Sum2+=C(i-N,min(M,i-N)),Sum2%=Mod;\n\t\t}\n\t\tAns+=C(i-1,N-1)*Pow[N+M+Q-i]%Mod*(Sum2-Sum1+Mod)%Mod,Ans%=Mod;\n//\t\tfor(int j=max(i-N-Q,0);j<=min(M,i-N);j++)\n//\t\t Ans+=C(i-1,N-1)*C(i-N,j)%Mod*Pow[N+M+Q-i]%Mod,Ans%=Mod;  \n\t}\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define lld long long\n#define pii pair<int,int>\n#define pll pair<lld,lld>\n#define pb push_back\n#define next nextt\n#define Inf 1000000000\n#define Linf 1000000000000000000LL\n#define Mod 1000000007\n\nusing namespace std;\n\nint N,M,K; lld ans;\nlld fact[900002],inv[900002],three[900002];\n\nlld mul(lld x,lld y){\n\tif(y == 0) return 1;\n\tlld tmp = mul(x,y/2);\n\ttmp *= tmp; tmp %= Mod;\n\tif(y%2 == 1){\n\t\ttmp *= x;\n\t\ttmp %= Mod;\n\t}\n\treturn tmp;\n}\nlld comb(lld x,lld y){\n\treturn (fact[x]*inv[x-y]%Mod)*inv[y]%Mod;\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\tfact[0] = inv[0] = three[0] = 1;\n\tfor(int i=1; i<=900000; i++){\n\t\tfact[i] = (fact[i-1]*i)%Mod;\n\t\tinv[i] = mul(fact[i],Mod-2);\n\t\tthree[i] = (three[i-1]*3)%Mod;\n\t}\n\tfor(int i=0; i<=M; i++){\n\t\tfor(int j=0; j<=K; j++){\n\t\t\tint cnt = (N-1)+i+j;\n\t\t\tlld tmp = comb(cnt,N-1);\n\t\t\ttmp *= comb(i+j,i); tmp %= Mod;\n\t\t\ttmp *= three[M-i]; tmp %= Mod;\n\t\t\ttmp *= three[K-j]; tmp %= Mod;\n\t\t\tans += tmp;\n\t\t\tans %= Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <deque>\n#include <queue>\n#include <string>\n#include <tuple>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\n#define pb push_back\n#define pbk pop_back\n#define sz(a) ((int) (a).size())\n#define all(a) (a).begin(), (a).end()\n#define mp make_pair\n#define mt make_tuple\n#define fs first\n#define sc second\n#define next hunext\n#define prev huprev\n#define rank hurank\n#define hash huhash\n\n#ifdef LOCAL42\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = int(1e9);\nconst ll linf = ll(1e18);\nconst double eps = 1e-9;\nconst double pi = 4 * atan(1.0);\nconst int MOD = int(1e9) + 7;\nconst int P = 500;\nconst int N = int(4e6);\nconst int K = 4;\n\nstruct base {\n    \n    double a, b;\n    \n    base() : a(0), b(0) {}\n    \n    base(double a, double b = 0) : a(a), b(b) {}\n    \n};\n\ninline base operator + (const base& a, const base& b) {\n    return base(a.a + b.a, a.b + b.b);\n}\n\ninline base operator - (const base& a, const base& b) {\n    return base(a.a - b.a, a.b - b.b);\n}\n\ninline base operator * (const base& a, const base& b) {\n    return base(a.a * b.a - a.b * b.b, a.a * b.b + a.b * b.a);\n}\n\ninline base operator / (const base& a, double b) {\n    return base(a.a / b, a.b / b);\n}\n\nint maxv;\nint a[K][N], b[K][N], ab[K * 2][N];\nint f[N], rf[N];\nbase aa[N];\n\ninline int calc(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2 != 0) {\n            res = (1LL * res * a) % MOD;\n        }\n        a = (1LL * a * a) % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\ninline void fft(base* a, int n, bool fl) {\n    for (int i = 1, j = 0; i < n; ++i) {\n        int bit = n / 2;\n        for (; j >= bit; bit /= 2) {\n            j -= bit;\n        }\n        j += bit;\n        if (i < j) {\n            swap(a[i], a[j]);\n        }\n    }\n    for (int len = 2; len <= n; len *= 2) {\n        double ang = 2 * pi / len * (fl ? -1 : 1);\n        base wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            base w(1);\n            for (int j = 0; j < len / 2; ++j) {\n                base u = a[i + j], v = a[i + j + len / 2] * w;\n                a[i + j] = u + v;\n                a[i + j + len / 2] = u - v;\n                w = w * wlen;\n            }\n        }\n    }\n    if (fl) {\n        for (int i = 0; i < n; ++i) {\n            a[i] = a[i] / n;\n        }\n    }\n}\n\ninline void mult(int* a, int* b, int* c) {\n    for (int i = 0; i < maxv; ++i) {\n        aa[i].a = a[i];\n        aa[i].b = b[i];\n    }\n    fft(aa, maxv, false);\n    for (int i = 0; i < maxv; ++i) {\n        aa[i] = aa[i] * aa[i];\n    }\n    fft(aa, maxv, true);\n    for (int i = 0; i < maxv; ++i) {\n        c[i] = (c[i] + ll(aa[i].b + 0.5) / 2) % MOD;\n    }\n}\n\nint main() {\n#ifdef LOCAL42\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int n, m, k;\n    cin >> n >> m >> k;\n    f[0] = 1;\n    for (int i = 1; i <= n + m + k; ++i) {\n        f[i] = (1LL * f[i - 1] * i) % MOD;\n    }\n    rf[n + m + k] = calc(f[n + m + k], MOD - 2);\n    for (int i = n + m + k - 1; i >= 0; --i) {\n        rf[i] = (1LL * rf[i + 1] * (i + 1)) % MOD;\n    }\n    for (int i = 0; i <= m; ++i) {\n        int cur = rf[i];\n        for (int j = 0; j < K; ++j) {\n            a[j][i] = cur % P;\n            cur /= P;\n        }\n        assert(cur == 0);\n    }\n    for (int i = 0; i <= k; ++i) {\n        int cur = rf[i];\n        for (int j = 0; j < K; ++j) {\n            b[j][i] = cur % P;\n            cur /= P;\n        }\n        assert(cur == 0);\n    }\n    maxv = 1;\n    while (maxv < max(m, k) + 1) {\n        maxv *= 2;\n    }\n    maxv *= 2;\n    assert(maxv < N);\n    for (int i = 0; i < K; ++i) {\n        for (int j = 0; j < K; ++j) {\n            mult(a[i], b[j], ab[i + j]);\n        }\n    }\n    int ans = 0, pw3 = 1, inv3 = calc(3, MOD - 2);\n    for (int i = 0; i <= m + k; ++i) {\n        int sum = 0;\n        for (int j = 2 * K - 1; j >= 0; --j) {\n            sum = (1LL * sum * P + ab[j][i]) % MOD;\n        }\n        sum = (1LL * sum * pw3) % MOD;\n        sum = (1LL * sum * f[n - 1 + i]) % MOD;\n        ans += sum;\n        if (ans >= MOD) {\n            ans -= MOD;\n        }\n        pw3 = (1LL * inv3 * pw3) % MOD;\n    }\n    ans = (1LL * ans * calc(3, m + k)) % MOD;\n    ans = (1LL * ans * rf[n - 1]) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int maxn(1e6 + 10), Mod(1e9 + 7);\nint N, M, K, ans, fac[maxn], inv[maxn], Pow[maxn];\nint C(int n, int m) { return 1ll * fac[n] * inv[m] % Mod * inv[n - m] % Mod; }\nint Minus(int x, int y) { return (x - y + Mod) % Mod; }\nint Add(int x, int y) { return (x + y) % Mod; }\nint Mul(int x, int y) { return 1ll * x * y % Mod; }\nint fastpow(int x, int y)\n{\n\tint ans = 1;\n\tfor (; y; y >>= 1, x = 1ll * x * x % Mod)\n\t\tif (y & 1) ans = 1ll * ans * x % Mod;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &K), fac[0] = inv[0] = Pow[0] = 1;\n\tfor (int i = 1; i <= N + M + K; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tfor (int i = 1; i <= N + M + K; i++) Pow[i] = 1ll * Pow[i - 1] * 3 % Mod;\n\tinv[N + M + K] = fastpow(fac[N + M + K], Mod - 2);\n\tfor (int i = N + M + K - 1; i; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % Mod;\n\tfor (int i = 0, x = 1; i <= M + K; i++)\n\t{\n\t\tans = Add(ans, Mul(Mul(C(N + i - 1, N - 1), Pow[M + K - i]), x));\n\t\tif (i < K) x = (x + x) % Mod; else if (i < M) x = Minus((x + x) % Mod, C(i, K));\n\t\telse x = Minus(Minus((x + x) % Mod, C(i, K)), C(i, M));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Mod = 1e9 + 7;\nconst int N = 9e5;\n\nint n, m, k;\nlong long fac[N], vfac[N];\n\nlong long mpow( long long a, int b ) {\n\tlong long rt;\n\tfor( rt = 1; b; b >>= 1, a = (a * a) % Mod )\n\t\tif( b & 1 ) rt = (rt * a) % Mod;\n\treturn rt;\n}\nvoid init( int n ) {\n\tfac[0] = 1;\n\tfor( int i = 1; i <= n; i++ )\n\t\tfac[i] = (fac[i-1] * i) % Mod;\n\tvfac[n]  = mpow( fac[n], Mod - 2 );\n\tfor( int i = n - 1; i >= 0; i-- )\n\t\tvfac[i] = vfac[i+1] * (i + 1) % Mod;\n}\nlong long comb( int n, int m ) {\n\treturn fac[n] * vfac[n-m] % Mod * vfac[m] % Mod;\n}\nint main() {\n\tscanf( \"%d%d%d\", &n, &m, &k );\n\tif( m < k ) swap( m, k );\n\tinit( m + k + n );\n\tlong long sum = 0, ans = 0;\n\tfor( int s = 0; s <= m + k; s++ ) {\n\t\tif( s == 0 ) {\n\t\t\tsum = 1;\n\t\t} else if( s <= k ) {\n\t\t\tsum = (sum<<1) % Mod;\n\t\t} else if( s <= m ) {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1)) % Mod;\n\t\t} else {\n\t\t\tsum = ((sum<<1) + Mod - comb(s-1,s-k-1) + Mod - comb(s-1,m)) % Mod;\n\t\t}\n\t\tlong long sub = sum * comb(n-1+s,n-1) % Mod * mpow(3,m+k-s) % Mod;\n\t\tans = (ans + sub) % Mod;\n//\t\tprintf( \"s = %d sub = %lld\\n\", s, sub );\n\t}\n\tprintf( \"%lld\\n\", ans );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i=(a); i<(b); i++)\n#define sz(a) (int)a.size()\n#define de(a) cout<<#a<<\" = \"<<a<<endl\n#define dd(a) cout<<#a<<\" = \"<<a<<\" \"\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n//----\nconst int N=303030;\nconst int MOD=1e9+7;\nint a, b, c;\nll inv[N], jc[N];\nll fasp(ll a, ll b){\n\tll res=1;\n\tfor(; b; b>>=1, a=a*a%MOD)\n\t\tif(b&1)\n\t\t\tres=res*a%MOD;\n\treturn res;\n}\nll C(int n, int m){\n\treturn jc[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nvoid upd(ll &a, ll b){\n\ta=a+b;\n\tif(a>=MOD)a-=MOD;\n}\nint main(){\n\tjc[0]=1;\n\trep(i, 1, N)jc[i]=jc[i-1]*i%MOD;\n\tinv[N-1]=fasp(jc[N-1], MOD-2);\n\tfor(int i=N-2; ~i; i--)inv[i]=inv[i+1]*(i+1)%MOD;\n\tscanf(\"%d%d%d\", &a, &b, &c);\n\tll ans=0;\n\trep(i, 0, b+c+1){\n\t\trep(j, 0, min(b, i)+1){\n\t\t\tif(i-j>c)continue;\n\t\t\tupd(ans, C(i, j)*C(a-1+i, a-1)%MOD*fasp(3, b+c-i)%MOD);\n\t\t}\n\t}\n//\tans=0;\n//\trep(x, 0, b+1)rep(y, 0, c+1)upd(ans, C(a-1+x+y, a-1)*C(x+y, x)%MOD*fasp(3, b+c-x-y)%MOD), dd(x), dd(y), de(ans);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pii;\ntypedef pair<double,double> pdd;\n#define SQ(i) ((i)*(i))\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define SZ(i) int(i.size())\n#define FOR(i, j, k, in) for (int i=j ; i<k ; i+=in)\n#define RFOR(i, j, k, in) for (int i=j ; i>=k ; i-=in)\n#define REP(i, j) FOR(i, 0, j, 1)\n#define REP1(i,j) FOR(i, 1, j+1, 1)\n#define RREP(i, j) RFOR(i, j, 0, 1)\n#define ALL(_a) _a.begin(),_a.end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n#ifdef tmd\n#define TIME(i) Timer i(#i)\n#define debug(...) do{\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\" ,\";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,deque<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define TIME(i)\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n#endif\nclass Timer {\nprivate:\n    string scope_name;\n    chrono::high_resolution_clock::time_point start_time;\npublic:\n    Timer (string name) : scope_name(name) {\n        start_time = chrono::high_resolution_clock::now();\n    }\n    ~Timer () {\n        auto stop_time = chrono::high_resolution_clock::now();\n        auto length = chrono::duration_cast<chrono::microseconds>(stop_time - start_time).count();\n        double mlength = double(length) * 0.001;\n        debug(scope_name, mlength);\n    }\n};\n\nconst ll MOD = 1000000007;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int iNF = 0x3f3f3f3f;\nconst ll MAXN = 900005;\n\nll n, m, k;\nll fact[MAXN], inv[MAXN];\n\nll mpow (ll bs, ll ep) {\n    ll ret = 1;\n    while (ep) {\n        if (ep & 1) {\n            ret = ret * bs % MOD;\n        }\n        ep >>= 1;\n        bs = bs * bs % MOD;\n    }\n    return ret;\n}\n\nll cob (ll a, ll b) {\n    return fact[a] * inv[b] % MOD * inv[a-b] % MOD; \n}\n/********** Good Luck :) **********/\nint main()\n{\n    TIME(main);\n    IOS();\n    debug(mpow(2, 10));\n\n    cin >> n >> m >> k;\n\n    inv[0] = fact[0] = 1;\n    REP1 (i, MAXN - 1) {\n        fact[i] = fact[i-1] * i % MOD;\n        inv[i] = mpow(fact[i], MOD - 2);\n    }\n\n    ll ans = mpow(3, m + k);\n\n    ll sum = 1;\n    REP1 (i, m+k) {\n        sum = sum * 2 % MOD;\n        if (i > m) {\n            sum -= cob(i-1, m);\n        }\n        if (i > k) {\n            sum -= cob(i-1, k);\n        }\n        sum = (sum % MOD + MOD) % MOD;\n        debug(sum);\n        ll cur = sum * cob(n + i - 1, n - 1) % MOD * mpow(3, m + k - i) % MOD;\n        debug(cur);\n        ans = (ans + cur) % MOD;\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x7fffffff\n#define RG register\n#define int long long\n#define maxn 1000005\n#define maxm 205\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\ninline ll read(){\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while(ch > '9' || ch < '0') {if(ch == '-') f = -1;ch = getchar();}\n    while(ch >= '0' && ch <= '9'){x = x *10 + ch -'0';ch = getchar();}\n    return x * f;\n}\n \nint n, m, k, po[2][maxn];\nint qpow(int a, int b){\n\tint ans = 1, base = a;\n\twhile(b){\n\t\tif(b & 1) ans = 1ll * ans * base % mod;\n\t\tbase= 1ll * base * base % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nint fac[maxn], inv[maxn], ans;\nint C(int n, int m){return 1ll * fac[n] * inv[m] % mod *inv[n - m] % mod;}\nsigned main(){\n\tint i, j, x, l, r, mid;\n\tfac[0] = po[0][0] = po[1][0] = 1;\n\tfor(i = 1;i <= maxn - 5;i++) fac[i] = 1ll * fac[i - 1] * i % mod, po[0][i] = po[0][i - 1] * 2ll % mod, po[1][i] = po[1][i - 1] * 3ll % mod;\n\tinv[maxn - 5] = qpow(fac[maxn - 5], mod - 2);\n\tfor(i = maxn - 6;i >= 0;i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; \n\tn = read(), m = read(), k = read();\n\tint las = 1;\n\tfor(i = 0;i <= m + k;i++){\n\t\tans = (ans + 1ll * C(n + i - 1, n - 1) * po[1][m + k -i] % mod * las % mod) % mod;\n\t\tif(i + 1 <= m && i + 1 <= k) las = las * 2ll % mod;\n\t\telse{\n\t\t\tif(i + 1 <= k) las = ((las * 2ll - C(i, m)) % mod + mod) % mod; \n\t\t\telse if(i + 1 <= m) las = ((las * 2ll - C(i, i - k)) % mod + mod) % mod;\n\t\t\telse las = ((las * 2ll - C(i, i - k)) % mod + mod - C(i, m) ) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int N=1000005,Mod=1e9+7;\ninline int qpow(int a,int b){\n\tint ans=1;\n\twhile (b){\n\t\tif (b&1) ans=1ll*ans*a%Mod;\n\t\ta=1ll*a*a%Mod,b>>=1; \n\t}\n\treturn ans;\n}\nint fac[N],inv[N],pow3[N];\ninline void init_binom(){\n\tfac[0]=1;for (int i=1;i<=1000000;i++) fac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[1000000]=qpow(fac[1000000],Mod-2);\n\tfor (int i=999999;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%Mod;\n\tpow3[0]=1;for (int i=1;i<=1000000;i++) pow3[i]=1ll*pow3[i-1]*3ll%Mod;\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint n,m,k;\ninline int calc(int i){\n\tint ans=0;\n\tfor (int x=0;x<=m;x++)\n\t\tif (i-x<=k&&i-x>=0) ans=(ans+C(i,x))%Mod;\n\treturn ans;\n}\nint main (){\n\tinit_binom();\n\tscanf (\"%d%d%d\",&n,&m,&k);\n\tint ans=0;\n\tfor (int i=0;i<=m+k;i++){\n\t\tans=(ans+1ll*C(n+i-1,n-1)*pow3[m+k-i]%Mod*calc(i)%Mod)%Mod;\n\t}\n\tprintf (\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nconst int mod=1000000007;\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\ts=s*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nll fact[3341919];\nll Comb(ll x,ll y){\n\treturn fact[x]*modInv(fact[y])%mod*modInv(fact[x-y])%mod;\n}\n\nint main(){\n\tll n=read()+1,m=read()+1,k=read()+1;\n\tassert(n<=1001);\n\tassert(m<=1001);\n\tassert(k<=1001);\n\tfact[0]=1;\n\tFOR(i,1,3341919)\n\t\tfact[i]=fact[i-1]*i%mod;\n\tll ans=0;\n\tREP(b,m)\n\t\tREP(c,k)\n\t\t\tans=(ans+Comb(n-2+b+c,n-2)*Comb(b+c,b)%mod*modPow(3,m-1-b+k-1-c))%mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=900010;\n#define ll long long \nint n,m,k;\nll fac[N],ifac[N],p[N]; \nll mul(ll x,ll y){\n    return (1ll*x*y)%mod;\n}\nll add( ll x , ll y ) {\n    return ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n    int ans = 1 , base = a ;\n    while( b ) {\n        if( b&1 ) ans = mul( ans , base ) ;\n        base = mul( base , base ) ; \n        b >>= 1 ;\n    }\n    return ans ;\n}\n\nll inv( ll x ) {\n    return power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n    return ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n    scanf( \"%d%d%d\" , &n , &m , &k ) ;\n    fac[ 0 ] = 1ll ;\n    p[ 0 ] = 1ll ;\n    for( int i = 1 ; i < N ; i ++ ) {\n        fac[ i ] = fac[ i - 1 ] * i % mod ;\n        p[ i ] = p[ i - 1 ] * 3ll % mod ;\n    }\n    for( int i = 0 ; i < N ; i ++ ) {\n        ifac[ i ] = inv( fac[ i ] ) ;\n    }\n    ll ans = 0 , x = 1ll ;\n    n -- ;\n    for( int i = 0 ; i <= m + k ; i ++ ) {\n        ans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n        if( i < k ) x = ( x * 2ll ) % mod ;\n        else if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n        else  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n    }\n    printf( \"%lld\\n\" , add( ans , mod ) ) ;\n    return 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "//by tzupengwang™\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nll n , m , k ;\nconst ll mod = 1000000007LL ;\nll fac[ 30005 ] ;\nll inv[ 30005 ] ;\nll p3[ 30005 ] ;\n\nll mpow( ll bs , ll pw ) {\n  if ( pw == 0 ) return 1LL ;\n  ll ret = mpow( bs , pw / 2 ) ;\n  ret = ret * ret % mod ;\n  if ( pw % 2 ) ret = ret * bs % mod ;\n  return ret ;\n}\n\nvoid pre() {\n  fac[ 0 ] = inv[ 0 ] = 1LL ;\n  p3[ 0 ] = 1LL ;\n  for ( ll i = 1 ; i <= 30000 ; i ++ ) {\n    fac[ i ] = fac[ i - 1 ] * i % mod ;\n    inv[ i ] = mpow( fac[ i ] , mod - 2 ) ;\n    p3[ i ] = p3[ i - 1 ] * 3 % mod ;\n  }\n}\n\nll C( ll x , ll y ) {\n  if ( x < y ) return 0 ;\n  return fac[ x ] * inv[ y ] % mod * inv[ x - y ] % mod ;\n}\n\nvoid init() {\n  scanf( \"%lld%lld%lld\" , &n , &m , &k ) ;\n}\n\nll dp[ 1005 ][ 1005 ] ;\n\nvoid process() {\n  for ( int i = 0 ; i <= m ; i ++ ) {\n    for ( int j = 0 ; j <= k ; j ++ ) {\n      dp[ i ][ j ] = C( n + i + j , n ) * C( i + j , i ) % mod ;\n      //printf( \"%d %d: %lld\\n\" , i , j , dp[ i ][ j ] ) ;\n    }\n  }\n  for ( int i = m ; i >= 0 ; i -- ) {\n    for ( int j = k ; j >= 0 ; j -- ) {\n      dp[ i ][ j ] = ( dp[ i ][ j ]\n                     - ( i - 1 >= 0 ? dp[ i - 1 ][ j ] : 0 )\n                     - ( j - 1 >= 0 ? dp[ i ][ j - 1 ] : 0 )\n                     //+ ( ( i - 1 >= 0 && j - 1 >= 0 ) ? dp[ i - 1 ][ j - 1 ] : 0 )\n                     + mod + mod ) % mod ;\n      //printf( \"%d %d: %lld\\n\" , i , j , dp[ i ][ j ] ) ;\n    }\n  }\n  for ( int i = 0 ; i <= m ; i ++ ) {\n    for ( int j = 0 ; j <= k ; j ++ ) {\n      dp[ i ][ j ] = dp[ i ][ j ] * p3[ m - i + k - j ] % mod ;\n      //printf( \"%d %d: %lld\\n\" , i , j , dp[ i ][ j ] ) ;\n    }\n  }\n  ll ans = 0 ;\n  for ( int i = 0 ; i <= m ; i ++ ) {\n    for ( int j = 0 ; j <= k ; j ++ ) {\n      ans = ( ans + dp[ i ][ j ] ) % mod ;\n    }\n  }\n  printf( \"%lld\\n\" , ans ) ;\n}\n\nint main() {\n  pre() ;\n  init() ;\n  process() ;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n\n#include <cassert>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\ninline void ModMul(int& x, int y) {\n    x = (1LL * x * y) % MOD;\n}\n\ninline int GetModMul(int x, int y) {\n    ModMul(x, y);\n    return x;\n}\n\ninline void ModSum(int& x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n    if (x < 0) {\n        x += MOD;\n    }\n}\n\ninline int GetModSum(int x, int y) {\n    ModSum(x, y);\n    return x;\n}\n\ninline int GetBinaryPow(int x, int pw) {\n    int r = 1;\n    while (pw > 0) {\n        if (pw & 1) {\n            ModMul(r, x);\n        }\n        ModMul(x, x);\n        pw >>= 1;\n    }\n    return r;\n}\n\ninline int GetInv(int x) {\n    return GetBinaryPow(x, MOD - 2);\n}\n\nconst int MAX_N = 3e5;\nconst int MAX_FACT = 2 * MAX_N + 100;\n\nvector<int> fact(MAX_FACT);\nvector<int> invFact(MAX_FACT);\n\nvoid BuildFact() {\n    fact[0] = 1;\n    for (int i = 1; i < MAX_FACT; ++i) {\n        fact[i] = fact[i - 1];\n        ModMul(fact[i], i);\n    }\n    for (int i = 0; i < MAX_FACT; ++i) {\n        invFact[i] = GetInv(fact[i]);\n    }\n}\n\ninline int GetC(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n    int r = fact[n];\n    ModMul(r, invFact[k]);\n    ModMul(r, invFact[n - k]);\n    return r;\n}\n\ninline int GetCoeff(int n, int m) {\n    if (n == 0) {\n        return 0;\n    }\n    return GetC(n + m - 1, n - 1);\n}\n\nint main() {\n    BuildFact();\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> pw3(m + k + 1);\n    pw3[0] = 1;\n    for (int i = 1; i <= m + k; ++i) {\n        pw3[i] = pw3[i - 1];\n        ModMul(pw3[i], 3);\n    }\n\n    int result = 0;\n    for (int dm = 0; dm <= m; ++dm) {\n        for (int dk = 0; dk <= k; ++dk) {\n            const int dn = n - 1;\n            int curResult = GetC(dn + dm + dk, dn);\n            ModMul(curResult, GetC(dm + dk, dm));\n            ModMul(curResult, pw3[m + k - (dm + dk)]);\n            ModSum(result, curResult);\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\n\nconstexpr lint MOD = 1000000007;\nlint N, M, K;\n\nlint power(lint x,lint n, lint mod)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) ans = ans * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return ans;\n}\n\nvector<lint> factorial;\nvector<lint> facInv;\nvoid cPrecal(int n)\n{\n    factorial = facInv = vector<lint>(n+1, 1);\n    for (int i=1; i<=n; i++)\n    {\n        factorial[i] = factorial[i-1] * i % MOD;\n        facInv[i] = power(factorial[i], MOD-2, MOD);\n    }\n}\n\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    else return (factorial[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\n\nint main()\n{\n    cin >> N >> M >> K;\n    if (K > M) swap(M, K);\n\n    cPrecal(N+M+K);\n    lint ans = 0;\n    lint bcpattern;\n    for (lint k=0; k<=M+K; k++)\n    {\n        if (k <= K) bcpattern = power(2, k, MOD);\n        else if (k <= M) bcpattern = (bcpattern * 2 - nCr(k-1, K) + MOD) % MOD;\n        else bcpattern = (bcpattern * 2 - nCr(k-1, K) - nCr(k-1, k-1-M) + 2 * MOD) % MOD;\n        lint tmp = ((nCr(N-1+k, k) % MOD) * bcpattern % MOD) * power(3, M+K-k, MOD);\n        ans  = (ans + tmp) % MOD;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD = 1000000007ll;\n\n\nll modSum(ll a, ll b) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\nll getInverse(ll x) {\n  return getPowMod(x, MOD-2);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, M, K;\n\n\nvoid input() {\n  cin >> N >> M >> K;\n  // We require M <= K\n  if (M > K) {\n    swap(M, K);\n  }\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n  ll ans = 0;\n  ll v1 = 1, v2 = 1, tmp1 = 1, tmp2 = 1;\n  for (int len = N ; len <= N+M+K ; len++) {\n    cerr << \"Len = \" << len << \"\\n\";\n    int bad = len - N;\n    if (len == N) {\n      v1 = 1;\n    } else {\n      v1 = modSum(v1, v1);\n    }\n    if (bad-1 >= M) {\n      if (bad-1 > M) {\n        tmp1 = modProd(tmp1, modProd(bad-1, getInverse(bad-1-M)));\n      }\n      v1 = modSubtract(v1, tmp1);\n    }\n    if (bad-1 >= K) {\n      if (bad-1 > K) {\n        tmp2 = modProd(tmp2, modProd(bad-1, getInverse(bad-1-K)));\n      }\n      v1 = modSubtract(v1, tmp2);\n    }\n    if (len > N) {\n      v2 = modProd(v2, modProd(len-1, getInverse(len-1-(N-1))));\n    }\n    ll mul = v1;\n    mul = modProd(mul, v2);\n    mul = modProd(mul, getPowMod(3, N+M+K-len));\n    ans = modSum(ans, mul);\n    /* \n    cerr << \"tmp1 = \" << tmp1 << \"\\n\";\n    cerr << \"tmp2 = \" << tmp2 << \"\\n\";\n    cerr << \"V1 = \" << v1 << \"\\n\";\n    cerr << \"V2 = \" << v2 << \"\\n\";\n    cerr << \"Bad = \" << bad << \"\\n\";\n    cerr << \"Mul = \" << mul << \"\\n\";\n    cerr << \"Ans = \" << ans << \"\\n\";\n    */\n  }\n  cout << ans;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n/* \nLen = 4\nV1 = 1\nV3 = 1\nV2 = 1\nBad = 0\nMul = 81\nAns = 81\nLen = 5\nV1 = 1\nV3 = 1\nV2 = 4\nBad = 1\nMul = 216\nAns = 297\nLen = 6\nV1 = 1\nV3 = 1\nV2 = 10\nBad = 2\nMul = 360\nAns = 657\nLen = 7\nV1 = 1\nV3 = 1\nV2 = 20\nBad = 3\nMul = 360\nAns = 1017\nLen = 8\nV1 = 4\nV3 = 4\nV2 = 35\nBad = 4\nMul = 0\nAns = 1017\n1017\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int mod = 1e9 + 7 ;\nconst int N = 900010 ;\n#define ll long long \n\nint n , m , k ;\nll fac[ N ] , ifac[ N ] , p[ N ] ; \n\nll mul( ll x , ll  y ) {\n\treturn ( 1ll * x * y ) % mod ;\n}\n\nll add( ll x , ll y ) {\n\treturn ( x + y ) % mod ;\n}\n\nll power( ll a , ll b ) {\n\tint ans = 1 , base = a ;\n\twhile( b ) {\n\t\tif( b&1 ) ans = mul( ans , base ) ;\n\t\tbase = mul( base , base ) ; \n\t\tb >>= 1 ;\n\t}\n\treturn ans ;\n}\n\nll inv( ll x ) {\n\treturn power( x , mod - 2 ) % mod ;\n}\n\nll C( ll x , ll y ) {\n\treturn ( fac[ x ] * ifac[ y ] % mod * ifac[ x - y ] % mod ) % mod ;\n}\n\nint main() {\n\tscanf( \"%d%d%d\" , &n , &m , &k ) ;\n\tfac[ 0 ] = 1ll ;\n\tp[ 0 ] = 1ll ;\n\tfor( int i = 1 ; i < N ; i ++ ) {\n\t\tfac[ i ] = fac[ i - 1 ] * i % mod ;\n\t\tp[ i ] = p[ i - 1 ] * 3ll % mod ;\n\t}\n\tfor( int i = 0 ; i < N ; i ++ ) {\n\t\tifac[ i ] = inv( fac[ i ] ) ;\n\t}\n\tll ans = 0 , x = 1ll ;\n\tn -- ;\n\tfor( int i = 0 ; i <= m + k ; i ++ ) {\n\t\tans = ( ans + C( n + i , n ) * p[ m + k - i ] % mod * x )  % mod  ;\n\t\t\n\t\tfor( int j = 0 ; j <= min( i , m - 1 ) ; j ++ ) {\n\t\t\tif( i - j < k ) x = add( x , C( i , j ) ) ;\n\t\t\telse if( i - j < m ) x = add( x , C( i , i - k + 1 ) ) ;\n\t\t}\n\t\t/*\n\t\tif( i < k ) x = ( x * 2ll ) % mod ;\n\t\telse if( i < m ) x = ( x * 2ll - C( i , k ) ) % mod ;\n\t\telse  x = ( x * 2ll - C( i , k ) - C( i , m ) ) % mod ;\n\t\t*/\n\t}\n\tprintf( \"%lld\\n\" , add( ans , mod ) ) ;\n\treturn 0 ;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\n\nint n;\nint m; \nint k;\n\n\nlong long int ppow(long long int i, long long int j){\n\tlong long int res = 1;\n\twhile (j){\n\t\tif ((j & 1LL)){\n\t\t\tres *= i;\n\t\t\tif (res >= MOD)res %= MOD;\n\t\t}\n\t\ti *= i;\n\t\tif (i >= MOD)i %= MOD;\n\t\tj >>= 1;\n\t}\n\treturn res;\n}\n#define MAX 300004\nlong long int ka[MAX];\nlong long int inv[MAX];\n\nlong long int C(int a, int b){\n\tlong long int r = ka[a];\n\tlong long int rr = inv[b] * inv[a - b]; \n\tif (rr >= MOD)rr %= MOD;\n\tr *= rr;\n\tif (r >= MOD)r %= MOD;\n\treturn r;\n}\nlong long int p3[MAX];\n\nlong long int p[1002][1002];\nlong long int ne[1002][1002];\nlong long int ii[MAX];\nint main(){\n\tfor (int i = 1; i < MAX; i++){\n\t\tii[i] = ppow(i, MOD - 2);\n\t}\n\tp3[0] = 1;\n\tfor (int i = 1; i < MAX; i++){\n\t\tp3[i] = p3[i - 1];\n\t\tp3[i] *= 3LL;\n\t\tif (p3[i] >= MOD)p3[i] %= MOD;\n\t}\n\tka[0] = 1;\n\tfor (int i = 1; i < MAX; i++){\n\t\tka[i] = ka[i - 1];\n\t\tka[i] *= (long long int)(i);\n\t\tif (ka[i] >= MOD)ka[i] %= MOD;\n\t}\n\tfor (int i = 0; i < MAX; i++){\n\t\tinv[i] = ppow(ka[i], MOD - 2);\n\t}\n\tcin >> n >> m >> k;\n\tif (n>1000 || m>1000 || k > 1000){\n\t\treturn 0;\n\t}\n\tn--;\n\tlong long int ans = 0;\n\tfor (int i = 0; i <= 1; i++){\n\t\tfor (int j = 0; j <= k; j++){\n\t\t\tint can = i + j + 1;\n\t\t\tlong long int W = ka[i + j + n];\n\t\t\tlong long int r = inv[n] * inv[j];\n\t\t\tr %= MOD;\n\t\t\tr *= inv[i];\n\t\t\tr %= MOD;\n\t\t\tW *= r;\n\t\t\tW %= MOD;\n\t\t\tlong long way = W;\n\t\t\tway *= p3[m - i];\n\t\t\tif (way >= MOD)way %= MOD;\n\t\t\tway *= p3[k - j];\n\t\t\tif (way >= MOD)way %= MOD;\n\t\t\tans += way;\n\t\t\tif (ans >= MOD)ans %= MOD;\n\t\t\tp[i][j] = way;\n\t\t}\n\t}\n\tfor (int j = 0; j <= k; j++){\n\t\tint jj = j;\n\t\tint i = 0;\n\t\tlong long int C = p[i][jj];\n\t\tlong long int SS = 1;\n\t\tlong long int MUL = 1;\n\t\twhile (jj > 0){\n\t\t\tMUL *= (long long int)(jj);\n\t\t\tMUL %= MOD;\n\t\t\tMUL *= ii[i + 1];\n\t\t\tMUL %= MOD;\n\t\t\tSS += MUL;\nSS%=MOD;\n\t\t\ti++;\n\t\t\tjj--;\n\t\t}\n\t\tans += C*SS;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble PI=3.141592653589793;\n\ncomplex <double> dftn[2100007];\ncomplex <double> dfts[2100007];\n\ncomplex <double> a1[2100007];\ncomplex <double> b1[2100007];\ncomplex <double> a2[2100007];\ncomplex <double> b2[2100007];\n\ndouble cosi[2100007];\ncomplex <double> omega[2100007];\n\ninline int potenga(int v)\n{\n    for (int i=1; 1; i<<=1)\n    {\n        if (i>=v)\n        {\n            return i;\n        }\n    }\n}\n\ninline void dft(int n, int kier)\n{\n    int n2=n-1;\n    int s=0;\n    int p;\n    int g;\n\n    for (int i=2; i<=n; i<<=1)\n    {\n\n        for (int j=0; j<n; j++)\n        {\n            dfts[j]=dftn[j];\n            dftn[j]=0;\n        }\n\n        p=n/i;\n\n        if (kier)\n        {\n            g=0;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=j+1;\n                    s=0;\n                }\n            }\n        }\n        else\n        {\n            g=n;\n            for (int j=0; j<n; j++)\n            {\n                dftn[j]=dfts[(2*(j-s)+s)&n2]+omega[g]*dfts[(2*(j-s)+p+s)&n2];\n                s++;\n                if (s==p)\n                {\n                    g=n-j-1;\n                    s=0;\n                }\n            }\n        }\n    }\n}\n\nvoid licz_omegi(int n1)\n{\n    double kat=2.0*PI/n1;\n    int n2=n1-1;\n    int dod=3*n1/4;\n\n    for (int i=0; i<=n1; i++)\n    cosi[i]=cos(kat*i);\n    for (int i=0; i<=n1; i++)\n    omega[i]=complex <double> (cosi[i], cosi[(i+dod)&n2]);\n}\n\nvector <long long> fft_dokladne(vector <long long> &jed, vector <long long> &dwa)\n{\n    int n1=potenga(jed.size()+dwa.size());\n\n    licz_omegi(n1);\n\n    long long M=32000;\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]/M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a1[i]=dftn[i];\n\n    for (int i=0; i<jed.size(); i++)\n    dftn[i]=jed[i]%M;\n    for (int i=jed.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b1[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]/M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    a2[i]=dftn[i];\n\n    for (int i=0; i<dwa.size(); i++)\n    dftn[i]=dwa[i]%M;\n    for (int i=dwa.size(); i<n1; i++)\n    dftn[i]=0;\n    dft(n1, 1);\n    for (int i=0; i<n1; i++)\n    b2[i]=dftn[i];\n\n    vector <long long> ret;\n    for (int i=0; i<n1; i++)\n    ret.push_back(0);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=(llround(dftn[i].real()/n1)%1000000007)*((M*M)%1000000007);\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=a1[i]*b2[i]+b1[i]*a2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=(llround(dftn[i].real()/n1)%1000000007)*M;\n\n    for (int i=0; i<n1; i++)\n    dftn[i]=b1[i]*b2[i];\n    dft(n1, 0);\n    for (int i=0; i<n1; i++)\n    ret[i]+=llround(dftn[i].real()/n1)%1000000007;\n\n    for (int i=0; i<ret.size(); i++)\n        ret[i]%=1000000007;\n\n    return ret;\n}\n\nint n, m, k;\n\nint s;\n\nlong long mod=1000000007;\n\nlong long sil[1000007];\nlong long odw[1000007];\nlong long do3[1000007];\n\nvector <long long> d1, d2, d3;\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n    long long wyk=mod-2;\n    while(wyk)\n    {\n        if (wyk&1)\n        {\n            a*=b;\n            a%=mod;\n        }\n        b*=b;\n        b%=mod;\n        wyk>>=1;\n    }\n    return a;\n}\n\nlong long komb(int a, int b)\n{\n    if (b<0 || b>a)\n        return 0;\n    return (sil[a]*((odw[b]*odw[a-b])%mod))%mod;\n}\n\nlong long komz(int a, int b)\n{\n    return komb(a+b-1, b);\n}\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &m, &k);\n    s=n+m+k;\n    sil[0]=1;\n    odw[0]=1;\n    do3[0]=1;\n    for (int i=1; i<=s; i++)\n        sil[i]=(sil[i-1]*i)%mod;\n    odw[s]=dziel(1, sil[s]);\n    for (int i=s-1; i; i--)\n        odw[i]=(odw[i+1]*(i+1))%mod;\n    for (int i=1; i<=s; i++)\n        do3[i]=(do3[i-1]*3)%mod;\n    for (int i=0; i<=m; i++)\n        d1.push_back((komz(n, i)*odw[n+i-1])%mod);\n    for (int i=0; i<=k; i++)\n        d2.push_back(odw[i]);\n    d3=fft_dokladne(d1, d2);\n    for (int i=0; i<=m+k; i++)\n        wyn+=(d3[i]*((sil[n+i-1]*do3[m+k-i])%mod))%mod;\n    printf(\"%lld\\n\", wyn%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 1e6 + 5;\nconst int mod = 1e9 + 7; \nusing namespace std;\n\nint n, m, k, fac[N], inv[N], ans, pw[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint fpow(int x, int y)\n{\n\tint res = 1;\n\tfor( ; y; y >>= 1, x = 1ll * x * x % mod)\n\t\tif(y & 1) res = 1ll * res * x % mod;\n\treturn res; \n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin);\n#endif\n\tn = read <int> (), m = read <int> (), k = read <int> ();\n\tfor(int i = (fac[0] = 1); i <= n + m + k; i++) fac[i] = 1ll * fac[i - 1] * i % mod; \n\tinv[n + m + k] = fpow(fac[n + m + k], mod - 2);\n\tfor(int i = n + m + k - 1; i >= 0; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; \n\tfor(int i = (pw[0] = 1); i <= n + m + k; i++) pw[i] = 1ll * pw[i - 1] * 3 % mod; \n\tfor(int x = 0; x <= m; x++)\n\t\tfor(int y = 0; y <= k; y++)\n\t\t\tans = (1ll * fac[n + m - x + k - y - 1] * inv[n - 1] % mod * inv[m - x] % mod * inv[k - y] % mod * pw[x + y] + ans) % mod; \n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define ll long long\nusing namespace std;\nconst int p = 1e9+7;\nconst int N = 1500010;\nint fac[N], inv[N], pwr[N];\ninline int qp(int x, int y) {\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (ll)x*x%p) if(y&1) res = (ll)res*x%p;\n\treturn res;\n}\ninline void init(int n) {\n\tfac[0] = pwr[0] = 1;\n\tfor(int i = 1; i <= n; i ++ ) fac[i] = (ll)i*fac[i-1]%p, pwr[i] = pwr[i-1]*(ll)3%p;\n\tinv[n] = qp(fac[n], p-2);\n\tfor(int i = n; i >= 1; i -- ) inv[i-1] = (ll)i*inv[i]%p;\n}\ninline ll c(int n, int m) {\n\tif(n < m) return 0;\n\treturn (ll)fac[n]*inv[m]%p*inv[n-m]%p;\n}\nint main() {\n\tint A, B, C; scanf(\"%d%d%d\", &A, &B, &C);\n\tinit(A+B+C); A -- ;\n\tll ans = 0;\n\tfor(int i = 0; i <= B+C; i ++ ) {\n\t\tll tmp = 0;\n\t\tfor(int x = 0; x <= B && x <= i; x ++ ) if(i-x <= C) {\n\t\t\ttmp = (tmp+c(i, x))%p;\n\t\t}\n\t\tans = (ans+c(i+A, A)*pwr[B+C-i]%p*tmp%p)%p;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\tgetchar(), getchar();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=900005,M=1e9+7;\nint a,b,c,fac[N],fac2[N],inv[N],f[N];\nint ksm(int x,int y){\n\tif (!y)return 1;\n\tint z=ksm(x,y/2);\n\tz*=z;z%=M;\n\tif (y&1)z*=x;\n\treturn z%M;\n}\nint C(int x,int y){\n\tif (x<y)return 0;\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&a,&b,&c);\n\tfac[0]=inv[0]=fac2[0]=1;\n\tfor (int i=1;i<N;i++)fac[i]=fac[i-1]*i%M,fac2[i]=fac2[i-1]*3%M,inv[i]=ksm(fac[i],M-2);\n\ta--;\n\tint now1=0,now2=1,ans=fac2[b+c];\n\tfor (int i=1;i<=b+c;i++){\n\t\tnow2=(now2*2-C(i-1,b)+M)%M;\n\t\tnow1=(now1*2+C(i-1,i-c-1))%M;\n\t\t(ans+=fac2[b+c-i]*(now2-now1+M)%M*C(a+i,a))%=M;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/numeric.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/adaptor/indexed.hpp>\n\nusing namespace std;\nusing namespace boost::adaptors;\nusing namespace std::string_literals;\nusing ll = int64_t;\nusing vecint = vector<int>;\nusing vecll = vector<ll>;\nusing boost::irange;\nconstexpr ll MOD = 1000000007;\n\n// a^-1 mod p\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nll pow3(ll x) {\n  if (x == 0) return 1;\n  if ((x%2)==1) return 3*pow3(x-1)%MOD;\n  ll h=pow3(x/2);\n  return h*h%MOD;\n}\n\nint main()\n{\n  ll n,m,k;\n  cin>>n>>m>>k;\n  vecll fact(3001);\n  vecll factinv(3001);\n  fact[0] = 1;\n  factinv[0] = 1;\n  for(int i:irange(0,3000)) {\n    fact[i+1] = fact[i] * (i+1) % MOD;\n    factinv[i+1] = inv(fact[i+1], MOD);\n  }\n  ll ans = 0;\n  ll l=n+m+k;\n  for(ll i:irange(n,l+1)) {\n    ll r = i-n;\n    ll comb = fact[i-1] * factinv[n-1] % MOD;\n    comb = comb * factinv[r] % MOD;\n    ll pw = pow3(l-i);\n    ll mn = max(0l,min(i-n-k, m));\n    for (ll j:irange(mn, min(r+1,m+1))) {\n      ll comb2 = fact[r] * factinv[j] % MOD;\n      comb2 = comb2 * factinv[r-j] % MOD;\n      ll mul = comb * comb2 % MOD;\n      mul = mul * pw % MOD;\n      ans += mul;\n      ans %= MOD;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n\ncs ll mod=1000000007;\n\nll fac[1000001]={1,1},inv[1000001]={1,1},ifac[1000001]={1,1};\n\ninline\nll C(int n,int m){\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint n,m,k,maxn;\n\nint main(){\n\t\n\tfor(int re i=2;i<=1000000;++i)\n\tfac[i]=fac[i-1]*i%mod,\n\tinv[i]=(mod-mod/i)*inv[mod%i]%mod,\n\tifac[i]=ifac[i-1]*inv[i]%mod;\n\t\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\t--n;\n\tmaxn=max(n,m+k);\n\tll sum=1,ans=1;\n\tfor(int re i=1;i<=maxn;++i){\n\t\tsum=(sum<<1)%mod;\n\t\tif(i>m)sum=(sum+mod-C(i-1,m))%mod;\n\t\tif(i>k)sum=(sum+mod-C(i-1,k))%mod;\n\t\tans=ans*3%mod;\n\t\tans=(ans+C(n+i,i)*sum%mod)%mod;\n\t}\n\tcout<<(ans%mod+mod)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm p(1 << 20);\n\nll t3[700001];\n\nvoid solve() {\n\tt3[0] = 1;\n\trep(i, 700000)t3[i + 1] = t3[i] * 3 % mod;\n\tint n, m, k; cin >> n >> m >> k;\n\tll ans = 0;\n\tll cur = 0;\n\trep(t, m + k + 1) {\n\t\tll csum = p.comb(t + n-1, t)*t3[m+k-t]%mod;\n\t\tll ncur = 0;\n\t\tif (t == 0) {\n\t\t\tcur = 1;\n\t\t}\n\t\telse {\n\t\t\tint ple = max(t - 1 - k, 0);\n\t\t\tint pri = min(m, t - 1);\n\t\t\tint le = max(t - k, 0);\n\t\t\tint ri = min(m,t);\n\t\t\tncur += cur;\n\t\t\tcur += mod-p.comb(t - 1, ple);\n\t\t\tcur += p.comb(t - 1, pri + 1);\n\t\t\tif (le == ple)cur++;\n\t\t\tif (pri == ri) {\n\t\t\t\t//cur += mod - 1;\n\t\t\t\tcur += mod - p.comb(t - 1, pri);\n\t\t\t\tcur += mod - p.comb(t - 1, pri + 1);\n\t\t\t}\n\t\t\twhile (cur >= mod)cur -= mod;\n\t\t\tncur += cur;\n\t\t\twhile (ncur >= mod)ncur -= mod;\n\t\t\tcur = ncur;\n\t\t\t//cout << t << \" \" << ncur << endl;\n\t\t}\n\t\tans += cur * csum%mod;\n\t\tif (ans >= mod)ans -= mod;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nvector<lint> zyo,rz,z3;\nlint mo=1000000007;\nlint extgcd(lint a, lint b, lint &x, lint &y) {\n  lint g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nlint invMod(lint a, lint m) {\n  lint x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;return 0;\n}\nlint cal(int a,int b,int c){\n\treturn ((((zyo[a+b+c]*rz[a])%mo)*rz[b])%mo*rz[c])%mo;\n}\nint main()\n{\n\tint n,m,k;lint out=0;\n\tcin>>n>>m>>k;\n\tzyo.pb(1);rep(i,364364) zyo.pb((zyo[i]*(i+1))%mo);\n\trep(i,364364) rz.pb(invMod(zyo[i],mo));\n\tz3.pb(1);rep(i,364364) z3.pb((z3[i]*3)%mo);\n\trep(i,m+1) rep(j,k+1){\n\t\tlint t=(cal(n-1,i,j)*z3[m-i])%mo;\n\t\t//cout<<i<<' '<<j<<' '<<cal(n,i,j)<<endl;\n\t\tout+=t*z3[k-j];out%=mo;\n\t}\n\tcout<<out%mo<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//In the name of GOD\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll maxn = 3e3 + 100;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\n\n#define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define file_io freopen(\"input.txt\" , \"r+\" , stdin) ; freopen(\"output.txt\" , \"w+\" , stdout);\n#define pb push_back\n#define Mp make_pair\n#define pll pair<ll, ll>\n#define F first\n#define S second\n\nll n, m, k, c[maxn][maxn], ans, p[maxn];\n\nint main(){\n\tfast_io;\n\tp[0] = 1;\n\tc[0][0] = 1;\n\tfor(ll i = 1; i < maxn; i++){\n\t\tp[i] = (p[i - 1] * 3) % mod;\n\t\tc[i][0] = 1;\n\t\tfor(ll j = 1; j < maxn; j++){\n\t\t\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]);\n\t\t\tif(c[i][j] >= mod) c[i][j] -= mod;\n\t\t}\n\t}\n\t\n\tcin >> n >> m >> k;\n\tm++;\n\tk++;\n\t\n\tfor(ll i = n; i < maxn; i++){\n\t\tfor(ll j = 0; j < m; j++){\n\t\t\tll x = i - n - j;\n\t\t\tif(x < 0 || x >= k) continue;\n\t\t\tans = (ans + ((c[i - 1][n - 1] * c[i - n][j]) % mod) * p[n + m + k - i - 2]) % mod;\n\t\t}\n\t}\n\tcout << ans;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) { os << \"[ \"; \n\tfor(auto v:V)os << v << \" \"; return os << \"]\";\n}\ntemplate<class T> ostream& operator<<(ostream &os, set<T> S){ os << \"{ \"; \n\tfor(auto s:S) os<<s<<\" \";  return os<<\"}\"; \n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os<<\"(\"<<P.first<<\",\"<< P.second << \")\";\n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, map<L,R> M) {\n\tos<<\"{ \";for(auto m:M)os<<\"(\"<<m.F<<\":\"<<m.S<<\")\";\n\treturn os<<\"}\";\n}\n#define cerr cout\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define For(i,n) for(int i=0;i<(int)n;++i)\n#define Rev(i,n) for(int i=(int)n-1;i>=0;--i)\n#define Rep(i,n) for(int i=1;i<=(int)n;++i)\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\ntypedef vector<pii> vpii;\n#define fio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n\nconst int N = 6e3 + 100;\nconst int mod = 1e9 + 7;\n\ninline int mul(int a , int b){\n\treturn a*1ll*b%mod;\n}\ninline int mul(int a , int b, int c){\n\treturn mul(a , mul(b , c));\n}\ninline int sub(int a , int b){\n\ta -= b;\n\tif(a < 0) a += mod;\n\treturn a;\n}\ninline int add(int a , int b){\n\ta += b;\n\tif(a >= mod) a -= mod;\n\treturn a;\n}\ninline int power(int x, int y){\n\tint res = 1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres = mul(res , x);\n\t\tx = mul(x , x);\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint fac[N] , inv[N];\nint pr[N];\nint pr2[N];\nint dp[N];\nint dp2[N];\nint nCr(int n , int r){\n\tif(r < 0 || r > n) return 0;\n\treturn mul(fac[n] , mul(inv[r] , inv[n-r]));\n}\n\nint main(){\n\tfio; cout<<fixed<<setprecision(25);\t\n\tfac[0] = 1;\n\tpr[0] = 1;\n\tpr2[0] = 1;\n\tfor(int i = 1;i< N ; ++i){\n\t\tpr[i] = mul(pr[i-1] , 3);\n\t\tpr2[i] = mul(pr2[i-1] , 2);\n\t\tfac[i] = mul(fac[i-1] , i);\n\t}\n\tinv[N-1] = power(fac[N-1] , mod-2);\n\tfor(int i = N-2 ; i >= 0 ; --i){\n\t\tinv[i] = mul(inv[i+1] , i+1);\n\t}\n\tassert(inv[0] == 1);\n\tint n , m , k; cin >> n >> m >> k;\n\tif(m > k) swap(m , k);\n\tint ans = 0;\n\t// for(int i = 0;i <= m ; ++i){\n\t// \tfor(int j = 0;j <= k ; ++j){\n\t// \t\tans = add(ans , mul( mul(mul( 1 , 1)  , mul(nCr(n-1+i+j , n-1) , nCr(i+j , i) )) , pr[m-i+k-j]  ) );\n\t// \t\t// trace(i , j , ans);\n\t// \t}\n\t// }\n\n\n\tfor(int i = 0 ;i <= m+k ; ++i){\n\n\n\t\tif(i <= k){\n\t\t\tdp[i] = pr2[i];\n\t\t}\n\t\telse{\n\t\t\tdp[i] =  sub( mul(2 , dp[i-1]) , nCr(i-1 , k));\n\t\t}\n\t\tif(i <= m){\n\t\t\tdp2[i] = pr2[i];\n\t\t}\n\t\telse{\n\t\t\tdp2[i] =  sub( mul(2 , dp[i-1]) , nCr(i-1 , m));\n\t\t}\n\t\tif(i <= k){\n\t\t\tans = add(ans ,   mul( nCr(n-1+i , i) , pr2[i] , pr[m+k-i]));\n\t\t}\n\t\telse{\n\t\t\tint ss = add(dp[i] , dp2[i]);\n\t\t\t// trace(ss);\n\t\t\tss = sub(ss , pr2[i]);\n\t\t\t// trace(ss);\n\t\t\t// ss = mul(ss , inv[2]);\n\t\t\t// trace(i , ss);\n\t\t\t// dp[i] = sub( mul(2 , dp[i-1]) , nCr(i-1 , k));\n\t\t\t// trace(i , dp[i]);\n\t\t\tans = add(ans , mul(nCr(n-1+i , i) ,  ss , pr[m+k-i]));\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint n, m, k;\nint f[4][1010101];\nint pow1[1010101], pow2[1010101];;\nint g[4][4][1010101];\nint fac[1010101], rev[1010101], ifac[1010101];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tpow1[0] = fac[0] = ifac[0] = rev[0] = pow2[0] = 1;\n\tifac[1] = rev[1] = 1;\n\tfor(int i = 1; i <= n + m + k; ++i)\n\t{\n\t\tpow1[i] = pow1[i - 1] * 3ll % MOD;\n\t\tpow2[i] = pow2[i - 1] * 2 % MOD;\n\t\tfac[i] = fac[i - 1] * 1ll * i % MOD;\n\t\tif(i >= 2)\n\t\t{\n\t\t\trev[i] = MOD - 1ll * (MOD / i) * rev[MOD % i] % MOD;\n\t\t\tifac[i] = 1ll * ifac[i - 1] * rev[i] % MOD;\n\t\t}\n\t}\n\tint mn = min(n, m);\n\tmn = min(mn, k);\n\tf[1][n] = 1;\n\tf[2][m + 1] = 1;\n\tf[3][k + 1] = 1;\n\tg[1][2][n + m] = 1ll * fac[n + m] * ifac[n] % MOD * ifac[m] % MOD;\n\tg[1][3][n + k] = 1ll * fac[n + k] * ifac[n] % MOD * ifac[k] % MOD;\n\tg[2][3][m + k + 1] = 1ll * fac[m + k + 1] * ifac[m + 1] % MOD * ifac[k] % MOD;\n\tg[2][1][m + n] = 1ll * fac[m + n] * ifac[m + 1] % MOD * ifac[n - 1] % MOD;\n\tg[3][1][k + n] = 1ll * fac[k + n] * ifac[k + 1] % MOD * ifac[n - 1] % MOD;\n\tg[3][2][k + m + 1] = 1ll * fac[k + m + 1] * ifac[k + 1] % MOD * ifac[m] % MOD;\n\t//cout<<g[2][1][2]<<\" \"<<g[3][1][2]<<endl;\n\t//cout<<fac[2]<<\" \"<<ifac[2]<<\" \"<<ifac[0]<<endl;\n\tint ans = pow1[m + k];\n\tlong long cnt1 = 0;\n\tlong long cnt2 = 0;\n\tlong long cnt3 = 0;\n\t//cout<<ans<<endl;\n\tfor(int i = mn + 1; i <= n + m + k; ++i)\n\t{\n\t\tif(i > n)\n\t\t{\n\t\t/*\tf[1][i] = 2ll * (n) * f[1][i - 1] % MOD - g[2][1][i - 1] - g[3][1][i - 1];\n\t\t\twhile(f[1][i] < 0)\n\t\t\t\tf[1][i] += MOD;*/\n\t\t\tf[1][i] = 1ll * fac[i - 1] * ifac[n - 1] % MOD * ifac[i - n] % MOD * pow2[i - n] % MOD;\n\t\t\t//cout<<i<<\" \"<<cnt1<<endl;\n\t\t\tf[1][i] -= 1ll * fac[i - 1] * ifac[m] % MOD * ifac[i - m - n] % MOD * ifac[n - 1] % MOD;\n\t\t\tf[1][i] -= 1ll * fac[i - 1] * ifac[k] % MOD * ifac[i - k - n] % MOD * ifac[n - 1] % MOD;\n\t\t\twhile(f[1][i] < 0)\n\t\t\t\tf[1][i] += MOD;\n\t\t\tans += 1ll * f[1][i] * pow1[n + m + k - i] % MOD;\n\t\t\tif(ans >= MOD)\n\t\t\t\tans -= MOD;\n\t\t}\n\t\tif(i > m + 1)\n\t\t{\n\t\t\t//f[2][i] = 2ll * (m + 1) * f[2][i - 1] % MOD - g[1][2][i - 1] - g[3][2][i - 1];\n\t\t\tf[2][i] = 1ll * fac[i - 1] * ifac[m] % MOD * ifac[i - m - 1] % MOD * pow2[i - m - 1] % MOD;\n\t\t\tf[2][i] -= 1ll * fac[i - 1] * ifac[n - 1] % MOD * ifac[i - n - m] % MOD * ifac[m] % MOD;\n\t\t\tf[2][i] -= 1ll * fac[i - 1] * ifac[k] % MOD * ifac[i - 1 - m - k] % MOD * ifac[m] % MOD;\n\t\t\twhile(f[2][i] < 0)\n\t\t\t\tf[2][i] += MOD;\n\t\t}\n\t\tif(i > k + 1)\n\t\t{\n\t\t\t//f[3][i] = 2ll * (k + 1) * f[3][i - 1] % MOD - g[2][3][i - 1] - g[1][3][i - 1];\n\t\t\tf[3][i] = 1ll * fac[i - 1] * ifac[i - k - 1] % MOD * ifac[k] % MOD * pow2[i - k - 1] % MOD;\n\t\t\tf[3][i] -= 1ll * fac[i - 1] * ifac[n - 1] % MOD * ifac[i - n - k] % MOD * ifac[k] % MOD;\n\t\t\tf[3][i] -= 1ll * fac[i - 1] * ifac[m] % MOD * ifac[i - 1 - m - k] % MOD * ifac[k] % MOD;\n\t\t\twhile(f[3][i] < 0)\n\t\t\t\tf[3][i] += MOD;\n\t\t}\n\t\t/*if(i > n + m)\n\t\t{\n\t\t\t//g[1][2][i] = 1ll * g[1][2][i - 1] * (i - 1) % MOD;\n\t\t\t//g[2][1][i] = 1ll * g[2][1][i - 1] * (i - 1) % MOD;\n\t\t\tg[1][2][i] = 1ll * fac[i - 1] * ifac[n - 1] % MOD * ifac[i - n - m] % MOD * ifac[m] % MOD;\n\t\t\tg[2][1][i] = 1ll * fac[i - 1] * ifac[m] % MOD * ifac[i - m - n] % MOD * ifac[n - 1] % MOD;\n\t\t}\n\t\tif(i > m + k + 1)\n\t\t{\n\t\t\t//g[2][3][i] = 1ll * g[2][3][i - 1] * (i - 1) % MOD;\n\t\t\t//g[3][2][i] = 1ll * g[3][2][i - 1] * (i - 1) % MOD;\n\t\t\tg[2][3][i] = 1ll * fac[i - 1] * ifac[m] % MOD * ifac[i - 1 - m - k] % MOD * ifac[k] % MOD;\n\t\t\tg[3][2][i] = 1ll * fac[i - 1] * ifac[k] % MOD * ifac[i - 1 - m - k] % MOD * ifac[m] % MOD;\n\t\t}\n\t\tif(i > k + n)\n\t\t{\n\t\t\t//g[1][3][i] = 1ll * g[1][3][i - 1] * (i - 1) % MOD;\n\t\t\t//g[3][1][i] = 1ll * g[3][1][i - 1] * (i - 1) % MOD;\n\t\t\tg[1][3][i] = 1ll * fac[i - 1] * ifac[n - 1] % MOD * ifac[i - n - k] % MOD * ifac[k] % MOD;\n\t\t\tg[3][1][i] = 1ll * fac[i - 1] * ifac[k] % MOD * ifac[i - k - n] % MOD * ifac[n - 1] % MOD;\n\t\t}\n\t\tcnt1 = (cnt1 <<1) + g[2][1][i] + g[3][1][i];\n\t\tcnt1 %= MOD;\n//\t\tcout<<i<<\" g \"<<g[2][1][i]<<\" \"<<g[3][1][i]<<\" cnt1 \"<<cnt1<<endl;\n\t\tcnt2 = (cnt2<<1) + g[3][2][i] + g[1][2][i];\n\t\tcnt2 %= MOD;\n\t\tcnt3 = (cnt3<<1) + g[1][3][i] + g[2][3][i];\n\t\tcnt3 %= MOD;*/\n\t//\tcout<<i<<\" \"<<f[1][i]<<\" \"<<ans<<endl;\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <memory.h>\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\nconst int N = 1000500;\nint pw3[N];\n\nint stup(int n, int m, int k) {\n    const int N = 21;\n    int D[3][N][N][N];\n    memset(D, 0, sizeof(D));\n    for (int s = 0; s < 3 * N; s++) {\n        for (int x = 0; x <= min(s, N - 1); x++) {\n            for (int y = 0; x + y <= s && y <= N - 1; y++) {\n                int z = s - x - y;\n                if (z < 0 || z > N - 1)\n                    continue;\n                for (int w = 0; w < 3; w++) {\n                    int g[] = {x, y, z};\n                    if (g[w] == 0) {\n                        if (w == 0)\n                            D[w][x][y][z] = pw3[y + z];\n                        else\n                            D[w][x][y][z] = 0;\n                    } else {\n                        g[w]--;\n                        D[w][x][y][z] = (1ll * D[0][g[0]][g[1]][g[2]] + D[1][g[0]][g[1]][g[2]] + D[2][g[0]][g[1]][g[2]]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return D[0][n][m][k];\n}\n\nint powmod(int x, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = 1ll * res * x % MOD;\n        x = 1ll * x * x % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\ninline int inv(int x) {\n    return powmod(x, MOD - 2);\n}\n\nint F[N], iF[N];\n\nint C(int x, int y) {\n    if (y < 0 || y > x || x < 0)\n        return 0;\n    return 1ll * F[x] * iF[y] % MOD * iF[x - y] % MOD;\n}\n\nint D[N];\n\nint n, m, k;\nint get(int x) {\n    /*int res = 0;\n    for (int i = 0; i <= m; i++) {\n        int j = x - i;\n        if (j < 0 || j > k)\n            continue;\n        res += C(x, i);\n        if (res >= MOD)\n            res -= MOD;\n    }\n    return res;*/\n    if (x == 0)\n        D[x] = 1;\n    if (D[x] != -1)\n        return D[x];\n    D[x] = 2ll * D[x - 1] % MOD;\n    if (x >= m + 1 && x < k + 1) {\n        D[x] = (D[x] + MOD - C(x - 1, x - m - 1)) % MOD;\n    } else if (x >= k + 1) {\n        D[x] = (D[x] + 2ll * MOD - C(x - 1, x - m - 1) - C(x - 1, x - k - 1)) % MOD;\n    }\n    return D[x];\n}\n\nint main() {\n    memset(D, -1, sizeof(D));\n    pw3[0] = 1;\n    for (int i = 1; i < N; i++) {\n        pw3[i] = (pw3[i - 1] * 3ll) % MOD;\n    }\n    F[0] = 1;\n    for (int i = 1; i < N; i++) {\n        F[i] = 1ll * F[i - 1] * i % MOD;\n    }\n    iF[N - 1] = inv(F[N - 1]);\n    for (int i = N - 2; i >= 0; i--)\n        iF[i] = 1ll * iF[i + 1] * (i + 1) % MOD;\n\n    scanf(\"%d %d %d\", &n, &m, &k);\n    if (m > k)\n        swap(m, k);\n    int ans = 0;\n    for (int l = n; l <= n + m + k; l++) {\n        int cur1 = C(l - 1, n - 1);\n        int cur2 = get(l - n);\n        int cur3 = pw3[n + m + k - l];\n        ans += 1ll * cur1 * cur2 % MOD * cur3 % MOD;\n        if (ans >= MOD)\n            ans -= MOD;\n    }\n\n    printf(\"%d\\n\", ans);\n    if (n <= 20 && m <= 20 && k <= 20) {\n        int s = stup(n, m, k);\n        eprintf(\"stup = %d\\n\", s);\n        assert(s == ans);\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = (int)1e9 + 7;\n\nconst int root = 646;\n\nconst int root_1 = 208611436;\n\nconst int root_pw = 1<<20;\n\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\n\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\n\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\n\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\n\nconst int maxN = 9 * (int)1e5 + 100;\n\nint fact[maxN], invfact[maxN], inv[maxN];\nint pw3[maxN];\n\nvoid init() {\n    inv[1] = invfact[1] = invfact[0] = fact[0] = fact[1] = 1;\n    for (int i = 2; i < maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n    pw3[0] = 1;\n    for (int i = 1; i < maxN; i++) {\n        pw3[i] = mult(pw3[i - 1], 3);\n    }\n}\n\nint cnk(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return mult(fact[n], mult(invfact[k], invfact[n - k]));\n}\n\nint invNumber(int a) {\n    return pw(a, mod - 2);\n}\n\nstruct query{\n    int L, R, coef;\n    query(int _L, int _R, int _coef) : L(_L), R(_R), coef(_coef) {}\n};\nconst int BLOCK = 500;\nbool cmp(query& a, query& b) {\n    return make_pair(a.L / BLOCK, a.R) < make_pair(b.L / BLOCK, b.R);\n}\nint L, R, res;\nvoid incL() {\n    L++;\n    res = sum(res, cnk(R, L));\n}\nvoid decL() {\n    res = sub(res, cnk(R, L));\n    L--;\n}\nvoid incR() {\n    res = sum(res, res);\n    res = sub(res, cnk(R, L));\n    R++;\n}\nconst int inv2 = (mod + 1) / 2;\nvoid decR() {\n    R--;\n    res = sum(res, cnk(R, L));\n    res = mult(res, inv2);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    init();\n    int n, m, k;\n    cin >> n >> m >> k;\n    int tot = n + m + k;\n    vector < query > all;\n    for (int where = n; where <= tot; where++) {\n        int cur = cnk(where - 1, n - 1);\n        cur = mult(cur, pw3[tot - where]);\n        int from = where - n - k;\n        int to = m;\n        to = min(to, where - n);\n        from = max(from, 0);\n        if (from > to) continue;\n        all.emplace_back(to, where - n, cur);\n        if (from) all.emplace_back(from - 1, where - n, sub(0, cur));\n    }\n    sort(all.begin(), all.end(), cmp);\n    L = 0;\n    R = 0;\n    res = 1;\n    int ans = 0;\n    for (auto it : all) {\n        while (R < it.R) incR();\n        while (L > it.L) decL();\n        while (R > it.R) decR();\n        while (L < it.L) incL();\n\n        ans = sum(ans, mult(it.coef, res));\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e6+5;\nconst ll p = 1e9+7;\nconst ll inv3 = (p+1)/3;\n\nll fact[MAXN], invfact[MAXN], inv[MAXN], n, m, k, c[MAXN];\nll p3[MAXN], pinv3[MAXN];\n\nll comb(int x, int y) {\n\tif (x < 0 || y < 0 || x < y)\n\t\treturn 0;\n\treturn fact[x]*invfact[y]%p*invfact[x-y]%p;\n}\n\nll exp(ll x, ll k) {\n\tif (k == 0)\n\t\treturn 1;\n\tll y = exp(x, k/2);\n\treturn (k%2 == 0) ? y*y%p : y*y%p*x%p;\n}\n\nll inve(ll x) { return exp(x, p-2); }\n\nvoid init() {\n\tinv[1] = fact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i < MAXN; ++i) {\n\t\tinv[i] = (p - (p/i) * inv[p%i] % p) % p;\n\t\tfact[i] = i*fact[i-1]%p;\n\t\tinvfact[i] = inv[i]*invfact[i-1]%p;\n\t}\n\n\tp3[0] = pinv3[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tp3[i] = 3*p3[i-1]%p, pinv3[i] = inv3*pinv3[i-1]%p;\n}\n\nint main() {\n\tcin >> n >> m >> k;\n\tinit();\n\tfor (int i = 0; i <= k; ++i)\n\t\tc[0] = (c[0] + pinv3[i])%p;\n\tfor (int i = 1; i < MAXN-300000; ++i)\n\t\tc[i] = 3*(p+1)/2%p*(c[i-1]+p-comb(i+k, k)*pinv3[k+1]%p)%p;\n\tll ans = 0;\n\tfor (int i = 0; i <= m; ++i)\n\t\tans = (ans + comb(n-1+i, i)*pinv3[i]%p*c[n-1+i]%p)%p;\n\tcout << ans*p3[m+k]%p << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename T> constexpr T fpow(T x, ll y, T identity = 1) { return fpow_eq(x, y, identity); }\ntemplate <typename T> constexpr T fpow_eq(T& x, ll y, T identity = 1) {\n    for(; y > 0; x *= x, y >>= 1) {\n        if(y & 1) {\n            identity *= x;\n        }\n    }\n    return x = identity;\n}\n#ifdef __TOTIENT_INCLUDED_\ntemplate <int M, int PHI_M = phi(M)> struct modint {\n#else\ntemplate <int M, int PHI_M> struct modint {\n#endif\n    static constexpr int MOD = M;\n    int val;\n    constexpr modint() : val(0) {}\n    constexpr modint(int val) : val(val % M) { val += val < 0 ? M : 0; }\n    constexpr modint(long long val) : modint(int(val % M)) {}\n    constexpr modint(const modint& m) : val(m.val) {}\n    constexpr explicit operator int() const { return val; }\n    constexpr bool operator==(const modint& y) const { return val == y.val; }\n    constexpr bool operator!=(const modint& y) const { return val != y.val; }\n    constexpr bool operator< (const modint& y) const { return val <  y.val; }\n    constexpr bool operator<=(const modint& y) const { return val <= y.val; }\n    constexpr bool operator> (const modint& y) const { return val >  y.val; }\n    constexpr bool operator>=(const modint& y) const { return val >= y.val; }\n    constexpr modint& operator=(const modint& y) { val = y.val; return *this; }\n    constexpr modint& operator+=(const modint& y) { val += y.val; val -= val >= M ? M : 0; return *this; }\n    constexpr modint& operator-=(const modint& y) { val -= y.val; val += val <  0 ? M : 0; return *this; }\n    constexpr modint& operator*=(const modint& y) { val = ll(val) * y.val % M; return *this; }\n    constexpr modint& operator/=(const modint& y) { val = ll(val) * fpow(y, PHI_M - 1).val % M; return *this; }\n    constexpr modint& operator^=(ll y) { fpow_eq(*this, y); return *this; }\n    constexpr modint operator+(const modint& y) const { return modint(val) += y; }\n    constexpr modint operator-(const modint& y) const { return modint(val) -= y; }\n    constexpr modint operator*(const modint& y) const { return modint(val) *= y; }\n    constexpr modint operator/(const modint& y) const { return modint(val) /= y; }\n    constexpr modint operator^(ll y) const { return modint(val) ^= y; }\n    constexpr modint operator-() const { return modint(0) -= *this; }\n    constexpr modint operator~() const { return modint(1) /= *this; }\n    constexpr modint& operator++() { val = val == M - 1 ? 0 : val + 1; return *this; }\n    constexpr modint& operator--() { val = val == 0 ? M - 1 : val - 1; return *this; }\n    constexpr modint operator++(int) { modint m = *this; ++(*this); return m; }\n    constexpr modint operator--(int) { modint m = *this; --(*this); return m; }\n    friend constexpr modint operator+(long long x, const modint& y) { return modint(x) + y; }\n    friend constexpr modint operator*(long long x, const modint& y) { return modint(x) * y; }\n    friend constexpr modint operator-(long long x, const modint& y) { return modint(x) - y; }\n    friend constexpr modint operator/(long long x, const modint& y) { return modint(x) / y; }\n    friend ostream& operator<<(ostream& os, const modint& m) { return os << m.val; }\n    friend istream& operator>>(istream& is, modint& m) { ll val; is >> val; m = modint(val); return is; }\n};\nconstexpr int M = 1'000'000'007;\nusing mint = modint<M, M - 1>;\nmint operator\"\"_m(unsigned long long int x) { return mint(ll(x)); }\n#ifndef __COMBINATIONS_INCLUDED_\n#define __COMBINATIONS_INCLUDED_\ntemplate <typename T = mint> T fact(int n) {\n    static vector<T> fac = {1};\n    while(fac.size() <= n) {\n        fac.push_back(fac.back() * int(fac.size()));\n    }\n    return fac[n];\n}\ntemplate <typename T = mint> T fact_inv(int n) {\n    static vector<T> inv_fac = {1};\n    while(inv_fac.size() <= n) {\n        inv_fac.push_back(inv_fac.back() / int(inv_fac.size()));\n    }\n    return inv_fac[n];\n}\ntemplate <typename T = mint> T C(int n, int k) {\n    assert(n >= 0), assert(k >= 0);\n    return k <= n ? fact<T>(n) * fact_inv<T>(k) * fact_inv<T>(n - k) : 0;\n}\n#endif\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, k;\n    cin >> n >> m >> k;\n    mint ans = 0, cur = 1;\n    for(int ij = 0; ij <= m + k; ij++) {\n        ans += (3_m ^ (m + k - ij)) * C(n - 1 + ij, ij) * cur;\n        cur = cur * 2 - C(ij, k) - (ij >= m ? C(ij, ij - m) : 0);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <math.h>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <string.h>\n#include <bitset>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n \n \n \nconst int N = 1e6+10;\nint n,m,vis[N],d[N];\nstruct _ {int to,w,vis;};\nvector<_> g[N];\nstruct __ {\n\tint id,w;\n\tbool operator < (const __ &rhs) const {\n\t\treturn w>rhs.w;\n\t}\n};\npriority_queue<__> q;\n\nvoid dfs(int x, int w, int dd) {\nif(vis[x]) return;\nvis[x]=1;\n\tif (d[x]>dd) q.push({x,d[x]=dd});\n\tfor (_ &e:g[x]) if (e.w==w) { \n\t\tif (e.vis) continue;\n\t\te.vis = 1;\n\t\tdfs(e.to,w,dd);\n\t}\n}\n \nint main() {\n\tcin>>n>>m;\n\twhile (m--) {\n\t\tint p,q,c;\n\t\tcin>>p>>q>>c;\n\t\tg[p].pb({q,c});\n\t\tg[q].pb({p,c});\n\t}\n\tmemset(d,0x3f,sizeof d);\n\tq.push({1,d[1]=0});\n\twhile (q.size()) { \n\t\tint u = q.top().id; q.pop();\n\t\tif (vis[u]) continue;\n\t\tvis[u] = 1;\n\t\tfor (auto e:g[u]) dfs(e.to,e.w,d[u]+1);\n\t}\n\tprintf(\"%d\\n\", vis[n]?d[n]:-1);\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int N = 600010, Mod = 1e9 + 7;\nint fac[N], ifac[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod)\n\t\tif (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint C(int n, int m) {\n\tif (n < m) return 0;\n\tif (m < 0) return C(n - m - 1, -m);\n\treturn 1ll * fac[n] * ifac[n - m] % Mod * ifac[m] % Mod;\n}\nint n, m, k;\nint calc(int t) {\n\tint res = 0;\n\tfor (int j = 0; j < max(0, t - k); j++)\n\t\tprintf(\"%d \", C(t, j));\n\tfor (int i = max(0, t - k); i <= m; i++) {\n\t\tres = (res + C(t, i)) % Mod;\n\t\tprintf(\"%d \", C(t, i));\n\t}\n\tputs(\"\");\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tread(n), read(m), read(k);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N - 10; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[N - 10] = fpow(fac[N - 10], Mod - 2);\n\tfor (int i = N - 10; i >= 1; i--) ifac[i - 1] = 1ll * ifac[i] * i % Mod;\n\tLL ans = fpow(3, m + k), S = 1;\n\tfor (int t = 1; t <= m + k; t++) {\n\t\tS = (2 * S % Mod - C(t - 1, m) + Mod) % Mod;\n\t\tif (t - k > 0) S = (S - C(t - 1, t - k - 1) + Mod) % Mod;\n\t\tans = (ans + 1ll * fpow(3, m + k - t) * C(t + n - 1, n - 1) % Mod * S % Mod) % Mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<(b); i++)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); i--)\n#define debug(x) cout << #x << \" => \" << x << endl\nusing namespace std;\nconst int MAX_N = 7 + 300000;\nconst int MOD = 1e9 + 7;\n///----------------------------------------------\nint qpow(int a,int b) {\n    int ret=1;\n    for (; b; b>>=1) {\n        if (b&1) ret=1ll*ret*a%MOD;\n        a=1ll*a*a%MOD;\n    }\n    return ret;\n}\n///----------------------------------------------\nint jc[MAX_N*3],jcr[MAX_N*3];\nint C(int n,int m) {\n    return 1ll*jc[n]*jcr[m]%MOD*jcr[n-m]%MOD;\n}\n///----------------------------------------------\nint fb[MAX_N*3],fc[MAX_N*3];\nint main() {\n\n    ///read\n    int n1,n2,n3; cin>>n1>>n2>>n3;\n    int n=n1+n2+n3;\n\n    ///prework\n    jc[0]=1; rep(i,1,n+1) jc[i]=1ll*jc[i-1]*i%MOD;\n    rep(i,0,n+1) jcr[i]=qpow(jc[i],MOD-2);\n    rep(i,n2+1,n+1) fb[i]=(fb[i-1]+(fb[i-1]+C(i-1,n2))%MOD)%MOD;\n    rep(i,n3+1,n+1) fc[i]=(fc[i-1]+(fc[i-1]+C(i-1,n3))%MOD)%MOD;\n\n    ///work\n    int ans=0;\n    rep(i,n1,n+1) {\n        int tmp=((qpow(2,i-n1)+MOD-fb[i-n1])%MOD+MOD-fc[i-n1])%MOD;\n        tmp=1ll*tmp*qpow(3,n-i)%MOD;\n        ans=(ans+1ll*tmp*C(i-1,n1-1)%MOD)%MOD;\n    }\n    cout << ans;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2) \n#include<bits/stdc++.h>\n#define rg register\n#define il inline\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7,O=1000010;\nil int gi(){\n\trg int o=0,fl=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')fl=-1,ch=getchar();\n\twhile(isdigit(ch))o=o*10+ch-'0',ch=getchar();\n\treturn fl*o;\n}\nint n,m,k;\nll fac[O],inv[O],bin[O],ans,x=1;\nil ll C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);n--;\n\tbin[0]=fac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<O;++i)bin[i]=bin[i-1]*3%mod;\n\tfor(int i=2;i<O;++i){\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t}\n\tfor(int i=2;i<O;++i)inv[i]=inv[i-1]*inv[i]%mod;\n\tfor(int i=0;i<=m+k;++i){\n\t\t(ans+=C(n+i,n)*bin[m+k-i]%mod*x%mod)%=mod;\n\t\tif(i<k)(x<<=1)%=mod;\n        else if(i<m)x=(x*2-C(i,k))%mod;\n        else x=(x*2-C(i,k)-C(i,m))%mod;\n\t}\n\tprintf(\"%lld\",ans<0?ans+mod:ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 1e6 + 10;\nconst int MOD = 1e9 + 7;\n\nll inv[N], fact[N], ifact[N], pot[N];\n\nll comb(int m, int n) {\n    if (n < 0 || n > m) return 0;\n    return fact[m] * ifact[n] % MOD * ifact[m-n] % MOD;\n}\n\nvoid add(int &a, ll b) {\n    a += b%MOD;\n    if (a >= MOD) a-= MOD;\n    if (a < 0) a += MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    inv[1] = 1; forsn(n,2,N) inv[n] = (MOD - MOD/n) * inv[MOD%n] % MOD;\n    fact[0] = 1; forsn(n,1,N) fact[n] = n * fact[n-1] % MOD;\n    ifact[0] = 1; forsn(n,1,N) ifact[n] = inv[n] * ifact[n-1] % MOD;\n    pot[0] = 1; forsn(n,1,N) pot[n] = pot[n-1]*3 % MOD;\n\n    int a,b,c; cin >> a >> b >> c;\n\n\n    ll res = 0;\n    int l = 0, r = b; ll inter = 1;\n    for (int yz = 0; yz <= b+c; yz++) {\n        while (l < yz-c) {\n            inter -= comb(yz,l++);\n            if (inter < 0) inter += MOD;\n        }\n\n        res += inter * comb(a-1+yz,a-1) % MOD * pot[b+c-yz] % MOD;\n\n        inter = 2*inter - comb(yz,r) + comb(yz,l-1);\n        inter %= MOD; if (inter < 0) inter += MOD;\n    }\n    res %= MOD;\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nconst int N=3e5+10;\nconst LL MOD=1e9+7;\n\nLL inv[N],fac[N],ifac[N],pw3[N];\n\nvoid predo() {\n    inv[1]=1;\n    REP1(i,2,N-1) inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    fac[0]=1;\n    REP1(i,1,N-1) fac[i]=fac[i-1]*i%MOD;\n    ifac[0]=1;\n    REP1(i,1,N-1) ifac[i]=ifac[i-1]*inv[i]%MOD;\n    pw3[0]=1;\n    REP(i,N-1) pw3[i+1]=pw3[i]*3%MOD;\n}\n\nLL F( int n, int m ) {\n    return fac[n+m]*ifac[m]%MOD*ifac[m]%MOD;\n}\n\nLL F( int n, int m, int k ) {\n    return fac[n+m+k]*ifac[n]%MOD*ifac[m]%MOD*ifac[k]%MOD;\n}\n\nint main() {\n    predo();\n    int n,m,k;\n    R(n,m,k);\n    LL ans=0;\n    REP1(i,0,m) {\n        REP1(j,0,k) {\n            LL r=n+m+k-(n+i+j);\n            LL now=F(n-1,i,j)*pw3[r]%MOD;\n            // dump(i,j,r,now);\n            ans+=now;\n        }\n    }\n    ans%=MOD;\n    W(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define MOD 1000000007\n\nint N, M, K;\nlong long dp[4000][1001];\n\nlong long pow(long long x, long long k) {\n  long long a = 1;\n  while (k) {\n    if (k & 1) a = (a*x) % MOD;\n    x = (x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\nlong long inv(long long x) {\n  return pow(x, MOD-2);\n}\nlong long C(long long n, long long r) {\n  long long s = 1;\n  for (int i=1; i<=r; i++) {\n    s = (s*(n+1-i)) % MOD;\n    s = (s*inv(i)) % MOD;\n  }\n  return s;\n}\n\nint main() {\n  cin >> N >> M >> K;\n\n  if (N > 1000 || M > 1000 || K > 1000) return 1;\n\n  dp[0][0] = 1;\n  long long s = 0;\n  for (int i=N; i<=N+M+K; i++) {\n    int t = i-N;\n    long long d = 0;\n    for (int m=max(0, i-N-K); m<=M; m++) {\n      d = (d + dp[t][m]) % MOD;\n      dp[t+1][m+1] = (dp[t+1][m+1] + dp[t][m]) % MOD;\n      dp[t+1][m  ] = (dp[t+1][m  ] + dp[t][m]) % MOD;\n    }\n    s += (((pow(3, N+M+K-i) * C(i-1, N-1)) % MOD) * d) % MOD;\n    s %= MOD;\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nconst int MAXN = 1000100;\n\nMint fact[MAXN];\nMint ifact[MAXN];\nMint pow2[MAXN];\nMint pow3[MAXN];\n\nvoid precalc() {\n   fact[0] = 1;\n   for (int i = 1; i < MAXN; ++i) fact[i] = fact[i - 1] * i;\n   ifact[MAXN - 1] = fact[MAXN - 1].inv();\n   for (int i = MAXN - 1; i > 0; --i) ifact[i - 1] = ifact[i] * i;\n   pow2[0] = pow3[0] = 1;\n   for (int i = 1; i < MAXN; ++i) {\n      pow2[i] = pow2[i - 1] * 2;\n      pow3[i] = pow3[i - 1] * 3;\n   }\n}\n\nMint C(int N, int K) {\n   if (N < K || K < 0) return Mint(0);\n   return fact[N] * ifact[K] * ifact[N - K];\n}\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   precalc();\n   int N, M, K;\n   cin >> N >> M >> K;\n   vector<Mint> dpM(M + K + 1);\n   vector<Mint> dpK(M + K + 1);\n   dpM[0] = dpK[0] = 1;\n   for (int i = 1; i <= M + K; ++i) {\n      dpM[i] = dpM[i - 1] * 2;\n      if (i > M) dpM[i] -= C(i - 1, M);\n      dpK[i] = dpK[i - 1] * 2;\n      if (i > K) dpK[i] -= C(i - 1, K);\n   }\n   Mint ans = 0;\n   for (int i = 0; i <= M + K; ++i) {\n      ans += C(N - 1 + i, i) * (dpM[i] + dpK[i] - pow2[i]) * pow3[M + K - i];\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nclass Combination{\npublic:\n  typedef long long ll;\n  ll N;\n  ll mod;\n  vector<ll> fac;\n  vector<ll> finv;\n  vector<ll> inv;\n  \n  \n  Combination(ll N = 1e6,ll mod = 1e9 + 7): N(N), mod(mod), fac(N+1), finv(N+1), inv(N+1){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i <= N; i++){\n      fac[i] = fac[i-1] * i % mod;\n      inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n      finv[i] = finv[i-1] * inv[i] % mod;\n    }\n  }\n\n  function<ll(ll,ll)> get = [&](ll n,ll r){\n    if( n < r ) return 0LL;\n    if( n < 0 || r < 0) return 0LL;\n    return fac[n] * (finv[r] * finv[n-r] % mod) % mod;\n  };\n\n};\n\nauto nCr = (new Combination())->get;  \n\nint N, M, K, A[1000000];\nint dp[600005];\n\nsigned main(){\n  \n  A[0] = 1;\n  \n  for(int i=1;i<1000000;i++) A[i] = A[i-1] * 3 % mod;\n  \n  cin>>N>>M>>K;\n  \n  dp[0] = 1;\n  \n  for(int i=0;i<M+K;i++){\n    \n    dp[i+1] = dp[i] * 2;\n    \n    dp[i+1] -= nCr( i, M );\n    \n    dp[i+1] -= nCr( i, K );\n    \n    dp[i+1] += mod * 2;\n    \n    dp[i+1] %= mod;\n    \n  }\n  \n  int ans = 0;\n  \n  for(int i=N;i<=N+M+K;i++){\n    \n    ans += ( dp[i-N] * nCr( i - 1, N - 1 ) % mod ) * A[(N+M+K)-i] % mod;\n    \n    ans %= mod;\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nconstexpr int mod = 1000000007;\n\n// 階乗数n!を最初に計算して、呼ばれた時に返す\nclass Factorial {\n    std::vector<int> table;\npublic:\n    Factorial(int max) : table(max) // max:テーブルのサイズ\n    {\n        table[0] = 1;\n        for (int i = 1; i < max; ++i){\n            table[i] = (static_cast<long long>(table[i - 1]) * (i + 1)) % mod;\n        }\n    }\n\n    long long operator () (int n)\n    {\n        if (n < 0) return 0;\n        if (n == 0) return 1;\n        return table[n - 1];\n    }\n};\n\nclass FactorialInverse {\n    std::vector<int> table;\n    Factorial& fact;\npublic:\n    FactorialInverse(int max, Factorial fact) : table(max), fact(fact) // max:テーブルのサイズ\n    {\n        int digit  = 0;\n        {\n            int temp = mod - 2;\n            while (temp > 0){\n                temp >>= 1;\n                ++digit;\n            }\n        }\n        auto origin = fact(max);\n        vector<int> powerorigin2(digit);\n        powerorigin2[0] = origin;\n        for (int i = 1; i < digit; ++i) powerorigin2[i] = (static_cast<long long>(powerorigin2[i - 1]) * powerorigin2[i - 1]) % mod;\n        {\n            int table_max = 1;\n            int temp = mod - 2;\n            for (int i = 0; temp > 0; ++i, temp >>= 1){\n                if (!(temp & 1)) continue;\n                table_max = (static_cast<long long>(table_max) * powerorigin2[i]) % mod;\n            }\n            table[max - 1] = table_max; // origin^(mod - 2)\n        }\n        for (int i = max - 2; i >= 0; --i){\n            table[i] = (static_cast<long long>(table[i + 1]) * (i + 2)) % mod;\n        }\n    }\n\n    long long operator () (int n)\n    {\n        if (n < 0) return 0;\n        if (n == 0) return 1;\n        return table[n - 1];\n    }\n};\n\ntemplate <typename T> // 返り値とテーブルの型\nclass Power3 {\n    std::vector<T> table;\npublic:\n    Power3(int max) : table(max) // max:テーブルのサイズ\n    {\n        table[0] = 3;\n        for (int i = 1; i < max; ++i){\n            table[i] = (static_cast<long long>(table[i - 1]) * 3) % mod;\n        }\n    }\n\n    T operator () (int n)\n    {\n        if (n < 0) return 0;\n        if (n == 0) return 1;\n        return table[n - 1];\n    }\n};\n\nint main()\n{\n    int N, M, K;\n    scanf(\"%d %d %d\\n\", &N, &M, &K);\n\n    Factorial fact(N + M + K);\n    FactorialInverse factinv(N + M + K, fact);\n    auto nCr = [&](int n, int r){\n        return (((static_cast<long long>(fact(n)) * factinv(r)) % mod) * factinv(n - r)) % mod;\n    };\n    Power3<int> pow3(M + K);\n\n    int result = 0;\n    int old_sum;\n    for (int bc = 0; bc <= M + K; ++bc){\n        int sum;\n        if (bc == 0){\n            sum = 1;\n        }else if (bc <= min(M, K)){\n            sum = (static_cast<long long>(old_sum) * 2) % mod;\n        }else if (bc <= max(M, K)){\n            sum = (((static_cast<long long>(old_sum) * 2) % mod) - nCr(bc - 1, min(M, K))) % mod;\n        }else{\n            sum = ((((static_cast<long long>(old_sum) * 2) % mod) + (mod - nCr(bc - 1, M)) % mod) + (mod - nCr(bc - 1, K))) % mod;\n        }\n        old_sum = sum;\n        result += ((((static_cast<long long>(sum) * nCr(N - 1 + bc, bc)) % mod) * pow3(M + K - bc)) % mod);\n        result %= mod;\n    }\n    printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null frac[N_MAX], invf[N_MAX];\null ncr (ull n, ull r) {\n\treturn frac[n] * (invf[r] * invf[n - r] % MOD) % MOD;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfrac[0] = invf[0] = 1;\n\tfor (i = 1; i <= 900000; i++) {\n\t\tfrac[i] = (frac[i - 1] * i) % MOD;\n\t\tinvf[i] = divide(invf[i - 1], i, MOD);\n\t}\n\n\tconst ull inv3 = divide(1, 3, MOD);\n\n\tsum = 1;\n\tull pow3 = bitpow(3, ub + uc, MOD);\n\tfor (i = 0; i <= ub + uc; i++) {\n\t\tif (i) {\n\t\t\tpow3 = (pow3 * inv3) % MOD;\n\n\t\t\tsum = (sum * 2) % MOD;\n\t\t\tif (i > ub) {\n\t\t\t\tsum = (MOD + sum - ncr(i - 1, ub)) % MOD;\n\t\t\t}\n\t\t\tif (i > uc) {\n\t\t\t\tsum = (MOD + sum - ncr(i - 1, uc)) % MOD;\n\t\t\t}\n\t\t}\n\n\t\titem = ncr(ua - 1 + i, i) * pow3 % MOD;\n\t\titem = (item * sum) % MOD;\n\n\t\t// printf(\"sum: %llu, item: %llu\\n\", sum, item);\n\n\t\tresult = (result + item) % MOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\tscanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < m; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \t// scanf(\"%lld\", &c[i]);\n\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < k; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \tscanf(\"%lld\", &d[i]);\n\t// \td[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007LL\n#define max(x,y) ((x)>(y))?(x):(y)\n#define min(x,y) ((x)>(y))?(y):(x)\n\nlong long comb_mod(int a, int b) {\n\tlong long i, j, P, Q, R, EXP;\n\tif (a == b || b == 0) return 1;\n\telse {\n\t\tP = 1;\n\t\tfor (i=1;i<=a;i++) {\n\t\t\tP *= i; P %= MOD;\n\t\t}\n\t\tQ = 1;\n\t\tfor (j=1;j<=(max(b,a-b));j++) {\n\t\t\tR = j;\n\t\t\tEXP = 1000000005LL;\n\t\t\twhile (EXP>0) {\n\t\t\t\tif (EXP & 1) Q *= R;\n\t\t\t\tR *= R;\n\t\t\t\tEXP >>= 1;\n\t\t\t\tR %= MOD; Q %= MOD;\n\t\t\t}\n\t\t\tif (j==(min(b,a-b))) {\n\t\t\t\tP *= Q; P %= MOD;\n\t\t\t}\n\t\t}\n\t\tP *= Q; P %= MOD;\n\t\treturn P;\n\t}\n}\n\nint main() {\n\tint i, j, K, M, N, X, Y;\n\tlong long P, Q, R;\n\tscanf(\"%d%d%d\", &N, &M, &K);\n\n\tP = 0; \n\tfor (i=N;i<=N+M+K;i++) {\n//\t\tprintf(\"%d\\t\", i);\n\t\tQ = 1;\n\t\tR = 3;\n\t\tj = N+M+K-i;\n\t\twhile (j>0) {\n\t\t\tif (j & 1) Q *= R;\n\t\t\tR *= R;\n\t\t\tj >>= 1;\n\t\t\tR %= MOD;\n\t\t\tQ %= MOD;\n\t\t}\n//\t\tprintf(\"%lld\\t\", Q);\n\t\tQ *= comb_mod(i-1, N-1);\n\t\tQ %= MOD;\n//\t\tprintf(\"%lld\\t\", Q);\n\t\tR = 0;\n\t\tif (i-N == 0) R = 1;\n\t\telse for (j=(max(0,i-N-K));j<=(min(i-N,M));j++) {\n\t\t\tR += comb_mod(i-N,j);\n\t\t\tR %= MOD;\n\t\t}\n\t\tQ *= R;\n\t\tQ %= MOD;\n//\t\tprintf(\"%lld\\n\", Q);\n\n\t\tP += Q;\n\t}\n\n\tprintf(\"%lld\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007LL\n#define max(x,y) ((x)>(y))?(x):(y)\n#define min(x,y) ((x)>(y))?(y):(x)\n\nlong long factinv[900010], fact[900010];\n\nvoid factorial(void) {\n\tint i, j;\n\tlong long P, Q, R, EXP;\n\n\tfact[0] = 1; factinv[0] = 1;\n\tfor (i=1;i<=900000;i++) {\n\t\tfact[i] = fact[i-1];\n\t\tfact[i] *= i;\n\t\tfact[i] %= MOD;\n\n\t\tfactinv[i] = factinv[i-1];\n\t\tP = 1;\n\t\tQ = i;\n\t\tEXP = 1000000005LL;\n\t\twhile (EXP>0) {\n\t\t\tif (EXP & 1) P *= Q;\n\t\t\tQ *= Q;\n\t\t\tEXP >>= 1;\n\t\t\tP %= MOD;\n\t\t\tQ %= MOD;\n\t\t}\n\t\tfactinv[i] *= P;\n\t\tfactinv[i] %= MOD;\n\t}\n\n}\n\nlong long comb_mod(int a, int b) {\n\tlong long P=1;\n\tP = P * fact[a];\n\tP = P * factinv[a-b] % MOD;\n\tP = P * factinv[b]   % MOD;\n\treturn P;\n}\n\nint main() {\n\tint i, j, K, M, N;\n\tlong long P, Q, R, T;\n\tfactorial();\n\tscanf(\"%d%d%d\", &N, &M, &K);\n\n\tP = 0; T = 0;\n\tfor (i=N;i<=N+M+K;i++) {\n//\t\tprintf(\"%6d\\t\", i);\n\t\tQ = 1;\n\t\tR = 3;\n\t\tj = N+M+K-i;\n\t\twhile (j>0) {\n\t\t\tif (j & 1) Q *= R;\n\t\t\tR *= R;\n\t\t\tj >>= 1;\n\t\t\tR %= MOD;\n\t\t\tQ %= MOD;\n\t\t}\n//\t\tprintf(\"%10lld\\t\", Q);\n\t\tQ *= comb_mod(i-1, N-1);\n\t\tQ %= MOD;\n//\t\tprintf(\"%10lld\\t\", Q);\n\t\tif (T==0) T = 1LL;\n\t\telse {\n\t\t\tT *= 2LL;\n\t\t\tif (i>N+K) T -= comb_mod(i-N-1, i-N-1-K);\n\t\t\tif (M<i-N) T -= comb_mod(i-N-1, M);\n\t\t}\n\t\tT %= MOD;\n\t\tif (T<0) T += MOD;\n\t\tQ *= T;\n\t\tQ %= MOD;\n//\t\tprintf(\"%10lld\\n\", Q);\n\n\t\tP += Q;\n\t\tP %= MOD;\n\t}\n\n\tprintf(\"%lld\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N\t300000\n#define MD\t1000000007\n\nint min(int a, int b) { return a < b ? a : b; }\n\nint vv[N * 3 + 1], ff[N * 3 + 1], gg[N * 3 + 1], p3[N * 2 + 1];\n\nvoid init() {\n\tint i;\n\n\tff[0] = gg[0] = 1;\n\tfor (i = 1; i <= N * 3; i++) {\n\t\tvv[i] = i == 1 ? 1 : (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n\t\tff[i] = (long long) ff[i - 1] * i % MD;\n\t\tgg[i] = (long long) gg[i - 1] * vv[i] % MD;\n\t}\n\tp3[0] = 1;\n\tfor (i = 1; i <= N * 2; i++)\n\t\tp3[i] = p3[i - 1] * 3LL % MD;\n}\n\nlong long choose(int n, int k) {\n\treturn k < 0 || k > n ? 0 : (long long) ff[n] * gg[k] % MD * gg[n - k] % MD;\n}\n\nint main() {\n\tint n, m, k, i, ans, sum;\n\n\tinit();\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tans = 0, sum = 1;\n\tfor (i = 0; i <= m + k; i++) {\n\t\tans = (ans + sum * choose(n - 1 + i, n - 1) % MD * p3[m + k - i]) % MD;\n\t\tsum = (sum * 2 - choose(i, i - k) - choose(i, m)) % MD;\n\t}\n\tif (ans < 0)\n\t\tans += MD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N\t300000\n#define MD\t1000000007\n\nint min(int a, int b) { return a < b ? a : b; }\n\nlong long power(int a, int k, int md) {\n\tlong long b = a, p = 1;\n\n\twhile (k) {\n\t\tif (k & 1)\n\t\t\tp = p * b % md;\n\t\tb = b * b % md;\n\t\tk >>= 1;\n\t}\n\treturn p;\n}\n\nint ff[N * 2 + 1], gg[N * 2 + 1], p3[N * 2 + 1];\n\nvoid init() {\n\tint i, f, p;\n\n\tf = 1;\n\tfor (i = 0; i <= N * 2; i++) {\n\t\tgg[i] = power(ff[i] = f, MD - 2, MD);\n\t\tf = (long long) f * (i + 1) % MD;\n\t}\n\tp = 1;\n\tfor (i = 0; i <= N * 2; i++) {\n\t\tp3[i] = p;\n\t\tp = (long long) p * 3 % MD;\n\t}\n}\n\nlong long choose(int n, int k) {\n\treturn k < 0 || k > n ? 0 : (long long) ff[n] * gg[k] % MD * gg[n - k] % MD;\n}\n\nint main() {\n\tint n, m, k, i, ans, sum;\n\n\tinit();\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tans = 0, sum = 1;\n\tfor (i = 0; i <= m + k; i++) {\n\t\tans = (ans + sum * choose(n - 1 + i, n - 1) % MD * p3[m + k - i]) % MD;\n\t\tsum = (sum * 2 - choose(i, i - k) - choose(i, min(i, m))) % MD;\n\t\tif (i + 1 <= m)\n\t\t\tsum = (sum + 1) % MD;\n\t}\n\tif (ans < 0)\n\t\tans += MD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007LL\n#define max(x,y) ((x)>(y))?(x):(y)\n#define min(x,y) ((x)>(y))?(y):(x)\n\nlong long factinv[900010], fact[900010];\n\nvoid factorial(void) {\n\tint i, j;\n\tlong long P, Q, R, EXP;\n\n\tfact[0] = 1; factinv[0] = 1;\n\tfor (i=1;i<=900000;i++) {\n\t\tfact[i] = fact[i-1];\n\t\tfact[i] *= i;\n\t\tfact[i] %= MOD;\n\t}\n\tfor (i=1;i<=900000;i++) {\n\t\tfactinv[i] = factinv[i-1];\n\t\tP = 1;\n\t\tQ = i;\n\t\tEXP = 1000000005LL;\n\t\twhile (EXP>0) {\n\t\t\tif (EXP & 1) P *= Q;\n\t\t\tQ *= Q;\n\t\t\tEXP >>= 1;\n\t\t\tP %= MOD;\n\t\t\tQ %= MOD;\n\t\t}\n\t\tfactinv[i] *= P;\n\t\tfactinv[i] %= MOD;\n\t}\n\n}\n\nlong long comb_mod(int a, int b) {\n\tlong long P=1;\n\tP = P * fact[a];\n\tP = P * factinv[a-b] % MOD;\n\tP = P * factinv[b]   % MOD;\n\treturn P;\n}\n\nint main() {\n\tint i, j, K, M, N;\n\tlong long P, Q, R;\n\tfactorial();\n\tscanf(\"%d%d%d\", &N, &M, &K);\n\n\tP = 0; \n\tfor (i=N;i<=N+M+K;i++) {\n//\t\tprintf(\"%6d\\t\", i);\n\t\tQ = 1;\n\t\tR = 3;\n\t\tj = N+M+K-i;\n\t\twhile (j>0) {\n\t\t\tif (j & 1) Q *= R;\n\t\t\tR *= R;\n\t\t\tj >>= 1;\n\t\t\tR %= MOD;\n\t\t\tQ %= MOD;\n\t\t}\n//\t\tprintf(\"%10lld\\t\", Q);\n\t\tQ *= comb_mod(i-1, N-1);\n\t\tQ %= MOD;\n//\t\tprintf(\"%10lld\\t\", Q);\n\t\tR = 0;\n\t\tif (i-N == 0) R = 1;\n\t\telse for (j=(max(0,i-N-K));j<=(min(i-N,M));j++) {\n\t\t\tR += comb_mod(i-N,j);\n\t\t\tR %= MOD;\n\t\t}\n\t\tQ *= R;\n\t\tQ %= MOD;\n//\t\tprintf(\"%10lld\\n\", Q);\n\n\t\tP += Q;\n\t\tP %= MOD;\n\t}\n\n\tprintf(\"%lld\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N\t300000\n#define MD\t1000000007\n\nint min(int a, int b) { return a < b ? a : b; }\n\nlong long power(int a, int k, int md) {\n\tlong long b = a, p = 1;\n\n\twhile (k) {\n\t\tif (k & 1)\n\t\t\tp = p * b % md;\n\t\tb = b * b % md;\n\t\tk >>= 1;\n\t}\n\treturn p;\n}\n\nint ff[N * 3 + 1], gg[N * 3 + 1], p3[N * 2 + 1];\n\nvoid init() {\n\tint i, f, p;\n\n\tf = 1;\n\tfor (i = 0; i <= N * 3; i++) {\n\t\tgg[i] = power(ff[i] = f, MD - 2, MD);\n\t\tf = (long long) f * (i + 1) % MD;\n\t}\n\tp = 1;\n\tfor (i = 0; i <= N * 2; i++) {\n\t\tp3[i] = p;\n\t\tp = (long long) p * 3 % MD;\n\t}\n}\n\nlong long choose(int n, int k) {\n\treturn k < 0 || k > n ? 0 : (long long) ff[n] * gg[k] % MD * gg[n - k] % MD;\n}\n\nint main() {\n\tint n, m, k, i, ans, sum;\n\n\tinit();\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tans = 0, sum = 1;\n\tfor (i = 0; i <= m + k; i++) {\n\t\tans = (ans + sum * choose(n - 1 + i, n - 1) % MD * p3[m + k - i]) % MD;\n\t\tsum = (sum * 2 - choose(i, i - k) - choose(i, min(i, m))) % MD;\n\t\tif (i + 1 <= m)\n\t\t\tsum = (sum + 1) % MD;\n\t}\n\tif (ans < 0)\n\t\tans += MD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N\t300000\n#define MD\t1000000007\n\nint min(int a, int b) { return a < b ? a : b; }\n\nlong long power(int a, int k, int md) {\n\tlong long b = a, p = 1;\n\n\twhile (k) {\n\t\tif (k & 1)\n\t\t\tp = p * b % md;\n\t\tb = b * b % md;\n\t\tk >>= 1;\n\t}\n\treturn p;\n}\n\nint ff[N + 1], gg[N + 1], p3[N * 2 + 1];\n\nvoid init() {\n\tint i, f, p;\n\n\tf = 1;\n\tfor (i = 0; i <= N; i++) {\n\t\tgg[i] = power(ff[i] = f, MD - 2, MD);\n\t\tf = (long long) f * (i + 1) % MD;\n\t}\n\tp = 1;\n\tfor (i = 0; i <= N * 2; i++) {\n\t\tp3[i] = p;\n\t\tp = (long long) p * 3 % MD;\n\t}\n}\n\nlong long choose(int n, int k) {\n\treturn k < 0 || k > n ? 0 : (long long) ff[n] * gg[k] % MD * gg[n - k] % MD;\n}\n\nint main() {\n\tint n, m, k, i, ans, sum;\n\n\tinit();\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tans = 0, sum = 1;\n\tfor (i = 0; i <= m + k; i++) {\n\t\tans = (ans + sum * choose(n - 1 + i, n - 1) % MD * p3[m + k - i]) % MD;\n\t\tsum = (sum * 2 - choose(i, i - k) - choose(i, min(i, m))) % MD;\n\t\tif (i + 1 <= m)\n\t\t\tsum = (sum + 1) % MD;\n\t}\n\tif (ans < 0)\n\t\tans += MD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007LL\n#define max(x,y) ((x)>(y))?(x):(y)\n#define min(x,y) ((x)>(y))?(y):(x)\n\nlong long factinv[900010], fact[900010];\n\nvoid factorial(void) {\n\tint i, j;\n\tlong long P, Q, R, EXP;\n\n\tfact[0] = 1; factinv[0] = 1;\n\tfor (i=1;i<=900000;i++) {\n\t\tfact[i] = fact[i-1];\n\t\tfact[i] *= i;\n\t\tfact[i] %= MOD;\n\n\t\tfactinv[i] = factinv[i-1];\n\t\tP = 1;\n\t\tQ = i;\n\t\tEXP = 1000000005LL;\n\t\twhile (EXP>0) {\n\t\t\tif (EXP & 1) P *= Q;\n\t\t\tQ *= Q;\n\t\t\tEXP >>= 1;\n\t\t\tP %= MOD;\n\t\t\tQ %= MOD;\n\t\t}\n\t\tfactinv[i] *= P;\n\t\tfactinv[i] %= MOD;\n\t}\n\n}\n\nlong long comb_mod(int a, int b) {\n\tlong long P=1;\n\tP = P * fact[a];\n\tP = P * factinv[a-b] % MOD;\n\tP = P * factinv[b]   % MOD;\n\treturn P;\n}\n\nint main() {\n\tint i, j, K, M, N;\n\tlong long P, Q, R;\n\tfactorial();\n\tscanf(\"%d%d%d\", &N, &M, &K);\n\n\tP = 0; \n\tfor (i=N;i<=N+M+K;i++) {\n//\t\tprintf(\"%6d\\t\", i);\n\t\tQ = 1;\n\t\tR = 3;\n\t\tj = N+M+K-i;\n\t\twhile (j>0) {\n\t\t\tif (j & 1) Q *= R;\n\t\t\tR *= R;\n\t\t\tj >>= 1;\n\t\t\tR %= MOD;\n\t\t\tQ %= MOD;\n\t\t}\n//\t\tprintf(\"%10lld\\t\", Q);\n\t\tQ *= comb_mod(i-1, N-1);\n\t\tQ %= MOD;\n//\t\tprintf(\"%10lld\\t\", Q);\n\t\tR = 0;\n\t\tif (i-N == 0) R = 1;\n\t\telse for (j=(max(0,i-N-K));j<=(min(i-N,M));j++) {\n\t\t\tR += comb_mod(i-N,j);\n\t\t\tR %= MOD;\n\t\t}\n\t\tQ *= R;\n\t\tQ %= MOD;\n//\t\tprintf(\"%10lld\\n\", Q);\n\n\t\tP += Q;\n\t\tP %= MOD;\n\t}\n\n\tprintf(\"%lld\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007LL\n#define max(x,y) ((x)>(y))?(x):(y)\n#define min(x,y) ((x)>(y))?(y):(x)\n\nlong long factinv[300010], fact[300010];\n\nvoid factorial(void) {\n\tint i, j;\n\tlong long P, Q, R, EXP;\n\n\tfact[0] = 1; factinv[0] = 1;\n\tfor (i=1;i<=300000;i++) {\n\t\tfact[i] = fact[i-1];\n\t\tfact[i] *= i;\n\t\tfact[i] %= MOD;\n\t}\n\tfor (i=1;i<=300000;i++) {\n\t\tfactinv[i] = factinv[i-1];\n\t\tP = 1;\n\t\tQ = i;\n\t\tEXP = 1000000005LL;\n\t\twhile (EXP>0) {\n\t\t\tif (EXP & 1) P *= Q;\n\t\t\tQ *= Q;\n\t\t\tEXP >>= 1;\n\t\t\tP %= MOD;\n\t\t\tQ %= MOD;\n\t\t}\n\t\tfactinv[i] *= P;\n\t\tfactinv[i] %= MOD;\n\t}\n\n}\n\nlong long comb_mod(int a, int b) {\n\tlong long P=1;\n\tP = P * fact[a];\n\tP = P * factinv[a-b] % MOD;\n\tP = P * factinv[b]   % MOD;\n\treturn P;\n}\n\nint main() {\n\tint i, j, K, M, N, X, Y;\n\tlong long P, Q, R;\n\tfactorial();\n\tscanf(\"%d%d%d\", &N, &M, &K);\n\n\tP = 0; \n\tfor (i=N;i<=N+M+K;i++) {\n//\t\tprintf(\"%d\\t\", i);\n\t\tQ = 1;\n\t\tR = 3;\n\t\tj = N+M+K-i;\n\t\twhile (j>0) {\n\t\t\tif (j & 1) Q *= R;\n\t\t\tR *= R;\n\t\t\tj >>= 1;\n\t\t\tR %= MOD;\n\t\t\tQ %= MOD;\n\t\t}\n//\t\tprintf(\"%lld\\t\", Q);\n\t\tQ *= comb_mod(i-1, N-1);\n\t\tQ %= MOD;\n//\t\tprintf(\"%lld\\t\", Q);\n\t\tR = 0;\n\t\tif (i-N == 0) R = 1;\n\t\telse for (j=(max(0,i-N-K));j<=(min(i-N,M));j++) {\n\t\t\tR += comb_mod(i-N,j);\n\t\t\tR %= MOD;\n\t\t}\n\t\tQ *= R;\n\t\tQ %= MOD;\n//\t\tprintf(\"%lld\\n\", Q);\n\n\t\tP += Q;\n\t\tP %= MOD;\n\t}\n\n\tprintf(\"%lld\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic long MOD = 1_000_000_007;\n\tstatic long[] pow3 = new long[1_000_000];\n\tstatic long[] fact = new long[1_000_000];\n\tstatic long[] finv = new long[1_000_000];\n\tstatic int N, M, K;\n\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tK = sc.nextInt();\n\t\tif (N > 1000 || M > 1000 || K > 1000) return;\n\t\tpow3[0] = 1;\n\t\tfact[0] = 1;\n\t\tfinv[0] = inv(1);\n\t\tfor (int i = 1; i < pow3.length; ++i) {\n\t\t\tpow3[i] = pow3[i - 1] * 3 % MOD;\n\t\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\t\tfinv[i] = inv(fact[i]);\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i <= M; ++i) {\n\t\t\tfor (int j = 0; j <= K; ++j) {\n\t\t\t\tans += solve(i, j);\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long solve(int b, int c) {\n\t\tlong ret = pow3[M - b] * pow3[K - c] % MOD;\n\t\tret *= fact[N - 1 + b + c];\n\t\tret %= MOD;\n\t\tret *= finv[N - 1];\n\t\tret %= MOD;\n\t\tret *= finv[b];\n\t\tret %= MOD;\n\t\tret *= finv[c];\n\t\tret %= MOD;\n\t\treturn ret;\n\t}\n\n\tstatic long inv(long v) {\n\t\treturn pow(v, MOD - 2);\n\t}\n\n\tstatic long pow(long v, long p) {\n\t\tif (p == 0) return 1;\n\t\tif (p == 1) return v;\n\t\tlong ret = pow(v, p / 2);\n\t\tret *= ret;\n\t\tret %= MOD;\n\t\tif (p % 2 == 1) {\n\t\t\tret *= v;\n\t\t\tret %= MOD;\n\t\t}\n\t\treturn ret;\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni(), K = ni();\n\t\t// (t-1)!/(n-1)!b!c!*3^(n+m+K-t)\n\t\t// b<=m, c<=K\n\t\tint mod = 1000000007;\n\t\tint[][] fif = enumFIF(1000000, mod);\n\t\tlong[] ib = new long[m+1];\n\t\tfor(int i = 0;i <= m;i++)ib[i] = fif[1][i];\n\t\tlong[] ic = new long[K+1];\n\t\tfor(int i = 0;i <= K;i++)ic[i] = fif[1][i];\n\t\tlong[] is = convolute(ib, ic, 3, mod);\n\t\tlong ret = 0;\n\t\tfor(int t = n;t <= n+m+K;t++){\n\t\t\tret = ret * 3 + (long)fif[0][t-1]*is[t-n];\n\t\t\tret %= mod;\n\t\t}\n\t\tret = ret * fif[1][n-1] % mod;\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};\n\tpublic static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};\n//\tpublic static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};\n//\tpublic static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};\n\t\n\tpublic static long[] convoluteSimply(long[] a, long[] b, int P, int g)\n\t{\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t}\n\t\treturn nttmb(fa, m, true, P, g);\n\t}\n\t\n\tpublic static long[] convolute(long[] a, long[] b)\n\t{\n\t\tint USE = 2;\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[][] fs = new long[USE][];\n\t\tfor(int k = 0;k < USE;k++){\n\t\t\tint P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n\t\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t\t}\n\t\t\tfs[k] = nttmb(fa, m, true, P, g);\n\t\t}\n\t\t\n\t\tint[] mods = Arrays.copyOf(NTTPrimes, USE);\n\t\tlong[] gammas = garnerPrepare(mods);\n\t\tint[] buf = new int[USE];\n\t\tfor(int i = 0;i < fs[0].length;i++){\n\t\t\tfor(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n\t\t\tlong[] res = garnerBatch(buf, mods, gammas);\n\t\t\tlong ret = 0;\n\t\t\tfor(int j = res.length-1;j >= 0;j--)ret = ret * mods[j] + res[j];\n\t\t\tfs[0][i] = ret;\n\t\t}\n\t\treturn fs[0];\n\t}\n\t\n\tpublic static long[] convolute(long[] a, long[] b, int USE, int mod)\n\t{\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[][] fs = new long[USE][];\n\t\tfor(int k = 0;k < USE;k++){\n\t\t\tint P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n\t\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t\t}\n\t\t\tfs[k] = nttmb(fa, m, true, P, g);\n\t\t}\n\t\t\n\t\tint[] mods = Arrays.copyOf(NTTPrimes, USE);\n\t\tlong[] gammas = garnerPrepare(mods);\n\t\tint[] buf = new int[USE];\n\t\tfor(int i = 0;i < fs[0].length;i++){\n\t\t\tfor(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n\t\t\tlong[] res = garnerBatch(buf, mods, gammas);\n\t\t\tlong ret = 0;\n\t\t\tfor(int j = res.length-1;j >= 0;j--)ret = (ret * mods[j] + res[j]) % mod;\n\t\t\tfs[0][i] = ret;\n\t\t}\n\t\treturn fs[0];\n\t}\n\t\n\t// static int[] wws = new int[270000]; // outer faster\n\t\n\t// Modifed Montgomery + Barrett\n\tprivate static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)\n\t{\n\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\n\t\tint h = Integer.numberOfTrailingZeros(n);\n\t\tlong K = Integer.highestOneBit(P)<<1;\n\t\tint H = Long.numberOfTrailingZeros(K)*2;\n\t\tlong M = K*K/P;\n\t\t\n\t\tint[] wws = new int[1<<h-1];\n\t\tlong dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n\t\tlong w = (1L<<32)%P;\n\t\tfor(int k = 0;k < 1<<h-1;k++){\n\t\t\twws[k] = (int)w;\n\t\t\tw = modh(w*dw, M, H, P);\n\t\t}\n\t\tlong J = invl(P, 1L<<32);\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < 1<<i;j++){\n\t\t\t\tfor(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n\t\t\t\t\tlong u = (dst[s] - dst[t] + 2*P)*wws[k];\n\t\t\t\t\tdst[s] += dst[t];\n\t\t\t\t\tif(dst[s] >= 2*P)dst[s] -= 2*P;\n//\t\t\t\t\tlong Q = (u&(1L<<32)-1)*J&(1L<<32)-1;\n\t\t\t\t\tlong Q = (u<<32)*J>>>32;\n\t\t\t\t\tdst[t] = (u>>>32)-(Q*P>>>32)+P;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i < h-1){\n\t\t\t\tfor(int k = 0;k < 1<<h-i-2;k++)wws[k] = wws[k*2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(dst[i] >= P)dst[i] -= P;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint rev = Integer.reverse(i)>>>-h;\n\t\t\tif(i < rev){\n\t\t\t\tlong d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(inverse){\n\t\t\tlong in = invl(n, P);\n\t\t\tfor(int i = 0;i < n;i++)dst[i] = modh(dst[i]*in, M, H, P);\n\t\t}\n\t\t\n\t\treturn dst;\n\t}\n\t\n\t// Modified Shoup + Barrett\n\tprivate static long[] nttsb(long[] src, int n, boolean inverse, int P, int g)\n\t{\n\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\n\t\tint h = Integer.numberOfTrailingZeros(n);\n\t\tlong K = Integer.highestOneBit(P)<<1;\n\t\tint H = Long.numberOfTrailingZeros(K)*2;\n\t\tlong M = K*K/P;\n\t\t\n\t\tlong dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n\t\tlong[] wws = new long[1<<h-1];\n\t\tlong[] ws = new long[1<<h-1];\n\t\tlong w = 1;\n\t\tfor(int k = 0;k < 1<<h-1;k++){\n\t\t\twws[k] = (w<<32)/P;\n\t\t\tws[k] = w;\n\t\t\tw = modh(w*dw, M, H, P);\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < 1<<i;j++){\n\t\t\t\tfor(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n\t\t\t\t\tlong ndsts = dst[s] + dst[t];\n\t\t\t\t\tif(ndsts >= 2*P)ndsts -= 2*P;\n\t\t\t\t\tlong T = dst[s] - dst[t] + 2*P;\n\t\t\t\t\tlong Q = wws[k]*T>>>32;\n\t\t\t\t\tdst[s] = ndsts;\n\t\t\t\t\tdst[t] = ws[k]*T-Q*P&(1L<<32)-1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdw = dw * dw % P;\n\t\t\tif(i < h-1){\n\t\t\t\tfor(int k = 0;k < 1<<h-i-2;k++){\n\t\t\t\t\twws[k] = wws[k*2];\n\t\t\t\t\tws[k] = ws[k*2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(dst[i] >= P)dst[i] -= P;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint rev = Integer.reverse(i)>>>-h;\n\t\t\tif(i < rev){\n\t\t\t\tlong d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(inverse){\n\t\t\tlong in = invl(n, P);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tdst[i] = modh(dst[i] * in, M, H, P);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dst;\n\t}\n\t\n\tstatic final long mask = (1L<<31)-1;\n\t\n\tpublic static long modh(long a, long M, int h, int mod)\n\t{\n\t\tlong r = a-((M*(a&mask)>>>31)+M*(a>>>31)>>>h-31)*mod;\n\t\treturn r < mod ? r : r-mod;\n\t}\n\t\n\tprivate static long[] garnerPrepare(int[] m)\n\t{\n\t\tint n = m.length;\n\t\tassert n == m.length;\n\t\tif(n == 0)return new long[0];\n\t\tlong[] gamma = new long[n];\n\t\tfor(int k = 1;k < n;k++){\n\t\t\tlong prod = 1;\n\t\t\tfor(int i = 0;i < k;i++){\n\t\t\t\tprod = prod * m[i] % m[k];\n\t\t\t}\n\t\t\tgamma[k] = invl(prod, m[k]);\n\t\t}\n\t\treturn gamma;\n\t}\n\t\n\tprivate static long[] garnerBatch(int[] u, int[] m, long[] gamma)\n\t{\n\t\tint n = u.length;\n\t\tassert n == m.length;\n\t\tlong[] v = new long[n];\n\t\tv[0] = u[0];\n\t\tfor(int k = 1;k < n;k++){\n\t\t\tlong temp = v[k-1];\n\t\t\tfor(int j = k-2;j >= 0;j--){\n\t\t\t\ttemp = (temp * m[j] + v[j]) % m[k];\n\t\t\t}\n\t\t\tv[k] = (u[k] - temp) * gamma[k] % m[k];\n\t\t\tif(v[k] < 0)v[k] += m[k];\n\t\t}\n\t\treturn v;\n\t}\n\t\n\tprivate static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tprivate static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        prec(1000000);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int k = in.nextInt();\n\n        long[] pow3 = new long[1000000];\n        pow3[0] = 1;\n        for (int i = 1 ; i < pow3.length; i++) {\n            pow3[i] = (pow3[i-1] * 3) % MOD;\n        }\n\n        long[] ptn = computePatterns(1000000, m, k);\n\n        long ways = 0;\n        for (int l = n ; l <= n + m + k ; l++) {\n            long add = comb(l-1, n-1);\n            add *= ptn[l-n];\n            add %= MOD;\n            add *= pow3[n+m+k-l];\n            add %= MOD;\n            ways += add;\n            ways %= MOD;\n        }\n\n        out.println(ways);\n        out.flush();\n    }\n\n    static long[] computePatterns(int n, int a, int b) {\n        if (a > b) {\n            return computePatterns(n, b, a);\n        }\n        n = Math.max(n, a+b+1);\n\n        long[] ret = new long[n+1];\n        ret[0] = 1;\n\n        for (int i = 1 ; i < n ; i++) {\n            ret[i] = ret[i-1] * 2 % MOD;\n        }\n\n        for (int p : new int[]{a, b}) {\n            long left = 0;\n            for (int i = p + 1; i < n; i++) {\n                left = left * 2 % MOD;\n                left = left + comb(i - 1, i - (p + 1));\n                left %= MOD;\n                ret[i] = (ret[i] + MOD - left) % MOD;\n            }\n        }\n        for (int i = a+b+1 ; i < n ; i++) {\n            ret[i] = 0;\n        }\n        return ret;\n\n    }\n\n    static final int MOD = 1000000007;\n\n    static long pow(long a, long x) {\n        long res = 1;\n        while (x > 0) {\n            if (x % 2 != 0) {\n                res = (res * a) % MOD;\n            }\n            a = (a * a) % MOD;\n            x /= 2;\n        }\n        return res;\n    }\n\n    static long inv(long a) {\n        return pow(a, MOD - 2) % MOD;\n    }\n\n    static long[] _fact;\n    static long[] _invfact;\n\n    static long comb(long ln, long lr) {\n        int n = (int) ln;\n        int r = (int) lr;\n        if (n < 0 || r < 0 || r > n) {\n            return 0;\n        }\n        if (r > n / 2) {\n            r = n - r;\n        }\n        return (((_fact[n] * _invfact[n - r]) % MOD) * _invfact[r]) % MOD;\n    }\n\n    static void prec(int n) {\n        _fact = new long[n + 1];\n        _invfact = new long[n + 1];\n        _fact[0] = 1;\n        _invfact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            _fact[i] = _fact[i - 1] * i % MOD;\n            _invfact[i] = inv(_fact[i]);\n        }\n    }\n\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            PrintWriter out = new PrintWriter(outputStream);\n            TaskD solver = new TaskD();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskD {\n        public void solve(int testNumber, FastInput in, PrintWriter out) {\n            NumberTheory.Modular mod = new NumberTheory.Modular((int) 1e9 + 7);\n            NumberTheory.Power power = new NumberTheory.Power(mod);\n            NumberTheory.Factorial fact = new NumberTheory.Factorial(3000, mod);\n\n            int n = in.readInt();\n            int m = in.readInt();\n            int k = in.readInt();\n\n            int ans = 0;\n            for (int i = 0; i <= m; i++) {\n                for (int j = 0; j <= k; j++) {\n                    int cnt = fact.fact(n - 1 + i + j);\n                    cnt = mod.mul(cnt, fact.invFact(n - 1));\n                    cnt = mod.mul(cnt, fact.invFact(i));\n                    cnt = mod.mul(cnt, fact.invFact(j));\n                    int remain = m + k - i - j;\n                    cnt = mod.mul(cnt, power.pow(3, remain));\n\n                    ans = mod.plus(ans, cnt);\n                }\n            }\n\n            out.println(ans);\n        }\n\n    }\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n        }\n\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, NumberTheory.Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n\n        }\n\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n\n            public Factorial(int[] fact, int[] inv, NumberTheory.InverseNumber in, int limit,\n                            NumberTheory.Modular modular) {\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new NumberTheory.InverseNumber(limit, modular), limit,\n                                modular);\n            }\n\n            public int fact(int n) {\n                return fact[n];\n            }\n\n            public int invFact(int n) {\n                return inv[n];\n            }\n\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n \n \n \npublic class Main {\n\tpublic static long C(int n, int r)\n\t{\n\t\tif(n < 0 || r < 0 || r > n)return 0;\n\t\tif(r > n / 2)r = n - r;\n\t\treturn FACT[n]*IFACT[n-r]%mod*IFACT[r]%mod;\n\t}\n\t \n\tstatic long[] FACT, IFACT;\n\t \n\t\t\n\tstatic int MOD = 1000000007;\n\tstatic int mod = MOD;\n\tpublic static void main(String[] args) {\n\t\tint n = 300000;\n\t\tFACT = new long[n+1];\n\t\tIFACT = new long[n+1];\n\t\tFACT[0] = 1;\n\t\tIFACT[0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tFACT[i] = FACT[i-1] * i % mod;\n\t\t\tIFACT[i] = new BigInteger(String.valueOf(FACT[i])).modInverse(new BigInteger(String.valueOf(mod))).longValue();\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintStream out = new PrintStream(System.out);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tlong ans = 0;\n\t\t\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tint retA = modPow(3,N + M + K - i);\n\t\t\t\n\t\t\tint retB = (int)C(i-1,N-1);\n\t\t\tint kMax = Math.max(0, i - N-K);\n\t\t\tint kMin = Math.min(i - N, M);\n\t\t\tlong sum = 0;\n\t\t\tfor(int k = kMax; k <= kMin; k++) {\n\t\t\t\tsum += (int)C(i - N, k) % MOD;\n\t\t\t\tsum %= MOD;\n\t\t\t}\n\t\t\tlong ansA = ((long)(retA) * (long)(retB)) % MOD;\n\t\t\tansA *= sum % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static int modPow(int a, int b) {\n\t\tif(b == 0) return 1 % MOD;\n\t\tif(b == 1) return a % MOD;\n\t\t\n\t\tif(b % 2 == 0) {\n\t\t\tlong ret = modPow(a % MOD,b / 2) % MOD;\n\t\t\treturn (int)((ret * ret) % MOD);\n\t\t}\n\t\telse {\n\t\t\tlong ret = (a * (long)modPow(a % MOD,b-1)) % MOD;\n\t\t\treturn (int)(ret % MOD);\n\t\t}\n\t}\n\tpublic static int comb(int n, int k) {\n\t\tif(k == 0) return 1;\n\t\tlong AA = 1;\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tAA *= (long)n - i;\n\t\t\tAA %= MOD;\n\t\t}\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tAA *= new BigInteger(String.valueOf(i)).modInverse(new BigInteger(String.valueOf(MOD))).longValue();\n\t\t\tAA %= MOD;\n\t\t}\n\t\treturn (int)(AA % MOD);\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass SmallSolver {\n  final int n, m, k;\n  ModCalculator mc;\n  \n  SmallSolver (int n, int m, int k) {\n    this.n = n;\n    this.m = m;\n    this.k = k;\n  }\n  \n  public long solve() {\n    mc = new ModCalculator(1_000_000_007L);\n    long answer = 0;\n    for (int bc = 0; bc <= m + k; bc++) {\n      for (int b = 0; b <= m; b++) {\n        int c = bc - b;\n        if (c < 0 || k < c) {\n          continue;\n        }\n        \n        // a [abc]* a\n        long v1 = mc.getC(n + b + c - 1, b);\n        long v2 = mc.getC(n + c - 1, c);\n        long v3 = mc.pow(3, (m - b) + (k - c));\n        long v = mc.mul(v1, mc.mul(v2, v3));\n        answer = mc.add(answer, v);\n      }\n    }\n    return answer;\n  }\n}\n\nclass LargeSolver {\n  final int n, m, k;\n  ModCalculator mc;\n  \n  LargeSolver (int n, int m, int k) {\n    this.n = n;\n    this.m = m;\n    this.k = k;\n  }\n  \n  public long solve() {\n    mc = new ModCalculator(1_000_000_007L);\n    long answer = 0;\n    for (int x = 0; x <= m + k; x++) {\n      // a [ax]* a\n      long v1 = mc.getC(n + x - 1, x);\n      long v2 = mc.pow(3, m + k - x);\n      long v3 = mc.pow(2, x);\n      long v = mc.mul(v1, mc.mul(v2, v3));\n      answer = mc.add(answer, v);\n    }\n    \n    long vTemp = 0;\n    for (int y = 1; y <= k; y++) {\n      int x = y + m;\n      long v1 = mc.getC(n + x - 1, x);\n      long v2 = mc.pow(3, m + k - x);\n      vTemp = mc.mul(vTemp, 2);\n      vTemp = mc.add(vTemp, mc.getC(x - 1, m));\n      long v = mc.mul(v1, mc.mul(v2, vTemp));\n      answer = mc.sub(answer, v);\n    }\n    \n    vTemp = 0;\n    for (int y = 1; y <= m; y++) {\n      int x = y + k;\n      long v1 = mc.getC(n + x - 1, x);\n      long v2 = mc.pow(3, m + k - x);\n      vTemp = mc.mul(vTemp, 2);\n      vTemp = mc.add(vTemp, mc.getC(x - 1, k));\n      long v = mc.mul(v1, mc.mul(v2, vTemp));\n      answer = mc.sub(answer, v);\n    }\n    return answer;\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, PrintWriter out) {\n    int n = reader.nextInt();\n    int m = reader.nextInt();\n    int k = reader.nextInt();\n//    out.println(new SmallSolver(n, m, k).solve());\n    out.println(new LargeSolver(n, m, k).solve());\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestReader {\n  private BufferedReader reader;\n  private StringTokenizer tokenizer;\n  \n  ContestReader(InputStream in) {\n    reader = new BufferedReader(new InputStreamReader(in));\n  }\n  \n  public String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n  \n  public int nextInt() {\n    return Integer.parseInt(next());\n  }\n  \n  public long nextLong() {\n    return Long.parseLong(next());\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] nextArray(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public int[] nextIntArray(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLongArray(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDoubleArray(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public int[][] nextIntMatrix(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLongMatrix(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDoubleMatrix(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long add(long a, long b) {\n    return (a + b) % mod;\n  }\n  \n  public long sub(long a, long b) {\n    return (a - b + mod) % mod;\n  }\n  \n  public long mul(long a, long b) {\n    return (a * b) % mod;\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n  \n  class ModCombinationCache {\n    private final List<Long> factorialCache;\n    private final List<Long> factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new ArrayList<>();\n      factorialCache.add(1L);\n      factorialInverseCache = new ArrayList<>();\n      factorialInverseCache.add(1L);\n    }\n    \n    private void resize(int n) {\n      for (int i = factorialCache.size() - 1; i < n; i++) {\n        long v = mul(factorialCache.get(i), i + 1);\n        factorialCache.add(v);\n        factorialInverseCache.add(inverse(v));\n      }\n    }\n    \n    long getF(int n) {\n      resize(n);\n      return factorialCache.get(n);\n    }\n    \n    long getP(int n, int r) {\n      resize(n);\n      return mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n    }\n    \n    long getC(int n, int k) {\n      resize(n);\n      return mul(factorialCache.get(n), mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n    }\n  }\n}\n \nclass Algorithm {\n  private static void swap(Object[] list, int a, int b) {\n    Object tmp = list[a];\n    list[a] = list[b];\n    list[b] = tmp;\n  }\n  \n  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {\n    int rightMostAscendingOrderIndex = ts.length - 2;\n    while (rightMostAscendingOrderIndex >= 0 &&\n        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {\n      rightMostAscendingOrderIndex--;\n    }\n    if (rightMostAscendingOrderIndex < 0) {\n      return false;\n    }\n    \n    int rightMostGreatorIndex = ts.length - 1;\n    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {\n      rightMostGreatorIndex--;\n    }\n    \n    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);\n    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {\n      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);\n    }\n    return true;\n  }\n  \n  public static void shuffle(int[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      int temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void shuffle(long[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      long temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void sort(int[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n  \n  public static void sort(long[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n}\n\nclass UnionFind {\n  int[] parents;\n  int[] ranks;\n\n  UnionFind(int n) {\n    parents = new int[n];\n    ranks = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      parents[i] = i;\n    }\n  }\n\n  public int getRoot(int index) {\n    if (parents[index] == index) {\n      return index;\n    } else {\n      parents[index] = getRoot(parents[index]);\n      return parents[index];\n    }\n  }\n\n  public boolean sameGroup(int a, int b) {\n    return getRoot(a) == getRoot(b);\n  }\n\n  public void merge(int a, int b) {\n    int rootA = getRoot(a);\n    int rootB = getRoot(b);\n    if (rootA == rootB) {\n      return;\n    }\n    if (ranks[rootA] < ranks[rootB]) {\n      parents[rootA] = rootB;\n    } else if (ranks[rootB] < ranks[rootA]) {\n      parents[rootB] = rootA;\n    } else {\n      parents[rootA] = rootB;\n      ranks[rootB]++;\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n \n \n \npublic class Main {\n\tpublic static long C(int n, int r)\n\t{\n\t\tif(n < 0 || r < 0 || r > n)return 0;\n\t\tif(r > n / 2)r = n - r;\n\t\treturn FACT[n]*IFACT[n-r]%mod*IFACT[r]%mod;\n\t}\n\t \n\tstatic long[] FACT, IFACT;\n\tstatic long inv(long v) {\n\t\treturn modPow(v, MOD - 2);\n\t}\n\t \n\t\t\n\tstatic int MOD = 1000000007;\n\tstatic int mod = MOD;\n\tpublic static void main(String[] args) {\n\t\tint n = 900000;\n\t\tFACT = new long[n+1];\n\t\tIFACT = new long[n+1];\n\t\tFACT[0] = 1;\n\t\tIFACT[0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tFACT[i] = FACT[i-1] * i % mod;\n\t\t\tIFACT[i] = inv(FACT[i]);\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintStream out = new PrintStream(System.out);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tlong ans = 0;\n\t\tlong hh = 0;\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tint retA = modPow(3,N + M + K - i);\n\t\t\t\n\t\t\tint retB = (int)C(i-1,N-1);\n\t\t\tlong  retC = 0;\n\t\t\tretC = (retC + modPow(2,i - N)) % MOD;\n\t\t\thh = hh * 2 % MOD;\n\t\t\tif (i - N > M) hh = (hh + C(M + i - N - M - 1, i - N - M - 1)) % MOD;\n\t\t\tif (i - N > K) hh = (hh + C(K + i - N - K - 1, i - N - K - 1)) % MOD;\n\t\t\tretC = (retC - hh) % MOD;\n\t\t\tlong ansA = ((long)(retA) * (long)(retB)) % MOD;\n\t\t\t\n\t\t\tansA *= retC % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static int modPow(long a, long b) {\n\t\tif(b == 0) return 1 % MOD;\n\t\tif(b == 1) return (int) (a % MOD);\n\t\t\n\t\tif(b % 2 == 0) {\n\t\t\tlong ret = modPow(a % MOD,b / 2) % MOD;\n\t\t\treturn (int)((ret * ret) % MOD);\n\t\t}\n\t\telse {\n\t\t\tlong ret = (a * (long)modPow(a % MOD,b-1)) % MOD;\n\t\t\treturn (int)(ret % MOD);\n\t\t}\n\t}\n\tpublic static int comb(long n, long k) {\n\t\tif(k == 0) return 1;\n\t\tlong AA = 1;\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tAA *= (long)n - i;\n\t\t\tAA %= MOD;\n\t\t}\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tAA *= inv(i);\n\t\t\tAA %= MOD;\n\t\t}\n\t\treturn (int)(AA % MOD);\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n \n \n \npublic class Main {\n\n\tstatic long inv(long v) {\n\t\treturn modPow(v, MOD - 2);\n\t}\n\t \n\t\t\n\tstatic int MOD = 1000000007;\n\tstatic int mod = MOD;\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintStream out = new PrintStream(System.out);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint n = N + M + K;\n\t\tlong ans = 0;\n\t\tlong hh = 0;\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tlong retA = modPow(3,N + M + K - i) % MOD;\n\t\t\t\n\t\t\tlong retB = comb(i-1,N-1) % MOD;\n\t\t\tlong  retC = 0;\n\t\t\tretC = (retC + modPow(2,i - N)) % MOD;\n\t\t\thh = hh * 2 % MOD;\n\t\t\tif (i - N > M) hh = (hh + comb(M + i - N - M - 1, i - N - M - 1) % MOD) % MOD;\n\t\t\tif (i - N > K) hh = (hh + comb(K + i - N - K - 1, i - N - K - 1) % MOD) % MOD;\n\t\t\tretC = (retC - hh) % MOD;\n\t\t\tlong ansA = ((long)(retA) * (long)(retB)) % MOD;\n\t\t\t\n\t\t\tansA *= retC % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static int modPow(long a, long b) {\n\t\tif(b == 0) return 1 % MOD;\n\t\tif(b == 1) return (int) (a % MOD);\n\t\t\n\t\tif(b % 2 == 0) {\n\t\t\tlong ret = modPow(a % MOD,b / 2) % MOD;\n\t\t\treturn (int)((ret * ret) % MOD);\n\t\t}\n\t\telse {\n\t\t\tlong ret = (a * (long)modPow(a % MOD,b-1)) % MOD;\n\t\t\treturn (int)(ret % MOD);\n\t\t}\n\t}\n\tpublic static int comb(long n, long k) {\n\t\tif(k == 0) return 1;\n\t\tlong AA = 1;\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tAA *= (long)n - i;\n\t\t\tAA %= MOD;\n\t\t}\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tAA *= inv(i);\n\t\t\tAA %= MOD;\n\t\t}\n\t\treturn (int)(AA % MOD);\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass LargeSolver {\n  final int n, m, k;\n  ModCalculator mc;\n  \n  LargeSolver (int n, int m, int k) {\n    this.n = n;\n    this.m = m;\n    this.k = k;\n  }\n  \n  public long solve() {\n    mc = new ModCalculator(1_000_000_007L);\n    long answer = 0;\n//      System.err.println();\n    for (int x = 0; x <= m + k; x++) {\n      // a [ax]* a\n      long v1 = mc.getC(n + x - 1, x);\n      long v2 = mc.pow(3, m + k - x);\n      long v3 = mc.pow(2, x);\n      long v = mc.mul(v1, mc.mul(v2, v3));\n//      System.err.printf(\"%d %d %d %d\\n\", v1, v2, v3, v);\n      answer = mc.add(answer, v);\n    }\n//    System.err.println(answer);\n//      System.err.println();\n      // b: m+1\n      // x: m+1 -> m+k\n    long vTemp = 0;\n    for (int y = 1; y <= k; y++) {\n      int x = y + m;\n      long v1 = mc.getC(n + x - 1, x);\n      long v2 = mc.pow(3, m + k - x);\n      vTemp = mc.mul(vTemp, 2);\n      vTemp = mc.add(vTemp, mc.getC(x - 1, m));\n      long v = mc.mul(v1, mc.mul(v2, vTemp));\n//      System.err.printf(\"%d %d %d %d\\n\", v1, v2, vTemp, v);\n      answer = mc.sub(answer, v);\n    }\n//      System.err.println();\n//    System.err.println(answer);\n    vTemp = 0;\n    for (int y = 1; y <= m; y++) {\n      int x = y + k;\n      long v1 = mc.getC(n + x - 1, x);\n      long v2 = mc.pow(3, m + k - x);\n      vTemp = mc.mul(vTemp, 2);\n      vTemp = mc.add(vTemp, mc.getC(x - 1, m));\n      long v = mc.mul(v1, mc.mul(v2, vTemp));\n//      System.err.printf(\"%d %d %d %d\\n\", v1, v2, vTemp, v);\n      answer = mc.sub(answer, v);\n    }\n//    System.err.println(answer);\n    return answer;\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, PrintWriter out) {\n    int n = reader.nextInt();\n    int m = reader.nextInt();\n    int k = reader.nextInt();\n    out.println(new LargeSolver(n, m, k).solve());\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestReader {\n  private BufferedReader reader;\n  private StringTokenizer tokenizer;\n  \n  ContestReader(InputStream in) {\n    reader = new BufferedReader(new InputStreamReader(in));\n  }\n  \n  public String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n  \n  public int nextInt() {\n    return Integer.parseInt(next());\n  }\n  \n  public long nextLong() {\n    return Long.parseLong(next());\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] nextArray(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public int[] nextIntArray(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLongArray(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDoubleArray(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public int[][] nextIntMatrix(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLongMatrix(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDoubleMatrix(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long add(long a, long b) {\n    return (a + b) % mod;\n  }\n  \n  public long sub(long a, long b) {\n    return (a - b + mod) % mod;\n  }\n  \n  public long mul(long a, long b) {\n    return (a * b) % mod;\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n  \n  class ModCombinationCache {\n    private final List<Long> factorialCache;\n    private final List<Long> factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new ArrayList<>();\n      factorialCache.add(1L);\n      factorialInverseCache = new ArrayList<>();\n      factorialInverseCache.add(1L);\n    }\n    \n    private void resize(int n) {\n      for (int i = factorialCache.size() - 1; i < n; i++) {\n        long v = mul(factorialCache.get(i), i + 1);\n        factorialCache.add(v);\n        factorialInverseCache.add(inverse(v));\n      }\n    }\n    \n    long getF(int n) {\n      resize(n);\n      return factorialCache.get(n);\n    }\n    \n    long getP(int n, int r) {\n      resize(n);\n      return mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n    }\n    \n    long getC(int n, int k) {\n      resize(n);\n      return mul(factorialCache.get(n), mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n    }\n  }\n}\n \nclass Algorithm {\n  private static void swap(Object[] list, int a, int b) {\n    Object tmp = list[a];\n    list[a] = list[b];\n    list[b] = tmp;\n  }\n  \n  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {\n    int rightMostAscendingOrderIndex = ts.length - 2;\n    while (rightMostAscendingOrderIndex >= 0 &&\n        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {\n      rightMostAscendingOrderIndex--;\n    }\n    if (rightMostAscendingOrderIndex < 0) {\n      return false;\n    }\n    \n    int rightMostGreatorIndex = ts.length - 1;\n    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {\n      rightMostGreatorIndex--;\n    }\n    \n    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);\n    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {\n      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);\n    }\n    return true;\n  }\n  \n  public static void shuffle(int[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      int temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void shuffle(long[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      long temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void sort(int[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n  \n  public static void sort(long[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n}\n\nclass UnionFind {\n  int[] parents;\n  int[] ranks;\n\n  UnionFind(int n) {\n    parents = new int[n];\n    ranks = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      parents[i] = i;\n    }\n  }\n\n  public int getRoot(int index) {\n    if (parents[index] == index) {\n      return index;\n    } else {\n      parents[index] = getRoot(parents[index]);\n      return parents[index];\n    }\n  }\n\n  public boolean sameGroup(int a, int b) {\n    return getRoot(a) == getRoot(b);\n  }\n\n  public void merge(int a, int b) {\n    int rootA = getRoot(a);\n    int rootB = getRoot(b);\n    if (rootA == rootB) {\n      return;\n    }\n    if (ranks[rootA] < ranks[rootB]) {\n      parents[rootA] = rootB;\n    } else if (ranks[rootB] < ranks[rootA]) {\n      parents[rootB] = rootA;\n    } else {\n      parents[rootA] = rootB;\n      ranks[rootB]++;\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            PrintWriter out = new PrintWriter(outputStream);\n            TaskD solver = new TaskD();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskD {\n        public void solve(int testNumber, FastInput in, PrintWriter out) {\n            NumberTheory.Modular mod = new NumberTheory.Modular((int) 1e9 + 7);\n            NumberTheory.Power power = new NumberTheory.Power(mod);\n            NumberTheory.Composite comp = new NumberTheory.Composite(1000000, mod);\n\n            int n = in.readInt();\n            int m = in.readInt();\n            int k = in.readInt();\n\n            int ans = 0;\n\n            int t = m + k;\n            int[] preSumOfM = new int[t + 1];\n            int[] preSumOfK = new int[t + 1];\n            preSumOfM[0] = 1;\n            preSumOfK[0] = 1;\n            for (int i = 1; i <= t; i++) {\n                preSumOfM[i] = mod.subtract(mod.mul(2, preSumOfM[i - 1]), comp.composite(i - 1, m));\n                preSumOfK[i] = mod.subtract(mod.mul(2, preSumOfK[i - 1]), comp.composite(i - 1, k));\n            }\n\n            for (int i = 0; i <= m + k; i++) {\n                int total = power.pow(2, i);\n                int b = mod.subtract(total, preSumOfM[i]);\n                int c = mod.subtract(total, preSumOfK[i]);\n                int cnt = mod.subtract(total, b);\n                cnt = mod.subtract(cnt, c);\n                cnt = mod.mul(cnt, comp.composite(n - 1 + i, i));\n                cnt = mod.mul(cnt, power.pow(3, m + k - i));\n                ans = mod.plus(ans, cnt);\n            }\n\n            out.println(ans);\n        }\n\n    }\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n        }\n\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, NumberTheory.Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n\n        }\n\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n\n            public Factorial(int[] fact, int[] inv, NumberTheory.InverseNumber in, int limit,\n                            NumberTheory.Modular modular) {\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new NumberTheory.InverseNumber(limit, modular), limit,\n                                modular);\n            }\n\n        }\n\n        public static class Composite {\n            final NumberTheory.Factorial factorial;\n            final NumberTheory.Modular modular;\n\n            public Composite(NumberTheory.Factorial factorial, NumberTheory.Modular modular) {\n                this.factorial = factorial;\n                this.modular = modular;\n            }\n\n            public Composite(int limit, NumberTheory.Modular modular) {\n                this(new NumberTheory.Factorial(limit, modular), modular);\n            }\n\n            public int composite(int m, int n) {\n                if (n > m) {\n                    return 0;\n                }\n                return modular.mul(modular.mul(factorial.fact[m], factorial.inv[n]), factorial.inv[m - n]);\n            }\n\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 1000000007;\n\t\tint n = ni(), m = ni(), K = ni();\n\t\tint[][] fif = enumFIF(1000000, mod);\n\t\tlong[] cx = enumCombSums(m, K, fif, mod);\n\t\t\n\t\tlong ret = 0;\n\t\tfor(int t = n;t <= n+m+K;t++){\n\t\t\tret = ret * 3;\n\t\t\tret += C(t-1, n-1, mod, fif) * cx[t-n];\n\t\t\tret %= mod;\n\t\t}\n\t\tif(ret < 0)ret += mod;\n\t\tout.println(ret);\n\t}\n\t\n\tstatic long[] enumCombSums(int n, int m, int[][] fif, int mod)\n\t{\n\t\tlong[] ret = new long[n+m+1];\n\t\tret[0] = 1%mod;\n\t\tfor(int i = 1;i <= n+m;i++){\n\t\t\tret[i] = ret[i-1] * 2;\n\t\t\tif(i > m){\n\t\t\t\tret[i] -= C(i-1, m, mod, fif);\n\t\t\t}\n\t\t\tif(i > n){\n\t\t\t\tret[i] -= C(i-1, n, mod, fif);\n\t\t\t}\n\t\t\tret[i] %= mod;\n\t\t\tif(ret[i] < 0)ret[i] += mod;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass SmallSolver {\n  final int n, m, k;\n  ModCalculator mc;\n  \n  SmallSolver (int n, int m, int k) {\n    this.n = n;\n    this.m = m;\n    this.k = k;\n  }\n  \n  public long solve() {\n    mc = new ModCalculator(1_000_000_007L);\n    long answer = 0;\n    for (int b = 0; b <= m; b++) {\n      for (int c = 0; c <= k; c++) {\n        // a [abc]* a\n        long v1 = mc.getC(n + b + c - 1, b);\n        long v2 = mc.getC(n + c - 1, c);\n        long v3 = mc.pow(3, (m - b) + (k - c));\n        long v = mc.mul(v1, mc.mul(v2, v3));\n//        System.out.printf(\"%d %d %d %d\\n\", v1, v2, v3, v);\n        answer = mc.add(answer, v);\n      }\n    }\n    return answer;\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, PrintWriter out) {\n    int n = reader.nextInt();\n    int m = reader.nextInt();\n    int k = reader.nextInt();\n    out.println(new SmallSolver(n, m, k).solve());\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestReader {\n  private BufferedReader reader;\n  private StringTokenizer tokenizer;\n  \n  ContestReader(InputStream in) {\n    reader = new BufferedReader(new InputStreamReader(in));\n  }\n  \n  public String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n  \n  public int nextInt() {\n    return Integer.parseInt(next());\n  }\n  \n  public long nextLong() {\n    return Long.parseLong(next());\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] nextArray(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public int[] nextIntArray(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLongArray(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDoubleArray(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public int[][] nextIntMatrix(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLongMatrix(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDoubleMatrix(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long add(long a, long b) {\n    return (a + b) % mod;\n  }\n  \n  public long sub(long a, long b) {\n    return (a - b + mod) % mod;\n  }\n  \n  public long mul(long a, long b) {\n    return (a * b) % mod;\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n  \n  class ModCombinationCache {\n    private final List<Long> factorialCache;\n    private final List<Long> factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new ArrayList<>();\n      factorialCache.add(1L);\n      factorialInverseCache = new ArrayList<>();\n      factorialInverseCache.add(1L);\n    }\n    \n    private void resize(int n) {\n      for (int i = factorialCache.size() - 1; i < n; i++) {\n        long v = mul(factorialCache.get(i), i + 1);\n        factorialCache.add(v);\n        factorialInverseCache.add(inverse(v));\n      }\n    }\n    \n    long getF(int n) {\n      resize(n);\n      return factorialCache.get(n);\n    }\n    \n    long getP(int n, int r) {\n      resize(n);\n      return mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n    }\n    \n    long getC(int n, int k) {\n      resize(n);\n      return mul(factorialCache.get(n), mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n    }\n  }\n}\n \nclass Algorithm {\n  private static void swap(Object[] list, int a, int b) {\n    Object tmp = list[a];\n    list[a] = list[b];\n    list[b] = tmp;\n  }\n  \n  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {\n    int rightMostAscendingOrderIndex = ts.length - 2;\n    while (rightMostAscendingOrderIndex >= 0 &&\n        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {\n      rightMostAscendingOrderIndex--;\n    }\n    if (rightMostAscendingOrderIndex < 0) {\n      return false;\n    }\n    \n    int rightMostGreatorIndex = ts.length - 1;\n    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {\n      rightMostGreatorIndex--;\n    }\n    \n    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);\n    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {\n      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);\n    }\n    return true;\n  }\n  \n  public static void shuffle(int[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      int temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void shuffle(long[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      long temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void sort(int[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n  \n  public static void sort(long[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n}\n\nclass UnionFind {\n  int[] parents;\n  int[] ranks;\n\n  UnionFind(int n) {\n    parents = new int[n];\n    ranks = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      parents[i] = i;\n    }\n  }\n\n  public int getRoot(int index) {\n    if (parents[index] == index) {\n      return index;\n    } else {\n      parents[index] = getRoot(parents[index]);\n      return parents[index];\n    }\n  }\n\n  public boolean sameGroup(int a, int b) {\n    return getRoot(a) == getRoot(b);\n  }\n\n  public void merge(int a, int b) {\n    int rootA = getRoot(a);\n    int rootB = getRoot(b);\n    if (rootA == rootB) {\n      return;\n    }\n    if (ranks[rootA] < ranks[rootB]) {\n      parents[rootA] = rootB;\n    } else if (ranks[rootB] < ranks[rootA]) {\n      parents[rootB] = rootA;\n    } else {\n      parents[rootA] = rootB;\n      ranks[rootB]++;\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main\n{\n\tprivate void solve()throws IOException\n\t{\n\t\tfact();\n\t\tint n=nextInt();\n\t\tint m=nextInt();\n\t\tint k=nextInt();\n\t\tlong ans=0;\n\t\tfor(int i=0;i<=m;i++)\n\t\t\tfor(int j=0;j<=k;j++)\n\t\t\t{\n\t\t\t\tlong curr=fact[n-1+i+j];\n\t\t\t\tlong den=(fact[n-1]*((fact[i]*fact[j])%mod))%mod;\n\t\t\t\tcurr=(curr*modinv(den))%mod;\n\t\t\t\tcurr=(curr*modpow(3,m+k-i-j))%mod;\n\t\t\t\tans=(ans+curr)%mod;\n\t\t\t}\n\t\tout.println(ans);\n\t}\n\tint maxn=(int)(1e6);\n\tlong fact[];\n\tvoid fact(){\n\t\tfact=new long[maxn+1];\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=maxn;i++)\n\t\t\tfact[i]=(fact[i-1]*i)%mod;\n\t}\n\tfinal long mod=(long)(1e9+7);\n\tlong modinv(long x){\n\t    return modpow(x,mod-2);\n\t}\n\tlong modpow(long a,long b){\n\t    long ret=1;\n\t    while(b!=0)\n\t    {\n\t        if(b%2==1)\n\t            ret=(ret*a)%mod;\n\t        a=(a*a)%mod;\n\t        b=b/2;\n\t    }\n\t    return ret;\n\t} \n\n\t \n\t///////////////////////////////////////////////////////////\n\n\tpublic void run()throws IOException\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\tst=null;\n\t\tout=new PrintWriter(System.out);\n\n\t\tsolve();\n\t\t\n\t\tbr.close();\n\t\tout.close();\n\t}\n\tpublic static void main(String args[])throws IOException{\n\t\tnew Main().run();\n\t}\n\tBufferedReader br;\n\tStringTokenizer st;\n\tPrintWriter out;\n\tString nextToken()throws IOException{\n\t\twhile(st==null || !st.hasMoreTokens())\n\t\tst=new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\tString nextLine()throws IOException{\n\t\treturn br.readLine();\n\t}\n\tint nextInt()throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tlong nextLong()throws IOException{\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tdouble nextDouble()throws IOException{\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n \n \n \npublic class Main {\n\tpublic static long C(int n, int r)\n\t{\n\t\tif(n < 0 || r < 0 || r > n)return 0;\n\t\tif(r > n / 2)r = n - r;\n\t\treturn FACT[n]*IFACT[n-r]%mod*IFACT[r]%mod;\n\t}\n\tlong extGcd()\n\t \n\tstatic long[] FACT, IFACT;\n\tstatic long  get_gcd(long  n, long  m) {\n\t\t  if (n < m) {\n\t\t\t  long tmp = n;\n\t\t\t  n = m;\n\t\t\t  m = tmp;\n\t\t  }\n\t\t  while (m != 0) {\n\t\t\t  long tmp = n;\n\t\t\t  n = m;\n\t\t\t  m = tmp;\n\t\t    m %= n;\n\t\t  }\n\t\t  return n;\n\t\t}\n\n\tpublic static long  modinv(long  x, long  m) {\n\t    long  s, t;\n\t    s = get_gcd(x, m);\n\t    \n\t    return (m+s) % m;\n\t}\n\t \n\t\t\n\tstatic int MOD = 1000000007;\n\tstatic int mod = MOD;\n\tpublic static void main(String[] args) {\n\t\tint n = 900000;\n\t\tFACT = new long[n+1];\n\t\tIFACT = new long[n+1];\n\t\tFACT[0] = 1;\n\t\tIFACT[0] = 1;\n\t\t\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tFACT[i] = FACT[i-1] * i % mod;\n\t\t\tIFACT[i] = new BigInteger(String.valueOf(FACT[i])).modInverse(new BigInteger(String.valueOf(mod))).longValue();\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintStream out = new PrintStream(System.out);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tlong ans = 0;\n\t\t\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tint retA = modPow(3,N + M + K - i);\n\t\t\t\n\t\t\tint retB = (int)C(i-1,N-1);\n\t\t\tint kMax = Math.max(0, i - N-K);\n\t\t\tint kMin = Math.min(i - N, M);\n\t\t\tlong sum = 0;\n\t\t\tfor(int k = kMax; k <= kMin; k++) {\n\t\t\t\tsum += (int)C(i - N, k) % MOD;\n\t\t\t\tsum %= MOD;\n\t\t\t}\n\t\t\tlong ansA = ((long)(retA) * (long)(retB)) % MOD;\n\t\t\tansA *= sum % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static int modPow(int a, int b) {\n\t\tif(b == 0) return 1 % MOD;\n\t\tif(b == 1) return a % MOD;\n\t\t\n\t\tif(b % 2 == 0) {\n\t\t\tlong ret = modPow(a % MOD,b / 2) % MOD;\n\t\t\treturn (int)((ret * ret) % MOD);\n\t\t}\n\t\telse {\n\t\t\tlong ret = (a * (long)modPow(a % MOD,b-1)) % MOD;\n\t\t\treturn (int)(ret % MOD);\n\t\t}\n\t}\n\tpublic static int comb(int n, int k) {\n\t\tif(k == 0) return 1;\n\t\tlong AA = 1;\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tAA *= (long)n - i;\n\t\t\tAA %= MOD;\n\t\t}\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tAA *= new BigInteger(String.valueOf(i)).modInverse(new BigInteger(String.valueOf(MOD))).longValue();\n\t\t\tAA %= MOD;\n\t\t}\n\t\treturn (int)(AA % MOD);\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n \n \n \npublic class Main {\n\tpublic static long C(int n, int r)\n\t{\n\t\tif(n < 0 || r < 0 || r > n)return 0;\n\t\tif(r > n / 2)r = n - r;\n\t\treturn FACT[n]*IFACT[n-r]%mod*IFACT[r]%mod;\n\t}\n\t \n\tstatic long[] FACT, IFACT;\n\n\t \n\t\t\n\tstatic int MOD = 1000000007;\n\tstatic int mod = MOD;\n\tpublic static void main(String[] args) {\n\t\tint n = 900000;\n\t\tFACT = new long[n+1];\n\t\tIFACT = new long[n+1];\n\t\tFACT[0] = 1;\n\t\tIFACT[0] = 1;\n\t\tBigInteger MODBI = new BigInteger(String.valueOf(mod));\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tFACT[i] = FACT[i-1] * i % mod;\n\t\t\tIFACT[i] = new BigInteger(String.valueOf(FACT[i])).modInverse(MODBI).longValue();\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintStream out = new PrintStream(System.out);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tlong ans = 0;\n\t\t\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tint retA = modPow(3,N + M + K - i);\n\t\t\t\n\t\t\tint retB = (int)C(i-1,N-1);\n\t\t\tint kMax = Math.max(0, i - N-K);\n\t\t\tint kMin = Math.min(i - N, M);\n\t\t\tlong sum = 0;\n\t\t\tfor(int k = kMax; k <= kMin; k++) {\n\t\t\t\tsum += (int)C(i - N, k) % MOD;\n\t\t\t\tsum %= MOD;\n\t\t\t}\n\t\t\tlong ansA = ((long)(retA) * (long)(retB)) % MOD;\n\t\t\tansA *= sum % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static int modPow(int a, int b) {\n\t\tif(b == 0) return 1 % MOD;\n\t\tif(b == 1) return a % MOD;\n\t\t\n\t\tif(b % 2 == 0) {\n\t\t\tlong ret = modPow(a % MOD,b / 2) % MOD;\n\t\t\treturn (int)((ret * ret) % MOD);\n\t\t}\n\t\telse {\n\t\t\tlong ret = (a * (long)modPow(a % MOD,b-1)) % MOD;\n\t\t\treturn (int)(ret % MOD);\n\t\t}\n\t}\n\tpublic static int comb(int n, int k) {\n\t\tif(k == 0) return 1;\n\t\tlong AA = 1;\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tAA *= (long)n - i;\n\t\t\tAA %= MOD;\n\t\t}\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tAA *= new BigInteger(String.valueOf(i)).modInverse(new BigInteger(String.valueOf(MOD))).longValue();\n\t\t\tAA %= MOD;\n\t\t}\n\t\treturn (int)(AA % MOD);\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni(), K = ni();\n\t\t// (t-1)!/(n-1)!b!c!*3^(n+m+K-t)\n\t\t// b<=m, c<=K\n\t\tint mod = 1000000007;\n\t\tint[][] fif = enumFIF(1000000, mod);\n\t\tlong[] ib = new long[m+1];\n\t\tfor(int i = 0;i <= m;i++)ib[i] = fif[1][i];\n\t\tlong[] ic = new long[K+1];\n\t\tfor(int i = 0;i <= K;i++)ic[i] = fif[1][i];\n\t\tlong[] is = convolute(ib, ic, 3, mod);\n\t\tlong ret = 0;\n\t\tfor(int t = n;t <= n+m+K;t++){\n\t\t\tret += (long)fif[0][t-1]*fif[1][n-1]%mod\n\t\t\t\t\t*is[t-n]%mod\n\t\t\t\t\t*pow(3, n+m+K-t, mod)%mod;\n\t\t}\n\t\tout.println(ret%mod);\n\t}\n\t\n\tpublic static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};\n\tpublic static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};\n//\tpublic static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};\n//\tpublic static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};\n\t\n\tpublic static long[] convoluteSimply(long[] a, long[] b, int P, int g)\n\t{\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t}\n\t\treturn nttmb(fa, m, true, P, g);\n\t}\n\t\n\tpublic static long[] convolute(long[] a, long[] b)\n\t{\n\t\tint USE = 2;\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[][] fs = new long[USE][];\n\t\tfor(int k = 0;k < USE;k++){\n\t\t\tint P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n\t\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t\t}\n\t\t\tfs[k] = nttmb(fa, m, true, P, g);\n\t\t}\n\t\t\n\t\tint[] mods = Arrays.copyOf(NTTPrimes, USE);\n\t\tlong[] gammas = garnerPrepare(mods);\n\t\tint[] buf = new int[USE];\n\t\tfor(int i = 0;i < fs[0].length;i++){\n\t\t\tfor(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n\t\t\tlong[] res = garnerBatch(buf, mods, gammas);\n\t\t\tlong ret = 0;\n\t\t\tfor(int j = res.length-1;j >= 0;j--)ret = ret * mods[j] + res[j];\n\t\t\tfs[0][i] = ret;\n\t\t}\n\t\treturn fs[0];\n\t}\n\t\n\tpublic static long[] convolute(long[] a, long[] b, int USE, int mod)\n\t{\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[][] fs = new long[USE][];\n\t\tfor(int k = 0;k < USE;k++){\n\t\t\tint P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n\t\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t\t}\n\t\t\tfs[k] = nttmb(fa, m, true, P, g);\n\t\t}\n\t\t\n\t\tint[] mods = Arrays.copyOf(NTTPrimes, USE);\n\t\tlong[] gammas = garnerPrepare(mods);\n\t\tint[] buf = new int[USE];\n\t\tfor(int i = 0;i < fs[0].length;i++){\n\t\t\tfor(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n\t\t\tlong[] res = garnerBatch(buf, mods, gammas);\n\t\t\tlong ret = 0;\n\t\t\tfor(int j = res.length-1;j >= 0;j--)ret = (ret * mods[j] + res[j]) % mod;\n\t\t\tfs[0][i] = ret;\n\t\t}\n\t\treturn fs[0];\n\t}\n\t\n\t// static int[] wws = new int[270000]; // outer faster\n\t\n\t// Modifed Montgomery + Barrett\n\tprivate static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)\n\t{\n\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\n\t\tint h = Integer.numberOfTrailingZeros(n);\n\t\tlong K = Integer.highestOneBit(P)<<1;\n\t\tint H = Long.numberOfTrailingZeros(K)*2;\n\t\tlong M = K*K/P;\n\t\t\n\t\tint[] wws = new int[1<<h-1];\n\t\tlong dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n\t\tlong w = (1L<<32)%P;\n\t\tfor(int k = 0;k < 1<<h-1;k++){\n\t\t\twws[k] = (int)w;\n\t\t\tw = modh(w*dw, M, H, P);\n\t\t}\n\t\tlong J = invl(P, 1L<<32);\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < 1<<i;j++){\n\t\t\t\tfor(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n\t\t\t\t\tlong u = (dst[s] - dst[t] + 2*P)*wws[k];\n\t\t\t\t\tdst[s] += dst[t];\n\t\t\t\t\tif(dst[s] >= 2*P)dst[s] -= 2*P;\n//\t\t\t\t\tlong Q = (u&(1L<<32)-1)*J&(1L<<32)-1;\n\t\t\t\t\tlong Q = (u<<32)*J>>>32;\n\t\t\t\t\tdst[t] = (u>>>32)-(Q*P>>>32)+P;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i < h-1){\n\t\t\t\tfor(int k = 0;k < 1<<h-i-2;k++)wws[k] = wws[k*2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(dst[i] >= P)dst[i] -= P;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint rev = Integer.reverse(i)>>>-h;\n\t\t\tif(i < rev){\n\t\t\t\tlong d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(inverse){\n\t\t\tlong in = invl(n, P);\n\t\t\tfor(int i = 0;i < n;i++)dst[i] = modh(dst[i]*in, M, H, P);\n\t\t}\n\t\t\n\t\treturn dst;\n\t}\n\t\n\t// Modified Shoup + Barrett\n\tprivate static long[] nttsb(long[] src, int n, boolean inverse, int P, int g)\n\t{\n\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\n\t\tint h = Integer.numberOfTrailingZeros(n);\n\t\tlong K = Integer.highestOneBit(P)<<1;\n\t\tint H = Long.numberOfTrailingZeros(K)*2;\n\t\tlong M = K*K/P;\n\t\t\n\t\tlong dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n\t\tlong[] wws = new long[1<<h-1];\n\t\tlong[] ws = new long[1<<h-1];\n\t\tlong w = 1;\n\t\tfor(int k = 0;k < 1<<h-1;k++){\n\t\t\twws[k] = (w<<32)/P;\n\t\t\tws[k] = w;\n\t\t\tw = modh(w*dw, M, H, P);\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < 1<<i;j++){\n\t\t\t\tfor(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n\t\t\t\t\tlong ndsts = dst[s] + dst[t];\n\t\t\t\t\tif(ndsts >= 2*P)ndsts -= 2*P;\n\t\t\t\t\tlong T = dst[s] - dst[t] + 2*P;\n\t\t\t\t\tlong Q = wws[k]*T>>>32;\n\t\t\t\t\tdst[s] = ndsts;\n\t\t\t\t\tdst[t] = ws[k]*T-Q*P&(1L<<32)-1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdw = dw * dw % P;\n\t\t\tif(i < h-1){\n\t\t\t\tfor(int k = 0;k < 1<<h-i-2;k++){\n\t\t\t\t\twws[k] = wws[k*2];\n\t\t\t\t\tws[k] = ws[k*2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(dst[i] >= P)dst[i] -= P;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint rev = Integer.reverse(i)>>>-h;\n\t\t\tif(i < rev){\n\t\t\t\tlong d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(inverse){\n\t\t\tlong in = invl(n, P);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tdst[i] = modh(dst[i] * in, M, H, P);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dst;\n\t}\n\t\n\tstatic final long mask = (1L<<31)-1;\n\t\n\tpublic static long modh(long a, long M, int h, int mod)\n\t{\n\t\tlong r = a-((M*(a&mask)>>>31)+M*(a>>>31)>>>h-31)*mod;\n\t\treturn r < mod ? r : r-mod;\n\t}\n\t\n\tprivate static long[] garnerPrepare(int[] m)\n\t{\n\t\tint n = m.length;\n\t\tassert n == m.length;\n\t\tif(n == 0)return new long[0];\n\t\tlong[] gamma = new long[n];\n\t\tfor(int k = 1;k < n;k++){\n\t\t\tlong prod = 1;\n\t\t\tfor(int i = 0;i < k;i++){\n\t\t\t\tprod = prod * m[i] % m[k];\n\t\t\t}\n\t\t\tgamma[k] = invl(prod, m[k]);\n\t\t}\n\t\treturn gamma;\n\t}\n\t\n\tprivate static long[] garnerBatch(int[] u, int[] m, long[] gamma)\n\t{\n\t\tint n = u.length;\n\t\tassert n == m.length;\n\t\tlong[] v = new long[n];\n\t\tv[0] = u[0];\n\t\tfor(int k = 1;k < n;k++){\n\t\t\tlong temp = v[k-1];\n\t\t\tfor(int j = k-2;j >= 0;j--){\n\t\t\t\ttemp = (temp * m[j] + v[j]) % m[k];\n\t\t\t}\n\t\t\tv[k] = (u[k] - temp) * gamma[k] % m[k];\n\t\t\tif(v[k] < 0)v[k] += m[k];\n\t\t}\n\t\treturn v;\n\t}\n\t\n\tprivate static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tprivate static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n \n \n \npublic class Main {\n\tpublic static long C(int n, int r)\n\t{\n\t\tif(n < 0 || r < 0 || r > n)return 0;\n\t\tif(r > n / 2)r = n - r;\n\t\treturn FACT[n]*IFACT[n-r]%mod*IFACT[r]%mod;\n\t}\n\t \n\tstatic long[] FACT, IFACT;\n\tstatic long inv(long v) {\n\t\treturn modPow(v, MOD - 2);\n\t}\n\t \n\t\t\n\tstatic int MOD = 1000000007;\n\tstatic int mod = MOD;\n\tpublic static void main(String[] args) {\n\t\tint n = 900000;\n\t\tFACT = new long[n+1];\n\t\tIFACT = new long[n+1];\n\t\tFACT[0] = 1;\n\t\tIFACT[0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tFACT[i] = FACT[i-1] * i % mod;\n\t\t\tIFACT[i] = inv(FACT[i]);\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintStream out = new PrintStream(System.out);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tlong ans = 0;\n\t\t\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tint retA = modPow(3,N + M + K - i);\n\t\t\t\n\t\t\tint retB = (int)C(i-1,N-1);\n\t\t\tint kMax = Math.max(0, i - N-K);\n\t\t\tint kMin = Math.min(i - N, M);\n\t\t\tlong sum = 0;\n\t\t\tfor(int k = kMax; k <= kMin; k++) {\n\t\t\t\tsum += (int)C(i - N, k) % MOD;\n\t\t\t\tsum %= MOD;\n\t\t\t}\n\t\t\tlong ansA = ((long)(retA) * (long)(retB)) % MOD;\n\t\t\tansA *= sum % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static int modPow(long a, long b) {\n\t\tif(b == 0) return 1 % MOD;\n\t\tif(b == 1) return (int) (a % MOD);\n\t\t\n\t\tif(b % 2 == 0) {\n\t\t\tlong ret = modPow(a % MOD,b / 2) % MOD;\n\t\t\treturn (int)((ret * ret) % MOD);\n\t\t}\n\t\telse {\n\t\t\tlong ret = (a * (long)modPow(a % MOD,b-1)) % MOD;\n\t\t\treturn (int)(ret % MOD);\n\t\t}\n\t}\n\tpublic static int comb(long n, long k) {\n\t\tif(k == 0) return 1;\n\t\tlong AA = 1;\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tAA *= (long)n - i;\n\t\t\tAA %= MOD;\n\t\t}\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tAA *= inv(i);\n\t\t\tAA %= MOD;\n\t\t}\n\t\treturn (int)(AA % MOD);\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 1000000007;\n\t\tint n = ni(), m = ni(), K = ni();\n\t\tint[][] fif = enumFIF(1000000, mod);\n\t\t\n\t\tlong ret = 0;\n\t\tlong cx = 1;\n\t\tfor(int t = n;t <= n+m+K;t++){\n\t\t\tret = ret * 3;\n\t\t\tret += C(t-1, n-1, mod, fif) * cx;\n\t\t\tret %= mod;\n\t\t\t\n\t\t\tcx = cx * 2;\n\t\t\tif(cx >= mod)cx -= mod;\n\t\t\tif(t-n+1 > K){\n\t\t\t\tcx -= C(t-n, K, mod, fif);\n\t\t\t\tif(cx < 0)cx += mod;\n\t\t\t}\n\t\t\tif(t-n+1 > m){\n\t\t\t\tcx -= C(t-n, m, mod, fif);\n\t\t\t\tif(cx < 0)cx += mod;\n\t\t\t}\n\t\t}\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.arc.arc061;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n/**\n * Created by hama_du on 2016/09/11.\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int z = in.nextInt();\n        int B = Math.min(y, z);\n        int C = Math.max(y, z);\n        prec(1000000);\n\n        long[] pow3 = new long[1000000];\n        pow3[0] = 1;\n        for (int i = 1 ; i < pow3.length; i++) {\n            pow3[i] = pow3[i-1] * 3 % MOD;\n        }\n        \n        long[] ans = new long[x+y+z+2];\n        long last = 0;\n        for (int l = x+1 ; l <= x+y+z+1 ; l++) {\n            int space = l-2;\n            long base = comb(space, x-1);\n            int row = space-(x-1);\n            if (row == 0) {\n                last = 1;\n            } else if (row <= B) {\n                last = (last * 2) % MOD;\n            } else if (row <= C) {\n                last = (last * 2 - comb(row-1, B) + MOD) % MOD;\n            } else {\n                int d = (row-1)-C;\n                last = (last * 2 - comb(row-1, B) - comb(row-1, d) + MOD + MOD) % MOD;\n            }\n            ans[l] = base * last % MOD * pow3[x+y+z+1-l] % MOD;\n        }\n\n        long sum = 0;\n        for (int i = 0; i < ans.length ; i++) {\n            sum += ans[i];\n        }\n        out.println(sum % MOD);\n        out.flush();\n    }\n\n    static final int MOD = 1000000007;\n\n    static long pow(long a, long x) {\n        long res = 1;\n        while (x > 0) {\n            if (x % 2 != 0) {\n            res = (res * a) % MOD;\n            }\n            a = (a * a) % MOD;\n            x /= 2;\n        }\n        return res;\n    }\n\n    static long inv(long a) {\n        return pow(a, MOD - 2) % MOD;\n    }\n\n    static long[] _fact;\n    static long[] _invfact;\n    static long comb(long ln, long lr) {\n        int n = (int)ln;\n        int r = (int)lr;\n        if (n < 0 || r < 0 || r > n) {\n            return 0;\n        }\n        if (r > n / 2) {\n            r = n - r;\n        }\n        return (((_fact[n] * _invfact[n - r]) % MOD) * _invfact[r]) % MOD;\n    }\n\n    static void prec(int n) {\n        _fact = new long[n + 1];\n        _invfact = new long[n + 1];\n        _fact[0] = 1;\n        _invfact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            _fact[i] = _fact[i - 1] * i % MOD;\n            _invfact[i] = inv(_fact[i]);\n        }\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class D3 {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni(), K = ni();\n\t\t// (t-1)!/(n-1)!b!c!*3^(n+m+K-t)\n\t\t// b<=m, c<=K\n\t\tint mod = 1000000007;\n\t\tint[][] fif = enumFIF(400000, mod);\n\t\tlong[] ib = new long[m+1];\n\t\tfor(int i = 0;i <= m;i++)ib[i] = fif[1][i];\n\t\tlong[] ic = new long[K+1];\n\t\tfor(int i = 0;i <= K;i++)ic[i] = fif[1][i];\n\t\tlong[] is = convolute(ib, ic, 3, mod);\n\t\tlong ret = 0;\n\t\tfor(int t = n;t <= n+m+K;t++){\n\t\t\tret = ret * 3 + (long)fif[0][t-1]*is[t-n];\n\t\t\tret %= mod;\n\t\t}\n\t\tret = ret * fif[1][n-1] % mod;\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};\n\tpublic static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};\n//\tpublic static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};\n//\tpublic static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};\n\t\n\tpublic static long[] convoluteSimply(long[] a, long[] b, int P, int g)\n\t{\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t}\n\t\treturn nttmb(fa, m, true, P, g);\n\t}\n\t\n\tpublic static long[] convolute(long[] a, long[] b)\n\t{\n\t\tint USE = 2;\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[][] fs = new long[USE][];\n\t\tfor(int k = 0;k < USE;k++){\n\t\t\tint P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n\t\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t\t}\n\t\t\tfs[k] = nttmb(fa, m, true, P, g);\n\t\t}\n\t\t\n\t\tint[] mods = Arrays.copyOf(NTTPrimes, USE);\n\t\tlong[] gammas = garnerPrepare(mods);\n\t\tint[] buf = new int[USE];\n\t\tfor(int i = 0;i < fs[0].length;i++){\n\t\t\tfor(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n\t\t\tlong[] res = garnerBatch(buf, mods, gammas);\n\t\t\tlong ret = 0;\n\t\t\tfor(int j = res.length-1;j >= 0;j--)ret = ret * mods[j] + res[j];\n\t\t\tfs[0][i] = ret;\n\t\t}\n\t\treturn fs[0];\n\t}\n\t\n\tpublic static long[] convolute(long[] a, long[] b, int USE, int mod)\n\t{\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[][] fs = new long[USE][];\n\t\tfor(int k = 0;k < USE;k++){\n\t\t\tint P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n\t\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t\t}\n\t\t\tfs[k] = nttmb(fa, m, true, P, g);\n\t\t}\n\t\t\n\t\tint[] mods = Arrays.copyOf(NTTPrimes, USE);\n\t\tlong[] gammas = garnerPrepare(mods);\n\t\tint[] buf = new int[USE];\n\t\tfor(int i = 0;i < fs[0].length;i++){\n\t\t\tfor(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n\t\t\tlong[] res = garnerBatch(buf, mods, gammas);\n\t\t\tlong ret = 0;\n\t\t\tfor(int j = res.length-1;j >= 0;j--)ret = (ret * mods[j] + res[j]) % mod;\n\t\t\tfs[0][i] = ret;\n\t\t}\n\t\treturn fs[0];\n\t}\n\t\n\t// static int[] wws = new int[270000]; // outer faster\n\t\n\t// Modifed Montgomery + Barrett\n\tprivate static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)\n\t{\n\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\n\t\tint h = Integer.numberOfTrailingZeros(n);\n\t\tlong K = Integer.highestOneBit(P)<<1;\n\t\tint H = Long.numberOfTrailingZeros(K)*2;\n\t\tlong M = K*K/P;\n\t\t\n\t\tint[] wws = new int[1<<h-1];\n\t\tlong dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n\t\tlong w = (1L<<32)%P;\n\t\tfor(int k = 0;k < 1<<h-1;k++){\n\t\t\twws[k] = (int)w;\n\t\t\tw = modh(w*dw, M, H, P);\n\t\t}\n\t\tlong J = invl(P, 1L<<32);\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < 1<<i;j++){\n\t\t\t\tfor(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n\t\t\t\t\tlong u = (dst[s] - dst[t] + 2*P)*wws[k];\n\t\t\t\t\tdst[s] += dst[t];\n\t\t\t\t\tif(dst[s] >= 2*P)dst[s] -= 2*P;\n//\t\t\t\t\tlong Q = (u&(1L<<32)-1)*J&(1L<<32)-1;\n\t\t\t\t\tlong Q = (u<<32)*J>>>32;\n\t\t\t\t\tdst[t] = (u>>>32)-(Q*P>>>32)+P;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i < h-1){\n\t\t\t\tfor(int k = 0;k < 1<<h-i-2;k++)wws[k] = wws[k*2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(dst[i] >= P)dst[i] -= P;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint rev = Integer.reverse(i)>>>-h;\n\t\t\tif(i < rev){\n\t\t\t\tlong d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(inverse){\n\t\t\tlong in = invl(n, P);\n\t\t\tfor(int i = 0;i < n;i++)dst[i] = modh(dst[i]*in, M, H, P);\n\t\t}\n\t\t\n\t\treturn dst;\n\t}\n\t\n\t// Modified Shoup + Barrett\n\tprivate static long[] nttsb(long[] src, int n, boolean inverse, int P, int g)\n\t{\n\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\n\t\tint h = Integer.numberOfTrailingZeros(n);\n\t\tlong K = Integer.highestOneBit(P)<<1;\n\t\tint H = Long.numberOfTrailingZeros(K)*2;\n\t\tlong M = K*K/P;\n\t\t\n\t\tlong dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n\t\tlong[] wws = new long[1<<h-1];\n\t\tlong[] ws = new long[1<<h-1];\n\t\tlong w = 1;\n\t\tfor(int k = 0;k < 1<<h-1;k++){\n\t\t\twws[k] = (w<<32)/P;\n\t\t\tws[k] = w;\n\t\t\tw = modh(w*dw, M, H, P);\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < 1<<i;j++){\n\t\t\t\tfor(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n\t\t\t\t\tlong ndsts = dst[s] + dst[t];\n\t\t\t\t\tif(ndsts >= 2*P)ndsts -= 2*P;\n\t\t\t\t\tlong T = dst[s] - dst[t] + 2*P;\n\t\t\t\t\tlong Q = wws[k]*T>>>32;\n\t\t\t\t\tdst[s] = ndsts;\n\t\t\t\t\tdst[t] = ws[k]*T-Q*P&(1L<<32)-1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdw = dw * dw % P;\n\t\t\tif(i < h-1){\n\t\t\t\tfor(int k = 0;k < 1<<h-i-2;k++){\n\t\t\t\t\twws[k] = wws[k*2];\n\t\t\t\t\tws[k] = ws[k*2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(dst[i] >= P)dst[i] -= P;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint rev = Integer.reverse(i)>>>-h;\n\t\t\tif(i < rev){\n\t\t\t\tlong d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(inverse){\n\t\t\tlong in = invl(n, P);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tdst[i] = modh(dst[i] * in, M, H, P);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dst;\n\t}\n\t\n\tstatic final long mask = (1L<<31)-1;\n\t\n\tpublic static long modh(long a, long M, int h, int mod)\n\t{\n\t\tlong r = a-((M*(a&mask)>>>31)+M*(a>>>31)>>>h-31)*mod;\n\t\treturn r < mod ? r : r-mod;\n\t}\n\t\n\tprivate static long[] garnerPrepare(int[] m)\n\t{\n\t\tint n = m.length;\n\t\tassert n == m.length;\n\t\tif(n == 0)return new long[0];\n\t\tlong[] gamma = new long[n];\n\t\tfor(int k = 1;k < n;k++){\n\t\t\tlong prod = 1;\n\t\t\tfor(int i = 0;i < k;i++){\n\t\t\t\tprod = prod * m[i] % m[k];\n\t\t\t}\n\t\t\tgamma[k] = invl(prod, m[k]);\n\t\t}\n\t\treturn gamma;\n\t}\n\t\n\tprivate static long[] garnerBatch(int[] u, int[] m, long[] gamma)\n\t{\n\t\tint n = u.length;\n\t\tassert n == m.length;\n\t\tlong[] v = new long[n];\n\t\tv[0] = u[0];\n\t\tfor(int k = 1;k < n;k++){\n\t\t\tlong temp = v[k-1];\n\t\t\tfor(int j = k-2;j >= 0;j--){\n\t\t\t\ttemp = (temp * m[j] + v[j]) % m[k];\n\t\t\t}\n\t\t\tv[k] = (u[k] - temp) * gamma[k] % m[k];\n\t\t\tif(v[k] < 0)v[k] += m[k];\n\t\t}\n\t\treturn v;\n\t}\n\t\n\tprivate static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tprivate static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni(), K = ni();\n\t\t// (t-1)!/(n-1)!b!c!*3^(n+m+K-t)\n\t\t// b<=m, c<=K\n\t\tint mod = 1000000007;\n\t\tint[][] fif = enumFIF(400000, mod);\n\t\tlong[] ib = new long[m+1];\n\t\tfor(int i = 0;i <= m;i++)ib[i] = fif[1][i];\n\t\tlong[] ic = new long[K+1];\n\t\tfor(int i = 0;i <= K;i++)ic[i] = fif[1][i];\n\t\tlong[] is = convolute(ib, ic, 3, mod);\n\t\tlong ret = 0;\n\t\tfor(int t = n;t <= n+m+K;t++){\n\t\t\tret = ret * 3 + (long)fif[0][t-1]*is[t-n];\n\t\t\tret %= mod;\n\t\t}\n\t\tret = ret * fif[1][n-1] % mod;\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};\n\tpublic static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};\n//\tpublic static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};\n//\tpublic static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};\n\t\n\tpublic static long[] convoluteSimply(long[] a, long[] b, int P, int g)\n\t{\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t}\n\t\treturn nttmb(fa, m, true, P, g);\n\t}\n\t\n\tpublic static long[] convolute(long[] a, long[] b)\n\t{\n\t\tint USE = 2;\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[][] fs = new long[USE][];\n\t\tfor(int k = 0;k < USE;k++){\n\t\t\tint P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n\t\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t\t}\n\t\t\tfs[k] = nttmb(fa, m, true, P, g);\n\t\t}\n\t\t\n\t\tint[] mods = Arrays.copyOf(NTTPrimes, USE);\n\t\tlong[] gammas = garnerPrepare(mods);\n\t\tint[] buf = new int[USE];\n\t\tfor(int i = 0;i < fs[0].length;i++){\n\t\t\tfor(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n\t\t\tlong[] res = garnerBatch(buf, mods, gammas);\n\t\t\tlong ret = 0;\n\t\t\tfor(int j = res.length-1;j >= 0;j--)ret = ret * mods[j] + res[j];\n\t\t\tfs[0][i] = ret;\n\t\t}\n\t\treturn fs[0];\n\t}\n\t\n\tpublic static long[] convolute(long[] a, long[] b, int USE, int mod)\n\t{\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[][] fs = new long[USE][];\n\t\tfor(int k = 0;k < USE;k++){\n\t\t\tint P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n\t\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t\t}\n\t\t\tfs[k] = nttmb(fa, m, true, P, g);\n\t\t}\n\t\t\n\t\tint[] mods = Arrays.copyOf(NTTPrimes, USE);\n\t\tlong[] gammas = garnerPrepare(mods);\n\t\tint[] buf = new int[USE];\n\t\tfor(int i = 0;i < fs[0].length;i++){\n\t\t\tfor(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n\t\t\tlong[] res = garnerBatch(buf, mods, gammas);\n\t\t\tlong ret = 0;\n\t\t\tfor(int j = res.length-1;j >= 0;j--)ret = (ret * mods[j] + res[j]) % mod;\n\t\t\tfs[0][i] = ret;\n\t\t}\n\t\treturn fs[0];\n\t}\n\t\n\t// static int[] wws = new int[270000]; // outer faster\n\t\n\t// Modifed Montgomery + Barrett\n\tprivate static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)\n\t{\n\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\n\t\tint h = Integer.numberOfTrailingZeros(n);\n\t\tlong K = Integer.highestOneBit(P)<<1;\n\t\tint H = Long.numberOfTrailingZeros(K)*2;\n\t\tlong M = K*K/P;\n\t\t\n\t\tint[] wws = new int[1<<h-1];\n\t\tlong dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n\t\tlong w = (1L<<32)%P;\n\t\tfor(int k = 0;k < 1<<h-1;k++){\n\t\t\twws[k] = (int)w;\n\t\t\tw = modh(w*dw, M, H, P);\n\t\t}\n\t\tlong J = invl(P, 1L<<32);\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < 1<<i;j++){\n\t\t\t\tfor(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n\t\t\t\t\tlong u = (dst[s] - dst[t] + 2*P)*wws[k];\n\t\t\t\t\tdst[s] += dst[t];\n\t\t\t\t\tif(dst[s] >= 2*P)dst[s] -= 2*P;\n//\t\t\t\t\tlong Q = (u&(1L<<32)-1)*J&(1L<<32)-1;\n\t\t\t\t\tlong Q = (u<<32)*J>>>32;\n\t\t\t\t\tdst[t] = (u>>>32)-(Q*P>>>32)+P;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i < h-1){\n\t\t\t\tfor(int k = 0;k < 1<<h-i-2;k++)wws[k] = wws[k*2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(dst[i] >= P)dst[i] -= P;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint rev = Integer.reverse(i)>>>-h;\n\t\t\tif(i < rev){\n\t\t\t\tlong d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(inverse){\n\t\t\tlong in = invl(n, P);\n\t\t\tfor(int i = 0;i < n;i++)dst[i] = modh(dst[i]*in, M, H, P);\n\t\t}\n\t\t\n\t\treturn dst;\n\t}\n\t\n\t// Modified Shoup + Barrett\n\tprivate static long[] nttsb(long[] src, int n, boolean inverse, int P, int g)\n\t{\n\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\n\t\tint h = Integer.numberOfTrailingZeros(n);\n\t\tlong K = Integer.highestOneBit(P)<<1;\n\t\tint H = Long.numberOfTrailingZeros(K)*2;\n\t\tlong M = K*K/P;\n\t\t\n\t\tlong dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n\t\tlong[] wws = new long[1<<h-1];\n\t\tlong[] ws = new long[1<<h-1];\n\t\tlong w = 1;\n\t\tfor(int k = 0;k < 1<<h-1;k++){\n\t\t\twws[k] = (w<<32)/P;\n\t\t\tws[k] = w;\n\t\t\tw = modh(w*dw, M, H, P);\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < 1<<i;j++){\n\t\t\t\tfor(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n\t\t\t\t\tlong ndsts = dst[s] + dst[t];\n\t\t\t\t\tif(ndsts >= 2*P)ndsts -= 2*P;\n\t\t\t\t\tlong T = dst[s] - dst[t] + 2*P;\n\t\t\t\t\tlong Q = wws[k]*T>>>32;\n\t\t\t\t\tdst[s] = ndsts;\n\t\t\t\t\tdst[t] = ws[k]*T-Q*P&(1L<<32)-1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdw = dw * dw % P;\n\t\t\tif(i < h-1){\n\t\t\t\tfor(int k = 0;k < 1<<h-i-2;k++){\n\t\t\t\t\twws[k] = wws[k*2];\n\t\t\t\t\tws[k] = ws[k*2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(dst[i] >= P)dst[i] -= P;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint rev = Integer.reverse(i)>>>-h;\n\t\t\tif(i < rev){\n\t\t\t\tlong d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(inverse){\n\t\t\tlong in = invl(n, P);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tdst[i] = modh(dst[i] * in, M, H, P);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dst;\n\t}\n\t\n\tstatic final long mask = (1L<<31)-1;\n\t\n\tpublic static long modh(long a, long M, int h, int mod)\n\t{\n\t\tlong r = a-((M*(a&mask)>>>31)+M*(a>>>31)>>>h-31)*mod;\n\t\treturn r < mod ? r : r-mod;\n\t}\n\t\n\tprivate static long[] garnerPrepare(int[] m)\n\t{\n\t\tint n = m.length;\n\t\tassert n == m.length;\n\t\tif(n == 0)return new long[0];\n\t\tlong[] gamma = new long[n];\n\t\tfor(int k = 1;k < n;k++){\n\t\t\tlong prod = 1;\n\t\t\tfor(int i = 0;i < k;i++){\n\t\t\t\tprod = prod * m[i] % m[k];\n\t\t\t}\n\t\t\tgamma[k] = invl(prod, m[k]);\n\t\t}\n\t\treturn gamma;\n\t}\n\t\n\tprivate static long[] garnerBatch(int[] u, int[] m, long[] gamma)\n\t{\n\t\tint n = u.length;\n\t\tassert n == m.length;\n\t\tlong[] v = new long[n];\n\t\tv[0] = u[0];\n\t\tfor(int k = 1;k < n;k++){\n\t\t\tlong temp = v[k-1];\n\t\t\tfor(int j = k-2;j >= 0;j--){\n\t\t\t\ttemp = (temp * m[j] + v[j]) % m[k];\n\t\t\t}\n\t\t\tv[k] = (u[k] - temp) * gamma[k] % m[k];\n\t\t\tif(v[k] < 0)v[k] += m[k];\n\t\t}\n\t\treturn v;\n\t}\n\t\n\tprivate static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tprivate static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n \n \n \npublic class Main {\n\tpublic static long C(int n, int r)\n\t{\n\t\tif(n < 0 || r < 0 || r > n)return 0;\n\t\tif(r > n / 2)r = n - r;\n\t\treturn FACT[n]*IFACT[n-r]%mod*IFACT[r]%mod;\n\t}\n\t \n\tstatic long[] FACT, IFACT;\n\tstatic long inv(long v) {\n\t\treturn modPow(v, MOD - 2);\n\t}\n\t \n\t\t\n\tstatic int MOD = 1000000007;\n\tstatic int mod = MOD;\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintStream out = new PrintStream(System.out);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint n = N + M + K;\n\t\tFACT = new long[n+1];\n\t\tIFACT = new long[n+1];\n\t\tFACT[0] = 1;\n\t\tIFACT[0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tFACT[i] = FACT[i-1] * i % mod;\n\t\t\tIFACT[i] = inv(FACT[i]);\n\t\t}\n\t\tlong ans = 0;\n\t\tlong hh = 0;\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tint retA = modPow(3,N + M + K - i);\n\t\t\t\n\t\t\tint retB = (int)C(i-1,N-1);\n\t\t\tlong  retC = 0;\n\t\t\tretC = (retC + modPow(2,i - N)) % MOD;\n\t\t\thh = hh * 2 % MOD;\n\t\t\tif (i - N > M) hh = (hh + C(M + i - N - M - 1, i - N - M - 1)) % MOD;\n\t\t\tif (i - N > K) hh = (hh + C(K + i - N - K - 1, i - N - K - 1)) % MOD;\n\t\t\tretC = (retC - hh) % MOD;\n\t\t\tlong ansA = ((long)(retA) * (long)(retB)) % MOD;\n\t\t\t\n\t\t\tansA *= retC % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static int modPow(long a, long b) {\n\t\tif(b == 0) return 1 % MOD;\n\t\tif(b == 1) return (int) (a % MOD);\n\t\t\n\t\tif(b % 2 == 0) {\n\t\t\tlong ret = modPow(a % MOD,b / 2) % MOD;\n\t\t\treturn (int)((ret * ret) % MOD);\n\t\t}\n\t\telse {\n\t\t\tlong ret = (a * (long)modPow(a % MOD,b-1)) % MOD;\n\t\t\treturn (int)(ret % MOD);\n\t\t}\n\t}\n\tpublic static int comb(long n, long k) {\n\t\tif(k == 0) return 1;\n\t\tlong AA = 1;\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tAA *= (long)n - i;\n\t\t\tAA %= MOD;\n\t\t}\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tAA *= inv(i);\n\t\t\tAA %= MOD;\n\t\t}\n\t\treturn (int)(AA % MOD);\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n \n \n \npublic class Main {\n\tpublic static long C(int n, int r)\n\t{\n\t\tif(n < 0 || r < 0 || r > n)return 0;\n\t\tif(r > n / 2)r = n - r;\n\t\treturn FACT[n]*IFACT[n-r]%mod*IFACT[r]%mod;\n\t}\n\t \n\tstatic long[] FACT, IFACT;\n\n\t \n\t\t\n\tstatic int MOD = 1000000007;\n\tstatic int mod = MOD;\n\tpublic static void main(String[] args) {\n\t\tint n = 900000;\n\t\tFACT = new long[n+1];\n\t\tIFACT = new long[n+1];\n\t\tFACT[0] = 1;\n\t\tIFACT[0] = 1;\n\t\t\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tFACT[i] = FACT[i-1] * i % mod;\n\t\t\tIFACT[i] = new BigInteger(String.valueOf(FACT[i])).modInverse(new BigInteger(String.valueOf(mod))).longValue();\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintStream out = new PrintStream(System.out);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tlong ans = 0;\n\t\t\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tint retA = modPow(3,N + M + K - i);\n\t\t\t\n\t\t\tint retB = (int)C(i-1,N-1);\n\t\t\tint kMax = Math.max(0, i - N-K);\n\t\t\tint kMin = Math.min(i - N, M);\n\t\t\tlong sum = 0;\n\t\t\tfor(int k = kMax; k <= kMin; k++) {\n\t\t\t\tsum += (int)C(i - N, k) % MOD;\n\t\t\t\tsum %= MOD;\n\t\t\t}\n\t\t\tlong ansA = ((long)(retA) * (long)(retB)) % MOD;\n\t\t\tansA *= sum % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static int modPow(int a, int b) {\n\t\tif(b == 0) return 1 % MOD;\n\t\tif(b == 1) return a % MOD;\n\t\t\n\t\tif(b % 2 == 0) {\n\t\t\tlong ret = modPow(a % MOD,b / 2) % MOD;\n\t\t\treturn (int)((ret * ret) % MOD);\n\t\t}\n\t\telse {\n\t\t\tlong ret = (a * (long)modPow(a % MOD,b-1)) % MOD;\n\t\t\treturn (int)(ret % MOD);\n\t\t}\n\t}\n\tpublic static int comb(int n, int k) {\n\t\tif(k == 0) return 1;\n\t\tlong AA = 1;\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tAA *= (long)n - i;\n\t\t\tAA %= MOD;\n\t\t}\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tAA *= new BigInteger(String.valueOf(i)).modInverse(new BigInteger(String.valueOf(MOD))).longValue();\n\t\t\tAA %= MOD;\n\t\t}\n\t\treturn (int)(AA % MOD);\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long FACT[1000000];\nlong long IFACT[1000000];\n\nstatic int MOD = 1000000007;\nstatic int mod = MOD;\nint modPow(long a, long b) {\n if(b == 0) return 1 % MOD;\n if(b == 1) return (int) (a % MOD);\n\n if(b % 2 == 0) {\n\t long ret = modPow(a % MOD,b / 2) % MOD;\n\t return (int)((ret * ret) % MOD);\n }\n else {\n\t long ret = (a * (long)modPow(a % MOD,b-1)) % MOD;\n\t return (int)(ret % MOD);\n }\n}\n\n\n\n\tlong long C(int n, int r)\n\t{\n\t\tif(n < 0 || r < 0 || r > n)return 0;\n\t\tif(r > n / 2)r = n - r;\n\t\treturn FACT[n]*IFACT[n-r]%mod*IFACT[r]%mod;\n\t}\n\n\tlong long INV(long v) {\n\t\treturn modPow(v, MOD - 2);\n\t}\n\n\n\nint main() {\n\tint N,M,K,n;\n\tcin >> N >> M >> K;\n\t\tn = N + M + K;\n\n\t\tFACT[0] = 1;\n\t\tIFACT[0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tFACT[i] = FACT[i-1] * i % mod;\n\t\t\tIFACT[i] = INV(FACT[i]);\n\t\t}\n\t\tlong long ans = 0;\n\t\tlong long hh = 0;\n\t\tfor(int i = N; i <= N + M + K; i++) {\n\t\t\tint retA = modPow(3,N + M + K - i);\n\n\t\t\tint retB = (int)C(i-1,N-1);\n\t\t\tlong  retC = 0;\n\t\t\tretC = (retC + modPow(2,i - N)) % MOD;\n\t\t\thh = hh * 2 % MOD;\n\t\t\tif (i - N > M) hh = (hh + C(M + i - N - M - 1, i - N - M - 1)) % MOD;\n\t\t\tif (i - N > K) hh = (hh + C(K + i - N - K - 1, i - N - K - 1)) % MOD;\n\t\t\tretC = (retC - hh) % MOD;\n\t\t\tlong ansA = ((long)(retA) * (long)(retB)) % MOD;\n\n\t\t\tansA *= retC % MOD;\n\t\t\tansA %= MOD;\n\t\t\tans += ansA;\n\t\t\tans %= MOD;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Number = System.Int64;\n\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            var k = sc.Integer();\n            var table = new ModTable(n + m + k + 1);\n\n            ModInteger ans = 0;\n            ModInteger C = 1;\n            var l = 0;\n            var r = 0;\n            for (int i = n; i <= n + m + k; i++)\n            {\n                var a = table.Combination(i - 1, n - 1);\n                a *= ModInteger.Pow(3, n + m + k - i);\n                a *= C;\n                ans += a;\n                C *= 2;\n                var rem = i - n + 1;\n                Debug.WriteLine(\"{0} {1}\", l, r);\n                var nl = Math.Max(0, rem - k);\n                var nr = Math.Min(m, rem);\n                if (l != nl) C -= table.Combination(i - n, l);\n                if (r == nr) C -= table.Combination(i - n, r);\n                else if (r > nr) { C -= table.Combination(i - n, r) * 2; }\n                l = nl;\n                r = nr;\n            }\n            IO.Printer.Out.WriteLine(ans);\n\n        }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region ModNumber\npublic partial struct ModInteger\n{\n    public const long Mod = (long)1e9 + 7;\n    public long num;\n    public ModInteger(long n) : this() { num = n % Mod; if (num < 0) num += Mod; }\n    public override string ToString() { return num.ToString(); }\n    public static ModInteger operator +(ModInteger l, ModInteger r) { var n = l.num + r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator -(ModInteger l, ModInteger r) { var n = l.num + Mod - r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator *(ModInteger l, ModInteger r) { return new ModInteger(l.num * r.num); }\n    public static implicit operator ModInteger(long n) { return new ModInteger(n); }\n    public static ModInteger Pow(ModInteger v, long k)\n    {\n        ModInteger ret = 1;\n        var n = k;\n        for (; n > 0; n >>= 1, v *= v)\n        {\n            if ((n & 1) == 1)\n                ret = ret * v;\n        }\n        return ret;\n    }\n}\n#endregion\n#region Inverse\npublic partial struct ModInteger\n{\n    static public ModInteger Inverse(ModInteger v)\n    {\n        long p, q;\n        ExGCD(v.num, Mod, out p, out q);\n        return new ModInteger(p % Mod + Mod);\n    }\n    static public long ExGCD(long a, long b, out long x, out long y)\n    {\n        var u = new long[] { a, 1, 0 };\n        var v = new long[] { b, 0, 1 };\n        while (v[0] != 0)\n        {\n            var t = u[0] / v[0];\n            for (int i = 0; i < 3; i++)\n            {\n                var tmp = u[i] - t * v[i];\n                u[i] = v[i];\n                v[i] = tmp;\n            }\n        }\n        x = u[1];\n        y = u[2];\n        if (u[0] > 0)\n            return u[0];\n        for (int i = 0; i < 3; i++)\n            u[i] = -u[i];\n        return u[0];\n    }\n}\n#endregion\n\n#region ModTable\npublic class ModTable\n{\n    public ModInteger[] perm, invp;\n    public ModTable(int n)\n    {\n        perm = new ModInteger[n + 1];\n        invp = new ModInteger[n + 1];\n        perm[0] = 1;\n        for (int i = 1; i <= n; i++)\n            perm[i] = perm[i - 1] * i;\n        invp[n] = ModInteger.Inverse(perm[n]);\n        for (int i = n - 1; i >= 0; i--)\n            invp[i] = invp[i + 1] * (i + 1);\n        invp[0] = invp[1];\n    }\n    public ModInteger Inverse(int k) { return invp[k]; }\n    public ModInteger Permutation(int n, int k)\n    {\n        if (n < 0 || n >= perm.Length)\n            return 0;\n        if (k < 0 || k >= n)\n            return 0;\n        return perm[n] * invp[n - k];\n    }\n    public ModInteger Combination(int n, int r)\n    {\n        if (n < 0 || n >= perm.Length || r < 0 || r > n) return 0;\n        return perm[n] * invp[n - r] * invp[r];\n    }\n    public ModInteger RepeatedCombination(int n, int k)\n    {\n        if (k == 0) return 1;\n        return Combination(n + k - 1, k);\n    }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    int N,M,K;\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Read();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        Fact F = new Fact(N+M+K);\n        long[] po = new long[M+K+1];\n        po[0] = 1;\n        for(int i=1;i<=M+K;i++){\n            po[i] = po[i-1]*3%Define.mod;\n        }\n        long d = 1;\n        long count = 0;\n        for(int i=N;i<=N+M+K;i++){\n            count = (count + (F.GetConv(i-1,N-1)*d)%Define.mod*po[N+M+K-i]%Define.mod) % Define.mod;\n            d = d*2%Define.mod;\n            if(i-N >= M){\n                d = (d + Define.mod - F.GetConv(i-N,M))%Define.mod;\n            }\n            if(i-N >= K){\n                d = (d + Define.mod - F.GetConv(i-N,K))%Define.mod;\n            }\n        }\n        sb.Append(count+\"\\n\");\n    }\n    void Read(){\n        string[] str = Console.ReadLine().Split(' ');\n        N = int.Parse(str[0]);\n        M = int.Parse(str[1]);\n        K = int.Parse(str[2]);\n    }    \n}\nclass Fact{\n    public long[] f;\n    public long[] rf;\n    public Fact(int N){\n        f = new long[N+1];\n        rf = new long[N+1];\n        for(int i=0;i<N+1;i++){\n            if(i == 0){\n                f[i] = 1;\n            }\n            else{\n                f[i] = (f[i-1]*i)%Define.mod;\n            }\n        }\n        for(int i=N;i>=0;i--){\n            if(i == N){\n                rf[i] = pow(f[N],Define.mod-2);\n            }\n            else{\n                rf[i] = rf[i+1]*(i+1)%Define.mod;\n            }\n        }\n    }\n    public long pow(long N,long K){\n        if(K == 0){\n            return 1;\n        }\n        else if(K % 2 == 0){\n            long t = pow(N,K/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return N*pow(N,K-1)%Define.mod;\n        }\n    }\n    public long GetFact(int N){\n        return f[N];\n    }\n    public long GetConv(int N,int R){\n        return ((f[N]*rf[R])%Define.mod*rf[N-R])%Define.mod;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    static readonly int Mod = (int)1e9 + 7;\n\n    public void Solve()\n    {\n        int A = Reader.Int(), B = Reader.Int(), C = Reader.Int();\n        if (B > C) { int t = B; B = C; C = t; }\n        long ans = 0;\n        var Comb = new ModC(A + B + C, Mod);\n        var pow3 = new long[A + B + C];\n        pow3[0] = 1;\n        for (int i = 1; i < pow3.Length; i++) pow3[i] = pow3[i - 1] * 3 % Mod;\n        long BCcomb = 1;\n\n        for (int S = A - 1; S <= A - 1 + B + C; S++)\n        {\n            ans = (ans + Comb[S, A - 1] * BCcomb % Mod * pow3[A + B + C - S - 1]) % Mod;\n            BCcomb = BCcomb * 2 % Mod;\n            int rem = S - A + 1;\n            if (rem >= B) BCcomb = (BCcomb + Mod - Comb[rem, B]) % Mod;\n            if (rem >= C) BCcomb = (BCcomb + Mod - Comb[rem, rem - C]) % Mod;\n        }\n\n        Console.WriteLine(ans);\n    }\n\n    static long ModPower(long x, long n, long mod) // x ^ n\n    {\n        long res = 1;\n        x = (x % mod + mod) % mod;\n        while (n > 0)\n        {\n            if ((n & 1) == 1) res = res * x % mod;\n            x = x * x % mod;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    class ModC\n    {\n        readonly long P;\n        readonly long[] Fact, InvFact;\n\n        public int this[int n, int k]\n        {\n            get\n            {\n                if (n < 0 || k < 0 || k > n) return 0;\n                return (int)(Fact[n] * InvFact[k] % P * InvFact[n - k] % P);\n            }\n        }\n        public ModC(int maxN, int p) // maxN < p, p is prime\n        {\n            P = p;\n            Fact = new long[maxN + 1];\n            InvFact = new long[maxN + 1];\n            Fact[0] = 1;\n            for (long i = 1; i <= maxN; i++)\n                Fact[i] = Fact[i - 1] * i % P;\n            InvFact[maxN] = ModPower(Fact[maxN], Mod - 2, Mod);\n            for (int i = maxN - 1; i >= 0; i--)\n                InvFact[i] = InvFact[i + 1] * (i + 1) % Mod;\n        }\n    }\n}\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\nclass Program\n{\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var sc = new Scan();\n        int n, m, k;\n        sc.Multi(out n, out m, out k);\n        var mt = new mymath();\n        long ans = 0;\n        for (int i = 0; i <= m; i++)\n        {\n            for (int j = 0; j <= k; j++)\n            {\n                ans = (ans + mt.Comb(n - 1 + i + j, i) * mt.Comb(n - 1 + j, j) % M * (mt.powmod(3, m - i + k - j)) % M) % M;\n            }\n        }\n        sw.WriteLine(ans);\n        sw.Flush();\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static void swap<T>(IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG<T>(params T[] a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { Console.WriteLine(string.Join(\" \", a)); }\n    static T[] copy<T>(IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public int[] IntArrWithSep(char sep) { return Str.Split(sep).Select(int.Parse).ToArray(); }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    T cv<T>(string inp)\n    {\n        if (typeof(T).Equals(typeof(int)))    return (T)Convert.ChangeType(int.Parse(inp), typeof(T));\n        if (typeof(T).Equals(typeof(long)))   return (T)Convert.ChangeType(long.Parse(inp), typeof(T));\n        if (typeof(T).Equals(typeof(double))) return (T)Convert.ChangeType(double.Parse(inp), typeof(T));\n        if (typeof(T).Equals(typeof(char)))   return (T)Convert.ChangeType(inp[0], typeof(T));\n        return (T)Convert.ChangeType(inp, typeof(T));\n    }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass mymath\n{\n    static int Mod = 1000000007;\n    public void setMod(int m) { Mod = m; }\n    public bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public bool[] sieve(int n)\n    {\n        var isp = new bool[n + 1];\n        for (int i = 2; i <= n; i++) isp[i] = true;\n        for (int i = 2; i * i <= n; i++) if (isp[i]) for (int j = i * i; j <= n; j += i) isp[j] = false;\n        return isp;\n    }\n    public List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var isp = sieve(n);\n        for (int i = 2; i <= n; i++) if (isp[i]) prs.Add(i);\n        return prs;\n    }\n    public long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++)\n        {\n            ret[i] = new long[n];\n            ret[i][i] = 1;\n        }\n        return ret;\n    }\n    public long[][] powmat(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = powmat(A, n / 2);\n        if ((n & 1) == 0) return mulmat(t, t);\n        return mulmat(mulmat(t, t), A);\n    }\n    public long[] mulmat(long[][] A, long[] x)\n    {\n        int n = A.Length, m = x.Length;\n        var ans = new long[n];\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) ans[i] = (ans[i] + x[j] * A[i][j]) % Mod;\n        return ans;\n    }\n    public long[][] mulmat(long[][] A, long[][] B)\n    {\n        int n = A.Length, m = B[0].Length, l = B.Length;\n        var ans = new long[n][];\n        for (int i = 0; i < n; i++)\n        {\n            ans[i] = new long[m];\n            for (int j = 0; j < m; j++) for (int k = 0; k < l; k++) ans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % Mod;\n        }\n        return ans;\n    }\n    public long powmod(long a, long b)\n    {\n        if (a >= Mod) return powmod(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = powmod(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    public long lcm(long a, long b) { return a * (b / gcd(a, b)); }\n    public long Comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        var numerator = new int[r];\n        var denominator = new int[r];\n        for (int k = 0; k < r; k++)\n        {\n            numerator[k] = n - r + k + 1;\n            denominator[k] = k + 1;\n        }\n        for (int p = 2; p <= r; p++)\n        {\n            int pivot = denominator[p - 1];\n            if (pivot > 1)\n            {\n                int offset = (n - r) % p;\n                for (int k = p - 1; k < r; k += p)\n                {\n                    numerator[k - offset] /= pivot;\n                    denominator[k] /= pivot;\n                }\n            }\n        }\n        long result = 1;\n        for (int k = 0; k < r; k++) if (numerator[k] > 1) result = result * numerator[k] % Mod;\n        return result;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Numerics;\n\n// (づ°ω°)づﾐe★゜・。。・゜゜・。。・゜☆゜・。。・゜゜・。。・゜\npublic class Solver\n{\n    const int MOD = 1000000007;\n\n    long[] f, rf, inv;\n    void InitFacts(int size)\n    {\n        f = new long[size + 1];\n        rf = new long[size + 1];\n        inv = new long[size + 1];\n        f[0] = f[1] = rf[0] = rf[1] = inv[1] = 1;\n        for (int i = 2; i <= size; i++)\n        {\n            f[i] = f[i - 1] * i % MOD;\n            inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n            rf[i] = inv[i] * rf[i - 1] % MOD;\n        }\n    }\n\n    const int MAX = 10000;\n\n    public void Solve()\n    {\n        int n = ReadInt();\n        int m = ReadInt();\n        int k = ReadInt();\n\n        if (n > 1000 || m > 1000 || k > 1000)\n            throw new Exception();\n\n        InitFacts(MAX);\n        var pow = new long[MAX];\n        pow[0] = 1;\n        for (int i = 1; i < MAX; i++)\n            pow[i] = pow[i - 1] * 3 % MOD;\n\n        long ans = 0;\n        for (int len = n; len <= n + m + k; len++)\n        {\n            for (int i = 0; i <= m; i++)\n            {\n                int j = len - n - i;\n                if (j < 0 || j > k)\n                    continue;\n                ans += f[len - 1] * rf[n - 1] % MOD * rf[i] % MOD * rf[j] % MOD * pow[n + m + k - len] % MOD;\n            }\n        }\n\n        Write(ans % MOD);\n    }\n\n    #region Main\n\n    protected static TextReader reader;\n    protected static TextWriter writer;\n    static void Main()\n    {\n#if DEBUG\n        reader = new StreamReader(\"..\\\\..\\\\input.txt\");\n        //reader = new StreamReader(Console.OpenStandardInput());\n        writer = Console.Out;\n        //writer = new StreamWriter(\"..\\\\..\\\\output.txt\");\n#else\n        reader = new StreamReader(Console.OpenStandardInput());\n        writer = new StreamWriter(Console.OpenStandardOutput());\n        //reader = new StreamReader(\"input.txt\");\n        //writer = new StreamWriter(\"output.txt\");\n#endif\n        try\n        {\n            new Solver().Solve();\n            //var thread = new Thread(new Solver().Solve, 1024 * 1024 * 128);\n            //thread.Start();\n            //thread.Join();\n        }\n        catch (Exception ex)\n        {\n#if DEBUG\n            Console.WriteLine(ex);\n#else\n            throw;\n#endif\n        }\n        reader.Close();\n        writer.Close();\n    }\n\n    #endregion\n\n    #region Read / Write\n    private static Queue<string> currentLineTokens = new Queue<string>();\n    private static string[] ReadAndSplitLine() { return reader.ReadLine().Split(new[] { ' ', '\\t', }, StringSplitOptions.RemoveEmptyEntries); }\n    public static string ReadToken() { while (currentLineTokens.Count == 0)currentLineTokens = new Queue<string>(ReadAndSplitLine()); return currentLineTokens.Dequeue(); }\n    public static int ReadInt() { return int.Parse(ReadToken()); }\n    public static long ReadLong() { return long.Parse(ReadToken()); }\n    public static double ReadDouble() { return double.Parse(ReadToken(), CultureInfo.InvariantCulture); }\n    public static int[] ReadIntArray() { return ReadAndSplitLine().Select(int.Parse).ToArray(); }\n    public static long[] ReadLongArray() { return ReadAndSplitLine().Select(long.Parse).ToArray(); }\n    public static double[] ReadDoubleArray() { return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray(); }\n    public static int[][] ReadIntMatrix(int numberOfRows) { int[][] matrix = new int[numberOfRows][]; for (int i = 0; i < numberOfRows; i++)matrix[i] = ReadIntArray(); return matrix; }\n    public static int[][] ReadAndTransposeIntMatrix(int numberOfRows)\n    {\n        int[][] matrix = ReadIntMatrix(numberOfRows); int[][] ret = new int[matrix[0].Length][];\n        for (int i = 0; i < ret.Length; i++) { ret[i] = new int[numberOfRows]; for (int j = 0; j < numberOfRows; j++)ret[i][j] = matrix[j][i]; } return ret;\n    }\n    public static string[] ReadLines(int quantity) { string[] lines = new string[quantity]; for (int i = 0; i < quantity; i++)lines[i] = reader.ReadLine().Trim(); return lines; }\n    public static void WriteArray<T>(IEnumerable<T> array) { writer.WriteLine(string.Join(\" \", array)); }\n    public static void Write(params object[] array) { WriteArray(array); }\n    public static void WriteLines<T>(IEnumerable<T> array) { foreach (var a in array)writer.WriteLine(a); }\n    private class SDictionary<TKey, TValue> : Dictionary<TKey, TValue>\n    {\n        public new TValue this[TKey key]\n        {\n            get { return ContainsKey(key) ? base[key] : default(TValue); }\n            set { base[key] = value; }\n        }\n    }\n    private static T[] Init<T>(int size) where T : new() { var ret = new T[size]; for (int i = 0; i < size; i++)ret[i] = new T(); return ret; }\n    #endregion\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    static readonly int Mod = (int)1e9 + 7;\n\n    public void Solve()\n    {\n        int A = Reader.Int(), B = Reader.Int(), C = Reader.Int();\n        if (B > C) { int t = B; B = C; C = t; }\n        long ans = 0;\n        var Comb = new ModC(A + B + C, Mod);\n        long BCcomb = 1;\n\n        for (int S = A - 1; S <= A - 1 + B + C; S++)\n        {\n            long count = Comb[S, A - 1];\n            ans = (ans + count * BCcomb % Mod * ModPower(3, A + B + C - S - 1, Mod)) % Mod;\n            BCcomb = BCcomb * 2 % Mod;\n            int rem = S - A + 1;\n            if (rem >= B) BCcomb = (BCcomb + Mod - Comb[rem, B]) % Mod;\n            if (rem >= C) BCcomb = (BCcomb + Mod - Comb[rem, rem - C]) % Mod;\n        }\n\n        Console.WriteLine(ans);\n    }\n\n    static long ModPower(long x, long n, long mod) // x ^ n\n    {\n        long res = 1;\n        x = (x % mod + mod) % mod;\n        while (n > 0)\n        {\n            if ((n & 1) == 1) res = res * x % mod;\n            x = x * x % mod;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    class ModC\n    {\n        readonly long P;\n        readonly long[] Fact, InvFact;\n\n        public int this[int n, int k]\n        {\n            get\n            {\n                if (n < 0 || k < 0 || k > n) return 0;\n                return (int)(Fact[n] * InvFact[k] % P * InvFact[n - k] % P);\n            }\n        }\n        public ModC(int maxN, int p) // maxN < p, p is prime\n        {\n            P = p;\n            Fact = new long[maxN + 1];\n            InvFact = new long[maxN + 1];\n            Fact[0] = InvFact[0] = 1;\n            for (long i = 1; i <= maxN; i++)\n            {\n                Fact[i] = Fact[i - 1] * i % P;\n                InvFact[i] = ModPower(Fact[i], P - 2, P) % P;\n            }\n        }\n    }\n}\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "N, M, K = gets.strip.split(/ /).collect{|n| n.to_i}\n\nif N > 1000 || M > 1000 || K > 1000\n\tputs 0\n\texit\nend\n\nMOD = 10 ** 9 + 7\n\n$fact1_table = {}\ndef fact1(n)\n\tif ret = $fact1_table[n]\n\t\treturn ret\n\tend\n\tret = 1\n\t(2..n).each{|i|\n\t\tret *= i\n\t}\n\t$fact1_table[n] = ret\n\tret\nend\n\n$fact2_table = {}\ndef fact2(n)\n\tif ret = $fact2_table[n]\n\t\treturn ret\n\tend\n\tret = 1\n\t(N..n).each{|i|\n\t\tret *= i\n\t}\n\t$fact2_table[n] = ret\n\tret\nend\n\n\ncount = 0\n\ntable_m = []\ntable_mk = []\n\n(0..M).each{|m|\n#p m\n\t(0..K).each{|k|\n\t\tif m < k\n\t\t\tm2 = m\n\t\t\tk2 = k\n\t\telse\n\t\t\tm2 = k\n\t\t\tk2 = m\n\t\tend\n\t\t\n\t\t\n\t\tt1 = table_m[m2]\n\t\tt2 = table_mk[m2]\n\t\tunless t1\n\t\t\tt1 = table_m[m2] = []\n\t\t\tt2 = table_mk[m2] = []\n\t\tend\n\t\t\n\t\tunless c = t2[k2]\n\t\t\tc = 0\n#\t\t\tunless c = t1[k2]\n\t\t\t\tc = fact2(N - 1 + m + k)\n\t\t\t\tc /= fact1(m)\n\t\t\t\tt1[k2] = c\n#\t\t\tend\n\t\t\tc /= fact1(k)\n\t\t\tc = c % MOD\n\t\t\tc = (c * ((3 ** (M - m + K - k)) % MOD)) % MOD\n\t\t\tt2[k2] = c\n\t\tend\n\t\t\n\t\tcount = (count + c) % MOD\n\t}\n}\n\nputs count\n\n"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define N 555555\n#define M 1000000007\nint A,B,C,S,i;LL w,an,pw[N],I[N];\nLL Pw(LL a,LL b,LL p){\n\tLL v=1;\n\tfor(;b;b>>=1,a=a*a%p)if(b&1)v=v*a%p;\n\treturn v;\n}\nLL Ce(int x,int y){\n\treturn pw[y]*I[x]%M*I[y-x]%M;\n}\nint main(){\n\tscanf(\"%d%d%d\",&A,&B,&C);\n\tS=A+B+C;\n\tfor(pw[0]=i=1;i<=S;i++)pw[i]=1ll*i*pw[i-1];\n\tI[S]=Pw(pw[S],M-2,M);\n\tfor(i=S;i;i--)I[i-1]=1ll*i*I[i]%M;w=1;\n\tfor(i=A;i<=S;i++){\n\t\tan=(an+Ce(A-1,i-1)*w%M*Pw(3,S-i,M))%M;\n\t\tw=(w+w)%M;\n\t\tif(i>=A+B)w=(w-Ce(B,i-A)+M)%M;\n\t\tif(i>=A+C)w=(w-Ce(i-A-C,i-A)+M)%M;\n\t}\n\tprintf(\"%lld\",an);\n}"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef long double DD;\nconst int inf = 1e9;\nconst int mo= 1e9+7;\nconst int N = 9e5+10;\nint n, m, k, fac[N], inv[N], tmp[N], mi[N];\n\n\nint C(int n, int m){\n\treturn 1ll * fac[n] * inv[m] % mo * inv[n - m] % mo;\n}\n\nint pow(int a, int k){\n\tint ans=1;\n\tfor(; k; k =k >> 1, a = 1ll * a * a % mo)\n\t\tif(k & 1)\n\t\t\tans = 1ll * ans * a % mo;\n\treturn ans;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(false);\n\tcout.tie(false);\n\tcin >> n >> m >> k;\n\tfac[0] = 1;\n\tfor(int i = 1; i <= 900000; i++){\n\t\tfac[i] = 1ll * fac[i-1] * i % mo;\n\t}\n\tinv[900000] = pow(fac[900000], mo - 2);\n\tinv[0] = 1;\n\tint sz = m + k;\n\tfor(int i = 899999; i ; i--)\n\t\tinv[i] = 1ll * inv[i + 1] * (i + 1) % mo;\n\tmi[0] = 1;\n\tfor(int i = 1; i <= sz; i++)\n\t\tmi[i] = mi[i - 1] * 3ll % mo;\n\t\n\tLL ans = 0,sum = 1;\n\tfor(int i = 0; i <= sz; i++){\n\t\tans = (ans + 1ll * sum * C(i + n -1, n - 1) % mo * mi[sz - i] )% mo;\n\t\tsum=(sum<<1)%mo;\n\t\tif(i >= m)\n\t\t\tsum = (sum - C(i, m) + mo) % mo;\n\t\tif(i >= k)\n\t\t\tsum = (sum - C(i, i - k) + mo) % mo;\n\t\t\t\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<algorithm>\n#define md 1000000007\n#define C(x,y)(1ll*jc[y]*ny[x]%md*ny[(y)-(x)]%md)\nusing namespace std;\nint jc[1000001],ny[1000001];\nint pw(int x,int y){\n\tint ans=1;\n\tfor(int i=1;y;i<<=1,x=1ll*x*x%md)\n\t\tif(y&i)ans=1ll*x*ans%md,y-=i;\n\treturn ans;\n}\nint main(){\n\tint n,m,k,z;scanf(\"%d%d%d\",&n,&m,&k);z=n+m+k;\n\tif(m>k)swap(m,k);\n\tfor(int i=jc[0]=1;i<=z;i++)jc[i]=1ll*i*jc[i-1]%md;\n\tny[z]=pw(jc[z],md-2);\n\tfor(int i=z;i;i--)ny[i-1]=1ll*i*ny[i]%md;\n\tint ans=0,o=1;\n\tfor(int i=n;i<=z;i++){\n\t\tans=(ans+C(n-1,i-1)*o%md*pw(3,z-i))%md;\n\t\to=(o+o)%md;\n\t\tif(i>=n+m)o=(o-C(m,i-n)+md)%md;\n\t\tif(i>=n+k)o=(o-C(i-n-k,i-n)+md)%md;\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "Nim",
    "code": "import sequtils, strutils\n\nconst\n  mo = 1_000_000_007\n\nproc powmod(x:int, y=mo-2): int =\n  result = 1\n  var\n    x = x\n    i = 1\n  while i <= y:\n    if (i and y) != 0:\n      result = result * x mod mo\n    x = x*x mod mo\n    i = i shl 1\n\nvar\n  facts = newSeq[int](1_000_000)\n  inv_fact = newSeq[int](1_000_000)\nfacts[0] = 1\nfor i in 1..<1_000_000:\n  facts[i] = facts[i-1]*i mod mo\ninv_fact[1_000_000-1] = powmod(facts[1_000_000-1])\nfor i in countdown(1_000_000-1, 1):\n  inv_fact[i-1] = inv_fact[i]*i mod mo\n\nproc comb(n,k: int): int =\n  if n < k:\n    return 0\n  facts[n] * inv_fact[n-k] mod mo * inv_fact[k] mod mo\n\nlet\n  nmk = stdin.readline.split.map(parseInt)\n  (n, m, k) = (nmk[0], nmk[1], nmk[2])\nvar\n  res = 0\n  mc = 0\n  kc = 0\n\nfor i in n..(n+m+k):\n  mc = (2 * mc + comb(i-1-n, m)) mod mo\n  kc = (2 * kc + comb(i-1-n, k)) mod mo\n  res +=  (comb(i-1, n-1)*(powmod(2, i-n)-mc-kc) mod mo * powmod(3, n+m+k-i) mod mo + mo) mod mo\n  res = res mod mo\n\necho res\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\nconst MOD = 1000000007\nvar N:int\nvar M:int\nvar K:int\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  M = nextInt()\n  K = nextInt()\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int32\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a.int32\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0.int32: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v = ((self.v.int * initModInt(a, Mod).v.int) mod MOD).int32\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ combination\nimport sequtils\n\nproc `/`(a, b:int):int = a div b\n\nproc fact(T:typedesc, k:int):T =\n  var fact_a{.global.} = @[getDefault(T).init(1)]\n  if k >= fact_a.len:\n    let sz_old = fact_a.len - 1\n    let sz = max(sz_old * 2, k)\n    fact_a.setlen(sz + 1)\n    for i in sz_old + 1..sz: fact_a[i] = fact_a[i-1] * getDefault(T).init(i)\n  return fact_a[k]\nproc rfact(T:typedesc, k:int):T =\n  var rfact_a{.global.} = @[getDefault(T).init(1)]\n  if k >= rfact_a.len:\n    let sz_old = rfact_a.len - 1\n    let sz = max(sz_old * 2, k)\n    rfact_a.setlen(sz + 1)\n    rfact_a[sz] = getDefault(T).init(1) / T.fact(sz)\n    for i in countdown(sz - 1, sz_old + 1): rfact_a[i] = rfact_a[i + 1] * getDefault(T).init(i + 1)\n  return rfact_a[k]\n\nproc inv(T:typedesc, k:int):T =\n  return T.fact_a(k - 1) * T.rfact(k)\n\nproc P(T:typedesc, n,r:int):T =\n  if r < 0 or n < r: return getDefault(T).init(0)\n  return T.fact(n) * T.rfact(n - r)\nproc C(T:typedesc, p,q:int):T =\n  if q < 0 or p < q: return getDefault(T).init(0)\n  return T.fact(p) * T.rfact(q) * T.rfact(p - q)\nproc H(T: typedesc, n,r:int):T =\n  if n < 0 or r < 0: return getDefault(T).init(0)\n  return if r == 0: T(1) else: T.C(n + r - 1, r)\n#}}}\n\nproc main() =\n  ans := initMint(0)\n  s := initMint(1)\n  l := 0\n  r := 0\n  for m in 0..M+K:\n    let\n      l2 = max(0, m - K)\n      r2 = min(M, m)\n    if l < l2:\n      while l < l2:\n        s -= Mint.C(m, l)\n        l.inc\n    elif l > l2:\n      while l > l2:\n        l.dec\n        s += Mint.C(m, l)\n    if r < r2:\n      while r < r2:\n        r.inc\n        s += Mint.C(m, r)\n    elif r > r2:\n      while r > r2:\n        s -= Mint.C(m, r)\n        r.dec\n    ans += s * Mint.fact(N - 1 + m)/(Mint.fact(N - 1) * Mint.fact(m)) * initMint(3) ^ (M + K - m)\n    s = s * 2 + Mint.C(m, l - 1) - Mint.C(m, r)\n  print ans\n\n\n#  for i in 0..M:\n#    for j in 0..K:\n#      d := Mint.fact(N - 1 + i + j)/(Mint.fact(N - 1) * Mint.fact(i) * Mint.fact(j)) * initMint(3)^(M + K - i - j)\n#      ans += d\n##      echo i,\" \", j, \" \", d\n#  print ans\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "mod=int(1E9+7)\nJS=[1]\nfor i in range(1,5000):\n    JS.append(JS[-1]*i%mod)\nCs=lambda x,y:js(x)*inv(js(y))*inv(js(x-y))%mod\ninv =lambda x:pow(x,mod-2,mod)\njs=lambda x:JS[x]\n#while True:\nA,B,C=map(int,input().split())\nA-=1;B+=1;C+=1;\nans=0\nfor x in range(1,B+1):\n    for y in range(1,C+1):\n        ans+=Cs(A+B-x+C-y,A)*Cs(B-x+C-y,B-x)*pow(3,x-1+y-1,mod)%mod\n        ans%=mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "mod=int(1E9+7)\nJS=[1]\nfor i in range(1,4000):\n    JS.append(JS[-1]*i%mod)\nCs=lambda x,y:js(x)*inv(js(y))*inv(js(x-y))%mod\ninv =lambda x:pow(x,mod-2,mod)\njs=lambda x:JS[x]\n#while True:\nA,B,C=map(int,input().split())\nA-=1;B+=1;C+=1;\nans=0\nfor x in range(1,B+1):\n    for y in range(1,C+1):\n        ans+=Cs(A+B-x+C-y,A)*Cs(B-x+C-y,B-x)*pow(3,x-1+y-1,mod)%mod\n        ans%=mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN,M,K = map(int,input().split())\n\ndef cumprod(arr):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\nU = 10**6\nx = np.full(U,2,dtype=np.int64); x[0] = 1\npow2 = cumprod(x)\nx = np.full(U,3,dtype=np.int64); x[0] = 1\npow3 = cumprod(x)\nx = np.full(U,pow(2,MOD-2,MOD),dtype=np.int64); x[0] = 1\npow2_inv = cumprod(x)\nx = np.full(U,pow(3,MOD-2,MOD),dtype=np.int64); x[0] = 1\npow3_inv = cumprod(x)\nx = np.arange(U,dtype=np.int64); x[0] = 1\nfact = cumprod(x)\nx = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\nfact_inv = cumprod(x)[::-1]\n\nL = N+M\nA = np.zeros(N+M,dtype=np.int64)\nA[1:L] = (-1) * pow2[0:L-1] * pow3_inv[0:L-1] % MOD\nA[1:L] *= fact[K+1:K+L] * fact_inv[K] % MOD * fact_inv[1:L] % MOD; A %= MOD\nA[1:L] *= pow3_inv[K+1]; A %= MOD\nA[0] = 3 * (1 - pow3_inv[K+1]) % MOD * pow2_inv[1] % MOD\nnp.cumsum(A,out=A); A %= MOD\nA *= pow3[:L]; A %= MOD\nA *= pow2_inv[:L]; A %= MOD\n\ncomb = fact[N-1:N+M] * fact_inv[:M+1] % MOD * fact_inv[N-1] % MOD\nanswer = (comb * pow3[K+M:K-1:-1] % MOD * A[N-1:N+M] % MOD).sum() % MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nN,M,K = map(int,read().split())\n\nMOD = 10 ** 9 + 7\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\ndef make_power(a,L,MOD):\n    B = L.bit_length()\n    x = np.empty(1 + (1<<B),np.int64)\n    x[0] = 1; x[1] = a\n    for n in range(B):\n        x[1<<n:1<<(n+1)] = x[:1<<n] * (a * x[(1<<n)-1] % MOD) % MOD\n    return x[:L]\n\nU = 10 ** 6\npower2 = make_power(2,U,MOD)\npower2_inv = make_power(pow(2,MOD-2,MOD),U,MOD)\npower3 = make_power(3,U,MOD)\npower3_inv = make_power(pow(3,MOD-2,MOD),U,MOD)\nfact,fact_inv = make_fact(U,MOD)\n\nx = np.zeros(N+M,np.int64)\nx[1:] = (-1) * power2[:N+M-1] * power3_inv[K+1:N+M+K] % MOD\nx[1:] *= fact[K+1:N+M+K] * fact_inv[K] % MOD * fact_inv[1:N+M] % MOD\nx %= MOD\nx[0] = 3 * (1 - power3_inv[K+1]) % MOD * power2_inv[1] % MOD\nnp.cumsum(x, out=x); x %= MOD\nx *= power3[:N+M] * power2_inv[:N+M] % MOD; x %= MOD\n\ncoef = fact[N-1:N+M] * fact_inv[:M+1] % MOD * fact_inv[N-1] % MOD\ncoef *= power3[K:K+M+1][::-1]; coef %= MOD\nanswer = (coef * x[N-1:N+M] % MOD).sum() % MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "#include<iostream>\n#define MOD 1000000007\n#define N 1000\nusing namespace std;\ntypedef long long LL;\nLL mod_pow(LL base, LL exp)\n{\n\tif(exp==0) return 1;\n\tif(exp&1) return (mod_pow(base,exp-1)*base)%MOD;\n\telse return mod_pow((base*base)%MOD,exp/2);\n}\nLL fac[3*N+1];\nLL fac_inv[3*N+1];\nLL C(LL n, LL k)\n{\n\tif(k < 0 || n < k) return 0;\n\tLL num = fac[n];\n\tLL den = (fac_inv[n-k]*fac_inv[k])%MOD;\n\treturn (num*den)%MOD;\n}\nint main()\n{\n\tfac[0] = 1;\n\tfor(LL n = 1; n <= 3*N; n++)\n\t\tfac[n] = (fac[n-1]*n)%MOD;\n\tfac_inv[3*N] = mod_pow(fac[3*N],MOD-2);\n\tfor(LL n = 3*N-1; n >= 0; n--)\n\t\tfac_inv[n] = (fac_inv[n+1]*(n+1))%MOD;\n\n\tLL a, b, c; cin >> a >> b >> c;\n\ta++;\n\t//WLOG, b > c\n\tif(!(b>c))\n\t{\n\t\tb = b^c;\n\t\tc = b^c;\n\t\tb = b^c;\n\t}\n\n\tLL ans = 0;\n\tLL sum = 1;\n\tLL pull = 0;\n\tfor(LL n = a; n <= a+b+c; n++)\n\t{\n\t\tLL sub = 0;\n\t\t\n\t\tsub = (sub+sum-pull)%MOD;\n\t\tsub = (sub*C(n-2,a-2))%MOD;\n\t\tsub = (sub*mod_pow(3,a+b+c-n))%MOD;\n\t\tans = (ans+sub)%MOD;\n\n\t\tsum  = (2*sum-C(n-a,c))%MOD;\n\t\tpull = (2*pull+C(n-a,n-a-b))%MOD;\n\t}\n\tcout<<(ans+MOD)%MOD<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "Rust",
    "code": "use std::str::FromStr;\nuse std::io::*;\nuse std::cmp::*;\nuse utils::*;\n\npub fn main() {\n    let i = stdin();\n    let mut o = Vec::new();\n    run(i.lock(), &mut o);\n    stdout().write_all(&o).unwrap();\n}\n\nfn run<R: BufRead, W: Write>(i: R, o: &mut W) {\n    let mut i = AtRead::from(i);\n    let nmk = i.read3::<usize, usize, usize>();\n    writeln!(o, \"{}\", solve(nmk)).unwrap();\n}\nfn solve(n: (usize, usize, usize)) -> usize {\n    let mut pows = Vec::new();\n    let mut p = ModInt(1);\n    for _ in 0..n.1 + n.2 + 1 {\n        pows.push(p);\n        p *= 3;\n    }\n\n    let n_sum = n.0 + n.1 + n.2;\n    let facts = ModIntFacts::new(n_sum - 1);\n    let mut result = ModInt(0);\n    for i012 in n.0 - 1..n_sum {\n        let i12 = i012 - (n.0 - 1);\n        let mut c = ModInt(0);\n        for i1 in 0..min(n.1, i12) + 1 {\n            let i2 = i12 - i1;\n            if i2 > n.2 {\n                continue;\n            }\n            c += facts.comb(i12, i1);\n        }\n        c *= facts.comb(i012, n.0 - 1);\n        c *= pows[n_sum - 1 - i012];\n        result += c;\n    }\n    result.0\n}\n\nmod utils {\n    #![allow(dead_code)]\n    use super::*;\n    use std::ops::*;\n\n    pub struct AtRead<R: BufRead> {\n        r: R,\n        s: String,\n    }\n\n    macro_rules! fn_read {\n        {$f:ident($($v:ident: $t:ident),*)} => {\n            pub fn $f<$($t: FromStr),*>(&mut self) -> ($($t),*) {\n                let i = &mut self.read_line().split(' ');\n                $(\n                    let $v = next(i);\n                )*\n                ($($v),*)\n            }\n        };\n    }\n\n    impl<R: BufRead> AtRead<R> {\n        pub fn from(r: R) -> Self {\n            AtRead {\n                r: r,\n                s: String::new(),\n            }\n        }\n        pub fn read_line(&mut self) -> &str {\n            self.s.clear();\n            self.r.read_line(&mut self.s).unwrap();\n            self.s.trim()\n        }\n\n        pub fn read<T: FromStr>(&mut self) -> T {\n            self.read_line().parse().ok().unwrap()\n        }\n        fn_read! { read2(v1: T1, v2: T2) }\n        fn_read! { read3(v1: T1, v2: T2, v3: T3) }\n        fn_read! { read4(v1: T1, v2: T2, v3: T3, v4: T4) }\n\n        pub fn read_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n            self.read_line()\n                .split(' ')\n                .take(n)\n                .map(|x| x.parse().ok().unwrap())\n                .collect()\n        }\n    }\n\n    fn next<'a, T: FromStr, I: std::iter::Iterator<Item = &'a str>>(i: &mut I) -> T {\n        i.next().unwrap().parse().ok().unwrap()\n    }\n\n    #[derive(Debug, Clone, Copy)]\n    pub struct ModInt(pub usize);\n\n    const MOD_BASE: usize = 1000000007;\n    const MOD_INV_POW: usize = 1000000005;\n\n    impl ModInt {\n        pub fn new(n: usize) -> Self {\n            ModInt(n % MOD_BASE)\n        }\n        pub fn pow(self, mut exp: usize) -> Self {\n            let mut b = self;\n            let mut r = ModInt(1);\n            while exp != 0 {\n                if exp % 2 == 1 {\n                    r *= b;\n                }\n                exp /= 2;\n                b = b * b;\n            }\n            r\n        }\n        pub fn inverse_element(self) -> Self {\n            self.pow(MOD_INV_POW)\n        }\n    }\n\n    macro_rules! ModInt_op {\n        (($ot:ident, $f:ident), ($ot_a:ident, $f_a:ident), $($rhs:ty, $e:expr,)*) => {\n            $(\n            impl $ot<$rhs> for ModInt {\n                type Output = Self;\n                fn $f(self, rhs: $rhs) -> Self {\n                    Self::new(($e)(self, rhs))\n                }\n            }\n            impl $ot_a<$rhs> for ModInt {\n                fn $f_a(&mut self, rhs: $rhs) {\n                    *self = Self::new(($e)(*self, rhs))\n                }\n            }\n            )*\n        }\n    }\n\n    ModInt_op!(\n        (Add, add),\n        (AddAssign, add_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 + r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 + r,\n    );\n\n    ModInt_op!(\n        (Mul, mul),\n        (MulAssign, mul_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 * r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 * r,\n    );\n\n    ModInt_op!(\n        (Sub, sub),\n        (SubAssign, sub_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| MOD_BASE + l.0 - r.0,\n        usize,\n        |l: ModInt, r: usize| MOD_BASE + l.0 - r,\n    );\n\n    // std::cmp::Reverseと同じ\n    #[derive(PartialEq, Eq)]\n    pub struct RevCmp<T>(pub T);\n\n    impl<T: PartialOrd> PartialOrd for RevCmp<T> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            other.0.partial_cmp(&self.0)\n        }\n    }\n    impl<T: Ord> Ord for RevCmp<T> {\n        fn cmp(&self, other: &Self) -> Ordering {\n            other.0.cmp(&self.0)\n        }\n    }\n\n    pub struct PascalsTriangle<T> {\n        buf: Vec<T>,\n        n: usize,\n    }\n\n    impl<T: One> PascalsTriangle<T> {\n        pub fn new() -> Self {\n            PascalsTriangle {\n                buf: vec![T::one()],\n                n: 1,\n            }\n        }\n        pub fn get(&mut self, n: usize, m: usize) -> T {\n            assert!(m <= n);\n            self.ready(n);\n            self.buf[n * (n + 1) / 2 + m]\n        }\n\n        pub fn ready(&mut self, n: usize) {\n            while self.n <= n {\n                let i = self.buf.len() - self.n;\n                self.buf.push(T::one());\n                for m in 1..self.n {\n                    let v = self.buf[i + m - 1] + self.buf[i + m];\n                    self.buf.push(v);\n                }\n                self.buf.push(T::one());\n                self.n += 1;\n            }\n        }\n    }\n\n    pub struct PascalsTriangleIter<T> {\n        buf: Vec<T>,\n    }\n    impl<T: One> PascalsTriangleIter<T> {\n        pub fn new(n: usize) -> Self {\n            let mut s = PascalsTriangleIter {\n                buf: vec![T::one()],\n            };\n            for _ in 0..n {\n                s.next();\n            }\n            s\n        }\n        pub fn next(&mut self) -> &[T] {\n            for i in (1..self.buf.len()).rev() {\n                self.buf[i] = self.buf[i] + self.buf[i - 1];\n            }\n            self.buf.push(T::one());\n            self.get()\n        }\n        pub fn get(&self) -> &[T] {\n            &self.buf\n        }\n    }\n\n    pub struct ModIntFacts {\n        f: Vec<ModInt>,\n        rf: Vec<ModInt>,\n    }\n    impl ModIntFacts {\n        pub fn new(n: usize) -> Self {\n            let mut s = ModIntFacts {\n                f: vec![ModInt(0); n + 1],\n                rf: vec![ModInt(0); n + 1],\n            };\n\n            let v = ModInt(1);\n            s.f[0] = v;\n            for i in 1..n + 1 {\n                s.f[i] = s.f[i - 1] * i;\n            }\n            s.rf[n] = s.f[n].inverse_element();\n            for i in (1..n + 1).rev() {\n                s.rf[i - 1] = s.rf[i] * i;\n            }\n            s\n        }\n        pub fn fact(&self, n: usize) -> ModInt {\n            self.f[n]\n        }\n        pub fn comb(&self, n: usize, c: usize) -> ModInt {\n            self.f[n] * self.rf[c] * self.rf[n - c]\n        }\n    }\n\n    pub trait Zero: Add<Output = Self> + Sized + Copy {\n        fn zero() -> Self;\n    }\n    pub trait One: Zero {\n        fn one() -> Self;\n    }\n\n    macro_rules! impl_zero {\n        ($t:ty, $e:expr) => {\n            impl Zero for $t {\n                fn zero() -> Self {\n                    $e\n                }\n            }\n        }\n    }\n    macro_rules! impl_one {\n        ($t:ty, $e1:expr, $e0:expr) => {\n            impl One for $t {\n                fn one() -> Self {\n                    $e1\n                }\n            }\n            impl_zero!($t, $e0);\n        }\n    }\n\n    impl_one!(usize, 1, 0);\n    impl_one!(u32, 1, 0);\n    impl_one!(i32, 1, 0);\n    impl_one!(f64, 1.0, 0.0);\n    impl_one!(ModInt, ModInt(1), ModInt(0));\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nconst MOD: i64 = 1000000007;\n\nfn powmod(a: i64, p: i64, m: i64) -> i64 {\n    let mut ret = 1i64;\n    let mut aa = a;\n    let mut pp = p;\n    while pp >= 1 {\n        if pp & 1 == 1 {\n            ret *= aa;\n            ret %= m;\n        }\n        aa = aa * aa % m;\n        pp >>= 1;\n    }\n    ret\n}\n\nfn inv(a: i64, m: i64) -> i64 {\n    powmod(a, m-2, m)\n}\n\nstruct Combination {\n    fact: Vec<i64>,\n    invfact: Vec<i64>,\n    modulo: i64\n}\n\nimpl Combination {\n    fn new(n: usize, modulo: i64) -> Self {\n        let mut fact: Vec<i64> = vec![0; n];\n        let mut invfact: Vec<i64> = vec![0; n];\n        fact[0] = 1;\n        for i in 1..n {\n            fact[i] = fact[i-1] * i as i64 % modulo;\n        }\n        invfact[n-1] = inv(fact[n-1], modulo);\n        for i in (0..n-1).rev() {\n            invfact[i] = (invfact[i+1] * (i+1) as i64) % modulo;\n        }\n\n        Combination { fact: fact, invfact: invfact, modulo: modulo }\n    }\n\n    fn combination(&self, n: usize, k: usize) -> i64 {\n        if n < k {\n            return 0;\n        }\n        self.fact[n] * self.invfact[n-k] % self.modulo * self.invfact[k] % self.modulo\n    }\n}\n\n\nfn main() {\n    let (n, m, k): (usize, usize, usize) = read();\n    let (m, k) = (min(m, k), max(m, k));\n\n    let l = n + m + k;\n    let comb = Combination::new(l + 10, MOD);\n\n    let mut pow3: Vec<i64> = vec![0; l + 10];\n    pow3[0] = 1;\n    for i in 1..l+10 {\n        pow3[i] = (pow3[i-1] * 3) % MOD;\n    }\n\n\n    let mut ans = 0;\n\n    let mut mul = 1;\n    let mut lid = 0;\n    let mut rid = 0;\n    for xl in n..l+1 {\n        let left = xl - n;\n        let right = l - xl;\n\n        if left == 0 {\n        } else if left <= m {\n            mul = (mul * 2) % MOD;\n        } else if left <= k {\n            mul = (mul * 2 - comb.combination(left-1, lid) + MOD) % MOD;\n            lid += 1;\n        } else {\n            mul = (mul * 2 - comb.combination(left-1, lid) - comb.combination(left-1, rid) + MOD + MOD) % MOD;\n            lid += 1;\n            rid += 1;\n        }\n\n        ans += comb.combination(xl-1, n-1) * mul % MOD * pow3[right] % MOD;\n        ans %= MOD;\n    }\n\n    println!(\"{}\", ans);\n}"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\n//https://github.com/kenkoooo/competitive-programming-rs/blob/master/src/math/mod_int.rs\n//を参考にしています\n#[allow(dead_code)]\nmod modint {\n    pub const MOD: u32 = 1_000_000_007;\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n    type Num = u32;\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, other: ModInt<Num>) -> ModInt<Num> {\n            let mut d = self.0 + other.0;\n            if d >= MOD {\n                d -= MOD;\n            }\n            ModInt(d)\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, other: ModInt<Num>) -> ModInt<Num> {\n            let mut d = self.0 + MOD - other.0;\n            if d >= MOD {\n                d -= MOD;\n            }\n            ModInt(d)\n        }\n    }\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn mul(self, other: ModInt<Num>) -> ModInt<Num> {\n            ModInt(((self.0 as u64) * (other.0 as u64) % (MOD as u64)) as u32)\n        }\n    }\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, other: ModInt<Num>) {\n            *self = *self * other;\n        }\n    }\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, other: ModInt<Num>) -> ModInt<Num> {\n            self * other.pow(MOD - 2)\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, other: ModInt<Num>) {\n            *self = *self / other;\n        }\n    }\n    impl Neg for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn neg(self) -> ModInt<Num> {\n            ModInt(if self.0 == 0 { 0 } else { MOD - self.0 })\n        }\n    }\n    impl ModInt<Num> {\n        pub fn new(v: u32) -> ModInt<Num> {\n            ModInt(v % MOD)\n        }\n        pub fn pow(self, mut n: u32) -> ModInt<Num> {\n            let mut t = ModInt::new(1);\n            let mut s = self;\n            while n > 0 {\n                if (n & 1) == 1 {\n                    t *= s;\n                }\n                s *= s;\n                n >>= 1;\n            }\n            t\n        }\n    }\n    pub struct Precalc {\n        n: usize,\n        inv: Vec<ModInt<Num>>,\n        fact: Vec<ModInt<Num>>,\n        ifact: Vec<ModInt<Num>>,\n    }\n    impl Precalc {\n        pub fn new(n: usize) -> Precalc {\n            let mut inv = vec![ModInt(1); n + 1];\n            let mut fact = vec![ModInt(1); n + 1];\n            let mut ifact = vec![ModInt(1); n + 1];\n            for i in 1..(n + 1) {\n                if i >= 2 {\n                    inv[i] = -inv[(MOD as usize) % i] * ModInt(MOD / (i as u32));\n                }\n                fact[i] = ModInt(i as u32) * fact[i - 1];\n                ifact[i] = inv[i] * ifact[i - 1];\n            }\n            Precalc {\n                n: n,\n                inv: inv,\n                fact: fact,\n                ifact: ifact,\n            }\n        }\n        pub fn fact(&self, n: usize) -> ModInt<Num> {\n            self.fact[n]\n        }\n        pub fn inv(&self, x: usize) -> ModInt<Num> {\n            self.inv[x]\n        }\n        pub fn ifact(&self, x: usize) -> ModInt<Num> {\n            self.ifact[x]\n        }\n        pub fn comb(&self, n: usize, k: usize) -> ModInt<Num> {\n            if !(k <= n) {\n                return ModInt(0);\n            }\n            self.fact[n] * self.ifact[k] * self.ifact[n - k]\n        }\n    }\n    use std;\n    impl std::fmt::Display for ModInt<Num> {\n        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n}\n// ---------- end ModInt ----------\n\nuse modint::*;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let m: usize = it.next().unwrap().parse().unwrap();\n    let k: usize = it.next().unwrap().parse().unwrap();\n    assert!(n <= 1000 && m <= 1000 && k <= 1000);\n    let mut ans = ModInt(0);\n    let pc = Precalc::new(n + m + k);\n    for x in 0..(m + 1) {\n        for y in 0..(k + 1) {\n            ans += pc.fact(n - 1 + x + y) * pc.ifact(n - 1) * pc.ifact(x) * pc.ifact(y) * ModInt(3).pow((m + k - x - y) as u32);\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::str::FromStr;\nuse std::io::*;\nuse std::cmp::*;\nuse utils::*;\n\npub fn main() {\n    let i = stdin();\n    let mut o = Vec::new();\n    run(i.lock(), &mut o);\n    stdout().write_all(&o).unwrap();\n}\n\nfn run<R: BufRead, W: Write>(i: R, o: &mut W) {\n    let mut i = AtRead::from(i);\n    let nmk = i.read3::<usize, usize, usize>();\n    writeln!(o, \"{}\", solve(nmk)).unwrap();\n}\nfn solve(n: (usize, usize, usize)) -> usize {\n    let mut pows = Vec::new();\n    let mut p = ModInt(1);\n    for _ in 0..n.1 + n.2 + 1 {\n        pows.push(p);\n        p *= 3;\n    }\n\n    let mut comb = Combination::<ModInt>::new();\n\n    let n_sum = n.0 + n.1 + n.2;\n    let mut result = ModInt(0);\n    for i012 in n.0 - 1..n_sum {\n        let i12 = i012 - (n.0 - 1);\n        let mut c = ModInt(0);\n        for i1 in 0..min(n.1, i12) + 1 {\n            let i2 = i12 - i1;\n            if i2 > n.2 {\n                continue;\n            }\n            c += comb.get(i12, i1);\n        }\n        c *= comb.get(i012, n.0 - 1);\n        c *= pows[n_sum - 1 - i012];\n        result += c;\n    }\n    result.0\n}\n\nmod utils {\n    #![allow(dead_code)]\n    use super::*;\n    use std::ops::*;\n\n    pub struct AtRead<R: BufRead> {\n        r: R,\n        s: String,\n    }\n\n    macro_rules! fn_read {\n        {$f:ident($($v:ident: $t:ident),*)} => {\n            pub fn $f<$($t: FromStr),*>(&mut self) -> ($($t),*) {\n                let i = &mut self.read_line().split(' ');\n                $(\n                    let $v = next(i);\n                )*\n                ($($v),*)\n            }\n        };\n    }\n\n    impl<R: BufRead> AtRead<R> {\n        pub fn from(r: R) -> Self {\n            AtRead {\n                r: r,\n                s: String::new(),\n            }\n        }\n        pub fn read_line(&mut self) -> &str {\n            self.s.clear();\n            self.r.read_line(&mut self.s).unwrap();\n            self.s.trim()\n        }\n\n        pub fn read<T: FromStr>(&mut self) -> T {\n            self.read_line().parse().ok().unwrap()\n        }\n        fn_read! { read2(v1: T1, v2: T2) }\n        fn_read! { read3(v1: T1, v2: T2, v3: T3) }\n        fn_read! { read4(v1: T1, v2: T2, v3: T3, v4: T4) }\n\n        pub fn read_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n            self.read_line()\n                .split(' ')\n                .take(n)\n                .map(|x| x.parse().ok().unwrap())\n                .collect()\n        }\n    }\n\n    fn next<'a, T: FromStr, I: std::iter::Iterator<Item = &'a str>>(i: &mut I) -> T {\n        i.next().unwrap().parse().ok().unwrap()\n    }\n\n    #[derive(Debug, Clone, Copy)]\n    pub struct ModInt(pub usize);\n\n    const MOD_BASE: usize = 1000000007;\n    const MOD_INV_POW: usize = 1000000005;\n\n    impl ModInt {\n        pub fn new(n: usize) -> Self {\n            ModInt(n % MOD_BASE)\n        }\n        pub fn pow(self, mut exp: usize) -> ModInt {\n            let mut b = self;\n            let mut r = ModInt(1);\n            while exp != 0 {\n                if exp % 2 == 1 {\n                    r *= b;\n                }\n                exp /= 2;\n                b = b * b;\n            }\n            r\n        }\n        pub fn inverse_element(self) -> ModInt {\n            self.pow(MOD_INV_POW)\n        }\n    }\n\n    macro_rules! ModInt_op {\n        (($ot:ident, $f:ident), ($ot_a:ident, $f_a:ident), $($rhs:ty, $e:expr,)*) => {\n            $(\n            impl $ot<$rhs> for ModInt {\n                type Output = Self;\n                fn $f(self, rhs: $rhs) -> Self {\n                    Self::new(($e)(self, rhs))\n                }\n            }\n            impl $ot_a<$rhs> for ModInt {\n                fn $f_a(&mut self, rhs: $rhs) {\n                    *self = Self::new(($e)(*self, rhs))\n                }\n            }\n            )*\n        }\n    }\n\n    ModInt_op!(\n        (Add, add),\n        (AddAssign, add_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 + r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 + r,\n    );\n\n    ModInt_op!(\n        (Mul, mul),\n        (MulAssign, mul_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 * r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 * r,\n    );\n\n    ModInt_op!(\n        (Sub, sub),\n        (SubAssign, sub_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| MOD_BASE + l.0 - r.0,\n        usize,\n        |l: ModInt, r: usize| MOD_BASE + l.0 - r,\n    );\n\n    // std::cmp::Reverseと同じ\n    #[derive(PartialEq, Eq)]\n    pub struct RevCmp<T>(pub T);\n\n    impl<T: PartialOrd> PartialOrd for RevCmp<T> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            other.0.partial_cmp(&self.0)\n        }\n    }\n    impl<T: Ord> Ord for RevCmp<T> {\n        fn cmp(&self, other: &Self) -> Ordering {\n            other.0.cmp(&self.0)\n        }\n    }\n\n    /// パスカルの三角形による組み合わせ数の計算\n    pub struct Combination<T> {\n        buf: Vec<T>,\n        n: usize,\n    }\n\n    impl<T: One> Combination<T> {\n        pub fn new() -> Self {\n            Combination {\n                buf: vec![T::one()],\n                n: 1,\n            }\n        }\n        pub fn get(&mut self, n: usize, m: usize) -> T {\n            assert!(m <= n);\n            self.ready(n);\n            self.buf[n * (n + 1) / 2 + m]\n        }\n\n        pub fn ready(&mut self, n: usize) {\n            while self.n <= n {\n                let i = self.buf.len() - self.n;\n                self.buf.push(T::one());\n                for m in 1..self.n {\n                    let v = self.buf[i + m - 1] + self.buf[i + m];\n                    self.buf.push(v);\n                }\n                self.buf.push(T::one());\n                self.n += 1;\n            }\n        }\n    }\n\n    pub trait Zero: Add<Output = Self> + Sized + Copy {\n        fn zero() -> Self;\n    }\n    pub trait One: Zero {\n        fn one() -> Self;\n    }\n\n    macro_rules! impl_zero {\n        ($t:ty, $e:expr) => {\n            impl Zero for $t {\n                fn zero() -> Self {\n                    $e\n                }\n            }\n        }\n    }\n    macro_rules! impl_one {\n        ($t:ty, $e1:expr, $e0:expr) => {\n            impl One for $t {\n                fn one() -> Self {\n                    $e1\n                }\n            }\n            impl_zero!($t, $e0);\n        }\n    }\n\n    impl_one!(usize, 1, 0);\n    impl_one!(u32, 1, 0);\n    impl_one!(i32, 1, 0);\n    impl_one!(f64, 1.0, 0.0);\n    impl_one!(ModInt, ModInt(1), ModInt(0));\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::str::FromStr;\nuse std::io::*;\nuse std::cmp::*;\nuse utils::*;\n\npub fn main() {\n    let i = stdin();\n    let mut o = Vec::new();\n    run(i.lock(), &mut o);\n    stdout().write_all(&o).unwrap();\n}\n\nfn run<R: BufRead, W: Write>(i: R, o: &mut W) {\n    let mut i = AtRead::from(i);\n    let nmk = i.read3::<usize, usize, usize>();\n    writeln!(o, \"{}\", solve(nmk)).unwrap();\n}\nfn solve(n: (usize, usize, usize)) -> usize {\n    let mut pows = Vec::new();\n    let mut p = ModInt(1);\n    for _ in 0..n.1 + n.2 + 1 {\n        pows.push(p);\n        p *= 3;\n    }\n\n    let n0_ex = n.0 - 1;\n    let n12 = n.1 + n.2;\n    let facts = ModIntFacts::new(n0_ex + n12);\n    let mut result = ModInt(0);\n    let mut c = ModInt(1);\n\n    for i12 in 0..n12 + 1 {\n        let c0 = c * facts.comb(n0_ex + i12, n0_ex) * pows[n12 - i12];\n        result += c0;\n        c *= 2;\n        if i12 >= n.1 {\n            c -= facts.comb(i12, i12 - n.1);\n        }\n        if i12 >= n.2 {\n            c -= facts.comb(i12, i12 - n.2);\n        }\n    }\n\n    result.0\n}\n\nmod utils {\n    #![allow(dead_code)]\n    use super::*;\n    use std::ops::*;\n\n    pub struct AtRead<R: BufRead> {\n        r: R,\n        s: String,\n    }\n\n    macro_rules! fn_read {\n        {$f:ident($($v:ident: $t:ident),*)} => {\n            pub fn $f<$($t: FromStr),*>(&mut self) -> ($($t),*) {\n                let i = &mut self.read_line().split(' ');\n                $(\n                    let $v = next(i);\n                )*\n                ($($v),*)\n            }\n        };\n    }\n\n    impl<R: BufRead> AtRead<R> {\n        pub fn from(r: R) -> Self {\n            AtRead {\n                r: r,\n                s: String::new(),\n            }\n        }\n        pub fn read_line(&mut self) -> &str {\n            self.s.clear();\n            self.r.read_line(&mut self.s).unwrap();\n            self.s.trim()\n        }\n\n        pub fn read<T: FromStr>(&mut self) -> T {\n            self.read_line().parse().ok().unwrap()\n        }\n        fn_read! { read2(v1: T1, v2: T2) }\n        fn_read! { read3(v1: T1, v2: T2, v3: T3) }\n        fn_read! { read4(v1: T1, v2: T2, v3: T3, v4: T4) }\n\n        pub fn read_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n            self.read_line()\n                .split(' ')\n                .take(n)\n                .map(|x| x.parse().ok().unwrap())\n                .collect()\n        }\n    }\n\n    fn next<'a, T: FromStr, I: std::iter::Iterator<Item = &'a str>>(i: &mut I) -> T {\n        i.next().unwrap().parse().ok().unwrap()\n    }\n\n    #[derive(Debug, Clone, Copy)]\n    pub struct ModInt(pub usize);\n\n    const MOD_BASE: usize = 1000000007;\n    const MOD_INV_POW: usize = 1000000005;\n\n    impl ModInt {\n        pub fn new(n: usize) -> Self {\n            ModInt(n % MOD_BASE)\n        }\n        pub fn pow(self, mut exp: usize) -> Self {\n            let mut b = self;\n            let mut r = ModInt(1);\n            while exp != 0 {\n                if exp % 2 == 1 {\n                    r *= b;\n                }\n                exp /= 2;\n                b = b * b;\n            }\n            r\n        }\n        pub fn inverse_element(self) -> Self {\n            self.pow(MOD_INV_POW)\n        }\n    }\n\n    macro_rules! ModInt_op {\n        (($ot:ident, $f:ident), ($ot_a:ident, $f_a:ident), $($rhs:ty, $e:expr,)*) => {\n            $(\n            impl $ot<$rhs> for ModInt {\n                type Output = Self;\n                fn $f(self, rhs: $rhs) -> Self {\n                    Self::new(($e)(self, rhs))\n                }\n            }\n            impl $ot_a<$rhs> for ModInt {\n                fn $f_a(&mut self, rhs: $rhs) {\n                    *self = Self::new(($e)(*self, rhs))\n                }\n            }\n            )*\n        }\n    }\n\n    ModInt_op!(\n        (Add, add),\n        (AddAssign, add_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 + r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 + r,\n    );\n\n    ModInt_op!(\n        (Mul, mul),\n        (MulAssign, mul_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 * r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 * r,\n    );\n\n    ModInt_op!(\n        (Sub, sub),\n        (SubAssign, sub_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| MOD_BASE + l.0 - r.0,\n        usize,\n        |l: ModInt, r: usize| MOD_BASE + l.0 - r,\n    );\n\n    // std::cmp::Reverseと同じ\n    #[derive(PartialEq, Eq)]\n    pub struct RevCmp<T>(pub T);\n\n    impl<T: PartialOrd> PartialOrd for RevCmp<T> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            other.0.partial_cmp(&self.0)\n        }\n    }\n    impl<T: Ord> Ord for RevCmp<T> {\n        fn cmp(&self, other: &Self) -> Ordering {\n            other.0.cmp(&self.0)\n        }\n    }\n\n    pub struct PascalsTriangle<T> {\n        buf: Vec<T>,\n        n: usize,\n    }\n\n    impl<T: One> PascalsTriangle<T> {\n        pub fn new() -> Self {\n            PascalsTriangle {\n                buf: vec![T::one()],\n                n: 1,\n            }\n        }\n        pub fn get(&mut self, n: usize, m: usize) -> T {\n            assert!(m <= n);\n            self.ready(n);\n            self.buf[n * (n + 1) / 2 + m]\n        }\n\n        pub fn ready(&mut self, n: usize) {\n            while self.n <= n {\n                let i = self.buf.len() - self.n;\n                self.buf.push(T::one());\n                for m in 1..self.n {\n                    let v = self.buf[i + m - 1] + self.buf[i + m];\n                    self.buf.push(v);\n                }\n                self.buf.push(T::one());\n                self.n += 1;\n            }\n        }\n    }\n\n    pub struct PascalsTriangleIter<T> {\n        buf: Vec<T>,\n    }\n    impl<T: One> PascalsTriangleIter<T> {\n        pub fn new(n: usize) -> Self {\n            let mut s = PascalsTriangleIter {\n                buf: vec![T::one()],\n            };\n            for _ in 0..n {\n                s.next();\n            }\n            s\n        }\n        pub fn next(&mut self) -> &[T] {\n            for i in (1..self.buf.len()).rev() {\n                self.buf[i] = self.buf[i] + self.buf[i - 1];\n            }\n            self.buf.push(T::one());\n            self.get()\n        }\n        pub fn get(&self) -> &[T] {\n            &self.buf\n        }\n    }\n\n    pub struct ModIntFacts {\n        f: Vec<ModInt>,\n        rf: Vec<ModInt>,\n    }\n    impl ModIntFacts {\n        pub fn new(n: usize) -> Self {\n            let mut s = ModIntFacts {\n                f: vec![ModInt(0); n + 1],\n                rf: vec![ModInt(0); n + 1],\n            };\n\n            let v = ModInt(1);\n            s.f[0] = v;\n            for i in 1..n + 1 {\n                s.f[i] = s.f[i - 1] * i;\n            }\n            s.rf[n] = s.f[n].inverse_element();\n            for i in (1..n + 1).rev() {\n                s.rf[i - 1] = s.rf[i] * i;\n            }\n            s\n        }\n        pub fn fact(&self, n: usize) -> ModInt {\n            self.f[n]\n        }\n        pub fn comb(&self, n: usize, c: usize) -> ModInt {\n            self.f[n] * self.rf[c] * self.rf[n - c]\n        }\n    }\n\n    pub trait Zero: Add<Output = Self> + Sized + Copy {\n        fn zero() -> Self;\n    }\n    pub trait One: Zero {\n        fn one() -> Self;\n    }\n\n    macro_rules! impl_zero {\n        ($t:ty, $e:expr) => {\n            impl Zero for $t {\n                fn zero() -> Self {\n                    $e\n                }\n            }\n        }\n    }\n    macro_rules! impl_one {\n        ($t:ty, $e1:expr, $e0:expr) => {\n            impl One for $t {\n                fn one() -> Self {\n                    $e1\n                }\n            }\n            impl_zero!($t, $e0);\n        }\n    }\n\n    impl_one!(usize, 1, 0);\n    impl_one!(u32, 1, 0);\n    impl_one!(i32, 1, 0);\n    impl_one!(f64, 1.0, 0.0);\n    impl_one!(ModInt, ModInt(1), ModInt(0));\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nfn main() {\n    input!{\n        n: usize,\n        m: usize,\n        k: usize\n    }\n    let d = 1000000007;\n    let mut st = vec![0; n + m + k];\n    st[0] = 1;\n    for i in 1..n + m + k {\n        st[i] = st[i - 1] * i % d;\n    }\n    let sti: Vec<usize> = st.iter().cloned().map(|x| inv_m(x, d)).collect();\n    let mut pow3 = vec![0; m + k + 1];\n    pow3[0] = 1;\n    for i in 0..m + k {\n        pow3[i + 1] = pow3[i] * 3 % d;\n    }\n    let m1 = min(m, k);\n    let k1 = max(m, k);\n    let mut ans = pow3[m + k];\n    let mut s = 1;\n    for i in 1..m + k + 1 {\n        if i <= m1 {\n            s = s * 2 % d;\n        } else if i <= k1 {\n            s = (s * 2 + d - st[i - 1] * sti[i - 1 - m1] % d * sti[m1] % d) % d;\n        } else {\n            s = (s * 2 + 2 * d - st[i - 1] * sti[i - 1 - m1] % d * sti[m1] % d - st[i - 1] * sti[i - 1 - k1] % d * sti[k1] % d) % d;\n        }\n        ans = (ans + st[i + n - 1] * sti[n - 1] % d * sti[i] % d * pow3[m + k - i] % d * s) % d;\n    }\n    println!(\"{}\", ans);\n}\n\nfn pow_m(n: usize, mut p: usize, d: usize) -> usize {\n    let mut r = n;\n    let mut ret = 1;\n    while p > 0 {\n        if p % 2 == 0 {\n            r = r * r % d;\n            p /= 2;\n        } else {\n            ret = ret * r % d;\n            p -= 1;\n        }\n    }\n    ret\n}\n\nfn inv_m(n: usize, d: usize) -> usize {\n    pow_m(n, d - 2, d)\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\n//https://github.com/kenkoooo/competitive-programming-rs/blob/master/src/math/mod_int.rs\n//を参考にしています\n#[allow(dead_code)]\nmod modint {\n    pub const MOD: u32 = 1_000_000_007;\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n    type Num = u32;\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, other: ModInt<Num>) -> ModInt<Num> {\n            let mut d = self.0 + other.0;\n            if d >= MOD {\n                d -= MOD;\n            }\n            ModInt(d)\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, other: ModInt<Num>) -> ModInt<Num> {\n            let mut d = self.0 + MOD - other.0;\n            if d >= MOD {\n                d -= MOD;\n            }\n            ModInt(d)\n        }\n    }\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn mul(self, other: ModInt<Num>) -> ModInt<Num> {\n            ModInt(((self.0 as u64) * (other.0 as u64) % (MOD as u64)) as u32)\n        }\n    }\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, other: ModInt<Num>) {\n            *self = *self * other;\n        }\n    }\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, other: ModInt<Num>) -> ModInt<Num> {\n            self * other.pow(MOD - 2)\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, other: ModInt<Num>) {\n            *self = *self / other;\n        }\n    }\n    impl Neg for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn neg(self) -> ModInt<Num> {\n            ModInt(if self.0 == 0 { 0 } else { MOD - self.0 })\n        }\n    }\n    impl ModInt<Num> {\n        pub fn new(v: u32) -> ModInt<Num> {\n            ModInt(v % MOD)\n        }\n        pub fn pow(self, mut n: u32) -> ModInt<Num> {\n            let mut t = ModInt::new(1);\n            let mut s = self;\n            while n > 0 {\n                if (n & 1) == 1 {\n                    t *= s;\n                }\n                s *= s;\n                n >>= 1;\n            }\n            t\n        }\n    }\n    pub struct Precalc {\n        n: usize,\n        inv: Vec<ModInt<Num>>,\n        fact: Vec<ModInt<Num>>,\n        ifact: Vec<ModInt<Num>>,\n    }\n    impl Precalc {\n        pub fn new(n: usize) -> Precalc {\n            let mut inv = vec![ModInt(1); n + 1];\n            let mut fact = vec![ModInt(1); n + 1];\n            let mut ifact = vec![ModInt(1); n + 1];\n            for i in 1..(n + 1) {\n                if i >= 2 {\n                    inv[i] = -inv[(MOD as usize) % i] * ModInt(MOD / (i as u32));\n                }\n                fact[i] = ModInt(i as u32) * fact[i - 1];\n                ifact[i] = inv[i] * ifact[i - 1];\n            }\n            Precalc {\n                n: n,\n                inv: inv,\n                fact: fact,\n                ifact: ifact,\n            }\n        }\n        pub fn fact(&self, n: usize) -> ModInt<Num> {\n            self.fact[n]\n        }\n        pub fn inv(&self, x: usize) -> ModInt<Num> {\n            self.inv[x]\n        }\n        pub fn ifact(&self, x: usize) -> ModInt<Num> {\n            self.ifact[x]\n        }\n        pub fn comb(&self, n: usize, k: usize) -> ModInt<Num> {\n            if !(k <= n) {\n                return ModInt(0);\n            }\n            self.fact[n] * self.ifact[k] * self.ifact[n - k]\n        }\n    }\n    use std;\n    impl std::fmt::Display for ModInt<Num> {\n        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n}\n// ---------- end ModInt ----------\n\nuse modint::*;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let m: usize = it.next().unwrap().parse().unwrap();\n    let k: usize = it.next().unwrap().parse().unwrap();\n    let pc = Precalc::new(n + m + k);\n    let mut ans = ModInt(0);\n    let mut sub = ModInt(0);\n    for z in 0..(m + k + 1) {\n        sub *= ModInt(2);\n        if z > m {\n            sub += pc.comb(z - 1, m);\n        }\n        if z > k {\n            sub += pc.comb(z - 1, k);\n        }\n        ans += pc.comb(n - 1 + z, z) * ModInt(3).pow((m + k - z) as u32) * (ModInt(2).pow(z as u32) - sub);\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nfn main() {\n    input!{\n        n: usize,\n        m: usize,\n        k: usize\n    }\n    let d = 1000000007;\n    let mut st = vec![0; n + m + k];\n    st[0] = 1;\n    for i in 1..n + m + k {\n        st[i] = st[i - 1] * i % d;\n    }\n    let sti: Vec<usize> = st.iter().cloned().map(|x| inv_m(x, d)).collect();\n    let mut pow3 = vec![0; m + k + 1];\n    pow3[0] = 1;\n    for i in 0..m + k {\n        pow3[i + 1] = pow3[i] * 3 % d;\n    }\n    let m1 = min(m, k);\n    let k1 = max(m, k);\n    let mut ans = pow3[m + k];\n    let mut s = 1;\n    for i in 1..m + k + 1 {\n        if i <= m1 {\n            s = s * 2 % d;\n        } else if i <= k1 {\n            s = (s * 2 + d - st[i - 1] * sti[i - 1 - m] % d * sti[m] % d) % d;\n        } else {\n            s = (s * 2 + 2 * d - st[i - 1] * sti[i - 1 - m] % d * sti[m] % d - st[i - 1] * sti[i - 1 - k] % d * sti[k] % d) % d;\n        }\n        ans = (ans + st[i + n - 1] * sti[n - 1] % d * sti[i] % d * pow3[m + k - i] % d * s) % d;\n    }\n    println!(\"{}\", ans);\n}\n\nfn pow_m(n: usize, mut p: usize, d: usize) -> usize {\n    let mut r = n;\n    let mut ret = 1;\n    while p > 0 {\n        if p % 2 == 0 {\n            r = r * r % d;\n            p /= 2;\n        } else {\n            ret = ret * r % d;\n            p -= 1;\n        }\n    }\n    ret\n}\n\nfn inv_m(n: usize, d: usize) -> usize {\n    pow_m(n, d - 2, d)\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::str::FromStr;\nuse std::io::*;\nuse std::cmp::*;\nuse utils::*;\n\npub fn main() {\n    let i = stdin();\n    let mut o = Vec::new();\n    run(i.lock(), &mut o);\n    stdout().write_all(&o).unwrap();\n}\n\nfn run<R: BufRead, W: Write>(i: R, o: &mut W) {\n    let mut i = AtRead::from(i);\n    let nmk = i.read3::<usize, usize, usize>();\n    writeln!(o, \"{}\", solve(nmk)).unwrap();\n}\nfn solve(n: (usize, usize, usize)) -> usize {\n    let mut pows = Vec::new();\n    let mut p = ModInt(1);\n    for _ in 0..n.1 + n.2 + 1 {\n        pows.push(p);\n        p *= 3;\n    }\n\n    let mut c_i012 = PascalsTriangleIter::<ModInt>::new(n.0 - 1);\n    let mut c_i12 = PascalsTriangleIter::<ModInt>::new(0);\n\n    let n_sum = n.0 + n.1 + n.2;\n    let mut result = ModInt(0);\n    for i012 in n.0 - 1..n_sum {\n        let i12 = i012 - (n.0 - 1);\n        let mut c = ModInt(0);\n        for i1 in 0..min(n.1, i12) + 1 {\n            let i2 = i12 - i1;\n            if i2 > n.2 {\n                continue;\n            }\n            c += c_i12.get()[i1];\n        }\n        c *= c_i012.get()[n.0 - 1];\n        c *= pows[n_sum - 1 - i012];\n        result += c;\n\n        c_i012.next();\n        c_i12.next();\n    }\n    result.0\n}\n\nmod utils {\n    #![allow(dead_code)]\n    use super::*;\n    use std::ops::*;\n\n    pub struct AtRead<R: BufRead> {\n        r: R,\n        s: String,\n    }\n\n    macro_rules! fn_read {\n        {$f:ident($($v:ident: $t:ident),*)} => {\n            pub fn $f<$($t: FromStr),*>(&mut self) -> ($($t),*) {\n                let i = &mut self.read_line().split(' ');\n                $(\n                    let $v = next(i);\n                )*\n                ($($v),*)\n            }\n        };\n    }\n\n    impl<R: BufRead> AtRead<R> {\n        pub fn from(r: R) -> Self {\n            AtRead {\n                r: r,\n                s: String::new(),\n            }\n        }\n        pub fn read_line(&mut self) -> &str {\n            self.s.clear();\n            self.r.read_line(&mut self.s).unwrap();\n            self.s.trim()\n        }\n\n        pub fn read<T: FromStr>(&mut self) -> T {\n            self.read_line().parse().ok().unwrap()\n        }\n        fn_read! { read2(v1: T1, v2: T2) }\n        fn_read! { read3(v1: T1, v2: T2, v3: T3) }\n        fn_read! { read4(v1: T1, v2: T2, v3: T3, v4: T4) }\n\n        pub fn read_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n            self.read_line()\n                .split(' ')\n                .take(n)\n                .map(|x| x.parse().ok().unwrap())\n                .collect()\n        }\n    }\n\n    fn next<'a, T: FromStr, I: std::iter::Iterator<Item = &'a str>>(i: &mut I) -> T {\n        i.next().unwrap().parse().ok().unwrap()\n    }\n\n    #[derive(Debug, Clone, Copy)]\n    pub struct ModInt(pub usize);\n\n    const MOD_BASE: usize = 1000000007;\n    const MOD_INV_POW: usize = 1000000005;\n\n    impl ModInt {\n        pub fn new(n: usize) -> Self {\n            ModInt(n % MOD_BASE)\n        }\n        pub fn pow(self, mut exp: usize) -> ModInt {\n            let mut b = self;\n            let mut r = ModInt(1);\n            while exp != 0 {\n                if exp % 2 == 1 {\n                    r *= b;\n                }\n                exp /= 2;\n                b = b * b;\n            }\n            r\n        }\n        pub fn inverse_element(self) -> ModInt {\n            self.pow(MOD_INV_POW)\n        }\n    }\n\n    macro_rules! ModInt_op {\n        (($ot:ident, $f:ident), ($ot_a:ident, $f_a:ident), $($rhs:ty, $e:expr,)*) => {\n            $(\n            impl $ot<$rhs> for ModInt {\n                type Output = Self;\n                fn $f(self, rhs: $rhs) -> Self {\n                    Self::new(($e)(self, rhs))\n                }\n            }\n            impl $ot_a<$rhs> for ModInt {\n                fn $f_a(&mut self, rhs: $rhs) {\n                    *self = Self::new(($e)(*self, rhs))\n                }\n            }\n            )*\n        }\n    }\n\n    ModInt_op!(\n        (Add, add),\n        (AddAssign, add_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 + r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 + r,\n    );\n\n    ModInt_op!(\n        (Mul, mul),\n        (MulAssign, mul_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 * r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 * r,\n    );\n\n    ModInt_op!(\n        (Sub, sub),\n        (SubAssign, sub_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| MOD_BASE + l.0 - r.0,\n        usize,\n        |l: ModInt, r: usize| MOD_BASE + l.0 - r,\n    );\n\n    // std::cmp::Reverseと同じ\n    #[derive(PartialEq, Eq)]\n    pub struct RevCmp<T>(pub T);\n\n    impl<T: PartialOrd> PartialOrd for RevCmp<T> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            other.0.partial_cmp(&self.0)\n        }\n    }\n    impl<T: Ord> Ord for RevCmp<T> {\n        fn cmp(&self, other: &Self) -> Ordering {\n            other.0.cmp(&self.0)\n        }\n    }\n\n    pub struct PascalsTriangle<T> {\n        buf: Vec<T>,\n        n: usize,\n    }\n\n    impl<T: One> PascalsTriangle<T> {\n        pub fn new() -> Self {\n            PascalsTriangle {\n                buf: vec![T::one()],\n                n: 1,\n            }\n        }\n        pub fn get(&mut self, n: usize, m: usize) -> T {\n            assert!(m <= n);\n            self.ready(n);\n            self.buf[n * (n + 1) / 2 + m]\n        }\n\n        pub fn ready(&mut self, n: usize) {\n            while self.n <= n {\n                let i = self.buf.len() - self.n;\n                self.buf.push(T::one());\n                for m in 1..self.n {\n                    let v = self.buf[i + m - 1] + self.buf[i + m];\n                    self.buf.push(v);\n                }\n                self.buf.push(T::one());\n                self.n += 1;\n            }\n        }\n    }\n\n    pub struct PascalsTriangleIter<T> {\n        buf: Vec<T>,\n    }\n    impl<T: One> PascalsTriangleIter<T> {\n        pub fn new(n: usize) -> Self {\n            let mut s = PascalsTriangleIter {\n                buf: vec![T::one()],\n            };\n            for _ in 0..n {\n                s.next();\n            }\n            s\n        }\n        pub fn next(&mut self) -> &[T] {\n            for i in (1..self.buf.len()).rev() {\n                self.buf[i] = self.buf[i] + self.buf[i - 1];\n            }\n            self.buf.push(T::one());\n            self.get()\n        }\n        pub fn get(&self) -> &[T] {\n            &self.buf\n        }\n    }\n\n    pub trait Zero: Add<Output = Self> + Sized + Copy {\n        fn zero() -> Self;\n    }\n    pub trait One: Zero {\n        fn one() -> Self;\n    }\n\n    macro_rules! impl_zero {\n        ($t:ty, $e:expr) => {\n            impl Zero for $t {\n                fn zero() -> Self {\n                    $e\n                }\n            }\n        }\n    }\n    macro_rules! impl_one {\n        ($t:ty, $e1:expr, $e0:expr) => {\n            impl One for $t {\n                fn one() -> Self {\n                    $e1\n                }\n            }\n            impl_zero!($t, $e0);\n        }\n    }\n\n    impl_one!(usize, 1, 0);\n    impl_one!(u32, 1, 0);\n    impl_one!(i32, 1, 0);\n    impl_one!(f64, 1.0, 0.0);\n    impl_one!(ModInt, ModInt(1), ModInt(0));\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::str::FromStr;\nuse std::io::*;\nuse std::cmp::*;\nuse utils::*;\n\npub fn main() {\n    let i = stdin();\n    let mut o = Vec::new();\n    run(i.lock(), &mut o);\n    stdout().write_all(&o).unwrap();\n}\n\nfn run<R: BufRead, W: Write>(i: R, o: &mut W) {\n    let mut i = AtRead::from(i);\n    let nmk = i.read3::<usize, usize, usize>();\n    writeln!(o, \"{}\", solve(nmk)).unwrap();\n}\nfn solve(n: (usize, usize, usize)) -> usize {\n    let mut pows = Vec::new();\n    let mut p = ModInt(1);\n    for _ in 0..n.1 + n.2 + 1 {\n        pows.push(p);\n        p *= 3;\n    }\n\n    let mut comb = Combination::<ModInt>::new();\n\n    log!();\n\n    log!(\"n = {:?}\", n);\n\n    let n_sum = n.0 + n.1 + n.2;\n    let mut result = ModInt(0);\n    for i012 in n.0 - 1..n_sum {\n        let i12 = i012 - (n.0 - 1);\n        let mut c = ModInt(0);\n        for i1 in 0..min(n.1, i12) + 1 {\n            let i2 = i12 - i1;\n            if i2 > n.2 {\n                continue;\n            }\n            c += comb.get(i12, i1);\n        }\n        c *= comb.get(i012, n.0 - 1);\n        c *= pows[n_sum - 1 - i012];\n        result += c;\n    }\n    result.0\n}\n\nmod utils {\n    #![allow(dead_code)]\n    use super::*;\n    use std::ops::*;\n\n    pub struct AtRead<R: BufRead> {\n        r: R,\n        s: String,\n    }\n\n    macro_rules! fn_read {\n        {$f:ident($($v:ident: $t:ident),*)} => {\n            pub fn $f<$($t: FromStr),*>(&mut self) -> ($($t),*) {\n                let i = &mut self.read_line().split(' ');\n                $(\n                    let $v = next(i);\n                )*\n                ($($v),*)\n            }\n        };\n    }\n\n    impl<R: BufRead> AtRead<R> {\n        pub fn from(r: R) -> Self {\n            AtRead {\n                r: r,\n                s: String::new(),\n            }\n        }\n        pub fn read_line(&mut self) -> &str {\n            self.s.clear();\n            self.r.read_line(&mut self.s).unwrap();\n            self.s.trim()\n        }\n\n        pub fn read<T: FromStr>(&mut self) -> T {\n            self.read_line().parse().ok().unwrap()\n        }\n        fn_read! { read2(v1: T1, v2: T2) }\n        fn_read! { read3(v1: T1, v2: T2, v3: T3) }\n        fn_read! { read4(v1: T1, v2: T2, v3: T3, v4: T4) }\n\n        pub fn read_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n            self.read_line()\n                .split(' ')\n                .take(n)\n                .map(|x| x.parse().ok().unwrap())\n                .collect()\n        }\n    }\n\n    fn next<'a, T: FromStr, I: std::iter::Iterator<Item = &'a str>>(i: &mut I) -> T {\n        i.next().unwrap().parse().ok().unwrap()\n    }\n\n    #[derive(Debug, Clone, Copy)]\n    pub struct ModInt(pub usize);\n\n    const MOD_BASE: usize = 1000000007;\n    const MOD_INV_POW: usize = 1000000005;\n\n    impl ModInt {\n        pub fn new(n: usize) -> Self {\n            ModInt(n % MOD_BASE)\n        }\n        pub fn pow(self, mut exp: usize) -> ModInt {\n            let mut b = self;\n            let mut r = ModInt(1);\n            while exp != 0 {\n                if exp % 2 == 1 {\n                    r *= b;\n                }\n                exp /= 2;\n                b = b * b;\n            }\n            r\n        }\n        pub fn inverse_element(self) -> ModInt {\n            self.pow(MOD_INV_POW)\n        }\n    }\n\n    macro_rules! ModInt_op {\n        (($ot:ident, $f:ident), ($ot_a:ident, $f_a:ident), $($rhs:ty, $e:expr,)*) => {\n            $(\n            impl $ot<$rhs> for ModInt {\n                type Output = Self;\n                fn $f(self, rhs: $rhs) -> Self {\n                    Self::new(($e)(self, rhs))\n                }\n            }\n            impl $ot_a<$rhs> for ModInt {\n                fn $f_a(&mut self, rhs: $rhs) {\n                    *self = Self::new(($e)(*self, rhs))\n                }\n            }\n            )*\n        }\n    }\n\n    ModInt_op!(\n        (Add, add),\n        (AddAssign, add_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 + r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 + r,\n    );\n\n    ModInt_op!(\n        (Mul, mul),\n        (MulAssign, mul_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 * r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 * r,\n    );\n\n    ModInt_op!(\n        (Sub, sub),\n        (SubAssign, sub_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| MOD_BASE + l.0 - r.0,\n        usize,\n        |l: ModInt, r: usize| MOD_BASE + l.0 - r,\n    );\n\n    // std::cmp::Reverseと同じ\n    #[derive(PartialEq, Eq)]\n    pub struct RevCmp<T>(pub T);\n\n    impl<T: PartialOrd> PartialOrd for RevCmp<T> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            other.0.partial_cmp(&self.0)\n        }\n    }\n    impl<T: Ord> Ord for RevCmp<T> {\n        fn cmp(&self, other: &Self) -> Ordering {\n            other.0.cmp(&self.0)\n        }\n    }\n\n    /// パスカルの三角形による組み合わせ数の計算\n    pub struct Combination<T> {\n        buf: Vec<T>,\n        n: usize,\n    }\n\n    impl<T: One> Combination<T> {\n        pub fn new() -> Self {\n            Combination {\n                buf: vec![T::one()],\n                n: 1,\n            }\n        }\n        pub fn get(&mut self, n: usize, m: usize) -> T {\n            assert!(m <= n);\n            self.ready(n);\n            self.buf[n * (n + 1) / 2 + m]\n        }\n\n        pub fn ready(&mut self, n: usize) {\n            while self.n <= n {\n                let i = self.buf.len() - self.n;\n                self.buf.push(T::one());\n                for m in 1..self.n {\n                    let v = self.buf[i + m - 1] + self.buf[i + m];\n                    self.buf.push(v);\n                }\n                self.buf.push(T::one());\n                self.n += 1;\n            }\n        }\n    }\n\n    pub trait Zero: Add<Output = Self> + Sized + Copy {\n        fn zero() -> Self;\n    }\n    pub trait One: Zero {\n        fn one() -> Self;\n    }\n\n    macro_rules! impl_zero {\n        ($t:ty, $e:expr) => {\n            impl Zero for $t {\n                fn zero() -> Self {\n                    $e\n                }\n            }\n        }\n    }\n    macro_rules! impl_one {\n        ($t:ty, $e1:expr, $e0:expr) => {\n            impl One for $t {\n                fn one() -> Self {\n                    $e1\n                }\n            }\n            impl_zero!($t, $e0);\n        }\n    }\n\n    impl_one!(usize, 1, 0);\n    impl_one!(u32, 1, 0);\n    impl_one!(i32, 1, 0);\n    impl_one!(f64, 1.0, 0.0);\n    impl_one!(ModInt, ModInt(1), ModInt(0));\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::str::FromStr;\nuse std::io::*;\nuse std::cmp::*;\nuse utils::*;\n\npub fn main() {\n    let i = stdin();\n    let mut o = Vec::new();\n    run(i.lock(), &mut o);\n    stdout().write_all(&o).unwrap();\n}\n\nfn run<R: BufRead, W: Write>(i: R, o: &mut W) {\n    let mut i = AtRead::from(i);\n    let nmk = i.read3::<usize, usize, usize>();\n    writeln!(o, \"{}\", solve(nmk)).unwrap();\n}\nfn solve(n: (usize, usize, usize)) -> usize {\n    let mut pows = Vec::new();\n    let mut p = ModInt(1);\n    for _ in 0..n.1 + n.2 + 1 {\n        pows.push(p);\n        p *= 3;\n    }\n\n    let n0_ex = n.0 - 1;\n    let n12 = n.1 + n.2;\n    let facts = ModIntFacts::new(n0_ex + n12);\n    let mut result = ModInt(0);\n    let mut c = ModInt(1);\n\n    for i12 in 0..n12 + 1 {\n        let c0 = c * facts.comb(n0_ex + i12, n0_ex) * pows[n12 - i12];\n        result += c0;\n        c *= 2;\n        if i12 >= n.1 {\n            c -= facts.comb(i12, i12 - n.1);\n        }\n        if i12 >= n.2 {\n            c -= facts.comb(i12, i12 - n.2);\n        }\n    }\n\n    result.0\n}\n\nmod utils {\n    use super::*;\n    use std::ops::*;\n\n    pub struct AtRead<R: BufRead> {\n        r: R,\n        s: String,\n    }\n\n    macro_rules! fn_read {\n        {$f:ident($($v:ident: $t:ident),*)} => {\n            pub fn $f<$($t: FromStr),*>(&mut self) -> ($($t),*) {\n                let i = &mut self.read_line().split(' ');\n                $(\n                    let $v = next(i);\n                )*\n                ($($v),*)\n            }\n        };\n    }\n\n    impl<R: BufRead> AtRead<R> {\n        pub fn from(r: R) -> Self {\n            AtRead {\n                r: r,\n                s: String::new(),\n            }\n        }\n        pub fn read_line(&mut self) -> &str {\n            self.s.clear();\n            self.r.read_line(&mut self.s).unwrap();\n            self.s.trim()\n        }\n\n        fn_read! { read3(v1: T1, v2: T2, v3: T3) }\n    }\n\n    fn next<'a, T: FromStr, I: std::iter::Iterator<Item = &'a str>>(i: &mut I) -> T {\n        i.next().unwrap().parse().ok().unwrap()\n    }\n\n    #[derive(Debug, Clone, Copy)]\n    pub struct ModInt(pub usize);\n\n    const MOD_BASE: usize = 1000000007;\n    const MOD_INV_POW: usize = 1000000005;\n\n    impl ModInt {\n        pub fn new(n: usize) -> Self {\n            ModInt(n % MOD_BASE)\n        }\n        pub fn pow(self, mut exp: usize) -> Self {\n            let mut b = self;\n            let mut r = ModInt(1);\n            while exp != 0 {\n                if exp % 2 == 1 {\n                    r *= b;\n                }\n                exp /= 2;\n                b = b * b;\n            }\n            r\n        }\n        pub fn inverse_element(self) -> Self {\n            self.pow(MOD_INV_POW)\n        }\n    }\n\n    macro_rules! ModInt_op {\n        (($ot:ident, $f:ident), ($ot_a:ident, $f_a:ident), $($rhs:ty, $e:expr,)*) => {\n            $(\n            impl $ot<$rhs> for ModInt {\n                type Output = Self;\n                fn $f(self, rhs: $rhs) -> Self {\n                    Self::new(($e)(self, rhs))\n                }\n            }\n            impl $ot_a<$rhs> for ModInt {\n                fn $f_a(&mut self, rhs: $rhs) {\n                    *self = Self::new(($e)(*self, rhs))\n                }\n            }\n            )*\n        }\n    }\n\n    ModInt_op!(\n        (Add, add),\n        (AddAssign, add_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 + r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 + r,\n    );\n\n    ModInt_op!(\n        (Mul, mul),\n        (MulAssign, mul_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| l.0 * r.0,\n        usize,\n        |l: ModInt, r: usize| l.0 * r,\n    );\n\n    ModInt_op!(\n        (Sub, sub),\n        (SubAssign, sub_assign),\n        ModInt,\n        |l: ModInt, r: ModInt| MOD_BASE + l.0 - r.0,\n        usize,\n        |l: ModInt, r: usize| MOD_BASE + l.0 - r,\n    );\n\n    pub struct ModIntFacts {\n        f: Vec<ModInt>,\n        rf: Vec<ModInt>,\n    }\n    impl ModIntFacts {\n        pub fn new(n: usize) -> Self {\n            let mut s = ModIntFacts {\n                f: vec![ModInt(0); n + 1],\n                rf: vec![ModInt(0); n + 1],\n            };\n\n            let v = ModInt(1);\n            s.f[0] = v;\n            for i in 1..n + 1 {\n                s.f[i] = s.f[i - 1] * i;\n            }\n            s.rf[n] = s.f[n].inverse_element();\n            for i in (1..n + 1).rev() {\n                s.rf[i - 1] = s.rf[i] * i;\n            }\n            s\n        }\n        pub fn comb(&self, n: usize, c: usize) -> ModInt {\n            self.f[n] * self.rf[c] * self.rf[n - c]\n        }\n    }\n}"
  }
]