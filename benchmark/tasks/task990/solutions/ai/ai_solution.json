[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nlong long solve(int N, int M, int K) {\n    long long dp[N+1][M+1][K+1][3];\n    memset(dp, 0, sizeof(dp));\n    \n    // Base cases for decks with 1 card\n    for (int a = 0; a <= N; a++) {\n        for (int b = 0; b <= M; b++) {\n            for (int c = 0; c <= K; c++) {\n                if (a + b + c == 0) continue;\n                \n                if (a > 0) dp[a][b][c][0] = 1;\n                if (b > 0) dp[a][b][c][1] = 1;\n                if (c > 0) dp[a][b][c][2] = 1;\n            }\n        }\n    }\n    \n    // DP to calculate winning configurations\n    for (int a = 0; a <= N; a++) {\n        for (int b = 0; b <= M; b++) {\n            for (int c = 0; c <= K; c++) {\n                for (int last = 0; last < 3; last++) {\n                    // a card (A's turn)\n                    if (last == 0 && a > 0) {\n                        if (b > 0) dp[a-1][b][c][1] = (dp[a-1][b][c][1] + dp[a][b][c][0]) % MOD;\n                        if (c > 0) dp[a-1][b][c][2] = (dp[a-1][b][c][2] + dp[a][b][c][0]) % MOD;\n                    }\n                    \n                    // b card (B's turn)\n                    if (last == 1 && b > 0) {\n                        if (a > 0) dp[a][b-1][c][0] = (dp[a][b-1][c][0] + dp[a][b][c][1]) % MOD;\n                        if (c > 0) dp[a][b-1][c][2] = (dp[a][b-1][c][2] + dp[a][b][c][1]) % MOD;\n                    }\n                    \n                    // c card (C's turn)\n                    if (last == 2 && c > 0) {\n                        if (a > 0) dp[a][b][c-1][0] = (dp[a][b][c-1][0] + dp[a][b][c][2]) % MOD;\n                        if (b > 0) dp[a][b][c-1][1] = (dp[a][b][c-1][1] + dp[a][b][c][2]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    \n    // Sum of Alice's winning configurations\n    long long total = 0;\n    for (int b = 0; b <= M; b++) {\n        for (int c = 0; c <= K; c++) {\n            total = (total + dp[0][b][c][0]) % MOD;\n        }\n    }\n    \n    return total;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n    printf(\"%lld\\n\", solve(N, M, K));\n    return 0;\n}",
    "timestamp": "2025-08-05 23:35:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint N, M, K;\nint dp[101][101][101][3];\n\nint solve(int a, int b, int c, int turn) {\n    if (a == 0 && b == 0 && c == 0) return 0;\n    if (a == 0 && b == 0) return 2;\n    if (a == 0 && c == 0) return 1;\n    if (b == 0 && c == 0) return 0;\n    \n    if (dp[a][b][c][turn] != -1) return dp[a][b][c][turn];\n    \n    int res = 0;\n    if (turn == 0) {\n        if (a > 0) res = (res + solve(a - 1, b, c, 0)) % MOD;\n        if (b > 0) res = (res + solve(a, b - 1, c, 1)) % MOD;\n        if (c > 0) res = (res + solve(a, b, c - 1, 2)) % MOD;\n    } else if (turn == 1) {\n        if (a > 0) res = (res + solve(a - 1, b, c, 0)) % MOD;\n        if (b > 0) res = (res + solve(a, b - 1, c, 1)) % MOD;\n        if (c > 0) res = (res + solve(a, b, c - 1, 2)) % MOD;\n    } else {\n        if (a > 0) res = (res + solve(a - 1, b, c, 0)) % MOD;\n        if (b > 0) res = (res + solve(a, b - 1, c, 1)) % MOD;\n        if (c > 0) res = (res + solve(a, b, c - 1, 2)) % MOD;\n    }\n    \n    return dp[a][b][c][turn] = res;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &K);\n    memset(dp, -1, sizeof(dp));\n    int result = solve(N, M, K, 0);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:36:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint dp[101][101][101][3];\n\nint solve(int a, int b, int c, int turn) {\n    if (a == 0 && b == 0 && c == 0) return 0;\n    if (dp[a][b][c][turn] != -1) return dp[a][b][c][turn];\n    \n    int res = 0;\n    if (turn == 0) {\n        if (a == 0) return 0;\n        if (a == 1 && b == 0 && c == 0) return 1;\n        if (a > 0) res = (res + solve(a - 1, b, c, 0)) % MOD;\n        if (b > 0) res = (res + solve(a, b - 1, c, 1)) % MOD;\n        if (c > 0) res = (res + solve(a, b, c - 1, 2)) % MOD;\n    } else if (turn == 1) {\n        if (b == 0) return 0;\n        if (a == 0 && b == 1 && c == 0) return 0;\n        if (a > 0) res = (res + solve(a - 1, b, c, 0)) % MOD;\n        if (b > 0) res = (res + solve(a, b - 1, c, 1)) % MOD;\n        if (c > 0) res = (res + solve(a, b, c - 1, 2)) % MOD;\n    } else {\n        if (c == 0) return 0;\n        if (a == 0 && b == 0 && c == 1) return 0;\n        if (a > 0) res = (res + solve(a - 1, b, c, 0)) % MOD;\n        if (b > 0) res = (res + solve(a, b - 1, c, 1)) % MOD;\n        if (c > 0) res = (res + solve(a, b, c - 1, 2)) % MOD;\n    }\n    return dp[a][b][c][turn] = res;\n}\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    \n    memset(dp, -1, sizeof(dp));\n    \n    int result = solve(N, M, K, 0);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:36:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n    static int[][][][] dp;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int K = sc.nextInt();\n        \n        dp = new int[N + 1][M + 1][K + 1][3];\n        for (int[][][] arr3 : dp) {\n            for (int[][] arr2 : arr3) {\n                for (int[] arr1 : arr2) {\n                    Arrays.fill(arr1, -1);\n                }\n            }\n        }\n        \n        long res = solve(N, M, K, 0);\n        System.out.println(res % MOD);\n    }\n\n    static int solve(int a, int b, int c, int turn) {\n        if (a == 0 && b == 0 && c == 0) return 0;\n        if (dp[a][b][c][turn] != -1) return dp[a][b][c][turn];\n        \n        long res = 0;\n        if (turn == 0) {\n            if (a == 0) return 0;\n            if (a == 1 && b == 0 && c == 0) return 1;\n            if (a > 0) res += solve(a - 1, b, c, 0);\n            if (b > 0) res += solve(a, b - 1, c, 1);\n            if (c > 0) res += solve(a, b, c - 1, 2);\n        } else if (turn == 1) {\n            if (b == 0) return 0;\n            if (b == 1 && a == 0 && c == 0) return 0;\n            if (a > 0) res += solve(a - 1, b, c, 0);\n            if (b > 0) res += solve(a, b - 1, c, 1);\n            if (c > 0) res += solve(a, b, c - 1, 2);\n        } else {\n            if (c == 0) return 0;\n            if (c == 1 && a == 0 && b == 0) return 0;\n            if (a > 0) res += solve(a - 1, b, c, 0);\n            if (b > 0) res += solve(a, b - 1, c, 1);\n            if (c > 0) res += solve(a, b, c - 1, 2);\n        }\n        \n        res %= MOD;\n        dp[a][b][c][turn] = (int) res;\n        return (int) res;\n    }\n}",
    "timestamp": "2025-08-05 23:37:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public int countAliceWins(int N, int M, int K) {\n        long[][][] dp = new long[N + 1][M + 1][K + 1];\n        dp[N][M][K] = 1;\n\n        for (int a = N; a >= 0; a--) {\n            for (int b = M; b >= 0; b--) {\n                for (int c = K; c >= 0; c--) {\n                    if (a + b + c == 0) continue;\n\n                    // Alice's turn\n                    if ((a + b + c) % 3 == 0) {\n                        if (a > 0) {\n                            dp[a - 1][b][c] = (dp[a - 1][b][c] + dp[a][b][c]) % MOD;\n                        }\n                        if (b > 0) {\n                            dp[a][b - 1][c] = (dp[a][b - 1][c] + dp[a][b][c]) % MOD;\n                        }\n                        if (c > 0) {\n                            dp[a][b][c - 1] = (dp[a][b][c - 1] + dp[a][b][c]) % MOD;\n                        }\n                    }\n                    // Bob's turn\n                    else if ((a + b + c) % 3 == 1) {\n                        if (a > 0) {\n                            dp[a - 1][b][c] = (dp[a - 1][b][c] + dp[a][b][c]) % MOD;\n                        }\n                        if (b > 0) {\n                            dp[a][b - 1][c] = (dp[a][b - 1][c] + dp[a][b][c]) % MOD;\n                        }\n                        if (c > 0) {\n                            dp[a][b][c - 1] = (dp[a][b][c - 1] + dp[a][b][c]) % MOD;\n                        }\n                    }\n                    // Charlie's turn\n                    else {\n                        if (a > 0) {\n                            dp[a - 1][b][c] = (dp[a - 1][b][c] + dp[a][b][c]) % MOD;\n                        }\n                        if (b > 0) {\n                            dp[a][b - 1][c] = (dp[a][b - 1][c] + dp[a][b][c]) % MOD;\n                        }\n                        if (c > 0) {\n                            dp[a][b][c - 1] = (dp[a][b][c - 1] + dp[a][b][c]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n\n        long result = 0;\n        for (int a = 0; a <= N; a++) {\n            for (int b = 0; b <= M; b++) {\n                for (int c = 0; c <= K; c++) {\n                    if (a + b + c > 0 && (a + b + c) % 3 == 0) {\n                        result = (result + dp[a][b][c]) % MOD;\n                    }\n                }\n            }\n        }\n        return (int) result;\n    }\n}",
    "timestamp": "2025-08-05 23:37:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countAliceWins(int N, int M, int K) {\n        const int MOD = 1000000007;\n        vector<vector<vector<vector<int>>>> dp(\n            N + 1, \n            vector<vector<vector<int>>>(\n                M + 1, \n                vector<vector<int>>(\n                    K + 1, \n                    vector<int>(3, 0)\n                )\n            )\n        );\n        \n        for (int a = 0; a < N + 1; a++) {\n            for (int b = 0; b < M + 1; b++) {\n                for (int c = 0; c < K + 1; c++) {\n                    for (int turn = 0; turn < 3; turn++) {\n                        if (a + b + c == 0) continue;\n                        \n                        if (turn == 0) {\n                            if (a > 0) {\n                                if (a == 1 && b == 0 && c == 0) \n                                    dp[a][b][c][turn] = 1;\n                                else {\n                                    if (b > 0) \n                                        dp[a][b][c][turn] = (dp[a][b][c][turn] + dp[a-1][b-1][c][1]) % MOD;\n                                    if (c > 0) \n                                        dp[a][b][c][turn] = (dp[a][b][c][turn] + dp[a-1][b][c-1][2]) % MOD;\n                                }\n                            }\n                        } \n                        else if (turn == 1) {\n                            if (b > 0) {\n                                if (b == 1 && a == 0 && c == 0) \n                                    dp[a][b][c][turn] = 1;\n                                else {\n                                    if (a > 0) \n                                        dp[a][b][c][turn] = (dp[a][b][c][turn] + dp[a-1][b-1][c][0]) % MOD;\n                                    if (c > 0) \n                                        dp[a][b][c][turn] = (dp[a][b][c][turn] + dp[a][b-1][c-1][2]) % MOD;\n                                }\n                            }\n                        } \n                        else {\n                            if (c > 0) {\n                                if (c == 1 && a == 0 && b == 0) \n                                    dp[a][b][c][turn] = 1;\n                                else {\n                                    if (a > 0) \n                                        dp[a][b][c][turn] = (dp[a][b][c][turn] + dp[a-1][b][c-1][0]) % MOD;\n                                    if (b > 0) \n                                        dp[a][b][c][turn] = (dp[a][b][c][turn] + dp[a][b-1][c-1][1]) % MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        int total = 0;\n        for (int turn = 0; turn < 3; turn++) {\n            total = (total + dp[N][M][K][turn]) % MOD;\n        }\n        return total;\n    }\n};",
    "timestamp": "2025-08-05 23:37:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 1000000007\n\ndef count_alice_wins(N, M, K):\n    def dp(a, b, c, turn):\n        if a == 0:\n            return 1 if turn == 'a' else 0\n        if b == 0 or c == 0:\n            return 0\n        if memo[a][b][c][turn_index[turn]] != -1:\n            return memo[a][b][c][turn_index[turn]]\n        \n        if turn == 'a':\n            result = (a * dp(a - 1, b, c, 'a') + b * dp(a, b - 1, c, 'b') + c * dp(a, b, c - 1, 'c')) % MOD\n        elif turn == 'b':\n            result = (a * dp(a - 1, b, c, 'a') + b * dp(a, b - 1, c, 'b')) % MOD\n        else: # turn == 'c'\n            result = (a * dp(a - 1, b, c, 'a') + c * dp(a, b, c - 1, 'c')) % MOD\n        \n        memo[a][b][c][turn_index[turn]] = result\n        return result\n    \n    memo = [[[[-1 for _ in range(3)] for _ in range(K + 1)] for _ in range(M + 1)] for _ in range(N + 1)]\n    turn_index = {'a': 0, 'b': 1, 'c': 2}\n    return dp(N, M, K, 'a')\n\nN, M, K = map(int, input().split())\nprint(count_alice_wins(N, M, K))",
    "timestamp": "2025-08-13 16:21:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class CardGame {\n\n    private static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt(); // Cards for Alice\n        int M = scanner.nextInt(); // Cards for Bob\n        int K = scanner.nextInt(); // Cards for Charlie\n        scanner.close();\n\n        long[][][] dp = new long[N + 1][M + 1][K + 1];\n        dp[0][0][0] = 1;\n\n        for (int n = 0; n <= N; n++) {\n            for (int m = 0; m <= M; m++) {\n                for (int k = 0; k <= K; k++) {\n                    if (n > 0)\n                        dp[n][m][k] = (dp[n][m][k] + dp[n - 1][m][k]) % MOD;\n                    if (m > 0 && n > 0)\n                        dp[n][m][k] = (dp[n][m][k] + dp[n][m - 1][k]) % MOD;\n                    if (k > 0 && n > 0)\n                        dp[n][m][k] = (dp[n][m][k] + dp[n][m][k - 1]) % MOD;\n\n                    if (n > 0 && m > 0 && k > 0)\n                        dp[n][m][k] = (dp[n][m][k] + dp[n - 1][m - 1][k] + dp[n - 1][m][k - 1] + dp[n][m - 1][k - 1]) % MOD;\n                    else if (n > 0 && m > 0)\n                        dp[n][m][k] = (dp[n][m][k] + dp[n - 1][m - 1][k]) % MOD;\n                    else if (n > 0 && k > 0)\n                        dp[n][m][k] = (dp[n][m][k] + dp[n - 1][m][k - 1]) % MOD;\n                    else if (m > 0 && k > 0)\n                        dp[n][m][k] = (dp[n][m][k] + dp[n][m - 1][k - 1]) % MOD;\n                }\n            }\n        }\n\n        long result = 0;\n        for (int m = 0; m <= M; m++) {\n            for (int k = 0; k <= K; k++) {\n                result = (result + dp[N][m][k]) % MOD;\n            }\n        }\n\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 16:21:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\nlong long dp[101][101][101][3];\n\nlong long solve(int a, int b, int c, int turn) {\n    if (a == 0 && turn == 0) return 1;\n    if (b == 0 && turn == 1) return 0;\n    if (c == 0 && turn == 2) return 0;\n    \n    if (dp[a][b][c][turn] != -1) return dp[a][b][c][turn];\n    \n    long long result = 0;\n    if (turn == 0) {\n        if (a > 0) result = (result + solve(a - 1, b, c, 0)) % MOD;\n        if (b > 0) result = (result + solve(a, b - 1, c, 1)) % MOD;\n        if (c > 0) result = (result + solve(a, b, c - 1, 2)) % MOD;\n    } else if (turn == 1) {\n        if (a > 0) result = (result + solve(a - 1, b, c, 0)) % MOD;\n        if (b > 0) result = (result + solve(a, b - 1, c, 1)) % MOD;\n        if (c > 0) result = (result + solve(a, b, c - 1, 2)) % MOD;\n    } else if (turn == 2) {\n        if (a > 0) result = (result + solve(a - 1, b, c, 0)) % MOD;\n        if (b > 0) result = (result + solve(a, b - 1, c, 1)) % MOD;\n        if (c > 0) result = (result + solve(a, b, c - 1, 2)) % MOD;\n    }\n    \n    dp[a][b][c][turn] = result;\n    return result;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n    \n    for (int i = 0; i <= N; ++i)\n        for (int j = 0; j <= M; ++j)\n            for (int k = 0; k <= K; ++k)\n                for (int t = 0; t < 3; ++t)\n                    dp[i][j][k][t] = -1;\n    \n    printf(\"%lld\\n\", solve(N, M, K, 0));\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 16:21:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\n// Helper function to calculate power of a number modulo MOD\nint modPow(int base, int exp, int mod) {\n    int result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result = (long long)result * base % mod;\n        base = (long long)base * base % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\n// Helper function to calculate factorial modulo MOD\nint modFact(int n, int mod) {\n    int result = 1;\n    for (int i = 2; i <= n; i++)\n        result = (long long)result * i % mod;\n    return result;\n}\n\n// Helper function to calculate modular inverse\nint modInverse(int n, int mod) {\n    return modPow(n, mod - 2, mod);\n}\n\n// Helper function to calculate nCr modulo MOD\nint modBinomial(int n, int r, int mod) {\n    if (r > n) return 0;\n    return (long long)modFact(n, mod) * modInverse(modFact(r, mod), mod) % mod * modInverse(modFact(n - r, mod), mod) % mod;\n}\n\nint main() {\n    int N, M, K;\n    std::cin >> N >> M >> K;\n\n    int total_cards = N + M + K;\n    if (N == 0) {\n        std::cout << 0 << std::endl;\n        return 0;\n    }\n\n    // Calculate total configurations\n    int total_configurations = modBinomial(total_cards - 1, N - 1, MOD);\n\n    // Calculate configurations where Alice wins\n    int alice_wins = 0;\n    for (int a_win_pos = N; a_win_pos <= total_cards; a_win_pos += 3) {\n        int sum_m_k = total_cards - a_win_pos;\n        if (sum_m_k < M || sum_m_k > M + K) continue;\n        int ways = (long long)modBinomial(sum_m_k, M, MOD) * modBinomial(a_win_pos - 1, N - 1, MOD) % MOD;\n        alice_wins = (alice_wins + ways) % MOD;\n    }\n\n    std::cout << alice_wins << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 16:21:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_card_game(N, M, K):\n    MOD = 10**9 + 7\n    \n    # 3D dynamic programming array \n    # dp[a][b][c][p] represents number of ways to reach state \n    # with Alice having a cards, Bob b cards, Charlie c cards\n    # and player p (0=Alice, 1=Bob, 2=Charlie) to play\n    dp = [[[[0 for _ in range(3)] for _ in range(K+1)] \n           for _ in range(M+1)] for _ in range(N+1)]\n    \n    # Base case: initial state \n    dp[N][M][K][0] = 1\n    \n    # Iterate through all possible states\n    for a in range(N+1):\n        for b in range(M+1):\n            for c in range(K+1):\n                for p in range(3):\n                    if dp[a][b][c][p] == 0:\n                        continue\n                    \n                    # Alice's turn\n                    if p == 0:\n                        # Discard 'a' \n                        if a > 0:\n                            dp[a-1][b][c][0] = (dp[a-1][b][c][0] + dp[a][b][c][p]) % MOD\n                        # Discard 'b'\n                        if b > 0:\n                            dp[a][b-1][c][1] = (dp[a][b-1][c][1] + dp[a][b][c][p]) % MOD\n                        # Discard 'c'\n                        if c > 0:\n                            dp[a][b][c-1][2] = (dp[a][b][c-1][2] + dp[a][b][c][p]) % MOD\n                    \n                    # Bob's turn\n                    elif p == 1:\n                        # Discard 'a'\n                        if a > 0:\n                            dp[a-1][b][c][0] = (dp[a-1][b][c][0] + dp[a][b][c][p]) % MOD\n                        # Discard 'b'\n                        if b > 0:\n                            dp[a][b-1][c][1] = (dp[a][b-1][c][1] + dp[a][b][c][p]) % MOD\n                        # Discard 'c'\n                        if c > 0:\n                            dp[a][b][c-1][2] = (dp[a][b][c-1][2] + dp[a][b][c][p]) % MOD\n                    \n                    # Charlie's turn\n                    else:\n                        # Discard 'a'\n                        if a > 0:\n                            dp[a-1][b][c][0] = (dp[a-1][b][c][0] + dp[a][b][c][p]) % MOD\n                        # Discard 'b'\n                        if b > 0:\n                            dp[a][b-1][c][1] = (dp[a][b-1][c][1] + dp[a][b][c][p]) % MOD\n                        # Discard 'c'\n                        if c > 0:\n                            dp[a][b][c-1][2] = (dp[a][b][c-1][2] + dp[a][b][c][p]) % MOD\n    \n    # Sum all ways Alice wins by depleting her cards\n    alice_wins = 0\n    for b in range(M+1):\n        for c in range(K+1):\n            alice_wins = (alice_wins + dp[0][b][c][0] + \n                          dp[0][b][c][1] + dp[0][b][c][2]) % MOD\n    \n    return alice_wins",
    "timestamp": "2025-08-13 16:22:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    N, M, K = map(int, input().split())\n    max_turns = N + M + K\n    \n    # dp[n][m][k][turn] : turn is 0 (Alice), 1 (Bob), 2 (Charlie)\n    dp = [[[[0] * 3 for _ in range(K+1)] for __ in range(M+1)] for ___ in range(N+1)]\n    \n    # Base case: when a player has no cards left, the game ends\n    # We need to count only when Alice wins (i.e., N=0 and it's not her turn)\n    # But the transitions will handle it\n    \n    # Initialize for the case when all have 0 cards (though it's not possible as per constraints)\n    # But we need to handle cases where one or two players have 0 cards\n    \n    for n in range(N+1):\n        for m in range(M+1):\n            for k in range(K+1):\n                for turn in range(3):\n                    if n == 0 and m == 0 and k == 0:\n                        continue  # no cards left, game ends, no winner in this state\n                    total = 0\n                    if turn == 0:  # Alice's turn\n                        if n == 0:\n                            continue  # Alice has no cards, can't play\n                        # She draws 'a', 'b', or 'c' with equal probability (but counts as separate configs)\n                        # 'a' -> next turn is Alice\n                        if n > 0:\n                            if n == 1 and m == 0 and k == 0:\n                                total += 1  # Alice wins\n                            else:\n                                if n-1 >=0:\n                                    total += dp[n-1][m][k][0]\n                        # 'b' -> next turn is Bob\n                        if m > 0 or k > 0 or (n-1) > 0:\n                            if n-1 >=0 and m >=0 and k >=0:\n                                total += dp[n-1][m][k][1]\n                        # 'c' -> next turn is Charlie\n                        if m > 0 or k > 0 or (n-1) > 0:\n                            if n-1 >=0 and m >=0 and k >=0:\n                                total += dp[n-1][m][k][2]\n                    elif turn == 1:  # Bob's turn\n                        if m == 0:\n                            continue  # Bob has no cards, can't play\n                        # 'a' -> next turn is Alice\n                        if n > 0 or (m-1) > 0 or k > 0:\n                            if n >=0 and m-1 >=0 and k >=0:\n                                total += dp[n][m-1][k][0]\n                        # 'b' -> next turn is Bob\n                        if m > 0:\n                            if m == 1 and n == 0 and k == 0:\n                                pass  # Bob wins, not counted\n                            else:\n                                if n >=0 and m-1 >=0 and k >=0:\n                                    total += dp[n][m-1][k][1]\n                        # 'c' -> next turn is Charlie\n                        if n > 0 or (m-1) > 0 or k > 0:\n                            if n >=0 and m-1 >=0 and k >=0:\n                                total += dp[n][m-1][k][2]\n                    elif turn == 2:  # Charlie's turn\n                        if k == 0:\n                            continue  # Charlie has no cards, can't play\n                        # 'a' -> next turn is Alice\n                        if n > 0 or m > 0 or (k-1) > 0:\n                            if n >=0 and m >=0 and k-1 >=0:\n                                total += dp[n][m][k-1][0]\n                        # 'b' -> next turn is Bob\n                        if n > 0 or m > 0 or (k-1) > 0:\n                            if n >=0 and m >=0 and k-1 >=0:\n                                total += dp[n][m][k-1][1]\n                        # 'c' -> next turn is Charlie\n                        if k > 0:\n                            if k == 1 and n == 0 and m == 0:\n                                pass  # Charlie wins, not counted\n                            else:\n                                if n >=0 and m >=0 and k-1 >=0:\n                                    total += dp[n][m][k-1][2]\n                    total %= MOD\n                    dp[n][m][k][turn] = total\n    \n    # The initial state is N, M, K, and Alice's turn (0)\n    result = dp[N][M][K][0] % MOD\n    print(result)\n\nsolve()",
    "timestamp": "2025-08-13 16:22:46"
  }
]