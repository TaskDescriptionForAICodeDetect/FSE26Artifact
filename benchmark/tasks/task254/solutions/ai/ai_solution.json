[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_CHECKPOINTS 100\n\nint distances[MAX_CHECKPOINTS];\nint dp[MAX_CHECKPOINTS];\nint n;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint calculateTime(int distance) {\n    if (distance <= 1000) {\n        return 0;\n    } else if (distance <= 3000) {\n        return 10;\n    } else if (distance <= 6000) {\n        return 20;\n    } else {\n        return 30;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &distances[i]);\n    }\n\n    dp[0] = 0;\n    for (int i = 1; i < n; i++) {\n        dp[i] = INT_MAX;\n        for (int j = 0; j < i; j++) {\n            int distance = distances[i] - distances[j];\n            dp[i] = min(dp[i], dp[j] + calculateTime(distance));\n        }\n    }\n\n    printf(\"%d\\n\", dp[n - 1]);\n    return 0;\n}",
    "timestamp": "2025-08-05 19:18:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AtomicCarRace {\n    public static int minimizeTotalTime(int[] checkpoints, int[] changeCosts) {\n        int n = checkpoints.length;\n        int[][] dp = new int[n][2];\n        \n        // Initialize first checkpoint\n        dp[0][0] = 0; // No tire change\n        dp[0][1] = changeCosts[0]; // Tire change\n        \n        for (int i = 1; i < n; i++) {\n            int distance = checkpoints[i] - checkpoints[i-1];\n            \n            // Option 1: No tire change at current checkpoint\n            dp[i][0] = Math.min(dp[i-1][0], dp[i-1][1]) + distance;\n            \n            // Option 2: Change tires at current checkpoint\n            dp[i][1] = Math.min(\n                dp[i-1][0] + changeCosts[i],\n                dp[i-1][1] + changeCosts[i]\n            );\n        }\n        \n        return Math.min(dp[n-1][0], dp[n-1][1]);\n    }\n    \n    public static void main(String[] args) {\n        int[] checkpoints = {0, 100, 250, 350, 500};\n        int[] changeCosts = {0, 50, 30, 40, 60};\n        \n        int minTime = minimizeTotalTime(checkpoints, changeCosts);\n        System.out.println(\"Minimum total time: \" + minTime);\n    }\n}",
    "timestamp": "2025-08-05 19:18:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> distances(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        cin >> distances[i];\n    }\n\n    vector<vector<int>> dp(N + 1, vector<int>(N + 1, INT_MAX));\n    dp[1][1] = 0; // Base case: first checkpoint, tire changed\n\n    for (int i = 2; i <= N; ++i) {\n        for (int j = 1; j < i; ++j) {\n            if (dp[i - 1][j] != INT_MAX) {\n                // Option 1: Do not change tires\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + distances[i] * distances[i]);\n                // Option 2: Change tires\n                dp[i][i] = min(dp[i][i], dp[i - 1][j] + distances[i] + (j == 1 ? 0 : distances[j] * distances[j]));\n            }\n        }\n    }\n\n    int min_time = INT_MAX;\n    for (int j = 1; j <= N; ++j) {\n        min_time = min(min_time, dp[N][j]);\n    }\n\n    cout << min_time << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 19:19:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_CHECKPOINTS 100\n\nint minTotalTime(int checkpoints[], int distances[], int tire_change_times[], int n) {\n    int dp[MAX_CHECKPOINTS][MAX_CHECKPOINTS];\n    \n    // Initialize dynamic programming table\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = INT_MAX;\n        }\n    }\n    \n    // Base case: first checkpoint\n    dp[0][0] = 0;\n    \n    // Dynamic programming calculation\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            int distance_traveled = checkpoints[i] - checkpoints[j];\n            \n            // Calculate tire change time based on distance\n            int change_time = tire_change_times[distance_traveled];\n            \n            if (dp[j][j] != INT_MAX) {\n                dp[i][j] = dp[j][j] + change_time + (checkpoints[i] - checkpoints[j]);\n            }\n            \n            // Find minimum time to reach current checkpoint\n            for (int k = 0; k < j; k++) {\n                if (dp[j][k] != INT_MAX) {\n                    int prev_time = dp[j][k] + change_time + (checkpoints[i] - checkpoints[j]);\n                    dp[i][j] = (prev_time < dp[i][j]) ? prev_time : dp[i][j];\n                }\n            }\n        }\n    }\n    \n    // Find minimum total time\n    int min_time = INT_MAX;\n    for (int j = 0; j < n; j++) {\n        if (dp[n-1][j] < min_time) {\n            min_time = dp[n-1][j];\n        }\n    }\n    \n    return min_time;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int checkpoints[MAX_CHECKPOINTS];\n    int distances[MAX_CHECKPOINTS];\n    int tire_change_times[MAX_CHECKPOINTS];\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &checkpoints[i]);\n    }\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &distances[i]);\n    }\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &tire_change_times[i]);\n    }\n    \n    int result = minTotalTime(checkpoints, distances, tire_change_times, n);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:19:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nclass RaceStrategy {\nprivate:\n    int checkpoints;\n    vector<int> distances;\n    vector<int> tire_change_times;\n    vector<vector<int>> dp;\n\npublic:\n    RaceStrategy(int n, vector<int>& points, vector<int>& change_times) {\n        checkpoints = n;\n        distances = points;\n        tire_change_times = change_times;\n        dp.resize(n, vector<int>(n, INT_MAX));\n    }\n\n    int calculateOptimalTireChanges() {\n        for (int i = 0; i < checkpoints; ++i) {\n            dp[i][i] = 0;\n        }\n\n        for (int len = 2; len <= checkpoints; ++len) {\n            for (int start = 0; start < checkpoints - len + 1; ++start) {\n                int end = start + len - 1;\n                int total_distance = distances[end] - distances[start];\n\n                for (int k = start; k < end; ++k) {\n                    int tire_change_penalty = tire_change_times[total_distance];\n                    dp[start][end] = min(dp[start][end], \n                        dp[start][k] + dp[k+1][end] + tire_change_penalty);\n                }\n            }\n        }\n\n        return dp[0][checkpoints-1];\n    }\n};\n\nint main() {\n    int n = 5;\n    vector<int> distances = {0, 100, 250, 400, 600};\n    vector<int> tire_change_times = {0, 10, 20, 35, 50};\n\n    RaceStrategy race(n, distances, tire_change_times);\n    int optimal_time = race.calculateOptimalTireChanges();\n\n    cout << \"Optimal Race Time: \" << optimal_time << \" seconds\" << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:20:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TireChangeOptimization {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] distances = new int[N];\n        for (int i = 0; i < N; i++) {\n            distances[i] = scanner.nextInt();\n        }\n        int changeTime = scanner.nextInt();\n\n        long[] dp = new long[N];\n        dp[0] = 0;\n\n        for (int i = 1; i < N; i++) {\n            dp[i] = Long.MAX_VALUE;\n            long distanceSum = 0;\n            for (int j = i; j >= 1; j--) {\n                distanceSum += distances[j];\n                long time = dp[j - 1] + changeTime + distanceSum * distanceSum;\n                if (time < dp[i]) {\n                    dp[i] = time;\n                }\n            }\n        }\n\n        System.out.println(dp[N - 1]);\n    }\n}",
    "timestamp": "2025-08-05 19:20:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_race_time(distances, change_time, speeds):\n    n = len(distances)\n    memo = {}\n\n    def dp(i, last_change):\n        if i == n:\n            return 0\n        if (i, last_change) in memo:\n            return memo[(i, last_change)]\n        \n        # Calculate time without tire change\n        distance_since_last_change = sum(distances[last_change:i+1])\n        no_change_time = distance_since_last_change / speeds[min(i-last_change, len(speeds)-1)]\n        \n        # Calculate time with tire change\n        change_time_included = change_time + (distances[i] / speeds[0])\n        \n        # Recursive calculations\n        change = change_time_included + dp(i+1, i+1)\n        no_change = no_change_time + dp(i+1, last_change)\n\n        # Take the minimum of changing or not changing\n        result = min(change, no_change)\n        memo[(i, last_change)] = result\n        return result\n\n    return dp(0, 0)\n\n# Example usage\ndistances = [100, 200, 150, 200]\nchange_time = 30\nspeeds = [5, 4, 3]  # Speeds depending on how many segments since the last change\n\ntotal_time = min_race_time(distances, change_time, speeds)\nprint(total_time)",
    "timestamp": "2025-08-13 03:29:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TireChangeStrategy {\n\n    public static int minimizeTotalTime(int[] checkpoints, int changeTime, int[] tireTimeRates) {\n        int n = checkpoints.length;\n        int[] dp = new int[n]; // dp[i] stores the minimum time to reach checkpoint i\n        \n        // Initialize the first checkpoint time\n        dp[0] = 0;\n        \n        for (int i = 1; i < n; i++) {\n            dp[i] = Integer.MAX_VALUE;\n            \n            // Consider each previous checkpoint as a potential tire change point\n            for (int j = 0; j < i; j++) {\n                int distance = checkpoints[i] - checkpoints[j];\n                int timeWithoutChange = dp[j] + (distance * tireTimeRates[j]);\n                int timeWithChange = dp[j] + changeTime + (distance * tireTimeRates[i]);\n                \n                dp[i] = Math.min(dp[i], timeWithoutChange);\n                dp[i] = Math.min(dp[i], timeWithChange);\n            }\n        }\n        \n        return dp[n - 1];\n    }\n\n    public static void main(String[] args) {\n        // Example usage:\n        int[] checkpoints = {0, 100, 200, 300, 400};\n        int changeTime = 10;\n        int[] tireTimeRates = {2, 3, 1, 4, 2};\n        \n        int result = minimizeTotalTime(checkpoints, changeTime, tireTimeRates);\n        System.out.println(\"Minimum total time: \" + result);\n    }\n}",
    "timestamp": "2025-08-13 03:29:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_CHECKPOINTS 100\n\nint main() {\n    int n, i, j;\n    int distances[MAX_CHECKPOINTS], change_time, travel_time[MAX_CHECKPOINTS];\n    int min_time[MAX_CHECKPOINTS];\n    \n    // Number of checkpoints\n    printf(\"Enter number of checkpoints: \");\n    scanf(\"%d\", &n);\n    \n    // Distances between checkpoints\n    printf(\"Enter distances between checkpoints: \");\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &distances[i]);\n    }\n    \n    // Time to change tires\n    printf(\"Enter time to change tires: \");\n    scanf(\"%d\", &change_time);\n\n    // Travel time calculations for each distance\n    printf(\"Enter travel times for each distance: \");\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &travel_time[i]);\n    }\n    \n    // Initialize the minimum time array\n    for (i = 0; i <= n; i++) {\n        min_time[i] = INT_MAX;\n    }\n    \n    // Starting point (no time needed to start)\n    min_time[0] = 0;\n\n    // Determine the best strategy using dynamic programming\n    for (i = 0; i < n; i++) {\n        int total_distance = 0;\n        for (j = i; j < n; j++) {\n            total_distance += distances[j];\n            int current_tire_status = min_time[i] + travel_time[j] + change_time;\n            if (current_tire_status < min_time[j + 1]) {\n                min_time[j + 1] = current_tire_status;\n            }\n        }\n    }\n\n    // Output the minimum time needed to reach the final checkpoint\n    printf(\"Minimum total time: %d\\n\", min_time[n]);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:29:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimize_race_time(total_distance, checkpoints, tire_change_times):\n    # Dynamic programming solution to minimize race time\n    n = len(checkpoints)\n    dp = [[float('inf')] * (total_distance + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        checkpoint_dist = checkpoints[i - 1]\n        \n        for prev_dist in range(total_distance + 1):\n            # Option 1: Don't change tires\n            if prev_dist + checkpoint_dist <= total_distance:\n                dp[i][prev_dist + checkpoint_dist] = min(\n                    dp[i][prev_dist + checkpoint_dist], \n                    dp[i-1][prev_dist]\n                )\n            \n            # Option 2: Change tires\n            for j in range(prev_dist + 1):\n                tire_change_time = tire_change_times[min(prev_dist - j, len(tire_change_times) - 1)]\n                if prev_dist + checkpoint_dist <= total_distance:\n                    dp[i][prev_dist + checkpoint_dist] = min(\n                        dp[i][prev_dist + checkpoint_dist],\n                        dp[i-1][j] + tire_change_time\n                    )\n\n    return min(dp[n])\n\n# Example usage\ntotal_race_distance = 1000\ncheckpoint_distances = [100, 250, 500, 750, 1000]\ntire_change_penalty_times = [10, 15, 20, 25, 30]  # Penalty times based on distance since last change\n\nbest_time = minimize_race_time(total_race_distance, checkpoint_distances, tire_change_penalty_times)\nprint(f\"Best race time: {best_time}\")",
    "timestamp": "2025-08-13 03:29:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimal_total_time(N, checkpoints):\n    # DP table: dp[i] represents the minimal time to reach checkpoint i\n    dp = [float('inf')] * (N + 1)\n    dp[0] = 0  # Starting point\n    \n    for i in range(1, N + 1):\n        for j in range(i):\n            distance = checkpoints[i - 1] - (checkpoints[j - 1] if j > 0 else 0)\n            # Time calculation based on distance\n            if distance <= 1000:\n                time = distance * 2\n            elif distance <= 3000:\n                time = distance * 1\n            else:\n                time = distance * 0.5\n            # Add tire change time (15 seconds) if j > 0 (not the start)\n            total_time = dp[j] + time + (15 if j > 0 else 0)\n            if total_time < dp[i]:\n                dp[i] = total_time\n    return dp[N]\n\n# Example usage:\n# N = 3\n# checkpoints = [1000, 2000, 3000]\n# print(minimal_total_time(N, checkpoints))",
    "timestamp": "2025-08-13 03:30:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Checkpoint {\n    int distance; // Distance from the start to this checkpoint\n    int changeTime; // Time taken to change tires at this checkpoint\n};\n\n// Function to calculate the total time spent if tires are changed at the specified checkpoints\nint calculateTotalTime(const vector<Checkpoint>& checkpoints, const vector<bool>& changeTires) {\n    int totalTime = 0;\n    int lastChangeDistance = 0;\n    int n = checkpoints.size();\n\n    for (int i = 0; i < n; ++i) {\n        int travelTime = checkpoints[i].distance - lastChangeDistance; // Assume travel time is proportional to distance\n        if (changeTires[i]) {\n            totalTime += travelTime + checkpoints[i].changeTime;\n            lastChangeDistance = checkpoints[i].distance;\n        } else {\n            totalTime += travelTime;\n        }\n    }\n    return totalTime;\n}\n\nint main() {\n    int numCheckpoints;\n    cin >> numCheckpoints;\n\n    vector<Checkpoint> checkpoints(numCheckpoints);\n    for (int i = 0; i < numCheckpoints; ++i) {\n        cin >> checkpoints[i].distance >> checkpoints[i].changeTime;\n    }\n\n    vector<bool> bestStrategy(numCheckpoints, false);\n    int minTime = INT_MAX;\n\n    // Try all combinations of where to change tires\n    int combinations = 1 << numCheckpoints; // 2^numCheckpoints combinations\n    for (int mask = 0; mask < combinations; ++mask) {\n        vector<bool> changeTires(numCheckpoints);\n        for (int i = 0; i < numCheckpoints; ++i) {\n            changeTires[i] = mask & (1 << i);\n        }\n        \n        int currentTime = calculateTotalTime(checkpoints, changeTires);\n        if (currentTime < minTime) {\n            minTime = currentTime;\n            bestStrategy = changeTires;\n        }\n    }\n\n    cout << \"Minimum Total Time: \" << minTime << endl;\n    cout << \"Change tires at checkpoints: \";\n    for (int i = 0; i < numCheckpoints; ++i) {\n        if (bestStrategy[i]) {\n            cout << (i+1) << \" \";\n        }\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:12:35"
  }
]