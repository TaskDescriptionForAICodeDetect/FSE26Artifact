[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N;\nint check_point[101];\ndouble min_time[101][101];\ndouble B,R,V,E,F;\n\n\ndouble calcTime(int x){\n\tif(x >= R){\n\n\t\treturn 1.0/(V-E*((double)x-R));\n\t}else{\n\n\t\treturn 1.0/(V-F*(R-(double)x));\n\t}\n}\n\nvoid func(){\n\n\tcheck_point[0] = 0.0;\n\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&check_point[i]);\n\tscanf(\"%lf\",&B);\n\tscanf(\"%lf %lf %lf %lf\",&R,&V,&E,&F);\n\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int k = 0; k <= i; k++)min_time[i][k] = DBL_MAX;\n\t}\n\n\tmin_time[0][0] = 0;\n\n\tint x;\n\tdouble add_time;\n\n\tfor(int point = 1; point <= N; point++){\n\t\tfor(int changed_loc = 0; changed_loc <= point-1; changed_loc++){\n\t\t\tadd_time = 0.0;\n\t\t\tfor(int loc = check_point[point-1]; loc <= check_point[point]-1; loc++){\n\t\t\t\tx = loc - check_point[changed_loc];\n\t\t\t\tadd_time += calcTime(x);\n\t\t\t}\n\n\t\t\tmin_time[point][changed_loc] = min(min_time[point][changed_loc],min_time[point-1][changed_loc]+add_time);\n\n\t\t\tmin_time[point][point] = min(min_time[point][point],min_time[point-1][changed_loc]+add_time+B);\n\t\t}\n\t}\n\n\tdouble ans = DBL_MAX;\n\tfor(int i = 0; i < N; i++)ans = min(ans,min_time[N][i]);\n\n\tprintf(\"%.10lf\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define INF 10000000\n#define t first\n#define x second\nusing namespace std;\ntypedef pair <double,int> P;\ndouble b,r,v,e,f;\n\ndouble mk(int x) {\n  if(x >= r) return 1.0/(v-e*(1.0*x-r));\n  return  1.0/(v-f*(r-1.0*x));\n}\n\nint main() {\n  while(1) {\n    int n,a[101];\n    cin >> n;\n    if(n==0) break;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    \n    cin >> b;\n    cin >> r >> v >> e >> f;\n    P dp[10010]={};\n    for(int i=1;i<=a[n];i++) dp[i] = make_pair(INF,0);\n\n    for(int i=0;i<n;i++) {\n      int tx;\n      double tt;\n      //No Change\n      tx=dp[a[i]].x,  tt=dp[a[i]].t;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt += k , tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n\n      //Change\n      tx= 0, tt=dp[a[i]].t+b;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt +=k; tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n      \n\n      //      for(int j=0;j<=a[n];j++) cout <<\"[\"<< dp[j].t<<\" \"<<dp[j].x<<\"]\";\n      //cout <<endl;\n    }\n    printf(\"%.8f\\n\",dp[a[n]].t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nint n;\ndouble dp[101][30001];\ndouble b,e,v,f;\nint r;\nint a[1001];\ndouble mem[30000];\nconst int INF=1000000000;\n\n\ndouble dfs(int idx,int runDist){\n    if(!EQ(dp[idx][runDist],INF))return dp[idx][runDist];\n    if(idx==n)\n        return 0;\n    double res=INF;\n    double cost=0;\n    int ndist=a[idx+1]-a[idx];\n    res=min(res,dfs(idx+1,ndist)+mem[ndist-1]+b);\n    // no change\n    if(runDist>=1)\n        res=min(res,dfs(idx+1,ndist+runDist)+mem[ndist+runDist-1]-mem[runDist-1]);\n    else\n        res=min(res,dfs(idx+1,ndist+runDist)+mem[ndist+runDist-1]);\n    return dp[idx][runDist]=res;\n}\n\nint main(){\n    while(cin>>n&&n!=0){\n        a[0]=0;\n        for(int i = 0; i < n; i++)cin>>a[i+1];\n        cin>>b;\n        cin>>r>>v>>e>>f;\n        for(int i = 0; i < 101; i++)for(int j = 0; j < 30001; j++)dp[i][j]=INF;\n        memset(mem,0,sizeof(mem));\n        mem[0]=1.0/(v-f*(r));\n        for(int i = 1; i < 10001; i++){\n            if(i>=r)\n                mem[i]=mem[i-1]+1.0/(v-e*(i-r));\n            else\n                mem[i]=mem[i-1]+1.0/(v-f*(r-i));\n        }\n        for(int i = 0; i < 30000; i++)\n            dp[n][i]=0;\n        for(int i = n-1; i >= 0; i--){\n            for(int j = 10001; j >= 0; j--){\n                int ndist=a[i+1]-a[i];\n                dp[i][j]=min(dp[i][j],dp[i+1][ndist]+mem[ndist-1]+b);\n                if(j>=1)\n                    dp[i][j]=min(dp[i][j],dp[i+1][ndist+j]+mem[ndist+j-1]-mem[j-1]);\n                else\n                    dp[i][j]=min(dp[i][j],dp[i+1][ndist+j]+mem[ndist+j-1]);\n            }\n        }\n        printf(\"%.10f\\n\",dp[0][0]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n \ninline double calc(int x, int r, double v, double e, double f) {\n\tif(x >= r) return 1.0 / (v - e * (x - r));\n\treturn 1.0 / (v - f * (r - x));\n}\n \nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n \n\tfor(int n; cin >> n && n;) {\n\t\tvector<int> a(n + 1, 0);\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n \n\t\tdouble b;\n\t\tcin >> b;\n \n\t\tint r;\n\t\tdouble v, e, f;\n\t\tcin >> r >> v >> e >> f;\n \n\t\tvector<vector<double>> dp(n + 1, vector<double>(n + 1, INT_MAX));\n\t\tdp[0][0] = 0.0;\n \n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j <= i; ++j) {\n\t\t\t\tchmin(dp[i][i], dp[i][j] + b);\n \n\t\t\t\tdouble next_cost = 0.0;\n\t\t\t\tfor(int x = a[i]; x < a[i + 1]; ++x) {\n\t\t\t\t\tnext_cost += calc(x - a[j], r, v, e, f);\n\t\t\t\t}\n\n\t\t\t\tchmin(dp[i + 1][j], dp[i][j] + next_cost);\n\t\t\t}\n\t\t}\n \n\t\tcout << *min_element(dp[n].begin(), dp[n].end()) << endl;\n\t}\n \n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\n#include<cassert>\n#include<queue>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 101\n#define inf (1<<29)\nusing namespace std;\nint a[MAX];\nint A[10001];\nint n;\ndouble b,r,v,e,f;\ndouble mincost[MAX][10001];\n\nstruct P\n{\n  int last;\n  double x,cost,now;\n  P(double now=-1,double x=-1,double cost=-1,int last=-1):now(now),x(x),cost(cost),last(last){}\n  bool operator < (const P &a)const\n  {\n    return cost >= a.cost;\n  }\n};\n\ndouble getCost(double x)\n{\n  if(x >= r)return 1.0/(v - e * (x - r));\n            return 1.0/(v - f * (r - x));    \n}\n\nvoid dijkstra()\n{\n  double ans = inf;\n  rep(i,n)rep(j,10001)mincost[i][j] = inf;\n  mincost[0][0] = 0;\n\n  priority_queue<P> Q;\n  Q.push(P(0,0,0,0));\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      if(p.now >= a[n-1])\n\t{\n\t  ans = min(ans,p.cost);\n\t  continue;\n\t}    \n\n      if(ans <= p.cost)continue;\n\n      assert(0 <= p.cost);\n      double ncost = p.cost + getCost(p.x);\n      assert(0 <= ncost);\n\n      if(mincost[p.last][(int)p.now+1] > ncost)\n\t{\n\t  mincost[p.last][(int)p.now+1] = ncost;\n\t  Q.push(P(p.now+1,p.x+1,ncost,p.last));\n\t}\n\n      if(A[(int)p.now+1] != -1)\n\t{\n\t  double change_cost = (A[(int)p.now+1]==n?0:b);\n\t  ncost += change_cost;\n\t  Q.push(P(p.now+1,0,ncost,A[(int)p.now+1]));\n\t}\n\n    }\n\n  cout << setiosflags(ios::fixed) << setprecision(4) << ans << endl;\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      rep(i,10001)A[i] = -1;\n      rep(i,n)\n\t{\n\t  cin >> a[i];\t \n\t  A[a[i]] = i+1; \n\t}\n      cin >> b >> r >> v >> e >> f;\n   \n\n      dijkstra();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ i=0;i<(int__)(j);i++)\n\nbool solve(){\n    int n;cin>>n;\n    if(n==0)return false;\n    vector<int> a(n);\n    rep(i,n)cin>>a[i];\n    double b;\n    int r;\n    double v,e,f;\n    cin>>b>>r>>v>>e>>f;\n\n    vector<double> interval_time(a[n-1]+1);\n    interval_time[0]=0;\n    rep(x,interval_time.size()-1){\n        interval_time[x+1] = interval_time[x];\n        if(x>=r)interval_time[x+1] += 1.0/(v - e * (double)(x-r));\n        else interval_time[x+1] += 1.0/(v - f * (double)(r-x));\n    }\n    \n    vector<double> DP(n);\n    rep(i,n){\n        DP[i]=interval_time[a[i]];\n        rep(j,i){\n            DP[i] = min(DP[i] , DP[j] + interval_time[a[i]-a[j]] + b);\n        }\n    }\n    printf(\"%.10f\\n\",DP.back());\n    \n    return true;\n}\n\nint main()\n{\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\ndouble compute_next_x_duration(double x, double r, double v, double e, double f){\n  if(x >= r){\n    return 1.0 / (v - e * (x - r));\n  }\n  else{\n    return 1.0 / (v - f * (r - x));\n  }\n}\n\ndouble compute_duration(double from, double to, double r, double v, double e, double f){\n  double sum = 0;\n  \n  for(int pos = 0; pos < to - from; pos++){\n    sum += compute_next_x_duration(pos,r,v,e,f);\n  }\n  return sum;\n}\n\n\ndouble dp[101][101]; // dp[current_i][last_change_pos]\n\nint main(){\n  int num_of_checkpoints;\n  while(~scanf(\"%d\",&num_of_checkpoints)){\n    if(num_of_checkpoints == 0) break;\n\n    vector<int> checkpoints;\n    checkpoints.push_back(0);\n    for(int checkpoint_i = 0; checkpoint_i < num_of_checkpoints; checkpoint_i++){\n      int pos;\n      scanf(\"%d\",&pos);\n      checkpoints.push_back(pos);\n    }\n    double tire_change_time;\n    scanf(\"%lf\",&tire_change_time);\n    double r,v,e,f;\n    scanf(\"%lf %lf %lf %lf\",&r,&v,&e,&f);\n\n    fill((double*)dp,(double*)dp + 101 * 101,1000000000000.0);\n    dp[0][0] = 0;\n    for(int current_i = 0; current_i < checkpoints.size(); current_i++){\n      for(int prev_i = 0; prev_i < current_i; prev_i++){\n        // x is a nonnegative integer denoting the distance (in kilometers) \n        // from the latest checkpoint where tires are changed\n        \n        dp[current_i][prev_i]\n          = min(dp[prev_i][prev_i]\n                + compute_duration(checkpoints[prev_i],checkpoints[current_i],r,v,e,f),\n                dp[current_i][prev_i]);\n\n        dp[current_i][current_i]\n          = min(dp[prev_i][prev_i]\n                + compute_duration(checkpoints[prev_i],checkpoints[current_i],r,v,e,f)\n                + tire_change_time,\n                dp[current_i][current_i]);\n      }\n    }\n\n    double res = numeric_limits<double>::max();\n    for(int i = 0; i < checkpoints.size(); i++){\n      res = min(res,dp[checkpoints.size()-1][i]);\n    }\n    printf(\"%lf\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define N_MAX 105\n#define X_MAX 10010\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P > P1;\nvoid dijkstra();\ndouble Cal(int,int);\nint n,a[N_MAX],r;\ndouble b,v,e,f,dp[X_MAX][N_MAX];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  for(int i=0;i<=X_MAX;i++)\n    for(int j=0;j<n;j++) dp[i][j]=INF;\n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  dp[0][0]=Cal(0,a[0]);\n  Q.push(make_pair(dp[0][0],make_pair(a[0],1)));\n  while(!Q.empty()){\n    P1 v=Q.top();\n    Q.pop();\n    double t=v.first;\n    int uy=v.second.first,ux=v.second.second;\n    int ncny=uy+a[ux]-a[ux-1];\n    double nccal=Cal(uy,ncny);\n    if(dp[ncny][ux]>t+nccal){\n      dp[ncny][ux]=t+nccal;\n      if(ux!=n-1) Q.push(make_pair(dp[ncny][ux],make_pair(ncny,ux+1)));\n    }\n    int cny=a[ux]-a[ux-1];\n    double ccal=Cal(0,cny)+b;\n    if(dp[cny][ux]>t+ccal){\n      dp[cny][ux]=t+ccal;\n      if(ux!=n-1) Q.push(make_pair(dp[cny][ux],make_pair(cny,ux+1)));\n    }\n  }\n  double mincost=INF;\n  for(int i=0;i<=a[n-1];i++) mincost=min(mincost,dp[i][n-1]);\n  cout<<mincost<<endl;\n}\n\ndouble Cal(int begin,int end){\n  double ret=0;\n  for(int i=begin;i<end;i++){\n    if(i>=r) ret+=1.0/(1.0*v-1.0*e*(1.0*i-1.0*r));\n    else ret+=1.0/(1.0*v-1.0*f*(1.0*r-1.0*i));\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 101\n#define inf (1<<29)\nusing namespace std;\nint a[MAX];\nint A[10001];\nint n;\ndouble b,r,v,e,f;\ndouble mincost[MAX][10001];\n\nstruct P\n{\n  int last;\n  double x,cost,now;\n  P(double now=-1,double x=-1,double cost=-1,int last=-1):now(now),x(x),cost(cost),last(last){}\n  bool operator < (const P &a)const\n  {\n    return cost < a.cost;\n  }\n};\n\ndouble getCost(double x)\n{\n  if(x >= r)return 1.0/(v - e * (x - r));\n            return 1.0/(v - f * (r - x));    \n}\n\nvoid dijkstra()\n{\n  rep(i,MAX)rep(j,10001)mincost[i][j] = inf;\n  priority_queue<P> Q;\n  Q.push(P(0,0,0,0));\n  mincost[0][0] = 0;\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n     \n      if(p.now >= a[n-1])continue;\n\n      double ncost = p.cost + getCost((int)p.x);//+1\n      \n      if(mincost[p.last][(int)p.now+1] > ncost)\n\t{\n\t  mincost[p.last][(int)p.now+1] = ncost;\n\t  Q.push(P(p.now+1,p.x+1,ncost,p.last));\n\t}\n\n      if(A[(int)p.now+1] != -1)\n\t{\n\t  double change_cost = (A[(int)p.now+1] == n-1?0:b);\n\t  Q.push(P(p.now+1,0,ncost+change_cost,A[(int)p.now+1]));\n\t}\n    }\n  double ans = inf;\n  rep(i,MAX)ans = min(ans,mincost[i][a[n-1]]);\n  cout << setiosflags(ios::fixed) << setprecision(4) << ans << endl;\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      rep(i,10001)A[i] = -1;\n      rep(i,n)\n\t{\n\t  cin >> a[i];\n\t  A[a[i]] = i; \n\t}\n      cin >> b >> r >> v >> e >> f;\n   \n      dijkstra();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (not n) break;\n        vector<int> a(n); repeat (i,n) cin >> a[i];\n        double b; cin >> b;\n        int r; double v, e, f; cin >> r >> v >> e >> f;\n        vector<double> ts(a.back()+1);\n        ts[0] = 0;\n        repeat (x,a.back()) {\n            ts[x+1] = ts[x] + (x >= r\n                ? 1 / (v - e *(double) (x - r))\n                : 1 / (v - f *(double) (r - x)));\n        }\n        vector<double> dp(n+1);\n        dp[0] = 0;\n        repeat_from (j,1,n+1) dp[j] = ts[a[j-1]];\n        repeat_from (i,1,n+1) {\n            repeat_from (j,i+1,n+1) {\n                int x = a[j-1] - a[i-1];\n                dp[j] = min(dp[j], dp[i] + ts[x] + b);\n            }\n        }\n        printf(\"%.6lf\\n\", dp[n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ndouble const inf = 1e20;\n\nint a[200],n;\ndouble dp[200];\ndouble d[10001];\nint main(){\n    while(cin>>n && n){\n        rep(i,n)cin>>a[i+1];\n        a[0]=0;\n        double b,r,v,e,f;\n        cin>>b;\n        cin>>r>>v>>e>>f;\n        d[0]=0;\n        rep(i,10000){\n            if(i>=r)d[i+1] = d[i]+1./(v-e*(i-r));\n            else d[i+1] = d[i]+1./(v-f*(r-i));\n        }\n        rep(i,200)dp[i]=inf;\n        dp[0]=0;\n        for(int i=1;i<=n;i++){\n            for(int j=0;j<i;j++){\n                double t = dp[j]+d[a[i]-a[j]];\n                if(j!=0)t+=b;\n                dp[i] = min(dp[i], t);\n            }\n        }\n        printf(\"%.10lf\\n\", dp[n]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#define N_MAX 105\n#define X_MAX 10010\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P > P1;\nvoid dijkstra();\ndouble Cal(int,int);\nint n,a[N_MAX],r;\ndouble b,v,e,f,dp[X_MAX][N_MAX];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  for(int i=0;i<X_MAX;i++)\n    for(int j=0;j<n;j++) dp[i][j]=INF;\n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  dp[0][0]=Cal(0,a[0]);\n  if(n!=1) Q.push(make_pair(dp[0][0],make_pair(a[0],1)));\n  while(!Q.empty()){\n    P1 v=Q.top();\n    Q.pop();\n    double t=v.first;\n    int uy=v.second.first,ux=v.second.second;\n    int ncny=uy+a[ux]-a[ux-1];\n    double nccal=Cal(uy,ncny);\n    if(dp[ncny][ux]>t+nccal){\n      dp[ncny][ux]=t+nccal;\n      if(ux!=n-1) Q.push(make_pair(dp[ncny][ux],make_pair(ncny,ux+1)));\n    }\n    int cny=a[ux]-a[ux-1];\n    double ccal=Cal(0,cny)+b;\n    if(dp[cny][ux]>t+ccal){\n      dp[cny][ux]=t+ccal;\n      if(ux!=n-1) Q.push(make_pair(dp[cny][ux],make_pair(cny,ux+1)));\n    }\n  }\n  double mincost=INF;\n  for(int i=0;i<=a[n-1];i++) mincost=min(mincost,dp[i][n-1]);\n  printf(\"%.4f\\n\",mincost);\n}\n\ndouble Cal(int begin,int end){\n  double ret=0;\n  for(int i=begin;i<end;i++){\n    if(i>=r) ret+=1.0/(1.0*v-1.0*e*(1.0*i-1.0*r));\n    else ret+=1.0/(1.0*v-1.0*f*(1.0*r-1.0*i));\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#define N_MAX 105\n#define X_MAX 10010\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P > P1;\nvoid dijkstra();\ndouble Cal(int,int);\nint n,a[N_MAX],r;\ndouble b,v,e,f,dp[X_MAX][N_MAX];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  for(int i=0;i<X_MAX;i++)\n    for(int j=0;j<n;j++) dp[i][j]=INF;\n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  dp[0][0]=Cal(0,a[0]);\n  Q.push(make_pair(dp[0][0],make_pair(a[0],1)));\n  while(!Q.empty()){\n    P1 v=Q.top();\n    Q.pop();\n    double t=v.first;\n    int uy=v.second.first,ux=v.second.second;\n    int ncny=uy+a[ux]-a[ux-1];\n    double nccal=Cal(uy,ncny);\n    if(ncny<0) continue;\n    if(dp[ncny][ux]>t+nccal){\n      dp[ncny][ux]=t+nccal;\n      if(ux!=n-1) Q.push(make_pair(dp[ncny][ux],make_pair(ncny,ux+1)));\n    }\n    int cny=a[ux]-a[ux-1];\n    if(cny<0) continue;\n    double ccal=Cal(0,cny)+b;\n    if(dp[cny][ux]>t+ccal){\n      dp[cny][ux]=t+ccal;\n      if(ux!=n-1) Q.push(make_pair(dp[cny][ux],make_pair(cny,ux+1)));\n    }\n  }\n  double mincost=INF;\n  for(int i=0;i<=a[n-1];i++) mincost=min(mincost,dp[i][n-1]);\n  printf(\"%.4f\\n\",mincost);\n}\n\ndouble Cal(int begin,int end){\n  double ret=0;\n  for(int i=begin;i<end;i++){\n    if(i>=r) ret+=1.0/(1.0*v-1.0*e*(1.0*i-1.0*r));\n    else ret+=1.0/(1.0*v-1.0*f*(1.0*r-1.0*i));\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<int> a(n+1, 0);\n        for(int i=1; i<=n; ++i)\n            cin >> a[i];\n\n        int r;\n        double b, v, e, f;\n        cin >> b >> r >> v >> e >> f;\n\n        vector<double> time(a[n]+1, 0.0);\n        for(int i=0; i<a[n]; ++i){\n            time[i+1] = time[i];\n            if(i >= r)\n                time[i+1] += 1.0 / (v - e * (i - r));\n            else\n                time[i+1] += 1.0 / (v - f * (r - i));\n        }\n\n        vector<double> dp(n+1, DBL_MAX/100);\n        dp[0] = -b;\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<=n; ++j)\n                dp[j] = min(dp[j], dp[i] + time[a[j]-a[i]] + b);\n        }\n\n        printf(\"%.10f\\n\", dp[n]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  file : /1262.comp.cpp\n  date : 2015-10-19\n  summary :\n  {\n  ??\\???\n  n         0< . <=100   ?????§????????????????????°\n  a1 ... an 0< . <=10^4  start???????????§??????????????????????????¢\n  b         0< . < 100.0 ?£??????????\n  r v e f   0< . , v-e*(an-1-r)>=0.01 , v-f*r >=0.01 ?????????????????????\n\n  ????????§????????????????????§????????§????£?????????????\n  x=0 ?????? x=an ?????§???????????????????????????????±???????\n  }\n  status :\n  {\n  \n  }\n  memo :\n  {\n  \n  }\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ i=0;i<(int__)(j);i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(int__)(k);i++)\n#define all(v) v.begin(),v.end()\n\n\nbool solve(){\n    int n;cin>>n;\n    if(n==0)return false;\n    vector<int> a(n);\n    rep(i,n)cin>>a[i];\n    double b,v,e,f;\n    int r;\n    cin>>b>>r>>v>>e>>f;\n\n    vector<double> interval_time(a[n-1]+1);\n    interval_time[0]=0;\n    rep(x,interval_time.size()){\n        interval_time[x+1] = interval_time[x];\n        if(x>=r)interval_time[x+1] += 1.0/(v - e * (double)(x-r));\n        else interval_time[x+1] += 1.0/(v - f * (double)(r-x));\n    }\n\n    \n    vector<double> DP(n);\n    rep(i,n){\n        DP[i]=interval_time[a[i]];\n        rep(j,i){\n            DP[i] = min(DP[i] , DP[j] + interval_time[a[i]-a[j]] + b);\n        }\n    }\n\n    printf(\"%.10f\\n\",DP.back());\n    \n    return true;\n}\n\nint main()\n{\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <vector>\n#include <map>\n#define maxn 110\n#define maxl 1000000000\n#define mod 1000000007\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint a[maxn];\ndouble ans[maxn];\n\nbool solve(){\n\tint n,i,j,r,k;\n\tdouble b,v,e,f,temp2,temp;\n\tscanf(\"%d\",&n);\n\tif(n==0)return false;\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%d\",&a[i]);\n\t\tans[i]=1e30;\n\t}\n\tscanf(\"%lf%d%lf%lf%lf\",&b,&r,&v,&e,&f);\n\tans[0]=-b;\n\tfor(i=0;i<n;++i){\n\t\ttemp=ans[i]+b;\n\t\tfor(j=i+1;j<=n;++j){\n\t\t\tfor(k=a[j-1];k<a[j];++k){\n\t\t\t\tif(k-a[i]>=r)temp2=1/(v-e*(k-a[i]-r));\n\t\t\t\telse temp2=1/(v-f*(r-(k-a[i])));\n\t\t\t\ttemp+=temp2;\n\t\t\t}\n\t\t\tans[j]=min(temp,ans[j]);\n\t\t}\n\t}\n\tprintf(\"%.4f\\n\",ans[n]);\n\treturn true;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nvoid update(double& a, double b){\n  a = min(a, b);\n}\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    vector<double> a(N + 1, 0);\n    double b, r, v, e, f;\n    REP(i, N) cin >> a[i + 1];\n    cin >> b >> r >> v >> e >> f;\n    double dp[101][101] = {}; // checkpoint i を終えた時間 (最後のタイヤ交換は checkpoint j)\n    REP(i, N + 1) REP(j, N + 1) dp[i][j] = INF;\n    dp[0][0] = 0;\n    double time[10001] = {};\n    for(int x = 0; x < 10000; x++){\n      time[x + 1] = time[x] + (x >= r ? (1.0 / (v - e * (x - r))) : (1.0 / (v - f * (r - x))));\n    }\n    for(int i = 0; i < N; i++){\n      for(int j = 0; j <= i; j++){\n        int d1 = a[i] - a[j];\n        int d2 = a[i + 1] - a[j];\n        update(dp[i + 1][i + 1], dp[i][j] + time[d2] - time[d1] + b);\n        update(dp[i + 1][j], dp[i][j] + time[d2] - time[d1]);\n      }\n    }\n    double ans = INF;\n    for(int i = 0; i <= N; i++) ans = min(ans, dp[N][i]);\n    printf(\"%.12lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nint n;\nint a[100];\ndouble b;\nint r;\ndouble v, e, f;\n\nclass State {\npublic:\n  int pos;\n  double sec;\n  State();\n  State(int pos, double sec) : pos(pos), sec(sec) {}\n  bool operator <(const State &s) const {\n    return sec > s.sec;\n  }\n};\n\nState move(State s, int to) {\n  State ns = s;\n  ns.sec = s.sec;\n  ns.pos = to;\n\n  int dist = (s.pos == -1) ? a[to] : a[to]-a[s.pos];\n\n  int tmp = dist - r;\n\n  for(int x = 0; x < dist; ++x) {\n    if(x >= r) {\n      ns.sec += 1.0/(v-e*(x-r));\n    } else if(x < r) {\n      ns.sec += 1.0/(v-f*(r-x));\n    }\n  }\n  return ns;\n}\n\ndouble solve() {\n  priority_queue <State> que;\n  State s(-1, 0);\n  que.push(s);\n  while(!que.empty()) {\n    s = que.top();\n    que.pop();\n    if(s.pos == n-1) return s.sec;\n\n    if(s.pos != -1) s.sec += b;\n    for(int i = s.pos+1; i < n; ++i) {\n      que.push(move(s, i));\n    }\n  }\n  return -1;\n}\n\nmain() {\n  while((cin >> n) && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> a[i];\n    }\n    cin >> b;\n    cin >> r >> v >> e >> f;\n    printf(\"%.4f\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//21\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int a;\n  double t;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    int a[101]={};\n    for(int i=1;i<=n;i++){\n      cin>>a[i];\n    }\n    int r;\n    double b,v,e,f;\n    cin>>b>>r>>v>>e>>f;\n    S is={0,0};\n    priority_queue<S> que;\n    que.push(is);\n    bool p[101]={};\n    for(;;){\n      S c=que.top();\n      if(c.a==n)break;\n      que.pop();\n      if(p[c.a]++)continue;\n      int cp=a[c.a];\n      double t=c.t;\n      for(int np=c.a+1;np<=n;np++){\n\twhile(cp!=a[np]){\n\t  int x=cp-a[c.a];\n\t  t+=(x>=r)?1/(v-e*(x-r)):1/(v-f*(r-x));\n\t  cp++;\n\t}\n\tS n={np,t+b};\n\tque.push(n);\n      }\n    }\n    cout<<fixed<<que.top().t-b<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(a) (cerr << #a << \" = \" << (a) << endl)\n\n#define REP(i,a,b) for(int i=(a);i < (int)(b); i++)\n#define rep(i,n) REP(i,0,n)\n#define ALL(v) begin(v), end(v)\n\ndouble calc(int x, int r, double v, double e, double f) {\n  if(x >= r) return 1.0 / (v - e * (x - r));\n  return 1.0 / (v - f * (r - x));\n}\n\nint main(){\n  cout.setf(ios::fixed);\n  cout.precision(10);\n\n  for(int n; cin >> n && n;) {\n    vector<int> a(n + 1, 0);\n    for(int i = 1; i <= n; ++i) {\n      cin >> a[i];\n    }\n\n    double b;\n    cin >> b;\n\n    int r;\n    double v, e, f;\n    cin >> r >> v >> e >> f;\n\n    vector<vector<double>> dp(n + 1, vector<double>(n + 1, INT_MAX));\n    dp[0][0] = 0;\n\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j <= i; ++j) {\n\tif(dp[i][j] == INT_MAX) continue;\n\n\tdp[i][i] = min(dp[i][i], dp[i][j] + b);\n\n\tdouble next_cost = 0.0;\n\tfor(int x = a[i]; x < a[i + 1]; ++x) {\n\t  next_cost += calc(x - a[j], r, v, e, f);\n\t}\n\n\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + next_cost);\n      }\n    }\n\n    double ans = INT_MAX;\n    for(int i = 0; i <= n; ++i) {\n      ans = min(ans, dp[n][i]);\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define N_MAX 105\n#define X_MAX 100010\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P > P1;\nvoid dijkstra();\ndouble Cal(int,int);\nint n,a[N_MAX],r;\ndouble b,v,e,f,dp[X_MAX][N_MAX];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  for(int i=0;i<X_MAX;i++)\n    for(int j=0;j<n;j++) dp[i][j]=INF;\n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  dp[0][0]=Cal(0,a[0]);\n  Q.push(make_pair(dp[0][0],make_pair(a[0],1)));\n  while(!Q.empty()){\n    P1 v=Q.top();\n    Q.pop();\n    double t=v.first;\n    int uy=v.second.first,ux=v.second.second;\n    int ncny=uy+a[ux]-a[ux-1];\n    double nccal=Cal(uy,ncny);\n    if(dp[ncny][ux]>t+nccal){\n      dp[ncny][ux]=t+nccal;\n      if(ux!=n-1) Q.push(make_pair(dp[ncny][ux],make_pair(ncny,ux+1)));\n    }\n    int cny=a[ux]-a[ux-1];\n    double ccal=Cal(0,cny)+b;\n    if(dp[cny][ux]>t+ccal){\n      dp[cny][ux]=t+ccal;\n      if(ux!=n-1) Q.push(make_pair(dp[cny][ux],make_pair(cny,ux+1)));\n    }\n  }\n  double mincost=INF;\n  for(int i=0;i<=a[n-1];i++) mincost=min(mincost,dp[i][n-1]);\n  cout<<mincost<<endl;\n}\n\ndouble Cal(int begin,int end){\n  double ret=0;\n  for(int i=begin;i<end;i++){\n    if(i>=r) ret+=1.0/(1.0*v-1.0*e*(1.0*i-1.0*r));\n    else ret+=1.0/(1.0*v-1.0*f*(1.0*r-1.0*i));\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nint n;\nint a[101];\ndouble b;\nint r;\ndouble v, e, f;\n\nclass State {\npublic:\n  int pos;\n  double sec;\n  State();\n  State(int pos, double sec) : pos(pos), sec(sec) {}\n  bool operator <(const State &s) const {\n    return sec > s.sec;\n  }\n};\n\ndouble cost[101][101];\n\nvoid make() {\n  for(int i = 0; i <= n; ++i) {\n    for(int j = i+1; j <= n; ++j) {\n      double tmp = 0;\n      int dist = a[j]-a[i];\n      for(int x = 0; x < dist; ++x) {\n\tif(x >= r) {\n\t  tmp += 1.0/(v-e*(x-r));\n\t} else if(x < r) {\n\t  tmp += 1.0/(v-f*(r-x));\n\t}\n      }\n      cost[i][j] = tmp;\n    }\n  }\n}\n\n#define INF 9999999\ndouble solve2() {\n  double dp[101];\n  fill(dp, dp+101, INF);\n  dp[0] = 0;\n  make();\n  for(int i = 1; i <= n; ++i) {\n    for(int j = 0; j < i; ++j) {\n      double tmp = dp[j] + cost[j][i];\n      if(j != 0) tmp += b;\n      dp[i] = min(dp[i], tmp);\n    }\n  }\n  return dp[n];\n}\n\nmain() {\n  while((cin >> n) && n) {\n    a[0] = 0;\n    for(int i = 1; i <= n; ++i) {\n      cin >> a[i];\n    }\n    cin >> b;\n    cin >> r >> v >> e >> f;\n    printf(\"%.4f\\n\", solve2());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint a[101]={},r;\n\t\trep(i,n)\tscanf(\"%d\",a+i+1);\n\t\tdouble b,v,e,f;\tscanf(\"%lf%d%lf%lf%lf\",&b,&r,&v,&e,&f);\n\t\tn++;\n\n\t\tstatic double t[10001];\n\t\trep(x,a[n-1]){\n\t\t\tif(x<r)\tt[x+1]=t[x]+1/(v-f*(r-x));\n\t\t\telse\tt[x+1]=t[x]+1/(v-e*(x-r));\n\t\t}\n\n\t\tstatic double dp[101][101];\n\t\trep(i,n)rep(j,n)\tdp[i][j]=1e60;\n\t\tdp[0][0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\trep(j,i){\n\t\t\t\tint dis=a[i]-a[j];\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j][j]+t[dis]);\n\t\t\t\tdp[i][i]=min(dp[i][i],dp[i][j]+b);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.9f\\n\",*min_element(dp[n-1],dp[n-1]+n));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define N_MAX 102\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P > P1;\nvoid dijkstra();\ndouble Cal(int,int);\nint n,a[N_MAX],r;\ndouble b,v,e,f,dp[N_MAX*N_MAX][N_MAX];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  for(int i=0;i<=N_MAX*N_MAX;i++)\n    for(int j=0;j<n;j++) dp[i][j]=INF;\n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  dp[0][0]=Cal(0,a[0]);\n  Q.push(make_pair(dp[0][0],make_pair(a[0],1)));\n  while(!Q.empty()){\n    P1 v=Q.top();\n    Q.pop();\n    double t=v.first;\n    int uy=v.second.first,ux=v.second.second;\n    int ncny=uy+a[ux]-a[ux-1];\n    double nccal=Cal(uy,ncny);\n    if(dp[ncny][ux]>t+nccal){\n      dp[ncny][ux]=t+nccal;\n      if(ux!=n-1) Q.push(make_pair(dp[ncny][ux],make_pair(ncny,ux+1)));\n    }\n    int cny=a[ux]-a[ux-1];\n    double ccal=Cal(0,cny)+b;\n    if(dp[cny][ux]>t+ccal){\n      dp[cny][ux]=t+ccal;\n      if(ux!=n-1) Q.push(make_pair(dp[cny][ux],make_pair(cny,ux+1)));\n    }\n  }\n  double mincost=INF;\n  for(int i=0;i<=a[n-1];i++) mincost=min(mincost,dp[i][n-1]);\n  cout<<mincost<<endl;\n}\n\ndouble Cal(int begin,int end){\n  double ret=0;\n  for(int i=begin;i<end;i++){\n    if(i>=r) ret+=1.0/(1.0*v-1.0*e*(1.0*i-1.0*r));\n    else ret+=1.0/(1.0*v-1.0*f*(1.0*r-1.0*i));\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (not n) break;\n        vector<int> a(n); repeat (i,n) cin >> a[i];\n        double b; cin >> b;\n        int r; double v, e, f; cin >> r >> v >> e >> f;\n        vector<double> ts(a.back()+1);\n        ts[0] = 0;\n        repeat (x,a.back()) {\n            ts[x+1] = ts[x] + (x >= r\n                ? 1 / (v - e *(double) (x - r))\n                : 1 / (v - f *(double) (r - x)));\n        }\n        vector<double> dp(n+1);\n        dp[0] = 0;\n        repeat_from (j,1,n+1) dp[j] = ts[a[j-1]];\n        repeat_from (i,1,n+1) {\n            repeat_from (j,i+1,n+1) {\n                int x = a[j-1] - a[i-1];\n                dp[j] = min(dp[j], dp[i] + ts[x] + b);\n            }\n        }\n        cout << dp[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define N_MAX 105\n#define X_MAX 10010\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P > P1;\nvoid dijkstra();\ndouble Cal(int,int);\nint n,a[N_MAX],r;\ndouble b,v,e,f,dp[X_MAX][N_MAX];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  for(int i=0;i<X_MAX;i++)\n    for(int j=0;j<n;j++) dp[i][j]=INF;\n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  dp[0][0]=Cal(0,a[0]);\n  Q.push(make_pair(dp[0][0],make_pair(a[0],1)));\n  while(!Q.empty()){\n    P1 v=Q.top();\n    Q.pop();\n    double t=v.first;\n    int uy=v.second.first,ux=v.second.second;\n    int ncny=uy+a[ux]-a[ux-1];\n    double nccal=Cal(uy,ncny);\n    if(ncny<0) continue;\n    if(dp[ncny][ux]>t+nccal){\n      dp[ncny][ux]=t+nccal;\n      if(ux!=n-1) Q.push(make_pair(dp[ncny][ux],make_pair(ncny,ux+1)));\n    }\n    int cny=a[ux]-a[ux-1];\n    if(cny<0) continue;\n    double ccal=Cal(0,cny)+b;\n    if(dp[cny][ux]>t+ccal){\n      dp[cny][ux]=t+ccal;\n      if(ux!=n-1) Q.push(make_pair(dp[cny][ux],make_pair(cny,ux+1)));\n    }\n  }\n  double mincost=INF;\n  for(int i=0;i<=a[n-1];i++) mincost=min(mincost,dp[i][n-1]);\n  cout<<mincost<<endl;\n}\n\ndouble Cal(int begin,int end){\n  double ret=0;\n  for(int i=begin;i<end;i++){\n    if(i>=r) ret+=1.0/(1.0*v-1.0*e*(1.0*i-1.0*r));\n    else ret+=1.0/(1.0*v-1.0*f*(1.0*r-1.0*i));\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tvector<int> a(n + 1);\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t}\n\t\t\n\t\tint r;\n\t\tdouble b, v, e, f;\n\t\tif( scanf(\"%lf%d%lf%lf%lf\", &b, &r, &v, &e, &f) != 5 ){\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<double> t(a[n] + 1);\n\t\tfor(int x = 0; x < a[n]; ++x){\n\t\t\tif( x >= r ){\n\t\t\t\tt[x + 1] = t[x] + 1.0 / (v - e * (x - r) );\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt[x + 1] = t[x] + 1.0 / (v - f * (r - x) );\n\t\t\t}\n\t\t}\n\n\t\tvector<double> dp(n + 1, 1e99);\n\t\tdp[0] = -b;\n\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tfor(int j = 0; j < i; ++j){\n\t\t\t\tint x = a[i] - a[j];\n\t\t\t\tdp[i] = min(dp[i], dp[j] + b + t[x]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%f\\n\", dp[n]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n \ninline double calc(int x, int r, double v, double e, double f) {\n\tif(x >= r) return 1.0 / (v - e * (x - r));\n\treturn 1.0 / (v - f * (r - x));\n}\n \nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n \n\tfor(int n; cin >> n && n;) {\n\t\tvector<int> a(n + 1, 0);\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n \n\t\tdouble b;\n\t\tcin >> b;\n \n\t\tint r;\n\t\tdouble v, e, f;\n\t\tcin >> r >> v >> e >> f;\n \n\t\tvector<vector<double>> dp(n + 1, vector<double>(n + 1, INT_MAX));\n\t\tdp[0][0] = 0.0;\n \n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j <= i; ++j) {\n\t\t\t\tchmin(dp[i][i], dp[i][j] + b);\n \n\t\t\t\tdouble next_cost = 0.0;\n\t\t\t\tfor(int x = a[i]; x < a[i + 1]; ++x) {\n\t\t\t\t\tnext_cost += calc(x - a[j], r, v, e, f);\n\t\t\t\t}\n\n\t\t\t\tchmin(dp[i + 1][j], dp[i][j] + next_cost);\n\t\t\t}\n\t\t}\n \n\t\tcout << *min_element(dp[n].begin(), dp[n].end()) << endl;\n\t}\n \n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n#define REP(i,n)for(int i=0;i<(int)n;++i)\nint main(){int n;while(cin>>n,n){int a[n+1];a[0]=0;REP(i,n)cin>>a[i+1];double b,r,v,e,f,tt[10001];cin>>b>>r>>v>>e>>f;tt[0]=0;REP(x,10001)tt[x+1]=tt[x]+1/(v-(x>=r?e*(x-r):f*(r-x)));vector<double>dp(n+1,1<<29);dp[0]=0;REP(i,n)for(int j=i+1;j<n+1;++j)dp[j]=min(dp[j],dp[i]+tt[a[j]-a[i]]+(i?b:0));printf(\"%.12f\\n\",dp[n]);}}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MAXN 10010\ndouble v,e,f,b;\nint dis[MAXN];\ndouble dp[MAXN],time[MAXN];\nint r,n;\nvoid calc()\n{\n    int i;\n    memset(time,0,sizeof time);\n    for (i = 0; i <= dis[n]+1; i++)\n    {\n        double tmp;\n        if (i >= r) tmp = 1.0 / (v - e * (i - r));\n        else tmp = 1.0 / (v - f * (r - i));\n        time[i+1] = time[i] + tmp;\n    }\n}\n\nint main() {\n    while (scanf(\"%d\", &n) && n)\n    {\n        memset(dp,0,sizeof dp);\n        memset(dis,0,sizeof dis);\n        for (int i = 1; i <= n; i++)\n            scanf(\"%d\", &dis[i]);\n        scanf(\"%lf\",&b);\n        scanf(\"%d%lf%lf%lf\",&r,&v,&e,&f);\n        calc();\n        double min;\n\n        for(int i = 1; i <= n; i++)\n        {\n            double tmp;\n            min = 10000000000;\n            for(int j = 0; j < i; j++)\n                if ((tmp = dp[j] + time[dis[i] - dis[j]]) < min)\n                    min = tmp;\n            dp[i] = min + b;\n        }\n        printf(\"%.4lf\\n\", dp[n] - b);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define N_MAX 105\n#define X_MAX 10010\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P > P1;\nvoid dijkstra();\ndouble Cal(int,int);\nint n,a[N_MAX],r;\ndouble b,v,e,f,dp[X_MAX][N_MAX];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  for(int i=0;i<X_MAX;i++)\n    for(int j=0;j<n;j++) dp[i][j]=INF;\n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  dp[0][0]=Cal(0,a[0]);\n  Q.push(make_pair(dp[0][0],make_pair(a[0],1)));\n  while(!Q.empty()){\n    P1 v=Q.top();\n    Q.pop();\n    double t=v.first;\n    int uy=v.second.first,ux=v.second.second;\n    int ncny=uy+a[ux]-a[ux-1];\n    double nccal=Cal(uy,ncny);\n    if(dp[ncny][ux]>t+nccal){\n      dp[ncny][ux]=t+nccal;\n      if(ux!=n-1) Q.push(make_pair(dp[ncny][ux],make_pair(ncny,ux+1)));\n    }\n    int cny=a[ux]-a[ux-1];\n    double ccal=Cal(0,cny)+b;\n    if(dp[cny][ux]>t+ccal){\n      dp[cny][ux]=t+ccal;\n      if(ux!=n-1) Q.push(make_pair(dp[cny][ux],make_pair(cny,ux+1)));\n    }\n  }\n  double mincost=INF;\n  for(int i=0;i<=a[n-1];i++) mincost=min(mincost,dp[i][n-1]);\n  cout<<mincost<<endl;\n}\n\ndouble Cal(int begin,int end){\n  double ret=0;\n  for(int i=begin;i<end;i++){\n    if(i>=r) ret+=1.0/(1.0*v-1.0*e*(1.0*i-1.0*r));\n    else ret+=1.0/(1.0*v-1.0*f*(1.0*r-1.0*i));\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;\n#define fi first\n#define se second\n\nint n,a[10001];\ndouble tim[11111],dp[11111];\ndouble b,r,v,e,f;\n\nsigned main(){\n\twhile(cin>>n,n){\n\t\tr(i,11111)dp[i]=1e15;\n\t\ttim[0]=0;\n\t\tr(i,n)cin>>a[i];\n\t\tcin>>b>>r>>v>>e>>f;\n\t\tr(i,11100){\n\t\t\tif(i>=r) tim[i+1]= 1.0/(v-e*(double)(i-r)) + tim[i];\n\t\t\telse tim[i+1]= 1.0/(v-f*(double)(r-i)) + tim[i];\n\t\t}\n\t\tr(i,n)dp[i+1]=tim[a[i]];\n\t\tr(i,n){\n\t\t\tr(j,n){\n\t\t\t\tdp[j+1]=min(dp[j+1],dp[i+1]+tim[a[j]-a[i]]+b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.11f\\n\",dp[n]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#define N_MAX 105\n#define X_MAX 10010\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P > P1;\nvoid dijkstra();\ndouble Cal(int,int);\nint n,a[N_MAX],r;\ndouble b,v,e,f,dp[X_MAX][N_MAX];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  for(int i=0;i<X_MAX;i++)\n    for(int j=0;j<n;j++) dp[i][j]=INF;\n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  dp[0][0]=Cal(0,a[0]);\n  Q.push(make_pair(dp[0][0],make_pair(a[0],1)));\n  while(!Q.empty()){\n    P1 v=Q.top();\n    Q.pop();\n    double t=v.first;\n    int uy=v.second.first,ux=v.second.second;\n    int ncny=uy+a[ux]-a[ux-1];\n    double nccal=Cal(uy,ncny);\n    if(ncny<0) continue;\n    if(dp[ncny][ux]>t+nccal){\n      dp[ncny][ux]=t+nccal;\n      if(ux!=n-1) Q.push(make_pair(dp[ncny][ux],make_pair(ncny,ux+1)));\n    }\n    int cny=a[ux]-a[ux-1];\n    if(cny<0) continue;\n    double ccal=Cal(0,cny)+b;\n    if(dp[cny][ux]>t+ccal){\n      dp[cny][ux]=t+ccal;\n      if(ux!=n-1) Q.push(make_pair(dp[cny][ux],make_pair(cny,ux+1)));\n    }\n  }\n  double mincost=INF;\n  for(int i=0;i<=a[n-1];i++) mincost=min(mincost,dp[i][n-1]);\n  printf(\"%.4f\\n\",mincost);\n}\n\ndouble Cal(int begin,int end){\n  double ret=0;\n  for(int i=begin;i<end;i++){\n    if(i>=r) ret+=1.0/(1.0*v-1.0*e*(1.0*i-1.0*r));\n    else ret+=1.0/(1.0*v-1.0*f*(1.0*r-1.0*i));\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\ntypedef double D;\n\nint n,a[110],r;\nD b,v,e,f;\nD dp[10100][110];\nconst D EPS = 1e-8;\n\nint main(){\n  while(scanf(\"%d\",&n),n){\n    a[0] = 0;\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n    scanf(\"%lf%d%lf%lf%lf\",&b,&r,&v,&e,&f);\n\n    for(int i=0;i<=a[n];i++)\n      for(int j=0;j<=n;j++)dp[i][j] = 1e15;\n    dp[0][0] = 0;\n\n    int pos = 1;\n    for(int i=0;i<a[n];i++){\n      if(i==a[pos]){\n\tfor(int j=0;j<pos;j++){\n\t  if(dp[i][pos] > dp[i][j] + b + EPS){\n\t    dp[i][pos] = dp[i][j] + b;\n\t  }\n\t}\n\tpos++;\n      }\n\n      for(int j=0;j<=n;j++){\n\tint x = i-a[j];\n\tD cost = (x<r)?(1.0/(v-f*(r-x))):(1.0/(v-e*(x-r)));\n\tif(dp[i+1][j] > dp[i][j] + cost + EPS){\n\t  dp[i+1][j] = dp[i][j] + cost;\n\t}\n      }\n    }\n    \n    D res = 1e15;\n    for(int i=0;i<=n;i++){\n      if(res > dp[a[n]][i] + EPS)res = dp[a[n]][i];\n    }\n    printf(\"%.10lf\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<28)\nint n;\nint a[200],r;\ndouble b,v,e,f;\ndouble dp[200];\nint main(){\n  while(cin>>n&&n){\n    for(int i=1;i<=n;i++)cin>>a[i];\n    cin>>b;\n    cin>>r>>v>>e>>f;\n    for(int i=0;i<=n;i++)dp[i]=INF;\n    dp[0]=0;\n    a[0]=0;\n    for(int i=0;i<n;i++){\n      int x=0;\n      double sum=0;\n      for(int j=i+1;j<=n;j++){\n    while(a[i]+x<a[j]){\n      double d;\n      if(x>=r){\n        d=x-r;\n        sum += 1.0/(v-e*d);\n      }else{\n        d=r-x;\n        sum += 1.0/(v-f*d);\n      }\n      x++;\n    }\n    if(i!=0)dp[j]=min(dp[j],dp[i]+b+sum);\n    else dp[j]=min(dp[j],sum);\n      }\n    }\n \n    printf(\"%.6f\\n\",dp[n]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define INF 2000000\n#define t first\n#define x second\nusing namespace std;\ntypedef pair <double,int> P;\ndouble b,v,e,f;\nint r;\n\ndouble mk(int x) {\n  if(x >= r) return 1.0/(v-e*(x-r));\n  return  1.0/(v-f*(r-x));\n}\n\nint main() {\n  while(1) {\n    int n,a[110]={};\n    cin >> n;\n    if(n==0) break;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    cin >> b;\n    cin >> r >> v >> e >> f;\n    P dp[10100]={};\n    for(int i=1;i<=a[n];i++) dp[i] = make_pair(INF,0);\n\n    for(int i=0;i<n;i++) {\n      int tx;\n      double tt;\n      //No Change\n      tx=dp[a[i]].x,  tt=dp[a[i]].t;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt += k , tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n\n      //Change\n      tx= 0, tt=dp[a[i]].t+b;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt +=k; tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n      \n    }\n    printf(\"%.4f\\n\",dp[a[n]].t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define INF 10000000\n#define t first\n#define x second\nusing namespace std;\ntypedef pair <double,int> P;\ndouble b,r,v,e,f;\n\ndouble mk(int x) {\n  if(x >= r) return 1.0/(v-e*(1.0*x-r));\n  return  1.0/(v-f*(r-1.0*x));\n}\n\nint main() {\n  while(1) {\n    int n,a[101];\n    cin >> n;\n    if(n==0) break;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    \n    cin >> b;\n    cin >> r >> v >> e >> f;\n    P dp[10010]={};\n    for(int i=1;i<=a[n];i++) dp[i] = make_pair(INF,0);\n\n    for(int i=0;i<n;i++) {\n      int tx;\n      double tt;\n      //No Change\n      tx=dp[a[i]].x,  tt=dp[a[i]].t;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt += k , tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n\n      //Change\n      tx= 0, tt=dp[a[i]].t+b;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt +=k; tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n      \n    }\n    printf(\"%.4f\\n\",dp[a[n]].t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n// // ¹öª¢çÈ¢ê\nvector<Weight> dijkstra2(const Graph &g, int s) {\n  vector<Weight> dist(g.size(), INF);\n  dist[s] = 0;\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (dist[e.dst] < e.weight) continue;\n    FOR(f,g[e.dst]) {\n      if (dist[f->dst] > e.weight+f->weight) {\n        dist[f->dst] = e.weight+f->weight;\n        Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n      }\n    }\n  }\n  return dist;\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int a[n+1];\n    a[0] = 0;\n    REP(i, n)\n      cin >> a[i+1];\n    double b,r,v,e,f;\n    cin>>b>>r>>v>>e>>f;\n    double timetable[10001];\n    timetable[0] = 0;\n    REP(x, 10001) {\n      double t;\n      if (x >= r) t = 1.0/(v-e*(x-r));\n      else t = 1.0/(v-f*(r-x));\n      timetable[x+1] = timetable[x] + t;\n    }\n    \n    Graph g(n+1);\n    REP(i, n) {\n      for (int j=i+1; j<n+1; ++j) {\n        double t = 0;\n        if (i) t += b;\n        t += timetable[a[j]-a[i]];\n        g[i].push_back(Edge(i,j,t));\n      }\n    }\n    printf(\"%.12f\\n\", dijkstra2(g, 0)[n]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#define INF 105\n#define inf 0x0f0f0f0f\n\nusing namespace std;\nint A[INF],r;\ndouble F[INF],T[INF*INF],b,v,e,f;\nvoid Cost_time(int n)\n{\n    double t,j;\n    int i; T[0]=F[0]=0.0;\n    for (i=0;i<=A[n]+1;i++)\n    {\n        if (i>=r) t=1.0/(v-e*(i-r));\n        else t=1.0/(v-f*(r-i));\n        T[i+1]=T[i]+t;\n    }\n}\nint main()\n{\n    int i,j,n;\n    while (scanf(\"%d\",&n),n)\n    {\n        for (i=1;i<=n;i++)\n            scanf(\"%d\",&A[i]),F[i]=99999999;\n        scanf(\"%lf%d%lf%lf%lf\",&b,&r,&v,&e,&f);\n        Cost_time(n);\n        for (i=1;i<=n;i++)\n        {\n            for (j=0;j<i;j++)\n                F[i]=min(F[i],F[j]+b+T[A[i]-A[j]]);\n            F[i]+=b;\n        }\n        printf(\"%.4lf\\n\",F[n]-b);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#define INF 1<<29\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<int>a(n+1);\n    a[0]=0;\n    for(int i=1;i<=n;i++)cin >> a[i];\n    double b,r,v,e,f;\n    cin >> b >> r >> v >> e >> f;\n\n    double time[10001];\n    time[0]=0;\n    for(int i=0;i<10001;i++){\n      if(i>=r)time[i+1]=1/(v-e*(i-r))+time[i];\n      else time[i+1]=1/(v-f*(r-i))+time[i];\n    }\n    double dp[101];\n    fill(dp,dp+101,INF);\n    dp[0]=0;\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<=n;j++)\n\tdp[j]=min(dp[j],dp[i]+time[a[j]-a[i]]+(i>0)*b);\n\n    printf(\"%.4fテつ・n\",dp[n]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N_MAX 102\n#define t first\n#define x second\nusing namespace std;\ntypedef pair<double,int> P;\ndouble Cal(int,int);\nP dp[N_MAX];\nint n,a[N_MAX],r;\ndouble b,v,e,f;\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    double t=0;\n    for(int i=0;i<a[1];i++){\n      if(i>=r) t+=Cal(0,i);\n      else t+=Cal(1,i);\n    }\n    dp[0]=make_pair(t,a[1]);\n    for(int i=1;i<n;i++){\n      double coma=0,comb=0;\n      for(int j=dp[i-1].x;j<dp[i-1].x+a[i+1]-a[i];j++){\n\tif(j>=r) coma+=Cal(0,j);\n\telse coma+=Cal(1,j);\n      }\n      for(int j=0;j<a[i+1]-a[i];j++){\n\tif(j>=r) comb+=Cal(0,j);\n\telse comb+=Cal(1,j);\n      }\n      double comt;\n      int comx;\n      if(coma<=comb+b) comx=dp[i-1].x+a[i+1]-a[i],comt=coma;\n      else comx=a[i+1]-a[i],comt=comb+b;\n      dp[i]=make_pair(dp[i-1].t+comt,comx+1);\n    }\n    cout<<dp[n-1].t<<endl;\n  }\n  return 0;\n}\n\ndouble Cal(int c,int x){\n  if(!c) return 1.0/(v-e*(x-r));\n  return 1.0/(v-f*(r-x));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define INF 10000000\n#define t first\n#define x second\nusing namespace std;\ntypedef pair <double,int> P;\ndouble b,r,v,e,f;\n\ndouble mk(int x) {\n  if(x >= r) return 1.0/(v-e*(1.0*x-r));\n  return  1.0/(v-f*(r-1.0*x));\n}\n\nint main() {\n  while(1) {\n    int n,a[101];\n    cin >> n;\n    if(n==0) break;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    \n    cin >> b;\n    cin >> r >> v >> e >> f;\n    P dp[10010]={};\n    for(int i=1;i<=a[n];i++) dp[i] = make_pair(INF,0);\n\n    for(int i=0;i<n;i++) {\n      int tx;\n      double tt;\n      //No Change\n      tx=dp[a[i]].x,  tt=dp[a[i]].t;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt += k , tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n\n      //Change\n      tx= 0, tt=dp[a[i]].t+b;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt +=k; tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n      \n    }\n    printf(\"%.4f\\n\",dp[a[n]].t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n \ntypedef double D;\n \nint n,a[110],r;\nD b,v,e,f;\nD dp[10100][110];\nconst D EPS = 1e-8;\n \nint main(){\n  while(scanf(\"%d\",&n),n){\n    a[0] = 0;\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n    scanf(\"%lf%d%lf%lf%lf\",&b,&r,&v,&e,&f);\n \n    for(int i=0;i<=a[n];i++)\n      for(int j=0;j<=n;j++)dp[i][j] = 1e15;\n    dp[0][0] = 0;\n \n    int pos = 1;\n    for(int i=0;i<a[n];i++){\n      if(i==a[pos]){\n    for(int j=0;j<pos;j++){\n      if(dp[i][pos] > dp[i][j] + b + EPS){\n        dp[i][pos] = dp[i][j] + b;\n      }\n    }\n    pos++;\n      }\n \n      for(int j=0;j<=n;j++){\n    int x = i-a[j];\n    D cost = (x<r)?(1.0/(v-f*(r-x))):(1.0/(v-e*(x-r)));\n    if(dp[i+1][j] > dp[i][j] + cost + EPS){\n      dp[i+1][j] = dp[i][j] + cost;\n    }\n      }\n    }\n     \n    D res = 1e15;\n    for(int i=0;i<=n;i++){\n      if(res > dp[a[n]][i] + EPS)res = dp[a[n]][i];\n    }\n    printf(\"%.10lf\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//21\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int a;\n  double t;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    int a[101]={};\n    for(int i=1;i<=n;i++){\n      cin>>a[i];\n    }\n    int r;\n    double b,v,e,f;\n    cin>>b>>r>>v>>e>>f;\n    S is={0,0};\n    priority_queue<S> que;\n    que.push(is);\n    bool p[101]={};\n    for(;;){\n      S c=que.top();\n      if(c.a==n)break;\n      que.pop();\n      if(p[c.a]++)continue;\n      int cp=a[c.a];\n      double t=c.t;\n      for(int np=c.a+1;np<=n;np++){\n\twhile(cp!=a[np]){\n\t  int x=cp-a[c.a];\n\t  t+=(x>=r)?1/(v-e*(x-r)):1/(v-f*(r-x));\n\t  cp++;\n\t}\n\tS n={np,t+b};\n\tque.push(n);\n      }\n    }\n    cout<<fixed<<que.top().t-b<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint a[101]={},r;\n\t\trep(i,n)\tscanf(\"%d\",a+i+1);\n\t\tdouble b,v,e,f;\tscanf(\"%lf%d%lf%lf%lf\",&b,&r,&v,&e,&f);\n\t\tn++;\n\n\t\tstatic double t[10001];\n\t\trep(x,a[n-1]){\n\t\t\tif(x<r)\tt[x+1]=t[x]+1/(v-f*(r-x));\n\t\t\telse\tt[x+1]=t[x]+1/(v-e*(x-r));\n\t\t}\n\n\t\tstatic double dp[101][10001];\n\t\trep(i,n)rep(x,a[n-1]+1)\tdp[i][x]=1e60;\n\t\tdp[0][0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint dis=a[i]-a[i-1];\n\t\t\tfor(int x=dis;x<=a[n-1];x++){\n\t\t\t\tdp[i][x]=min(dp[i][x],dp[i-1][x-dis]+t[x]-t[x-dis]);\n\t\t\t\tdp[i][0]=min(dp[i][0],dp[i][x]+b);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.9f\\n\",*min_element(dp[n-1],dp[n-1]+a[n-1]+1));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n  \ntypedef double D;\n  \nint n,a[110],r;\nD b,v,e,f;\nD dp[10100][110];\nconst D EPS = 1e-8;\n  \nint main(){\n  while(scanf(\"%d\",&n),n){\n    a[0] = 0;\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n    scanf(\"%lf%d%lf%lf%lf\",&b,&r,&v,&e,&f);\n  \n    for(int i=0;i<=a[n];i++)\n      for(int j=0;j<=n;j++)dp[i][j] = 1e15;\n    dp[0][0] = 0;\n  \n    int pos = 1;\n    for(int i=0;i<a[n];i++){\n      if(i==a[pos]){\n    for(int j=0;j<pos;j++){\n      if(dp[i][pos] > dp[i][j] + b + EPS){\n        dp[i][pos] = dp[i][j] + b;\n      }\n    }\n    pos++;\n      }\n  \n      for(int j=0;j<=n;j++){\n      if(dp[i][j] +EPS > 1e15)continue;\n    int x = i-a[j];\n    D cost = (x<r)?(1.0/(v-f*(r-x))):(1.0/(v-e*(x-r)));\n    if(dp[i+1][j] > dp[i][j] + cost + EPS){\n      dp[i+1][j] = dp[i][j] + cost;\n    }\n      }\n    }\n      \n    D res = 1e15;\n    for(int i=0;i<=n;i++){\n      if(res > dp[a[n]][i] + EPS)res = dp[a[n]][i];\n    }\n    printf(\"%.10lf\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define INF 10000000\n#define t first\n#define x second\nusing namespace std;\ntypedef pair <double,int> P;\ndouble b,v,e,f;\nint r;\n\ndouble mk(int x) {\n  if(x >= r) return 1.0/(v-e*(1.0*x-r));\n  return  1.0/(v-f*(r-1.0*x));\n}\n\nint main() {\n  while(1) {\n    int n,a[110];\n    cin >> n;\n    if(n==0) break;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    cin >> b;\n    cin >> r >> v >> e >> f;\n    P dp[10100];\n    dp[0] = make_pair(0,0);\n    for(int i=1;i<=a[n];i++) dp[i] = make_pair(INF,0);\n\n    for(int i=0;i<n;i++) {\n      int tx;\n      double tt;\n      //No Change\n      tx=dp[a[i]].x,  tt=dp[a[i]].t;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt += k , tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n\n      //Change\n      tx= 0, tt=dp[a[i]].t+b;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt +=k; tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n      \n    }\n    printf(\"%.4f\\n\",dp[a[n]].t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int TYRE = 10001;\nconst int NODE = 101;\nconst int INF = (1<<25);\n\nstruct State{\n  int x, pos;\n  ld t;\n  bool operator < (const State& s) const {\n    return t > s.t;\n  }\n};\n\nvector<int> V;\n\nld T[TYRE][NODE];\nint n;\nld b,r,v,e,f;\n\n\nvoid solve(){\n  fill(T[0],T[0]+TYRE*NODE,(ld)INF);\n\n  priority_queue<State> Q;\n  Q.push((State){0,0,0});\n\n  while(!Q.empty()){\n\n    State now = Q.top(); Q.pop();\n    if(now.pos == n) continue;\n\n    if(T[now.x][now.pos] < now.t) continue;\n\n    //change tyre\n    \n    State nex = now;\n    nex.x = 0;\n    nex.t += b;\n    int diff = V[now.pos+1]-V[now.pos];\n    \n    for(int i = 0; i < diff; i++){\n      if(nex.x >= r) nex.t += 1.0/(v-e*(nex.x-r));\n      else nex.t += 1.0/(v-f*(r-nex.x));\n      nex.x++;\n    }\n    nex.pos++;\n    \n    if(T[nex.x][nex.pos] > nex.t) {\n      T[nex.x][nex.pos] = nex.t;\n      Q.push(nex);\n    }\n\n    //not change tyre\n    nex = now;\n\n    for(int i = 0; i < diff; i++){\n      if(nex.x >= r) nex.t += 1.0/(v-e*(nex.x-r));\n      else nex.t += 1.0/(v-f*(r-nex.x));\n      nex.x++;\n    }\n\n    nex.pos++;\n    \n    if(T[nex.x][nex.pos] > nex.t) {\n      T[nex.x][nex.pos] = nex.t;\n      Q.push(nex);\n    }\n  }\n  ld ans = (ld)INF;\n  \n  for(int i = 0; i < TYRE; i++) ans = min(ans,T[i][n]);\n\n  printf(\"%.4Lf\\n\",ans);\n}\n\n\nvoid input(){\n  V.resize(n+1); V[0] = 0;\n  for(int i = 1; i <= n; i++) cin >> V[i];\n  cin >> b >> r >> v >> e >> f;\n}\n\nint main(){\n  \n  while(cin >> n && n){\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n#define INF 1e10\nint main()\n{\n\tint a[101],N,r;\n\tdouble dp[10001],b,v,e,f;\n\n\twhile(cin >> N, N)\n\t{\n\t\tREP(i,N) cin >> a[i];\n\t\tcin >> b;\n\t\tcin >> r >> v >> e >> f;\n\t\ta[N]=-1;\n\n\t\tREP(i,10001) dp[i]=INF;\n\n\t\tint next=0;\n\t\tdp[0]=0;\n\t\tfor(int i=0; i<a[N-1]; i++)\n\t\t{\n\t\t\tfor(int j=i; j>=0; j--)\n\t\t\t{\n\t\t\t\tif(j>=r) dp[j+1]=dp[j]+1/(v-e*(j-r));\n\t\t\t\telse \t dp[j+1]=dp[j]+1/(v-f*(r-j));\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tdp[0]=INF;\n\n\t\t\tif(i+1==a[next])\n\t\t\t{\n\t\t\t\tREP(j,i+2)\t\t\t\t\n\t\t\t\t\tdp[0]=min(dp[j]+b, dp[0]);\n\t\t\t\tnext++;\n\t\t\t}\n\t\t}\n\t\tdouble ans=INF;\n\t\tREP(i,a[N-1]+1) ans=min(ans, dp[i]);\n\t\t\n\t\tcout << setprecision(7) << setiosflags(ios::fixed);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nint n;\ndouble dp[101][30001];\ndouble b,e,v,f;\nint r;\nint a[1001];\ndouble mem[30000];\nconst int INF=1000000000;\n\n\ndouble dfs(int idx,int runDist){\n    if(!EQ(dp[idx][runDist],-1))return dp[idx][runDist];\n    if(idx==n)\n        return 0;\n    double res=INF;\n    double cost=0;\n    int ndist=a[idx+1]-a[idx];\n    res=min(res,dfs(idx+1,ndist)+mem[ndist-1]+b);\n    // no change\n    if(runDist>=1)\n        res=min(res,dfs(idx+1,ndist+runDist)+mem[ndist+runDist-1]-mem[runDist-1]);\n    else\n        res=min(res,dfs(idx+1,ndist+runDist)+mem[ndist+runDist-1]);\n    return dp[idx][runDist]=res;\n}\n\nint main(){\n    while(cin>>n&&n!=0){\n        a[0]=0;\n        for(int i = 0; i < n; i++)cin>>a[i+1];\n        cin>>b;\n        cin>>r>>v>>e>>f;\n        for(int i = 0; i < 101; i++)for(int j = 0; j < 30001; j++)dp[i][j]=-1;\n        memset(mem,0,sizeof(mem));\n        mem[0]=1.0/(v-f*(r));\n        for(int i = 1; i < 10001; i++){\n            if(i>=r)\n                mem[i]=mem[i-1]+1.0/(v-e*(i-r));\n            else\n                mem[i]=mem[i-1]+1.0/(v-f*(r-i));\n        }\n        double res=dfs(0,0);\n        printf(\"%.10f\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define INF 100000000\n#define t first\n#define x second\nusing namespace std;\ntypedef pair <double,int> P;\ndouble b,v,e,f;\nint r;\ndouble mk(int x) {\n  if(x >= r) return 1.0/(v-e*(x-r));\n  return  1.0/(v-f*(r-x));\n}\n\nint main() {\n  while(1) {\n    int n,a[102]={};\n    cin >> n;\n    if(n==0) break;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    cin >> b >> r >> v >> e >> f;\n    P dp[10010]={};\n    for(int i=1;i<=a[n];i++) dp[i] = make_pair(INF,0);\n    \n    for(int i=0;i<n;i++) {\n      int nx=dp[a[i]].x,cx= 0;\n      double nt=dp[a[i]].t,ct=dp[a[i]].t+b;\n\n      for(int j=a[i]+1;j<=a[n];j++){\n\tnt += mk(nx),ct += mk(cx);\n\tdp[j] = min(dp[j],min((P){nt,++nx},(P){ct,++cx}));\n      }\n    }\n    printf(\"%.4f\\n\",dp[a[n]].t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<complex>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#include<vector>\n\n#define repi(i,a,b) for(int i = int(a); i < int(b); i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i = int(a); i >= int(b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\nconst double pi = acos(-1.0);\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 128;\nconst int M = 10010;\n\nint n, a[N], r;\ndouble b, v, e, f;\n\nvoid input()\n{\n    rep(i, n) cin >> a[i + 1];\n    cin >> b >> r >> v >> e >> f;\n}\n\ndouble t[M];\n\nvoid gen()\n{\n    t[0] = 0.0;\n    rep(i, M - 1)\n        t[i + 1] = t[i] + 1.0 / (v - (i >= r ? e * (i - r) : f * (r - i)));\n}\n\nconst double inf = 1e9;\n\ndouble dp[N];\n\nvoid solve()\n{\n    dp[0] = 0.0;\n    fill(dp + 1, dp + n + 1, inf);\n\n    repi(i, 1, n + 1) rep(j, i)\n        dp[i] = min(dp[i], dp[j] + (j ? b : 0) + t[a[i] - a[j]]);\n    printf(\"%.4f\\n\", dp[n]);\n}\n\nsigned main()\n{\n    while (cin >> n && n) {\n        input();\n        gen();\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#define N_MAX 105\n#define X_MAX 10010\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P > P1;\nvoid dijkstra();\ndouble Cal(int,int);\nint n,a[N_MAX],r;\ndouble b,v,e,f,dp[X_MAX][N_MAX];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  for(int i=0;i<X_MAX;i++)\n    for(int j=0;j<n;j++) dp[i][j]=INF;\n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  dp[0][0]=Cal(0,a[0]);\n  Q.push(make_pair(dp[0][0],make_pair(a[0],1)));\n  while(!Q.empty()){\n    P1 v=Q.top();\n    Q.pop();\n    double t=v.first;\n    int uy=v.second.first,ux=v.second.second;\n    int ncny=uy+a[ux]-a[ux-1];\n    double nccal=Cal(uy,ncny);\n    if(ncny<0) continue;\n    if(dp[ncny][ux]>t+nccal){\n      dp[ncny][ux]=t+nccal;\n      if(ux!=n-1) Q.push(make_pair(dp[ncny][ux],make_pair(ncny,ux+1)));\n    }\n    int cny=a[ux]-a[ux-1];\n    if(cny<0) continue;\n    double ccal=Cal(0,cny)+b;\n    if(dp[cny][ux]>t+ccal){\n      dp[cny][ux]=t+ccal;\n      if(ux!=n-1) Q.push(make_pair(dp[cny][ux],make_pair(cny,ux+1)));\n    }\n  }\n  double mincost=INF;\n  for(int i=0;i<=a[n-1];i++) mincost=min(mincost,dp[i][n-1]);\n  printf(\"%.4f\\n\",mincost);\n}\n\ndouble Cal(int begin,int end){\n  double ret=0;\n  for(int i=begin;i<end;i++){\n    if(i>=r) ret+=1.0/(1.0*v-1.0*e*(1.0*i-1.0*r));\n    else ret+=1.0/(1.0*v-1.0*f*(1.0*r-1.0*i));\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define INF 2000000\n#define t first\n#define x second\nusing namespace std;\ntypedef pair <double,int> P;\ndouble b,v,e,f;\nint r;\n\ndouble mk(int x) {\n  if(x >= r) return 1.0/(v-e*(x-r));\n  return  1.0/(v-f*(r-x));\n}\n\nint main() {\n  while(1) {\n    int n,a[110];\n    cin >> n;\n    if(n==0) break;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    cin >> b;\n    cin >> r >> v >> e >> f;\n    P dp[10100]={};\n    for(int i=1;i<=a[n];i++) dp[i] = make_pair(INF,0);\n\n    for(int i=0;i<n;i++) {\n      int tx;\n      double tt;\n      //No Change\n      tx=dp[a[i]].x,  tt=dp[a[i]].t;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt += k , tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n\n      //Change\n      tx= 0, tt=dp[a[i]].t+b;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt +=k; tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n      \n    }\n    printf(\"%.4f\\n\",dp[a[n]].t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n  \ntypedef double D;\n  \nint n,a[110],r;\nD b,v,e,f;\nD dp[10100][110];\nconst D EPS = 1e-8;\n  \nint main(){\n  while(scanf(\"%d\",&n),n){\n    a[0] = 0;\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n    scanf(\"%lf%d%lf%lf%lf\",&b,&r,&v,&e,&f);\n  \n    for(int i=0;i<=a[n];i++)\n      for(int j=0;j<=n;j++)dp[i][j] = 1e15;\n    dp[0][0] = 0;\n  \n    int pos = 1;\n    for(int i=0;i<a[n];i++){\n      if(i==a[pos]){\n    for(int j=0;j<pos;j++){\n      if(dp[i][pos] > dp[i][j] + b + EPS){\n        dp[i][pos] = dp[i][j] + b;\n      }\n    }\n    pos++;\n      }\n  \n      for(int j=0;j<=n;j++){\n    if(dp[i][j] + ESP >= 1e15)continue;\n    int x = i-a[j];\n    D cost = (x<r)?(1.0/(v-f*(r-x))):(1.0/(v-e*(x-r)));\n    if(dp[i+1][j] > dp[i][j] + cost + EPS){\n      dp[i+1][j] = dp[i][j] + cost;\n    }\n      }\n    }\n      \n    D res = 1e15;\n    for(int i=0;i<=n;i++){\n      if(res > dp[a[n]][i] + EPS)res = dp[a[n]][i];\n    }\n    printf(\"%.10lf\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define N_MAX 110\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P > P1;\nvoid dijkstra();\ndouble Cal(int,int);\nint n,a[N_MAX],r;\ndouble b,v,e,f,dp[N_MAX*N_MAX][N_MAX];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  for(int i=0;i<=N_MAX*N_MAX;i++)\n    for(int j=0;j<n;j++) dp[i][j]=INF;\n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  dp[0][0]=Cal(0,a[0]);\n  Q.push(make_pair(dp[0][0],make_pair(a[0],1)));\n  while(!Q.empty()){\n    P1 v=Q.top();\n    Q.pop();\n    double t=v.first;\n    int uy=v.second.first,ux=v.second.second;\n    int ncny=uy+a[ux]-a[ux-1];\n    double nccal=Cal(uy,ncny);\n    if(dp[ncny][ux]>t+nccal){\n      dp[ncny][ux]=t+nccal;\n      if(ux!=n-1) Q.push(make_pair(dp[ncny][ux],make_pair(ncny,ux+1)));\n    }\n    int cny=a[ux]-a[ux-1];\n    double ccal=Cal(0,cny)+b;\n    if(dp[cny][ux]>t+ccal){\n      dp[cny][ux]=t+ccal;\n      if(ux!=n-1) Q.push(make_pair(dp[cny][ux],make_pair(cny,ux+1)));\n    }\n  }\n  double mincost=INF;\n  for(int i=0;i<=a[n-1];i++) mincost=min(mincost,dp[i][n-1]);\n  cout<<mincost<<endl;\n}\n\ndouble Cal(int begin,int end){\n  double ret=0;\n  for(int i=begin;i<end;i++){\n    if(i>=r) ret+=1.0/(1.0*v-1.0*e*(1.0*i-1.0*r));\n    else ret+=1.0/(1.0*v-1.0*f*(1.0*r-1.0*i));\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nint n;\ndouble dp[101][30001];\ndouble b,e,v,f;\nint r;\nint a[1001];\ndouble mem[30000];\nconst int INF=1000000000;\n\n\ndouble dfs(int idx,int runDist){\n    if(!EQ(dp[idx][runDist],-1))return dp[idx][runDist];\n    if(idx==n)\n        return 0;\n    double res=INF;\n    double cost=0;\n    int ndist=a[idx+1]-a[idx];\n    res=min(res,dfs(idx+1,ndist)+mem[ndist-1]+b);\n    // no change\n    if(runDist>=1)\n        res=min(res,dfs(idx+1,ndist+runDist)+mem[ndist+runDist-1]-mem[runDist-1]);\n    else\n        res=min(res,dfs(idx+1,ndist+runDist)+mem[ndist+runDist-1]);\n    return dp[idx][runDist]=res;\n}\n\nint main(){\n    while(cin>>n&&n!=0){\n        a[0]=0;\n        for(int i = 0; i < n; i++)cin>>a[i+1];\n        cin>>b;\n        cin>>r>>v>>e>>f;\n        for(int i = 0; i < 101; i++)for(int j = 0; j < 30001; j++)dp[i][j]=-1;\n        memset(mem,0,sizeof(mem));\n        mem[0]=1.0/(v-f*(r));\n        for(int i = 1; i < 10001; i++){\n            if(i>=r)\n                mem[i]=mem[i-1]+1.0/(v-e*(i-r));\n            else\n                mem[i]=mem[i-1]+1.0/(v-f*(r-i));\n        }\n        double res=dfs(0,0);\n        printf(\"%.10f\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N_MAX 102\n#define t first\n#define x second\nusing namespace std;\ntypedef pair<double,int> P;\ndouble Cal(int,int);\nP dp[N_MAX];\nint n,a[N_MAX],r;\ndouble b,v,e,f;\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    double t=0;\n    for(int i=0;i<a[1];i++){\n      if(i>=r) t+=Cal(0,i);\n      else t+=Cal(1,i);\n    }\n    dp[0]=make_pair(t,a[1]);\n    for(int i=1;i<n;i++){\n      double coma=0,comb=0;\n      for(int j=dp[i-1].x;j<dp[i-1].x+a[i+1]-a[i];j++){\n\tif(j>=r) coma+=Cal(0,j);\n\telse coma+=Cal(1,j);\n      }\n      for(int j=0;j<a[i+1]-a[i];j++){\n\tif(j>=r) comb+=Cal(0,j);\n\telse comb+=Cal(1,j);\n      }\n      double comt;\n      int comx;\n      if(coma<comb+b) comx=dp[i-1].x+a[i+1]-a[i],comt=coma;\n      else comx=a[i+1]-a[i],comt=comb+b;\n      dp[i]=make_pair(dp[i-1].t+comt,comx);\n    }\n    /*    for(int i=0;i<n;i++) cout<<dp[i].x<< endl;\n    cout<<endl;\n    for(int i=0;i<n;i++) cout<<dp[i].t<< endl;*/\n    cout<<dp[n-1].t<<endl;\n  }\n  return 0;\n}\n\ndouble Cal(int c,int x){\n  if(!c) return 1.0/(1.0*v-1.0*e*(1.0*x-1.0*r));\n  return 1.0/(1.0*v-1.0*f*(1.0*r-1.0*x));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<math.h> \n#include <algorithm>\n#include<cstdio>\n#include <map>\n#include<vector>\n\nusing namespace std;  \n\n\nconst int MAXN=110;\nint a[MAXN],N;\ndouble _time[11000],b,r,v,e,f,dp[MAXN];\nvoid init()\n{\n int x,nx,j;\n double temp;\n _time[0]=0.0;\n for(x=1;x<=10000;x++)\n\t _time[x]=0.0;\n for(x=1;x<=10000;x++)\n {\n  nx=x-1;\n  if(nx>=r)\n  temp=1.0/(v-e*(nx-r));\n  else\n\t  temp=1.0/(v-f*(r-nx));\n  _time[x]=_time[x-1]+temp;\n  \n }\n}\nvoid work()\n{\n int i,j;\n\n for(i=1;i<=N;i++)\n {double temp=_time[a[i]];\n  for(j=1;j<i;j++)\n  {\n\ttemp=min(temp,dp[j]+_time[a[i]-a[j]]+b);\n  }\n  dp[i]=temp;\n }\n}\nint main()\n{\n  int i,j;\n \n  while(cin>>N,N)\n  {\n   for(i=1;i<=N;i++)\n\t   cin>>a[i];\n   cin>>b>>r>>v>>e>>f;\n     init();\n   work();\n   printf(\"%.4lf\\n\",dp[N]);\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 101\n#define inf (1<<29)\nusing namespace std;\nint a[MAX];\nint A[10001];\nint n;\ndouble b,r,v,e,f;\ndouble mincost[MAX][10001];\n\nstruct P\n{\n  int last;\n  double x,cost,now;\n  P(double now=-1,double x=-1,double cost=-1,int last=-1):now(now),x(x),cost(cost),last(last){}\n  bool operator < (const P &a)const\n  {\n    return cost < a.cost;\n  }\n};\n\ndouble getCost(double x)\n{\n  if(x >= r)return 1.0/(v - e * (x - r));\n            return 1.0/(v - f * (r - x));    \n}\n\nvoid dijkstra()\n{\n  rep(i,n)rep(j,10001)mincost[i][j] = inf;\n  mincost[0][0] = 0;\n\n  priority_queue<P> Q;\n  Q.push(P(0,0,0,0));\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n     \n      if(p.now >= a[n-1])continue;\n\n      double ncost = p.cost + getCost((int)p.x);//+1\n      \n      if(mincost[p.last][(int)p.now+1] > ncost)\n\t{\n\t  mincost[p.last][(int)p.now+1] = ncost;\n\t  Q.push(P(p.now+1,p.x+1,ncost,p.last));\n\t}\n\n      if(A[(int)p.now+1] != -1)\n\t{\n\t  double change_cost = (A[(int)p.now+1] == n-1?0:b);\n\t  ncost = ncost + change_cost;\n\t  Q.push(P(p.now+1,0,ncost,A[(int)p.now+1]));\n\t}\n    }\n  double ans = inf;\n  rep(i,n)ans = min(ans,mincost[i][a[n-1]]);\n  cout << setiosflags(ios::fixed) << setprecision(4) << ans << endl;\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      rep(i,10001)A[i] = -1;\n      rep(i,n)\n\t{\n\t  cin >> a[i];\n\t  A[a[i]] = i; \n\t}\n      cin >> b >> r >> v >> e >> f;\n   \n\n      dijkstra();\n\n    }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n\n\nテ」ツ??」ツ??」ツ??」ツ??    テ」ツ??,-テッツスツ、テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??.-テッツスツ、 \nテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??./:::::テッツシツシテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??テッツシツ?:::::テ」ツδス \nテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??::::::::::::;テ」ツつ?-テ「ツ板?「ツ板?- テッツスツ、._/::::::::::::::| \nテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??/,.-テ「ツ??'\"テつエ テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??テッツシツシ:::::::::::| \nテ」ツ??」ツ??」ツ??」ツ??」ツ??ッツシツ湘」ツ??テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツδステッツスツ、::::| \nテ」ツ??」ツ??」ツ??」ツ??テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツδス| \nテ」ツ??」ツ??テ」ツ??lテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??l \nテ」ツ??」ツ??」ツ??.|テ」ツ??」ツ??」ツ??テ「ツ猟湘」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??テ」ツ??」ツ??」ツ??」ツ??」ツつ禿」ツδシテ」ツ?ィテ」ツ?ュテ」ツδサテ」ツδサ \nテ」ツ??テ」ツ??テ」ツ??テ」ツ??」ツ?? , ,テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??「ツ猟湘」ツ??」ツ??」ツ??」ツ??l \nテ」ツ??」ツ??」ツ??」ツ?? テッツスツ、テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??_テ、ツコツコ__テ、ツクツソテ」ツ??」ツ??」ツ??」ツ??ッツスツ、テッツスツ、テッツスツ、 テ」ツ??/テ」ツ??\nテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??テッツスツー テッツスツ、__テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??テ」ツ??テ」ツ??テッツシツ?\nテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??`'''テッツスツーテ「ツ?静「ツ?静「ツ板?「ツ板?「ツ?静「ツ?静「ツ?静「ツ板ャ'''\"\"テつエ \nテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??,-テッツスツ、テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??.-テッツスツ、 \nテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??./:::::テッツシツシテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??テッツシツ?:::::テ」ツδス \nテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??::::::::::::;テ」ツつ?-テ「ツ板?「ツ板?- テッツスツ、._/::::::::::::::| \nテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??/,.-テ「ツ??'\"テつエ テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??テッツシツシ:::::::::::| \nテ」ツ??」ツ??」ツ??」ツ??」ツ??ッツシツ湘」ツ??テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツδステッツスツ、::::| \nテ」ツ??」ツ??」ツ??」ツ??テ」ツ??」ツ??」ツ??」ツ??「ツ猟湘」ツ??」ツ??」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツδス| \nテ」ツ??」ツ??テ」ツ??lテ」ツ??」ツ??」ツ?? , ,テ」ツ??」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ「ツ猟湘」ツ??」ツ??」ツ??テ」ツ??l \nテ」ツ??」ツ??」ツ??.|テ」ツ??」ツ??」ツ??テ」ツ??」ツ??」ツ??」ツ??_テ、ツコツコ__テ、ツクツソテ」ツ??」ツ??」ツ??」ツ??」ツ??ッツスツ、テッツスツ、テッツスツ、テ」ツ??」ツ??テ」ツ??」ツ??」ツ??」ツ??」ツつ湘」ツ?凝」ツつ禿」ツ?ェテ」ツ??\nテ」ツ??テ」ツ??テ」ツ??テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??テ」ツ??l \nテ」ツ??」ツ??」ツ??」ツ?? テッツスツ、テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??テ」ツ??/ \nテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??テッツスツー テッツスツ、__テ」ツ??」ツ??」ツ??テ」ツ??テ」ツ??テ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??ッツシツ?\nテ」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??」ツ??`'''テッツスツーテ「ツ?静「ツ?静「ツ板?「ツ板?「ツ?静「ツ?静「ツ?静「ツ板ャ'''\"\"テつエ \n\n\n */"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\n#include<cassert>\n#include<queue>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 101\n#define inf (1<<29)\nusing namespace std;\nint a[MAX];\nint A[10001];\nint n;\ndouble b,r,v,e,f;\ndouble mincost[MAX][10001];\n \nstruct P\n{\n  int last;\n  double x,cost,now;\n  P(double now=-1,double x=-1,double cost=-1,int last=-1):now(now),x(x),cost(cost),last(last){}\n  bool operator < (const P &a)const\n  {\n    return cost >= a.cost;\n  }\n};\n \ndouble getCost(double x)\n{\n  if(x >= r)return 1.0/(v - e * (x - r));\n            return 1.0/(v - f * (r - x));    \n}\n \nvoid dijkstra()\n{\n  double ans = inf;\n  rep(i,n)rep(j,10001)mincost[i][j] = inf;\n  mincost[0][0] = 0;\n \n  priority_queue<P> Q;\n  Q.push(P(0,0,0,0));\n \n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      if(p.now >= a[n-1])\n    {\n      ans = min(ans,p.cost);\n      continue;\n    }    \n \n      if(ans <= p.cost)continue;\n \n      assert(0 <= p.cost);\n      double ncost = p.cost + getCost(p.x);\n      assert(0 <= ncost);\n \n      if(mincost[p.last][(int)p.now+1] > ncost)\n    {\n      mincost[p.last][(int)p.now+1] = ncost;\n      Q.push(P(p.now+1,p.x+1,ncost,p.last));\n    }\n \n      if(A[(int)p.now+1] != -1)\n    {\n      double change_cost = (A[(int)p.now+1]==n?0:b);\n      ncost += change_cost;\n      Q.push(P(p.now+1,0,ncost,A[(int)p.now+1]));\n    }\n \n    }\n \n  cout << setiosflags(ios::fixed) << setprecision(4) << ans << endl;\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      rep(i,10001)A[i] = -1;\n      rep(i,n)\n    {\n      cin >> a[i];     \n      A[a[i]] = i+1; \n    }\n      cin >> b >> r >> v >> e >> f;\n    \n \n      dijkstra();\n \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#define INF 1<<29\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<int>a(n+1);\n    a[0]=0;\n    for(int i=1;i<=n;i++)cin >> a[i];\n    double b,r,v,e,f;\n    cin >> b >> r >> v >> e >> f;\n\n    double time[10001];\n    time[0]=0;\n    for(int i=0;i<10001;i++){\n      if(i>=r)time[i+1]=1/(v-e*(i-r))+time[i];\n      else time[i+1]=1/(v-f*(r-i))+time[i];\n    }\n    double dp[101];\n    fill(dp,dp+101,INF);\n    dp[0]=0;\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<=n;j++)\n\tdp[j]=min(dp[j],dp[i]+time[a[j]-a[i]]+(i>0)*b);\n\n    printf(\"%.4f\",dp[n]);\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N_MAX 10002\n#define t first\n#define x second\nusing namespace std;\ntypedef pair<double,int> P;\ndouble Cal(int,int);\nP dp[N_MAX];\nint n,a[N_MAX],r;\ndouble b,v,e,f;\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    double t=0;\n    for(int i=0;i<a[1];i++){\n      if(i>=r) t+=Cal(0,i);\n      else t+=Cal(1,i);\n    }\n    dp[0]=make_pair(t,a[1]);\n    for(int i=1;i<n;i++){\n      double coma=0,comb=0;\n      for(int j=dp[i-1].x;j<N_MAX;j++){\n\tif(j>=r) coma+=Cal(0,j);\n\telse coma+=Cal(1,j);\n      }\n      for(int j=0;j<N_MAX;j++){\n\tif(j>=r) comb+=Cal(0,j);\n\telse comb+=Cal(1,j);\n      }\n      double comt;\n      int comx;\n      if(coma<comb+b) comx=dp[i-1].x+a[i+1]-a[i],comt=coma;\n      else comx=a[i+1]-a[i],comt=comb+b;\n      dp[i]=make_pair(dp[i-1].t+comt,comx);\n    }\n    /*    for(int i=0;i<n;i++) cout<<dp[i].x<< endl;\n    cout<<endl;\n    for(int i=0;i<n;i++) cout<<dp[i].t<< endl;*/\n    cout<<dp[n-1].t<<endl;\n  }\n  return 0;\n}\n\ndouble Cal(int c,int x){\n  if(!c) return 1.0/(1.0*v-1.0*e*(1.0*x-1.0*r));\n  return 1.0/(1.0*v-1.0*f*(1.0*r-1.0*x));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,b) loop(i,0,b)\nint main(){\n\tint n;\n\twhile(cin>>n && n){\t\n\t\tint a[200];\n\t\trep(i,n)cin>>a[i+1];\n\t\ta[0]=0;\n\t\tdouble b;\n\t\tdouble r,v,e,f;\n\t\tcin>>b>>r>>v>>e>>f;\n\t\tstatic double dist[10001];\n\t\tdist[0]=0;\n\t\tfor(int i=0;i<10000;i++){\n\t\t\tif(i>=r)dist[i+1] = dist[i] + 1./(v - e*(i - r));\n\t\t\tif(i<r) dist[i+1] = dist[i] + 1./(v - f*(r - i));\n\t\t}\n\t\tstatic double dp[200];\n\t\tfor(int i=0;i<200;i++)dp[i]=1e100;\n\t\tdp[0]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tint d=a[i]-a[j];\n\t\t\t\tdouble t = dp[j]+dist[d];\n\t\t\t\tif(j!=0)t+=b;\n\t\t\t\tdp[i] = min(dp[i], t);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", dp[n]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  while ( cin >> n, n ) {\n    vector<int> a(n+1);\n    vector<double> d(10001, 100000000.0);\n    d[0] = 0;\n    vector<int> is(10001, 0);\n    a[0] = 0;\n    for ( int i = 1; i <= n; i++ ) {\n      cin >> a[i];\n      is[a[i]] = 1;\n    }\n\n    double b;\n    cin >> b;\n    \n    int r;\n    double v, e, f;\n    cin >> r >> v >> e >> f;\n\n    for ( int i = 0; i < n; i++ ) {\n      int x = 0;\n      vector<double> dd = d;\n      if ( i > 0 ) d[a[i]] += b;      \n      for ( int j = a[i]; j < a[n]; j++ ) {\n\tif ( x >= r ) {\n\t  d[j+1] = d[j]+(1.0/(v-e*(x-r)));\t  \n\t} else {\n\t  d[j+1] = d[j]+(1.0/(v-f*(r-x)));\t  \n\t}\n\tx++;\t\n      }\n      for ( int j = 1; j <= n; j++ ) {\n\td[a[j]] = min(d[a[j]], dd[a[j]]);\t\n      }\n    }\n\n    printf(\"%.12lf\\n\", d[a[n]]);    \n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint n, a[128], r;\ndouble b, v, e, f;\ndouble co[20000], dp[128];\n\nint main() {\n    for (;;) {\n        scanf(\"%d\", &n);\n        if (n == 0) return 0;\n        rep (i, n) scanf(\"%d\", a+i+1);\n        scanf(\"%lf%d%lf%lf%lf\", &b, &r, &v, &e, &f);\n        rep (x, 15000) {\n            double t = x >= r ? 1.0/(v-e*(x-r)) : 1.0/(v-f*(r-x));\n            co[x+1] = co[x] + t;\n        }\n        dp[0] = 0;\n        rep (i, n) {\n            dp[i+1] = 1e100;\n            rep (j, i+1) {\n                dp[i+1] = min(dp[i+1], dp[j]+co[a[i+1]-a[j]]+b);\n            }\n        }\n        printf(\"%.9f\\n\", dp[n]-b);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\ndouble dp[110];\nint b[110];\ndouble val[10100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%d\",b+i+1);\n\t\ta++;\n\t\tdouble t,v,e,f;\n\t\tint r;\n\t\tscanf(\"%lf%d%lf%lf%lf\",&t,&r,&v,&e,&f);\n\t\tfor(int i=0;i<a;i++)dp[i]=999999999;\n\t\tdp[0]=0;\n\t\tfor(int i=0;i<10050;i++){\n\t\t\tdouble tmp=0;\n\t\t\tif(i>=r)tmp=1.0/(v-e*(i-r));\n\t\t\telse tmp=1.0/(v-f*(r-i));\n\t\t\tval[i+1]=val[i]+tmp;\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tdp[j]=min(dp[j],dp[i]+t+val[b[j]-b[i]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.12f\\n\",dp[a-1]-t);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<int> a(n+1);\n    rep(i, n) cin >> a[i+1];\n    int r;\n    double b, v, e, f;\n    cin >> b >> r >> v >> e >> f;\n    \n    double time[10010] = {0.0};\n    \n    for(int i = 0 ; i < 10010 ; i++){    \n      if(i >= r) time[i+1] += 1.0/(v - e * (i-r)) + time[i];      \n      else time[i+1] += 1.0/(v - f * (r-i)) + time[i];\n    }\n    \n    double dp[10010];\n    fill(dp, dp+10010, (1<<29));\n    dp[0] = -b;\n    \n    for(int i = 0 ; i < n ; i++){\n      for(int j = i+1 ; j < n+1 ; j++){\n\tdouble t = time[a[j] - a[i]] + b;\n\tdp[j] = min(dp[j], dp[i]+t);\n      }\n    }\n    printf(\"%.4f\\n\", dp[n]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define INF 10000000\n#define t first\n#define x second\nusing namespace std;\ntypedef pair <double,int> P;\ndouble b,r,v,e,f;\n\ndouble mk(int x) {\n  if(x >= r) return 1.0/(v-e*(1.0*x-r));\n  return  1.0/(v-f*(r-1.0*x));\n}\n\nint main() {\n  while(1) {\n    int n,a[110];\n    cin >> n;\n    if(n==0) break;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    cin >> b;\n    cin >> r >> v >> e >> f;\n    P dp[10100];\n    dp[0] = make_pair(0,0);\n    for(int i=1;i<=a[n];i++) dp[i] = make_pair(INF,0);\n\n    for(int i=0;i<n;i++) {\n      int tx;\n      double tt;\n      //No Change\n      tx=dp[a[i]].x,  tt=dp[a[i]].t;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt += k , tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n\n      //Change\n      tx= 0, tt=dp[a[i]].t+b;\n      for(int j=a[i]+1;j<=a[n];j++){\n\tdouble k = mk(tx);\n\ttt +=k; tx++;\n\tdp[j] = min(dp[j],make_pair(tt,tx));\n      }\n      \n    }\n    printf(\"%.4f\\n\",dp[a[n]].t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N_MAX 102\n#define t first\n#define x second\nusing namespace std;\ntypedef pair<double,int> P;\ndouble Cal(int,int);\nP dp[N_MAX];\nint n,a[N_MAX],r;\ndouble b,v,e,f;\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    cin>>b>>r>>v>>e>>f;\n    double t=0;\n    for(int i=0;i<a[1];i++){\n      if(i>=r) t+=Cal(0,i);\n      else t+=Cal(1,i);\n    }\n    dp[0]=make_pair(t,a[1]);\n    for(int i=1;i<n;i++){\n      double coma=0,comb=0;\n      for(int j=dp[i-1].x;j<dp[i-1].x+a[i+1]-a[i];j++){\n\tif(j>=r) coma+=Cal(0,j);\n\telse coma+=Cal(1,j);\n      }\n      for(int j=0;j<a[i+1]-a[i];j++){\n\tif(j>=r) comb+=Cal(0,j);\n\telse comb+=Cal(1,j);\n      }\n      double comt;\n      int comx;\n      if(coma<=comb+b) comx=dp[i-1].x+a[i+1]-a[i],comt=coma;\n      else comx=a[i+1]-a[i],comt=comb+b;\n      dp[i]=make_pair(dp[i-1].t+comt,comx);\n    }\n    /*    for(int i=0;i<n;i++) cout<<dp[i].x<< endl;\n    cout<<endl;\n    for(int i=0;i<n;i++) cout<<dp[i].t<< endl;*/\n    cout<<dp[n-1].t<<endl;\n  }\n  return 0;\n}\n\ndouble Cal(int c,int x){\n  if(!c) return 1.0/(v-e*(x-r));\n  return 1.0/(v-f*(r-x));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\n#define INF 999999999\n\nint n;\ndouble b, r, v, e, f;\nint a[102];\ndouble tim[10002];\ndouble dp[102][102];\n\nvoid calcTime(){\n  tim[0] = 0;\n  for(int x = 0; x < 10000; x++){\n    double add;\n    if(x >= r) add = 1.0 / ((double)v - e * (x - r));\n    else       add = 1.0 / ((double)v - f * (r - x));\n    tim[x + 1] = tim[x] + add;\n  }\n}\n\nvoid solve(){\n  calcTime();\n\n  for(int i = 0; i < 102; i++){\n    for(int j = 0; j < 102; j++){\n      dp[i][j] = INF;\n    }\n  }\n\n  dp[1][0] = 0;\n\n  for(int i = 1; i < n; i++){\n    for(int j = 0; j < i; j++){\n      if(dp[i][j] == INF) continue;\n\n      int dist = a[i] - a[j];\n      double addTm = tim[dist];\n\n      dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n      dp[i + 1][i] = min(dp[i + 1][i], dp[i][j] + addTm + b);\n    }\n  }\n\n  cout << fixed << setprecision(4) << dp[n][n - 1] - b << endl;\n}\n\nint main(){\n  while(cin >> n, n){\n    a[0] = 0;\n    for(int i = 0; i < n; i++){\n      cin >> a[i + 1];\n    }\n    n++;\n    cin >> b >> r >> v >> e >> f;\n    solve();\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1262: Atomic Car Race\n// 2017.12.4 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 10000\ntypedef struct { double t; int node; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int n, double t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint n;\nint a[101];\ndouble s[10005], dist[101], b;\n\ndouble dijkstra()\n{\n\tint i, k;\n\tdouble d;\n\n\tmemset(dist, 0x53, sizeof(dist));\n\tqsize = 0;\n\tdist[0] = 0;\n\tenq(0, 0);\n\twhile (qsize) {\n\t\tk = que[0].node; deq();\n\t\tif (k == n) break;\n\t\tfor (i = k+1; i <= n; i++) {\n\t\t\td = 0;\n\t\t\tif (k > 0) d = b;\n\t\t\td += dist[k] + s[a[i]-a[k]];\n\t\t\tif (d < dist[i]) dist[i] = d, enq(i, d);\n\t\t}\n\t}\n\treturn dist[n];\n}\n\nint main()\n{\n\tint r, i, j;\n\tdouble v, e, f, t;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 1; i <= n; i++) scanf(\"%d\", a+i);\n\t\tscanf(\"%lf%d%lf%lf%lf\", &b, &r, &v, &e, &f);\n\n\t\tfor (s[0] = 0, j = 0; j < a[n]; j++) {\n\t\t\tt = (r <= j) ? 1.0/(v-e*(j-r)) : 1.0/(v-f*(r-j));\n\t\t\ts[j+1] = s[j] + t;\n\t\t}\n\t\tprintf(\"%.8lf\\n\", dijkstra());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1262();\n\t}\n\t\n\tclass AOJ1262{\n\t\tfinal double INF=Double.MAX_VALUE/4.0;\n\t\tAOJ1262(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tSystem.out.printf(\"%.4f\\n\",solve(N));\n\t\t\t}\n\t\t}\n\t\tdouble solve(int N){\n\t\t\tint[] a=new int[N+1];\n\t\t\tfor(int i=1; i<=N; i++)\ta[i]=sc.nextInt();\n\t\t\tdouble b=sc.nextDouble();\n\t\t\tint r=sc.nextInt();\n\t\t\tdouble v=sc.nextDouble(),e=sc.nextDouble(),f=sc.nextDouble();\n\t\t\tdouble[][] dp=new double[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++)for(int j=0; j<=N; j++)dp[i][j]=INF;\n\t\t\t//flash(dp,N);\n\t\t\tdouble tmp=0.0;\n\t\t\tfor(int i=0; i<a[1]; i++)\ttmp+=exp(i,r,v,e,f);\n\t\t\tdp[1][0]=tmp;\n\t\t\tfor(int w=1; w<N; w++){\n\t\t\t\tfor(int h=0; h<w; h++){\n\t\t\t\t\tint d=a[w+1]-a[w],x=a[w]-a[h];\n\t\t\t\t\tdouble exp=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp+=exp(x++,r,v,e,f);\n\t\t\t\t\t//TODO debug\n\t\t\t\t\t//System.out.println(exp);\n\t\t\t\t\tdp[w+1][h]=dp[w][h]+exp;\n\t\t\t\t\tdouble exp2=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp2+=exp(i,r,v,e,f);\n\t\t\t\t\tdp[w+1][w]=min(dp[w+1][w], dp[w][h]+exp2+b);\n\t\t\t\t}\n\t\t\t\t//TODO debug\n\t\t\t\t//System.out.println(\"new \"+dp[w+1][w]);\n\t\t\t}\n\t\t\t//flash(dp,N);\n\t\t\tdouble ans=INF;\n\t\t\tfor(int i=0; i<=N; i++)\tans=min(ans,dp[N][i]);\n\t\t\treturn ans;\n\t\t}\n\t\tdouble exp(int x,double r,double v,double e,double f){\n\t\t\treturn x>=r?(1/(v-e*(x-r))):(1/(v-f*(r-x)));\n\t\t}\n\t\tvoid flash(double[][] dp,int N){\n\t\t\tfor(int y=0; y<=N; y++){\n\t\t\t\tfor(int x=0; x<=N; x++)\tSystem.out.printf(\"%3.3f \",dp[x][y]>=INF?-1:dp[x][y]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t//0438 start\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tint [] data = new int[n+1];\n\t\t\tfor(int i = 1; i <= n;i++){\n\t\t\t\tdata[i] = sc.nextInt();\n\t\t\t}\n\t\t\tdouble b  = sc.nextDouble();\n\t\t\tint r = sc.nextInt();\n\t\t\tdouble v = sc.nextDouble();\n\t\t\tdouble e = sc.nextDouble();\n\t\t\tdouble f = sc.nextDouble();\n\t\t\t\n\t\t\tdouble [][] dp = new double[n][n+1];\n\t\t\tint INF = 1 << 24;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tdp[0][0] =0;\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(dp[j][i] == INF) continue;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t//sonomama\n\t\t\t\t\tdouble sum = 0.0;\n\t\t\t\t\tfor(int k = data[i]; k < data[i+1]; k++){\n\t\t\t\t\t\tint x  = k - data[j];\n\t\t\t\t\t\tdouble value;\n\t\t\t\t\t\tif(x >= r){\n\t\t\t\t\t\t\tvalue = 1.0 / (v - e * (x - r));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tvalue = 1.0 / (v - f * (r - x));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.println(\"x = \" + x + \" value = \" + value + \" i = \" + i);\n\t\t\t\t\t\tsum += value;\n\t\t\t\t\t}\n\t\t\t\t\tdp[j][i+1] = Math.min(dp[j][i+1], sum + dp[j][i]);\n\t\t\t\t\t\n\t\t\t\t\t//keiyu\n\t\t\t\t\tdouble sum2 = 0.0;\n\t\t\t\t\tfor(int k = data[i]; k < data[i+1]; k++){\n\t\t\t\t\t\tint x = k - data[i];\n\t\t\t\t\t\tdouble value;\n\t\t\t\t\t\tif(x >= r){\n\t\t\t\t\t\t\tvalue = 1.0 / (v - e * (x - r));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tvalue = 1.0 / (v - f * (r - x));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum2 += value;\n\t\t\t\t\t}\n\t\t\t\t\tsum2 += b;\n\t\t\t\t\tdp[i][i+1] = Math.min(dp[i][i+1], sum2 + dp[j][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble min = INF;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmin = Math.min(min, dp[i][n]);\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tfor(int i = 0; i < n; i++){\n//\t\t\t\tfor(int j = 0; j <= n; j++){\n//\t\t\t\t\tSystem.out.printf(\"%.4f \",dp[i][j]);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.4f\\n\",min);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        double INF = Double.MAX_VALUE;\n        double EPS = (double)1e-9;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n            dp[0][0] = 0.0;\n\n            for(int i=1; i<=n; i++){\n                double time1 = 0.0;\n                for(int j=0; j<a[i]; j++){\n                    if(j>=r) time1 += 1.0/(v - e * (j-r));\n                    else time1 += 1.0/(v - f * (r-j));\n                }\n                dp[0][i] = time1;\n                dp[1][i] = dp[0][i] + b;\n            }\n\n            for(int i=2; i<n; i++){//テ」ツつソテ」ツつ、テ」ツδ、テ・ツ、ツ嘉」ツ?暗」ツつ凝・ツ崢榲ヲツ閉ー\n                for(int j=0; j<=n; j++){//テァツ崢ョテァツ堋?・ツ慊ー\n                    for(int l=0; l<=j; l++){//テ・ツ?コテァツ卍コテ・ツ慊ー\n                        double time = 0.0;\n                        for(int k=0; k+a[l]<a[j]; k++){\n                            if(k>=r) time += 1.0/(v - e * (k-r));\n                            else time += 1.0/(v - f * (r-k));\n                            \n                        }\n                        //System.out.println(\"time: \"+time+\" a[l]: \"+a[l]+\" a[j]: \"+a[j]+\" i: \"+i);\n                        \n                        double d = dp[i-1][l];\n                        if(d==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], d + time + b);\n\n                        time = 0.0;\n                        for(int k=0; k+a[j]<a[n]; k++){\n                            if(k>=r) time += 1.0/(v - e * (k-r));\n                            else time += 1.0/(v - f * (r-k));\n                            \n                        }\n\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + time);\n                    }\n                }\n            }\n\n            //for(int i=0; i<=n; i++) System.out.println(Arrays.toString(dp[i]));\n\n            double min = INF;\n            for(int i=0; i<n; i++) min = Math.min(min, dp[i][n]);\n            System.out.println(min);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        double INF = Double.MAX_VALUE;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n\n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n\n            for(int i=0; i<=n; i++){\n                dp[0][i] = times[0][i];\n                if(i!=n) dp[1][i] = dp[0][i] + b;\n                else dp[1][i] = dp[0][i];\n                dp[1][n] = Math.min(dp[1][n], dp[0][i] + times[i][n]);\n            }\n\n            for(int i=2; i<=n; i++){\n                for(int j=0; j<n; j++){\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                        dp[i][n] = Math.min(dp[i][n], dp[i-1][n]);\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + times[j][n]);\n                    }\n                }\n            }\n\n            System.out.printf(\"%.4f\\n\",dp[n][n]);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int INF=1<<28;\n    int n;\n    int[] a;\n    int r;\n    double b,v,e,f;\n    double[][] dp;\n\n    void run(){\n\tScanner sc=new Scanner(System.in);\n\twhile(true){\n\t    n=sc.nextInt();if(n==0)break;\n\t    a=new int[n+1];\n\t    a[0]=0;\n\t    for(int i=1;i<=n;i++)a[i]=sc.nextInt();\n\t    b=sc.nextDouble();\n\t    r=sc.nextInt();v=sc.nextDouble();e=sc.nextDouble();f=sc.nextDouble();\n\n\t    dp=new double[n+1][n];\n\t    for(int i=0;i<dp.length;i++)for(int j=0;j<dp[0].length;j++)dp[i][j]=INF;\n\t    for(int i=0;i<n;i++)dp[0][i]=0;\n\n\n\t    //dp[i][j]=テ・ツ可催・ツ崢榲」ツδ?」ツつァテ」ツδε」ツつッテ」ツδ敕」ツつ、テ」ツδウテ」ツδ?テ」ツ?ァテ」ツつソテ」ツつ、テ」ツδ、テ」ツつ津・ツ、ツ嘉」ツ?暗」ツ?淌」ツ?ィテ」ツ?催」ツ?ョテ」ツ??」ツつケテ」ツつソテ」ツδシテ」ツδ暗」ツ?凝」ツつ嘉」ツδ?」ツつァテ」ツδε」ツつッテ」ツδ敕」ツつ、テ」ツδウテ」ツδ?テ」ツ?セテ」ツ?ァテ」ツ?ョテヲツ慊?・ツーツ湘ヲツ卍づゥツ鳴?\n\t    for(int i=0;i<n;i++){ //テァツ渉セテ・ツ慊ィテ」ツ?ョテ」ツδ?」ツつァテ」ツδε」ツつッテ」ツδ敕」ツつ、テ」ツδウテ」ツδ?\n\t\tfor(int j=0;j<i;j++){//テ」ツδ?」ツつァテ」ツδε」ツつッテ」ツδ敕」ツつ、テ」ツδウテ」ツδ?テ」ツ?ァテ」ツつソテ」ツつ、テ」ツδ、テ」ツつ津・ツ、ツ嘉」ツ?暗」ツつ?\n\t\t    double time=0;\n\t\t    int dx=a[i+1]-a[i];\n\t\t    int x=a[i]-a[j];//テ・ツ可催・ツ崢榲」ツつソテ」ツつ、テ」ツδ、テ」ツつ津」ツ?凝」ツ?暗」ツ?ヲテ」ツ?凝」ツつ嘉」ツ?ョティツキツ敕ゥツ崢「\n\t\t    int k;\n\t\t    \n\t\t    for(k=0;k<dx && x<r;k++){\n\t\t\ttime+=1/(v-e*(x-r));\n\t\t\tx++;\n\t\t    }\n\t\t    for(;k<dx;k++){\n\t\t\ttime+=1/(v-f*(r-x));\n\t\t\tx++;\n\t\t    }\n\t\t    dp[i+1][j]=Math.min(dp[i+1][j],dp[i][j]+time);\n\t\t    \n\t\t    \n\t\t    //テ」ツつソテ」ツつ、テ」ツδ、テ」ツつ津・ツ、ツ嘉」ツ?暗」ツつ凝・ツ?エテ・ツ青?\n\t\t     x=0;\n\t\t    time=0;\n\t\t    for(k=0;k<dx && x<r;k++){\n\t\t\ttime+=1/(v-e*(x-r));\n\t\t\tx++;\n\t\t    }\n\t\t    for(;k<dx;k++){\n\t\t\ttime+=1/(v-f*(r-x));\n\t\t\tx++;\n\t\t    }\n\t\t    dp[i+1][i]=Math.min(dp[i+1][i],dp[i][j]+time+b);\n\t\t    \n\t\t}\n\t    }\n\n\t    double ans=INF;\n\t    for(int i=0;i<n;i++)ans=Math.min(ans,dp[n][i]);\n\n\t    System.out.println(ans);\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n}\n\n\t\t  "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nclass Main{\n \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n \n        double INF = Double.MAX_VALUE;\n \n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n \n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n \n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n \n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n \n            for(int i=0; i<=n; i++){\n                dp[0][i] = times[0][i];\n                if(i!=n) dp[1][i] = dp[0][i] + b;\n                else dp[1][i] = dp[0][i];\n                dp[1][n] = Math.min(dp[1][n], dp[1][i] + times[i][n]);\n            }\n \n            for(int i=2; i<=n; i++){\n                for(int j=0; j<n; j++){\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                        dp[i][n] = Math.min(dp[i][n], dp[i-1][n]);\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + times[j][n]);\n                    }\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j]);\n                }\n            }\n \n            System.out.printf(\"%.4f\\n\",dp[n][n]);\n        }\n    }\n \n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        double INF = Double.MAX_VALUE;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n\n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n            dp[0][0] = 0.0;\n\n            for(int i=1; i<=n; i++){\n                dp[0][i] = times[0][i];\n                dp[1][i] = dp[0][i] + b;\n            }\n\n            for(int i=2; i<n; i++){\n                for(int j=0; j<=n; j++){\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + times[j][n]);\n                    }\n                }\n            }\n\n            double min = INF;\n            for(int i=0; i<n; i++) min = Math.min(min, dp[i][n]);\n            System.out.printf(\"%.4f\\n\",min);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nclass Main{\n \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n \n        double INF = Double.MAX_VALUE;\n \n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n \n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n \n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n \n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n \n            for(int i=0; i<=n; i++){\n                dp[0][i] = times[0][i];\n                if(i!=n) dp[1][i] = dp[0][i] + b;\n                else dp[1][i] = dp[0][i];\n                dp[1][n] = Math.min(dp[1][n], dp[1][i] + times[i][n]);\n            }\n \n            for(int i=2; i<=n; i++){\n                for(int j=0; j<n; j++){\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j]);\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                        dp[i][n] = Math.min(dp[i][n], dp[i-1][n]);\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + times[j][n]);\n                    }\n                }\n            }\n \n            System.out.printf(\"%.4f\\n\",dp[n][n]);\n        }\n    }\n \n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nclass Main{\n \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n \n        double INF = Double.MAX_VALUE;\n \n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n \n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n \n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n \n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n \n            for(int i=0; i<=n; i++){\n                dp[0][i] = times[0][i];\n                dp[1][i] = dp[0][i] + b;\n            }\n \n            for(int i=2; i<=n; i++){\n                for(int j=0; j<n; j++){\n                    for(int l=0; l<=j; l++){\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                    }\n                }\n            }\n \n            double min = INF;\n            for(int i=0; i<n; i++){\n                for(int j=0; j<n; j++){\n                    min = Math.min(min, dp[i][j] + times[j][n]);\n                }\n            }\n\n            System.out.printf(\"%.5f\\n\", min);\n        }\n    }\n \n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        double INF = Double.MAX_VALUE;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n\n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n\n            for(int i=0; i<=n; i++){\n                dp[0][i] = times[0][i];\n                if(i!=n) dp[1][i] = dp[0][i] + b;\n                else dp[1][i] = dp[0][i];\n                dp[1][n] = Math.min(dp[1][n], dp[1][i] + times[i][n]);\n            }\n\n            for(int i=2; i<=n; i++){\n                for(int j=0; j<n; j++){\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                        dp[i][n] = Math.min(dp[i][n], dp[i-1][n]);\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + times[j][n]);\n                    }\n                }\n            }\n\n            System.out.printf(\"%.4f\\n\",dp[n][n]);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        double INF = Double.MAX_VALUE;\n        double eps = 1e-8;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n\n            double[][] dp = new double[n][n+1];\n            for(int i=0; i<n; i++) Arrays.fill(dp[i], INF);\n            dp[0][0] = 0.0;\n\n            for(int i=1; i<=n; i++){\n                dp[0][i] = times[0][i];\n                if(i!=n) dp[1][i] = dp[0][i] + b;\n                else dp[1][i] = dp[0][i];\n            }\n\n            for(int i=2; i<n; i++){\n                for(int j=0; j<=n; j++){\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                        dp[i][n] = Math.min(dp[i][n], dp[i-1][n]);\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + times[j][n]);\n                    }\n                }\n            }\n\n            System.out.printf(\"%.4f\\n\",dp[n-1][n]);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        double INF = Double.MAX_VALUE;\n        double eps = 1e-9;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n\n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n\n            for(int i=0; i<=n; i++){\n                dp[0][i] = times[0][i];\n                if(i!=n) dp[1][i] = dp[0][i] + b;\n                else dp[1][i] = dp[0][i];\n                if(dp[1][n] > dp[1][i]+times[i][n] + eps) dp[1][n] = dp[1][i] + times[i][n];\n            }\n\n            for(int i=2; i<=n; i++){\n                for(int j=0; j<n; j++){\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        if(dp[i][j] > dp[i-1][l]+times[l][j]+b + eps)\n                            dp[i][j] = dp[i-1][l] + times[l][j] + b;\n                        if(dp[i][n] > dp[i-1][n] + eps)\n                            dp[i][n] = dp[i-1][n];\n                        if(dp[i][n] > dp[i][j]+times[j][n] + eps)\n                            dp[i][n] = dp[i][j] + times[j][n];\n                    }\n                }\n            }\n\n            System.out.printf(\"%.4f\\n\",dp[n][n]);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Atomic Car Race\npublic class Main{\n\n\tdouble[] dist;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint[] a = new int[n+1];\n\t\t\tfor(int i=1;i<=n;i++)a[i]=sc.nextInt();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tint r = sc.nextInt();\n\t\t\tdouble v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\t\t\tdouble[] s = new double[a[n]+1];\n\t\t\tfor(int x=0;x<a[n];x++){\n\t\t\t\tdouble c = r<=x?(1/(v-e*(x-r))):(1/(v-f*(r-x)));\n\t\t\t\ts[x+1] = s[x]+c;\n\t\t\t}\n\t\t\tdist = new double[n+1];\n\t\t\tArrays.fill(dist, 1<<29);\n\t\t\tdist[0] = 0;\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn (int) Math.signum(dist[o1]-dist[o2]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(0);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint p = q.poll();\n\t\t\t\tif(p==n){\n\t\t\t\t\tSystem.out.printf(\"%.4f\\n\", dist[n]);break;\n\t\t\t\t}\n\t\t\t\tfor(int k=p+1;k<=n;k++){\n\t\t\t\t\tdouble w = dist[p]+s[a[k]-a[p]]+(p==0?0:b);\n\t\t\t\t\tif(w<dist[k]){\n\t\t\t\t\t\tq.remove(k);\n\t\t\t\t\t\tdist[k] = w;\n\t\t\t\t\t\tq.add(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        double INF = Double.MAX_VALUE;\n        double eps = 1e-8;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n\n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n            dp[0][0] = 0.0;\n\n            for(int i=1; i<=n; i++){\n                dp[0][i] = times[0][i];\n                if(i!=n) dp[1][i] = dp[0][i] + b;\n                else dp[1][i] = dp[0][i];\n            }\n\n            for(int i=2; i<n; i++){\n                for(int j=0; j<=n; j++){\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + times[j][n]);\n                    }\n                }\n            }\n\n            double min = INF;\n            for(int i=0; i<n; i++) min = Math.min(min, dp[i][n]);\n            System.out.printf(\"%.4f\\n\",min);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        double INF = Double.MAX_VALUE;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n\n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n\n            for(int i=0; i<=n; i++){\n                dp[0][i] = times[0][i];\n                if(i!=n) dp[1][i] = dp[0][i] + b;\n                else dp[1][i] = dp[0][i];\n            }\n\n            for(int i=2; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                        dp[i][n] = Math.min(dp[i][n], dp[i-1][n]);\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + times[j][n]);\n                    }\n                }\n            }\n\n            System.out.printf(\"%.4f\\n\",dp[n][n]);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        double INF = Double.MAX_VALUE;\n        double eps = 1e-8;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n\n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n            dp[0][0] = 0.0;\n\n            for(int i=1; i<=n; i++){\n                dp[0][i] = times[0][i];\n                if(i!=n) dp[1][i] = dp[0][i] + b;\n                else dp[1][i] = dp[0][i];\n            }\n\n            for(int i=2; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                        dp[i][n] = Math.min(dp[i][n], dp[i-1][n]);\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + times[j][n]);\n                    }\n                }\n            }\n\n            System.out.printf(\"%.4f\\n\",dp[n][n]);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nclass Main{\n \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n \n        double INF = Double.MAX_VALUE;\n \n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n \n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n \n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n \n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n \n            for(int i=0; i<n; i++){\n                dp[0][i] = times[0][i];\n                dp[1][i] = dp[0][i] + b;\n            }\n \n            for(int i=2; i<n; i++){\n                for(int j=0; j<n; j++){\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                    }\n                }\n            }\n \n            double min = INF;\n            for(int i=0; i<n; i++){\n                for(int j=0; j<n; j++){\n                    min = Math.min(min, dp[i][j] + times[j][n]);\n                }\n            }\n\n            System.out.printf(\"%.4f\\n\",min);\n        }\n    }\n \n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        double INF = Double.MAX_VALUE;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\n            double[][] times = new double[n+1][n+1];\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    double time = 0.0;\n                    for(int k=0; k+a[i]<a[j]; k++){\n                        if(k>=r) time += 1.0/(v - e * (k-r));\n                        else time += 1.0/(v - f * (r-k));\n                    }\n                    times[i][j] = time;\n                }\n            }\n\n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n            dp[0][0] = 0.0;\n\n            for(int i=1; i<=n; i++){\n                dp[0][i] = times[0][i];\n                dp[1][i] = dp[0][i] + b;\n            }\n\n            for(int i=2; i<n; i++){\n                for(int j=0; j<=n; j++){\n                    for(int l=0; l<=j; l++){\n                        if(dp[i-1][l]==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][l] + times[l][j] + b);\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + times[j][n]);\n                    }\n                }\n            }\n\n            double min = INF;\n            for(int i=0; i<n; i++) min = Math.min(min, dp[i][n]);\n            System.out.println(min);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        double INF = Double.MAX_VALUE;\n        double EPS = (double)1e-9;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            int[] a = new int[n+1];\n            for(int i=1; i<=n; i++) a[i] = sc.nextInt();\n            double b = sc.nextDouble();\n            int r = sc.nextInt();\n            double v = sc.nextDouble(), e = sc.nextDouble(), f = sc.nextDouble();\n\n            double[][] dp = new double[n+1][n+1];\n            for(int i=0; i<=n; i++) Arrays.fill(dp[i], INF);\n            dp[0][0] = 0.0;\n\n            for(int i=1; i<=n; i++){\n                double time1 = 0.0;\n                for(int j=0; j<a[i]; j++){\n                    if(j>=r) time1 += 1.0/(v - e * (j-r));\n                    else time1 += 1.0/(v - f * (r-j));\n                }\n                dp[0][i] = time1;\n                dp[1][i] = dp[0][i] + b;\n            }\n\n            for(int i=2; i<n; i++){//テ」ツつソテ」ツつ、テ」ツδ、テ・ツ、ツ嘉」ツ?暗」ツつ凝・ツ崢榲ヲツ閉ー\n                for(int j=0; j<=n; j++){//テァツ崢ョテァツ堋?・ツ慊ー\n\n                    double time3 = 0.0;\n                    for(int l=0; l+a[j]<a[n]; l++){\n                        if(l>=r) time3 += 1.0/(v - e * (l-r));\n                        else time3 += 1.0/(v - f * (r-l));\n                        \n                    }\n\n                    for(int l=0; l<=j; l++){//テ・ツ?コテァツ卍コテ・ツ慊ー\n                        double time = 0.0;\n                        for(int k=0; k+a[l]<a[j]; k++){\n                            if(k>=r) time += 1.0/(v - e * (k-r));\n                            else time += 1.0/(v - f * (r-k));\n                            \n                        }\n                        //System.out.println(\"time: \"+time+\" a[l]: \"+a[l]+\" a[j]: \"+a[j]+\" i: \"+i);\n                        \n                        double d = dp[i-1][l];\n                        if(d==INF) continue;\n                        dp[i][j] = Math.min(dp[i][j], d + time + b);\n                        dp[i][n] = Math.min(dp[i][n], dp[i][j] + time3);\n                    }\n                }\n            }\n\n            //for(int i=0; i<=n; i++) System.out.println(Arrays.toString(dp[i]));\n\n            double min = INF;\n            for(int i=0; i<n; i++) min = Math.min(min, dp[i][n]);\n            System.out.println(min);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n} "
  },
  {
    "language": "Ruby",
    "code": "# Aizu Online Judge\n# Atomic Car Race\n\nclass Object\n  def apply\n    yield(self)\n  end\nend\n\nsolve = -> n, checkpoints, b, r, v, e, f {\n  # last_changed 地点でタイヤを変えた時、start から goal まで走行するのにかかる時間\n  time = -> start, goal, last_changed {\n    res = 0.0\n    while start < goal\n      x = start - last_changed\n      res += if x >= r\n               1.0 / (v - e * (x - r))\n             else\n               1.0 / (v - f * (r - x))\n             end\n      start += 1\n    end\n    res\n  }\n\n  dp = Array.new(n) { Array.new(checkpoints.size + 1) }\n\n  (n-1).downto(0) do |i|\n    0.upto(checkpoints.size) do |j| # checkpoints に入れるときに -1 する\n      dp[i][j] = if i == n-1\n                   0.0\n                 else\n                   this_cp = checkpoints[i]\n                   next_cp = checkpoints[i+1]\n                   last_changed = j==0 ? 0 : checkpoints[j-1]\n                   [ dp[i+1][i+1] + time.(this_cp, next_cp, checkpoints[i]) + b,\n                     dp[i+1][j] + time.(this_cp, next_cp, last_changed) ].min\n                 end\n    end\n  end\n\n  return dp[0][0] + time.(0, checkpoints[0], 0)\n}\n\n# n\n# a1 a2 . . . an\n# b\n# r v e f\n\nloop do\n  # n checkpoints\n  n = gets.to_i\n  break if n == 0\n  checkpoints = gets.split.map(&:to_i)\n\n  # b seconds to change tires\n  b = gets.to_f\n\n  # time to run from x to x+1:\n  #   1/(v - e(x - r)) (if x >= r)\n  #   1/(v - f(r - x)) (if x < r )\n  r, v, e, f = gets.split.apply { |r, v, e, f| [r.to_i, *[v, e, f].map(&:to_f)] }\n\n  puts solve.(n, checkpoints, b, r, v, e, f).round(4)\nend"
  },
  {
    "language": "Ruby",
    "code": "# Aizu Online Judge\n# Atomic Car Race\n\nclass Object\n  def apply\n    yield(self)\n  end\nend\n\nsolve = -> n, checkpoints, b, r, v, e, f {\n  # last_changed 地点でタイヤを変えた時、start から goal まで走行するのにかかる時間\n  time = -> start, goal, last_changed {\n    if start == goal\n      0.0\n    else\n      x = start - last_changed\n      if x >= r\n        1.0 / (v - e * (x - r))\n      else\n        1.0 / (v - f * (r - x))\n      end + time.(start + 1, goal, last_changed)\n    end\n  }\n\n  dp = Array.new(n) { Array.new(checkpoints.size + 1) }\n\n  (n-1).downto(0) do |i|\n    0.upto(checkpoints.size) do |j| # checkpoints に入れるときに -1 する\n      dp[i][j] = if i == n-1\n                   0.0\n                 else\n                   this_cp = checkpoints[i]\n                   next_cp = checkpoints[i+1]\n                   last_changed = j==0 ? 0 : checkpoints[j-1]\n                   [ dp[i+1][i+1] + time.(this_cp, next_cp, checkpoints[i]) + b,\n                     dp[i+1][j] + time.(this_cp, next_cp, last_changed) ].min\n                 end\n    end\n  end\n\n  return dp[0][0] + time.(0, checkpoints[0], 0)\n}\n\n# n\n# a1 a2 . . . an\n# b\n# r v e f\n\nloop do\n  # n checkpoints\n  n = gets.to_i\n  break if n == 0\n  checkpoints = gets.split.map(&:to_i)\n\n  # b seconds to change tires\n  b = gets.to_f\n\n  # time to run from x to x+1:\n  #   1/(v - e(x - r)) (if x >= r)\n  #   1/(v - f(r - x)) (if x < r )\n  r, v, e, f = gets.split.apply { |r, v, e, f| [r.to_i, *[v, e, f].map(&:to_f)] }\n\n  puts solve.(n, checkpoints, b, r, v, e, f).round(4)\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef interval(x, r, v, e, f)\n  if x >= r\n    1.0 / (v - e * (x - r))\n  else\n    1.0 / (v - f * (r - x))\n  end\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  ais = gets.split.map(&:to_i)\n  ais.unshift(0)\n  gl = ais.pop\n  b = gets.to_f\n  r, v, e, f = gets.split.map(&:to_f)\n  r = r.to_i\n  #p [ais, gl]\n  #p b\n  #p [r, v, e, f]\n\n  tis = n.times.map{[0.0]}\n\n  for x in (0...gl)\n    ti = interval(x, r, v, e, f)\n    tis[0][x + 1] = tis[0][x] + ti\n  end\n  #p tis[0]\n\n  for k in (1...n)\n    ai = ais[k]\n    tis[k][ai] = (0...k).map{|i| tis[i][ai]}.min + b\n\n    for x in (ai...gl)\n      ti = interval(x - ai, r, v, e, f)\n      tis[k][x + 1] = tis[k][x] + ti\n    end\n  end\n\n  min_t = (0...n).map{|i| tis[i][gl]}.min\n  puts \"%.4f\" % min_t\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N;\n    int[] A;\n    real B;\n    int R; real V, E, F;\n\n    bool input() {\n        N = readln.chomp.to!int;\n        if (N == 0) return false;\n        A = readln.chomp.split(\" \").map!(to!int).array;\n        B = readln.chomp.to!real;\n        scanf(\"%d %Lf %Lf %Lf\\n\", &R, &V, &E, &F);\n        return true;\n    }\n    void solve() {\n        real time(int d) {\n            real t = 0;\n            for (int x = 0; x < min(d, R); x++) {\n                t += 1.0 / (V - F * (R - x));\n            }\n            for (int x = min(d, R); x < d; x++) {\n                t += 1.0 / (V - E * (x - R));\n            }\n            return t;\n        }\n        A = [0] ~ A;\n        N = cast(int)(A.length);\n        auto dp = new real[N];\n        dp[] = 1e10;\n        dp[0] = 0;\n        foreach (i; 0 .. N - 1) {\n            foreach (j; i + 1 .. N) {\n                dp[j] = min(dp[j], dp[i] + time(A[j] - A[i]) + (i == 0 ? 0 : B));\n            }\n        }\n        writefln(\"%.20f\", dp[N - 1]);\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from bisect import bisect\n    from itertools import accumulate\n    from sys import stdin\n    f_i = stdin\n    \n    while True:\n        n = int(f_i.readline())\n        if n == 0:\n            break\n        \n        a = list(map(int, f_i.readline().split()))\n        b = float(f_i.readline())\n        r, v, e, f = map(float, f_i.readline().split())\n        \n        r = int(r)\n        a_n = a.pop()\n        \n        dp = [1 / (v - f * (r - x))for x in range(r)]\n        dp += [1 / (v - e * (x - r))for x in range(r, a_n)]\n        \n        dp = list(accumulate(dp))\n        cost = tuple(time + b for time in dp)\n        \n        for a_i in a:\n            base = dp[a_i-1]\n            for i, tpl in enumerate(zip(dp[a_i:], cost), start=a_i):\n                pre, new = tpl\n                new += base\n                if new < pre:\n                    dp[i] = new\n        \n        print(dp[-1])\n\nsolve()\n"
  }
]