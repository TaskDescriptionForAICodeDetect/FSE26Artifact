[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n#define MAX_LOG 20\n\ntypedef struct {\n    int to, color, length;\n} Edge;\n\nint n, q;\nint parent[MAX_N][MAX_LOG];\nint depth[MAX_N];\nint distances[MAX_N];\nEdge edges[2 * MAX_N];\nint edge_count = 0;\nint head[MAX_N];\n\nvoid add_edge(int u, int v, int color, int length) {\n    edges[edge_count] = (Edge){v, color, length};\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n    edges[edge_count] = (Edge){u, color, length};\n    edges[edge_count].next = head[v];\n    head[v] = edge_count++;\n}\n\nvoid dfs(int node, int parent, int current_depth) {\n    depth[node] = current_depth;\n    parent[node][0] = parent;\n    \n    for (int i = 1; i < MAX_LOG; i++) {\n        if (parent[node][i-1] != -1)\n            parent[node][i] = parent[parent[node][i-1]][i-1];\n        else\n            parent[node][i] = -1;\n    }\n    \n    for (int i = head[node]; i != -1; i = edges[i].next) {\n        int next = edges[i].to;\n        if (next != parent) {\n            distances[next] = distances[node] + edges[i].length;\n            dfs(next, node, current_depth + 1);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n    \n    for (int i = MAX_LOG - 1; i >= 0; i--) {\n        if (parent[u][i] != -1 && depth[parent[u][i]] >= depth[v])\n            u = parent[u][i];\n    }\n    \n    if (u == v) return u;\n    \n    for (int i = MAX_LOG - 1; i >= 0; i--) {\n        if (parent[u][i] != parent[v][i]) {\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    \n    return parent[u][0];\n}\n\nint get_distance(int u, int v) {\n    int common_ancestor = lca(u, v);\n    return distances[u] + distances[v] - 2 * distances[common_ancestor];\n}\n\nvoid update_lengths(int color, int new_length) {\n    for (int i = 0; i < edge_count; i++) {\n        if (edges[i].color == color)\n            edges[i].length = new_length;\n    }\n    \n    // Recalculate distances\n    memset(distances, 0, sizeof(distances));\n    dfs(1, -1, 0);\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &q);\n    \n    memset(head, -1, sizeof(head));\n    memset(parent, -1, sizeof(parent));\n    \n    for (int i = 0; i < n - 1; i++) {\n        int u, v, color, length;\n        scanf(\"%d %d %d %d\", &u, &v, &color, &length);\n        add_edge(u, v, color, length);\n    }\n    \n    // Initial DFS to set up parent and distances\n    dfs(1, -1, 0);\n    \n    while (q--) {\n        int color, new_length, u, v;\n        scanf(\"%d %d %d %d\", &color, &new_length, &u, &v);\n        \n        update_lengths(color, new_length);\n        printf(\"%d\\n\", get_distance(u, v));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:47:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n#define MAX_LOG 20\n\ntypedef struct {\n    int to, c, d, next;\n} Edge;\n\nEdge edges[2 * MAX_N];\nint head[MAX_N + 1], edge_count;\nint depth[MAX_N + 1];\nint parent[MAX_N + 1][MAX_LOG];\nint color_map[MAX_N];\nint dist[MAX_N + 1];\nint N, Q;\n\nvoid add_edge(int a, int b, int c, int d) {\n    edges[edge_count] = (Edge){b, c, d, head[a]};\n    head[a] = edge_count++;\n    edges[edge_count] = (Edge){a, c, d, head[b]};\n    head[b] = edge_count++;\n}\n\nvoid dfs(int u, int p, int d) {\n    parent[u][0] = p;\n    depth[u] = d;\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        Edge e = edges[i];\n        if (e.to != p) {\n            color_map[e.c] = i;\n            dist[e.to] = dist[u] + e.d;\n            dfs(e.to, u, d + 1);\n        }\n    }\n}\n\nvoid build_lca() {\n    for (int k = 1; k < MAX_LOG; k++) {\n        for (int i = 1; i <= N; i++) {\n            if (parent[i][k - 1] != -1) {\n                parent[i][k] = parent[parent[i][k - 1]][k - 1];\n            } else {\n                parent[i][k] = -1;\n            }\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n    for (int k = MAX_LOG - 1; k >= 0; k--) {\n        if (depth[u] - (1 << k) >= depth[v]) {\n            u = parent[u][k];\n        }\n    }\n    if (u == v) return u;\n    for (int k = MAX_LOG - 1; k >= 0; k--) {\n        if (parent[u][k] != -1 && parent[u][k] != parent[v][k]) {\n            u = parent[u][k];\n            v = parent[v][k];\n        }\n    }\n    return parent[u][0];\n}\n\nint get_distance(int u, int v) {\n    int ancestor = lca(u, v);\n    return dist[u] + dist[v] - 2 * dist[ancestor];\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &Q);\n    memset(head, -1, sizeof(head));\n    edge_count = 0;\n    for (int i = 0; i < N - 1; i++) {\n        int a, b, c, d;\n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        add_edge(a, b, c, d);\n    }\n    memset(parent, -1, sizeof(parent));\n    dist[1] = 0;\n    dfs(1, -1, 0);\n    build_lca();\n    while (Q--) {\n        int x, y, u, v;\n        scanf(\"%d %d %d %d\", &x, &y, &u, &v);\n        Edge *e1 = &edges[color_map[x]];\n        Edge *e2 = &edges[color_map[x] ^ 1];\n        int original_d = e1->d;\n        e1->d = y;\n        e2->d = y;\n        int ancestor = lca(u, v);\n        int distance = dist[u] + dist[v] - 2 * dist[ancestor];\n        printf(\"%d\\n\", distance);\n        e1->d = original_d;\n        e2->d = original_d;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:48:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_LOG = 20;\n\nstruct Edge {\n    int to, color, length;\n};\n\nvector<vector<Edge>> tree;\nvector<vector<int>> parent;\nvector<vector<unordered_map<int, int>>> color_lengths;\nvector<int> depth;\n\nvoid dfs(int u, int p, int d) {\n    parent[u][0] = p;\n    depth[u] = d;\n    for (const Edge& e : tree[u]) {\n        if (e.to != p) {\n            color_lengths[e.to][0][e.color] = e.length;\n            dfs(e.to, u, d + 1);\n        }\n    }\n}\n\nvoid preprocess(int N) {\n    for (int k = 1; k < MAX_LOG; ++k) {\n        for (int u = 1; u <= N; ++u) {\n            if (parent[u][k-1] != -1) {\n                parent[u][k] = parent[parent[u][k-1]][k-1];\n                for (const auto& entry : color_lengths[u][k-1]) {\n                    color_lengths[u][k][entry.first] = entry.second;\n                }\n                if (parent[u][k-1] != -1) {\n                    for (const auto& entry : color_lengths[parent[u][k-1]][k-1]) {\n                        color_lengths[u][k][entry.first] += entry.second;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) swap(u, v);\n    for (int k = MAX_LOG - 1; k >= 0; --k) {\n        if (depth[u] - (1 << k) >= depth[v]) {\n            u = parent[u][k];\n        }\n    }\n    if (u == v) return u;\n    for (int k = MAX_LOG - 1; k >= 0; --k) {\n        if (parent[u][k] != -1 && parent[u][k] != parent[v][k]) {\n            u = parent[u][k];\n            v = parent[v][k];\n        }\n    }\n    return parent[u][0];\n}\n\nint get_distance(int u, int v, int x, int y) {\n    int ancestor = lca(u, v);\n    int distance = 0;\n\n    for (int vertex : {u, v}) {\n        int current = vertex;\n        while (current != ancestor) {\n            for (int k = MAX_LOG - 1; k >= 0; --k) {\n                if (parent[current][k] != -1 && depth[parent[current][k]] >= depth[ancestor]) {\n                    if (color_lengths[current][k].count(x)) {\n                        distance += y;\n                    } else {\n                        distance += color_lengths[current][k].begin()->second;\n                    }\n                    current = parent[current][k];\n                    break;\n                }\n            }\n        }\n    }\n\n    return distance;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    tree.resize(N + 1);\n    parent.assign(N + 1, vector<int>(MAX_LOG, -1));\n    color_lengths.assign(N + 1, vector<unordered_map<int, int>>(MAX_LOG));\n    depth.resize(N + 1);\n\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        tree[a].push_back({b, c, d});\n        tree[b].push_back({a, c, d});\n    }\n\n    dfs(1, -1, 0);\n    preprocess(N);\n\n    while (Q--) {\n        int x, y, u, v;\n        cin >> x >> y >> u >> v;\n        cout << get_distance(u, v, x, y) << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:49:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, color, length;\n        Edge(int to, int color, int length) {\n            this.to = to;\n            this.color = color;\n            this.length = length;\n        }\n    }\n\n    static int N, Q;\n    static List<Edge>[] tree;\n    static Map<Integer, Integer> colorToLength = new HashMap<>();\n    static int[] parent, depth;\n    static int[][] up;\n    static int LOG;\n    static int[] originalColorLength;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        N = Integer.parseInt(st.nextToken());\n        Q = Integer.parseInt(st.nextToken());\n\n        tree = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n\n        originalColorLength = new int[N];\n        for (int i = 1; i < N; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            int c = Integer.parseInt(st.nextToken());\n            int d = Integer.parseInt(st.nextToken());\n            tree[a].add(new Edge(b, c, d));\n            tree[b].add(new Edge(a, c, d));\n            originalColorLength[c] = d;\n        }\n\n        LOG = 1;\n        while ((1 << LOG) <= N) LOG++;\n        up = new int[N + 1][LOG];\n        parent = new int[N + 1];\n        depth = new int[N + 1];\n        for (int i = 0; i <= N; i++) {\n            Arrays.fill(up[i], -1);\n        }\n\n        dfs(1, -1, 0);\n\n        for (int k = 1; k < LOG; k++) {\n            for (int v = 1; v <= N; v++) {\n                if (up[v][k - 1] != -1) {\n                    up[v][k] = up[up[v][k - 1]][k - 1];\n                }\n            }\n        }\n\n        while (Q-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n\n            colorToLength.put(x, y);\n            int distance = getDistance(u, v);\n            out.println(distance);\n            colorToLength.remove(x);\n        }\n        out.close();\n    }\n\n    static void dfs(int u, int p, int d) {\n        parent[u] = p;\n        depth[u] = d;\n        for (Edge e : tree[u]) {\n            if (e.to != p) {\n                up[e.to][0] = u;\n                dfs(e.to, u, d + 1);\n            }\n        }\n    }\n\n    static int lca(int u, int v) {\n        if (depth[u] < depth[v]) {\n            int temp = u;\n            u = v;\n            v = temp;\n        }\n\n        for (int k = LOG - 1; k >= 0; k--) {\n            if (depth[u] - (1 << k) >= depth[v]) {\n                u = up[u][k];\n            }\n        }\n\n        if (u == v) return u;\n\n        for (int k = LOG - 1; k >= 0; k--) {\n            if (up[u][k] != -1 && up[u][k] != up[v][k]) {\n                u = up[u][k];\n                v = up[v][k];\n            }\n        }\n        return parent[u];\n    }\n\n    static int getDistance(int u, int v) {\n        int ancestor = lca(u, v);\n        return getPathLength(u, ancestor) + getPathLength(v, ancestor);\n    }\n\n    static int getPathLength(int u, int ancestor) {\n        int length = 0;\n        while (u != ancestor) {\n            for (Edge e : tree[u]) {\n                if (e.to == parent[u]) {\n                    int currentLength = colorToLength.containsKey(e.color) ? colorToLength.get(e.color) : e.length;\n                    length += currentLength;\n                    u = e.to;\n                    break;\n                }\n            }\n        }\n        return length;\n    }\n}",
    "timestamp": "2025-08-05 22:49:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class TreeDistanceQuery {\n    static int N, Q;\n    static ArrayList<ArrayList<Edge>> graph;\n    static long[][] dist;\n\n    static class Edge {\n        int to, color, length;\n        Edge(int to, int color, int length) {\n            this.to = to;\n            this.color = color;\n            this.length = length;\n        }\n    }\n\n    static void updateEdgeLengths(int color, int newLength) {\n        for (int u = 1; u <= N; u++) {\n            for (Edge e : graph.get(u)) {\n                if (e.color == color) {\n                    e.length = newLength;\n                }\n            }\n        }\n    }\n\n    static void computeDistances() {\n        dist = new long[N+1][N+1];\n        for (int u = 1; u <= N; u++) {\n            dist[u][u] = 0;\n            boolean[] visited = new boolean[N+1];\n            PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[1], b[1]));\n            pq.offer(new long[]{u, 0});\n\n            while (!pq.isEmpty()) {\n                long[] curr = pq.poll();\n                int node = (int)curr[0];\n                long currDist = curr[1];\n\n                if (visited[node]) continue;\n                visited[node] = true;\n                dist[u][node] = currDist;\n\n                for (Edge e : graph.get(node)) {\n                    if (!visited[e.to]) {\n                        pq.offer(new long[]{e.to, currDist + e.length});\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        N = Integer.parseInt(st.nextToken());\n        graph = new ArrayList<>(N+1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 1; i < N; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            int color = Integer.parseInt(st.nextToken());\n            int length = Integer.parseInt(st.nextToken());\n            graph.get(a).add(new Edge(b, color, length));\n            graph.get(b).add(new Edge(a, color, length));\n        }\n\n        computeDistances();\n\n        Q = Integer.parseInt(br.readLine());\n        for (int j = 0; j < Q; j++) {\n            st = new StringTokenizer(br.readLine());\n            int color = Integer.parseInt(st.nextToken());\n            int newLength = Integer.parseInt(st.nextToken());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n\n            updateEdgeLengths(color, newLength);\n            computeDistances();\n\n            System.out.println(dist[u][v]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:49:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nconst int LOG = 20;\n\nvector<pair<int, int>> graph[MAXN];\nint parent[MAXN][LOG], depth[MAXN];\nlong long dist[MAXN];\n\nvoid dfs(int node, int par, long long cur_dist) {\n    parent[node][0] = par;\n    depth[node] = depth[par] + 1;\n    dist[node] = cur_dist;\n\n    for (int i = 1; i < LOG; i++) {\n        parent[node][i] = parent[parent[node][i-1]][i-1];\n    }\n\n    for (auto& [child, edge_info] : graph[node]) {\n        if (child != par) {\n            int color = edge_info >> 30;\n            int length = edge_info & ((1 << 30) - 1);\n            dfs(child, node, cur_dist + length);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) swap(u, v);\n    \n    for (int i = LOG - 1; i >= 0; i--) {\n        if (depth[u] - (1 << i) >= depth[v]) {\n            u = parent[u][i];\n        }\n    }\n    \n    if (u == v) return u;\n    \n    for (int i = LOG - 1; i >= 0; i--) {\n        if (parent[u][i] != parent[v][i]) {\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    \n    return parent[u][0];\n}\n\nlong long get_distance(int u, int v) {\n    int common_ancestor = lca(u, v);\n    return dist[u] + dist[v] - 2 * dist[common_ancestor];\n}\n\nvoid update_edge_lengths(int color, int new_length) {\n    for (int i = 1; i <= color; i++) {\n        for (auto& [node, edge_info] : graph[i]) {\n            int curr_color = edge_info >> 30;\n            if (curr_color == color) {\n                edge_info = (curr_color << 30) | new_length;\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int N, M, Q;\n    cin >> N >> M;\n\n    for (int i = 0; i < M; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        graph[a].push_back({b, (c << 30) | d});\n        graph[b].push_back({a, (c << 30) | d});\n    }\n\n    dfs(1, 0, 0);\n\n    cin >> Q;\n    while (Q--) {\n        int x, y, u, v;\n        cin >> x >> y >> u >> v;\n        update_edge_lengths(x, y);\n        cout << get_distance(u, v) << \"\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef tree_queries(N, edges, queries):\n    # Build adjacency list from edges\n    adj = defaultdict(list)\n    for a, b, c, d in edges:\n        adj[a].append((b, c, d))\n        adj[b].append((a, c, d))\n    \n    # Helper function to perform BFS and return distance between two nodes\n    def bfs(u, v, color_len):\n        queue = deque([(u, 0)])\n        visited = set([u])\n        while queue:\n            node, dist = queue.popleft()\n            if node == v:\n                return dist\n            for neighbor, color, length in adj[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + color_len[(color, length)]))\n        return -1\n    \n    # Answer each query\n    result = []\n    for x, y, u, v in queries:\n        # Modify edge lengths based on the current query\n        color_len = {}\n        for a, b, c, d in edges:\n            if c == x:\n                color_len[(c, d)] = y\n            else:\n                color_len[(c, d)] = d\n\n        # Find distance from u to v using modified lengths\n        result.append(bfs(u, v, color_len))\n    \n    return result\n\n# Example usage:\nN = 5\nedges = [\n    (1, 2, 1, 1),\n    (2, 3, 2, 1),\n    (3, 4, 3, 1),\n    (4, 5, 2, 1)\n]\n\nqueries = [\n    (2, 2, 1, 5),  # Change lengths of edges with color 2 to 2, find distance from 1 to 5\n    (3, 3, 1, 4)   # Change lengths of edges with color 3 to 3, find distance from 1 to 4\n]\n\nprint(tree_queries(N, edges, queries))",
    "timestamp": "2025-08-13 12:33:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeDistanceQuery {\n    static class Edge {\n        int from, to, color, length;\n        Edge(int from, int to, int color, int length) {\n            this.from = from;\n            this.to = to;\n            this.color = color;\n            this.length = length;\n        }\n    }\n\n    static class Query {\n        int color, newLength, start, end;\n        Query(int color, int newLength, int start, int end) {\n            this.color = color;\n            this.newLength = newLength;\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    static class Tree {\n        int n;\n        List<Edge>[] adj;\n\n        Tree(int n) {\n            this.n = n;\n            adj = new ArrayList[n + 1];\n            for (int i = 1; i <= n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n        }\n\n        void addEdge(int from, int to, int color, int length) {\n            adj[from].add(new Edge(from, to, color, length));\n            adj[to].add(new Edge(to, from, color, length));\n        }\n\n        Map<Integer, Integer> dfs(int node, int parent, Map<Integer, Integer> lengths) {\n            Map<Integer, Integer> distance = new HashMap<>();\n            distance.put(node, 0);\n            for (Edge edge : adj[node]) {\n                if (edge.to != parent) {\n                    lengths.put(edge.color, edge.length);\n                    Map<Integer, Integer> childDistances = dfs(edge.to, node, lengths);\n                    for (Map.Entry<Integer, Integer> entry : childDistances.entrySet()) {\n                        int child = entry.getKey();\n                        int dist = entry.getValue() + lengths.get(edge.color);\n                        distance.put(child, dist);\n                    }\n                }\n            }\n            return distance;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        Tree tree = new Tree(n);\n        Edge[] edges = new Edge[n - 1];\n\n        for (int i = 0; i < n - 1; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int color = sc.nextInt();\n            int length = sc.nextInt();\n            edges[i] = new Edge(a, b, color, length);\n            tree.addEdge(a, b, color, length);\n        }\n\n        int q = sc.nextInt();\n        Query[] queries = new Query[q];\n\n        for (int i = 0; i < q; i++) {\n            int color = sc.nextInt();\n            int newLength = sc.nextInt();\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            queries[i] = new Query(color, newLength, u, v);\n        }\n\n        for (Query query : queries) {\n            for (Edge edge : edges) {\n                if (edge.color == query.color) {\n                    edge.length = query.newLength;\n                }\n            }\n\n            Map<Integer, Integer> lengths = new HashMap<>();\n            Map<Integer, Integer> distanceFromU = tree.dfs(query.start, -1, lengths);\n\n            System.out.println(distanceFromU.get(query.end));\n        }\n\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 12:34:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 1005\n#define MAXQ 1005\n\ntypedef struct {\n    int to;\n    int color;\n    int length;\n} Edge;\n\nEdge graph[MAXN][MAXN];\nint distances[MAXN];\nint visited[MAXN];\n\nvoid add_edge(int u, int v, int color, int length) {\n    int idx;\n    for (idx = 0; graph[u][idx].to != 0; ++idx);\n    graph[u][idx].to = v;\n    graph[u][idx].color = color;\n    graph[u][idx].length = length;\n\n    for (idx = 0; graph[v][idx].to != 0; ++idx);\n    graph[v][idx].to = u;\n    graph[v][idx].color = color;\n    graph[v][idx].length = length;\n}\n\nint dfs(int current, int target) {\n    if (current == target) {\n        return 0;\n    }\n    visited[current] = 1;\n    for (int i = 0; graph[current][i].to != 0; ++i) {\n        int next = graph[current][i].to;\n        if (!visited[next]) {\n            int dist = dfs(next, target);\n            if (dist >= 0) {\n                return dist + graph[current][i].length;\n            }\n        }\n    }\n    return -1;\n}\n\nvoid process_query(int n, int q, int queries[q][4]) {\n    for (int i = 0; i < q; ++i) {\n        int x = queries[i][0];\n        int y = queries[i][1];\n        int u = queries[i][2];\n        int v = queries[i][3];\n\n        // Update the lengths of the edges with color x.\n        for (int j = 1; j <= n; ++j) {\n            for (int k = 0; graph[j][k].to != 0; ++k) {\n                if (graph[j][k].color == x) {\n                    graph[j][k].length = y;\n                }\n            }\n        }\n\n        // Reset visited array.\n        memset(visited, 0, sizeof(visited));\n        // Find distance between u and v.\n        int distance = dfs(u, v);\n        printf(\"%d\\n\", distance);\n    }\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d\", &n);\n\n    for (int i = 1; i < n; ++i) {\n        int a, b, c, d;\n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        add_edge(a, b, c, d);\n    }\n\n    scanf(\"%d\", &q);\n    int queries[q][4];\n    for (int i = 0; i < q; ++i) {\n        scanf(\"%d %d %d %d\", &queries[i][0], &queries[i][1], &queries[i][2], &queries[i][3]);\n    }\n\n    process_query(n, q, queries);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:34:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const treeDistanceQueries = (N, edges, queries) => {\n    const adjList = Array.from({ length: N + 1 }, () => []);\n    const originalLengths = new Map();\n\n    for (const [a, b, c, d] of edges) {\n        adjList[a].push([b, c, d]);\n        adjList[b].push([a, c, d]);\n        originalLengths.set(`${a},${b}`, d);\n        originalLengths.set(`${b},${a}`, d);\n    }\n\n    const findDistanceWithModifiedEdge = (u, v, color, newLength) => {\n        let distance = 0;\n        const visited = new Array(N + 1).fill(false);\n        \n        const dfs = (current, target, accDist) => {\n            if (current === target) {\n                distance = accDist;\n                return true;\n            }\n            visited[current] = true;\n            for (const [neighbor, edgeColor, edgeLength] of adjList[current]) {\n                if (!visited[neighbor]) {\n                    const length = (edgeColor === color) ? newLength : edgeLength;\n                    if (dfs(neighbor, target, accDist + length)) return true;\n                }\n            }\n            return false;\n        };\n        dfs(u, v, 0);\n        return distance;\n    };\n\n    const results = [];\n    for (const [x, y, u, v] of queries) {\n        const totalDistance = findDistanceWithModifiedEdge(u, v, x, y);\n        results.push(totalDistance);\n    }\n\n    return results;\n};\n\n// Example usage:\nconst N = 4;\nconst edges = [\n    [1, 2, 1, 2],\n    [2, 3, 2, 3],\n    [3, 4, 3, 4]\n];\nconst queries = [\n    [1, 5, 1, 4],\n    [2, 6, 2, 4]\n];\nconsole.log(treeDistanceQueries(N, edges, queries));",
    "timestamp": "2025-08-13 12:34:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\nclass TreeDistanceCalculator:\n    def __init__(self, N):\n        self.N = N\n        self.graph = defaultdict(list)\n        self.edge_colors = {}\n\n    def add_edge(self, a, b, color, length):\n        self.graph[a].append((b, color, length))\n        self.graph[b].append((a, color, length))\n        self.edge_colors[(a, b)] = (color, length)\n        self.edge_colors[(b, a)] = (color, length)\n\n    def modify_edge_lengths(self, color, new_length):\n        modified_edges = []\n        for (u, v), (edge_color, old_length) in list(self.edge_colors.items()):\n            if edge_color == color:\n                # Update graph edge lengths\n                for i, (neighbor, c, l) in enumerate(self.graph[u]):\n                    if neighbor == v and c == color:\n                        self.graph[u][i] = (neighbor, c, new_length)\n                \n                modified_edges.append((u, v, old_length, new_length))\n                self.edge_colors[(u, v)] = (color, new_length)\n        \n        return modified_edges\n\n    def bfs_distance(self, start, end):\n        distances = {start: 0}\n        queue = deque([start])\n        \n        while queue:\n            current = queue.popleft()\n            \n            if current == end:\n                return distances[current]\n            \n            for neighbor, _, length in self.graph[current]:\n                if neighbor not in distances:\n                    distances[neighbor] = distances[current] + length\n                    queue.append(neighbor)\n        \n        return -1  # No path found\n\n    def process_queries(self, queries):\n        results = []\n        \n        for color, new_length, u, v in queries:\n            # Modify edge lengths for given color\n            modified_edges = self.modify_edge_lengths(color, new_length)\n            \n            # Calculate distance\n            distance = self.bfs_distance(u, v)\n            results.append(distance)\n            \n            # Revert edge lengths (optional, depends on problem specification)\n            for u, v, old_length, _ in modified_edges:\n                self.modify_edge_lengths(color, old_length)\n        \n        return results\n\ndef main():\n    N = int(input())\n    tree = TreeDistanceCalculator(N)\n    \n    # Read edges\n    for _ in range(N-1):\n        a, b, color, length = map(int, input().split())\n        tree.add_edge(a, b, color, length)\n    \n    # Read queries\n    Q = int(input())\n    queries = []\n    for _ in range(Q):\n        x, y, u, v = map(int, input().split())\n        queries.append((x, y, u, v))\n    \n    # Process queries and print results\n    results = tree.process_queries(queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:34:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class TreeDistanceCalculator {\n    constructor(N) {\n        this.N = N;\n        this.graph = Array.from({ length: N + 1 }, () => []);\n        this.edges = [];\n    }\n\n    addEdge(a, b, color, length) {\n        this.graph[a].push({ node: b, color, length });\n        this.graph[b].push({ node: a, color, length });\n        this.edges.push({ a, b, color, length });\n    }\n\n    findPath(start, end) {\n        const dist = new Array(this.N + 1).fill(Infinity);\n        const parent = new Array(this.N + 1).fill(-1);\n        const queue = [start];\n        dist[start] = 0;\n\n        while (queue.length) {\n            const curr = queue.shift();\n            if (curr === end) break;\n\n            for (const neighbor of this.graph[curr]) {\n                const next = neighbor.node;\n                const edgeLength = neighbor.length;\n                if (dist[next] > dist[curr] + edgeLength) {\n                    dist[next] = dist[curr] + edgeLength;\n                    parent[next] = curr;\n                    queue.push(next);\n                }\n            }\n        }\n\n        return dist[end];\n    }\n\n    processQueries(queries) {\n        const results = [];\n\n        for (const query of queries) {\n            const { color, newLength, u, v } = query;\n\n            // Temporarily modify edge lengths\n            for (const edge of this.edges) {\n                if (edge.color === color) {\n                    const a = this.graph[edge.a].find(x => x.node === edge.b);\n                    const b = this.graph[edge.b].find(x => x.node === edge.a);\n                    a.length = newLength;\n                    b.length = newLength;\n                }\n            }\n\n            // Calculate distance\n            const distance = this.findPath(u, v);\n            results.push(distance);\n\n            // Revert lengths\n            for (const edge of this.edges) {\n                if (edge.color === color) {\n                    const a = this.graph[edge.a].find(x => x.node === edge.b);\n                    const b = this.graph[edge.b].find(x => x.node === edge.a);\n                    a.length = edge.length;\n                    b.length = edge.length;\n                }\n            }\n        }\n\n        return results;\n    }\n}\n\nfunction solve(N, edges, queries) {\n    const calculator = new TreeDistanceCalculator(N);\n    for (const [a, b, color, length] of edges) {\n        calculator.addEdge(a, b, color, length);\n    }\n    return calculator.processQueries(queries.map(([color, newLength, u, v]) => \n        ({ color, newLength, u, v })));\n}",
    "timestamp": "2025-08-13 12:34:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n\n    N = int(data[idx])\n    idx += 1\n    Q = int(data[idx])\n    idx += 1\n\n    adj = [[] for _ in range(N+1)]\n    color_to_edges = defaultdict(list)\n    original_d = {}\n\n    for _ in range(N-1):\n        a = int(data[idx])\n        idx += 1\n        b = int(data[idx])\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        d = int(data[idx])\n        idx += 1\n        adj[a].append((b, c, d))\n        adj[b].append((a, c, d))\n        color_to_edges[c].append((a, b))\n        original_d[(a, b)] = d\n        original_d[(b, a)] = d\n\n    LOG = 20\n    parent = [[-1]*(N+1) for _ in range(LOG)]\n    depth = [0]*(N+1)\n    dist = [0]*(N+1)\n\n    stack = [(1, -1, 0, 0)]\n    while stack:\n        u, p, d, current_dist = stack.pop()\n        parent[0][u] = p\n        depth[u] = d\n        dist[u] = current_dist\n        for v, c, di in adj[u]:\n            if v != p:\n                stack.append((v, u, d+1, current_dist + di))\n\n    for k in range(LOG-1):\n        for v in range(1, N+1):\n            if parent[k][v] != -1:\n                parent[k+1][v] = parent[k][parent[k][v]]\n\n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        for k in range(LOG-1, -1, -1):\n            if depth[u] - (1 << k) >= depth[v]:\n                u = parent[k][u]\n        if u == v:\n            return u\n        for k in range(LOG-1, -1, -1):\n            if parent[k][u] != -1 and parent[k][u] != parent[k][v]:\n                u = parent[k][u]\n                v = parent[k][v]\n        return parent[0][u]\n\n    def get_distance(u, v):\n        ancestor = lca(u, v)\n        return dist[u] + dist[v] - 2 * dist[ancestor]\n\n    color_to_current_d = {}\n    for c in color_to_edges:\n        color_to_current_d[c] = original_d[color_to_edges[c][0]]\n\n    for _ in range(Q):\n        x = int(data[idx])\n        idx += 1\n        y = int(data[idx])\n        idx += 1\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n\n        old_d = color_to_current_d.get(x, None)\n        if old_d is not None:\n            delta = y - old_d\n            color_to_current_d[x] = y\n            for a, b in color_to_edges[x]:\n                if parent[0][a] == b:\n                    a, b = b, a\n                stack = [b]\n                visited = set()\n                while stack:\n                    node = stack.pop()\n                    visited.add(node)\n                    for child, c, di in adj[node]:\n                        if child != parent[0][node] and child not in visited:\n                            dist[child] += delta\n                            stack.append(child)\n        print(get_distance(u, v))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 12:34:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync(0, 'utf-8').split('\\n');\n\nlet ptr = 0;\nconst readLine = () => input[ptr++] || '';\n\nconst [N, Q] = readLine().split(' ').map(Number);\nconst adj = Array.from({ length: N + 1 }, () => []);\nconst colorMap = new Map();\n\nfor (let i = 0; i < N - 1; i++) {\n    const [a, b, c, d] = readLine().split(' ').map(Number);\n    adj[a].push({ to: b, color: c, length: d });\n    adj[b].push({ to: a, color: c, length: d });\n    if (!colorMap.has(c)) colorMap.set(c, []);\n    colorMap.get(c).push({ a, b, d });\n}\n\nconst LOG = Math.floor(Math.log2(N)) + 1;\nconst parent = Array.from({ length: LOG }, () => Array(N + 1).fill(0));\nconst depth = Array(N + 1).fill(0);\nconst dist = Array(N + 1).fill(0);\nconst colorCount = Array.from({ length: N + 1 }, () => new Map());\nconst colorSum = Array.from({ length: N + 1 }, () => new Map());\n\nfunction dfs(u, p) {\n    parent[0][u] = p;\n    for (let k = 1; k < LOG; k++) {\n        parent[k][u] = parent[k - 1][parent[k - 1][u]];\n    }\n    for (const { to, color, length } of adj[u]) {\n        if (to === p) continue;\n        depth[to] = depth[u] + 1;\n        dist[to] = dist[u] + length;\n        colorCount[to] = new Map(colorCount[u]);\n        colorSum[to] = new Map(colorSum[u]);\n        colorCount[to].set(color, (colorCount[to].get(color) || 0) + 1);\n        colorSum[to].set(color, (colorSum[to].get(color) || 0) + length);\n        dfs(to, u);\n    }\n}\n\ndfs(1, 0);\n\nfunction lca(u, v) {\n    if (depth[u] < depth[v]) [u, v] = [v, u];\n    for (let k = LOG - 1; k >= 0; k--) {\n        if (depth[u] - (1 << k) >= depth[v]) {\n            u = parent[k][u];\n        }\n    }\n    if (u === v) return u;\n    for (let k = LOG - 1; k >= 0; k--) {\n        if (parent[k][u] !== parent[k][v]) {\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nfunction getColorInfo(u, v, l) {\n    let cntU = colorCount[u].get(l) || 0;\n    let cntV = colorCount[v].get(l) || 0;\n    let cntL = colorCount[l].get(l) || 0;\n    let sumU = colorSum[u].get(l) || 0;\n    let sumV = colorSum[v].get(l) || 0;\n    let sumL = colorSum[l].get(l) || 0;\n    return {\n        count: cntU + cntV - 2 * cntL,\n        sum: sumU + sumV - 2 * sumL\n    };\n}\n\nconst output = [];\nfor (let j = 0; j < Q; j++) {\n    const [x, y, u, v] = readLine().split(' ').map(Number);\n    const l = lca(u, v);\n    const originalDist = dist[u] + dist[v] - 2 * dist[l];\n    const { count, sum } = getColorInfo(u, v, x);\n    const newDist = originalDist - sum + count * y;\n    output.push(newDist);\n}\n\nconsole.log(output.join('\\n'));",
    "timestamp": "2025-08-13 12:35:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n    int to, color, length;\n};\n\nvoid bfs(int start, int end, const vector<vector<Edge>>& graph, vector<int>& dist) {\n    queue<int> q;\n    dist.assign(graph.size(), -1);\n    q.push(start);\n    dist[start] = 0;\n\n    while(!q.empty()) {\n        int current = q.front();\n        q.pop();\n\n        for(const Edge& edge : graph[current]) {\n            if(dist[edge.to] == -1) {\n                dist[edge.to] = dist[current] + edge.length;\n                q.push(edge.to);\n            }\n        }\n    }\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<vector<Edge>> graph(N + 1);\n    vector<int> lengths(N - 1);\n    vector<int> colors(N - 1);\n\n    for(int i = 1; i < N; ++i) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        graph[a].push_back({b, c, d});\n        graph[b].push_back({a, c, d});\n        lengths[i - 1] = d;\n        colors[i - 1] = c;\n    }\n\n    for(int j = 0; j < Q; ++j) {\n        int x_j, y_j, u_j, v_j;\n        cin >> x_j >> y_j >> u_j >> v_j;\n\n        vector<int> dist;\n        for(int i = 1; i <= N; ++i) {\n            for(Edge& edge : graph[i]) {\n                if(edge.color == x_j) {\n                    edge.length = y_j;\n                } else {\n                    edge.length = lengths[edge.color - 1];\n                }\n            }\n        }\n\n        bfs(u_j, v_j, graph, dist);\n\n        cout << dist[v_j] << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:35:17"
  }
]