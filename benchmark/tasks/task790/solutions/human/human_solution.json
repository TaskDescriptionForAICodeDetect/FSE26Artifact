[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <random>\n\nusing namespace std;\nrandom_device rd;\nmt19937 mt(rd());\n\nint solve(int r, int b) {\n  int an = 0;\n  for(int i=1;i<1e9;i++) {\n    // max(i-b,0) <= j && j <= min(i, r)\n    \n    int mux = max(i-b, 0);\n    int ix = min(i, r) - mux + 1;\n    int h[ix];\n    for(int j=0;j<ix;j++) {\n      h[j] = mux + j;\n    }\n    for(int j=0;j<ix;j++) {\n      int a=mt()%ix, b=mt()%ix;\n      swap(h[a],h[b]);\n    }\n    for(int j=0;j<ix;j++) {\n    //for(int j=max(i-b,0);j<i;j++) {\n      //int k = j;\n      int k = h[j];\n      if (r >= k && b >= i-k) {\n        an++; r-=k; b-=i-k;\n      }\n    }\n    if (r + b < i) break;\n  }\n  //cout<<r<<\" \"<<b<<endl;\n  return an;\n}\n\nint main() {\n  int r,b; cin>>r>>b;\n  int an = 0;\n  for(int i=0;i<35;i++) {\n    int sm = solve(r, b);\n    an=max(an,sm);\n  }\n  cout<<an<<endl;\n}\n// ・配列の大きさok？　・priority_queueはgreater？　・debug消した？\n// ・落ち着いて。提出まで4分待ってね……WJ……1/10……2/10……\n\n// Thank you for making problems and running the contest\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 27.01.2020 01:09:52       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long r, b;\n  cin >> r >> b;\n  auto Count = [&](long long p, long long q, long long bound) {\n    long long sx = 0;\n    long long sy = 0;\n    long long cnt = 0;\n    for (long long x = 0; x * p <= bound; x++) {\n      long long y = (bound - x * p) / q;\n      sx += x * (y + 1);\n      sy += y * (y + 1) / 2;\n      cnt += y + 1;\n    }\n    return make_tuple(sx, sy, cnt);\n  };\n  auto Test = [&](long long p, long long q) {\n    bool inv = false;\n    if (p < q) {\n      swap(p, q);\n      swap(r, b);\n      inv = true;\n    }\n    long long low = 0, high = 1;\n    while (true) {\n      auto got = Count(p, q, high);\n      if (get<0>(got) * p + get<1>(got) * q > r * p + b * q) {\n        break;\n      }\n      low = high;\n      high <<= 1;\n    }\n    while (low + 1 < high) {\n      long long mid = (low + high) >> 1;\n      auto got = Count(p, q, mid);\n      if (get<0>(got) * p + get<1>(got) * q > r * p + b * q) {\n        high = mid;\n      } else { \n        low = mid;\n      }\n    }\n    auto got = Count(p, q, low);\n    long long sx = get<0>(got);\n    long long sy = get<1>(got);\n    long long cnt = get<2>(got);\n    long long s = sx * p + sy * q;\n    long long add = (r * p + b * q - s) / high;\n    long long x = 0;\n    while ((high - x * p) % q != 0) {\n      ++x;\n    }\n    sx += x * add + q * (add * (add - 1) / 2);\n    long long y = (high - x * p) / q;\n    while (y >= p) {\n      x += q;\n      y -= p;\n    }\n    sy += y * add + p * (add * (add - 1) / 2);\n    cnt += add;\n    if (sx <= r && sy <= b) {\n      cout << cnt - 1 << '\\n';\n      exit(0);\n    }\n    bool ret = (sx > r) ^ inv;\n    if (inv) {\n      swap(r, b);\n    }\n    return ret;\n  };\n  long long p0 = 0, q0 = 1;\n  long long p1 = 1, q1 = 0;\n  while (true) {\n    long long low = 0, high = 1;\n    while (true) {\n      if (!Test(p0 + high * p1, q0 + high * q1)) {\n        break;\n      }\n      low = high;\n      high <<= 1;\n    }\n    while (low + 1 < high) {\n      long long mid = (low + high) >> 1;\n      if (!Test(p0 + mid * p1, q0 + mid * q1)) {\n        high = mid;\n      } else {\n        low = mid;\n      }\n    }\n    p0 += low * p1;\n    q0 += low * q1;\n    p1 += p0;\n    q1 += q0;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 05.01.2020 11:08:10       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll solve(ll n, ll a, ll b, ll m) {\n  if (b == 0) return n * (a / m);\n  if (a >= m) return n * (a / m) + solve(n, a % m, b, m);\n  if (b >= m) return n * (n - 1) / 2 * (b / m) + solve(n, a, b % m, m);\n  return solve((a + b * n) / m, (a + b * n) % m, m, b);\n}\n\npair<long long, long long> GetKBest(int k, long long cx, long long cy) {\n  long long high = (long long) sqrt(2 * k * (double) cx * (double) cy);\n  long long low = max(0LL, high - cx - cy - 1);\n  while (low < high) {\n    long long mid = (low + high) >> 1;\n    long long cnt = solve(mid / cx + 1, mid % cx, cx, cy) + (mid / cx + 1);\n    if (cnt >= k) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n  long long sx = 0, sy = 0;\n  for (int x = 0; x * cx <= high; x++) {\n    long long cc = (high - x * cx) / cy + 1;\n    sx += cc * x;\n    sy += cc * (cc - 1) / 2;\n  }\n  return {sx, sy};\n}\n\nbool Solvable(int k, int X, int Y) {\n  auto a = make_pair(-1LL, -1LL), b = a;\n  long long total = (long long) 1e9 + 7;\n  long long low = 0, high = total;\n  while (low < high) {\n    long long mid = (low + high) >> 1;\n    auto p = GetKBest(k, total - mid, mid);\n    if (p.first <= X && p.second <= Y) {\n      return true;\n    }\n    if (p.first >= X && p.second >= Y) {\n      return false;\n    }\n    if (p.first < X) {\n      a = p;\n      low = mid + 1;\n    } else {\n      b = p;\n      high = mid;\n    }\n  }\n  return (a.second * (b.first - X) + b.second * (X - a.first) <= Y * (b.first - a.first));\n}\n\nint main() {\n  int X, Y;\n  cin >> X >> Y;\n  if (X > Y) {\n    swap(X, Y);\n  }\n  int low = 3, high = (int) 2e6;\n  while (low < high) {\n    int mid = (low + high + 1) >> 1;\n    if (Solvable(mid, X, Y)) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  cout << low - 1 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n\nconst long P = 10000000019;\n\nint main() {\n  long R, B;\n  cin.sync_with_stdio(0);\n  cin >> R >> B;\n  long Kl = 1, Kh = 2*(sqrt(2*max(R,B))+1);\n  while (Kl < Kh) {\n    long K = Kl+Kh+1 >> 1, pl = 1, ph = P, lx = 0, ly, rx = 0, ry;\n    while (pl < ph) {\n      long p = pl+ph >> 1, zl = 0, zh = p*K;\n      while (zl < zh) {\n        long z = zl+zh >> 1, c = 0;\n        // c : px+qy <= z\n        for (long px = 0; px <= z && (c += (z-px)/(P-p)+1) <= K; px += p);\n        if (c <= K) zl = z+1;\n        else zh = z;\n      }\n      long sx = 0, sy = 0;\n      for (long x = 0; p*x <= zl; x++) {\n        long y = (zl-p*x)/(P-p);\n        sx += x*(y+1);\n        sy += y*(y+1)/2;\n      }\n      if (R < sx) {\n        if (!rx || sx < rx)\n          rx = sx, ry = sy;\n        if (B <= sy) {\n          Kh = K-1;\n          goto out;\n        }\n        pl = p+1;\n      } else {\n        if (!lx || lx < sx)\n          lx = sx, ly = sy;\n        if (B >= sy) {\n          Kl = K;\n          goto out;\n        }\n        ph = p;\n      }\n    }\n    // (R,B) is on or above the hull (lx,ly)-(rx,ry)\n    if ((R-lx)*(ry-ly) <= (B-ly)*(rx-lx))\n      Kl = K;\n    else\n      Kh = K-1;\n    out:;\n  }\n  cout << Kl << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long P = (long long) 1e15 + 19;\n\nlong long count_lattice_points(long long p, long long z) {\n  long long q = P - p;\n  long long ans = 0;\n  if (p < q) {\n    for (int y = 0; y * q <= z; ++y) {\n      ans += (z - y * q) / p + 1;\n    }\n  } else {\n    for (int x = 0; x * p <= z; ++x) {\n      ans += (z - x * p) / q + 1;\n    }\n  }\n  return ans;\n}\n\npair<long long, long long> sum_lattice_points(long long p, long long z, int remain) {\n  long long q = P - p;\n  long long sum_x = 0;\n  long long sum_y = 0;\n  if (p < q) {\n    for (int y = 0; y * q <= z; ++y) {\n      long long max_x = (z - y * q) / p;\n      sum_x += max_x * (max_x + 1) / 2;\n      sum_y += y * (max_x + 1);\n      if (remain && (z + 1 - y * q) % p == 0) {\n        --remain;\n        sum_x += (z + 1 - y * q) / p;\n        sum_y += y;\n      }\n    }\n  } else {\n    for (int x = 0; x * p <= z; ++x) {\n      long long max_y = (z - x * p) / q;\n      sum_x += x * (max_y + 1);\n      sum_y += max_y * (max_y + 1) / 2;\n      if (remain && (z + 1 - x * p) % q == 0) {\n        --remain;\n        sum_x += x;\n        sum_y += (z + 1 - x * p) / q;\n      }\n    }\n  }\n  return make_pair(sum_x, sum_y);\n}\n\nlong long binary_search_z(long long p, int k) {\n  long long l = 0, r = P * 2000;\n  while (l < r) {\n    long long z = (l + r + 1) >> 1;\n    if (count_lattice_points(p, z) <= k) {\n      l = z;\n    } else {\n      r = z - 1;\n    }\n  }\n  return l;\n}\n\nbool check(int x, int y, int k) {\n  long long l = 0, r = P;\n  while (r - l > 1) {\n    long long p = (l + r) >> 1;\n    long long z = binary_search_z(p, k);\n    pair<long long, long long> s = sum_lattice_points(p, z, k - count_lattice_points(p, z));\n    if (s.first <= x) {\n      if (s.second <= y) {\n        return true;\n      } else {\n        r = p;\n      }\n    } else {\n      if (s.second <= y) {\n        l = p;\n      } else {\n        return false;\n      }\n    }\n  }\n  return false;\n}\n\nint main() {\n  int x, y;\n  cin >> x >> y;\n  int l = 1, r = (int) 4e6;\n  while (l < r) {\n    int k = (l + r + 1) >> 1;\n    if (check(x, y, k)) {\n      l = k;\n    } else {\n      r = k - 1;\n    }\n  }\n  cout << l - 1 << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 05.01.2020 11:08:10       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll solve(ll n, ll a, ll b, ll m) {\n  if (b == 0) return n * (a / m);\n  if (a >= m) return n * (a / m) + solve(n, a % m, b, m);\n  if (b >= m) return n * (n - 1) / 2 * (b / m) + solve(n, a, b % m, m);\n  return solve((a + b * n) / m, (a + b * n) % m, m, b);\n}\n\npair<long long, long long> GetKBest(int k, long long cx, long long cy) {\n  long long low = 0, high = 1;\n  while (true) {\n    long long cnt = solve(high / cx + 1, high % cx, cx, cy) + (high / cx + 1);\n    if (cnt >= k) {\n      break;\n    }\n    low = high + 1;\n    high = 2 * high;\n  }\n  while (low < high) {\n    long long mid = (low + high) >> 1;\n    long long cnt = solve(mid / cx + 1, mid % cx, cx, cy) + (mid / cx + 1);\n    if (cnt >= k) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n  long long sx = 0, sy = 0;\n  for (int x = 0; x * cx <= high; x++) {\n    long long cc = (high - x * cx) / cy + 1;\n    sx += cc * x;\n    sy += cc * (cc - 1) / 2;\n  }\n  return {sx, sy};\n}\n\nbool Solvable(int k, int X, int Y) {\n  auto a = make_pair(-1LL, -1LL), b = a;\n  long long total = (long long) 1e9 + 7;\n  long long low = 0, high = total;\n  while (low < high) {\n    long long mid = (low + high) >> 1;\n    auto p = GetKBest(k, total - mid, mid);\n    if (p.first <= X && p.second <= Y) {\n      return true;\n    }\n    if (p.first >= X && p.second >= Y) {\n      return false;\n    }\n    if (p.first < X) {\n      a = p;\n      low = mid + 1;\n    } else {\n      b = p;\n      high = mid;\n    }\n  }\n  return (a.second * (b.first - X) + b.second * (X - a.first) <= Y * (b.first - a.first));\n}\n\nint main() {\n  int X, Y;\n  cin >> X >> Y;\n  if (X > Y) {\n    swap(X, Y);\n  }\n  int low = 3, high = (int) 2e6;\n  while (low < high) {\n    int mid = (low + high + 1) >> 1;\n    if (Solvable(mid, X, Y)) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  cout << low - 1 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n\nconst long P = 10000000019;\n\nint main() {\n  long R, B;\n  cin.sync_with_stdio(0);\n  cin >> R >> B;\n  long Kl = 1, Kh = sqrt(8*max(R,B));\n  while (Kl < Kh) {\n    long K = Kl+Kh+1 >> 1, pl = 1, ph = P-1;\n    while (pl < ph) {\n      long p = pl+ph >> 1, zl = 0, zh = p*K;\n      while (zl < zh) {\n        long z = zl+zh >> 1, c = 0;\n        // c : px+qy <= z\n        for (long px = 0; px <= z && (c += (z-px)/(P-p)+1) <= K; px += p);\n        if (c <= K) zl = z+1;\n        else zh = z;\n      }\n      long c = 0, sx = 0, sy = 0;\n      for (long x = 0; p*x <= zl; x++) {\n        long y = (zl-p*x)/(P-p);\n        sx += x*(y+1);\n        sy += y*(y+1)/2;\n        c += (zl-p*x)/(P-p)+1;\n      }\n      if (R < sx) {\n        if (B <= sy)\n          break;\n        pl = p+1;\n      } else {\n        if (B >= sy) {\n          Kl = K;\n          goto out;\n        }\n        ph = p;\n      }\n    }\n    Kh = K-1;\n    out:;\n  }\n  cout << Kl << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 05.01.2020 11:08:10       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll solve(ll n, ll a, ll b, ll m) {\n  if (b == 0) return n * (a / m);\n  if (a >= m) return n * (a / m) + solve(n, a % m, b, m);\n  if (b >= m) return n * (n - 1) / 2 * (b / m) + solve(n, a, b % m, m);\n  return solve((a + b * n) / m, (a + b * n) % m, m, b);\n}\n\npair<long long, long long> GetKBest(int k, long long cx, long long cy) {\n  long long low = 0, high = 1;\n  while (true) {\n    long long cnt = solve(high / cx + 1, high % cx, cx, cy) + (high / cx + 1);\n    if (cnt >= k) {\n      break;\n    }\n    low = high + 1;\n    high = 2 * high;\n  }\n  while (low < high) {\n    long long mid = (low + high) >> 1;\n    long long cnt = solve(mid / cx + 1, mid % cx, cx, cy) + (mid / cx + 1);\n    if (cnt >= k) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n  long long sx = 0, sy = 0;\n  for (int x = 0; x * cx <= high; x++) {\n    long long cc = (high - x * cx) / cy + 1;\n    sx += cc * x;\n    sy += cc * (cc - 1) / 2;\n  }\n  return {sx, sy};\n}\n\nbool Solvable(int k, int X, int Y) {\n  auto a = make_pair(-1LL, -1LL), b = a;\n  long long total = (long long) 1e9 + 7;\n  long long low = 0, high = total;\n  while (low < high) {\n    long long mid = (low + high) >> 1;\n    auto p = GetKBest(k, total - mid, mid);\n    if (p.first <= X && p.second <= Y) {\n      return true;\n    }\n    if (p.first < X) {\n      a = p;\n      low = mid + 1;\n    } else {\n      b = p;\n      high = mid;\n    }\n  }\n  return (a.second * (b.first - X) + b.second * (X - a.first) <= Y * (b.first - a.first));\n}\n\nint main() {\n  int X, Y;\n  cin >> X >> Y;\n  if (X > Y) {\n    swap(X, Y);\n  }\n  int low = 3, high = (int) 2e6;\n  while (low < high) {\n    int mid = (low + high + 1) >> 1;\n    if (Solvable(mid, X, Y)) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  cout << low - 1 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <random>\n\nusing namespace std;\nrandom_device rd;\nmt19937 mt(rd());\n\nint solve(int r, int b) {\n  int an = 0;\n  for(int i=1;i<1e9;i++) {\n    // max(i-b,0) <= j && j <= min(i, r)\n    \n    int mux = max(i-b, 0);\n    int ix = min(i, r) - mux + 1;\n    int h[ix];\n    for(int j=0;j<ix;j++) {\n      h[j] = mux + j;\n    }\n    for(int j=0;j<ix;j++) {\n      int a=mt()%ix, b=mt()%ix;\n      swap(h[a],h[b]);\n    }\n    for(int j=0;j<ix;j++) {\n    //for(int j=max(i-b,0);j<i;j++) {\n      //int k = j;\n      int k = h[j];\n      if (r >= k && b >= i-k) {\n        an++; r-=k; b-=i-k;\n      }\n      if (r < k) break;\n    }\n    if (r + b < i) break;\n  }\n  //cout<<r<<\" \"<<b<<endl;\n  return an;\n}\n\nint main() {\n  int r,b; cin>>r>>b;\n  int an = 0;\n  for(int i=0;i<20;i++) {\n    int sm = solve(r, b);\n    if (an<sm) {\n      //cout<<sm<<endl;\n      an=sm;\n    }\n  }\n  cout<<an<<endl;\n}\n// ・配列の大きさok？　・priority_queueはgreater？　・debug消した？\n// ・落ち着いて。提出まで4分待ってね……WJ……1/10……2/10……\n\n// Thank you for making problems and running the contest\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll A,B;\nconst ll M=10000000000LL+19;\n\nll hoge2(ll p,ll C) {\n\tll q=M-p;\n\t\n\tll X=C/p;\n\tll Y=C/q;\n\t\n\tif(X==0) return Y+1;\n\tif(Y==0) return X+1;\n\t\n\tif(X>=1<<30 || Y>=1<<30 || (X-1)*(Y-1)/2>=1LL<<30) return 1LL<<30;\n\tif(p<q) swap(p,q);\n\t\n\tll ret=0;\n\tfor(int i=0;p*i<=C;i++) {\n\t\tll v=(C-p*i)/q;\n\t\tret+=v+1;\n\t\tif(ret>1LL<<25) break;\n\t}\n\treturn ret;\n\t\n}\n\npair<ll,ll> hoge(ll p,ll K) {\n\t\n\tll C=1LL<<61;\n\tfor(int i=60;i>=0;i--) if(hoge2(p,C-(1LL<<i))>=K) C-=1LL<<i;\n\tll q=M-p;\n\tll a=0,b=0;\n\tif(p>q) {\n\t\tfor(int i=0;p*i<=C;i++) {\n\t\t\tll v=(C-p*i)/q;\n\t\t\ta+=(v+1)*i;\n\t\t\tb+=v*(v+1)/2;\n\t\t}\n\t}\n\telse {\n\t\tfor(int i=0;q*i<=C;i++) {\n\t\t\tll v=(C-q*i)/p;\n\t\t\tb+=(v+1)*i;\n\t\t\ta+=v*(v+1)/2;\n\t\t}\n\t}\n\t\n\treturn {a,b};\n\t\n}\n\n\nint ok(int K) {\n\tll p=1;\n\t\n\tauto r=hoge(p,K);\n\tif(r.first>A&&r.second>B) return 0;\n\tif(r.first<=A&&r.second<=B) return 1;\n\tint i;\n\tfor(i=40;i>=0;i--) if(p+(1LL<<i)<M) {\n\t\tauto r=hoge(p+(1LL<<i),K);\n\t\tif(r.first>A&&r.second>B) return 0;\n\t\tif(r.first<=A&&r.second<=B) return 1;\n\t\tif(r.first>A) p+=1LL<<i;\n\t\t\n\t}\n\tr=hoge(p,K);\n\tif(r.first>A&&r.second>B) return 0;\n\tif(r.first<=A&&r.second<=B) return 1;\n\tauto r2=hoge(p+1,K);\n\tif(r2.first>A&&r2.second>B) return 0;\n\tif(r2.first<=A&&r2.second<=B) return 1;\n\t\n\tassert(r.first>=A&&r.second<=B&&r2.first<=A&&r2.second>=B);\n\tll ax=r2.first-r.first;\n\tll ay=r2.second-r.second;\n\tll bx=A-r.first;\n\tll by=B-r.second;\n\tif(ax*by-bx*ay<=0) return 1;\n\t\n\treturn 0;\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>A>>B;\n\t\n\tint K=0;\n\tfor(i=20;i>=0;i--) if(ok(K+(1<<i))) K+=1<<i;\n\tcout<<K-1<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int r,b,i,j;\n    int a1=0,a2=0,sum=0;\n    cin>>r>>b;\n    if(r<=b){\n        for(i=0,j=1;a1<r||a2<b;i++){\n            if(a1<r){\n                a1+=j;\n                a2+=i;\n                sum++;\n            }\n            if(a2<b&&b-a2>=i+1&&j==1){\n                a2+=i+1;\n                sum++;\n            }\n            else if(b-a2<i+1){\n                if(a1==r)\n                a2=b;\n                j++;\n                i=-1;\n            }\n        }\n    }\n    else{\n        for(i=0,j=1;a1<r||a2<b;i++){\n            if(a2<b){\n                a2+=j;\n                a1+=i;\n                sum++;\n            }\n            if(a1<r&&r-a1>=i+1&&j==1){\n                a1+=i+1;\n                sum++;\n            }\n            else if(r-a1<i+1){\n                if(a2==b)\n                a1=r;\n                j++;\n                i=-1;\n            }\n        }\n    }\n    cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T, typename S>\nostream& operator<<(ostream& os, pair<S, T> t){\n    os << \"(\" << t.first << \", \" << t.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> t){\n    long c = 0;\n    for(auto i : t)os << (c++ ? \", \" : \"{\") << i;\n    os << \"}\";\n    return os;\n}\n\nint main(){\n    long R, B;\n    cin >> R >> B;\n    if(R > B)swap(R, B);\n\n    auto hoge = [](long RR, long BB, long X, long R, long B){\n        long b = 0, r = 0;\n        long t = X + RR, x = 0;\n        while(t >= 0){\n            b += (t / RR) * (t / RR - 1) / 2;\n            r += x * (t / RR);\n            if(b > B || r > R)return 0;\n            t -= BB;\n            ++x;\n        }\n        return 1;\n    };\n\n    auto nibutan = [&hoge](long RR, long BB, long R, long B){\n        if(RR < BB){\n            swap(RR, BB);\n            swap(R, B);\n        }\n        cerr << RR << \" \" << BB << \" : \" << R << \" \" << B << endl;\n\n        long r = 0, l = 1;\n\n        while(hoge(RR, BB, l, R, B))l <<= 1;\n\n        while(r + 1 < l){\n            long mid = (l + r) / 2;\n            (hoge(RR, BB, mid, R, B) ? r : l) = mid;\n        }\n        cerr << r << \" : \" << l << endl;\n\n        vector<pair<long, long>> rem;\n        long remr = R, remb = B, c = 0;\n        {\n            long t = r + RR, s = t + 1, x = 0;\n            while(s >= 0){\n                if(!(s % RR) && rem.size() <= 1){\n                    rem.emplace_back(t / RR, x);\n                    if(rem.size() > 1){\n                        rem[1].first -= rem[0].first;\n                        rem[1].second -= rem[0].second;\n                    }\n                }\n                remr -= x * (t / RR);\n                remb -= (t / RR) * (t / RR - 1) / 2;\n                c += (t / RR);\n                t -= BB;\n                s -= BB;\n                ++x;\n            }\n        }\n        assert(remr >= 0 && remb >= 0);\n\n        if(rem.size() <= 1)return c;\n\n        long j = 0, k = (rem[0].first - rem[1].first - 1) / -rem[1].first, m = k - 1;\n\n        auto tapi = [&remr, remb, rem, m](long a){\n            long lb = (a * rem[0].first - remb) / -rem[1].first, ub = (remr - a * rem[0].second) / rem[1].second;\n            return ub >= lb && ub >= a * (a - 1) / 2 && lb <= a * (2 * m + 1 - a) / 2;\n        };\n\n        cerr << r << \" : \" << c << \" : \" << rem << \" : \" << remr << \", \" << remb << \" : \" << k << endl;\n\n        assert(tapi(j) && !tapi(k));\n\n        while(j + 1 < k){\n            long mid = (j + k) / 2;\n            (tapi(mid) ? j : k) = mid;\n        }\n\n        return c + j;\n    };\n\n    auto cfexpand = [](long A, long B){\n        vector<pair<long, long>> ret;\n        long a(1), b(0), c(0), d(1), x(A), y(B);\n        auto comp = [](long& a, long& b, long x){\n            swap(a, b);\n            a += b * x;\n        };\n        while(y){\n            auto t = x / y;\n            comp(a, b, t);\n            comp(c, d, t);\n            ret.emplace_back(a, c);\n            swap(x, y);\n            y %= x;\n        }\n        return ret;\n    };\n\n    /*//long l = 0, r = 20 * B + 1000;\n    long l = 9999999980, r = 10000000000;\n    long mi1, mi2;\n\n    while(r - l > 700){\n        mi1 = (2 * l + r) / 3;\n        mi2 = (l + 2 * r) / 3;\n        long k1 = nibutan(10 * R, mi1, R, B), k2 = nibutan(10 * R, mi2, R, B);\n        cerr << mi1 << \" : \" << k1 << \" \" << mi2 << \" : \" << k2 << endl;\n        k1 > k2 ? r = mi2 : k1 < k2 || mi1 & 1 ? l = mi1 : r = mi2;\n    }\n\n    long ans = numeric_limits<long>::min();\n    for(l += l ? 0 : 1; l <= r; ++l){\n        cerr << l << \" : \" << nibutan(10 * R, l, R, B) - 1 << \" : \" << ans << endl;\n        ans = max(ans, nibutan(10 * R, l, R, B));\n    }\n    cout << ans - 1 << endl;\n    cout << nibutan(10 * R, 10 * R, R, B) - 1 << endl;*/\n\n    auto t = cfexpand(B, R);\n    cerr << t << endl;\n    long ans = numeric_limits<long>::min();\n    for(auto i : t){\n        ans = max(ans, nibutan(i.second, i.first, R, B));\n        cerr << i << \" : \" << ans << endl << endl;\n    }\n    cout << ans - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n\nconst long P = 10000000019;\n\nint main() {\n  long R, B;\n  cin.sync_with_stdio(0);\n  cin >> R >> B;\n  long Kl = 1, Kh = 2*(sqrt(2*max(R,B))+1);\n  while (Kl < Kh) {\n    long K = Kl+Kh+1 >> 1, pl = 1, ph = P;\n    while (pl < ph) {\n      long p = pl+ph >> 1, zl = 0, zh = p*K;\n      while (zl < zh) {\n        long z = zl+zh >> 1, c = 0;\n        // c : px+qy <= z\n        for (long px = 0; px <= z && (c += (z-px)/(P-p)+1) <= K; px += p);\n        if (c <= K) zl = z+1;\n        else zh = z;\n      }\n      long c = 0, sx = 0, sy = 0;\n      for (long x = 0; p*x <= zl; x++) {\n        long y = (zl-p*x)/(P-p);\n        sx += x*(y+1);\n        sy += y*(y+1)/2;\n        c += (zl-p*x)/(P-p)+1;\n      }\n      if (R < sx) {\n        if (B < sy) {\n          Kh = K-1;\n          goto out;\n        }\n        pl = p+1;\n      } else {\n        if (B >= sy) {\n          Kl = K;\n          goto out;\n        }\n        ph = p;\n      }\n    }\n    Kl = K;\n    out:;\n  }\n  cout << Kl << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T, typename S>\nostream& operator<<(ostream& os, pair<S, T> t){\n    os << \"(\" << t.first << \", \" << t.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> t){\n    long c = 0;\n    for(auto i : t)os << (c++ ? \", \" : \"{\") << i;\n    os << \"}\";\n    return os;\n}\n\nint main(){\n    long R, B;\n    cin >> R >> B;\n    if(R > B)swap(R, B);\n\n    auto hoge = [](long RR, long BB, long X, long R, long B){\n        long b = 0, r = 0;\n        long t = X + RR, x = 0;\n        while(t >= 0){\n            b += (t / RR) * (t / RR - 1) / 2;\n            r += x * (t / RR);\n            if(b > B || r > R)return 0;\n            t -= BB;\n            ++x;\n        }\n        return 1;\n    };\n\n    auto nibutan = [&hoge](long RR, long BB, long R, long B){\n        if(RR > BB){\n            swap(RR, BB);\n            swap(R, B);\n        }\n        cerr << RR << \" \" << BB << \" : \" << R << \" \" << B << endl;\n\n        long r = 0, l = 1;\n\n        while(hoge(RR, BB, l, R, B))l <<= 1;\n\n        while(r + 1 < l){\n            long mid = (l + r) / 2;\n            (hoge(RR, BB, mid, R, B) ? r : l) = mid;\n        }\n        cerr << r << \" : \" << l << endl;\n\n        vector<pair<long, long>> rem;\n        long remr = R, remb = B, c = 0;\n        {\n            long t = r + RR, s = t + 1, x = 0;\n            while(s >= 0){\n                if(!(s % RR) && rem.size() <= 1){\n                    rem.emplace_back(t / RR, x);\n                    if(rem.size() > 1){\n                        rem[1].first -= rem[0].first;\n                        rem[1].second -= rem[0].second;\n                    }\n                }\n                remr -= x * (t / RR);\n                remb -= (t / RR) * (t / RR - 1) / 2;\n                c += (t / RR);\n                t -= BB;\n                s -= BB;\n                ++x;\n            }\n        }\n        assert(remr >= 0 && remb >= 0);\n\n        if(rem.size() <= 1)return c;\n\n        long j = 0, k = (rem[0].first - rem[1].first - 1) / -rem[1].first, m = k - 1;\n\n        auto tapi = [&remr, remb, rem, m](long a){\n            long lb = (a * rem[0].first - remb - rem[1].first - 1) / -rem[1].first, ub = (remr - a * rem[0].second) / rem[1].second;\n            return ub >= lb && ub >= a * (a - 1) / 2 && lb <= a * (2 * m + 1 - a) / 2;\n        };\n\n        cerr << r << \" : \" << c << \" : \" << rem << \" : \" << remb << \", \" << remr << \" : \" << k << endl;\n\n        assert(tapi(j) && !tapi(k));\n\n        while(j + 1 < k){\n            long mid = (j + k) / 2;\n            (tapi(mid) ? j : k) = mid;\n        }\n\n        return c + j;\n    };\n\n    auto cfexpand = [](long A, long B){\n        vector<pair<long, long>> ret;\n        long a(1), b(0), c(0), d(1), x(A), y(B);\n        auto comp = [](long& a, long& b, long x){\n            swap(a, b);\n            a += b * x;\n        };\n        while(y){\n            auto t = x / y;\n            comp(a, b, t);\n            comp(c, d, t);\n            ret.emplace_back(a, c);\n            swap(x, y);\n            y %= x;\n        }\n        return ret;\n    };\n\n    /*//long l = 0, r = 20 * B + 1000;\n    long l = 9999999980, r = 10000000000;\n    long mi1, mi2;\n\n    while(r - l > 700){\n        mi1 = (2 * l + r) / 3;\n        mi2 = (l + 2 * r) / 3;\n        long k1 = nibutan(10 * R, mi1, R, B), k2 = nibutan(10 * R, mi2, R, B);\n        cerr << mi1 << \" : \" << k1 << \" \" << mi2 << \" : \" << k2 << endl;\n        k1 > k2 ? r = mi2 : k1 < k2 || mi1 & 1 ? l = mi1 : r = mi2;\n    }\n\n    long ans = numeric_limits<long>::min();\n    for(l += l ? 0 : 1; l <= r; ++l){\n        cerr << l << \" : \" << nibutan(10 * R, l, R, B) - 1 << \" : \" << ans << endl;\n        ans = max(ans, nibutan(10 * R, l, R, B));\n    }\n    cout << ans - 1 << endl;\n    cout << nibutan(10 * R, 10 * R, R, B) - 1 << endl;*/\n\n    auto t = cfexpand(B, R);\n    cerr << t << endl;\n    long ans = numeric_limits<long>::min();\n    for(auto i : t){\n        ans = max(ans, nibutan(i.second, i.first, R, B));\n        cerr << i << \" : \" << ans << endl << endl;\n    }\n    cout << ans - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing ll = long long;\nconstexpr ll sum = 1e10 + 19;\nstruct point\n{\n\tll x, y;\n\tinline point operator +(const point &a) const { return {x + a.x, y + a.y}; }\n\tinline point operator -(const point &a) const { return {x - a.x, y - a.y}; }\n\tinline ll operator *(const point &a) const { return x * a.y - y * a.x; }\n};\ninline ll calc_cnt(ll p, ll lim)\n{\n\tll q = sum - p, res = 0;\n\tif (p > q)\n\t\tstd::swap(p, q);\n\tfor (int y = 0; y * q <= lim; y++)\n\t\tres += (lim - y * q) / p + 1;\n\treturn res;\n}\ninline point calc_sum(ll p, ll lim, int rem)\n{\n\trem -= calc_cnt(p, lim);\n\tll q = sum - p;\n\tpoint res = {0, 0};\n\tbool rev = p > q;\n\tif (rev)\n\t\tstd::swap(p, q);\n\tfor (int y = 0; y * q <= lim; y++)\n\t{\n\t\tll mx_x = (lim - y * q) / p;\n\t\tres = res + (point) {mx_x * (mx_x + 1) / 2, y * (mx_x + 1)};\n\t\tif (rem && !((lim + 1 - y * q) % p))\n\t\t{\n\t\t\tres = res + (point) {(lim + 1 - y * q) / p, y};\n\t\t\trem--;\n\t\t}\n\t}\n\tif (rev)\n\t\tstd::swap(res.x, res.y);\n\treturn res;\n}\ninline ll search(ll p, int k)\n{\n\tll l = 0, r = sum * 2000, res = -1;\n\twhile (l <= r)\n\t{\n\t\tll mid = l + r >> 1;\n\t\tif (calc_cnt(p, mid) <= k)\n\t\t{\n\t\t\tres = mid;\n\t\t\tl = mid + 1;\n\t\t}\n\t\telse\n\t\t\tr = mid - 1;\n\t}\n\treturn res;\n}\ninline bool check(int n, int m, int k)\n{\n\tauto calc = [&] (ll p) { return calc_sum(p, search(p, k), k); };\n\tll l = 0, r = sum;\n\twhile (l + 1 < r)\n\t{\n\t\tll mid = l + r >> 1;\n\t\tpoint res = calc(mid);\n\t\tif (res.x <= n && res.y <= m)\n\t\t\treturn true;\n\t\telse if (res.x <= n)\n\t\t\tr = mid;\n\t\telse if (res.y <= m)\n\t\t\tl = mid;\n\t\telse\n\t\t\treturn false;\n\t}\n\tpoint res_l = calc(l), res_r = calc(r);\n\treturn (res_r - res_l) * ((point) {n, m} - res_l) <= 0;\n}\nint main()\n{\n\t// freopen(\"D.in\", \"r\", stdin);\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tint l = 1, r = 4e6, ans = -1;\n\twhile (l <= r)\n\t{\n\t\tint mid = l + r >> 1;\n\t\tif (check(n, m, mid))\n\t\t{\n\t\t\tans = mid;\n\t\t\tl = mid + 1;\n\t\t}\n\t\telse\n\t\t\tr = mid - 1;\n\t}\n\tprintf(\"%d\\n\", ans - 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long P = (long long) 1e10 + 19;\n\nlong long count_lattice_points(long long p, long long z) {\n  long long q = P - p;\n  long long ans = 0;\n  if (p < q) {\n    for (int y = 0; y * q <= z; ++y) {\n      ans += (z - y * q) / p + 1;\n    }\n  } else {\n    for (int x = 0; x * p <= z; ++x) {\n      ans += (z - x * p) / q + 1;\n    }\n  }\n  return ans;\n}\n\npair<long long, long long> sum_lattice_points(long long p, long long z, int remain) {\n  long long q = P - p;\n  long long sum_x = 0;\n  long long sum_y = 0;\n  if (p < q) {\n    for (int y = 0; y * q <= z; ++y) {\n      long long max_x = (z - y * q) / p;\n      sum_x += max_x * (max_x + 1) / 2;\n      sum_y += y * (max_x + 1);\n      if (remain && (z + 1 - y * q) % p == 0) {\n        --remain;\n        sum_x += (z + 1 - y * q) / p;\n        sum_y += y;\n      }\n    }\n  } else {\n    for (int x = 0; x * p <= z; ++x) {\n      long long max_y = (z - x * p) / q;\n      sum_x += x * (max_y + 1);\n      sum_y += max_y * (max_y + 1) / 2;\n      if (remain && (z + 1 - x * p) % q == 0) {\n        --remain;\n        sum_x += x;\n        sum_y += (z + 1 - x * p) / q;\n      }\n    }\n  }\n  return make_pair(sum_x, sum_y);\n}\n\nlong long binary_search_z(long long p, int k) {\n  long long l = 0, r = P * 2000;\n  while (l < r) {\n    long long z = (l + r + 1) >> 1;\n    if (count_lattice_points(p, z) <= k) {\n      l = z;\n    } else {\n      r = z - 1;\n    }\n  }\n  return l;\n}\n\nbool check(int x, int y, int k) {\n  long long l = 0, r = P;\n  while (r - l > 1) {\n    long long p = (l + r) >> 1;\n    long long z = binary_search_z(p, k);\n    pair<long long, long long> s = sum_lattice_points(p, z, k - count_lattice_points(p, z));\n    if (s.first <= x) {\n      if (s.second <= y) {\n        return true;\n      } else {\n        r = p;\n      }\n    } else {\n      if (s.second <= y) {\n        l = p;\n      } else {\n        return false;\n      }\n    }\n  }\n  return false;\n}\n\nint main() {\n  int x, y;\n  cin >> x >> y;\n  int l = 1, r = (int) 4e6;\n  while (l < r) {\n    int k = (l + r + 1) >> 1;\n    if (check(x, y, k)) {\n      l = k;\n    } else {\n      r = k - 1;\n    }\n  }\n  cout << l - 1 << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\ntypedef pair<ll,ll> P;\n\nconstexpr ll C=1000000007;\n//傾きと作る箱の個数から必要なボールの個数\nP need(int k,int p){\n   int q=C-p; ll lb=0,rb=C*2020;\n   while(rb-lb>1){\n      ll mid=(lb+rb)/2,cnt=0;\n      rep(x,0,mid/p+1){\n         cnt+=(mid-x*p)/q+1;\n         if(cnt>=k)break;\n      } if(cnt<k)lb=mid; else rb=mid;\n   }\n   P res({0,0});\n   rep(x,0,rb/p+1){\n      ll y=(rb-x*p)/q;\n      res.first+=x*(y+1); res.second+=y*(y+1)/2;\n   } return res;\n}\n\n//箱の個数とボールの個数から判定\nbool check(int k,int r,int b){\n   int lb=0,rb=C+1; P x,y;\n   while(rb-lb>1){\n      int mid=(lb+rb)/2; P p=need(k,mid);\n      if(p.first<=r&&p.second<=b)return true;\n      if(p.first>r&&p.second>b)return false;\n      if(p.first>r)x=p,lb=mid; else y=p,rb=mid;\n   } return (y.first-x.first)*(b-x.second)<=(y.second-x.second)*(r-x.first);\n}\n\n//reference:https://physics0523.hatenablog.com/entry/2020/02/05/024612\nint main(){\n   int r,b; cin>>r>>b; if(r>b)swap(r,b);\n   int lb=0,rb=1341398*2;\n   while(rb-lb>1){\n      int mid=(lb+rb)/2;\n      if(check(mid,r,b))lb=mid; else rb=mid;\n   } cout<<lb-1<<endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <math.h>\n\nusing namespace std;\n#define LL long long\nusing VS = vector<string>;\nusing VI = vector<int>;\nusing VL = vector<LL>;\nusing VVI = vector<VI>;\nusing VVL = vector<VL>;\n#define FOR(i,s,e) for(i = s; i < e; i++)\n#define FORR(i,s,e) for(i = e-1; i >= s; i--)\nconst LL INF = (LL)1e16;\nconst LL MOD = (LL)1e9 + 7;\n\n\n// A\n\n// B\n\n// C\nLL f(LL n){\n  return n*(n+1)/2;\n}\n\nint main(){\n  LL r,b,ans = 0,i = 0,a,c,e,d,k = 0;\n  cin >> r >> b;\n  FOR(i,1,1500000){\n    r -= f(i);\n    b -= f(i);\n    if (r < 0 || b < 0){\n      r += f(i);\n      b += f(i);\n      break;\n    }\n    ans += i+1;\n  }\n  a = max(r,b);\n  c = min(r,b);\n  while (a+c >= i){\n    FOR(k,0,i+1){\n      if (a >= i-k && c >= k){\n        a -= i-k;\n        c -= k;\n        ans ++;\n      }\n    }\n    i ++;\n    d = max(a,c);\n    e = min(a,c);\n    a = d;\n    c = e;\n  }\n  cout << ans << endl;\n  return 0;\n}\n// D\n\n// E\n\n// F\n\n// G\n\n// H\n\n// I\n\n// J\n\n// K\n\n// L\n\n// M\n\n// N\n\n// O\n\n// P\n\n// Q\n\n// R\n\n// S\n\n// T\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll MAXP = 10000000019ll;\nint A, B;\nll count_below_line(ll p, ll q, ll m, ll bound)\n{\n\tif (p<q) swap(p, q);\n\tll ans = 0;\n\tfor (int i=0; i<=m/p&&ans<=bound; i++)\n\t{\n\t\tans += (m-i*p)/q;\n\t}\n\treturn ans;\n}\npair<ll,ll> sum_below_line(ll p, ll q, ll m, ll K)\n{\n//\tcerr<<\"sum_below_line:\"<<p<<\",\"<<q<<\" \"<<m<<\" \"<<K<<\"  \"<<count_below_line(p, q, m, K)<<endl;\n\tbool flag = 0;\n\tif (p<q) swap(p, q), flag = 1;\n\tll x = 0, y = 0;\n\tfor (int i=0; i*p<=m-1; i++)\n\t{\n\t\tll cnt = (m-1-i*p)/q;\n\t\tK -= cnt;\n\t\tx += cnt*i;\n\t\ty += 1ll*cnt*(cnt-1)/2;\n\t}\n\tassert(K>=0);\n\tfor (int i=0; K>0&&i*p<=m; i++)\n\t{\n\t\tif ((m-i*p)%q==0)\n\t\t{\n\t\t\tK--;\n\t\t\tx += i;\n\t\t\ty += (m-i*p)/q;\n\t\t}\n\t}\n\tif (flag) swap(x, y);\n\treturn MP(x, y);\n}\npair<ll,ll> solve_point(int K, ll p, ll q)\n{\n//\tcerr<<\"solve_point:\"<<K<<\" \"<<p<<\" \"<<q<<endl;\n\tif (p>0&&q>0)\n\t{\n\t\tll l = 0, r = p*K;\n\t\twhile (l<=r)\n\t\t{\n\t\t\tll m = l+r>>1;\n\t\t\tll cnt = count_below_line(p, q, m, K);\n\t\t\tif (cnt<=K) l = m+1;\n\t\t\telse r = m-1;\n\t\t}\n\t\treturn sum_below_line(p, q, r, K);\n\t}\n\telse\n\t{\n\t\tif (p==0) return MP(1ll*K*(K-1)/2, 0);\n\t\telse return MP(0, 1ll*K*(K-1)/2);\n\t}\n}\nbool det_gt_zero(ll ax, ll ay, ll bx, ll by)\n{\n\tdouble tmp = 1.0*ax*by-1.0*ay*bx;\n\tif (tmp>1e18) return true;\n\tif (tmp<-1e18) return false;\n\treturn ax*by-ay*bx>=0;\n}\nbool solve(int K, ll al, ll ar)\n{\n\tif (al+1==ar)\n\t{\n\t\tpair<ll,ll> pt1 = solve_point(K, al, MAXP-al);\n\t\tpair<ll,ll> pt2 = solve_point(K, ar, MAXP-ar);\n\t\tassert(A<=pt1.FF&&A>=pt2.FF);\n\t\tassert(B>=pt1.SS&&B<=pt2.SS);\n\t\tassert(pt1.FF!=pt2.FF);\n\t\treturn det_gt_zero(pt1.FF-pt2.FF, pt1.SS-pt2.SS, A-pt2.FF, B-pt2.SS);\n\t}\n\telse\n\t{\n\t\tll am = al+ar>>1;\n\t\tpair<ll,ll> pt = solve_point(K, am, MAXP-am);\n\t\tif (A>=pt.FF&&B>=pt.SS) return true;\n\t\tif (A<pt.FF&&B<pt.SS) return false;\n\t\tif (A<pt.FF) return solve(K, am, ar);\n\t\telse return solve(K, al, am);\n\t}\n}\nint main()\n{\n\tcin>>A>>B;\n\tint l = 1, r = 100000;\n\twhile (l<=r)\n\t{\n\t\tll m = l+r>>1;\n\t\tif (solve(m, 0, MAXP)) l = m+1;\n\t\telse r = m-1;\n\t}\n\tcout<<r-1<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 27.01.2020 01:09:52       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long r, b;\n  cin >> r >> b;\n  auto Count = [&](long long p, long long q, long long bound) {\n    long long sx = 0;\n    long long sy = 0;\n    long long cnt = 0;\n    for (long long x = 0; x * p <= bound; x++) {\n      long long y = (bound - x * p) / q;\n      sx += x * (y + 1);\n      sy += y * (y + 1) / 2;\n      cnt += y + 1;\n    }\n    return make_tuple(sx, sy, cnt);\n  };\n  auto Test = [&](long long p, long long q) {\n    long long low = 0, high = 1;\n    while (true) {\n      auto got = Count(p, q, high);\n      if (get<0>(got) * p + get<1>(got) * q > r * p + b * q) {\n        break;\n      }\n      low = high;\n      high <<= 1;\n    }\n    while (low + 1 < high) {\n      long long mid = (low + high) >> 1;\n      auto got = Count(p, q, mid);\n      if (get<0>(got) * p + get<1>(got) * q > r * p + b * q) {\n        high = mid;\n      } else { \n        low = mid;\n      }\n    }\n    auto got = Count(p, q, low);\n    long long sx = get<0>(got);\n    long long sy = get<1>(got);\n    long long cnt = get<2>(got);\n    long long s = sx * p + sy * q;\n    long long add = (r * p + b * q - s) / high;\n    long long x = 0;\n    while ((high - x * p) % q != 0) {\n      ++x;\n    }\n    sx += x * add + q * (add * (add - 1) / 2);\n    long long y = (high - x * p) / q;\n    while (y >= p) {\n      x += q;\n      y -= p;\n    }\n    sy += y * add + p * (add * (add - 1) / 2);\n    cnt += add;\n    if (sx <= r && sy <= b) {\n      cout << cnt - 1 << '\\n';\n      exit(0);\n    }\n    return (sx > r);\n  };\n  long long p0 = 0, q0 = 1;\n  long long p1 = 1, q1 = 0;\n  while (true) {\n    if (Test(p0 + p1, q0 + q1)) {\n      p0 = p0 + p1;\n      q0 = q0 + q1;\n    } else {\n      p1 = p0 + p1;\n      q1 = q0 + q1;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int PP = 1e9 + 33;\ntypedef __int128_t T;\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int r, b;\n  cin>>r>>b;\n  int Kl = 1, Kr = 1e9, Kfaj = 1;\n  while (Kl <= Kr) {\n    int Kakt = (Kl + Kr) / 2;\n    int Pl = 1, Pr = PP - 1;\n    int Kok = 0, Kfail = 0;\n    int smX = -1, smY = -1, bigX = -1, bigY = -1;\n    while (Pl <= Pr) {\n      T Pakt = (Pl + Pr) / 2;\n      T Qakt = PP - Pakt; //pX + qY minimalne\n      T Zl = 0, Zr = 1e18;\n      int Xfaj, Yfaj;\n      while (Zl <= Zr) {\n        T Zakt = (Zl + Zr) / 2;\n        int cnt_taken = 0;\n        T Xhere = 0, Yhere = 0;\n        int sw = 0;\n        if (Pakt < Qakt) {\n          sw = 1;\n          swap(Pakt, Qakt);\n        }\n        REP (x, 2000) {\n          T rem = Zakt - x * Pakt;\n          if (rem < 0) { break; }\n          T maxY = rem / Qakt;\n          cnt_taken += maxY + 1;\n          Xhere += x * (maxY + 1);\n          Yhere += maxY * (maxY + 1) / 2;\n        }\n        if (sw) {\n          swap(Xhere, Yhere);\n          swap(Pakt, Qakt);\n        }\n        if (cnt_taken == Kakt) {\n          Xfaj = Xhere;\n          Yfaj = Yhere;\n          break;\n        }\n        if (cnt_taken < Kakt) {\n          Zl = Zakt + 1;\n        } else {\n          Zr = Zakt - 1;\n        }\n      }\n      if (r >= Xfaj && b >= Yfaj) {\n        debug((int)Pakt, (int)Qakt, (int)Xfaj, (int)Yfaj);\n        Kok = 1;\n        break;\n      }\n      if (r <= Xfaj && b <= Yfaj) {\n        Kfail = 1;\n        break;\n      }\n      if (r >= Xfaj) { // trzeba bardziej brac x, tzn zmniejszyc p\n        Pr = Pakt - 1;\n        smX = Xfaj;\n        smY = Yfaj;\n      } else {\n        Pl = Pakt + 1;\n        bigX = Xfaj;\n        bigY = Yfaj;\n      }\n    }\n    if (!Kfail && !Kok) {\n      debug(smX, smY, bigX, bigY, Pl, Pr, Kakt);\n      assert(smX != -1 && smY != -1 && bigX != -1 && bigY != -1);\n      //smX < bigX\n      //smY > bigY\n      int atR = bigY + (T(smY - bigY) * (bigX - r) + bigX - smX - 1) / (bigX - smX);\n      Kok = (b >= atR);\n    }\n    if (Kok) {\n      Kl = Kakt + 1;\n      Kfaj = Kakt;\n    } else {\n      Kr = Kakt - 1;\n    }\n  }\n  cout<<Kfaj - 1<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\ntypedef pair<ll,ll> P;\n\nconstexpr int C=1000000007;\n//傾きと作る箱の個数から必要なボールの個数\nP need(int k,int p){\n   int q=C-p; ll lb=0,rb=2020LL*C;\n   while(rb-lb>1){\n      ll mid=(lb+rb)/2,cnt=0;\n      rep(x,0,mid/p+1){\n         cnt+=(mid-x*p)/q+1; if(cnt>=k)break;\n      } if(cnt<k)lb=mid; else rb=mid;\n   }\n   P res({0,0});\n   rep(x,0,rb/p+1){\n      ll y=(rb-x*p)/q;\n      res.first+=x*(y+1); res.second+=y*(y+1)/2;\n   }\n   return res;\n}\n\n//箱の個数とボールの個数から判定\nbool check(int k,int r,int b){\n   int lb=0,rb=C+1; P x,y;\n   while(rb-lb>1){\n      int mid=(lb+rb)/2; P p=need(k,mid);\n      if(p.first<=r&&p.second<=b)return true;\n      if(p.first>r&&p.second>b)return false;\n      if(p.first>r)x=p,lb=mid; else y=p,rb=mid;\n   } return (y.first-x.first)*(b-x.second)<=(y.second-x.second)*(r-x.first);\n}\n\n//reference:https://physics0523.hatenablog.com/entry/2020/02/05/024612\nint main(){\n   int r,b; cin>>r>>b;\n   int lb=0,rb=inf;\n   while(rb-lb>1){\n      int mid=(lb+rb)/2;\n      if(check(mid,r,b))lb=mid; else rb=mid;\n   } cout<<lb-1<<endl;\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// InterestingLSY\n#include <bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define Eb emplace_back\n#define All(x) x.begin(),x.end()\n#define AllRev(x) x.rbegin(),x.rend()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n// Read\nstruct InputReader{\n\t#define bs 1048576\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != '-' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10 + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1LL, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10LL + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != '#'  &&  ch != '.' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == '#'  ||  ch == '.' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != '*'  &&  ch != '?'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == '*'  ||  ch == '?'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = '\\0';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != '#'  &&  c != '.'  &&  c != '='  &&  c != 'B' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,\"r\",stdin)\n#define Fout(a) freopen(a,\"w\",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO( string pname ){\n\t#ifndef intLSY\n\t\tFin((pname+\".in\").c_str());\n\t\tFout((pname+\".out\").c_str());\n\t#else\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO_OICONTEST( string pname ){\n\tFin((pname+\".in\").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+\".out\").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tfprintf(stderr,\"\\n\\nTime usage:\\n%.0lf ms\\n\",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n// Debug\n#define B cerr << \"BreakPoint\" << endl;\n#define O(x) cerr << #x << \" \" << x << endl;\n#define O_(x) cerr << #x << \" \" << x << \"  \";\n#define ERR(x) cerr << \"ERR! #\" << x << endl;\n#define Msz(x) cerr << \"Sizeof \" << #x << \" \" << sizeof(x)/1024/1024 << \" MB\" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = ' ' , char ed = '\\n' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = ' ' , char ed = '\\n' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n// Optimize\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define Sqr(x) ((x)*(x))\n#define Lowbit(a) ((a)&(-(a)))\nvc<int> Range( int l , int r ){\n\tvc<int> ret{};\n\tForx(i,l,r) ret.Pb(i);\n\treturn ret;\n}\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define x F\n#define y S\nil pll operator-( const pll &a , const pll &b ){ return {a.x-b.x,a.y-b.y}; }\nil ll operator*( const pll &a , const pll &b ){ return a.x*b.y - b.x*a.y; }\n#undef x\n#undef y\n\nint r,b;\n\nil bool IsZEnough( ll k , ll p , ll q , ll z ){\n\tif( p < q ) swap(p,q);\n\tll ans = 0;\n\tForx(x,0,z/p){\n\t\tll tans = (z-p*x)/q + 1;\n\t\tans += tans;\n\t\tif( ans >= k ) return true;\n\t}\n\treturn false;\n}\n\nil pll Count( ll p , ll q , ll z ){\n\tbool reversed = 0;\n\tif( p < q ){ swap(p,q); reversed = 1; }\n\tpll ans{0,0};\n\tForx(x,0,z/p){\n\t\tll cnt = (z-p*x)/q + 1;\n\t\tans.F += cnt*x;\n\t\tans.S += cnt*(cnt-1)/2;\n\t}\n\t// cout << ans.F << \" \" << ans.S << endl;\n\tif(reversed) swap(ans.F,ans.S);\n\treturn ans;\n}\n\n// XXXXXXOOOOO\npll CalcPoint( ll k , ll p , ll q ){\n\t// assert( p+q == 1e10 + 19 );\n\tll l = 0, r = (p+q)*(2003+7);\n\t// cout << p << \" \" << q << endl;\n\twhile( l < r ){\n\t\tll mid = l+r >> 1;\n\t\tif(IsZEnough(k,p,q,mid)) r = mid;\n\t\telse l = mid+1;\n\t}\n\treturn Count(p,q,l);\n}\nbool CheckAnswerPossibility( int k ){\n\tconst int total = 998244353;\n\tint l = 1, r = total-1;\n\twhile( l+1 < r ){\n\t\tint p = l+r >> 1;\n\t\tint q = total-p;\n\t\tpll ret = CalcPoint(k,p,q);\n\t\t// cout << ret.F << \" \" << ret.S << endl;\n\t\tif( ret.F <= ::r and ret.S <= b ) return true;\n\t\telif( ret.F > ::r and ret.S > b ) return false;\n\t\telif( ret.F <= ::r ) r = p;\n\t\telse l = p;\n\t}\n\t// cout << l << \" \" << r << endl;\n\tpll tl = CalcPoint(k,l,total-l), tr = CalcPoint(k,r,total-r);\n\t// cout << tl.F << \" \" << tl.S << endl;\n\t// cout << tr.F << \" \" << tr.S << endl;\n\treturn (tr-tl) * (Mp(::r,b)-tr) <= 0;\n}\n\n// OOOOOOXXXXXX\nint BinarySearch_K(){\n\tint l = 2, r = min(r+b,2e6), ans = l;\n\twhile( l <= r ){\n\t\tint mid = l+r >> 1;\n\t\tif(CheckAnswerPossibility(mid)){\n\t\t\tans = mid;\n\t\t\tl = mid+1;\n\t\t}else{\n\t\t\tr = mid-1;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tFILEIO();\n\n\tRead(r,b);\n\n\t// END(CheckAnswerPossibility(10));\n\n\tint ans = BinarySearch_K();\n\tprintf(\"%d\\n\",ans-1);\n\n\tEND();\n}\n"
  },
  {
    "language": "C++",
    "code": "//g++ t.cpp -o t && t < p.txt\n//d>p.txt&&t<p.txt&&t2<p.txt\n\n#include <iostream> // プログラムの耳と口\n#include <vector> // 超有能配列秘書\n#include <algorithm> // みんな大好きソートと二分探索\n#include <queue> // きゅーちゃん、だいすき\n#include <string> // to_string\n#include <functional> // 関数を変数に入れる子\n#include <set> // 値の取得・挿入・削除を高速に\n#include <map> // setの妹 これまた優秀\n#include <random> // 乱択さん\n#include <ctime>\n#include <bitset>\n\n#define DB cerr<<\"D\"<<endl\nusing namespace std; using ll=long long; using ld=long double; const int INF=1e9; const ll LINF=1e18; const double dINF = 1e18; const ld ldINF = 1e18; const double EPS = 1e-6;\ntemplate<typename T, typename U, typename O> void caut(T a, U b, O c){cout<<\"(\"<<a<<\",\"<<b<<\",\"<<c<<\") \";} template<typename T, typename U> void caut(T a, U b){cout<<\"(\"<<a<<\",\"<<b<<\") \";} template<typename T> void caut(T a){cout<<\"(\"<<a<<\") \";};\nusing P=pair<ll,ll>;\nconst ll M = 1e9+7;\nll mod_pow(ll x, ll a) { ll an = 1; while(a > 0) { if (a&1) an = an * x % M; x = x * x % M; a >>= 1;} return an;}\nvoid add(ll& x, ll y) {x+=y; x%=M;}; void mul(ll& x, ll y) {x*=y; x%=M;}; template<typename T, typename U> void chmax(T& x, U y) {if (x<y) x=y;}; template<typename T, typename U> void chmin(T& x, U y) {if (x>y) x=y;}\nbool vaild(int x, int y, int hh, int ww){return 0<=x&&x<hh&&0<=y&&y<ww;}\nint keta(ll a) {int res=0; while(a>0) res+=a%10, a/=10; return res;}\nconst int up[]={1,-1,0,0}, lf[]={0,0,1,-1};\n\nint solve(int r, int b) {\n  int an = 0;\n  for(int i=1;i<1000000;i++) {\n    for(int j=max(i-b,0);j<=i;j++) {\n      if (r >= j && b >= i-j) {\n        an++; r -= j; b -= i-j;\n        //cout << j << \" \" << i-j << \" \" << r << \" \" << b << endl;\n      }\n      if (r < j) break;\n    }\n    if (r + b < i) break;\n  }\n  return an;\n}\n\nint main() {\n  int r,b; cin>>r>>b;\n  cout<<solve(r,b)<<endl;\n}\n// ・配列の大きさok？　・priority_queueはgreater？　・debug消した？\n// ・落ち着いて。提出まで4分待ってね……WJ……1/10……2/10……\n\n// Thank you for making problems and running the contest\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 05.01.2020 11:08:10       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\npair<long long, long long> GetKBest(int k, double dir) {\n  double low = 0, high = k;\n  for (int it = 0; it < 60; it++) {\n    double mid = 0.5 * (low + high);\n    long long cnt = 0;\n    for (int x = 0; x <= mid; x++) {\n      cnt += (long long) ((mid - x) / dir);\n      if (cnt >= k) break;\n    }\n    if (cnt >= k) {\n      high = mid;\n    } else {\n      low = mid;\n    }\n  }\n  long long sx = 0, sy = 0, cnt = 0;\n  for (int x = 0; x <= high; x++) {\n    long long cc = (long long) ((high - x) / dir);\n    sx += cc * x;\n    sy += cc * (cc - 1) / 2;\n    cnt += cc;\n  }\n  if (cnt > k) {\n    for (int x = 0; x <= high; x++) {\n      long long cc = (long long) ((high - x) / dir);\n      if ((high - x) / dir - cc < 1e-10) {\n        sx -= x;\n        sy -= cc - 1;\n        cnt -= 1;\n        if (cnt == k) {\n          break;\n        }\n      }\n    }\n  }\n//  debug(k, dir, sx, sy, cnt);\n//  assert(cnt == k);\n  return make_pair(sx, sy);\n}\n\nbool Solvable(int k, int X, int Y) {\n  long long xa = -1, ya = -1;\n  long long xb = -1, yb = -1;\n  double low = 0, high = 1 + 2.39e-7;\n  for (int it = 0; it < 50; it++) {\n    double mid = 0.5 * (low + high);\n    pair<long long, long long> p = GetKBest(k, mid);\n    if (p.first < X) {\n      xa = p.first;\n      ya = p.second;\n      low = mid;\n    } else {\n      xb = p.first;\n      yb = p.second;\n      high = mid;\n    }\n  }\n  return (xa <= X && ya <= Y) || (xb <= X && yb <= Y) || (ya * (xb - X) + yb * (X - xa) <= Y * (xb - xa));\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int X, Y;\n  cin >> X >> Y;\n  if (X > Y) {\n    swap(X, Y);\n  }\n  int low = 3, high = (int) 1e7;\n  while (low < high) {\n    int mid = (low + high + 1) >> 1;\n    if (Solvable(mid, X, Y)) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  cout << low - 1 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define maxn 30000005\n#define ll long long\n#define ld double\n#define mod 1000000007\nusing namespace std;\t\nint a, b;\nstruct th\n{\n\tint x, y;\n\tdouble z;\n\tbool operator < (const th &l)const\n\t{\n\t\treturn z < l.z;\n\t}\n}p[maxn];\nint cnt = 0;\nint x, y;\nvoid work(double c, int d)\n{\t//I don't have time to change this part into convex hull & pre-treated \n\t//QAQ\n\t//but at least, i know how to solve this problem \n\tcnt = 0, x = 0, y = 0;\n\tfor(int j = 0; j <= 50000; j++)\n\t{\n\t\tif(j * (j + 1) / 2 > a) break;\n\t\tfor(int i = 0; i <= 50000; i++)\n\t\t{\n\t\t\tif(i == 0 && j == 0) continue;\n\t\t\tif(1ll * (j + 1) * i * (i + 1) / 2 > b) break;\n\t\t\tp[cnt].x = j, p[cnt].y = i, p[cnt].z = j + i * c, cnt++;\n\t\t}\n\t}\n//\tcout<<cnt<<endl;\n\tsort(p, p + cnt);\n\tfor(int j = 0; j < d; j++)\n\t\tx += p[j].x, y += p[j].y;\n}\nbool check(int c)\n{\n\tdouble l = 0, r = 1000;\n\twhile(l + 0.001 < r)\n\t{\n\t\tdouble mid = (l + r) / 2;\n\t\twork(mid, c);\n\t\tif(x < a) l = mid;\n\t\telse r = mid;\n\t\tif(x < a && y < b) return 1;\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>a>>b;\n\tint l = 1, r = 1000000;\n\twhile(l < r)\n\t{\n\t\tint mid = (l + r) >> 1;\n\t\tif(check(mid + 1)) l = mid + 1;\n\t\telse r = mid;\n\t}\n\tcout<<l<<endl; \n\treturn 0;\n} \n/*\n1000000000\n1000000000\n \n*/"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 27.01.2020 01:09:52       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long r, b;\n  cin >> r >> b;\n  auto Count = [&](long long p, long long q, long long bound) {\n    long long sx = 0;\n    long long sy = 0;\n    long long cnt = 0;\n    for (long long x = 0; x * p <= bound; x++) {\n      long long y = (bound - x * p) / q;\n      sx += x * (y + 1);\n      sy += y * (y + 1) / 2;\n      cnt += y + 1;\n    }\n    return make_tuple(sx, sy, cnt);\n  };\n  auto Test = [&](long long p, long long q) {\n    bool inv = false;\n    if (p < q) {\n      swap(p, q);\n      swap(r, b);\n      inv = true;\n    }\n    long long low = 0, high = 1;\n    while (true) {\n      auto got = Count(p, q, high);\n      if (get<0>(got) * p + get<1>(got) * q > r * p + b * q) {\n        break;\n      }\n      low = high;\n      high <<= 1;\n    }\n    while (low + 1 < high) {\n      long long mid = (low + high) >> 1;\n      auto got = Count(p, q, mid);\n      if (get<0>(got) * p + get<1>(got) * q > r * p + b * q) {\n        high = mid;\n      } else { \n        low = mid;\n      }\n    }\n    auto got = Count(p, q, low);\n    long long sx = get<0>(got);\n    long long sy = get<1>(got);\n    long long cnt = get<2>(got);\n    long long s = sx * p + sy * q;\n    long long add = (r * p + b * q - s) / high;\n    long long x = 0;\n    while ((high - x * p) % q != 0) {\n      ++x;\n    }\n    sx += x * add + q * (add * (add - 1) / 2);\n    long long y = (high - x * p) / q;\n    while (y >= p) {\n      x += q;\n      y -= p;\n    }\n    sy += y * add + p * (add * (add - 1) / 2);\n    cnt += add;\n    if (sx <= r && sy <= b) {\n      cout << cnt - 1 << '\\n';\n      exit(0);\n    }\n    bool ret = (sx > r) ^ inv;\n    if (inv) {\n      swap(r, b);\n    }\n    return ret;\n  };\n  long long p0 = 0, q0 = 1;\n  long long p1 = 1, q1 = 0;\n  while (true) {\n    if (Test(p0 + p1, q0 + q1)) {\n      p0 = p0 + p1;\n      q0 = q0 + q1;\n    } else {\n      p1 = p0 + p1;\n      q1 = q0 + q1;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define maxn 10000005\n#define ll long long\n#define ld double\n#define mod 1000000007\nusing namespace std;\t\nint a, b;\nstruct th\n{\n\tint x, y;\n\tdouble z;\n\tbool operator < (const th &l)const\n\t{\n\t\treturn z < l.z;\n\t}\n}p[maxn];\nint cnt = 0;\nint x, y;\nvoid work(double c, int d)\n{\n\tcnt = 0, x = 0, y = 0;\n\tfor(int j = 0; j <= 50000; j++)\n\t{\n\t\tif(j * (j + 1) / 2 > a) break;\n\t\tfor(int i = 0; i <= 50000; i++)\n\t\t{\n\t\t\tif(i == 0 && j == 0) continue;\n\t\t\tif((j + 1) * i * (i + 1) / 2 > b) break;\n\t\t\tp[cnt].x = j, p[cnt].y = i, p[cnt].z = j + i * c, cnt++;\n\t\t}\n\t}\n\tsort(p, p + cnt);\n\tfor(int j = 0; j < d; j++)\n\t\tx += p[j].x, y += p[j].y;\n}\nbool check(int c)\n{\n\tdouble l = 0, r = 10000;\n\twhile(l + 0.000001 < r)\n\t{\n\t\tdouble mid = (l + r) / 2;\n\t\twork(mid, c);\n\t\tif(x < a) l = mid;\n\t\telse r = mid;\n\t\tif(x < a && y < b) return 1;\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>a>>b;\n\tint l = 1, r = 1000000;\n\twhile(l < r)\n\t{\n\t\tint mid = (l + r) >> 1;\n\t\tif(check(mid + 1)) l = mid + 1;\n\t\telse r = mid;\n\t}\n\tcout<<l<<endl; \n\treturn 0;\n} \n/*\nbbbbbb\nbababa\n\n*/"
  },
  {
    "language": "C++",
    "code": "/*\n\n本コード及び直前の提出は解説を読み作成したものです\n\n*/\n\n//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nusing i8 = ::std::int_least8_t;\nusing i32 = ::std::int_least32_t;\nusing i64 = ::std::int_least64_t;\nusing u8 = ::std::uint_least8_t;\nusing u32 = ::std::uint_least32_t;\nusing u64 = ::std::uint_least64_t;\nusing isize = ::std::ptrdiff_t;\nusing usize = ::std::size_t;\n\ntemplate <class T = usize> class rep {\n\tconst T f, l;\n\npublic:\n\tclass itr {\n\t\tfriend rep;\n\t\tT i;\n\t\tconstexpr itr(T x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\tconstexpr T operator*() const noexcept { return i; }\n\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\tconstexpr rep(const T first, const T last) noexcept : f(first), l(last) {}\n\tconstexpr itr begin() const noexcept { return itr(f); }\n\tconstexpr itr end() const noexcept { return itr(l); }\n};\ntemplate <class T = usize> class revrep {\n\tconst T f, l;\n\npublic:\n\tclass itr {\n\t\tfriend revrep;\n\t\tT i;\n\t\tconstexpr itr(T x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\tconstexpr T operator*() const noexcept { return i; }\n\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\tconstexpr revrep(const T first, const T last) noexcept : f(first), l(last) {}\n\tconstexpr itr begin() const noexcept { return itr(l - 1); }\n\tconstexpr itr end() const noexcept { return itr(f - 1); }\n};\ntemplate <class T> bool amax(T &a, const T &b) {\n\treturn a <= b ? (a = b, 1) : 0;\n}\ntemplate <class T> bool amin(T &a, const T &b) {\n\treturn b <= a ? (a = b, 1) : 0;\n}\ntemplate <class T> bool asmax(T &a, const T &b) {\n\treturn b <= a ? 0 : (a = b, 1);\n}\ntemplate <class T> bool asmin(T &a, const T &b) {\n\treturn a <= b ? 0 : (a = b, 1);\n}\ntemplate <class T> using vec_alias = ::std::vector<T>;\ntemplate <class T> auto md_vec(usize n, const T &value) {\n\treturn ::std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(usize n, Args... args) {\n\treturn ::std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> const T &as_const(const T &v) noexcept { return v; }\ntemplate <class T> constexpr T difference(const T &a, const T &b) {\n\treturn a <= b ? b - a : a - b;\n}\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include<numeric>\n#include<cassert>\n#include<tuple>\n\n\nstatic constexpr u64 P = 10000000019ULL;\n\nu64 count_points(const u64 p, const u64 z) {\n\tconst u64 q = P - p;\n\tu64 ret = 0;\n\tif (p < q) {\n\t\tfor (u64 y = 0;z >= q*y;++y) {\n\t\t\tret += (z - q*y) / p + 1;\n\t\t}\n\t}\n\telse {\n\t\tfor (u64 x = 0;z >= p*x;++x) {\n\t\t\tret += (z - p*x) / q + 1;\n\t\t}\n\t}\n\treturn ret;\n}\n\n::std::pair<u64, u64> calc_sum(const u64 p, const u64 z, u64 cnt) {\n\tconst u64 q = P - p;\n\tu64 X = 0, Y = 0;\n\tif (p < q) {\n\t\tfor (u64 y = 0;z >= q*y;++y) {\n\t\t\tconst u64 d = (z - q*y) / p;\n\t\t\tY += y*(d + 1);\n\t\t\tX += d*(d + 1) / 2;\n\t\t\tif (cnt != 0 && (z + 1 - q*y) % p == 0) {\n\t\t\t\tY += y;\n\t\t\t\tX += d + 1;\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (u64 x = 0;z >= p*x;++x) {\n\t\t\tconst u64 d = (z - p*x) / q;\n\t\t\tX += x*(d + 1);\n\t\t\tY += d*(d + 1) / 2;\n\t\t\tif (cnt != 0 && (z + 1 - p*x) % q == 0) {\n\t\t\t\tX += x;\n\t\t\t\tY += d + 1;\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn ::std::make_pair(X, Y);\n}\n\nu64 calc_z(const u64 p, const u64 k) {\n\tu64 z_le = 0, z_gt = P * 2000;\n\twhile (z_gt - z_le != 1) {\n\t\tu64 z = (z_le + z_gt) / 2;\n\t\tif (count_points(p, z) <= k) {\n\t\t\tz_le = z;\n\t\t}\n\t\telse {\n\t\t\tz_gt = z;\n\t\t}\n\t}\n\treturn z_le;\n}\n\nbool check_k(const u64 R, const u64 B, const u64 k) {\n\tu64 p_lower = 0, p_upper = P;\n\twhile (p_upper - p_lower != 1) {\n\t\tu64 p = (p_lower + p_upper) / 2;\n\t\tu64 z = calc_z(p, k);\n\t\tu64 cnt = k - count_points(p, z);\n\t\tu64 X, Y;\n\t\t::std::tie(X, Y) = calc_sum(p, z, cnt);\n\t\tif (X <= R) {\n\t\t\tif (Y <= B) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp_upper = p;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (Y <= B) {\n\t\t\t\tp_lower = p;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tu64 z1 = calc_z(p_upper, k);\n\tu64 z2 = calc_z(p_lower, k);\n\tu64 X1, X2, Y1, Y2;\n\t::std::tie(X1, Y1) = calc_sum(p_upper, z1,\n\t\tk - count_points(p_upper, z1));\n\t::std::tie(X2, Y2) = calc_sum(p_lower, z2,\n\t\tk - count_points(p_lower, z2));\n\tif ((X2 - X1)*(Y1 - B) <= (Y1 - Y2)*(R - X1)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nint main() {\n\tu64 R, B;\n\t::std::cin >> R >> B;\n\n\tu64 k_ok = 0, k_ng = 2000000;\n\twhile (k_ng - k_ok != 1) {\n\t\tu64 k = (k_ok + k_ng) / 2;\n\t\tif (check_k(R, B, k)) {\n\t\t\tk_ok = k;\n\t\t}\n\t\telse {\n\t\t\tk_ng = k;\n\t\t}\n\t}\n\n\t::std::cout << k_ok - 1 << ::std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T, typename S>\nostream& operator<<(ostream& os, pair<S, T> t){\n    os << \"(\" << t.first << \", \" << t.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> t){\n    long c = 0;\n    for(auto i : t)os << (c++ ? \", \" : \"{\") << i;\n    os << \"}\";\n    return os;\n}\n\nint main(){\n    long R, B;\n    cin >> R >> B;\n    if(R > B)swap(R, B);\n\n    auto hoge = [](long RR, long BB, long X, long R, long B){\n        long b = 0, r = 0;\n        long t = X + RR, x = 0;\n        while(t >= 0){\n            b += (t / RR) * (t / RR - 1) / 2;\n            r += x * (t / RR);\n            if(b > B || r > R)return 0;\n            t -= BB;\n            ++x;\n        }\n        return 1;\n    };\n\n    auto nibutan = [&hoge](long RR, long BB, long R, long B){\n        if(RR < BB){\n            swap(RR, BB);\n            swap(R, B);\n        }\n        {\n            auto k = __gcd(RR, BB);\n            RR /= k;\n            BB /= k;\n        }\n\n        long r = 0, l = 1;\n\n        while(hoge(RR, BB, l, R, B))l <<= 1;\n\n        while(r + 1 < l){\n            long mid = (l + r) / 2;\n            (hoge(RR, BB, mid, R, B) ? r : l) = mid;\n        }\n\n        vector<pair<long, long>> rem;\n        long remr = R, remb = B, c = 0;\n        {\n            long t = r + RR, s = t + 1, x = 0;\n            while(s >= 0){\n                if((t - (t % RR + RR) % RR) / RR < (s - (s % RR + RR) % RR) / RR && rem.size() <= 1){\n                    rem.emplace_back(t / RR, x);\n                    if(rem.size() > 1){\n                        rem[1].first -= rem[0].first;\n                        rem[1].second -= rem[0].second;\n                    }\n                }\n                remr -= x * (t / RR);\n                remb -= (t / RR) * (t / RR - 1) / 2;\n                c += (t / RR);\n                t -= BB;\n                s -= BB;\n                ++x;\n            }\n        }\n        assert(remr >= 0 && remb >= 0);\n\n        if(rem.size() <= 1)return c;\n\n        long j = 0, k = (rem[0].first + 1) / -rem[1].first, m = k - 1;\n\n        auto tapi = [&remr, remb, rem, m](long a){\n            long lb = (a * rem[0].first - remr) / -rem[1].first, ub = (remb - a * rem[0].second) / rem[1].second;\n            return ub >= lb && ub >= a * (a - 1) / 2 && lb <= a * (2 * m + 1 - a) / 2;\n        };\n\n        cerr << r << \" : \" << c << \" : \" << rem << \" : \" << remr << \", \" << remb << \" : \" << k << endl;\n\n        assert(tapi(j) && !tapi(k));\n\n        while(j + 1 < k){\n            long mid = (j + k) / 2;\n            (tapi(mid) ? j : k) = mid;\n        }\n\n        return c + j;\n    };\n\n    auto cfexpand = [](long A, long B){\n        vector<pair<long, long>> ret;\n        long a(1), b(0), c(0), d(1), x(A), y(B);\n        auto comp = [](long& a, long& b, long x){\n            swap(a, b);\n            a += b * x;\n        };\n        while(y){\n            auto t = x / y;\n            comp(a, b, t);\n            comp(c, d, t);\n            ret.emplace_back(a, c);\n            swap(x, y);\n            y %= x;\n        }\n        return ret;\n    };\n\n    auto t = cfexpand(B, R);\n    cerr << t << endl;\n    long ans = numeric_limits<long>::min();\n    for(auto i : t)ans = max(ans, nibutan(i.second, i.first, R, B));\n    cout << ans - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\ntypedef pair<ll,ll> P;\n\nconstexpr int C=1000000007;\n//傾きと作る箱の個数から必要なボールの個数\nP need(int k,int p){\n   int q=C-p; ll lb=0,rb=2020LL*C;\n   while(rb-lb>1){\n      ll mid=(lb+rb)/2,cnt=0;\n      rep(x,0,mid/p+1){\n         cnt+=(mid-x*p)/q+1; if(cnt>=k)break;\n      } if(cnt<k)lb=mid; else rb=mid;\n   }\n   P res({0,0});\n   rep(x,0,rb/p+1){\n      ll y=(rb-x*p)/q;\n      res.first+=x*(y+1); res.second+=y*(y+1)/2;\n   }\n   return res;\n}\n\n//箱の個数とボールの個数から判定\nbool check(int k,int r,int b){\n   int lb=0,rb=C+1; P x,y;\n   while(rb-lb>1){\n      int mid=(lb+rb)/2; P p=need(k,mid);\n      if(p.first<=r&&p.second<=b)return true;\n      if(p.first>r&&p.second>b)return false;\n      if(p.first>r)x=p,lb=mid; else y=p,rb=mid;\n   } return (y.first-x.first)*(b-x.second)<=(y.second-x.second)*(r-x.first);\n}\n\n//reference:https://physics0523.hatenablog.com/entry/2020/02/05/024612\nint main(){\n   int r,b; cin>>r>>b;\n   int lb=0,rb=1341398*2;\n   while(rb-lb>1){\n      int mid=(lb+rb)/2;\n      if(check(mid,r,b))lb=mid; else rb=mid;\n   } cout<<lb-1<<endl;\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int r,b,i;\n    int a1=0,a2=0,sum=0;\n    cin>>r>>b;\n    if(r<=b){\n        for(i=0;;i++){\n            if(a1<r){\n                a1++;\n                a2+=i;\n                sum++;\n            }\n            if(a2<b&&b-a2>=i+1){\n                a2+=i+1;\n                sum++;\n            }\n            else\n            break;\n        }\n    }\n    else{\n        for(i=0;;i++){\n            if(a2<b){\n                a2++;\n                a1+=i;\n                sum++;\n            }\n            if(a1<r&&r-a1>=i+1){\n                a1+=i+1;\n                sum++;\n            }\n            else\n            break;\n        }\n    }\n    cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (int) n; i++)\nusing ll = long long;\ntemplate <class T>\nusing vt = std::vector<T>;\nusing vvi = std::vector<vt<int>>;\n\nint main(){\n  int r,b;\n  std::cin >> r >> b;\n  int cnt = 0;\n  int maxi = std::max(r,b);\n  int mini = std::min(r,b);\n  if(mini > 0){\n    cnt++;\n    mini--;\n  }\n  int num = 1;\n  while(maxi+mini >= num){\n    if(maxi >= num) {\n      cnt++;\n      maxi-=num;\n    }\n    if(maxi > num-1 && mini > 0){\n      cnt++;\n      maxi-=num;\n      mini--;\n    }\n    num++;\n  }\n\n  std::cout << cnt << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int r,b,i,j;\n    int a1=0,a2=0,sum=0;\n    cin>>r>>b;\n    if(r<=b){\n        for(i=0,j=1;a1<r||a2<b;i++){\n\n            if(a1<r&&r-a1>=j+1){\n                a1+=j;\n                a2+=i;\n                sum++;\n            }\n            else if(r-a1<j+1){\n                a1=r;\n            }\n            if(a2<b&&b-a2>=i+1&&j==1){\n                a2+=i+1;\n                sum++;\n            }\n            else if(b-a2<i+1){\n                if(a1==r)\n                a2=b;\n                j++;\n                i=-1;\n            }\n        }\n    }\n    else{\n        for(i=0,j=1;a1<r||a2<b;i++){\n            if(a2<b&&b-a2>=j+1){\n                a2+=j;\n                a1+=i;\n                sum++;\n            }\n            else if(b-a2<j+1){\n                a2=b;\n            }\n            if(a1<r&&r-a1>=i+1&&j==1){\n                a1+=i+1;\n                sum++;\n            }\n            else if(r-a1<i+1){\n                if(a2==b)\n                a1=r;\n                j++;\n                i=-1;\n            }\n        }\n    }\n    cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n\nconst long P = 10000000019;\n\nint main() {\n  long R, B;\n  cin.sync_with_stdio(0);\n  cin >> R >> B;\n  long Kl = 1, Kh = 3*(sqrt(2*(R+B))+1);\n  while (Kl < Kh) {\n    long K = Kl+Kh+1 >> 1, pl = 1, ph = P, lx = 0, ly, rx = 0, ry;\n    while (pl < ph) {\n      long p = pl+ph >> 1, zl = 0, zh = p*K;\n      while (zl < zh) {\n        long z = zl+zh >> 1, c = 0;\n        // c : px+qy <= z\n        for (long px = 0; px <= z && (c += (z-px)/(P-p)+1) <= K; px += p);\n        if (c <= K) zl = z+1;\n        else zh = z;\n      }\n      long sx = 0, sy = 0;\n      for (long x = 0; p*x <= zl; x++) {\n        long y = (zl-p*x)/(P-p);\n        sx += x*(y+1);\n        sy += y*(y+1)/2;\n      }\n      if (R < sx) {\n        if (!rx || sx < rx)\n          rx = sx, ry = sy;\n        if (B < sy) {\n          Kh = K-1;\n          goto out;\n        }\n        pl = p+1;\n      } else {\n        if (!lx || lx < sx)\n          lx = sx, ly = sy;\n        if (B >= sy) {\n          Kl = K;\n          goto out;\n        }\n        ph = p;\n      }\n    }\n    // (R,B) is on or above the hull (lx,ly)-(rx,ry)\n    if ((R-lx)*(ry-ly) <= (B-ly)*(rx-lx))\n      Kl = K;\n    else\n      Kh = K-1;\n    out:;\n  }\n  cout << Kl << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <math.h>\n\nusing namespace std;\n#define LL long long\nusing VS = vector<string>;\nusing VI = vector<int>;\nusing VL = vector<LL>;\nusing VVI = vector<VI>;\nusing VVL = vector<VL>;\n#define FOR(i,s,e) for(i = s; i < e; i++)\n#define FORR(i,s,e) for(i = e-1; i >= s; i--)\nconst LL INF = (LL)1e16;\nconst LL MOD = (LL)1e9 + 7;\n\n\n// A\n\n// B\n\n// C\nLL f(LL n){\n  return n*(n+1)/2;\n}\n\nint main(){\n  LL r,b,ans = 0,i = 0,a,c,e,d,k = 0;\n  cin >> r >> b;\n  FOR(i,1,1500000){\n    r -= f(i);\n    b -= f(i);\n    if (r < 0 || b < 0){\n      r += f(i);\n      b += f(i);\n      break;\n    }\n    ans += i+1;\n  }\n  a = max(r,b);\n  c = min(r,b);\n  while (a+c >= i){\n    FOR(k,0,i+1){\n      if (a >= i-k && c >= k){\n        a -= i-k;\n        c -= k;\n        ans ++;\n      }\n    }\n    i ++;\n    d = max(a,c);\n    e = min(a,c);\n    a = d;\n    c = e;\n  }\n  cout << ans;\n  return 0;\n}\n// D\n\n// E\n\n// F\n\n// G\n\n// H\n\n// I\n\n// J\n\n// K\n\n// L\n\n// M\n\n// N\n\n// O\n\n// P\n\n// Q\n\n// R\n\n// S\n\n// T\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking\n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define inf (1<<30)\n#define INF (1ll<<58)\nusing namespace std;\npll count(int cnt,ll A,ll B){\n\tll vl=0,vr=(A+B)*2000ll;\n\tll Sx=0,Sy=0;\n\twhile (vl<=vr){\n\t\tll vm=(vl+vr)/2;\n\t\tll sx=0,sy=0,s=0; \n\t\tFor(i,0,2000){\n\t\t\tll cnt=(vm-i*A);\n\t\t\tif (cnt<0) break;\n\t\t\tcnt/=B;\n\t\t\ts+=cnt;\n\t\t\tsx+=cnt*i;\n\t\t\tsy+=cnt*(cnt-1)/2;\n\t\t}\n\t\tif (s<=cnt)\n\t\t\tSx=sx,Sy=sy,vl=vm+1;\n\t\telse vr=vm-1;\n\t}\n\t//printf(\"%d %lld %lld %d %d\\n\",cnt,A,B,Sx,Sy);\n\treturn pll(Sx,Sy);\n}\nbool check(int cnt,int A,int B){\n\tconst ll S=100000000019ll;\n\tll l=1,r=S-1;\n\twhile (l<=r){\n\t\tll mid=(l+r)/2;\n\t\tpll ans=count(cnt,mid,S-mid);\n\t\tif (ans.fi<=A&&ans.se<=B) return 1;\n\t\tif (ans.fi<=A) r=mid-1;\n\t\telse l=mid+1;\n\t} \n\treturn 0;\n}\nint main(){\n\tint A,B;\n\tscanf(\"%d%d\",&A,&B);\n\tint l=1,r=2000000,ans=0;\n\twhile (l<=r){\n\t\tint mid=(l+r)/2;\n\t\tif (check(mid,A,B)) ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tprintf(\"%d\\n\",ans-1);\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll MAXP = 10000000019ll;\nint A, B;\nll count_below_line(ll p, ll q, ll m, ll bound)\n{\n\tif (p<q) swap(p, q);\n\tll ans = 0;\n\tfor (int i=0; i<=m/p&&ans<=bound; i++)\n\t{\n\t\tans += (m-i*p)/q+1;\n\t}\n\treturn ans;\n}\npair<ll,ll> sum_below_line(ll p, ll q, ll m, ll K)\n{\n//\tcerr<<\"sum_below_line:\"<<p<<\",\"<<q<<\" \"<<m<<\" \"<<K<<\"  \"<<count_below_line(p, q, m, K)<<endl;\n\tbool flag = 0;\n\tif (p<q) swap(p, q), flag = 1;\n\tll x = 0, y = 0;\n\tfor (int i=0; i*p<=m-1; i++)\n\t{\n\t\tll cnt = (m-1-i*p)/q+1;\n\t\tK -= cnt;\n\t\tx += cnt*i;\n\t\ty += 1ll*cnt*(cnt-1)/2;\n\t}\n\tassert(K>=0);\n\tfor (int i=0; K>0&&i*p<=m; i++)\n\t{\n\t\tif ((m-i*p)%q==0)\n\t\t{\n\t\t\tK--;\n\t\t\tx += i;\n\t\t\ty += (m-i*p)/q;\n\t\t}\n\t}\n\tif (flag) swap(x, y);\n\treturn MP(x, y);\n}\npair<ll,ll> solve_point(int K, ll p, ll q)\n{\n//\tcerr<<\"solve_point:\"<<K<<\" \"<<p<<\" \"<<q<<endl;\n\tif (p>0&&q>0)\n\t{\n\t\tll l = 0, r = p*K;\n\t\twhile (l<=r)\n\t\t{\n\t\t\tll m = l+r>>1;\n\t\t\tll cnt = count_below_line(p, q, m, K);\n\t\t\tif (cnt<=K) l = m+1;\n\t\t\telse r = m-1;\n\t\t}\n\t\treturn sum_below_line(p, q, r, K);\n\t}\n\telse\n\t{\n\t\tif (p==0) return MP(1ll*K*(K-1)/2, 0);\n\t\telse return MP(0, 1ll*K*(K-1)/2);\n\t}\n}\nbool det_gt_zero(ll ax, ll ay, ll bx, ll by)\n{\n\tdouble tmp = 1.0*ax*by-1.0*ay*bx;\n\tif (tmp>1e18) return true;\n\tif (tmp<-1e18) return false;\n\treturn ax*by-ay*bx>=0;\n}\nbool solve(int K, ll al, ll ar)\n{\n\tif (al+1==ar)\n\t{\n\t\tpair<ll,ll> pt1 = solve_point(K, al, MAXP-al);\n\t\tpair<ll,ll> pt2 = solve_point(K, ar, MAXP-ar);\n//\t\tcerr<<pt1.FF<<\",\"<<pt1.SS<<\" \"<<pt2.FF<<\",\"<<pt2.SS<<\" (\"<<K<<\" \"<<al<<\",\"<<ar<<\")\"<<endl;\n\t\tassert(A<=pt1.FF&&A>=pt2.FF);\n\t\tassert(B>=pt1.SS&&B<=pt2.SS);\n\t\tassert(pt1.FF!=pt2.FF);\n\t\treturn det_gt_zero(pt1.FF-pt2.FF, pt1.SS-pt2.SS, A-pt2.FF, B-pt2.SS);\n\t}\n\telse\n\t{\n\t\tll am = al+ar>>1;\n\t\tpair<ll,ll> pt = solve_point(K, am, MAXP-am);\n\t\tif (A>=pt.FF&&B>=pt.SS) return true;\n\t\tif (A<pt.FF&&B<pt.SS) return false;\n\t\tif (A<pt.FF) return solve(K, am, ar);\n\t\telse return solve(K, al, am);\n\t}\n}\nint main()\n{\n\tcin>>A>>B;\n\tint l = 1, r = 10000000;\n\twhile (l<=r)\n\t{\n\t\tll m = l+r>>1;\n\t\tif (solve(m, 0, MAXP)) l = m+1;\n\t\telse r = m-1;\n\t}\n\tcout<<r-1<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long P = (long long) 1e10 + 19;\n\nlong long count_lattice_points(long long p, long long z) {\n  long long q = P - p;\n  long long ans = 0;\n  if (p < q) {\n    for (int y = 0; y * q <= z; ++y) {\n      ans += (z - y * q) / p + 1;\n    }\n  } else {\n    for (int x = 0; x * p <= z; ++x) {\n      ans += (z - x * p) / q + 1;\n    }\n  }\n  return ans;\n}\n\npair<long long, long long> sum_lattice_points(long long p, long long z, int remain) {\n  long long q = P - p;\n  long long sum_x = 0;\n  long long sum_y = 0;\n  if (p < q) {\n    for (int y = 0; y * q <= z; ++y) {\n      long long max_x = (z - y * q) / p;\n      sum_x += max_x * (max_x + 1) / 2;\n      sum_y += y * (max_x + 1);\n      if (remain && (z + 1 - y * q) % p == 0) {\n        --remain;\n        sum_x += (z + 1 - y * q) / p;\n        sum_y += y;\n      }\n    }\n  } else {\n    for (int x = 0; x * p <= z; ++x) {\n      long long max_y = (z - x * p) / q;\n      sum_x += x * (max_y + 1);\n      sum_y += max_y * (max_y + 1) / 2;\n      if (remain && (z + 1 - x * p) % q == 0) {\n        --remain;\n        sum_x += x;\n        sum_y += (z + 1 - x * p) / q;\n      }\n    }\n  }\n  return make_pair(sum_x, sum_y);\n}\n\nlong long binary_search_z(long long p, int k) {\n  long long l = 0, r = P * 2000;\n  while (l < r) {\n    long long z = (l + r + 1) >> 1;\n    if (count_lattice_points(p, z) <= k) {\n      l = z;\n    } else {\n      r = z - 1;\n    }\n  }\n  return l;\n}\n\nbool check(int x, int y, int k) {\n  long long l = 0, r = P;\n  while (r - l > 1) {\n    long long p = (l + r) >> 1;\n    long long z = binary_search_z(p, k);\n    pair<long long, long long> s = sum_lattice_points(p, z, k - count_lattice_points(p, z));\n    if (s.first <= x) {\n      if (s.second <= y) {\n        return true;\n      } else {\n        r = p;\n      }\n    } else {\n      if (s.second <= y) {\n        l = p;\n      } else {\n        return false;\n      }\n    }\n  }\n  long long zl = binary_search_z(l, k);\n  long long zr = binary_search_z(r, k);\n  pair<long long, long long> sl = sum_lattice_points(l, zl, k - count_lattice_points(l, zl));\n  pair<long long, long long> sr = sum_lattice_points(r, zr, k - count_lattice_points(r, zr));\n  return (sr.first - sl.first) * (y - sl.second) <= (sr.second - sl.second) * (x - sl.first);\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int x, y;\n  cin >> x >> y;\n  int l = 1, r = (int) 4e6;\n  while (l < r) {\n    int k = (l + r + 1) >> 1;\n    if (check(x, y, k)) {\n      l = k;\n    } else {\n      r = k - 1;\n    }\n  }\n  cout << l - 1 << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <math.h>\n\nusing namespace std;\n#define LL long long\nusing VS = vector<string>;\nusing VI = vector<int>;\nusing VL = vector<LL>;\nusing VVI = vector<VI>;\nusing VVL = vector<VL>;\n#define FOR(i,s,e) for(i = s; i < e; i++)\n#define FORR(i,s,e) for(i = e-1; i >= s; i--)\nconst LL INF = (LL)1e16;\nconst LL MOD = (LL)1e9 + 7;\n\n\n// A\n\n// B\n\n// C\nLL f(LL n){\n  return n*(n+1)/2;\n}\n\nint main(){\n  LL r,b,ans = 0,i = 0,a,c,e,d,k = 0;\n  cin >> r >> b;\n  FOR(i,1,1500000){\n    r -= f(i);\n    b -= f(i);\n    if (r < 0 || b < 0){\n      r += f(i);\n      b += f(i);\n      break;\n    }\n    ans += i+1;\n  }\n  a = max(r,b);\n  c = min(r,b);\n  while (a+c >= i){\n    FOR(k,0,i+1){\n      if (a >= i-k && c >= k){\n        a -= i-k;\n        c -= k;\n        ans ++;\n      }\n    }\n    i ++;\n    d = max(a,c);\n    e = min(a,c);\n    a = d;\n    c = e;\n  }\n  cout << ans << endl;\n  return 0;\n}\n// D\n\n// E\n\n// F\n\n// G\n\n// H\n\n// I\n\n// J\n\n// K\n\n// L\n\n// M\n\n// N\n\n// O\n\n// P\n\n// Q\n\n// R\n\n// S\n\n// T\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nusing i8 = ::std::int_least8_t;\nusing i32 = ::std::int_least32_t;\nusing i64 = ::std::int_least64_t;\nusing u8 = ::std::uint_least8_t;\nusing u32 = ::std::uint_least32_t;\nusing u64 = ::std::uint_least64_t;\nusing isize = ::std::ptrdiff_t;\nusing usize = ::std::size_t;\n\ntemplate <class T = usize> class rep {\n\tconst T f, l;\n\npublic:\n\tclass itr {\n\t\tfriend rep;\n\t\tT i;\n\t\tconstexpr itr(T x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\tconstexpr T operator*() const noexcept { return i; }\n\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\tconstexpr rep(const T first, const T last) noexcept : f(first), l(last) {}\n\tconstexpr itr begin() const noexcept { return itr(f); }\n\tconstexpr itr end() const noexcept { return itr(l); }\n};\ntemplate <class T = usize> class revrep {\n\tconst T f, l;\n\npublic:\n\tclass itr {\n\t\tfriend revrep;\n\t\tT i;\n\t\tconstexpr itr(T x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\tconstexpr T operator*() const noexcept { return i; }\n\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\tconstexpr revrep(const T first, const T last) noexcept : f(first), l(last) {}\n\tconstexpr itr begin() const noexcept { return itr(l - 1); }\n\tconstexpr itr end() const noexcept { return itr(f - 1); }\n};\ntemplate <class T> bool amax(T &a, const T &b) {\n\treturn a <= b ? (a = b, 1) : 0;\n}\ntemplate <class T> bool amin(T &a, const T &b) {\n\treturn b <= a ? (a = b, 1) : 0;\n}\ntemplate <class T> bool asmax(T &a, const T &b) {\n\treturn b <= a ? 0 : (a = b, 1);\n}\ntemplate <class T> bool asmin(T &a, const T &b) {\n\treturn a <= b ? 0 : (a = b, 1);\n}\ntemplate <class T> using vec_alias = ::std::vector<T>;\ntemplate <class T> auto md_vec(usize n, const T &value) {\n\treturn ::std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(usize n, Args... args) {\n\treturn ::std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> const T &as_const(const T &v) noexcept { return v; }\ntemplate <class T> constexpr T difference(const T &a, const T &b) {\n\treturn a <= b ? b - a : a - b;\n}\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include<numeric>\n#include<cassert>\n#include<tuple>\n\n\nstatic constexpr u64 P = 10000000019ULL;\n\nu64 count_points(const u64 p, const u64 z) {\n\tconst u64 q = P - p;\n\tu64 ret = 0;\n\tif (p < q) {\n\t\tfor (u64 y = 0;z >= q*y;++y) {\n\t\t\tret += (z - q*y) / p + 1;\n\t\t}\n\t}\n\telse {\n\t\tfor (u64 x = 0;z >= p*x;++x) {\n\t\t\tret += (z - p*x) / q + 1;\n\t\t}\n\t}\n\treturn ret;\n}\n\n::std::pair<u64, u64> calc_sum(const u64 p, const u64 z, u64 cnt) {\n\tconst u64 q = P - p;\n\tu64 X = 0, Y = 0;\n\tif (p < q) {\n\t\tfor (u64 y = 0;z >= q*y;++y) {\n\t\t\tconst u64 d = (z - q*y) / p;\n\t\t\tY += y*(d + 1);\n\t\t\tX += d*(d + 1) / 2;\n\t\t\tif (cnt != 0 && (z + 1 - q*y) % p == 0) {\n\t\t\t\tY += y;\n\t\t\t\tX += d + 1;\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (u64 x = 0;z >= p*x;++x) {\n\t\t\tconst u64 d = (z - p*x) / q;\n\t\t\tX += x*(d + 1);\n\t\t\tY += d*(d + 1) / 2;\n\t\t\tif (cnt != 0 && (z + 1 - p*x) % q == 0) {\n\t\t\t\tX += x;\n\t\t\t\tY += d + 1;\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn ::std::make_pair(X, Y);\n}\n\nu64 calc_z(const u64 p, const u64 k) {\n\tu64 z_le = 0, z_gt = P * 2000;\n\twhile (z_gt - z_le != 1) {\n\t\tu64 z = (z_le + z_gt) / 2;\n\t\tif (count_points(p, z) <= k) {\n\t\t\tz_le = z;\n\t\t}\n\t\telse {\n\t\t\tz_gt = z;\n\t\t}\n\t}\n\treturn z_le;\n}\n\nbool check_k(const u64 R, const u64 B, const u64 k) {\n\tu64 p_lower = 0, p_upper = P;\n\twhile (p_upper - p_lower != 1) {\n\t\tu64 p = (p_lower + p_upper) / 2;\n\t\tu64 q = P - p;\n\t\tu64 z = calc_z(p, k);\n\t\tu64 cnt = k - count_points(p, z);\n\t\tu64 X, Y;\n\t\t::std::tie(X, Y) = calc_sum(p, z, cnt);\n\t\tif (X <= R) {\n\t\t\tif (Y <= B) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp_upper = p;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (Y <= B) {\n\t\t\t\tp_lower = p;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tu64 z1 = calc_z(p_upper, k);\n\tu64 z2 = calc_z(p_lower, k);\n\tu64 X1, X2, Y1, Y2;\n\t::std::tie(X1, Y1) = calc_sum(p_upper, z1,\n\t\tk - count_points(p_upper, z1));\n\t::std::tie(X2, Y2) = calc_sum(p_lower, z2,\n\t\tk - count_points(p_lower, z2));\n\tif ((X2 - X1)*(B - Y1) >= (Y2 - Y1)*(R - X1)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nint main() {\n\tu64 R, B;\n\t::std::cin >> R >> B;\n\n\tu64 k_ok = 0, k_ng = 2000000;\n\twhile (k_ng - k_ok != 1) {\n\t\tu64 k = (k_ok + k_ng) / 2;\n\t\tif (check_k(R, B, k)) {\n\t\t\tk_ok = k;\n\t\t}\n\t\telse {\n\t\t\tk_ng = k;\n\t\t}\n\t}\n\n\t::std::cout << k_ok - 1 << ::std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll MAXP = 10000000019ll;\nint A, B;\nll count_below_line(ll p, ll q, ll m, ll bound)\n{\n\tif (p<q) swap(p, q);\n\tll ans = 0;\n\tfor (int i=0; i<=m/p&&ans<=bound; i++)\n\t{\n\t\tans += (m-i*p)/q+1;\n\t}\n\treturn ans;\n}\npair<ll,ll> sum_below_line(ll p, ll q, ll m, ll K)\n{\n//\tcerr<<\"sum_below_line:\"<<p<<\",\"<<q<<\" \"<<m<<\" \"<<K<<\"  \"<<count_below_line(p, q, m, K)<<endl;\n\tbool flag = 0;\n\tif (p<q) swap(p, q), flag = 1;\n\tll x = 0, y = 0;\n\tfor (int i=0; i*p<=m-1; i++)\n\t{\n\t\tll cnt = (m-1-i*p)/q+1;\n\t\tK -= cnt;\n\t\tx += cnt*i;\n\t\ty += 1ll*cnt*(cnt-1)/2;\n\t}\n\tassert(K>=0);\n\tfor (int i=0; K>0&&i*p<=m; i++)\n\t{\n\t\tif ((m-i*p)%q==0)\n\t\t{\n\t\t\tK--;\n\t\t\tx += i;\n\t\t\ty += (m-i*p)/q;\n\t\t}\n\t}\n\tif (flag) swap(x, y);\n\treturn MP(x, y);\n}\npair<ll,ll> solve_point(int K, ll p, ll q)\n{\n//\tcerr<<\"solve_point:\"<<K<<\" \"<<p<<\" \"<<q<<endl;\n\tif (p>0&&q>0)\n\t{\n\t\tll l = 0, r = p*K;\n\t\twhile (l<=r)\n\t\t{\n\t\t\tll m = l+r>>1;\n\t\t\tll cnt = count_below_line(p, q, m, K);\n\t\t\tif (cnt<=K) l = m+1;\n\t\t\telse r = m-1;\n\t\t}\n\t\treturn sum_below_line(p, q, r, K);\n\t}\n\telse\n\t{\n\t\tif (p==0) return MP(1ll*K*(K-1)/2, 0);\n\t\telse return MP(0, 1ll*K*(K-1)/2);\n\t}\n}\nbool det_gt_zero(ll ax, ll ay, ll bx, ll by)\n{\n\tdouble tmp = 1.0*ax*by-1.0*ay*bx;\n\tif (tmp>1e18) return true;\n\tif (tmp<-1e18) return false;\n\treturn ax*by-ay*bx>=0;\n}\nbool solve(int K, ll al, ll ar)\n{\n\tif (al+1==ar)\n\t{\n\t\tpair<ll,ll> pt1 = solve_point(K, al, MAXP-al);\n\t\tpair<ll,ll> pt2 = solve_point(K, ar, MAXP-ar);\n//\t\tcerr<<pt1.FF<<\",\"<<pt1.SS<<\" \"<<pt2.FF<<\",\"<<pt2.SS<<\" (\"<<K<<\" \"<<al<<\",\"<<ar<<\")\"<<endl;\n\t\tassert(A<=pt1.FF&&A>=pt2.FF);\n\t\tassert(B>=pt1.SS&&B<=pt2.SS);\n\t\tassert(pt1.FF!=pt2.FF);\n\t\treturn det_gt_zero(pt1.FF-pt2.FF, pt1.SS-pt2.SS, A-pt2.FF, B-pt2.SS);\n\t}\n\telse\n\t{\n\t\tll am = al+ar>>1;\n\t\tpair<ll,ll> pt = solve_point(K, am, MAXP-am);\n\t\tif (A>=pt.FF&&B>=pt.SS) return true;\n\t\tif (A<pt.FF&&B<pt.SS) return false;\n\t\tif (A<pt.FF) return solve(K, am, ar);\n\t\telse return solve(K, al, am);\n\t}\n}\nint main()\n{\n\tcin>>A>>B;\n\tint l = 1, r = 100000;\n\twhile (l<=r)\n\t{\n\t\tll m = l+r>>1;\n\t\tif (solve(m, 0, MAXP)) l = m+1;\n\t\telse r = m-1;\n\t}\n\tcout<<r-1<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nvoid cnt(ll p, ll q, ll m, ll &x, ll &y, ll &num){\n\tx = y = num = 0;\n\tfor(ll i = 0; i*p <= m; ++i){\n\t\tll j = (m-i*p)/q;\n\t\tx += i*(j+1);\n\t\ty += j*(j+1)/2;\n\t\tnum += j+1;\n\t}\n}\n\nvoid calc(ll p, ll q, ll c, ll &r, ll &b, ll &k){\n\tbool foo = false;\n\tif(p < q){\n\t\tswap(p,q);\n\t\tfoo = true;\n\t}\n\tll lo = 0, hi = p*1818;\n\twhile(lo+1 < hi){\n\t\tll mi = (lo + hi)/2;\n\t\tll x, y, junk;\n\t\tcnt(p,q,mi,x,y,junk);\n\t\tif(p*x + q*y >= c) hi = mi;\n\t\telse lo = mi;\n\t}\n\t\n\tll x, y, num;\n\tcnt(p, q, lo, x, y, num);\n\tll bd = (c - x*p - y*q)/hi;\n\tk = num + bd;\n\n\tfor(int i = 0; true; i++) if((hi-i*p)%q == 0){\n\t\tint j = (hi-i*p)/q;\n\t\tr = x + i*bd + bd*(bd-1)/2 * q;\n\t\twhile(j >= p){\n\t\t\tj -= p;\n\t\t\ti += q;\n\t\t}\n\t\tb = y + j*bd + bd*(bd-1)/2 * p;\n\t\tbreak;\n\t}\n\n\tif(foo) swap(r,b);\n}\n\npii eval(ll r, ll b, ll p, ll q){\n\tll x, y, k;\n\tcalc(p, q, r*p + b*q, x, y, k);\n\tif(x <= r && y <= b) return pii(0, (int)k-1);\n\tif(x > r) return pii( 1,0);\n\telse \t  return pii(-1,0);\n}\n\nint solve(int r, int b, ll p0, ll q0, ll p1, ll q1){\n\tll lo = 0, hi = 1;\n\twhile(true){\n\t\tpii pa = eval(r, b, p0 + hi*p1, q0 + hi*q1);\n\t\tif(pa.first == 0) return pa.second;\n\t\tif(pa.first > 0) break;\n\t\thi *= 2;\n\t}\n\twhile(lo+1 < hi){\n\t\tll mi = (lo+hi)/2;\n\t\tpii pa = eval(r, b, p0 + mi*p1, q0 + mi*q1);\n\t\tif(pa.first == 0) return pa.second;\n\t\tif(pa.first > 0) hi = mi;\n\t\telse lo = mi;\n\t}\n\treturn solve(b,r, q1, p1, q0 + lo*q1, p0 + lo*p1);\n}\n\nint main(){\n\tint r, b;\n\tcin >> r >> b;\n\tcout << solve(r,b,1,0,0,1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 05.01.2020 11:08:10       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll solve(ll n, ll a, ll b, ll m) {\n    if (b == 0) return n * (a / m);\n    if (a >= m) return n * (a / m) + solve(n, a % m, b, m);\n    if (b >= m) return n * (n - 1) / 2 * (b / m) + solve(n, a, b % m, m);\n    return solve((a + b * n) / m, (a + b * n) % m, m, b);\n}\n\npair<long long, long long> GetKBest(int k, long long cx, long long cy) {\n  long long low = 0, high = (long long) 1e15;\n  while (low < high) {\n    long long mid = (low + high) >> 1;\n    long long cnt = solve(mid / cx + 1, mid % cx, cx, cy) + (mid / cx + 1);\n    if (cnt >= k) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n  long long sx = 0, sy = 0;\n  for (int x = 0; x * cx <= high; x++) {\n    long long cc = (high - x * cx) / cy + 1;\n    sx += cc * x;\n    sy += cc * (cc - 1) / 2;\n  }\n  return {sx, sy};\n}\n\nbool Solvable(int k, int X, int Y) {\n  auto a = make_pair(-1LL, -1LL), b = a;\n  long long total = (long long) 1e10 + 19;\n  long long low = 0, high = total;\n  while (low < high) {\n    long long mid = (low + high) >> 1;\n    auto p = GetKBest(k, total - mid, mid);\n    if (p.first <= X && p.second <= Y) {\n      return true;\n    }\n    if (p.first < X) {\n      a = p;\n      low = mid + 1;\n    } else {\n      b = p;\n      high = mid;\n    }\n  }\n  return (a.second * (b.first - X) + b.second * (X - a.first) <= Y * (b.first - a.first));\n}\n\nint main() {\n  int X, Y;\n  cin >> X >> Y;\n  if (X > Y) {\n    swap(X, Y);\n  }\n  int low = 3, high = (int) 2e6;\n  while (low < high) {\n    int mid = (low + high + 1) >> 1;\n    if (Solvable(mid, X, Y)) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  cout << low - 1 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll Ten(int n){\n\treturn n==0?1:Ten(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n}\n\nconst int P=2000000011LL;\n\nbool above(pi x,pi y,pi z){\n\tint c=(y.first-x.first)*(z.second-x.second)-(y.second-x.second)*(z.first-x.first);\n\treturn c>=0;\n}\n\npi sub(int k,int x){\n\tint mx=0;\n\t{\n\t\tint cur=0;\n\t\twhile(cur<k){\n\t\t\tmx++;\n\t\t\tcur+=mx;\n\t\t}\n\t}\n\tint lw=0,up=k*x;\n\twhile(up-lw>1){\n\t\tconst int mid=(up+lw)/2;\n\t\tint cnt=0;\n\t\tREP(b,mx){\n\t\t\tint rem=mid-b*P;\n\t\t\tif(rem>=0){\n\t\t\t\tcnt+=rem/x+1;\n\t\t\t}\n\t\t}\n\t\tif(cnt<=k)\n\t\t\tlw=mid;\n\t\telse\n\t\t\tup=mid;\n\t}\n\tpi ans(0,0);\n\tREP(b,mx){\n\t\tint rem=lw-b*P;\n\t\tif(rem>=0){\n\t\t\tint cnt=rem/x+1;\n\t\t\tans.first+=cnt*(cnt-1)/2;\n\t\t\tans.second+=b*cnt;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool Check(int r,int b,int k){\n\tif(r<b)swap(r,b);\n\t{\n\t\tpi y=sub(k,P-1);\n\t\tpi x=pi(y.second,y.first);\n\t\tif(x.first<=r&&r<=y.first)\n\t\t\treturn above(x,y,pi(r,b));\n\t}\n\tint lw=1,up=P-1;\n\twhile(up-lw>1){\n\t\tconst int mid=(up+lw)/2;\n\t\tpi w=sub(k,mid);\n\t\tif(w.first<=r&&w.second<=b)\n\t\t\treturn true;\n\t\tif(r<=w.first&&b<=w.second)\n\t\t\treturn false;\n\t\tif(w.first<=r){\n\t\t\tup=mid;\n\t\t}else{\n\t\t\tlw=mid;\n\t\t}\n\t}\n\t\n\tpi x=sub(k,up);\n\tpi y=sub(k,lw);\n\treturn above(x,y,pi(r,b));\n}\n\nsigned main(){\n\tint r=read(),b=read();\n\tint lw=0,up=0;\n\t{\n\t\tint cur=0,head=0;\n\t\twhile(cur<=r+b){\n\t\t\tup+=head+1;\n\t\t\tcur+=head*(head+1);\n\t\t\thead++;\n\t\t}\n\t\tcerr<<up<<endl;\n\t}\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tif(Check(r,b,mid))\n\t\t\tlw=mid;\n\t\telse\n\t\t\tup=mid;\n\t}\n\tprint(lw-1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T, typename S>\nostream& operator<<(ostream& os, pair<S, T> t){\n    os << \"(\" << t.first << \", \" << t.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> t){\n    long c = 0;\n    for(auto i : t)os << (c++ ? \", \" : \"{\") << i;\n    os << \"}\";\n    return os;\n}\n\nint main(){\n    long R, B;\n    cin >> R >> B;\n    if(R > B)swap(R, B);\n\n    auto hoge = [](long RR, long BB, long X, long R, long B){\n        long b = 0, r = 0;\n        long t = X + RR, x = 0;\n        while(t >= 0){\n            b += (t / RR) * (t / RR - 1) / 2;\n            r += x * (t / RR);\n            if(b > B || r > R)return 0;\n            t -= BB;\n            ++x;\n        }\n        return 1;\n    };\n\n    auto nibutan = [&hoge](long RR, long BB, long R, long B){\n        if(RR > BB){\n            swap(RR, BB);\n            swap(R, B);\n        }\n\n        long r = 0, l = 1;\n\n        while(hoge(RR, BB, l, R, B))l <<= 1;\n\n        while(r + 1 < l){\n            long mid = (l + r) / 2;\n            (hoge(RR, BB, mid, R, B) ? r : l) = mid;\n        }\n\n        vector<pair<long, long>> rem;\n        long remr = R, remb = B, c = 0;\n        {\n            long t = r + RR, s = t + 1, x = 0;\n            while(s >= 0){\n                if(!(s % RR) && rem.size() <= 1){\n                    rem.emplace_back(t / RR, x);\n                    if(rem.size() > 1){\n                        rem[1].first -= rem[0].first;\n                        rem[1].second -= rem[0].second;\n                    }\n                }\n                remr -= x * (t / RR);\n                remb -= (t / RR) * (t / RR - 1) / 2;\n                c += (t / RR);\n                t -= BB;\n                s -= BB;\n                ++x;\n            }\n        }\n        assert(remr >= 0 && remb >= 0);\n\n        if(rem.size() <= 1)return c;\n\n        long j = 0, k = (rem[0].first - rem[1].first - 1) / -rem[1].first, m = k - 1;\n\n        auto tapi = [&remr, remb, rem, m](long a){\n            long lb = (a * rem[0].first - remb - rem[1].first - 1) / -rem[1].first, ub = (remr - a * rem[0].second) / rem[1].second;\n            return ub >= lb && ub >= a * (a - 1) / 2 && lb <= a * (2 * m + 1 - a) / 2;\n        };\n\n        //cerr << r << \" : \" << c << \" : \" << rem << \" : \" << remb << \", \" << remr << \" : \" << k << endl;\n\n        assert(tapi(j) && !tapi(k));\n\n        while(j + 1 < k){\n            long mid = (j + k) / 2;\n            (tapi(mid) ? j : k) = mid;\n        }\n\n        return c + j;\n    };\n\n    auto cfexpand = [](long A, long B){\n        vector<pair<long, long>> ret;\n        long a(1), b(0), c(0), d(1), x(A), y(B);\n        auto comp = [](long& a, long& b, long x){\n            swap(a, b);\n            a += b * x;\n        };\n        while(y){\n            auto t = x / y;\n            comp(a, b, t);\n            comp(c, d, t);\n            ret.emplace_back(a, c);\n            swap(x, y);\n            y %= x;\n        }\n        return ret;\n    };\n\n    long l = 0, r = 20 * B + 1000;\n    long mi1, mi2;\n\n    while(r - l > 200){\n        mi1 = (2 * l + r) / 3;\n        mi2 = (l + 2 * r) / 3;\n        long k1 = nibutan(10 * R, mi1, R, B), k2 = nibutan(10 * R, mi2, R, B);\n        //cerr << mi1 << \" : \" << k1 << \" \" << mi2 << \" : \" << k2 << endl;\n        k1 > k2 ? r = mi2 : k1 < k2 || mi1 & 1 ? l = mi1 : r = mi2;\n    }\n\n    long ans = numeric_limits<long>::min();\n    for(l += l ? 0 : 1; l <= r; ++l){\n        cerr << l << \" : \" << nibutan(10 * R, l, R, B) - 1 << \" : \" << ans << endl;\n        ans = max(ans, nibutan(10 * R, l, R, B));\n    }\n    cout << ans - 1 << endl;\n    cerr << nibutan(10 * R, 10 * R, R, B) - 1 << endl;\n\n    /*auto t = cfexpand(B, R);\n    cerr << t << endl;\n    long ans = numeric_limits<long>::min();\n    for(auto i : t){\n        ans = max(ans, nibutan(i.second, i.first, R, B));\n        cerr << i << \" : \" << ans << endl << endl;\n    }\n    cout << ans - 1 << endl;*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define ws fuckinfoasdjfosadjljo\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, lint>;\nconst int MAXN = 100005;\nconst int mod = 1e9 + 7;\nconst lint inf = 1e10 + 19;\n\npi jeop(pi p, int n){\n\tvector<pi> v;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; j<=n; j++){\n\t\t\tv.emplace_back(i, j);\n\t\t}\n\t}\n\tsort(all(v), [&](const pi &a, const pi &b){\n\t\treturn a.first * p.first + a.second * p.second < \n\t\tb.first * p.first + b.second * p.second;\n\t});\n\tpi ret(0, 0);\n\tfor(int i=0; i<n; i++){\n\t\tret.first += v[i].first;\n\t\tret.second += v[i].second;\n\t}\n\treturn ret;\n\t/*\n\tif(p.first < p.second){\n\t\tauto ans = jeop(pi(p.second, p.first), n);\n\t\treturn pi(ans.second, ans.first);\n\t}\n\tauto enough = [&](lint k){\n\t\tlint ret = 0;\n\t\tfor(int i=0; i<2000; i++){\n\t\t\tif(k < p.first * i) break;\n\t\t\tret += (k - p.first * i) / p.second + 1;\n\t\t\tret = min(ret, (lint)2e9);\n\t\t}\n\t\treturn ret;\n\t};\n\tlint s = 0, e = 1e18;\n\twhile(s != e){\n\t\tlint m = (s+e)/2;\n\t\tif(enough(m) >= n) e = m;\n\t\telse s = m + 1;\n\t}\n\tpi ret(0, 0);\n\tfor(int i=0; i<2000; i++){\n\t\tif(s < p.first * i) break;\n\t\tlint cnt = (s - p.first * i) / p.second;\n\t\tret.first += cnt * (cnt + 1) / 2;\n\t\tret.second += (cnt + 1) * i;\n\t}\n\tint lim = enough(s) - n;\n\tfor(int i=0; i<2000 && lim; i++){\n\t\tif(s < p.first * i) break;\n\t\tif((s - p.first * i) % p.second == 0){\n\t\t\tret.first -= (s - p.first * i) / p.second;\n\t\t\tret.second -= i;\n\t\t\tlim--;\n\t\t}\n\t}\n\tswap(ret.first, ret.second);\n\treturn ret;*/\n}\n\nbool good(int n, int x, int y){\n\tauto ccw = [&](pi a, pi b, pi c){\n\t\tlint dx1 = b.first - a.first;\n\t\tlint dy1 = b.second - a.second;\n\t\tlint dx2 = c.first - a.first;\n\t\tlint dy2 = c.second - a.second;\n\t\treturn dx1 * dy2 - dy1 * dx2;\n\t};\n\tlint s = 1, e = inf - 1;\n\twhile(s != e){\n\t\tlint m = (s+e)/2;\n//\t\tprintf(\"%lld %lld %d -> \", m, inf - m, n);\n//\t\tfflush(stdout);\n\t\tauto pnt = jeop(pi(m, inf - m), n);\n//\t\tprintf(\"%lld %lld\\n\", pnt.first, pnt.second);\n//\t\tfflush(stdout);\n\t\tif(pnt.first <= x && pnt.second <= y){\n\t\t\treturn 1;\n\t\t}\n\t\tif(pnt.first >= x && pnt.second >= y){\n\t\t\treturn 0;\n\t\t}\n\t\tif(pnt.first < x) e = m;\n\t\telse s = m + 1;\n\t}\n\tauto func1 = jeop(pi(s, inf - s), n);\n\tauto func2 = jeop(pi(s - 1, inf - s + 1), n);\n\treturn ccw(func2, func1, pi(x, y)) <= 0;\n}\n\nint main(){\n\tint x, y;\n\tcin >> x >> y;\n\tint s = 0, e = 30; //1e9 + 2;\n\twhile(s != e){\n\t\tint m = (s+e+1)/2;\n\t\tif(good(m, x, y)) s = m;\n\t\telse e = m - 1;\n\t}\n\tcout << s - 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nusing i8 = ::std::int_least8_t;\nusing i32 = ::std::int_least32_t;\nusing i64 = ::std::int_least64_t;\nusing u8 = ::std::uint_least8_t;\nusing u32 = ::std::uint_least32_t;\nusing u64 = ::std::int_least64_t;\nusing isize = ::std::ptrdiff_t;\nusing usize = ::std::size_t;\n\ntemplate <class T = usize> class rep {\n\tconst T f, l;\n\npublic:\n\tclass itr {\n\t\tfriend rep;\n\t\tT i;\n\t\tconstexpr itr(T x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\tconstexpr T operator*() const noexcept { return i; }\n\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\tconstexpr rep(const T first, const T last) noexcept : f(first), l(last) {}\n\tconstexpr itr begin() const noexcept { return itr(f); }\n\tconstexpr itr end() const noexcept { return itr(l); }\n};\ntemplate <class T = usize> class revrep {\n\tconst T f, l;\n\npublic:\n\tclass itr {\n\t\tfriend revrep;\n\t\tT i;\n\t\tconstexpr itr(T x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\tconstexpr T operator*() const noexcept { return i; }\n\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\tconstexpr revrep(const T first, const T last) noexcept : f(first), l(last) {}\n\tconstexpr itr begin() const noexcept { return itr(l - 1); }\n\tconstexpr itr end() const noexcept { return itr(f - 1); }\n};\ntemplate <class T> bool amax(T &a, const T &b) {\n\treturn a <= b ? (a = b, 1) : 0;\n}\ntemplate <class T> bool amin(T &a, const T &b) {\n\treturn b <= a ? (a = b, 1) : 0;\n}\ntemplate <class T> bool asmax(T &a, const T &b) {\n\treturn b <= a ? 0 : (a = b, 1);\n}\ntemplate <class T> bool asmin(T &a, const T &b) {\n\treturn a <= b ? 0 : (a = b, 1);\n}\ntemplate <class T> using vec_alias = ::std::vector<T>;\ntemplate <class T> auto md_vec(usize n, const T &value) {\n\treturn ::std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(usize n, Args... args) {\n\treturn ::std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> const T &as_const(const T &v) noexcept { return v; }\ntemplate <class T> constexpr T difference(const T &a, const T &b) {\n\treturn a <= b ? b - a : a - b;\n}\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include<numeric>\n#include<cassert>\n#include<tuple>\n\n\nstatic constexpr u64 P = 10000000019ULL;\n\nu64 count_points(const u64 p, const u64 z) {\n\tconst u64 q = P - p;\n\tu64 ret = 0;\n\tif (p < q) {\n\t\tfor (u64 y = 0;z >= q*y;++y) {\n\t\t\tret += (z - q*y) / p + 1;\n\t\t}\n\t}\n\telse {\n\t\tfor (u64 x = 0;z >= p*x;++x) {\n\t\t\tret += (z - p*x) / q + 1;\n\t\t}\n\t}\n\treturn ret;\n}\n\n::std::pair<u64, u64> calc_sum(const u64 p, const u64 z, u64 cnt) {\n\tconst u64 q = P - p;\n\tu64 X = 0, Y = 0;\n\tif (p < q) {\n\t\tfor (u64 y = 0;z >= q*y;++y) {\n\t\t\tconst u64 d = (z - q*y) / p;\n\t\t\tY += y*(d + 1);\n\t\t\tX += d*(d + 1) / 2;\n\t\t\tif (cnt != 0 && (z + 1 - q*y) % p == 0) {\n\t\t\t\tY += y;\n\t\t\t\tX += d + 1;\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (u64 x = 0;z >= p*x;++x) {\n\t\t\tconst u64 d = (z - p*x) / q;\n\t\t\tX += x*(d + 1);\n\t\t\tY += d*(d + 1) / 2;\n\t\t\tif (cnt != 0 && (z + 1 - p*x) % q == 0) {\n\t\t\t\tX += x;\n\t\t\t\tY += d + 1;\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn ::std::make_pair(X, Y);\n}\n\nu64 calc_z(const u64 p, const u64 k) {\n\tu64 z_le = 0, z_gt = P * 3000;\n\twhile (z_gt - z_le != 1) {\n\t\tu64 z = (z_le + z_gt) / 2;\n\t\tif (count_points(p, z) <= k) {\n\t\t\tz_le = z;\n\t\t}\n\t\telse {\n\t\t\tz_gt = z;\n\t\t}\n\t}\n\treturn z_le;\n}\n\nbool check_k(const u64 R, const u64 B, const u64 k) {\n\tu64 p_lower = 0, p_upper = P;\n\twhile (p_upper - p_lower != 1) {\n\t\tu64 p = (p_lower + p_upper) / 2;\n\t\tu64 z = calc_z(p, k);\n\t\tu64 cnt = k - count_points(p, z);\n\t\tu64 X, Y;\n\t\t::std::tie(X, Y) = calc_sum(p, z, cnt);\n\t\tif (X <= R) {\n\t\t\tif (Y <= B) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp_upper = p;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (Y <= B) {\n\t\t\t\tp_lower = p;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tu64 z1 = calc_z(p_upper, k);\n\tu64 z2 = calc_z(p_lower, k);\n\tu64 X1, X2, Y1, Y2;\n\t::std::tie(X1, Y1) = calc_sum(p_upper, z1,\n\t\tk - count_points(p_upper, z1));\n\t::std::tie(X2, Y2) = calc_sum(p_lower, z2,\n\t\tk - count_points(p_lower, z2));\n\tif ((X2 - X1)*(B - Y1) >= (Y2 - Y1)*(R - X1)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nint main() {\n\tu64 R, B;\n\t::std::cin >> R >> B;\n\n\tu64 k_ok = 0, k_ng = 4000000;\n\twhile (k_ng - k_ok != 1) {\n\t\tu64 k = (k_ok + k_ng) / 2;\n\t\tif (check_k(R, B, k)) {\n\t\t\tk_ok = k;\n\t\t}\n\t\telse {\n\t\t\tk_ng = k;\n\t\t}\n\t}\n\n\t::std::cout << k_ok - 1 << ::std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 05.01.2020 11:08:10       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\npair<long long, long long> GetKBest(int k, long long cx, long long cy) {\n  long long low = 0, high = (long long) 1e15;\n  while (low < high) {\n    long long mid = (low + high) >> 1;\n    long long cnt = 0;\n    for (int x = 0; cnt < k && x * cx <= mid; x++) {\n      cnt += (mid - x * cx) / cy + 1;\n    }\n    if (cnt >= k) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n  long long sx = 0, sy = 0;\n  for (int x = 0; x * cx <= high; x++) {\n    long long cc = (high - x * cx) / cy + 1;\n    sx += cc * x;\n    sy += cc * (cc - 1) / 2;\n  }\n  return {sx, sy};\n}\n\nbool Solvable(int k, int X, int Y) {\n  auto a = make_pair(-1LL, -1LL), b = a;\n  long long total = (long long) 1e10 + 19;\n  long long low = 0, high = total;\n  while (low < high) {\n    long long mid = (low + high) >> 1;\n    auto p = GetKBest(k, total - mid, mid);\n    if (p.first <= X && p.second <= Y) {\n      return true;\n    }\n    if (p.first < X) {\n      a = p;\n      low = mid + 1;\n    } else {\n      b = p;\n      high = mid;\n    }\n  }\n  return (a.second * (b.first - X) + b.second * (X - a.first) <= Y * (b.first - a.first));\n}\n\nint main() {\n  int X, Y;\n  cin >> X >> Y;\n  if (X > Y) {\n    swap(X, Y);\n  }\n  int low = 3, high = (int) 2e6;\n  while (low < high) {\n    int mid = (low + high + 1) >> 1;\n    if (Solvable(mid, X, Y)) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  cout << low - 1 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define ws fuckinfoasdjfosadjljo\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, lint>;\nconst int MAXN = 100005;\nconst int mod = 1e9 + 7;\nconst lint inf = 1e10 + 19;\n\npi jeop(pi p, int n){\n\t/*\n\tvector<pi> v;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; j<=n; j++){\n\t\t\tv.emplace_back(i, j);\n\t\t}\n\t}\n\tsort(all(v), [&](const pi &a, const pi &b){\n\t\treturn a.first * p.first + a.second * p.second < \n\t\tb.first * p.first + b.second * p.second;\n\t});\n\tpi ret(0, 0);\n\tfor(int i=0; i<n; i++){\n\t\tret.first += v[i].first;\n\t\tret.second += v[i].second;\n\t}\n\treturn ret;\n\t*/\n\tif(p.first < p.second){\n\t\tauto ans = jeop(pi(p.second, p.first), n);\n\t\treturn pi(ans.second, ans.first);\n\t}\n\tauto enough = [&](lint k){\n\t\tlint ret = 0;\n\t\tfor(int i=0; i<2000; i++){\n\t\t\tif(k < p.first * i) break;\n\t\t\tret += (k - p.first * i) / p.second + 1;\n\t\t\tret = min(ret, (lint)2e9);\n\t\t}\n\t\treturn ret;\n\t};\n\tlint s = 0, e = 1e18;\n\twhile(s != e){\n\t\tlint m = (s+e)/2;\n\t\tif(enough(m) >= n) e = m;\n\t\telse s = m + 1;\n\t}\n\tpi ret(0, 0);\n\tfor(int i=0; i<2000; i++){\n\t\tif(s < p.first * i) break;\n\t\tlint cnt = (s - p.first * i) / p.second;\n\t\tret.first += cnt * (cnt + 1) / 2;\n\t\tret.second += (cnt + 1) * i;\n\t}\n\tint lim = enough(s) - n;\n\tfor(int i=0; i<2000 && lim; i++){\n\t\tif(s < p.first * i) break;\n\t\tif((s - p.first * i) % p.second == 0){\n\t\t\tret.first -= (s - p.first * i) / p.second;\n\t\t\tret.second -= i;\n\t\t\tlim--;\n\t\t}\n\t}\n\tswap(ret.first, ret.second);\n\treturn ret;\n}\n\nbool good(int n, int x, int y){\n\tauto ccw = [&](pi a, pi b, pi c){\n\t\tlint dx1 = b.first - a.first;\n\t\tlint dy1 = b.second - a.second;\n\t\tlint dx2 = c.first - a.first;\n\t\tlint dy2 = c.second - a.second;\n\t\treturn dx1 * dy2 - dy1 * dx2;\n\t};\n\tlint s = 1, e = inf - 1;\n\twhile(s != e){\n\t\tlint m = (s+e)/2;\n\t\t//printf(\"%lld %lld %d -> \", m, inf - m, n);\n\t\t//fflush(stdout);\n\t\tauto pnt = jeop(pi(m, inf - m), n);\n\t\t//printf(\"%lld %lld\\n\", pnt.first, pnt.second);\n\t\t//fflush(stdout);\n\t\tif(pnt.first <= x && pnt.second <= y){\n\t\t\treturn 1;\n\t\t}\n\t\tif(pnt.first >= x && pnt.second >= y){\n\t\t\treturn 0;\n\t\t}\n\t\tif(pnt.first < x) e = m;\n\t\telse s = m + 1;\n\t}\n\tauto func1 = jeop(pi(s, inf - s), n);\n\tauto func2 = jeop(pi(s - 1, inf - s + 1), n);\n\treturn ccw(func2, func1, pi(x, y)) <= 0;\n}\n\nint main(){\n\tint x, y;\n\tcin >> x >> y;\n\tint s = 0, e = 1e9 + 2;\n\twhile(s != e){\n\t\tint m = (s+e+1)/2;\n\t\tif(good(m, x, y)) s = m;\n\t\telse e = m - 1;\n\t}\n\tcout << s - 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T, typename S>\nostream& operator<<(ostream& os, pair<S, T> t){\n    os << \"(\" << t.first << \", \" << t.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> t){\n    long c = 0;\n    for(auto i : t)os << (c++ ? \", \" : \"{\") << i;\n    os << \"}\";\n    return os;\n}\n\nint main(){\n    long R, B;\n    cin >> R >> B;\n    if(R > B)swap(R, B);\n\n    auto hoge = [&B, R](long RR, long BB, long X){\n        long b = 0, r = 0;\n        long t = X + RR, x = 0;\n        while(t >= 0){\n            b += (t / RR) * (t / RR - 1) / 2;\n            r += x * (t / RR);\n            if(b > B || r > R)return 0;\n            t -= BB;\n            ++x;\n        }\n        return 1;\n    };\n\n    auto nibutan = [&hoge, B, R](long RR, long BB){\n        long r = 0, l = 1;\n\n        while(hoge(RR, BB, l))l <<= 1;\n\n        while(r + 1 < l){\n            long mid = (l + r) / 2;\n            (hoge(RR, BB, mid) ? r : l) = mid;\n        }\n\n        vector<pair<long, long>> rem;\n        long remr = R, remb = B, c = 0;\n        {\n            long t = r + RR, s = t + 1, x = 0;\n            while(s >= 0){\n                if((t + R * R) / R < (s + R * R) / R && rem.size() <= 1){\n                    rem.emplace_back(s / R, x);\n                    if(rem.size() > 1){\n                        rem[1].first -= rem[0].first;\n                        rem[1].second -= rem[0].second;\n                    }\n                }\n                remr -= x * (t / RR);\n                remb -= (t / RR) * (t / RR - 1) / 2;\n                c += (t / R);\n                t -= BB;\n                s -= BB;\n                ++x;\n            }\n        }\n\n        if(rem.size() <= 1)return c;\n\n        long j = 0, k = (rem[0].first + 1) / -rem[1].first, m = k - 1;\n\n        auto tapi = [&remr, remb, rem, m](long a){\n            long lb = (a * rem[0].first - remr) / -rem[1].first, ub = (remb - a * rem[0].second) / rem[1].second;\n            return ub >= lb && ub >= a * (a - 1) / 2 && lb <= a * (2 * m + 1 - a) / 2;\n        };\n\n        //cerr << r << \" : \" << c << \" : \" << rem << \" : \" << remr << \", \" << remb << \" : \" << k << endl;\n\n        while(j + 1 < k){\n            long mid = (j + k) / 2;\n            (tapi(mid) ? j : k) = mid;\n        }\n\n        return c + j;\n    };\n\n    if(R == B){\n        cout << nibutan(R, B) << endl;\n        return 0;\n    }\n\n    long l = 0, r = B + 10;\n    long mi1, mi2;\n\n    while(r - l > 50){\n        mi1 = (2 * l + r) / 3;\n        mi2 = (l + 2 * r) / 3;\n        nibutan(R, mi1) > nibutan(R, mi2) ? r = mi2 : l = mi1;\n    }\n\n    long ans = numeric_limits<long>::min();\n    for(l += l ? 0 : 1; l <= r; ++l)ans = max(ans, nibutan(R, l));\n    cout << ans - 1 << endl;\n}"
  },
  {
    "language": "Text",
    "code": "5"
  },
  {
    "language": "C",
    "code": "//AWTF2019-D\n#include<stdio.h>\n#include<stdbool.h>\n#define prime 10000000019\n\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\n\nlong long calcul(long long p,long long q,long long z,long long *r,long long *b){\n  long long f=0,cnt=0,w,i;\n  (*r)=0;(*b)=0;\n  if(p<q){f=1;llswap(&p,&q);}\n  i=0;\n  while(z>=0){\n    w=z/q;\n    cnt+=(w+1);\n    (*r)+=i*(w+1);\n    (*b)+=llsankaku(w);\n    z-=p;\n    i++;\n  }\n  if(f){llswap(r,b);}\n  return cnt;\n}\n\nvoid calc(long long p,long long q,long long k,long long *r,long long *b){\n  long long st,fi,te,c;\n  st=0;fi=prime*2000;\n  while(st<=fi){\n    te=(st+fi)/2;\n    c=calcul(p,q,te,r,b);\n    if(c==k){break;}\n    if(c<k){st=te+1;}\n    if(c>k){fi=te-1;}\n  }\n}\n\nbool ispossible(long long r,long long b,long long k){\n  long long st,fi,te,zr,zb;\n  st=1;fi=prime-1;\n  while(st<=fi){\n    te=(st+fi)/2;\n    calc(te,prime-te,k,&zr,&zb);\n    if(zr<=r && zb<=b){return true;}\n    if(zr>r && zb>b){return false;}\n    if(zr>r){st=te+1;}\n    else{fi=te-1;}\n  }\n  return false;\n}\n\nlong long solve(long long r,long long b){\n  long long st=0,fi=2222222,te;\n  while(st<=fi){\n    te=(st+fi)/2;\n    if(ispossible(r,b,te)){st=te+1;}\n    else{fi=te-1;}\n  }\n  return fi;\n}\n\nint main(){\n  long long r,b;\n  scanf(\"%lld%lld\",&r,&b);\n  printf(\"%lld\\n\",solve(r,b)-1);//-1 : empty box\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//AWTF2019-D\n#include<stdio.h>\n#include<stdbool.h>\n#define prime 10000000019\n\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\n\nlong long calcul(long long p,long long q,long long z,long long *r,long long *b){\n  long long f=0,cnt=0,w,i;\n  (*r)=0;(*b)=0;\n  if(p<q){f=1;llswap(&p,&q);}\n  i=0;\n  while(z>=0){\n    w=z/q;\n    cnt+=(w+1);\n    (*r)+=i*(w+1);\n    (*b)+=llsankaku(w);\n    z-=p;\n    i++;\n  }\n  if(f){llswap(r,b);}\n  return cnt;\n}\n\nvoid calc(long long p,long long q,long long k,long long *r,long long *b){\n  long long st,fi,te,c;\n  st=0;fi=prime*4000;\n  while(st<=fi){\n    te=(st+fi)/2;\n    c=calcul(p,q,te,r,b);\n    if(c==k){break;}\n    if(c<k){st=te+1;}\n    if(c>k){fi=te-1;}\n  }\n}\n\nbool ispossible(long long r,long long b,long long k){\n  long long st,fi,te,zr,zb;\n  st=1;fi=prime-1;\n  while(st<=fi){\n    te=(st+fi)/2;\n    calc(te,prime-te,k,&zr,&zb);\n    if(zr<=r && zb<=b){return true;}\n    if(zr>r && zb>b){return false;}\n    if(zr>r){st=te+1;}\n    else{fi=te-1;}\n  }\n  return false;\n}\n\nlong long solve(long long r,long long b){\n  long long st=0,fi=4444444,te;\n  while(st<=fi){\n    te=(st+fi)/2;\n    if(ispossible(r,b,te)){st=te+1;}\n    else{fi=te-1;}\n  }\n  return fi;\n}\n\nint main(){\n  long long r,b;\n  scanf(\"%lld%lld\",&r,&b);\n  printf(\"%lld\\n\",solve(r,b)-1);//-1 : empty box\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//AWTF2019-D\n#include<stdio.h>\n#include<stdbool.h>\n#define prime 10000000019\n\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\n\nlong long calcul(long long p,long long q,long long z,long long *r,long long *b){\n  long long f=0,cnt=0,w,i;\n  (*r)=0;(*b)=0;\n  if(p<q){f=1;llswap(&p,&q);}\n  i=0;\n  while(z>=0){\n    w=z/q;\n    cnt+=(w+1);\n    (*r)+=i*(w+1);\n    (*b)+=llsankaku(w);\n    z-=p;\n    i++;\n  }\n  if(f){llswap(r,b);}\n  return cnt;\n}\n\nvoid calc(long long p,long long q,long long k,long long *r,long long *b){\n  long long st,fi,te,c;\n  st=0;fi=prime*2000;\n  while(st<=fi){\n    te=(st+fi)/2;\n    c=calcul(p,q,te,r,b);\n    if(c==k){break;}\n    if(c<k){st=te+1;}\n    if(c>k){fi=te-1;}\n  }\n}\n\ntypedef struct{\n  long long xz;\n  long long yz;\n}point;\n\npoint vector_minus(point a,point b){\n  point r;\n  r.xz=a.xz-b.xz;\n  r.yz=a.yz-b.yz;\n  return r;\n}\n\n//gaiseki\nlong long crossproduct(point a,point b){\n  return a.xz*b.yz-a.yz*b.xz;\n}\n\nbool ispossible(long long r,long long b,long long k){\n  long long st,fi,te,zr,zb;\n  long long fr,fb,sr,sb;\n  st=1;fi=prime-1;\n  while(st<=fi){\n    te=(st+fi)/2;\n    calc(te,prime-te,k,&zr,&zb);\n    if(zr<=r && zb<=b){return true;}\n    if(zr>r && zb>b){return false;}\n    if(zr>r){st=te+1;sr=zr;sb=zb;}\n    else{fi=te-1;fr=zr;fb=zb;}\n  }\n  //Is (r,b) on above the line{(fr,fb),(sr,sb)}(fr<sr)?\n  point tg,l1,l2;\n  tg.xz=r;tg.yz=b;\n  l1.xz=fr;l1.yz=fb;\n  l2.xz=sr;l2.yz=sb;\n  if(crossproduct(vector_minus(l2,l1),vector_minus(tg,l1))>=0){return true;}\n  return false;\n}\n\nlong long solve(long long r,long long b){\n  long long st=0,fi=2222222,te;\n  while(st<=fi){\n    te=(st+fi)/2;\n    if(ispossible(r,b,te)){st=te+1;}\n    else{fi=te-1;}\n  }\n  return fi;\n}\n\nint main(){\n  long long r,b;\n  scanf(\"%lld%lld\",&r,&b);\n  printf(\"%lld\\n\",solve(r,b)-1);//-1 : empty box\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//AWTF2019-D\n#include<stdio.h>\n#include<stdbool.h>\n#define prime 10000000019\n\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\n\nlong long calcul(long long p,long long q,long long z,long long *r,long long *b){\n  long long f=0,cnt=0,w,i;\n  (*r)=0;(*b)=0;\n  if(p<q){f=1;llswap(&p,&q);}\n  i=0;\n  while(z>=0){\n    w=z/q;\n    cnt+=(w+1);\n    (*r)+=i*(w+1);\n    (*b)+=llsankaku(w);\n    z-=p;\n    i++;\n  }\n  if(f){llswap(r,b);}\n  return cnt;\n}\n\nvoid calc(long long p,long long q,long long k,long long *r,long long *b){\n  long long st,fi,te,c;\n  st=0;fi=prime*4000;\n  while(st<=fi){\n    te=(st+fi)/2;\n    c=calcul(p,q,te,r,b);\n    if(c==k){break;}\n    if(c<k){st=te+1;}\n    if(c>k){fi=te-1;}\n  }\n}\n\nbool ispossible(long long r,long long b,long long k){\n  long long st,fi,te,zr,zb;\n  st=1;fi=prime-1;\n  while(st<=fi){\n    te=(st+fi)/2;\n    calc(te,prime-te,k,&zr,&zb);\n    if(zr<=r && zb<=b){return true;}\n    if(zr>r && zb>b){return false;}\n    if(zr>r){st=te+1;}\n    else{fi=te-1;}\n  }\n  return false;\n}\n\nlong long solve(long long r,long long b){\n  long long st=0,fi=2222222,te;\n  while(st<=fi){\n    te=(st+fi)/2;\n    if(ispossible(r,b,te)){st=te+1;}\n    else{fi=te-1;}\n  }\n  return fi;\n}\n\nint main(){\n  long long r,b;\n  scanf(\"%lld%lld\",&r,&b);\n  printf(\"%lld\\n\",solve(r,b)-1);//-1 : empty box\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n\nint main()\n{\n  int cnt;\n  int R, B;\n  int M = 0; \n  int i,j,m;\n  int K = 0;\n\n  cnt = scanf(\"%d %d\", &R, &B);\n\n  M = R;\n  if(M < B) M=B;\n\n  for (m=1; m<M; m++) {\n    for (i=0; i<m; i++) {\n      for (j=0; j<m; j++) {\n        if ((i != (m-1)) && (j != (m-1))) continue;\n        if ((R >= i) && (B >= j)) {\n          K++;\n          R -= i;\n          B -= j;\n        } else if (B < j) {\n          break;\n        }\n      }\n    }\n  }\n\n  printf(\"%d\", (K - 1));\n\n  return 0;\n} "
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nr, b = [int(x) for x in stdin.readline().rstrip().split()]\n\ni = 0\nans = 0\nwhile True:\n    i += 1\n    n = (i * (i + 1))/2\n    r -= n\n    b -= n\n    if r < 0 or b < 0:\n        i -= 1\n        r += n\n        b += n\n        break\n    ans += i + 1\n    if r == 0 or b == 0:\n        break\n\nif r < b:\n    big = b\n    small = r\nelse:\n    big = r\n    small = b\n\nif big >= ((i + 1) * (i + 2)) / 2:\n    for j in range(i + 2):\n        small -= j\n        if small < 0:\n            big += j - abs(small)\n            break\n        ans += 1\n        big -= i + 1 - j\n        if small == 0:\n            break\n    i += 1\n    while True:\n        i += 1\n        big -= i\n        if big < 0:\n            break\n        ans += 1\n        if big == 0:\n            break\nelse:\n    pans = 0\n    for j in  range(i + 2):\n        bsum = 0\n        ssum = 0\n        for k in range(j, i + 2):\n            ssum += k\n            bsum += i + 1 - k\n            if ssum == small or bsum == big:\n                box = k - j + 1\n                break\n            if ssum > small or bsum > big:\n                k -= 1\n                box = k - j + 1\n                break\n        if pans < box:\n            pans = box\n    ans += pans\n\nprint(int(ans))\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, input().split()))\ndef I(): return int(input())\ndef LS(): return input().split()\ndef S(): return list(input())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\na = LI()\nif min(a) <= k:\n    print(-1)\nelse:\n    ans = []\n    while max(a) > 0:\n        for i in range(n):\n            if a[i] > 0:\n                a[i] -= 1\n                ans.append(i+1)\n    print(len(ans))\n    for i in range(len(ans)-1):\n        print(ans[i],end = \" \")\n    print(ans[-1])\n\"\"\"\n\n#B\n\"\"\"\nn = I()\nq = I()\n\"\"\"\n#C1\n\n#C2\n\n#D\nr,b = LI()\nansr = []\nansb = []\nflagr = True\nflagb = True\nfor i in range(150000):\n    r -= i\n    b -= i\n    if flagr:\n        if r > 0:\n            ansr.append(i)\n        else:\n            flagr = False\n            ansr.append(r+i)\n    if flagb:\n        if b > 0:\n            ansb.append(i)\n        else:\n            flagb = False\n            ansb.append(b+i)\nif ansr[-1] == len(ansr)-1 and ansb[-1] == len(ansb)-1:\n    ans = len(ansr)+len(ansb)-2\nelse:\n    ans = len(ansr)+len(ansb)-3\nprint(ans)\n#E\n\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nr, b = [int(x) for x in stdin.readline().rstrip().split()]\n\ni = 0\nans = 0\nwhile True:\n    i += 1\n    n = (i * (i + 1))/2\n    r -= n\n    b -= n\n    if r < 0 or b < 0:\n        i -= 1\n        r += n\n        b += n\n        break\n    ans += i + 1\n    if r == 0 or b == 0:\n        break\n\nif r < b:\n    big = b\n    small = r\nelse:\n    big = r\n    small = b\n\nif big >= (i + 1) * (i + 2) / 2:\n    for j in range(i + 2):\n        small -= j\n        if small < 0:\n            break\n        ans += 1\n        if small == 0:\n            break\n    big -= (i + 1) * (i + 2) / 2\n    i += 1\n    while True:\n        i += 1\n        big -= i\n        if big < 0:\n            break\n        ans += 1\n        if big == 0:\n            break\nelse:\n    ans += (big + small) // (i + 1)\n\nprint(int(ans))"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nr, b = [int(x) for x in stdin.readline().rstrip().split()]\n\ni = 0\nans = 0\nwhile True:\n    i += 1\n    n = (i * (i + 1))/2\n    r -= n\n    b -= n\n    if r < 0 or b < 0:\n        i -= 1\n        r += n\n        b += n\n        break\n    ans += i + 1\n    if r == 0 or b == 0:\n        break\n\nif r < b:\n    big = b\n    small = r\nelse:\n    big = r\n    small = b\n\nif big >= (i + 1) * (i + 2) / 2:\n    for j in range(i + 2):\n        small -= j\n        if small < 0:\n            break\n        ans += 1\n        if small == 0:\n            break\n    big -= (i + 1) * (i + 2) / 2\n    i += 1\n    while True:\n        i += 1\n        big -= i\n        if big < 0:\n            break\n        ans += 1\n        if big == 0:\n            break\nelse:\n    ans += (big + small) // (i + 1)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nr, b = [int(x) for x in stdin.readline().rstrip().split()]\n\ni = 0\nans = 0\nwhile True:\n    i += 1\n    n = (i * (i + 1))/2\n    r -= n\n    b -= n\n    if r < 0 or b < 0:\n        i -= 1\n        r += n\n        b += n\n        break\n    ans += i + 1\n    if r == 0 or b == 0:\n        break\n\nif r < b:\n    big = b\n    small = r\nelse:\n    big = r\n    small = b\n\nif big >= (i + 1) * (i + 2) / 2:\n    for j in range(i + 2):\n        small -= j\n        if small < 0:\n            big += j - abs(small)\n            break\n        ans += 1\n        big -= i + 1 - j\n        if small == 0:\n            break\n    i += 1\n    while True:\n        i += 1\n        big -= i\n        if big < 0:\n            break\n        ans += 1\n        if big == 0:\n            break\nelse:\n    ans += (big + small) // (i + 1)\n\nprint(int(ans))\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, input().split()))\ndef I(): return int(input())\ndef LS(): return input().split()\ndef S(): return list(input())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\na = LI()\nif min(a) <= k:\n    print(-1)\nelse:\n    ans = []\n    while max(a) > 0 and k >= 0:\n        for i in range(n):\n            if a[i] > 0:\n                a[i] -= 1\n                ans.append(i+1)\n        k -= 1\n    print(len(ans))\n    for i in range(len(ans)-1):\n        print(ans[i],end = \" \")\n    print(ans[-1])\n\"\"\"\n#B\n\"\"\"\nn = I()\nq = I()\n\"\"\"\n#C1\n\n#C2\n\n#D\ndef f(n):\n    return n*(n+1)//2\n\ndef f2(n,i):\n    return (n+1)*i-f(n)\nr,b = LI()\nans = 0\nfor i in range(1,1500000):\n    r -= f(i)\n    b -= f(i)\n    if r < 0 or b < 0:\n        r += f(i)\n        b += f(i)\n        break\n    ans += i+1\na = max(r,b)\nc = min(r,b)\nwhile a+c >= i:\n    r = int((-1+(1+8*c)**(1/2))/2)\n    k = f(r)\n    a -= i*(r+1)-k\n    c -= k\n    key = r+1\n    if a < 0:\n        l = int((2*i-1-((2*i+1)**2+8*a)**(1/2))/2)\n        k2 = f2(l,i)\n        a += k2\n        c += i-k2\n        key -= l+1\n    r += 1\n    while c >= r and a >= i-r:\n        c -= r\n        a -= i-r\n        key += 1\n        r += 1\n    ans += key\n    i += 1\n    d = max(a,c)\n    e = min(a,c)\n    a = d\n    c = e\nprint(ans)\n\n#E\n\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, input().split()))\ndef I(): return int(input())\ndef LS(): return input().split()\ndef S(): return list(input())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\na = LI()\nif min(a) <= k:\n    print(-1)\nelse:\n    ans = []\n    while max(a) > 0:\n        for i in range(n):\n            if a[i] > 0:\n                a[i] -= 1\n                ans.append(i+1)\n    print(len(ans))\n    for i in range(len(ans)-1):\n        print(ans[i],end = \" \")\n    print(ans[-1])\n\"\"\"\n\n#B\n\"\"\"\nn = I()\nq = I()\n\"\"\"\n#C1\n\n#C2\n\n#D\ndef f(n):\n    return n*(n+1)//2\nr,b = LI()\nans = 0\nfor i in range(1,1500000):\n    r -= f(i)\n    b -= f(i)\n    if r < 0 or b < 0:\n        r += f(i)\n        b += f(i)\n        break\n    ans += i+1\na = max(r,b)\nc = min(r,b)\nwhile a+c >= i:\n    for k in range(i+1):\n        if a >= i-k and c >= k:\n            a -= i-k\n            c -= k\n            ans += 1\n    i += 1\n    d = max(a,c)\n    e = min(a,c)\n    a = d\n    c = e\nprint(ans)\n#E\n\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nr, b = [int(x) for x in stdin.readline().rstrip().split()]\n\ni = 0\nans = 0\nwhile True:\n    i += 1\n    n = (i * (i + 1))/2\n    r -= n\n    b -= n\n    if r < 0 or b < 0:\n        i -= 1\n        r += n\n        b += n\n        break\n    ans += i + 1\n    if r == 0 or b == 0:\n        break\n\nif r < b:\n    big = b\n    small = r\nelse:\n    big = r\n    small = b\n\nif big >= ((i + 1) * (i + 2)) / 2:\n    for j in range(i + 2):\n        small -= j\n        if small < 0:\n            big += j - abs(small)\n            break\n        ans += 1\n        big -= i + 1 - j\n        if small == 0:\n            break\n    i += 1\n    while True:\n        i += 1\n        big -= i\n        if big < 0:\n            break\n        ans += 1\n        if big == 0:\n            break\nelse:\n    pans = 0\n    for j in  range(i + 2):\n        bsum = 0\n        ssum = 0\n        for k in range(j, i + 2):\n            ssum += k\n            bsum += i + 1 - k\n            if ssum == small or bsum == big:\n                box = k - j + 1\n                break\n            if ssum > small or bsum > big:\n                k -= 1\n                box = k - j + 1\n                break\n        if pans < box:\n            pans = box\n    ans += (big + small) // (i + 1)\n\nprint(int(ans))\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, input().split()))\ndef I(): return int(input())\ndef LS(): return input().split()\ndef S(): return list(input())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\na = LI()\nif min(a) <= k:\n    print(-1)\nelse:\n    ans = []\n    while max(a) > 0:\n        for i in range(n):\n            if a[i] > 0:\n                a[i] -= 1\n                ans.append(i+1)\n    print(len(ans))\n    for i in range(len(ans)-1):\n        print(ans[i],end = \" \")\n    print(ans[-1])\n\"\"\"\n\n#B\n\"\"\"\nn = I()\nq = I()\n\"\"\"\n#C1\n\n#C2\n\n#D\nr,b = LI()\nansr = []\nansb = []\nsum = 0\nflagr = True\nflagb = True\nfor i in range(100000):\n    r -= i\n    b -= i\n    if flagr:\n        if r > 0:\n            ansr.append(i)\n        else:\n            flagr = False\n            ansr.append(r+i)\n    if flagb:\n        if b > 0:\n            ansb.append(i)\n        else:\n            flagb = False\n            ansb.append(b+i)\nans = len(ansr)+len(ansb)-2\nif ansr[-1] != len(ansr)-1:\n    ans -= 1\nif ansb[-1] != len(ansb)-1:\n    ans -= 1\nprint(ans)\n#E\n\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nr, b = [int(x) for x in stdin.readline().rstrip().split()]\n\ni = 0\nans = 0\nwhile True:\n    i += 1\n    n = (i * (i + 1))/2\n    r -= n\n    b -= n\n    if r < 0 or b < 0:\n        i -= 1\n        r += n\n        b += n\n        break\n    ans += i + 1\n    if r == 0 or b == 0:\n        break\n\nif r < b:\n    big = b\n    small = r\nelse:\n    big = r\n    small = b\n\nif big >= (i + 1) * (i + 2) / 2:\n    for j in range(i + 2):\n        small -= j\n        if small < 0:\n            break\n        ans += 1\n        if small == 0:\n            break\n        big -= i + 1 - j\n    i += 1\n    while True:\n        i += 1\n        big -= i\n        if big < 0:\n            break\n        ans += 1\n        if big == 0:\n            break\nelse:\n    ans += (big + small) // (i + 1)\n\nprint(int(ans))\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nr, b = [int(x) for x in stdin.readline().rstrip().split()]\n\ni = 0\nans = 0\nwhile True:\n    i += 1\n    n = (i * (i + 1))/2\n    r -= n\n    b -= n\n    if r < 0 or b < 0:\n        i -= 1\n        r += n\n        b += n\n        break\n    ans += i + 1\n    if r == 0 or b == 0:\n        break\n\nif r < b:\n    big = b\n    small = r\nelse:\n    big = r\n    small = b\n\nif big >= (i + 1) * (i + 2) / 2:\n    for j in range(i + 2):\n        small -= j\n        if small < 0:\n            break\n        ans += 1\n        if small == 0:\n            break\n        big -= i + 1 - j\n    i += 1\n    while True:\n        i += 1\n        big -= i\n        if big < 0:\n            break\n        ans += 1\n        if big == 0:\n            break\nelse:\n    ans += (big + small) // (i + 1)\n\nprint(int(ans))"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, input().split()))\ndef I(): return int(input())\ndef LS(): return input().split()\ndef S(): return list(input())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\na = LI()\nif min(a) <= k:\n    print(-1)\nelse:\n    ans = []\n    while max(a) > 0:\n        for i in range(n):\n            if a[i] > 0:\n                a[i] -= 1\n                ans.append(i+1)\n    print(len(ans))\n    for i in range(len(ans)-1):\n        print(ans[i],end = \" \")\n    print(ans[-1])\n\"\"\"\n\n#B\n\"\"\"\nn = I()\nq = I()\n\"\"\"\n#C1\n\n#C2\n\n#D\nr,b = LI()\nansr = []\nansb = []\nsum = 0\nflagr = True\nflagb = True\nfor i in range(100000):\n    r -= i\n    b -= i\n    if flagr:\n        if r > 0:\n            ansr.append(i)\n        else:\n            flagr = False\n            ansr.append(r+i)\n    if flagb:\n        if b > 0:\n            ansb.append(i)\n        else:\n            flagb = False\n            ansb.append(b+i)\n\nif ansr[-1] == len(ansr)-1 and ansb[-1] == len(ansb)-1:\n    ans = len(ansr)+len(ansb)-2\nelse:\n    ans = len(ansr)+len(ansb)-3\nprint(ans)\n#E\n\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nr, b = [int(x) for x in stdin.readline().rstrip().split()]\n\ni = 0\nans = 0\nwhile True:\n    i += 1\n    n = (i * (i + 1))/2\n    r -= n\n    b -= n\n    if r < 0 or b < 0:\n        i -= 1\n        r += n\n        b += n\n        break\n    ans += i + 1\n    if r == 0 or b == 0:\n        break\n\nif r < b:\n    big = b\n    small = r\nelse:\n    big = r\n    small = b\n\nif big >= (i + 1) * (i + 2) / 2:\n    for j in range(i + 2):\n        small -= j\n        if small < 0:\n            break\n        ans += 1\n        big -= i + 1 - j\n        if small == 0:\n            break\n    i += 1\n    while True:\n        i += 1\n        big -= i\n        if big < 0:\n            break\n        ans += 1\n        if big == 0:\n            break\nelse:\n    ans += (big + small) // (i + 1)\n\nprint(int(ans))\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, input().split()))\ndef I(): return int(input())\ndef LS(): return input().split()\ndef S(): return list(input())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\na = LI()\nif min(a) <= k:\n    print(-1)\nelse:\n    ans = []\n    while max(a) > 0 and k >= 0:\n        for i in range(n):\n            if a[i] > 0:\n                a[i] -= 1\n                ans.append(i+1)\n        k -= 1\n    print(len(ans))\n    for i in range(len(ans)-1):\n        print(ans[i],end = \" \")\n    print(ans[-1])\n\"\"\"\n#B\n\"\"\"\nn = I()\nq = I()\n\"\"\"\n#C1\n\n#C2\n\n#D\ndef f(n):\n    return n*(n+1)//2\nr,b = LI()\nans = 0\nfor i in range(1,1500000):\n    r -= f(i)\n    b -= f(i)\n    if r < 0 or b < 0:\n        r += f(i)\n        b += f(i)\n        break\n    ans += i+1\na = max(r,b)\nc = min(r,b)\nwhile a+c >= i:\n    r = int((-1+(1+8*c)**(1/2))/2)\n    k = f(r)\n    a -= i*(r+1)-k\n    c -= k\n    key = r\n    if a < 0:\n        l = int((2*i-1+((2*i+1)**2+8*a)**(1/2))/2)\n        k2 = f(l)\n        a += (l+1)*i-k\n        c += k\n        key -= i-l+2\n    r += 1\n    while c >= r and a >= i-r:\n        c -= r\n        a -= i-r\n        key += 1\n        r += 1\n    ans += key\n    i += 1\n    d = max(a,c)\n    e = min(a,c)\n    a = d\n    c = e\nprint(ans)\n\n#E\n\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nr, b = [int(x) for x in stdin.readline().rstrip().split()]\n\ni = 0\nans = 0\nwhile True:\n    i += 1\n    n = (i * (i + 1))/2\n    r -= n\n    b -= n\n    if r < 0 or b < 0:\n        i -= 1\n        r += n\n        b += n\n        break\n    ans += i + 1\n    if r == 0 or b == 0:\n        break\n\nif r < b:\n    big = b\n    small = r\nelse:\n    big = r\n    small = b\n\nif big >= ((i + 1) * (i + 2)) / 2:\n    for j in range(i + 2):\n        small -= j\n        if small < 0:\n            big += j - abs(small)\n            break\n        ans += 1\n        big -= i + 1 - j\n        if small == 0:\n            break\n    i += 1\n    while True:\n        i += 1\n        big -= i\n        if big < 0:\n            break\n        ans += 1\n        if big == 0:\n            break\nelse:\n    ans += (big + small) // (i + 1)\n\nprint(int(ans))\n"
  }
]