[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nlong long countColorings(char* S1, char* S2, int N) {\n    long long dp[N+1][3][3];\n    memset(dp, 0, sizeof(dp));\n\n    // Initial state\n    for (int color = 0; color < 3; color++) {\n        if ((S1[0] == '.' || S1[0] - '1' == color) && \n            (S2[0] == '.' || S2[0] - '1' == color)) {\n            dp[1][color][color] = 1;\n        }\n    }\n\n    // Dynamic programming\n    for (int i = 1; i < N; i++) {\n        for (int prevColor = 0; prevColor < 3; prevColor++) {\n            for (int prevPrevColor = 0; prevPrevColor < 3; prevPrevColor++) {\n                for (int currColor = 0; currColor < 3; currColor++) {\n                    if (currColor == prevColor) continue;\n\n                    // Check domino coloring constraints\n                    if ((S1[i] == '.' || S1[i] - '1' == currColor) && \n                        (S2[i] == '.' || S2[i] - '1' == currColor)) {\n                        dp[i+1][currColor][prevColor] += dp[i][prevColor][prevPrevColor];\n                        dp[i+1][currColor][prevColor] %= MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    // Sum all possible final colorings\n    long long total = 0;\n    for (int color1 = 0; color1 < 3; color1++) {\n        for (int color2 = 0; color2 < 3; color2++) {\n            if (color1 != color2) {\n                total += dp[N][color1][color2];\n                total %= MOD;\n            }\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    int N;\n    char S1[100001], S2[100001];\n\n    scanf(\"%d %s %s\", &N, S1, S2);\n    printf(\"%lld\\n\", countColorings(S1, S2, N));\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:15:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MOD 1000000007\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char S1[N+1], S2[N+1];\n    scanf(\"%s\", S1);\n    scanf(\"%s\", S2);\n    \n    long long dp[N][3][3];\n    memset(dp, 0, sizeof(dp));\n    \n    if (S1[0] == S2[0]) {\n        // Vertical domino\n        for (int c1 = 0; c1 < 3; c1++) {\n            dp[0][c1][c1] = 1;\n        }\n    } else {\n        // Horizontal domino\n        for (int c1 = 0; c1 < 3; c1++) {\n            for (int c2 = 0; c2 < 3; c2++) {\n                if (c1 != c2) {\n                    dp[0][c1][c2] = 1;\n                }\n            }\n        }\n    }\n    \n    for (int i = 1; i < N; i++) {\n        if (S1[i] == S2[i]) {\n            // Vertical domino\n            for (int prev_c1 = 0; prev_c1 < 3; prev_c1++) {\n                for (int prev_c2 = 0; prev_c2 < 3; prev_c2++) {\n                    if (S1[i-1] == S2[i-1]) {\n                        // Previous was vertical\n                        for (int c = 0; c < 3; c++) {\n                            if (c != prev_c1) {\n                                dp[i][c][c] = (dp[i][c][c] + dp[i-1][prev_c1][prev_c2]) % MOD;\n                            }\n                        }\n                    } else {\n                        // Previous was horizontal\n                        for (int c = 0; c < 3; c++) {\n                            if (c != prev_c1 && c != prev_c2) {\n                                dp[i][c][c] = (dp[i][c][c] + dp[i-1][prev_c1][prev_c2]) % MOD;\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            if (S1[i-1] == S2[i-1]) {\n                // Previous was vertical\n                for (int prev_c = 0; prev_c < 3; prev_c++) {\n                    for (int c1 = 0; c1 < 3; c1++) {\n                        for (int c2 = 0; c2 < 3; c2++) {\n                            if (c1 != c2 && c1 != prev_c && c2 != prev_c) {\n                                dp[i][c1][c2] = (dp[i][c1][c2] + dp[i-1][prev_c][prev_c]) % MOD;\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Previous was horizontal\n                for (int prev_c1 = 0; prev_c1 < 3; prev_c1++) {\n                    for (int prev_c2 = 0; prev_c2 < 3; prev_c2++) {\n                        for (int c1 = 0; c1 < 3; c1++) {\n                            for (int c2 = 0; c2 < 3; c2++) {\n                                if (c1 != c2 && c1 != prev_c1 && c2 != prev_c2) {\n                                    dp[i][c1][c2] = (dp[i][c1][c2] + dp[i-1][prev_c1][prev_c2]) % MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    long long result = 0;\n    if (S1[N-1] == S2[N-1]) {\n        for (int c = 0; c < 3; c++) {\n            result = (result + dp[N-1][c][c]) % MOD;\n        }\n    } else {\n        for (int c1 = 0; c1 < 3; c1++) {\n            for (int c2 = 0; c2 < 3; c2++) {\n                result = (result + dp[N-1][c1][c2]) % MOD;\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:16:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint solve(int N, string S1, string S2) {\n    vector<vector<long long>> dp(N + 1, vector<long long>(4, 0));\n    dp[0][0] = 1;\n    \n    for (int i = 0; i < N; ) {\n        if (i + 1 <= N && S1[i] == S2[i]) {\n            // Vertical domino\n            for (int prev = 0; prev < 4; ++prev) {\n                if (dp[i][prev] == 0) continue;\n                for (int curr = 1; curr <= 3; ++curr) {\n                    if (curr == prev) continue;\n                    dp[i + 1][curr] = (dp[i + 1][curr] + dp[i][prev]) % MOD;\n                }\n            }\n            i += 1;\n        } else {\n            // Horizontal domino\n            for (int prev = 0; prev < 4; ++prev) {\n                if (dp[i][prev] == 0) continue;\n                for (int curr1 = 1; curr1 <= 3; ++curr1) {\n                    for (int curr2 = 1; curr2 <= 3; ++curr2) {\n                        if (curr1 == prev || curr1 == curr2) continue;\n                        dp[i + 2][curr2] = (dp[i + 2][curr2] + dp[i][prev]) % MOD;\n                    }\n                }\n            }\n            i += 2;\n        }\n    }\n    \n    long long res = 0;\n    for (int c = 1; c <= 3; ++c) {\n        res = (res + dp[N][c]) % MOD;\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    string S1, S2;\n    cin >> N;\n    cin >> S1 >> S2;\n    cout << solve(N, S1, S2) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DominoColoring {\n    private static final int MOD = 1000000007;\n\n    public static int solve(String S1, String S2) {\n        int N = S1.length();\n        long[][] dp = new long[N + 1][4]; // 0: none, 1: same, 2: different, 3: vertical\n        dp[0][0] = 1;\n\n        for (int i = 0; i < N; i++) {\n            char c1 = S1.charAt(i);\n            char c2 = S2.charAt(i);\n            if (c1 == c2) { // vertical domino\n                // Previous state can be anything except vertical\n                long ways = (dp[i][0] + dp[i][1] + dp[i][2]) % MOD;\n                dp[i + 1][3] = (ways * 3) % MOD;\n            } else { // horizontal domino\n                // Case 1: current domino is same color as previous vertical\n                long sameAsVertical = dp[i][3];\n                // Case 2: current domino is different from previous vertical\n                long differentFromVertical = (dp[i][3] * 2) % MOD;\n                // Case 3: previous was horizontal, current is same color for both\n                long sameAsHorizontal = (dp[i][1] + dp[i][2]) % MOD;\n                // Case 4: previous was horizontal, current is different colors\n                long differentFromHorizontal = (dp[i][1] + dp[i][2]) * 2 % MOD;\n\n                dp[i + 1][1] = (sameAsVertical + sameAsHorizontal) % MOD;\n                dp[i + 1][2] = (differentFromVertical + differentFromHorizontal) % MOD;\n            }\n        }\n\n        long result = 0;\n        for (int state = 1; state <= 3; state++) {\n            result = (result + dp[N][state]) % MOD;\n        }\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String S1 = scanner.next();\n        String S2 = scanner.next();\n        System.out.println(solve(S1, S2));\n    }\n}",
    "timestamp": "2025-08-05 23:17:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    private static final int MOD = 1000000007;\n\n    public int colorDominoes(String S1, String S2) {\n        int N = S1.length();\n        long[][] dp = new long[N][3];\n        \n        // Initialize first column\n        for (int color = 0; color < 3; color++) {\n            if (canPaint(S1.charAt(0), S2.charAt(0), color)) {\n                dp[0][color] = 1;\n            }\n        }\n        \n        // DP through columns\n        for (int i = 1; i < N; i++) {\n            for (int currColor = 0; currColor < 3; currColor++) {\n                if (!canPaint(S1.charAt(i), S2.charAt(i), currColor)) continue;\n                \n                for (int prevColor = 0; prevColor < 3; prevColor++) {\n                    if (currColor != prevColor) {\n                        dp[i][currColor] = (dp[i][currColor] + dp[i-1][prevColor]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        // Sum final column\n        long result = 0;\n        for (int color = 0; color < 3; color++) {\n            result = (result + dp[N-1][color]) % MOD;\n        }\n        \n        return (int)result;\n    }\n    \n    private boolean canPaint(char c1, char c2, int color) {\n        int digit1 = c1 - '0';\n        int digit2 = c2 - '0';\n        \n        if (digit1 == 1 && color == 0) return false;\n        if (digit1 == 2 && color == 1) return false;\n        if (digit1 == 3 && color == 2) return false;\n        \n        if (digit2 == 1 && color == 0) return false;\n        if (digit2 == 2 && color == 1) return false;\n        if (digit2 == 3 && color == 2) return false;\n        \n        return true;\n    }\n}",
    "timestamp": "2025-08-05 23:17:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numOfWays(string s1, string s2) {\n        int n = s1.length();\n        const int MOD = 1000000007;\n        \n        vector<vector<long long>> dp(n + 1, vector<long long>(3, 0));\n        dp[0][0] = dp[0][1] = dp[0][2] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int color = 0; color < 3; color++) {\n                for (int prevColor = 0; prevColor < 3; prevColor++) {\n                    if (color != prevColor) {\n                        if (s1[i-1] == s2[i-1]) {\n                            dp[i][color] = (dp[i][color] + dp[i-1][prevColor]) % MOD;\n                        } else {\n                            int otherColor = 3 - color - prevColor;\n                            dp[i][color] = (dp[i][color] + dp[i-1][otherColor]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n        \n        long long result = 0;\n        for (int color = 0; color < 3; color++) {\n            result = (result + dp[n][color]) % MOD;\n        }\n        \n        return result;\n    }\n};",
    "timestamp": "2025-08-05 23:17:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 1000000007\n\ndef count_paintings(S1, S2):\n    N = len(S1)\n    \n    # Base case initialization\n    if N == 0:\n        return 0\n    \n    # Create a dp table to store the number of ways to paint dominos upto i\n    dp = [[0] * 3 for _ in range(N)]\n    \n    # Fill initial values based on the first column of the grid\n    dp[0] = [1, 1, 1] # three choices of color for the first domino\n    \n    for i in range(1, N):\n        if S1[i-1] == S1[i] and S2[i-1] == S2[i]: # Vertical dominos\n            dp[i][0] = (dp[i-1][1] + dp[i-1][2]) % MOD\n            dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % MOD\n            dp[i][2] = (dp[i-1][0] + dp[i-1][1]) % MOD\n        else: # Horizontal dominos\n            dp[i][0] = (dp[i-1][1] + dp[i-1][2]) % MOD\n            dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % MOD\n            dp[i][2] = (dp[i-1][0] + dp[i-1][1]) % MOD\n    \n    return sum(dp[N-1]) % MOD\n\n# Example usage\nS1 = \"121211\"\nS2 = \"112121\"\nprint(count_paintings(S1, S2))",
    "timestamp": "2025-08-13 14:23:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class DominoesPainting {\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String S1 = scanner.next();\n        String S2 = scanner.next();\n        int N = S1.length();\n        \n        // dp array for the number of ways to paint up to i-th position\n        long[][] dp = new long[2][2];\n        \n        if (S1.charAt(0) == S2.charAt(0)) {\n            dp[0][0] = 3; // vertical domino\n        } else {\n            dp[0][1] = 6; // horizontal domino\n        }\n        \n        for (int i = 1; i < N; i++) {\n            if (S1.charAt(i) == S2.charAt(i)) { // vertical domino\n                if (S1.charAt(i - 1) == S2.charAt(i - 1)) { // previous was vertical\n                    dp[i % 2][0] = (dp[(i - 1) % 2][0] * 2) % MOD;\n                } else { // previous was horizontal\n                    dp[i % 2][0] = dp[(i - 1) % 2][1];\n                }\n                dp[i % 2][1] = 0; // reset horizontal for this index\n            } else { // horizontal domino\n                if (S1.charAt(i - 1) == S2.charAt(i - 1)) { // previous was vertical\n                    dp[i % 2][1] = (dp[(i - 1) % 2][0] * 2) % MOD;\n                } else { // previous was horizontal\n                    dp[i % 2][1] = (dp[(i - 1) % 2][1] * 3) % MOD;\n                }\n                dp[i % 2][0] = 0; // reset vertical for this index\n            }\n        }\n        \n        long result = (dp[(N - 1) % 2][0] + dp[(N - 1) % 2][1]) % MOD;\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 14:23:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\nint countWays(char* S1, char* S2, int N) {\n    long long dp[N+1][3]; // dp[i][c]: number of ways up to column i with color c at dp[i]\n    int i;\n\n    // initialize dp for the first column\n    dp[0][0] = 1; // color red\n    dp[0][1] = 1; // color cyan\n    dp[0][2] = 1; // color green\n\n    for (i = 1; i <= N; ++i) {\n        dp[i][0] = (dp[i-1][1] + dp[i-1][2]) % MOD;\n        dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % MOD;\n        dp[i][2] = (dp[i-1][0] + dp[i-1][1]) % MOD;\n\n        if ((S1[i-1] == 'X' && S1[i] == 'X') || (S2[i-1] == 'X' && S2[i] == 'X')) {\n            dp[i][0] = dp[i][1] = dp[i][2] = 0;\n        }\n    }\n    return (dp[N][0] + dp[N][1] + dp[N][2]) % MOD;\n}\n\nint main() {\n    int N;\n    char S1[1001], S2[1001];\n\n    // Input reading part (example)\n    printf(\"Enter N: \");\n    scanf(\"%d\", &N);\n    printf(\"Enter S1: \");\n    scanf(\"%s\", S1);\n    printf(\"Enter S2: \");\n    scanf(\"%s\", S2);\n\n    printf(\"Ways to paint: %d\\n\", countWays(S1, S2, N));\n    return 0;\n}",
    "timestamp": "2025-08-13 14:23:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countWays(S1, S2) {\n    const MOD = 1000000007;\n    const N = S1.length;\n    let i = 0;\n    let result = 1;\n\n    while (i < N) {\n        if (S1[i] === S2[i]) {\n            // Vertical domino\n            if (i === 0) {\n                result = (result * 3) % MOD;\n            } else if (S1[i - 1] === S2[i - 1]) {\n                result = (result * 2) % MOD;\n            }\n            i++;\n        } else {\n            // Horizontal domino\n            if (i === 0) {\n                result = (result * 6) % MOD;\n            } else if (S1[i - 1] === S2[i - 1]) {\n                result = (result * 2) % MOD;\n            } else {\n                result = (result * 3) % MOD;\n            }\n            i += 2;\n        }\n    }\n\n    return result;\n}",
    "timestamp": "2025-08-13 14:24:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_domino_colorings(S1, S2):\n    MOD = 10**9 + 7\n    N = len(S1)\n    \n    # DP states: [previous color][current column's coloring]\n    dp = [[[0]*8 for _ in range(3)] for _ in range(N+1)]\n    \n    # Initial state\n    dp[0][0][0] = 1\n    \n    for col in range(N):\n        for prev_color in range(3):\n            for mask in range(8):\n                if dp[col][prev_color][mask] == 0:\n                    continue\n                \n                # Try coloring next column\n                for new_color in range(3):\n                    if new_color == prev_color:\n                        continue\n                    \n                    # Check if current domino arrangement works\n                    valid = True\n                    new_mask = 0\n                    \n                    # Check first row\n                    if S1[col] == '.' and S2[col] == '.':\n                        new_mask |= new_color\n                        new_mask |= (new_color << 1)\n                    elif S1[col] == '.' and S2[col] == 'X':\n                        new_mask |= new_color\n                    elif S1[col] == 'X' and S2[col] == '.':\n                        new_mask |= (new_color << 1)\n                    \n                    # Validate color constraints\n                    if new_mask & mask:\n                        valid = False\n                    \n                    if valid:\n                        dp[col+1][new_color][new_mask] = (\n                            dp[col+1][new_color][new_mask] + \n                            dp[col][prev_color][mask]\n                        ) % MOD\n    \n    # Sum all final states\n    total = sum(sum(dp[N][color]) for color in range(3)) % MOD\n    return total",
    "timestamp": "2025-08-13 14:24:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function numberOfWays(S1, S2) {\n    const MOD = 1000000007;\n    const N = S1.length;\n    const dp = new Array(N + 1).fill(0).map(() => new Array(8).fill(0));\n    \n    dp[0][7] = 1;\n    \n    for (let i = 0; i < N; i++) {\n        for (let mask = 0; mask < 8; mask++) {\n            if (dp[i][mask] === 0) continue;\n            \n            for (let newMask = 0; newMask < 8; newMask++) {\n                if ((mask & newMask) !== 0) continue;\n                \n                const topLeft = (newMask & 1) !== 0;\n                const topRight = (newMask & 2) !== 0;\n                const bottomLeft = (newMask & 4) !== 0;\n                const bottomRight = (mask & 4) !== 0;\n                \n                if (S1[i] === '#' && topLeft) continue;\n                if (S1[i] === '#' && topRight) continue;\n                if (S2[i] === '#' && bottomLeft) continue;\n                if (S2[i] === '#' && bottomRight) continue;\n                \n                dp[i + 1][newMask] = (dp[i + 1][newMask] + dp[i][mask]) % MOD;\n            }\n        }\n    }\n    \n    let result = 0;\n    for (let mask = 0; mask < 8; mask++) {\n        result = (result + dp[N][mask]) % MOD;\n    }\n    \n    return result;\n}",
    "timestamp": "2025-08-13 14:24:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    import sys\n    S1 = sys.stdin.readline().strip()\n    S2 = sys.stdin.readline().strip()\n    N = len(S1)\n    \n    # Initialize DP\n    # dp[i][c1][c2] where c1 is color of S1[i], c2 is color of S2[i]\n    # But for efficiency, we can represent it as a dictionary or transition states\n    \n    # Initial state for the first column\n    if S1[0] == S2[0]:\n        # vertical domino\n        res = 3\n        prev = 3\n    else:\n        # two horizontal dominoes\n        res = 3 * 2\n        prev = 6\n    \n    for i in range(1, N):\n        if S1[i] == S2[i]:\n            # vertical domino\n            if S1[i-1] == S2[i-1]:\n                # previous was vertical\n                res = (prev * 2) % MOD\n            else:\n                # previous was horizontal\n                res = (prev * 1) % MOD\n        else:\n            # two horizontal dominoes\n            if S1[i-1] == S2[i-1]:\n                # previous was vertical\n                res = (prev * 2) % MOD\n            else:\n                # previous was horizontal\n                res = (prev * 3) % MOD\n        prev = res\n    \n    print(res % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 14:24:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1000000007;\n\nfunction solve(S1, S2) {\n    const N = S1.length;\n    let dp = new Array(N + 1).fill(0).map(() => new Array(3).fill(0).map(() => new Array(3).fill(0)));\n    \n    // Initialize the DP for the first column\n    if (S1[0] === S2[0]) {\n        // Vertical domino\n        for (let c1 = 0; c1 < 3; c1++) {\n            dp[1][c1][c1] = 0; // Same color not allowed\n        }\n    } else {\n        // Horizontal domino\n        for (let c1 = 0; c1 < 3; c1++) {\n            for (let c2 = 0; c2 < 3; c2++) {\n                if (c1 !== c2) {\n                    dp[1][c1][c2] = 1;\n                }\n            }\n        }\n    }\n    \n    for (let i = 2; i <= N; i++) {\n        if (S1[i-1] === S2[i-1]) {\n            // Vertical domino\n            for (let prev_c1 = 0; prev_c1 < 3; prev_c1++) {\n                for (let prev_c2 = 0; prev_c2 < 3; prev_c2++) {\n                    if (dp[i-1][prev_c1][prev_c2] === 0) continue;\n                    for (let curr_c = 0; curr_c < 3; curr_c++) {\n                        if (curr_c !== prev_c1 && curr_c !== prev_c2) {\n                            dp[i][curr_c][curr_c] = (dp[i][curr_c][curr_c] + dp[i-1][prev_c1][prev_c2]) % MOD;\n                        }\n                    }\n                }\n            }\n        } else {\n            // Horizontal domino\n            if (S1[i-1] === S1[i-2] && S2[i-1] === S2[i-2]) {\n                // Both dominoes are horizontal\n                for (let prev_c1 = 0; prev_c1 < 3; prev_c1++) {\n                    for (let prev_c2 = 0; prev_c2 < 3; prev_c2++) {\n                        if (dp[i-1][prev_c1][prev_c2] === 0) continue;\n                        for (let curr_c1 = 0; curr_c1 < 3; curr_c1++) {\n                            for (let curr_c2 = 0; curr_c2 < 3; curr_c2++) {\n                                if (curr_c1 !== curr_c2 && curr_c1 !== prev_c1 && curr_c2 !== prev_c2) {\n                                    dp[i][curr_c1][curr_c2] = (dp[i][curr_c1][curr_c2] + dp[i-1][prev_c1][prev_c2]) % MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n            } else if (S1[i-1] === S1[i-2]) {\n                // Previous domino is vertical, current is horizontal\n                for (let prev_c = 0; prev_c < 3; prev_c++) {\n                    for (let prev_c2 = 0; prev_c2 < 3; prev_c2++) {\n                        if (dp[i-1][prev_c][prev_c2] === 0) continue;\n                        for (let curr_c1 = 0; curr_c1 < 3; curr_c1++) {\n                            for (let curr_c2 = 0; curr_c2 < 3; curr_c2++) {\n                                if (curr_c1 !== curr_c2 && curr_c1 !== prev_c && curr_c2 !== prev_c2) {\n                                    dp[i][curr_c1][curr_c2] = (dp[i][curr_c1][curr_c2] + dp[i-1][prev_c][prev_c2]) % MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Previous domino is horizontal, current is vertical or mixed\n                for (let prev_c1 = 0; prev_c1 < 3; prev_c1++) {\n                    for (let prev_c2 = 0; prev_c2 < 3; prev_c2++) {\n                        if (dp[i-1][prev_c1][prev_c2] === 0) continue;\n                        for (let curr_c1 = 0; curr_c1 < 3; curr_c1++) {\n                            for (let curr_c2 = 0; curr_c2 < 3; curr_c2++) {\n                                if (curr_c1 !== curr_c2 && curr_c1 !== prev_c1 && curr_c2 !== prev_c2) {\n                                    dp[i][curr_c1][curr_c2] = (dp[i][curr_c1][curr_c2] + dp[i-1][prev_c1][prev_c2]) % MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    let result = 0;\n    for (let c1 = 0; c1 < 3; c1++) {\n        for (let c2 = 0; c2 < 3; c2++) {\n            result = (result + dp[N][c1][c2]) % MOD;\n        }\n    }\n    return result;\n}",
    "timestamp": "2025-08-13 14:25:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint countWays(string S1, string S2) {\n    int N = S1.length();\n    vector<vector<long long>> dp(N + 1, vector<long long>(3, 0));\n    dp[0][0] = 1; // Initial condition\n\n    for (int i = 1; i <= N; i++) {\n        if (S1[i - 1] == S2[i - 1]) {\n            // Vertical domino\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % MOD;\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % MOD;\n            dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % MOD;\n        } else {\n            // Horizontal domino covering S1[i-1] and S2[i-1] with S1[i] and S2[i]\n            if (i == 1 || (S1[i - 2] == S2[i - 2])) {\n                dp[i][0] = (dp[i - 1][0] * 2) % MOD;\n                dp[i][1] = (dp[i - 1][1] * 2) % MOD;\n                dp[i][2] = (dp[i - 1][2] * 2) % MOD;\n            } else {\n                dp[i][0] = dp[i - 1][0] % MOD;\n                dp[i][1] = dp[i - 1][1] % MOD;\n                dp[i][2] = dp[i - 1][2] % MOD;\n            }\n        }\n    }\n\n    return (dp[N][0] + dp[N][1] + dp[N][2]) % MOD;\n}\n\nint main() {\n    string S1, S2;\n    cin >> S1 >> S2;\n    cout << countWays(S1, S2) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:43:27"
  }
]