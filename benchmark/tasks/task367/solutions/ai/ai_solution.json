[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_UNITS 100\n#define MAX_RELATIONS 1000\n\ntypedef struct {\n    char from[50];\n    char to[50];\n    int exponent;\n} Relation;\n\nRelation relations[MAX_RELATIONS];\nint relationCount = 0;\nchar units[MAX_UNITS][50];\nint unitCount = 0;\nint adjacency[MAX_UNITS][MAX_UNITS];\nint visited[MAX_UNITS];\nint exponents[MAX_UNITS];\n\nint findOrAddUnit(const char *unit) {\n    for (int i = 0; i < unitCount; i++) {\n        if (strcmp(units[i], unit) == 0) {\n            return i;\n        }\n    }\n    strcpy(units[unitCount], unit);\n    return unitCount++;\n}\n\nint dfs(int u, int currentExponent) {\n    visited[u] = 1;\n    exponents[u] = currentExponent;\n    for (int v = 0; v < unitCount; v++) {\n        if (adjacency[u][v] != 0) {\n            if (visited[v]) {\n                if (exponents[v] != currentExponent + adjacency[u][v]) {\n                    return 0;\n                }\n            } else {\n                if (!dfs(v, currentExponent + adjacency[u][v])) {\n                    return 0;\n                }\n            }\n        }\n    }\n    return 1;\n}\n\nint checkConsistency() {\n    for (int i = 0; i < unitCount; i++) {\n        visited[i] = 0;\n        exponents[i] = 0;\n    }\n    for (int i = 0; i < unitCount; i++) {\n        if (!visited[i]) {\n            if (!dfs(i, 0)) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        char from[50], to[50];\n        int exponent;\n        scanf(\" 1 %s = 10^%d %s\", from, &exponent, to);\n        int u = findOrAddUnit(from);\n        int v = findOrAddUnit(to);\n        relations[relationCount].exponent = exponent;\n        strcpy(relations[relationCount].from, from);\n        strcpy(relations[relationCount].to, to);\n        relationCount++;\n        adjacency[u][v] = exponent;\n        adjacency[v][u] = -exponent;\n    }\n    if (checkConsistency()) {\n        printf(\"Consistent\\n\");\n    } else {\n        printf(\"Contradictory\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nbool areRelationsContradictory(const vector<tuple<string, string, int>>& relations) {\n    unordered_map<string, vector<pair<string, double>>> graph;\n    unordered_map<string, double> conversion;\n\n    for (const auto& rel : relations) {\n        string u = get<0>(rel);\n        string v = get<1>(rel);\n        int x = get<2>(rel);\n\n        graph[u].emplace_back(v, pow(10, x));\n        graph[v].emplace_back(u, 1.0 / pow(10, x));\n    }\n\n    for (const auto& entry : graph) {\n        const string& start = entry.first;\n        if (conversion.find(start) != conversion.end()) continue;\n\n        queue<string> q;\n        q.push(start);\n        conversion[start] = 1.0;\n\n        while (!q.empty()) {\n            string current = q.front();\n            q.pop();\n\n            for (const auto& neighbor : graph[current]) {\n                string next = neighbor.first;\n                double factor = neighbor.second;\n\n                if (conversion.find(next) == conversion.end()) {\n                    conversion[next] = conversion[current] * factor;\n                    q.push(next);\n                } else {\n                    if (abs(conversion[next] - (conversion[current] * factor)) > 1e-9) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<tuple<string, string, int>> relations;\n\n    for (int i = 0; i < N; ++i) {\n        string u, v;\n        int x;\n        cin >> u >> v >> x;\n        relations.emplace_back(u, v, x);\n    }\n\n    if (areRelationsContradictory(relations)) {\n        cout << \"contradictory\" << endl;\n    } else {\n        cout << \"consistent\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class UnitContradictionChecker {\n    private static class Edge {\n        String to;\n        int exponent;\n        Edge(String to, int exponent) {\n            this.to = to;\n            this.exponent = exponent;\n        }\n    }\n\n    public static boolean hasContradiction(String[] relations) {\n        Map<String, List<Edge>> graph = new HashMap<>();\n        Map<String, Integer> exponents = new HashMap<>();\n\n        for (String relation : relations) {\n            String[] parts = relation.split(\" \");\n            String unitA = parts[1];\n            String unitB = parts[3];\n            int exponent = Integer.parseInt(parts[2].substring(3));\n\n            if (!graph.containsKey(unitA)) {\n                graph.put(unitA, new ArrayList<>());\n            }\n            graph.get(unitA).add(new Edge(unitB, exponent));\n\n            if (!graph.containsKey(unitB)) {\n                graph.put(unitB, new ArrayList<>());\n            }\n            graph.get(unitB).add(new Edge(unitA, -exponent));\n        }\n\n        for (String unit : graph.keySet()) {\n            if (!exponents.containsKey(unit)) {\n                if (dfs(unit, 0, graph, exponents)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static boolean dfs(String current, int currentExp, Map<String, List<Edge>> graph, Map<String, Integer> exponents) {\n        if (exponents.containsKey(current)) {\n            return exponents.get(current) != currentExp;\n        }\n        exponents.put(current, currentExp);\n        for (Edge edge : graph.get(current)) {\n            if (dfs(edge.to, currentExp + edge.exponent, graph, exponents)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.nextLine();\n        String[] relations = new String[n];\n        for (int i = 0; i < n; i++) {\n            relations[i] = scanner.nextLine();\n        }\n        System.out.println(hasContradiction(relations) ? \"contradictory\" : \"consistent\");\n    }\n}",
    "timestamp": "2025-08-05 21:15:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class UnitRelationships {\n    public static boolean isConsistent(List<String> relations) {\n        Map<String, Map<String, Integer>> graph = new HashMap<>();\n        \n        for (String relation : relations) {\n            String[] parts = relation.split(\"=\");\n            String[] left = parts[0].trim().split(\"\\\\s+\");\n            String[] right = parts[1].trim().split(\"\\\\s+\");\n            \n            String unit1 = left[1];\n            String unit2 = right[1];\n            int power = Integer.parseInt(left[0]);\n            int logValue = Integer.parseInt(right[0].substring(2));\n            \n            if (!graph.containsKey(unit1)) {\n                graph.put(unit1, new HashMap<>());\n            }\n            if (!graph.containsKey(unit2)) {\n                graph.put(unit2, new HashMap<>());\n            }\n            \n            if (graph.get(unit1).containsKey(unit2) && \n                graph.get(unit1).get(unit2) != logValue - power) {\n                return false;\n            }\n            \n            graph.get(unit1).put(unit2, logValue - power);\n            graph.get(unit2).put(unit1, power - logValue);\n        }\n        \n        return true;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        List<String> relations1 = Arrays.asList(\n            \"1 A = 10^2 B\", \n            \"1 B = 10^3 C\"\n        );\n        System.out.println(isConsistent(relations1)); // true\n        \n        List<String> relations2 = Arrays.asList(\n            \"1 A = 10^2 B\", \n            \"1 B = 10^3 C\", \n            \"1 A = 10^6 C\"\n        );\n        System.out.println(isConsistent(relations2)); // false\n    }\n}",
    "timestamp": "2025-08-05 21:15:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_UNITS 100\n\nint powers[MAX_UNITS][MAX_UNITS];\nint unit_count = 0;\n\nint get_unit_index(char* unit) {\n    for (int i = 0; i < unit_count; i++) {\n        if (strcmp(unit, unit_names[i]) == 0) {\n            return i;\n        }\n    }\n    strcpy(unit_names[unit_count], unit);\n    return unit_count++;\n}\n\nint solve() {\n    for (int k = 0; k < unit_count; k++) {\n        for (int i = 0; i < unit_count; i++) {\n            for (int j = 0; j < unit_count; j++) {\n                if (powers[i][k] != INT_MIN && powers[k][j] != INT_MIN) {\n                    int new_power = powers[i][k] + powers[k][j];\n                    if (powers[i][j] == INT_MIN) {\n                        powers[i][j] = new_power;\n                    } else if (powers[i][j] != new_power) {\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < MAX_UNITS; i++) {\n        for (int j = 0; j < MAX_UNITS; j++) {\n            powers[i][j] = (i == j) ? 0 : INT_MIN;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        char unit1[20], unit2[20];\n        int power;\n        scanf(\"%s %*s %d %s\", unit1, &power, unit2);\n\n        int idx1 = get_unit_index(unit1);\n        int idx2 = get_unit_index(unit2);\n\n        if (powers[idx1][idx2] != INT_MIN && powers[idx1][idx2] != power) {\n            printf(\"Inconsistent\\n\");\n            return 0;\n        }\n        powers[idx1][idx2] = power;\n    }\n\n    printf(solve() ? \"Consistent\\n\" : \"Inconsistent\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cmath>\n\nusing namespace std;\n\nclass UnitGraph {\nprivate:\n    unordered_map<string, unordered_map<string, int>> graph;\n\npublic:\n    bool addRelation(const string& unit1, const string& unit2, int power) {\n        if (graph.count(unit1) && graph[unit1].count(unit2)) {\n            return graph[unit1][unit2] == power;\n        }\n\n        graph[unit1][unit2] = power;\n        graph[unit2][unit1] = -power;\n        return true;\n    }\n\n    bool checkConsistency() {\n        for (const auto& start : graph) {\n            unordered_map<string, int> dist;\n            if (bellmanFord(start.first, dist)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\nprivate:\n    bool bellmanFord(const string& start, unordered_map<string, int>& dist) {\n        dist[start] = 0;\n\n        for (size_t i = 0; i < graph.size(); ++i) {\n            bool updated = false;\n            for (const auto& u : graph) {\n                for (const auto& v : u.second) {\n                    if (dist.count(u.first) && \n                        (!dist.count(v.first) || \n                         dist[u.first] + v.second < dist[v.first])) {\n                        dist[v.first] = dist[u.first] + v.second;\n                        updated = true;\n                    }\n                }\n            }\n            if (!updated) break;\n        }\n\n        for (const auto& u : graph) {\n            for (const auto& v : u.second) {\n                if (dist.count(u.first) && dist.count(v.first) && \n                    dist[u.first] + v.second < dist[v.first]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n\n    UnitGraph unitGraph;\n    bool consistent = true;\n\n    for (int i = 0; i < n; ++i) {\n        string unit1, unit2, equals;\n        int power;\n        cin >> unit1 >> equals >> power >> unit2;\n\n        if (!unitGraph.addRelation(unit1, unit2, power)) {\n            consistent = false;\n            break;\n        }\n    }\n\n    if (consistent && unitGraph.checkConsistency()) {\n        cout << \"consistent\" << endl;\n    } else {\n        cout << \"inconsistent\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def check_for_contradictions(relations):\n    conversion_dict = {}\n    \n    for relation in relations:\n        parts = relation.split()\n        A, _, _, B = parts[1], parts[2], parts[3], parts[5]\n        power = int(parts[4][2:])\n        \n        if (A, B) in conversion_dict:\n            if conversion_dict[(A, B)] != power:\n                return \"Contradictory\"\n        else:\n            conversion_dict[(A, B)] = power\n            \n        if (B, A) in conversion_dict:\n            if conversion_dict[(B, A)] != -power:\n                return \"Contradictory\"\n        else:\n            conversion_dict[(B, A)] = -power\n    \n    return \"Consistent\"\n\n# Example usage\nrelations = [\n    \"1 A = 10^2 B\",\n    \"1 B = 10^-2 A\"\n]\n\nprint(check_for_contradictions(relations))",
    "timestamp": "2025-08-13 05:39:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class UnitConsistencyChecker {\n\n    public static void main(String[] args) {\n        List<String> relations = Arrays.asList(\n                \"1 A = 10^2 B\",\n                \"1 B = 10^-2 C\",\n                \"1 A = 10^4 C\",\n                \"1 A = 10^3 B\"\n        );\n        System.out.println(isConsistent(relations));\n    }\n\n    public static boolean isConsistent(List<String> relations) {\n        Map<String, Map<String, Integer>> graph = new HashMap<>();\n\n        for (String relation : relations) {\n            String[] parts = relation.split(\" \");\n            String unit1 = parts[1];\n            String unit2 = parts[4];\n            Integer power = Integer.parseInt(parts[2].substring(3));\n\n            graph.putIfAbsent(unit1, new HashMap<>());\n            graph.get(unit1).put(unit2, power);\n\n            graph.putIfAbsent(unit2, new HashMap<>());\n            graph.get(unit2).put(unit1, -power);\n        }\n\n        for (String startUnit : graph.keySet()) {\n            if (!isComponentConsistent(graph, startUnit)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isComponentConsistent(Map<String, Map<String, Integer>> graph, String startUnit) {\n        Map<String, Integer> powers = new HashMap<>();\n        Queue<String> queue = new LinkedList<>();\n        queue.add(startUnit);\n        powers.put(startUnit, 0);\n\n        while (!queue.isEmpty()) {\n            String currentUnit = queue.poll();\n            int currentPower = powers.get(currentUnit);\n\n            for (Map.Entry<String, Integer> entry : graph.get(currentUnit).entrySet()) {\n                String nextUnit = entry.getKey();\n                int nextPower = currentPower + entry.getValue();\n\n                if (!powers.containsKey(nextUnit)) {\n                    powers.put(nextUnit, nextPower);\n                    queue.add(nextUnit);\n                } else if (powers.get(nextUnit) != nextPower) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 05:40:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_UNITS 100\n#define INF 1000000\n\ntypedef struct {\n    int unitA;\n    int unitB;\n    int power;\n} Relation;\n\nint findUnitIndex(char units[][11], int *numUnits, char *unit) {\n    for (int i = 0; i < *numUnits; i++) {\n        if (strcmp(units[i], unit) == 0) {\n            return i;\n        }\n    }\n    strcpy(units[*numUnits], unit);\n    return (*numUnits)++;\n}\n\nbool checkContradictions(Relation relations[], int numRelations, int numUnits) {\n    int powerMatrix[MAX_UNITS][MAX_UNITS];\n    for (int i = 0; i < numUnits; i++) {\n        for (int j = 0; j < numUnits; j++) {\n            powerMatrix[i][j] = (i == j) ? 0 : INF;\n        }\n    }\n    \n    for (int i = 0; i < numRelations; i++) {\n        int a = relations[i].unitA;\n        int b = relations[i].unitB;\n        int p = relations[i].power;\n        powerMatrix[a][b] = p;\n        powerMatrix[b][a] = -p;\n    }\n    \n    for (int k = 0; k < numUnits; k++) {\n        for (int i = 0; i < numUnits; i++) {\n            for (int j = 0; j < numUnits; j++) {\n                if (powerMatrix[i][k] != INF && powerMatrix[k][j] != INF) {\n                    if (powerMatrix[i][j] > powerMatrix[i][k] + powerMatrix[k][j]) {\n                        powerMatrix[i][j] = powerMatrix[i][k] + powerMatrix[k][j];\n                    }\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < numUnits; i++) {\n        if (powerMatrix[i][i] < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int numRelations;\n    scanf(\"%d\", &numRelations);\n    \n    Relation relations[numRelations];\n    char units[MAX_UNITS][11];\n    int numUnits = 0;\n    \n    for (int i = 0; i < numRelations; i++) {\n        char unitA[11];\n        char unitB[11];\n        int power;\n        scanf(\" 1 %s = 10^%d %s\", unitA, &power, unitB);\n        \n        int indexA = findUnitIndex(units, &numUnits, unitA);\n        int indexB = findUnitIndex(units, &numUnits, unitB);\n        \n        relations[i].unitA = indexA;\n        relations[i].unitB = indexB;\n        relations[i].power = power;\n    }\n    \n    bool hasContradiction = checkContradictions(relations, numRelations, numUnits);\n    if (hasContradiction) {\n        printf(\"Contradictory\\n\");\n    } else {\n        printf(\"Consistent\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 05:40:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def check_unit_relations(relations):\n    graph = {}\n    \n    def add_relation(a, b, power):\n        if a not in graph:\n            graph[a] = {}\n        graph[a][b] = power\n    \n    for relation in relations:\n        parts = relation.split()\n        a, b = parts[1], parts[3]\n        power = int(parts[2][2:]) if parts[2].startswith('10^') else 0\n        \n        add_relation(a, b, power)\n        add_relation(b, a, -power)\n    \n    def dfs(node, target, visited, current_power):\n        if node == target:\n            return current_power\n        \n        visited.add(node)\n        \n        for neighbor, edge_power in graph.get(node, {}).items():\n            if neighbor not in visited:\n                result = dfs(neighbor, target, visited, current_power + edge_power)\n                if result is not None:\n                    return result\n        \n        return None\n    \n    for a in graph:\n        for b in graph:\n            if a != b:\n                visited_forward = set()\n                visited_backward = set()\n                \n                power_forward = dfs(a, b, visited_forward, 0)\n                power_backward = dfs(b, a, visited_backward, 0)\n                \n                if power_forward is not None and power_backward is not None:\n                    if power_forward + power_backward != 0:\n                        return False\n    \n    return True\n\ndef main():\n    n = int(input())\n    relations = [input() for _ in range(n)]\n    \n    result = check_unit_relations(relations)\n    print(\"consistent\" if result else \"contradiction\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:40:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    T = int(input[ptr])\n    ptr += 1\n    for _ in range(T):\n        N = int(input[ptr])\n        ptr += 1\n        adj = defaultdict(list)\n        known = {}\n        possible = True\n        \n        for __ in range(N):\n            A = input[ptr]\n            ptr += 1\n            x = int(input[ptr])\n            ptr += 1\n            B = input[ptr]\n            ptr += 1\n            \n            if (A, B) in known:\n                if known[(A, B)] != x:\n                    possible = False\n            else:\n                known[(A, B)] = x\n                adj[A].append((B, x))\n                adj[B].append((A, -x))\n        \n        if not possible:\n            print(\"No\")\n            continue\n        \n        visited = {}\n        for node in adj:\n            if node not in visited:\n                queue = deque()\n                queue.append((node, 0))\n                visited[node] = 0\n                while queue and possible:\n                    current, val = queue.popleft()\n                    for neighbor, delta in adj[current]:\n                        if neighbor in visited:\n                            if visited[neighbor] != val + delta:\n                                possible = False\n                                break\n                        else:\n                            visited[neighbor] = val + delta\n                            queue.append((neighbor, val + delta))\n                    if not possible:\n                        break\n                if not possible:\n                    break\n        \n        print(\"Yes\" if possible else \"No\")\n\nsolve()",
    "timestamp": "2025-08-13 05:40:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    unordered_map<string, pair<string, int>> parent;\n\n    pair<string, int> find(const string& x) {\n        if (parent.find(x) == parent.end()) {\n            parent[x] = {x, 0};\n        }\n        if (parent[x].first != x) {\n            auto origParent = parent[x];\n            auto result = find(origParent.first);\n            parent[x] = {result.first, origParent.second + result.second};\n        }\n        return parent[x];\n    }\n\n    bool unionUnits(const string& x, const string& y, int powerDiff) {\n        auto rootX = find(x);\n        auto rootY = find(y);\n\n        if (rootX.first == rootY.first) {\n            return (rootX.second - rootY.second == powerDiff);\n        } else {\n            parent[rootX.first] = {rootY.first, rootY.second - rootX.second + powerDiff};\n            return true;\n        }\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    UnionFind uf;\n    bool isConsistent = true;\n\n    for (int i = 0; i < n; ++i) {\n        int power;\n        string a, b, eq;\n\n        cin >> power >> a >> eq >> b;\n\n        if (isConsistent) {\n            if (!uf.unionUnits(a, b, power)) {\n                isConsistent = false;\n            }\n        }\n    }\n\n    cout << (isConsistent ? \"consistent\" : \"contradictory\") << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:26:45"
  }
]