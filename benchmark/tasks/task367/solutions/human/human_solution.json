[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <vector>\n#include <map>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nint n, vis[128], rk[128];\nmap<string, int> dict;\nvector<pair<int, int> > g[128];\n\nint of(const string& s) {\n    if (dict.count(s) == 0) dict[s] = n++;\n    return dict[s];\n}\n\nbool visit(int at, int r) {\n    if (vis[at]) return rk[at] == r;\n    vis[at] = 1;\n    rk[at] = r;\n    rep (i, g[at].size()) {\n        if (!visit(g[at][i].first, r+g[at][i].second)) return false;\n    }\n    return true;\n}\n\nint main() {\n    for (;;) {\n        int m;\n        scanf(\"%d\", &m);\n        if (m == 0) return 0;\n        n = 0;\n        dict.clear();\n        rep (i, 128) g[i].clear();\n        rep (_, m) {\n            static char a[32], b[32];\n            int x;\n            scanf(\" 1 %s = 10^%d %s\", a, &x, b);\n            const int u = of(a);\n            const int v = of(b);\n            g[u].push_back(mp(v, -x));\n            g[v].push_back(mp(u, x));\n        }\n        rep (i, n) vis[i] = 0;\n        bool ans = true;\n        rep (i, n) if (!vis[i]) {\n            if (!visit(i, 0)) ans = false;\n        }\n        puts(ans ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <string>\n\nusing namespace std;\n\npair<int, int> par[128];\n\nvoid init(int n)\n{\n\tfor (int i = 0; i < n; i++){\n\t\tpar[i] = make_pair(i, 0);\n\t}\n}\n\npair<int, int> find(int x)\n{\n\tif (par[x].first == x) return (par[x]);\n\tpair<int, int> ret = find(par[x].first);\n\treturn (par[x] = make_pair(ret.first, par[x].second + ret.second));\n}\n\nbool same(int u, int v)\n{\n\treturn (find(u).first == find(v).first);\n}\n\nvoid merge(int u, int v, int val)\n{\n\tpair<int, int> uu = find(u);\n\tpair<int, int> vv = find(v);\n\t\n\tif (uu.first == vv.first) return;\n\t\n\tpar[uu.first] = make_pair(vv.first, vv.second + val);\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\tgetchar();\n\t\t\n\t\tmap<string, int> mp;\n\t\tinit(n);\n\t\tbool ok = true;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tchar s[1024], t[1024];\n\t\t\tint val;\n\t\t\t\n\t\t\tscanf(\"1 %s = 10^%d %s\", &s, &val, &t);\n\t\t\tgetchar();\n\t\t\t\n\t\t\tstring ss = s, st = t;\n\t\t\tif (!mp.count(ss)){\n\t\t\t\tint ct = mp.size();\n\t\t\t\tmp[ss] = ct;\n\t\t\t}\n\t\t\tif (!mp.count(st)){\n\t\t\t\tint ct = mp.size();\n\t\t\t\tmp[st] = ct;\n\t\t\t}\n\t\t\t\n\t\t\tint u = mp[ss], v = mp[st];\n\t\t\tif (same(u, v)){\n\t\t\t\tif (par[u].second - par[v].second != val) ok = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmerge(u, v, val);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nconst int inf = 1<<29;\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n\nbool wf(vvi & d){\n    int n=d.size();\n    rep(k,n)rep(i,n)rep(j,n){\n        if(i==j) continue;\n        if(d[i][j]!=inf) continue;\n        if(d[i][k]==inf || d[k][j]==inf) continue;\n        d[i][j] = d[i][k]+d[k][j];\n    }\n    rep(k,n)rep(i,n)rep(j,n){\n        if(d[i][j]>=inf || d[i][k]>=inf || d[k][j]>=inf){\n            // cout << i << \" \" << j << \" \" << k << \" \" << d[i][j] << endl;\n            continue;\n        }\n        if(d[i][j] != d[i][k]+d[k][j]){\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        int c = 0;\n        map<string,int> m;\n        vvi d(n*2, vi(n*2,inf));\n        rep(i,n){\n            char u1[20],u2[20];\n            int t;\n            scanf(\" 1 %s = 10^ %d %s\",u1,&t,u2);\n            // cout << u1 << \" \" << u2 << \" \" << t << endl;\n            string u(u1),v(u2);\n            if(m.find(u) == m.end()){\n                m[u] = c++;\n            }\n            if(m.find(v) == m.end()){\n                m[v] = c++;\n            }\n            int mu=m[u];\n            int mv=m[v];\n            d[mu][mv] = t;\n            d[mv][mu] = -t;\n        }\n\n        if(wf(d)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nvector<pair<int, int> > edge[1000];\nchar str1[100];\nchar str2[100];\nint dist[1000];\n\nbool dfs(int now, int cost) {\n  if (dist[now] != 0x0f0f0f0f) {\n    return dist[now] == cost;\n  }\n  dist[now] = cost;\n  FORIT(it, edge[now]) {\n    if (!dfs(it->first, cost + it->second)) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\nREP(i, 1000) { edge[i].clear(); }\n  map<string, int> open;\n  int m = 0;\n  REP(i, n) {\n    int cost;\n    scanf(\" 1 %s = 10^ %d %s\", str1, &cost, str2);\n    if (!open.count((string)str1)) { open[(string)str1] = m++; }\n    if (!open.count((string)str2)) { open[(string)str2] = m++; }\n    int l = open[(string)str1];\n    int r = open[(string)str2];\n    edge[l].push_back(make_pair(r, -cost));\n    edge[r].push_back(make_pair(l, cost));\n  }\n  MEMSET(dist, 0x0f);\n  REP(i, m) {\n    if (dist[i] != 0x0f0f0f0f) { continue; }\n    if (dfs(i, 0)) {\n    } else {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \n\nint main(void){  \n  int N;\n  while(cin>>N){\n    if(!N) break;\n    vector<string> tani;\n    vector<int> ind;\n    bool flag = true;\n    bool first = true;\n    int tmp;\n    string tmp2;\n    int count=0;\n    int date[100];\n    string date2[100][2];\n    while(N--){\n      string tani1,tani2;\n      int index;\n      cin>>tmp;\n      cin>>tani1;\n      cin>>tmp2;\n      cin>>tmp2;\n      index = (tmp2[3]!='-')?(tmp2[3]-'0'):('0' - tmp2[4]);\n      cin>>tani2;\n      if(first){\n        tani.push_back(tani1); tani.push_back(tani2);\n        ind.push_back(0); ind.push_back(index);\n        first = false;\n        continue;\n      }\n      vector<string>::iterator it1 = find(tani.begin(),tani.end(),tani1)\n        , it2 = find(tani.begin(),tani.end(),tani2);\n      bool f1 = (it1 != tani.end());\n      bool f2 = (it2 != tani.end());\n      int ind1 = ind[distance(tani.begin(),it1)];\n      int ind2 = ind[distance(tani.begin(),it2)];\n      if(f1){\n        if(f2){\n          if(ind2 - ind1 != index){\n            flag = false;\n          }\n        }else{\n          ind.push_back(ind1 + index);\n          tani.push_back(tani2);\n        }\n      }else{\n        if(f2){\n          ind.push_back(ind2 - index);\n          tani.push_back(tani1);\n        }else{\n          date[count] = index;\n          date2[count][0] = tani1;\n          date2[count][1] = tani2;\n          count++;\n        }\n      }\n    }\n    REP(i,count){\n      vector<string>::iterator \n        it1 = find(tani.begin(),tani.end(),date2[i][0]), \n        it2 = find(tani.begin(),tani.end(),date2[i][1]);\n      bool f1 = (it1 != tani.end());\n      bool f2 = (it2 != tani.end());\n      int ind1 = ind[distance(tani.begin(),it1)];\n      int ind2 = ind[distance(tani.begin(),it2)];\n      if(f1&&f2&&ind2-ind1!=date[i])\n        flag = false;\n      else if(f1&&!f2){\n        ind.push_back(ind1 + date[i]);\n        tani.push_back(date2[i][1]);\n      }else if(!f1&&f2){\n        ind.push_back(ind2 - date[i]);\n        tani.push_back(date2[i][0]);\n      }\n    }\n    if(flag) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\n\n\nconst int INF = 100000000;\nconst long long INFL = 1000000000000LL;\n\nint n;\nmap<string, int> stoi;\nbool visited[200][200];\nlong long cost[200];\nint G[200][200];\n\nint conv(string& str){\n  int res = 1;\n  for(int i=0;i<str.size();i++){\n    if(str[i] == '^'){\n      if(str[i+1] == '-'){\n\tres *= -1;\n\ti++;\n      }\n      res *= atoi(str.substr(i+1).c_str());\n    }\n  }\n  return res;\n}\n\nbool dfs(int p, long long cos){\n  if(cost[p] == INFL) cost[p] = cos;\n  if(cost[p] != cos) return false;\n  for(int i=0;i<n;i++){\n    if(i == p) continue;\n    if(visited[p][i]) continue;\n    if(G[p][i] == INF) continue;\n    visited[p][i] = visited[i][p] = true;\n    if(!dfs(i, cos + G[p][i])) return false;\n  }\n  return true;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(G[0], G[200], INF);\n    int size = 0;\n    bool ans = true;\n    for(int i=0;i<n;i++){\n      string a, b;\n      int in;\n      cin >> a;\n      cin >> a;\n      cin >> b;\n      cin >> b;\n      in = conv(b);\n      cin >> b;\n      int c, d;\n      if(stoi.find(a) == stoi.end()){\n\tstoi[a] = size++;\n      }\n      if(stoi.find(b) == stoi.end()){\n\tstoi[b] = size++;\n      }\n      if(c == d && in != 0) ans = false;\n      c = stoi[a];\n      d = stoi[b];\n      G[c][d] = in;\n      G[d][c] = -in;\n    }\n    if(ans){\n      for(int i=0;i<n;i++){\n\tfill(visited[0], visited[200], false);\n\tfill(cost, cost+200, INFL);\n\tif(!dfs(i, 0LL)){\n\t  ans = false;\n\t  break;\n\t}\n      }\n    }\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n, Abel SUM_UNITY) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n, Abel SUM_UNITY) {\n        par.resize(n+1); rank.resize(n+1); diff_weight.resize(n+1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint sisu(string ju){\n    bool minus=0;\n    int i=3;\n    int w=0;\n    if(ju[3]=='-'){\n        minus=1;\n        i++;\n    }\n    for(;i<(int)ju.length(); i++){\n        w=10*w+(int)(ju[i]-'0');\n    }\n    if(minus){\n        w= -w;\n    }\n    return w;\n}\n\nint main(){\n    int N;\n    int i,j;\n    int a, b, w;\n    cin >> N;\n    while(N>0){\n        string one[N], tan[N], eq[N], ju[N], tantan[N];\n        set<string> st;\n        set<string>::iterator ite;\n        for(i=0; i<N; i++){\n            cin >> one[i] >> tan[i] >> eq[i] >> ju[i] >> tantan[i];\n            st.insert(tan[i]);\n            st.insert(tantan[i]);\n        }\n        vector<string> jisho((int)st.size());\n        UnionFind<int> uf((int)st.size(),0);\n        ite=st.begin();\n        for(i=0; i<(int)st.size(); i++){\n            jisho[i]= *ite;\n            ++ite;\n        }\n        for(i=0; i<N; i++){\n            a=lower_bound(jisho.begin(),jisho.end(),tan[i])-jisho.begin();\n            b=lower_bound(jisho.begin(),jisho.end(),tantan[i])-jisho.begin();\n            w=sisu(ju[i]);\n            if(uf.issame(a,b)){\n                if(uf.diff(a,b)!=w){\n                    break;\n                }\n            }else{\n                uf.merge(a,b,w);\n            }\n        }\n        if(i==N){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n        cin >> N;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<set>\n#include<cstdio>\n#include<cassert>\n#define F first\n#define S second\n#define inf (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nstruct P\n{\n  string unit;\n  int mpower;\n  int upower;\n  P(string unit=\"$\",int upower=-inf,int mpower=-inf):unit(unit),upower(upower),mpower(mpower){}\n};\nvector<vector<P> > G(110);\nmap<string,int> exist;\n\nint toPower(string s)\n{\n  if(s == \"1\")return 0;\n  int pos = 0;\n  rep(i,s.size())\n    {\n      if(s[i] == '^')\n\t{\n\t  pos = i+1;\n\t  break;\n\t}\n    }\n  return (atoi)(s.substr(pos,s.size()-pos).c_str());\n}\n\nbool used[110];\nint isok;//-1 -> No, 0 => Not yet, 1 -> Ok\n\nvoid dfs(string now,string target,int power,int target_power)\n{\n  if(isok != 0)return;\n  if(now == target)\n    {\n      isok = (power == target_power?1:-1);\n      return;\n    }\n  int index = exist[now];\n  if(used[index])return;\n  used[index] = true;\n\n  rep(i,G[index].size())\n    {\n      P p = G[index][i];\n      int next_index = exist[p.unit];\n      if(used[next_index])continue;\n      dfs(p.unit,target,power+(p.mpower==0?p.upower:-p.mpower),target_power );\n    }\n}\n\nbool check(string u1,string u2,int power)\n{\n  rep(i,110)used[i] = false;\n  isok = 0;\n\n  dfs(u1,u2,0,power);\n  return isok == 1;\n}\n\nbool reachable;\n\nvoid move(int now,int target)\n{\n  if(now == target)\n    {\n      reachable = true;\n      return;\n    }\n\n  if(used[now])return;\n  used[now] = true;\n  rep(i,G[now].size())\n    {\n      assert(exist.count(G[now][i].unit));\n      move(exist[G[now][i].unit],target);\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N , N)\n    {\n      rep(i,N)G[i].clear();\n      int index = 0;\n      exist.clear();\n      bool result = true;\n      rep(i,N)\n\t{\n\t  string v1,unit1,v2,unit2,eq;\n\t  cin >> v1 >> unit1 >> eq >> v2 >> unit2;\n\t  //cout << toPower(v1) << \" \" << unit1 << \" = \"<< toPower(v2) << \" \" << unit2 << endl;\n\t  if(exist.count(unit1) && exist.count(unit2))\n\t    {\n\t      rep(i,N)used[i] = false;\n\t      reachable = false;\n\t      move(exist[unit1],exist[unit2]);\n\t      if(reachable)\n\t\t{\n\t\t  int p1 = toPower(v1);\n\t\t  int p2 = toPower(v2);\n\t\t  result = check(unit1,unit2,p2);\n\t\t  //cout << \"result = \" << result << endl;\n\t\t}\n\t      continue;\n\t    }\n\n\t  //cout << \"not exists\" << endl;\n\t  if(!exist.count(unit1))exist[unit1] = index++;\n\t  if(!exist.count(unit2))exist[unit2] = index++;\n\t  int index1 = exist[unit1];\n\t  int index2 = exist[unit2];\n\t  G[index1].push_back(P(unit2,toPower(v2),toPower(v1)));\n\t  G[index2].push_back(P(unit1,toPower(v1),toPower(v2)));\n\t}\n      cout << (result?\"Yes\":\"No\") << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<map>\n#include<string>\nusing namespace std;\n\n#define INF 100000\n\nint main()\n{\t\n\tint n;\n\tstring temp;\n\tint a;\n\tint cost[201][201],minicost[201];\n\twhile(cin>>n && n!=0){\n\n\t\tfor(int i=0;i<=200;i++){\n\t\t\tfor(int j=0;j<=200;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t\tminicost[i]=INF;\n\t\t}\n\n\n\t\tmap<string,int> Idx;\n\t\tint num=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a;//1\n\t\t\tstring s,t,p; cin>>s>>temp>>p>>t;\n\t\t\tif(!Idx.count(s)){Idx[s]=num++;}\n\t\t\tif(!Idx.count(t)){Idx[t]=num++;}\n\t\t\tstd::istringstream is(p);\n\t\t\tint k;\n\t\t\tchar taa;\n\t\t\tis>>a>>taa>>k;\n\t\t\tcost[Idx[s]][Idx[t]]=k;\n\t\t\tcost[Idx[t]][Idx[s]]=-k;\n\t\t}\n\n\t\tint count=0;\n\t\twhile(true){\n\t\t\tbool update=false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(cost[i][j]<INF){\n\t\t\t\t\tcout<<minicost[j]<<\" \"<<minicost[i]+cost[i][j]<<endl;\n\t\t\t\t\t\tif(minicost[j]>minicost[i]+cost[i][j]){\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\tminicost[j]=minicost[i]+cost[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update){cout<<\"Yes\"<<endl;break;}\n\t\t\tcount++;\n\t\t\tif(count>n+1){cout<<\"No\"<<endl;break;}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<map>\nusing namespace std;\nchar in[30];\nint UF[300];\nint w[300];\npair<int,int> FIND(int a){\n\tif(UF[a]<0)return make_pair(a,0);\n\tpair<int,int>ret=FIND(UF[a]);\n\tret.second+=w[a];\n\treturn ret;\n}\nbool ok=true;\nvoid UNION(int a,int b,int c){\n\tpair<int,int>A=FIND(a);\n\tpair<int,int>B=FIND(b);\n\tint d=A.first;\n\tint e=B.first;\n\tint f=A.second+c-B.second;\n\tif(d==e){\n\t\tif(B.second-c!=A.second)ok=false;\n\t\treturn;\n\t}\n\tUF[d]+=UF[d];\n\tUF[e]=d;\n\tw[e]=f;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<string,int>m;\n\t\tint sz=0;ok=true;\n\t\tfor(int i=0;i<300;i++){\n\t\t\tUF[i]=-1;w[i]=0;\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s%s\",in,in);\n\t\t\tstring A=in;\n\t\t\tint C=0;\n\t\t\tscanf(\"%s%s\",in,in);\n\t\t\tif(in[1]==0)C=0;\n\t\t\telse{\n\t\t\t\tsscanf(in,\"%d^%d\",&C,&C);\n\t\t\t}\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring B=in;\n\t\t\tint p,q;\n\t\t\tif(!m.count(A)){\n\t\t\t\tp=sz;\n\t\t\t\tm[A]=sz++;\n\t\t\t}else p=m[A];\n\t\t\tif(!m.count(B)){\n\t\t\t\tq=sz;\n\t\t\t\tm[B]=sz++;\n\t\t\t}else q=m[B];\n\t\t\tUNION(p,q,C);\n\t\t//\tif(!ok)printf(\"%d\\n\",i);\n\t\t}\n\t\tif(ok)printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 100*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n\n    int size() const { return id; }\n};\n\nbool relax(const vector<vector<pair<int,int> > > &graph, vector<int> &dist, int N) {\n    bool updated = false;\n    for(int i = 0; i < N; ++i) {\n        const vector<pair<int,int> > &edges = graph[i];\n        for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n            const int nc = dist[i] + it->second;\n            if(dist[it->first] > nc) {\n                dist[it->first] = nc;\n                updated = true;\n            }\n        }\n    }\n    return updated;\n}\n\nvector<vector<pair<int,int> > > v(200);\nvector<int> dist(200);\nvector<unsigned char> visited(200);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < N; ++i) {\n            v[i].clear();\n            dist[i] = INF;\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            for(string::iterator it = line.begin(); it != line.end(); ++it) {\n                if(*it == '=' || *it == '^') *it = ' ';\n            }\n            istringstream is(line);\n            string unit_left, unit_right;\n            int ord;\n            int tmp;\n            is >> tmp >> unit_left >> tmp >> ord >> unit_right;\n            //sscanf(line.c_str(), \"%*d %s = %*d^%d %s \", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        const int M = dict.size();\n        // テ」ツ?敕」ツつ古」ツ?榲」ツつ古」ツ?ョテゥツ?」テァツオツ静ヲツ按静・ツ按?」ツ?ォテ」ツ?、テ」ツ?催ッツシツ?テ」ツδ偲」ツδシテ」ツδ嘉」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ィテ」ツ?凖」ツつ凝ッツシツ?\n        fill(visited.begin(), visited.end(), 0);\n        queue<int> q;\n        for(int i = 0; i < M; ++i) {\n            if(!visited[i]) {\n                dist[i] = 0;\n                visited[i] = 1;\n                q.push(i);\n                while(!q.empty()) {\n                    int cur = q.front();\n                    q.pop();\n                    const vector<pair<int,int> > &edges = v[cur];\n                    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                        if(!visited[it->first]) {\n                            visited[it->first] = 1;\n                            q.push(it->first);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Bellman-ford\n        for(int phase = 0; phase < M; ++phase) {\n            if(!relax(v, dist, M)) break;\n        }\n        bool ok = !relax(v, dist, M);\n        if(ok) {\n            for(int i = 0; i < M; ++i) {\n                const vector<pair<int,int> > &edges = v[i];\n                for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                    if(dist[i] + it->second != dist[it->first]) {\n                        ok = false;\n                        goto end;\n                    }\n                }\n            }\n        }\nend:\n        if(!ok) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#define P pair<string,int>\n#define PP pair<int,int>\n#define DEBUG false\nusing namespace std;\n\nint n;\nvector<PP> rl[110]; // 単位間の関係\n\nmap<string,int> units; // units[ a ] でaの配列番号が分かる\nmap<string,int>::iterator it;\nset<int> st; // これまでに通ったノード\nset<int> en; // ループ上に存在するノード\n\nstring tab(int n){\n  string r;  for( int j=0;j<n;j++ ) r+=\"  \";\n  return r;\n}\n\n/* 単位系が誤っているとfalseを返す */\nbool dfs(int i, int sum, int initP,int depth){\n  if( DEBUG ){\n    cout << tab(depth) << \" i=\" << i << \" sum=\" << sum << \" P=\"<< initP\n\t << \" size=\" << st.size() <<\" [\";\n    set<int>::iterator itr = st.begin();\n    while( itr!=st.end() ){\n      cout << \" \" << *itr ; itr++;\n    }\n    cout << \" ]\" << endl;\n  }\n\n  if( i==initP ){\n    if( sum==0 ){\n      set<int>::iterator itr = st.begin();\n      while( itr!=st.end() ){\n\ten.insert( *itr ); itr++;\n      }\n      return true;\n    }\n    return false;\n  }\n  // else if(sum==0) return false とはならない\n\n  if( rl[i].size()<=1 ) return true; // ループになっていない\n  depth++;\n  for( int j=0;j<(int)rl[i].size();j++ ){\n    //    if( rl[i][j].second>0 ) continue; +-+- =0の時を判定できない\n    if( st.find(rl[i][j].first)!=st.end() ){\n      if(DEBUG) cout << tab(depth) << \" * \" << rl[i][j].first << endl;\n      continue; // 既に通ったノード\n    }\n\n    st.insert( rl[i][j].first );\n    int nS = sum + rl[i][j].second;\n    if( dfs( rl[i][j].first,nS,initP,depth)==false )\n      return false;\n    st.erase( rl[i][j].first );\n  }\n  return true;\n}\n\n\nbool check(){ /* 誤った規則があればfalse */\n  en.clear();\n  for( int i=0;i<n;i++ ){\n    if( rl[i].size()<=1 ) continue;\n\n    for( int j=0;j<(int)rl[i].size();j++ ){\n      if( rl[i][j].second<=0 ) continue;\n      if( en.find( rl[i][j].first )!=en.end() )\n\tcontinue;\n\n      st.clear();\n      st.insert( rl[i][j].first );\n      if( dfs(rl[i][j].first,rl[i][j].second,i,0)==false )\n\treturn false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    units.clear();\n    for( int i=0;i<n;i++ )      rl[i].clear();\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() )\n\tunits.insert( P(a,(int)units.size()) );\n      if( (it=units.find( b ))==units.end() )\n\tunits.insert( P(b,(int)units.size()) );\n\n      int an=units[a], bn=units[b];\n      rl[ an ].push_back( PP(bn,x) );  rl[ bn ].push_back( PP(an,-x) );\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define\tmp\t\tmake_pair\n#define\tpb\t\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=1<<29;\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint unum=0;\n\t\tpair<pii,int> edge[100];\n\t\tmap<string,int> name;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint pw;\n\t\t\tchar u1[17],u2[17];\n\t\t\tscanf(\"%*d %s %*c %*d%*c%d %s\",u1,&pw,u2);\n\n\t\t\tint id1,id2;\n\t\t\tif(name.count(u1)==0)\tname[u1]=unum++;\n\t\t\tid1=name[u1];\n\t\t\tif(name.count(u2)==0)\tname[u2]=unum++;\n\t\t\tid2=name[u2];\n\n\t\t\tedge[i]=mp(mp(id1,id2),pw);\n\t\t}\n\n\t\tbool ok=true;\n\t\tstatic int wf[200][200];\n\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++)\twf[i][j]=(i==j?0:inf);\n\t\tfor(int k=0;k<n;k++){\n\t\t\tint from=edge[k].first.first,to=edge[k].first.second,dis=edge[k].second;\n\t\t\tif(wf[from][to]==inf){\n\t\t\t\twf[from][to]=dis;\n\t\t\t\twf[to][from]=-dis;\n\t\t\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++){\n\t\t\t\t\tif(wf[i][from]==inf || wf[to][j]==inf)\tcontinue;\n\t\t\t\t\twf[i][j]=min(wf[i][j],wf[i][from]+dis+wf[to][j]);\n\t\t\t\t\twf[j][i]=-wf[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(wf[from][to]!=dis){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <string>\n\nusing namespace std;\n\npair<int, int> par[256];\n\nvoid init(int n)\n{\n\tfor (int i = 0; i < n; i++){\n\t\tpar[i] = make_pair(i, 0);\n\t}\n}\n\npair<int, int> find(int x)\n{\n\tif (par[x].first == x) return (par[x]);\n\tpair<int, int> ret = find(par[x].first);\n\treturn (par[x] = make_pair(ret.first, par[x].second + ret.second));\n}\n\nbool same(int u, int v)\n{\n\treturn (find(u).first == find(v).first);\n}\n\nvoid merge(int u, int v, int val)\n{\n\tpair<int, int> uu = find(u);\n\tpair<int, int> vv = find(v);\n\t\n\tif (uu.first == vv.first) return;\n\t\n\t// 1 u = 10^val v\n\tpar[uu.first] = make_pair(vv.first, vv.second + val - uu.second);\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\tgetchar();\n\t\t\n\t\tmap<string, int> mp;\n\t\tinit(256);\n\t\tbool ok = true;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tchar s[1024], t[1024];\n\t\t\tint val;\n\t\t\t\n\t\t\tscanf(\"1 %s = 10^%d %s\", s, &val, t);\n\t\t\tgetchar();\n\t\t\t\n\t\t\tstring ss = s, st = t;\n\t\t\tif (!mp.count(ss)){\n\t\t\t\tint ct = mp.size();\n\t\t\t\tmp[ss] = ct;\n\t\t\t}\n\t\t\tif (!mp.count(st)){\n\t\t\t\tint ct = mp.size();\n\t\t\t\tmp[st] = ct;\n\t\t\t}\n\t\t\t\n\t\t\tint u = mp[ss], v = mp[st];\n\t\t\tif (same(u, v)){\n\t\t\t\tif (par[u].second - par[v].second != val) ok = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmerge(u, v, val);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_UN = MAX_N * 2;\n\nconst int INF = 1 << 28;\n\n/* typedef */\n\ntypedef map<string,int> msi;\n\n/* global variables */\n\nint n, un;\nmsi umap;\nint dp[MAX_N][MAX_N];\n\n/* subroutines */\n\nint unit2id(string unit) {\n  msi::iterator mit = umap.find(unit);\n  if (mit == umap.end()) {\n    umap[unit] = un;\n    return un++;\n  }\n  return mit->second;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    un = 0;\n    umap.clear();\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) dp[i][j] = INF;\n      dp[i][i] = 0;\n    }\n\n    for (int i = 0; i < n; i++) {\n      string dmy0, ua, dmy1, exp, ub;\n      cin >> dmy0 >> ua >> dmy1 >> exp >> ub;\n\n      int aid = unit2id(ua);\n      int bid = unit2id(ub);\n\n      int sign = 1;\n      int e = 0;\n      int pos = 3;\n      if (exp[pos] == '-') {\n\tsign = -1;\n\tpos++;\n      }\n      while (pos < exp.length())\n\te = (10 * e) + (exp[pos++] - '0');\n      e *= sign;\n\n      dp[aid][bid] = e;\n      dp[bid][aid] = -e;\n      //printf(\"aid=%d,bid=%d,e=%d\\n\", aid, bid, e);\n    }\n\n    bool ok = true;\n    for (int k = 0; ok && k < un; k++)\n      for (int i = 0; ok && i < un; i++)\n\tfor (int j = 0; ok && j < un; j++) {\n\t  if (dp[i][k] < INF && dp[k][j] < INF) {\n\t    int dij = dp[i][k] + dp[k][j];\n\t    if (dp[i][j] >= INF) {\n\t      dp[i][j] = dij;\n\t      dp[j][i] = -dij;\n\t    }\n\t    else if (dp[i][j] != dij) {\n\t      ok = false;\n\t      //printf(\"i,j,k=%d,%d,%d: %d,%d,%d\\n\",\n\t      //i, j, k, dp[i][j], dp[i][k], dp[k][j]);\n\t    }\n\t  }\n\t}\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\ntypedef pair<int, int> P;\n\nint d[201][201];\n\nconst int INF = 1<<29;\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\trep(i, 101) rep(j, 101) d[i][j] = INF;\n\t\tmap<string, int> num;\n\t\tint idx = 0;\n\t\tbool ans = true;\n\t\trep(i, n){\n\t\t\tstring a, b;\n\t\t\tstring c;\n\t\t\tcin >> c >> a >> c >> c >> b;\n\t\t\tif(!num[a]) num[a] = ++idx;\n\t\t\tif(!num[b]) num[b] = ++idx;\n\t\t\tint x = atoi(c.substr(3).c_str());\n\t\t\t// a = b+x\n\t\t\tint l = num[a], r = num[b];\n\t\t\trep(k, 2){\n\t\t\t\tif(d[l][r] == INF){\n\t\t\t\t\td[l][r] = x;\n\t\t\t\t}else{\n\t\t\t\t\tif(d[l][r] != x) ans = false;\n\t\t\t\t}\n\t\t\t\tswap(l, r);\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tfor(int j = 1; j <= idx; j++){\n\t\t\t\tfor(int k = 1; k <= idx; k++){\n\t\t\t\t\tif(d[k][j] == INF) continue;\n\t\t\t\t\tfor(int l = 1; l <= idx; l++){\n\t\t\t\t\t\tif(d[j][l] == INF) continue;\n\t\t\t\t\t\tif(d[k][l] == INF) continue;\n\t\t\t\t\t\tif(d[k][l] != d[k][j]+d[j][l]){\n\t\t\t\t\t\t\tans = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ans?\"Yes\":\"No\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\ntypedef pair<int, int> P;\n\nint d[201][201];\n\nconst int INF = 1<<29;\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\trep(i, 101) rep(j, 101) d[i][j] = INF;\n\t\tmap<string, int> num;\n\t\tint idx = 0;\n\t\tbool ans = true;\n\t\trep(i, n){\n\t\t\tstring a, b;\n\t\t\tstring c;\n\t\t\tcin >> c >> a >> c >> c >> b;\n\t\t\tif(!num[a]) num[a] = ++idx;\n\t\t\tif(!num[b]) num[b] = ++idx;\n\t\t\tint x = atoi(c.substr(3).c_str());\n\t\t\t// a = b+x\n\t\t\tint l = num[a], r = num[b];\n\t\t\trep(k, 2){\n\t\t\t\tif(d[l][r] == INF){\n\t\t\t\t\td[l][r] = x;\n\t\t\t\t}else{\n\t\t\t\t\tif(d[l][r] != x) ans = false;\n\t\t\t\t}\n\t\t\t\tswap(l, r);\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tfor(int j = 1; j <= idx; j++){\n\t\t\t\tfor(int k = 1; k <= idx; k++){\n\t\t\t\t\tif(d[k][j] == INF) continue;\n\t\t\t\t\tfor(int l = 1; l <= idx; l++){\n\t\t\t\t\t\tif(d[j][l] == INF) continue;\n\t\t\t\t\t\td[k][l] = min(d[k][l], d[k][j]+d[j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ans?\"Yes\":\"No\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 250\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,int> m;\nint n,x,s2,num,s;\nbool ans,used[N];\nvector<P> e[N];\nstring s1,s3;\n\nvoid dfs(int x,int y,int sum){\n  if(used[x])return;\n  used[x]=true;\n  if(x==y){\n    s=sum;\n    return;\n  }\n  for(int i=0;i<e[x].size();i++)\n    dfs(e[x][i].first,y,sum+e[x][i].second);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    num=0;\n    ans=true;\n    for(int i=0;i<n;i++){\n      cin>>s3>>s1>>s3;\n      scanf(\" 10^%d\",&s2); cin>>s3;\n      if(m.count(s1)&&m.count(s3)){\n\ts=(1e9);\n\tmemset(used,0,sizeof(used));\n\tdfs(m[s1],m[s3],0);\n\tif(s!=(1e9)&&(s!=s2&&s!=-s2))ans=false;\n      }\n      if(!m.count(s1))m[s1]=num++;\n      if(!m.count(s3))m[s3]=num++;\n      e[m[s1]].push_back(P(m[s3],s2));\n      e[m[s3]].push_back(P(m[s1],-s2));\n    }\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    for(int i=0;i<N;i++)e[i].clear();\n    m.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<string>v; int n, a[1000], b[1000], c[1000]; string s1[1000], s2[1000], t[1000];\nvector<int>u[1000]; int group[1000], dist[1000]; bool OK = true;\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\n\nvoid merge(int a, int b, int c) {\n\tif (group[a] == group[b]) { if (dist[a] - dist[b] != c)OK = false; }\n\tint sa = (dist[a] - dist[b]) - c;\n\tfor (int i : u[group[b]])dist[i] += sa;\n\tfor (int i : u[group[b]])u[group[a]].push_back(i); int w = group[b];\n\tfor (int i : u[w])group[i] = group[a];\n\tu[group[b]].clear();\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; v.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring a1, a2; cin >> a1 >> s1[i] >> a2 >> t[i] >> s2[i];\n\t\t\tv.push_back(s1[i]); v.push_back(s2[i]);\n\t\t}\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); OK = true;\n\t\tfor (int i = 0; i < n; i++) { u[i].clear(); u[i].push_back(i); group[i] = i; a[i] = s(s1[i]); b[i] = s(s2[i]); c[i] = stoi(t[i].substr(3, t[i].size() - 3)); }\n\t\tfor (int i = 0; i < n; i++) { merge(a[i], b[i], c[i]); }\n\t\tif (OK == true)cout << \"Yes\" << endl; else cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#define P pair<string,int>\n#define N 110\nusing namespace std;\n\nint n;\nint d[N][N];\n\nmap<string,int> units; // units[ a ] でaの配列番号が分かる\n\nbool check(){ /* 誤った規則があればfalse */\n  int len = units.size();\n\n  for( int k=0;k<len;k++ )\n    for( int i=0;i<len;i++ )\n      for( int j=0;j<len;j++ )\n\td[i][j] = min( d[i][j],d[i][k]+d[k][j] );\n\n  for( int i=0;i<len;i++ )\n      if( d[i][i]!=0 )\n\treturn false;\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    for( int i=0;i<N;i++ )\n      for( int j=0;j<N;j++ )\n\td[i][j]=1000;\n\n    units.clear();\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( units.find( a )==units.end() )\n\tunits.insert( P(a,(int)units.size()) );\n      if( units.find( b )==units.end() )\n\tunits.insert( P(b,(int)units.size()) );\n\n      int an=units[a], bn=units[b];\n      d[an][bn]=x; d[bn][an]=-x;\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<string>v; int n, a[100], b[100], c[100]; string s1[100], s2[100], t[100];\nvector<int>u[100]; int group[100], dist[100]; bool OK = true;\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\n\nvoid merge(int a, int b, int c) {\n\tif (group[a] == group[b]) { if (dist[a] - dist[b] != c)OK = false; }\n\tint sa = (dist[a] - dist[b]) - c;\n\tfor (int i : u[group[b]])dist[i] += sa;\n\tfor (int i : u[group[b]])u[group[a]].push_back(i); int w = group[b];\n\tfor (int i : u[w])group[i] = group[a];\n\tu[group[b]].clear();\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; v.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring a1, a2; cin >> a1 >> s1[i] >> a2 >> t[i] >> s2[i];\n\t\t\tv.push_back(s1[i]); v.push_back(s2[i]);\n\t\t}\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); OK = true;\n\t\tfor (int i = 0; i < n; i++) { u[i].clear(); u[i].push_back(i); group[i] = i; a[i] = s(s1[i]); b[i] = s(s2[i]); c[i] = stoi(t[i].substr(3, t[i].size() - 3)); }\n\t\tfor (int i = 0; i < n; i++) { merge(a[i], b[i], c[i]); }\n\t\tif (OK == true)cout << \"Yes\" << endl; else cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef string key_t;\n\nchar b1[99],b2[99];\nvoid main2(int n){\n\tmap<key_t,vector<pair<key_t,long long>>>m;\n\tfor(;n;n--){\n\t\tint d;\n\t\tscanf(\" 1 %s = 10^%d %s\",b1,&d,b2);\n\t\tstring s1=b1,s2=b2;\n\t\tm[s1].emplace_back(s2,d);\n\t\tm[s2].emplace_back(s1,-d);\n\t}\n\tfor(;!m.empty();){\n\t\tauto s=m.begin()->first;\n\t\tvector<pair<key_t,long long> >st={{s,0}};\n\t\tmap<key_t,long long>memo={{s,0}};\n\t\tfor(;!st.empty();){\n\t\t\tauto p=*st.rbegin();st.pop_back();\n\t\t\tauto cur=p.first;long long d=p.second;\n\t\t\tmemo[cur]=d;\n\t\t\tfor(auto &e:m[cur]){\n\t\t\t\tif(memo.find(e.first)==memo.end()){\n\t\t\t\t\tst.emplace_back(e.first,d+e.second);\n\t\t\t\t}else if(memo[e.first]!=d+e.second){\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto &e:memo)m.erase(m.find(e.first));\n\t}\n\tputs(\"Yes\");\n}\nint main(){int n;for(;~scanf(\"%d\",&n)&&n;)main2(n);}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#define P pair<string,int>\n#define PP pair<int,int>\nusing namespace std;\n\nint n;\nvector<PP> rl[110]; // 単位間の関係\n\nmap<string,int> units; // units[ a ] でaの配列番号が分かる\nmap<string,int>::iterator it;\nset<int> st; // これまでに通ったノード\n\nstring tab(int n){\n  string r;  for( int j=0;j<n;j++ ) r+=\"  \";\n  return r;\n}\n\n/* 単位系が誤っているとfalseを返す */\nbool dfs(int i, int sum, int initP,int depth){\n\n  /*\n  cout << tab(depth) << \" i=\" << i << \" sum=\" << sum << \" P=\"<< initP\n       << \" size=\" << st.size() <<\" [\";\n  set<int>::iterator itr = st.begin();\n  while( itr!=st.end() ){\n    cout << \" \" << *itr ; itr++;\n  }\n  cout << \" ]\" << endl;\n  */\n\n  if( i==initP ){\n    if( sum==0 ) return true;\n    else return false;\n  }\n  // else if(sum==0) return false とはならない\n\n  if( rl[i].size()<=1 )    return true;\n  depth++;\n  for( int j=0;j<(int)rl[i].size();j++ ){\n    //    if( rl[i][j].second>0 ) continue; +-+- =0の時を判定できない\n    if( st.find(rl[i][j].first)!=st.end() ){\n      //      cout << tab(depth) << \" * \" << rl[i][j].first << endl;\n      continue; // 既に通ったノード\n    }\n\n    st.insert( rl[i][j].first );\n    int nS = sum + rl[i][j].second;\n    if( dfs( rl[i][j].first,nS,initP,depth)==false )\n      return false;\n    st.erase( rl[i][j].first );\n  }\n  return true;\n}\n\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int i=0;i<n;i++ ){\n    if( rl[i].size()<=1 ) continue;\n\n    for( int j=0;j<(int)rl[i].size();j++ ){\n      if( rl[i][j].first<0 ) continue;\n      st.clear();\n      st.insert( rl[i][j].first );\n      if( dfs(rl[i][j].first,rl[i][j].second,i,0)==false )\n\treturn false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    units.clear();\n    for( int i=0;i<n;i++ )      rl[i].clear();\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() )\n\tunits.insert( P(a,(int)units.size()) );\n      if( (it=units.find( b ))==units.end() )\n\tunits.insert( P(b,(int)units.size()) );\n\n      int an=units[a], bn=units[b];\n      rl[ an ].push_back( PP(bn,x) );  rl[ bn ].push_back( PP(an,-x) );\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<string>v; int n, a[100], b[100], c[100]; string s1[100], s2[100], t[100];\nvector<int>u[100]; int group[100], dist[100]; bool OK = true;\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\n\nvoid merge(int a, int b, int c) {\n\tif (group[a] == group[b]) { if (dist[a] - dist[b] != c)OK = false; }\n\tint sa = (dist[a] - dist[b]) - c;\n\tfor (int i : u[group[b]])dist[i] += sa;\n\tfor (int i : u[group[b]])u[group[a]].push_back(i); int w = group[b];\n\tfor (int i : u[w])group[i] = group[a];\n\tu[group[b]].clear();\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; v.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring a1, a2; cin >> a1 >> s1[i] >> a2 >> t[i] >> s2[i];\n\t\t\tv.push_back(s1[i]); v.push_back(s2[i]);\n\t\t}\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); OK = true;\n\t\tfor (int i = 0; i < n; i++) { u[i].clear(); u[i].push_back(i); group[i] = i; a[i] = s(s1[i]); b[i] = s(s2[i]); c[i] = stoi(t[i].substr(3, t[i].size() - 3)); }\n\t\tfor (int i = 0; i < n; i++) { merge(a[i], b[i], c[i]); }\n\t\tif (OK == true)cout << \"Yes\" << endl; else cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//11\n#include<cstdio>\n#include<vector>\n#include<map>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct NM{\n  map<string,int> m;\n  vector<string> v;\n  void rec(string s){\n    if(!m.count(s)){\n      m[s]=v.size();\n      v.push_back(s);\n    }\n  }\n};\n\nint main(){\n  for(int n;scanf(\"%d\",&n),n;){\n    NM nm;\n    int d[200][200];\n    fill(d[0],d[200],1<<29);\n    for(int i=0;i<200;i++){\n      d[i][i]=0;\n    }\n    int s[100],t[100],c[100];\n    for(int i=0;i<n;i++){\n      char a[17],b[17];\n      int cs;\n      scanf(\" 1 %s = 10^%d %s\",a,&cs,b);\n      nm.rec(a);\n      nm.rec(b);\n      s[i]=nm.m[a];\n      t[i]=nm.m[b];\n      c[i]=cs;\n      d[s[i]][t[i]]=cs;\n      d[t[i]][s[i]]=-cs;\n    }\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tfor(int k=0;k<200;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    int i;\n    for(i=0;i<n;i++){\n      if(d[s[i]][t[i]]!=c[i])break;\n    }\n    puts((i==n)?\"Yes\":\"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconstexpr int MAX = 514;\nconstexpr int INF = (1 << 25);\n\nstruct Edge {\n    int to, cost;\n    Edge() {}\n    Edge(int to, int cost) :\n        to{to}, cost{cost} {}\n};\n\nvector<Edge> G[MAX];\nint dist[MAX];\n\nbool dfs(int v, int p, int d)\n{\n    if (dist[v] != INF) {\n        return (dist[v] != d);\n    }\n    \n    dist[v] = d;\n    bool res = 0;\n    for (const auto& g : G[v]) {\n        if (g.to == p) continue;\n        res |= dfs(g.to, v, d + g.cost); \n    }\n    return res;\n}\n\nbool run()\n{\n    int N;\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        G[i].clear();\n    }\n    \n    map<string, int> s2i;\n    \n    string t, u, v;\n    for (int i = 0; i < N; i++) {\n        cin >> u >> u;\n\n        if (s2i.count(u) == 0) {\n            s2i[u] = s2i.size();\n        }\n        \n        cin >> t >> t >> v;\n        t = t.substr(3);\n\n        if (s2i.count(v) == 0) {\n            s2i[v] = s2i.size();\n        }\n        \n        int num = stoi(t);        \n        G[s2i[v]].emplace_back(s2i[u], -num);\n        G[s2i[u]].emplace_back(s2i[v], num);\n    }\n    \n    N = s2i.size();\n    bool ok = 1;\n    for (int i = 0; i < N; i++) {\n        fill(dist, dist + N, INF);\n        if (dfs(i, -1, 0)) {\n            ok = 0;\n            break;\n        }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n\nint main()\n{\n    while (run())\n        ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint get_exp(string x) {\n  return stoi(x.substr(3));\n}\n\nbool dfs(string& s, int num, map<string, vector<pair<int, string>>>& G, map<string, int>& vis) {\n  for(auto& e: G[s]) {\n    int r; string next; tie(r, next) = e;\n    auto iter = vis.find(next);\n\n    if(iter != vis.end()) {\n      if(num + r != iter->second) return false;\n    } else {\n      vis[next] = num + r;\n      if(!dfs(next, num + r, G, vis)) return false;\n    }\n\n  }\n  return true;\n}\n\nint main() {\n\n  int N;\n  while(cin >> N && N) {\n\n    map<string, vector<pair<int, string>>> G;\n    set<string> st;\n\n    rep(__, N) {\n      char _; string s1, s2, t;\n      cin >> _ >> s1 >> _ >> t >> s2;\n      G[s1].emplace_back(get_exp(t), s2);\n      G[s2].emplace_back(get_exp(t) * -1, s1);\n      st.insert(s1), st.insert(s2);\n    }\n\n    map<string, int> vis;\n    bool ok = 1;\n    for(auto s: st) {\n      if(vis.find(s) != vis.end()) continue;\n      vis[s] = 1;\n      if(!dfs(s, 1, G, vis)) {\n        ok = 0;\n        break;\n      }\n    }\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<string>v; int n, a[1000], b[1000], c[1000]; string s1[1000], s2[1000], t[1000];\nvector<int>u[1000]; int group[1000], dist[1000]; bool OK = true;\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\n\nvoid merge(int a, int b, int c) {\n\tif (group[a] == group[b]) { if ((dist[a] - dist[b]) != c)OK = false; return; }\n\tint w1 = group[a], w2 = group[b];\n\tint sa = (dist[a] - dist[b]) - c;\n\tfor (int i : u[w2])dist[i] += sa;\n\tfor (int i : u[w2])u[w1].push_back(i);\n\tfor (int i : u[w2])group[i] = w1;\n\tu[w2].clear();\n\tsort(u[w1].begin(), u[w1].end());\n\treturn;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; v.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring a1, a2; cin >> a1 >> s1[i] >> a2 >> t[i] >> s2[i];\n\t\t\tv.push_back(s1[i]); v.push_back(s2[i]);\n\t\t}\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); OK = true; int m = v.size();\n\t\tfor (int i = 0; i < m; i++) { group[i] = i; u[i].clear(); u[i].push_back(i); }\n\t\tfor (int i = 0; i < n; i++) { a[i] = s(s1[i]); b[i] = s(s2[i]); c[i] = stoi(t[i].substr(3, t[i].size() - 3)); }\n\t\tfor (int i = 0; i < n; i++) { merge(a[i], b[i], c[i]); }\n\t\tif (OK == true)cout << \"Yes\" << endl; else cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nusing ll = long long;\nconstexpr ll MAX = 514;\nconstexpr ll UNVISITED = (1 << 25);\n\nstruct Edge {\n    ll to, cost;\n    Edge() {}\n    Edge(ll to, ll cost) :\n        to{to}, cost{cost} {}\n};\n\nvector<Edge> G[MAX];\nll dist[MAX];\n\nbool dfs(ll v, ll p, ll d)\n{\n    if (dist[v] != UNVISITED) {\n        return (dist[v] != d);\n    }\n    \n    dist[v] = d;\n    for (const auto& g : G[v]) {\n        if (g.to == p) continue;\n        if (dfs(g.to, v, d + g.cost)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool run()\n{\n    ll N;\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n\n    for (ll i = 0; i < MAX; i++) {\n        G[i].clear();\n    }\n    \n    ll n = 0;\n    map<string, ll> s2i;\n    \n    string t, u, v;\n    for (ll i = 0; i < N; i++) {\n        cin >> u >> u;\n\n        if (s2i.count(u) == 0) {\n            s2i[u] = n++;\n        }\n        \n        cin >> t >> t >> v;\n        t = t.substr(3);\n\n        if (s2i.count(v) == 0) {\n            s2i[v] = n++;\n        }\n        \n        ll num = stoi(t);        \n        G[s2i[v]].emplace_back(s2i[u], -num);\n        G[s2i[u]].emplace_back(s2i[v], num);\n    }\n   \n    bool ok = 1;\n    for (ll i = 0; i < n; i++) {\n        fill(dist, dist + MAX, UNVISITED);\n        if (dfs(i, -1, 0)) {\n            ok = 0;\n            break;\n        }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n\nint main()\n{\n    while (run())\n        ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int nn = 0;\n    string str;\n    getline(cin,str);\n    map<string,int> m;\n    vector<vector<int> > v;\n    v.assign(n, vector<int>(n,INF));\n    while(n--){\n      string str2, str3;\n      bool f = false, f2 = false, minus = false;\n      int a = 0;\n      getline(cin,str);\n\n      for(int i=2;i<str.size();i++){\n\tif(!f && !f2 && str[i] != ' '){\n\t  //str2 += str[i];\n\t  str2.insert(str2.size(),1,str[i]);\n\t}\n\telse if(!f && !f2 && str[i] == ' '){\n\t  f = true;\n\t  i += 6;\n\t  if(str[i] == '-'){\n\t    minus = true;\n\t    i++;\n\t    a = str[i] - '0';\n\t    a *= -1;\n\t  }\n\t  else a = str[i] - '0';\n\t}\n\telse if(!f2 && str[i] != ' '){\n\t  a *= 10;\n\t  if(minus) a -= str[i] - '0';\n\t  else a += str[i] - '0';\n\t}\n\telse if(!f2 && str[i] == ' ') f2 = true;\n\telse{\n\t  //str3 += str[i];\n\t  str3.insert(str3.size(),1,str[i]);\n\t}\n      }\n      if(m.find(str2) == m.end()) m[str2] = nn++;\n      if(m.find(str3) == m.end()) m[str3] = nn++;\n      //cout << str2 << \" \" << str3 << \" \" << a << endl;\n      v[m[str2]][m[str3]] = a;\n      v[m[str3]][m[str2]] = -1 * a;\n    }\n\n    bool ans = true;\n\n    for(int k=0;k<v.size();k++){\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v.size();j++){\n\t  if(i != j && v[i][j] == INF && v[i][k] < INF && v[k][j] < INF) v[i][j] = v[i][k] + v[k][j];\n\t}\n      }\n    }\n\n    for(int k=0;k<v.size();k++){\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v.size();j++){\n\t  if(v[i][j] >= INF || v[i][k] >= INF || v[k][j] >= INF) continue;\n\t  if(v[i][j] != v[i][k] + v[k][j]){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    /*for(int i=1;i<v.size();i++){\n      for(int j=1;j<v.size();j++){\n\tif(v[i][j] == INF) cout << \" I \";\n\telse printf(\"%2d \",v[i][j]);\n      }\n      cout << endl;\n      }*/\n\n    if(ans) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nbool warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n                //if(d[2][1]==2){\n                //    cout<<endl;\n                //}\n                // Ç¿çàINFæè¬³­Èé\n                if(prv!=INF&&d[j][i]+d[i][k]<INF&&j!=k){\n                    if(prv!=d[j][i]+d[i][k]){\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0)\n                d[dict[a]][dict[b]]=-cost;\n            else\n                d[dict[b]][dict[a]]=cost;\n        }\n        V=idx;\n        bool f=warshall_floyd();\n        if(!f)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <map>\nusing namespace std;\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nvector<string> split_native(const string &s, char delim) {\n    vector<string> elems;\n    string item;\n    for (char ch: s) {\n        if (ch == delim) {\n            if (!item.empty())\n                elems.push_back(item);\n            item.clear();\n        }\n        else {\n            item += ch;\n        }\n    }\n    if (!item.empty())\n        elems.push_back(item);\n    return elems;\n}\n\nint main(){\n    int N;\n\n    while(cin >> N){\n        if(N ==0) break;\n\n        UnionFind<int> UF(200);\n        map<string, int> m;\n        int idx = 0;\n        bool flag = true;\n\n        for(int i=0; i<N; ++i){\n            string one, unit1, equal, val, unit2;\n            cin >> one >> unit1 >> equal >> val >> unit2;\n            if(m.count(unit1) == 0){\n                m[unit1] = idx;\n                ++idx;\n            }\n            int id1 = m[unit1];\n\n            if(m.count(unit2) == 0){\n                m[unit2] = idx;\n                ++idx;\n            }\n            int id2 = m[unit2]; \n\n            int w;\n            vector<string> vec;\n            vec = split_native(val, '^');\n            w = stoi(vec[1]);\n\n            if(UF.issame(id1, id2)){\n                int diff = UF.diff(id1, id2);\n                if(diff != w) flag = false;\n            }else{\n                UF.merge(id1, id2, w);\n            }                 \n        }\n        if(flag){\n            puts(\"Yes\");\n        }else{\n            puts(\"No\");\n        }\n    }    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<set>\n#include<cstdio>\n#define F first\n#define S second\n#define inf (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nstruct P\n{\n  string unit;\n  int mpower;\n  int upower;\n  P(string unit=\"$\",int upower=-inf,int mpower=-inf):unit(unit),upower(upower),mpower(mpower){}\n};\nvector<vector<P> > G(110);\nmap<string,int> exist;\n\nint toPower(string s)\n{\n  if(s == \"1\")return 0;\n  int pos = 0;\n  rep(i,s.size())\n    {\n      if(s[i] == '^')\n\t{\n\t  pos = i+1;\n\t  break;\n\t}\n    }\n  return (atoi)(s.substr(pos,s.size()-pos).c_str());\n}\n\nbool used[110];\nint isok;//-1 -> No, 0 => Not yet, 1 -> Ok\n\nvoid dfs(string now,string target,int power,int target_power)\n{\n  if(isok != 0)return;\n  if(now == target)\n    {\n      isok = (power == target_power?1:-1);\n      return;\n    }\n  int index = exist[now];\n  if(used[index])return;\n  used[index] = true;\n\n  rep(i,G[index].size())\n    {\n      P p = G[index][i];\n      int next_index = exist[p.unit];\n      if(used[next_index])continue;\n      dfs(p.unit,target,power+(p.mpower==0?p.upower:-p.mpower),target_power );\n    }\n}\n\nbool check(string u1,string u2,int power)\n{\n  rep(i,110)used[i] = false;\n  isok = 0;\n\n  dfs(u1,u2,0,power);\n  return isok == 1;\n}\n\nbool reachable;\n\nvoid move(int now,int target)\n{\n  if(now == target)\n    {\n      reachable = true;\n      return;\n    }\n\n  if(used[now])return;\n  used[now] = true;\n  rep(i,G[now].size())\n    {\n      move(exist[G[now][i].unit],target);\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N , N)\n    {\n      rep(i,N)G[i].clear();\n      int index = 0;\n      exist.clear();\n      bool result = true;\n      rep(i,N)\n\t{\n\t  string v1,unit1,v2,unit2,eq;\n\t  cin >> v1 >> unit1 >> eq >> v2 >> unit2;\n\t  //cout << toPower(v1) << \" \" << unit1 << \" = \"<< toPower(v2) << \" \" << unit2 << endl;\n\t  if(exist.count(unit1) && exist.count(unit2))\n\t    {\n\t      rep(i,N)used[i] = false;\n\t      reachable = false;\n\t      move(exist[unit1],exist[unit2]);\n\t      if(reachable)\n\t\t{\n\t\t  int p1 = toPower(v1);\n\t\t  int p2 = toPower(v2);\n\t\t  result = check(unit1,unit2,p2);\n\t\t  //cout << \"result = \" << result << endl;\n\t\t}\n\t      continue;\n\t    }\n\n\t  //cout << \"not exists\" << endl;\n\t  if(!exist.count(unit1))exist[unit1] = index++;\n\t  if(!exist.count(unit2))exist[unit2] = index++;\n\t  int index1 = exist[unit1];\n\t  int index2 = exist[unit2];\n\t  G[index1].push_back(P(unit2,toPower(v2),toPower(v1)));\n\t  G[index2].push_back(P(unit1,toPower(v1),toPower(v2)));\n\t}\n      cout << (result?\"Yes\":\"No\") << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconstexpr int MAX = 100;\n\nstruct Edge {\n    int to, cost;\n    Edge() {}\n    Edge(int to, int cost) :\n        to{to}, cost{cost} {}\n};\n\nvector<Edge> G[MAX];\nint dist[MAX];\n\nbool dfs(int v, int p, int d)\n{\n    if (dist[v] != -1) {\n        return (dist[v] != d);\n    }\n    dist[v] = d;\n\n    for (auto& g : G[v]) {\n        if (g.to == p) continue;\n        if (dfs(g.to, v, d + g.cost)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool run()\n{\n    int N;\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n\n    for (int i = 0; i < N; i++) {\n        G[i].clear();\n    }\n    \n    map<string, int> s2i;\n    \n    string t, u, v;\n    for (int i = 0; i < N; i++) {\n        cin >> u >> u;\n\n        if (s2i.count(u) == 0) {\n            s2i[u] = s2i.size();\n        }\n        \n        cin >> t >> t >> v;\n        t = t.substr(3);\n\n        if (s2i.count(v) == 0) {\n            s2i[v] = s2i.size();\n        }\n        \n        int num = stoi(t);        \n        G[s2i[v]].emplace_back(s2i[u], -num);\n        G[s2i[u]].emplace_back(s2i[v], num);\n    }\n    bool ok = 1;\n    for (int i = 0; i < (int)s2i.size(); i++) {\n        memset(dist, -1, sizeof(dist));\n        if (dfs(i, -1, 0)) {\n            ok = 0;\n            break;\n        }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n\nint main()\n{\n    while (run())\n        ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nbool visited[200];\nint c[200];\n\nbool dfs(vector<vector<pair<int, int> > > &edge, int now, int cost) {\n    if (visited[now])return cost == c[now];\n    c[now] = cost;\n    visited[now] = true;\n    bool res = true;\n    rep(i, edge[now].size()) {\n        int next = edge[now][i].first;\n        int ncost = edge[now][i].second;\n        res &= dfs(edge, next, cost + ncost);\n    }\n    return res;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    int n;\n    while(1) {\n        cin >> n;\n        map<string, int> v;\n        vector<vector<pair<int, int> > > edge(2*n);\n        if (n == 0)break;\n        int cnt = 0;\n        rep(i,n) {\n            int idummy;\n            char cdummy;\n            string s[2],sdummy;\n            int cost;\n            cin >> idummy >> s[0] >> sdummy >> idummy >> cdummy >> cost >> s[1];\n            rep(j,2) {\n                if (v.find(s[j]) == v.end()) {\n                    v[s[j]] = cnt;\n                    cnt++;\n                }\n            }\n            edge[v[s[0]]].push_back(make_pair(v[s[1]], cost));\n            edge[v[s[1]]].push_back(make_pair(v[s[0]], -cost));\n        }\n        bool ok = true;\n        rep(i, n) {\n            rep(j,100) {\n                visited[j] = false;\n            }\n            ok &= dfs(edge, i, 0);\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \n\nint main(void){  \n  int N;\n  while(cin>>N){\n    if(!N) break;\n    vector<string> tani;\n    vector<int> ind;\n    bool flag = true;\n    bool first = true;\n    int tmp;\n    string tmp2;\n    while(N--){\n      string tani1,tani2;\n      int index;\n      cin>>tmp;\n      cin>>tani1;\n      cin>>tmp2;\n      cin>>tmp2;\n      index = (tmp2[3]!='-')?(tmp2[3]-'0'):('0' - tmp2[4]);\n      cin>>tani2;\n      if(first){\n        tani.push_back(tani1); tani.push_back(tani2);\n        ind.push_back(0); ind.push_back(index);\n        first = false;\n        continue;\n      }\n      vector<string>::iterator it1 = find(tani.begin(),tani.end(),tani1)\n        , it2 = find(tani.begin(),tani.end(),tani2);\n      bool f1 = (it1 != tani.end());\n      bool f2 = (it2 != tani.end());\n      int ind1 = ind[distance(tani.begin(),it1)];\n      int ind2 = ind[distance(tani.begin(),it2)];\n      if(f1){\n        if(f2){\n          if(ind2 - ind1 != index){\n            flag = false;\n          }\n        }else{\n          ind.push_back(ind1 + index);\n          tani.push_back(tani2);\n        }\n      }else{\n        if(f2){\n          ind.push_back(ind2 - index);\n          tani.push_back(tani1);\n        }else{\n          flag = false;\n        }\n      }\n    }\n    if(flag) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#define N 210\nusing namespace std;\n\nint n,m;\nint d[N][N];\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int k=0;k<m;k++ )\n    for( int i=0;i<m;i++ )\n      for( int j=0;j<m;j++ )\n\td[i][j] = min( d[i][j],d[i][k]+d[k][j] );\n\n  for( int i=0;i<m;i++ )\n    if( d[i][i]!=0 )\n      return false;\n  return true;\n}\n\nint main(){\n  string a,b, s;\n  int x;\n  char c;\n\n  while( cin>>n && n ){\n    m=n*2;\n    for( int i=0;i<m;i++ ){\n      for( int j=0;j<m;j++ )\n\td[i][j]=1000;\n    }\n    map<string,int> units; // units[ a ] でaの配列番号が分かる\n    m=0;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c;  // 10^\n      cin >> x >> b;  // [x] [B];\n\n      if( units.find( a )==units.end() )\n\tunits[a] = m++;\n      if( units.find( b )==units.end() )\n\tunits[b] = m++;\n\n      int an=units[a], bn=units[b];\n      \n      d[an][bn] =  x;\n      d[bn][an] = -x;\n    }\n\n    if( check() ) cout << \"Yes\" << endl;\n    else          cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 250\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,int> m;\nint n,x,s2,num,s;\nbool ans,used[N];\nvector<P> e[N];\nstring s1,s3;\n\nvoid dfs(int x,int y,int sum){\n  if(used[x])return;\n  used[x]=true;\n  if(x==y){\n    s=sum;\n    return;\n  }\n  for(int i=0;i<e[x].size();i++)\n    dfs(e[x][i].first,y,sum+e[x][i].second);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    num=0;\n    ans=true;\n    for(int i=0;i<n;i++){\n      cin>>s3>>s1>>s3;\n      scanf(\" 10^%d\",&s2); cin>>s3;\n      if(m.find(s1)!=m.end()&&m.find(s3)!=m.end()){\n\ts=-1;\n\tmemset(used,0,sizeof(used));\n\tdfs(m[s1],m[s3],0);\n\tif(s!=-1&&(s!=s2&&s!=-s2))ans=false;\n      }\n      if(m.find(s1)==m.end())m[s1]=num++;\n      if(m.find(s3)==m.end())m[s3]=num++;\n      e[m[s1]].push_back(P(m[s3],s2));\n      e[m[s3]].push_back(P(m[s1],-s2));\n    }\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    for(int i=0;i<N;i++)e[i].clear();\n    m.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nstruct NODE{\n\tstring to;\n\tint cost;\n\tNODE(string to,int cost) : to(to) , cost(cost) {}\n};\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tmap<string,vector<NODE> > g;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a,b,c,d,e;\n\t\t\tcin >> a >> b >> c >> d >> e;\n\t\t\tg[b].push_back(NODE(e,atoi(d.substr(d.find(\"^\")+1).c_str())));\n\t\t\tg[e].push_back(NODE(b,-atoi(d.substr(d.find(\"^\")+1).c_str())));\n\t\t\t\n\t\t}\n\t\tint ok = 1;\n\t\tfor( map<string,vector<NODE> > ::iterator it = g.begin() ; it != g.end() ; ++it ){\n\t\t\tmap<string,int> done;\n\t\t\tqueue<NODE> Q;\n\t\t\tQ.push(NODE(it->first,0));\n\t\t\twhile(Q.size()){\n\t\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t\tif( done.count(q.to) ){\n\t\t\t\t\tif( done[q.to] != q.cost ) ok = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdone[q.to] = q.cost;\n\t\t\t\tfor(int i = 0 ; i < g[q.to].size() ; i++)\n\t\t\t\t\tQ.push(NODE(g[q.to][i].to,q.cost+g[q.to][i].cost));\n\t\t\t}\n\t\t}\n\t\tcout << (ok?\"Yes\":\"No\") << endl;\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n                //// Ç¿çàINFæè¬³­Èé\n                //if(prv!=INF&&d[j][i]+d[i][k]<INF){\n                //    if(prv!=d[j][i]+d[i][k]){\n                //        return false;\n                //    }\n                //}\n            }\n        }\n    }\n//    return true;\n}\n\nbool passed[101];\nbool no;\nvoid dfs(int s){\n    passed[s]=true;\n    for(int i = 0; i < V; i++){\n        if(i==s)continue;\n        if(d[s][i]!=INF){\n            if(passed[i]){\n                no=true;\n                return;\n            }\n            dfs(i);\n            if(no)\n                return;\n        }\n    }\n    passed[s]=false;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0)\n                d[dict[a]][dict[b]]=-cost;\n            else\n                d[dict[b]][dict[a]]=cost;\n        }\n        V=idx;\n        //vector<int> roots;\n        //for(int j = 0; j < idx; j++){\n        //    int cnt=0;\n        //    for(int i = 0; i < idx; i++){\n        //        if(i==j)continue;\n        //        if(d[i][j]!=INF)\n        //            cnt++;\n        //    }\n        //    //if(cnt==0)\n        //    //    roots.push_back(j);\n        //}\n        no=false;\n        for(int i = 0; i < idx; i++){\n            fill(passed,passed+101,false);\n            dfs(idx);\n        }\n        //if(roots.size()==0)\n        //    no=true;\n        warshall_floyd();\n        for(int i = 0; i < idx; i++){\n            for(int j = 0;  j< idx; j++){\n                int dist=d[i][j];\n                if(i==j)\n                    continue;\n                for(int k = 0; k < idx; k++){\n                    if(dist<INF&&d[i][k]<INF&&d[k][j]<INF){\n                        if(dist!=d[i][k]+d[k][j])\n                            no=true;\n                    }\n                    if(no)\n                        break;\n                }\n                if(no)\n                    break;\n            }\n            if(no)break;\n        }\n\n        if(no)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<set>\n#include<cstdio>\n#include<cassert>\n#define F first\n#define S second\n#define inf (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nstruct P\n{\n  string unit;\n  int mpower;\n  int upower;\n  P(string unit=\"$\",int upower=-inf,int mpower=-inf):unit(unit),upower(upower),mpower(mpower){}\n};\nvector<vector<P> > G(210);\nmap<string,int> exist;\n\nint toPower(string s)\n{\n  if(s == \"1\")return 0;\n  int pos = 0;\n  rep(i,s.size())\n    {\n      if(s[i] == '^')\n\t{\n\t  pos = i+1;\n\t  break;\n\t}\n    }\n  return (atoi)(s.substr(pos,s.size()-pos).c_str());\n}\n\nbool used[210];\nint isok;//-1 -> No, 0 => Not yet, 1 -> Ok\n\nvoid dfs(string now,string target,int power,int target_power)\n{\n  if(isok != 0)return;\n  if(now == target)\n    {\n      isok = (power == target_power?1:-1);\n      return;\n    }\n  int index = exist[now];\n  if(used[index])return;\n  used[index] = true;\n\n  rep(i,G[index].size())\n    {\n      P p = G[index][i];\n      int next_index = exist[p.unit];\n      if(used[next_index])continue;\n      dfs(p.unit,target,power+(p.mpower==0?p.upower:-p.mpower),target_power );\n    }\n}\n\nbool check(string u1,string u2,int power)\n{\n  rep(i,110)used[i] = false;\n  isok = 0;\n\n  dfs(u1,u2,0,power);\n  return isok == 1;\n}\n\nbool reachable;\n\nvoid move(int now,int target)\n{\n  if(now == target)\n    {\n      reachable = true;\n      return;\n    }\n\n  if(used[now])return;\n  used[now] = true;\n\n  rep(i,G[now].size())\n    {\n          \n      assert(exist.count(G[now][i].unit));\n\n      move(exist[G[now][i].unit],target);\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N)\n    {\n      assert(N <= 100);\n      rep(i,N)G[i].clear();\n      int index = 0;\n      exist.clear();\n      bool result = true;\n      rep(i,N)\n\t{\n\t  string v1,unit1,v2,unit2,eq;\n\t  cin >> v1 >> unit1 >> eq >> v2 >> unit2;\n\t  if(unit1 == unit2)\n\t    {\n\t      if(v2 == \"10^0\")continue;\n\t      else            result = false;\n\t      continue;\n\t    }\n\t  //assert(unit1 != unit2);\n\t  if(!result)continue;\n\t  //cout << toPower(v1) << \" \" << unit1 << \" = \"<< toPower(v2) << \" \" << unit2 << endl;\n\t  if(exist.count(unit1) && exist.count(unit2))\n\t    {\n\t      rep(i,N)used[i] = false;\n\t      reachable = false;\n\t      move(exist[unit1],exist[unit2]);\n\t      if(reachable)\n\t\t{\n\t\t  int p1 = toPower(v1);\n\t\t  int p2 = toPower(v2);\n\t\t  result = check(unit1,unit2,p2);\n\t\t  //cout << \"result = \" << result << endl;\n\t\t}\n\t      else\n\t\t{\n\t\t  goto Insert;\n\t\t}\n\t      continue;\n\t    }\n\n\t  //cout << \"not exists\" << endl;\n\t  if(!exist.count(unit1))exist[unit1] = index++;\n\t  if(!exist.count(unit2))exist[unit2] = index++;\n\tInsert:;\n\t  int index1 = exist[unit1];\n\t  int index2 = exist[unit2];\n\t  G[index1].push_back(P(unit2,toPower(v2),toPower(v1)));\n\t  G[index2].push_back(P(unit1,toPower(v1),toPower(v2)));\n\t}\n      cout << (result?\"Yes\":\"No\") << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 200*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n\n    int size() const { return id; }\n};\n\n// INF テ、ツサツ・テ・ツ、ツ姪」ツ?古ヲツ崢エテヲツ鳴ーテ」ツ?陛」ツつ古」ツ?淌」ツつ?true\nbool relax(const vector<vector<pair<int,int> > > &graph, vector<int> &dist, int N) {\n    for(int i = 0; i < N; ++i) {\n        const vector<pair<int,int> > &edges = graph[i];\n        for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n            if(dist[i] == INF) continue;\n            const int nc = dist[i] + it->second;\n            if(dist[it->first] > nc) {\n                if(dist[it->first] == INF) {\n                    dist[it->first] = nc;\n                } else {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nvector<vector<pair<int,int> > > v(200);\nvector<int> dist(200);\nvector<unsigned char> visited(200);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < N; ++i) {\n            v[i].clear();\n            dist[i] = INF;\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            for(string::iterator it = line.begin(); it != line.end(); ++it) {\n                if(*it == '=' || *it == '^') *it = ' ';\n            }\n            istringstream is(line);\n            string unit_left, unit_right;\n            int ord;\n            int tmp;\n            is >> tmp >> unit_left >> tmp >> ord >> unit_right;\n            //sscanf(line.c_str(), \"%*d %s = %*d^%d %s \", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        const int M = dict.size();\n        // テ」ツ?敕」ツつ古」ツ?榲」ツつ古」ツ?ョテゥツ?」テァツオツ静ヲツ按静・ツ按?」ツ?ォテ」ツ?、テ」ツ?催ッツシツ?テ」ツδ偲」ツδシテ」ツδ嘉」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ィテ」ツ?凖」ツつ凝ッツシツ?\n        fill(visited.begin(), visited.end(), 0);\n        queue<int> q;\n        for(int i = 0; i < M; ++i) {\n            if(!visited[i]) {\n                dist[i] = 0;\n                visited[i] = 1;\n                q.push(i);\n                while(!q.empty()) {\n                    int cur = q.front();\n                    q.pop();\n                    const vector<pair<int,int> > &edges = v[cur];\n                    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                        if(!visited[it->first]) {\n                            visited[it->first] = 1;\n                            q.push(it->first);\n                        }\n                    }\n                }\n            }\n        }\n\n        bool ok = true;\n        for(int phase = 0; phase < M; ++phase) {\n            if(relax(v, dist, M)) {\n                ok = false;\n                break;\n            }\n        }\n        if(!ok) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int             long long\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define REPR( i, m )    for( int (i) = (m); (i) >= 0; (i)-- )\n#define REPONE( i, n )  FOR( i, 1, n + 1 )\n#define ALL( a )        (a).begin(), (a).end()\n#define MP              make_pair\n\nusing namespace std;\nusing P = pair<int, int>;\n\ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nstruct WaitedUnionFind{\n    vector<int> par, rank, diff_weight;\n\n    WaitedUnionFind( int N ){\n        par.resize( N ), rank.resize( N ), diff_weight.resize( N );\n        REP( i, N ) par[i] = i, rank[i] = diff_weight[i] = 0;\n    }\n\n    int root( int x ){\n        if( par[x] == x ){\n            return x;\n        }else{\n            int r = root( par[x] );\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    int weight( int x ){\n        root( x );\n        return diff_weight[x];\n    }\n\n    bool same( int x, int y ){\n        return root( x ) == root( y );\n    }\n\n    void unite( int x, int y, int w ){\n        w += weight( x ), w -= weight( y );\n        x = root( x ), y = root( y );\n        if( x == y ) return;\n        if( par[x] < par[y] ) swap( x, y ), w = -w;\n        if( par[x] == par[y] ) rank[x]++;\n        par[y] = x;\n        diff_weight[y] = w;\n    }\n\n    int diff( int x, int y ){\n        return weight( y ) - weight( x );\n    }\n};\n\nsigned main(){\n    int N;\n    while( cin >> N, N ){\n        bool ok = true;\n\n        WaitedUnionFind uf( 200 );\n\n        map<string, int> unite2id;\n        int final_id = 0;\n\n        REP( i, N ){\n            int one, ten, e;\n            string unite1, unite2;\n            char c;\n            cin >> one >> unite1 >> c >> ten >> c >> e >> unite2;\n\n            if( !unite2id.count( unite1 ) ){\n                unite2id[unite1] = final_id++;\n            }\n            int id1 = unite2id[unite1];\n\n            if( !unite2id.count( unite2 ) ){\n                unite2id[unite2] = final_id++;\n            }\n            int id2 = unite2id[unite2];\n\n            if( uf.same( id1, id2 ) ){\n                int curdiff = uf.diff( id1, id2 );\n                if( e != curdiff ) ok = false;\n            }else{\n                uf.unite( id1, id2, e );\n            }\n        }\n\n        if( ok ) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define all(a) (a).begin(),(a).end()\n\nint N;\n\nstruct edge {\n  int to, cost;\n};\n\nvector<edge> es[202];\nmap<string,int> vs;\n\nint d[202][202];\n\nstring solve() {\n  int V = vs.size();\n\n  rep(i,V) rep(j,V) d[i][j] = 1<<28;\n  rep(i,V) d[i][i] = 0;\n  \n  rep(i,V) {\n    rep(j,es[i].size()) {\n      edge& e = es[i][j];\n      d[i][e.to] = e.cost;\n    }\n  }\n  \n  rep(k,V) rep(i,V) rep(j,V) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n  rep(i,V) rep(j,V) {\n    if (i == j) continue;\n    rep(k,V) {\n      if (i == k || j == k) continue;\n      if (!(d[i][j] == d[i][k] + d[k][j])) {\n        // printf(\"%d - %d is %d, %d - %d - %d is %d\\n\",\n        //        i, j, d[i][j], i, k, j, d[i][k] + d[k][j]);\n        return \"No\";\n      }\n    }\n  }\n\n  return \"Yes\";\n}\n\nint main() {\n  while (cin>>N, N) {\n\n    rep(i,200) es[i].clear();\n    \n    int num;\n    string src, cost, dst;\n    char c;\n    int cst;\n\n    vs.clear();\n    \n    rep(i,N) {\n      cin>>num>>src>>c>>cost>>dst;\n      cst = atoi(cost.substr(cost.find(\"^\")+1).c_str());\n\n      if (!vs.count(src)) {\n        vs.insert(make_pair(src, vs.size()));\n      }\n      if (!vs.count(dst)) {\n        vs.insert(make_pair(dst, vs.size()));\n      }\n\n      es[ vs[src] ].push_back((edge){ vs[dst], cst });\n      es[ vs[dst] ].push_back((edge){ vs[src], -cst });\n    }\n\n    cout << solve() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <list>\n\n\nint* find(\n    std::unordered_map<std::string, std::unordered_map<std::string, int> > *map,\n    const std::string &s1, const std::string &s2)\n{\n    auto it1 = map->find(s1);\n    if (it1 == map->end()) return NULL;\n\n    auto it2 = it1->second.find(s2);\n    return (it2 == it1->second.end()) ? NULL : &it2->second;\n}\n\n\nbool walk(\n    std::unordered_map<std::string, std::unordered_map<std::string, int> > *map,\n    const std::tuple<std::string, std::string, int> &t)\n{\n    const std::string &s0 = std::get<0>(t);\n    const std::string &s1 = std::get<1>(t);\n    int mag1 = std::get<2>(t);\n\n    int *old = find(map, s0, s1);\n    if (old == NULL)\n    {\n        (*map)[s0][s1] = mag1;\n        (*map)[s1][s0] = -mag1;\n    }\n    else return (*old == mag1);\n\n    std::list<std::tuple<std::string, std::string, int> > next;\n        \n    for (auto x : map->at(s0))\n    {\n        const std::string &s2 = x.first;\n        int mag2 = x.second;\n        \n        if (s1 != s2)\n        if (find(map, s1, s2) == NULL)\n            next.push_back(std::make_tuple(s1, s2, -mag1 + mag2));\n    }\n    \n    for (auto x : map->at(s1))\n    {\n        const std::string &s2 = x.first;\n        int mag2 = x.second;\n        \n        if (s0 != s2)\n        if (find(map, s0, s2) == NULL)\n            next.push_back(std::make_tuple(s0, s2, mag1 + mag2));\n    }\n\n    for (auto t : next)\n        if (!walk(map, t))\n            return false;\n\n    return true;\n}\n\n\nint main()\n{\n    char line[256];\n    \n    while (not std::cin.eof())\n    {\n        int n;\n        std::cin >> n;\n        if (n == 0) break;\n\n        std::list<std::tuple<std::string, std::string, int> > inputs;\n        \n        for (int i = 0; i < n; ++i)\n        {\n            int x;\n            std::string s1, s2;\n            \n            std::cin.ignore(2);\n            std::cin >> s1;\n            std::cin.ignore(6);\n            std::cin >> x >> s2;\n\n            inputs.push_back(std::make_tuple(s1, s2, x));\n        }\n\n        std::unordered_map<std::string,\n            std::unordered_map<std::string, int> > map;\n        bool is_valid(true);\n        \n        for (auto x : inputs)\n            if (!walk(&map, x))\n            {\n                is_valid = false;\n                break;\n            }\n\n        std::cout << (is_valid ? \"Yes\" : \"No\") << std::endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tstring lhs;\n\tstring rhs;\n\tint power;\n\tData(string _l,string _r, int _p){\n\t\tlhs = _l;\n\t\trhs = _r;\n\t\tpower = _p;\n\t}\n};\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Data> relations;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint num;\n\t\t\tstring lhs;\n\t\t\tstring eq;\n\t\t\tstring rhs;\n\t\t\tstring tmp;\n\n\t\t\tcin >> num >> lhs >> eq >> tmp >> rhs;\n\t\t\tint base,pow;\n\t\t\tsscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n\t\t\trelations.push_back(Data(lhs,rhs,pow));\n\t\t}\n\n\t\tmap<string,set<int> > vals;\n\n\t\tbool isok = true;\n\t\tvals[relations[0].rhs].insert(0);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(set<int>::iterator it = vals[relations[j].rhs].begin();it != vals[relations[j].rhs].end();it++){\n\t\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\t\tvals[relations[j].lhs].insert(relations[j].power + *it);\n\t\t\t\t\tif(vals[relations[j].lhs].size() > 1){ \n\t\t\t\t\t\tisok = false;\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//sort(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t//vector<int>::iterator it = unique(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t//vals[relations[j].lhs].resize( it - vals[relations[j].lhs].begin() );\n\n\t\t\t\t//if(vals[relations[j].lhs].size() > 1) isok = false;\n\t\t\t}\n\n\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(set<int>::iterator it = vals[relations[j].lhs].begin();it != vals[relations[j].lhs].end();it++){\n\t\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\t\tvals[relations[j].rhs].insert(-relations[j].power + *it);\n\t\t\t\t\tif(vals[relations[j].rhs].size() > 1){ \n\t\t\t\t\t\tisok = false;\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//sort(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t//vector<int>::iterator it = unique(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t//vals[relations[j].rhs].resize( it - vals[relations[j].rhs].begin() );\n\t\t\t\t//if(vals[relations[j].rhs].size() > 1) isok = false;\n\t\t\t}\n\t\t}\n\nfound:;\n\n\t\tprintf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <unordered_map>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef string key;\n\nchar b1[99],b2[99];\nvoid main2(int n){\n\tunordered_map<key,deque<pair<key,long long>>>m;\n\tfor(;n;n--){\n\t\tint d;\n\t\tscanf(\" 1 %s = 10^%d %s\",b1,&d,b2);\n\t\tstring s1=b1,s2=b2;\n\t\tm[s1].emplace_back(s2,d);\n\t\tm[s2].emplace_back(s1,-d);\n\t}\n\tfor(;!m.empty();){\n\t\tauto s=m.begin()->first;\n\t\tdeque<pair<key,long long>>st={{s,0}};\n\t\tunordered_map<key,long long>memo={{s,0}};\n\t\tfor(;!st.empty();){\n\t\t\tauto p=*st.rbegin();st.pop_back();\n\t\t\tauto cur=p.first;long long d=p.second;\n\t\t\tfor(auto &e:m[cur]){\n\t\t\t\tif(memo.find(e.first)==memo.end()){\n\t\t\t\t\tst.emplace_back(e.first,d+e.second);\n\t\t\t\t\tmemo[e.first]=d+e.second;\n\t\t\t\t}else if(memo[e.first]!=d+e.second){\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto &e:memo)m.erase(m.find(e.first));\n\t}\n\tputs(\"Yes\");\n}\nint main(){int n;for(;~scanf(\"%d\",&n)&&n;)main2(n);}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int hoge[2*n];\n    UnionFind uf(2*n);\n    map<string,int> id;\n    int cnt = 0;\n    bool f = 0;\n    REP(i,n) {\n      int tmp;\n      string tmps, s1,s2,xx;\n      cin>>tmp>>s1>>tmps>>xx>>s2;\n      int x = atoi(xx.substr(3).c_str());\n      if (s1 == s2 && x != 1) {\n        f = 1;\n      }\n      if (id.count(s1)==0 && id.count(s2)==0) {\n        id[s1] = cnt++;\n        id[s2] = cnt++;\n        hoge[id[s1]] = 0;\n        hoge[id[s2]] = -x;\n      } else if (id.count(s1)==0) {\n        id[s1] = cnt++;\n        hoge[id[s1]] = hoge[id[s2]] + x;\n      } else if (id.count(s2)==0) {\n        id[s2] = cnt++;\n        hoge[id[s2]] = hoge[id[s1]] - x;\n      } else {\n        if (uf.findSet(id[s1], id[s2])) {\n          if (hoge[id[s1]] != hoge[id[s2]] + x) {\n            f = 1;\n          }\n        } else {\n          REP(j, cnt) {\n            if (uf.findSet(id[s2], j)) {\n              hoge[j] += hoge[id[s1]] - hoge[id[s2]] - x;\n            }\n          }\n        }\n      }\n      uf.unionSet(id[s1], id[s2]);\n    }\n    if(f)\n      cout << \"No\" << endl;\n    else\n      cout << \"Yes\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<cstdlib>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nconst int inf = 100000000;\nint dist[205][205];\n\nint main() {\n  int N,i,c,j,k;\n  string s,t,u,v,eq;\n  while(cin>>N, N) {\n    map<string,int> mp;\n\n    rep(i,205) {\n      rep(j,205) dist[i][j] = inf;\n      dist[i][i] = 0;\n    }\n\n    c = 0;\n    rep(i,N) {\n      cin>>v>>s>>eq>>u>>t;\n      u = u.substr(3);\n      int w = atoi(u.c_str());\n      if(mp.find(s) == mp.end()) {\n\tmp[s] = c;\n\tc++;\n      }\n      if(mp.find(t) == mp.end()) {\n\tmp[t] = c;\n\tc++;\n      }\n      dist[mp[s]][mp[t]] = w;\n      dist[mp[t]][mp[s]] = -w;\n    }\n\n    rep(k,c)\n      rep(i,c) rep(j,c)\n        dist[i][j] = min(dist[i][k] + dist[k][j], dist[i][j]);\n\n    rep(i,c) {\n      if(dist[i][i] < 0) {\n\tcout<<\"No\"<<endl;\n\tgoto NEXT;\n      }\n    }\n\n    cout<<\"Yes\"<<endl;\n  NEXT:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nint main(){\n  while(true){\n    int n,m=0;\n    int a,b,e;\n    string s1,s2;\n    char c,d;\n    int i,j,k;\n    cin>>n;\n    if(!n)break;\n    int graph[200][200];\n    for(i=0;i<200;i++)\n      for(j=0;j<200;j++)\n\tgraph[i][j] = 10000000;\n    vector<string> names(200);\n    names.clear();\n    for(i=0;i<n;i++){\n      cin>>a>>s1>>c>>b>>d>>e>>s2;\n      j=0,k=0;\n      for(;j<m;j++)if(names[j]==s1)break;\n      if(j==m){\n\tnames[j] = s1;\n\tm++;\n      }\n      for(;k<m;k++)if(names[k]==s2)break;\n      if(k==m){\n\tnames[k] = s2;\n\tm++;\n      }\n      graph[k][j] = e;\n      graph[j][k] = -e;\n    }\n    for(k=0;k<m;k++){\n      for(i=0;i<m;i++){\n\tfor(j=0;j<m;j++){\n\t  if(graph[i][k]+graph[k][j]<graph[i][j])graph[i][j]=graph[i][k]+graph[k][j];\n\t}\n      }\n    }\n    bool bb = true;\n    for(i=0;i<m;i++)\n      if(graph[i][i]<0)bb=false;\n    if(bb)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nbool warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n                // Ç¿çàINFæè¬³­Èé\n                if(prv!=INF&&d[j][i]+d[i][k]<INF){\n                    if(prv!=d[j][i]+d[i][k]){\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\nbool passed[101];\nbool no;\nvoid dfs(int s){\n    passed[s]=true;\n    for(int i = 0; i < V; i++){\n        if(i==s)continue;\n        if(d[s][i]!=INF){\n            if(passed[i]){\n                no=true;\n                return;\n            }\n            dfs(i);\n            if(no)\n                return;\n        }\n    }\n    passed[s]=false;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0)\n                d[dict[a]][dict[b]]=-cost;\n            else\n                d[dict[b]][dict[a]]=cost;\n        }\n        V=idx;\n        vector<int> roots;\n        for(int j = 0; j < idx; j++){\n            int cnt=0;\n            for(int i = 0; i < idx; i++){\n                if(i==j)continue;\n                if(d[i][j]!=INF)\n                    cnt++;\n            }\n            if(cnt==0)\n                roots.push_back(j);\n        }\n        no=false;\n        for(int i = 0; i < roots.size(); i++){\n            fill(passed,passed+101,false);\n            dfs(roots[i]);\n        }\n        bool f=warshall_floyd();\n        if(!f||no)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <vector>\n#include <map>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nint n, vis[256], rk[256];\nmap<string, int> dict;\nvector<pair<int, int> > g[256];\n\nint of(const string& s) {\n    if (dict.count(s) == 0) dict[s] = n++;\n    return dict[s];\n}\n\nbool visit(int at, int r) {\n    if (vis[at]) return rk[at] == r;\n    vis[at] = 1;\n    rk[at] = r;\n    rep (i, g[at].size()) {\n        if (!visit(g[at][i].first, r+g[at][i].second)) return false;\n    }\n    return true;\n}\n\nint main() {\n    for (;;) {\n        int m;\n        scanf(\"%d\", &m);\n        if (m == 0) return 0;\n        n = 0;\n        dict.clear();\n        rep (i, 256) g[i].clear();\n        rep (_, m) {\n            static char a[32], b[32];\n            int x;\n            scanf(\" 1 %s = 10^%d %s\", a, &x, b);\n            const int u = of(a);\n            const int v = of(b);\n            g[u].push_back(mp(v, -x));\n            g[v].push_back(mp(u, x));\n        }\n        rep (i, n) vis[i] = 0;\n        bool ans = true;\n        rep (i, n) if (!vis[i]) {\n            if (!visit(i, 0)) ans = false;\n        }\n        puts(ans ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#define P pair<string,int>\n#define PP pair<int,int>\n#define DEBUG false\nusing namespace std;\n\nint n;\nvector<PP> rl[110]; // 単位間の関係\nvector<string> v; // 一応単位の文字列を保持.インデックスはunitsと同じ。\n\nstring tab(int len){\n  string r=\"\";  for( int  i=0;i<len;i++ ) r+=\"  \";\n  return r;\n}\n\n\n/* 単位系が誤っているとfalseを返す */\nbool dfs(int i, int sum, int initP,int depth){\n  if( depth==n ) return false;\n\n  if(DEBUG)\n    cout << tab(depth) << v[i] << \" sum=\"<< sum << \" dpth=\" << depth << endl;\n  if( i==initP ){\n    if( sum==0 ) return true;\n    else return false;\n  }else{\n    if( sum==0 ) return false;\n  }\n\n  if( rl[i].size()<=1 )    return true;\n  depth++;\n  for( int j=0;j<(int)rl[i].size();j++ ){\n    if( rl[i][j].second>0 ) continue;\n    int nS = sum + rl[i][j].second;\n    if( dfs( rl[i][j].first,nS,initP,depth)==false )\n      return false;\n  }\n  return true;\n}\n\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int i=0;i<n;i++ ){\n    if( rl[i].size()<=1 ) continue;\n\n    if(DEBUG)cout << v[i] << \" ************************\" << endl;\n    for( int j=0;j<(int)rl[i].size();j++ ){\n      if( rl[i][j].second<0 ) continue;\n\n      if( dfs(rl[i][j].first,rl[i][j].second,i,0)==false )\n\treturn false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    map<string,int> units; // units[ a ] でaの配列番号が分かる\n    map<string,int>::iterator it;\n\n    v.clear();\n    for( int i=0;i<n;i++ )\n      rl[i].clear();\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() ){\n\tunits.insert( P(a,(int)units.size()) ); v.push_back( a );\n      }\n      if( (it=units.find( b ))==units.end() ){\n\tunits.insert( P(b,(int)units.size()) ); v.push_back( b );\n      }\n      int an=units[a], bn=units[b];\n      rl[ an ].push_back( PP(bn,x) );  rl[ bn ].push_back( PP(an,-x) );\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\ntypedef vector<pii> VP;\ntypedef vector<string> VS;\ntypedef priority_queue<int> PQ;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n//priority_queue<int,vector<int>, greater<int> > q2;\n\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> rank;\n\tvector<int> diff_weight;\n\n\tUnionFind(int n = 1, int SUM_UNITY = 0) {\n\t\tinit(n, SUM_UNITY);\n\t}\n\n\tvoid init(int n = 1, int SUM_UNITY = 0) {\n\t\tpar.resize(n); rank.resize(n); diff_weight.resize(n);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n\t}\n\n\tint root(int x) {\n\t\tif (par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\tint r = root(par[x]);\n\t\t\tdiff_weight[x] += diff_weight[par[x]];\n\t\t\treturn par[x] = r;\n\t\t}\n\t}\n\n\tint weight(int x) {\n\t\troot(x);\n\t\treturn diff_weight[x];\n\t}\n\n\tbool issame(int x, int y) {//same\n\t\treturn root(x) == root(y);\n\t}\n\n\tbool merge(int x, int y, int w) {//unite\n\t\tw += weight(x); w -= weight(y);\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (rank[x] < rank[y]) swap(x, y), w = -w;\n\t\tif (rank[x] == rank[y]) ++rank[x];\n\t\tpar[y] = x;\n\t\tdiff_weight[y] = w;\n\t\treturn true;\n\t}\n\n\tint diff(int x, int y) {//頂点間の距離\n\t\treturn weight(y) - weight(x);\n\t}\n};\n\nvoid solve(int N) {\n\tmap<string, int>id;\n\tUnionFind uni(210);\n\tint k = 1;\n\tbool F = 1;\n\tREP(i, N) {\n\t\tstring ichi, t1, eq, ten, t2;\n\t\tcin >> ichi >> t1 >> eq >> ten >> t2;\n\t\tint val = 0;\n\n\t\tif (ten[3] == '-') {\n\t\t\tint a = 4;\n\t\t\twhile (a < ten.size()) {\n\t\t\t\tval *= 10;\n\t\t\t\tval += ten[a] - '0';\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tval *= -1;\n\t\t}\n\t\telse {\n\t\t\tint a = 3;\n\t\t\twhile (a < ten.size()) {\n\t\t\t\tval *= 10;\n\t\t\t\tval += ten[a] - '0';\n\t\t\t\ta++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << val << endl;\n\t\tif (id[t1] == 0)id[t1] = k++;\n\t\tif (id[t2] == 0)id[t2] = k++;\n\t\tif (uni.issame(id[t1], id[t2])) {\n\t\t\t//cout << uni.diff(id[t1], id[t2]) << endl;\n\t\t\tif (uni.diff(id[t2], id[t1]) != val) {\n\t\t\t\tF = false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tuni.merge(id[t2], id[t1], val);\n\t\t}\n\t}\n\tif(F)cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn;\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tsolve(N);\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint n,m,e[200][200];\n\nint main()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tmap<string,int> id;\n\t\trep(i,n)rep(j,n)e[i][j]=inf;\n\t\t\n\t\tstring u1,u2,t; m=0;\n\t\trep(i,n)\n\t\t{\n\t\t\tcin>>t>>u1>>t>>t>>u2;\n\t\t\tif(!id.count(u1))id[u1]=m++;\n\t\t\tif(!id.count(u2))id[u2]=m++;\n\t\t\te[id[u1]][id[u2]]=atoi(t.substr(3).c_str());\n\t\t\te[id[u2]][id[u1]]=-e[id[u1]][id[u2]];\n\t\t}\n\t\trep(k,m)rep(i,m)rep(j,m)e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\t\tbool f=0;\n\t\trep(i,m)if(e[i][i]!=inf&&e[i][i]!=0)f=1;\n\t\tputs(f?\"No\":\"Yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nmap<string, vector<pair<string,int> > >m; //no direction graph\nvector<string> memo;\n\nint dfs(string &now, string &goal, int d){\n\tvector<pair<string,int> >v=m[now];\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i].first==goal&&v[i].second!=d)return 1;\n\t\tif(find(memo.begin(),memo.end(),v[i].first)==memo.end()){\n\t\t\tmemo.push_back(v[i].first);\n\t\t\tif(dfs(v[i].first,goal,d-v[i].second))return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar b1[17],b2[17];\nvoid main2(int n){\n\tint d,e=0;\n\tfor(;n;n--){\n\t\tscanf(\" 1 %s = 10^%d %s\",b1,&d,b2);\n\t\tif(!e){\n\t\t\tstring s1=b1,s2=b2;\n\t\t\tmemo.clear();\n\t\t\tif(dfs(s1,s2,d))e=1;\n\t\t\tm[s1].push_back(make_pair(s2,d));\n\t\t\tm[s2].push_back(make_pair(s1,-d));\n\t\t}\n\t}\n\tputs(e?\"No\":\"Yes\");\n}\nmain(){int n;for(;scanf(\"%d\",&n),n;)main2(n);}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nbool warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n                // Ç¿çàINFæè¬³­Èé\n                if(prv!=INF&&d[j][i]+d[i][k]<INF&&j!=k){\n                    if(prv!=d[j][i]+d[i][k]){\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0)\n                d[dict[a]][dict[b]]=-cost;\n            else\n                d[dict[b]][dict[a]]=cost;\n        }\n        V=idx;\n        bool f=warshall_floyd();\n        if(!f)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconstexpr int MAX = 1000;\n\nstruct Edge {\n    int to, cost;\n    Edge() {}\n    Edge(int to, int cost) :\n        to{to}, cost{cost} {}\n};\n\nvector<Edge> G[MAX];\nint dist[MAX];\n\nbool dfs(int v, int p, int d)\n{\n    if (dist[v] != -1) {\n        return (dist[v] != d);\n    }\n    dist[v] = d;\n\n    for (auto& g : G[v]) {\n        if (g.to == p) continue;\n        if (dfs(g.to, v, d + g.cost)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool run()\n{\n    int N;\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n\n    for (int i = 0; i < N; i++) {\n        G[i].clear();\n    }\n    \n    map<string, int> s2i;\n    \n    string t, u, v;\n    for (int i = 0; i < N; i++) {\n        cin >> u >> u;\n\n        if (s2i.count(u) == 0) {\n            s2i[u] = s2i.size();\n        }\n        \n        cin >> t >> t >> v;\n        t = t.substr(3);\n\n        if (s2i.count(v) == 0) {\n            s2i[v] = s2i.size();\n        }\n        \n        int num = stoi(t);        \n        G[s2i[v]].emplace_back(s2i[u], -num);\n        G[s2i[u]].emplace_back(s2i[v], num);\n    }\n    bool ok = 1;\n    for (int i = 0; i < (int)s2i.size(); i++) {\n        memset(dist, -1, sizeof(dist));\n        if (dfs(i, -1, 0)) {\n            ok = 0;\n            break;\n        }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n\nint main()\n{\n    while (run())\n        ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int, int> pii;\n\nstruct UnionFind_W {\n\tvector<pii> data;\n\tUnionFind_W(int size) : data(size, { -1,0 }) { }\n\tbool unionSet(int x, int y, int d) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tint ox = x,oy =y;\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tdata[x].first += data[y].first;\n\t\t\tdata[y].second = data[ox].second - data[oy].second+ d;\n\t\t\tdata[y].first = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tint findSet(int x, int y) { //x??????y?????????\n\t\tint rx = root(x), ry = root(y);\n\t\tif (rx == ry) {\n\t\t\treturn data[x].second - data[y].second;\n\t\t}\n\t\treturn INT_MAX;\n\t}\n\tint root(int x) {\n\t\tif (data[x].first < 0)\n\t\t\treturn x;\n\t\tint op = data[x].first;\n\t\tdata[x].first = root(data[x].first);\n\t\tdata[x].second += data[op].second;\n\t\treturn data[x].first;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)].first;\n\t}\n};\n\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n)) {\n\t\tif (!n)\n\t\t\treturn 0;\n\t\n\t\tUnionFind_W uf(n*2);\n\t\tmap<string, int> unit;\n\t\tchar str[17],str2[17];\n\t\tbool f = 1;\n\t\tREP(i, n) {\n\t\t\tint d;\n\t\t\tscanf(\"%*d%s%*s%*d%*c%d%s\", str, &d, str2);\n\t\t\tif (!unit.count(str))\n\t\t\t\tunit[str] = unit.size();\n\t\t\tif (!unit.count(str2))\n\t\t\t\tunit[str2] = unit.size();\n\n\t\t\tint he = uf.findSet(unit[str], unit[str2]);\n\t\t\tif (he == INT_MAX) {\n\t\t\t\tuf.unionSet(unit[str], unit[str2], d);\n\t\t\t}\n\t\t\telse if (he != -d) {\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\tf = 0;\n\t\t\t\trep(j, i, n-1) {\n\t\t\t\t\tscanf(\"%*d%s%*s%*d%*c%d%s\", str, &d, str2);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t\tprintf(\"Yes\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<map>\n#include<string>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint main(){\n  int n;\n  while(cin>>n, n){\n    int m = 0;\n    vector<vector<int> > g(200, vector<int>(200, -1));\n    map<string,int> type;\n    bool ans = true;\n\n    REP(i,n){\n      int o1, o2, o3;\n      string t1, t2;\n      char h;\n      cin>>o1>>t1>>h>>o2>>h>>o3>>t2;\n\n      int ti1, ti2;\n      if(type.find(t1) == type.end()) type[t1] = m++;\n      ti1 = type[t1];\n      if(type.find(t2) == type.end()) type[t2] = m++;\n      ti2 = type[t2];\n\n      if(g[ti1][ti2] != -1 && g[ti1][ti2] !=  o3) ans = false;\n      if(g[ti2][ti1] != -1 && g[ti2][ti1] != -o3) ans = false;\n      \n      if(o3 > 0) g[ti1][ti2] =  o3;\n      else       g[ti2][ti1] = -o3;\n    }\n\n    if(ans) REP(k,m) REP(i,m) REP(j,m){\n\tif(g[i][k] != -1 && g[k][j] != -1){\n\t  if(g[i][j] == -1){\n\t    g[i][j] = g[i][k] + g[k][j];\n\t  }else{\n\t    if(g[i][j] != g[i][k] + g[k][j])\n\t      ans = false;\n\t  }\n\t}\n    }\n\n    cout << (ans?\"Yes\":\"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\ntypedef pair<int, int> P;\n\nint d[101][101];\n\nconst int INF = 1<<29;\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\trep(i, 101) rep(j, 101) d[i][j] = INF;\n\t\tmap<string, int> num;\n\t\tint idx = 0;\n\t\tbool ans = true;\n\t\trep(i, n){\n\t\t\tstring a, b;\n\t\t\tstring c;\n\t\t\tcin >> c >> a >> c >> c >> b;\n\t\t\tif(!num[a]) num[a] = ++idx;\n\t\t\tif(!num[b]) num[b] = ++idx;\n\t\t\tint x = atoi(c.substr(3).c_str());\n\t\t\t// a = b+x\n\t\t\tint l = num[a], r = num[b];\n\t\t\trep(k, 2){\n\t\t\t\tif(d[l][r] == INF){\n\t\t\t\t\td[l][r] = x;\n\t\t\t\t}else{\n\t\t\t\t\tif(d[l][r] != x) ans = false;\n\t\t\t\t}\n\t\t\t\tswap(l, r);\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tfor(int j = 1; j <= idx; j++){\n\t\t\t\tfor(int k = 1; k <= idx; k++){\n\t\t\t\t\tif(d[k][j] == INF) continue;\n\t\t\t\t\tfor(int l = 1; l <= idx; l++){\n\t\t\t\t\t\tif(d[j][l] == INF) continue;\n\t\t\t\t\t\td[k][l] = min(d[k][l], d[k][j]+d[j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ans?\"Yes\":\"No\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 100*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n};\n\nbool relax(const vector<vector<pair<int,int> > > &graph, vector<int> &dist) {\n    const int N = graph.size();\n    bool updated = false;\n    for(int i = 0; i < N; ++i) {\n        const vector<pair<int,int> > &edges = graph[i];\n        for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n            const int nc = dist[i] + it->second;\n            if(dist[it->first] > nc) {\n                dist[it->first] = nc;\n                updated = true;\n            }\n        }\n    }\n    return updated;\n}\n\nvector<vector<pair<int,int> > > v(100);\nvector<int> dist(100);\nvector<unsigned char> visited(100);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < N; ++i) {\n            v[i].clear();\n            dist[i] = INF;\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            for(string::iterator it = line.begin(); it != line.end(); ++it) {\n                if(*it == '=' || *it == '^') *it = ' ';\n            }\n            istringstream is(line);\n            string unit_left, unit_right;\n            int ord;\n            int tmp;\n            is >> tmp >> unit_left >> tmp >> ord >> unit_right;\n            //sscanf(line.c_str(), \"%*d %s = %*d^%d %s \", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        // テ」ツ?敕」ツつ古」ツ?榲」ツつ古」ツ?ョテゥツ?」テァツオツ静ヲツ按静・ツ按?」ツ?ォテ」ツ?、テ」ツ?催ッツシツ?テ」ツδ偲」ツδシテ」ツδ嘉」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ィテ」ツ?凖」ツつ凝ッツシツ?\n        fill(visited.begin(), visited.end(), 0);\n        queue<int> q;\n        for(int i = 0; i < N; ++i) {\n            if(!visited[i]) {\n                dist[i] = 0;\n                visited[i] = 1;\n                q.push(i);\n                while(!q.empty()) {\n                    int cur = q.front();\n                    q.pop();\n                    const vector<pair<int,int> > &edges = v[cur];\n                    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                        if(!visited[it->first]) {\n                            visited[it->first] = 1;\n                            q.push(it->first);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Bellman-ford\n        for(int phase = 0; phase < N; ++phase) {\n            if(!relax(v, dist)) break;\n        }\n        if(relax(v, dist)) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\nconst int MAX_M = 101;\nconst int INF = 1<<24;\nmap<string, int> id;\nint G[MAX_M][MAX_M];\nint M;\n\n\nint getId(string s) {\n  if(id.find(s) == id.end()) {\n    id[s] = M++;\n  }\n  return id[s];\n}\n\nbool solve() {\n  for(int k = 0; k < M; ++k) {\n    for(int s = 0; s < M; ++s) {\n      for(int d = 0; d < M; ++d) {\n\tif(G[s][k] == INF || G[k][d] == INF) continue;\n\tif(G[s][d] == INF) {\n\t  G[s][d] = G[s][k] + G[k][d];\n\t} else if(G[s][d] != G[s][k] + G[k][d]) {\n\t  return false;\n\t}\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    M = 0;\n    id.clear();\n    fill(G[0], G[MAX_M], INF);\n    for(int i = 0; i < N; ++i) {\n      string in[5];\n      for(int j = 0; j < 5; ++j) cin >> in[j];\n      int a = getId(in[1]);\n      int b = getId(in[4]);\n      int cost = atoi((in[3].substr(3)).c_str());\n      G[a][b] = cost;\n      G[b][a] = -cost;\n    }\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tstring lhs;\n\tstring rhs;\n\tint power;\n\tData(string _l,string _r, int _p){\n\t\tlhs = _l;\n\t\trhs = _r;\n\t\tpower = _p;\n\t}\n};\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Data> relations;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint num;\n\t\t\tstring lhs;\n\t\t\tstring eq;\n\t\t\tstring rhs;\n\t\t\tstring tmp;\n\n\t\t\tcin >> num >> lhs >> eq >> tmp >> rhs;\n\t\t\tint base,pow;\n\t\t\tsscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n\t\t\trelations.push_back(Data(lhs,rhs,pow));\n\t\t}\n\n\t\tmap<string,set<int> > vals;\n\n\t\tbool isok = true;\n\t\tvals[relations[0].rhs].insert(0);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(set<int>::iterator it = vals[relations[j].rhs].begin();it != vals[relations[j].rhs].end();it++){\n\t\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\t\tvals[relations[j].lhs].insert(relations[j].power + *it);\n\t\t\t\t}\n\t\t\t\t//sort(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t//vector<int>::iterator it = unique(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t//vals[relations[j].lhs].resize( it - vals[relations[j].lhs].begin() );\n\n\t\t\t\t//if(vals[relations[j].lhs].size() > 1) isok = false;\n\t\t\t}\n\n\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(set<int>::iterator it = vals[relations[j].lhs].begin();it != vals[relations[j].lhs].end();it++){\n\t\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\t\tvals[relations[j].rhs].insert(-relations[j].power + *it);\n\t\t\t\t}\n\t\t\t\t//sort(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t//vector<int>::iterator it = unique(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t//vals[relations[j].rhs].resize( it - vals[relations[j].rhs].begin() );\n\t\t\t\t//if(vals[relations[j].rhs].size() > 1) isok = false;\n\t\t\t}\n\t\t}\n\n\t\tfor(map<string,set<int> >::iterator it = vals.begin(); it != vals.end(); it++){\n\t\t\tif(it->second.size() > 1) isok = false;\n\t\t}\n\t\tprintf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#define P pair<string,int>\n#define PP pair<int,int>\nusing namespace std;\n\nint n;\nvector<PP> rl[110]; // 単位間の関係\n\nset<int> st;\n\n/* 単位系が誤っているとfalseを返す */\nbool dfs(int i, int sum, int initP,int depth){\n  //  if( depth==n+1 ) return false;\n\n  if( i==initP ){\n    if( sum==0 ) return true;\n    else return false;\n  } /* else{\n    if( sum==0 ) return false;\n    }*/\n\n  if( rl[i].size()<=1 )    return true;\n  depth++;\n  for( int j=0;j<(int)rl[i].size();j++ ){\n    //    if( rl[i][j].second>0 ) continue;\n\n    if( st.find( rl[i][j].first )!= st.end() )\n      continue; // 既に通ったノード\n    st.insert( rl[i][j].first );\n    int nS = sum + rl[i][j].second;\n    if( dfs( rl[i][j].first,nS,initP,depth)==false )\n      return false;\n    st.erase( rl[i][j].first );\n  }\n  return true;\n}\n\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int i=0;i<n;i++ ){\n    if( rl[i].size()<=1 ) continue;\n\n    for( int j=0;j<(int)rl[i].size();j++ ){\n      //      if( rl[i][j].second<0 ) continue;\n\n      st.clear();\n      if( dfs(rl[i][j].first,rl[i][j].second,i,0)==false )\n\treturn false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    map<string,int> units; // units[ a ] でaの配列番号が分かる\n    map<string,int>::iterator it;\n\n    for( int i=0;i<n;i++ )      rl[i].clear();\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() )\n\tunits.insert( P(a,(int)units.size()) );\n      if( (it=units.find( b ))==units.end() )\n\tunits.insert( P(b,(int)units.size()) );\n\n      int an=units[a], bn=units[b];\n      rl[ an ].push_back( PP(bn,x) );  rl[ bn ].push_back( PP(an,-x) );\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int hoge[2*n];\n    UnionFind uf(2*n);\n    map<string,int> id;\n    int cnt = 0;\n    bool f = 0;\n    REP(i,n) {\n      int tmp;\n      string tmps, s1,s2,xx;\n      cin>>tmp>>s1>>tmps>>xx>>s2;\n      int x = atoi(xx.substr(3).c_str());\n      if (id.count(s1)==0 && id.count(s2)==0) {\n        id[s1] = cnt++;\n        id[s2] = cnt++;\n        hoge[id[s1]] = 0;\n        hoge[id[s2]] = -x;\n      } else if (id.count(s1)==0) {\n        id[s1] = cnt++;\n        hoge[id[s1]] = hoge[id[s2]] + x;\n      } if (id.count(s2)==0) {\n        id[s2] = cnt++;\n        hoge[id[s2]] = hoge[id[s1]] - x;\n      } else {\n        if (uf.findSet(id[s1], id[s2])) {\n          if (hoge[id[s1]] != hoge[id[s2]] + x) {\n            f = 1;\n          }\n        } else {\n          REP(j, cnt) {\n            if (uf.findSet(id[s2], j)) {\n              hoge[j] += hoge[id[s1]] - hoge[id[s2]] - x;\n            }\n          }\n        }\n      }\n      uf.unionSet(id[s1], id[s2]);\n    }\n    if(f)\n      cout << \"No\" << endl;\n    else\n      cout << \"Yes\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<string>v; int n, a[1000], b[1000], c[1000]; string s1[1000], s2[1000], t[1000];\nvector<int>u[1000]; int group[1000], dist[1000]; bool OK = true;\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\n\nvoid merge(int a, int b, int c) {\n\tif (group[a] == group[b]) { if (dist[a] - dist[b] != c)OK = false; return; }\n\tint w1 = group[a], w2 = group[b];\n\tint sa = (dist[a] - dist[b]) - c;\n\tfor (int i : u[w2])dist[i] += sa;\n\tfor (int i : u[w2])u[w1].push_back(i);\n\tfor (int i : u[w2])group[i] = w1;\n\tsort(u[w1].begin(), u[w1].end());\n\tu[w2].clear();\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; v.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring a1, a2; cin >> a1 >> s1[i] >> a2 >> t[i] >> s2[i];\n\t\t\tv.push_back(s1[i]); v.push_back(s2[i]);\n\t\t}\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); OK = true;\n\t\tfor (int i = 0; i < n; i++) { u[i].clear(); u[i].push_back(i); group[i] = i; a[i] = s(s1[i]); b[i] = s(s2[i]); c[i] = stoi(t[i].substr(3, t[i].size() - 3)); }\n\t\tfor (int i = 0; i < n; i++) { merge(a[i], b[i], c[i]); }\n\t\tif (OK == true)cout << \"Yes\" << endl; else cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<set>\n#include<cstdio>\n#include<cassert>\n#define F first\n#define S second\n#define inf (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nstruct P\n{\n  string unit;\n  int mpower;\n  int upower;\n  P(string unit=\"$\",int upower=-inf,int mpower=-inf):unit(unit),upower(upower),mpower(mpower){}\n};\nvector<vector<P> > G(210);\nmap<string,int> exist;\n\nint toPower(string s)\n{\n  if(s == \"1\")return 0;\n  int pos = 0;\n  rep(i,s.size())\n    {\n      if(s[i] == '^')\n\t{\n\t  pos = i+1;\n\t  break;\n\t}\n    }\n  return (atoi)(s.substr(pos,s.size()-pos).c_str());\n}\n\nbool used[210];\nint isok;//-1 -> No, 0 => Not yet, 1 -> Ok\n\nvoid dfs(string now,string target,int power,int target_power)\n{\n  if(isok != 0)return;\n  if(now == target)\n    {\n      isok = (power == target_power?1:-1);\n      return;\n    }\n  int index = exist[now];\n  if(used[index])return;\n  used[index] = true;\n\n  rep(i,G[index].size())\n    {\n      P p = G[index][i];\n      int next_index = exist[p.unit];\n      if(used[next_index])continue;\n      dfs(p.unit,target,power+(p.mpower==0?p.upower:-p.mpower),target_power );\n    }\n}\n\nbool check(string u1,string u2,int power)\n{\n  rep(i,110)used[i] = false;\n  isok = 0;\n\n  dfs(u1,u2,0,power);\n  return isok == 1;\n}\n\nbool reachable;\n\nvoid move(int now,int target)\n{\n  if(now == target)\n    {\n      reachable = true;\n      return;\n    }\n\n  if(used[now])return;\n  used[now] = true;\n\n  rep(i,G[now].size())\n    {\n          \n      assert(exist.count(G[now][i].unit));\n\n      move(exist[G[now][i].unit],target);\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      assert(N <= 100);\n      rep(i,N)G[i].clear();\n      int index = 0;\n      exist.clear();\n      bool result = true;\n      rep(i,N)\n\t{\n\t  string v1,unit1,v2,unit2,eq;\n\t  cin >> v1 >> unit1 >> eq >> v2 >> unit2;\n\t  if(unit1 == unit2)\n\t    {\n\t      if(v2 == \"10^0\")continue;\n\t      else            result = false;\n\t      continue;\n\t    }\n\t  //assert(unit1 != unit2);\n\t  if(!result)continue;\n\t  //cout << toPower(v1) << \" \" << unit1 << \" = \"<< toPower(v2) << \" \" << unit2 << endl;\n\t  if(exist.count(unit1) && exist.count(unit2))\n\t    {\n\t      rep(i,N)used[i] = false;\n\t      reachable = false;\n\t      move(exist[unit1],exist[unit2]);\n\t      if(reachable)\n\t\t{\n\t\t  int p1 = toPower(v1);\n\t\t  int p2 = toPower(v2);\n\t\t  result = check(unit1,unit2,p2);\n\t\t  //cout << \"result = \" << result << endl;\n\t\t}\n\t      else\n\t\t{\n\t\t  goto Insert;\n\t\t}\n\t      continue;\n\t    }\n\n\t  //cout << \"not exists\" << endl;\n\t  if(!exist.count(unit1))exist[unit1] = index++;\n\t  if(!exist.count(unit2))exist[unit2] = index++;\n\tInsert:;\n\t  int index1 = exist[unit1];\n\t  int index2 = exist[unit2];\n\t  G[index1].push_back(P(unit2,toPower(v2),toPower(v1)));\n\t  G[index2].push_back(P(unit1,toPower(v1),toPower(v2)));\n\t}\n      cout << (result?\"Yes\":\"No\") << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct Node{\n  vector<int> con;\n  vector<int> cost;\n};\n\nconst int inf = 1<<27;\n\nbool BellmanFord(const vector<Node> &Graph, int s, int A[], bool vis[])\n{\n  bool ret = false;\n  const int n = Graph.size();\n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int e = 0; e < (int)Graph[i].con.size(); ++e){\n        int dst = Graph[i].con[e];\n        int src = i;\n        if( A[dst] > A[src] + Graph[i].cost[e] ){\n          A[dst] = A[src] + Graph[i].cost[e];\n          \n          if( k == n-1 ){\n            A[dst] = -inf;\n            ret = true;\n          }\n        }\n      }\n    }\n  \n  }\n  return ret;\n}\n\nint main()\n{\n  int n;\n  while(cin>>n&&n){\n    // A km = 10^B km\n    // A == 1 , B == 0\n    int id = 0;\n    vector<Node> Graph(100);\n    map<string,int> D;\n    for(int i = 0; i < n; ++i){\n      char c;\n      string A,B;\n      int power;\n      cin >> c >> A >> c >> c >> c >> c >> power >> B;\n      //cout << A << ' ' << power << ' ' << B << endl;\n      if( D.find(A) == D.end() ){\n        D[A] = id++;\n      }\n      if( D.find(B) == D.end() ){\n        D[B] = id++;\n      }\n      Graph[D[A]].con.push_back( D[B] );\n      Graph[D[A]].cost.push_back( power );\n      Graph[D[B]].con.push_back( D[A] );\n      Graph[D[B]].cost.push_back( -power );\n    }\n    Graph.resize( id );\n    bool vis[id];\n    int A[id];\n    for(int i = 0; i < id; ++i){\n      vis[i] = false;\n      A[id] = inf*2;\n    }\n    bool res = true;\n    for(int i = 0; i < id; ++i){\n      if( !vis[i] ){\n        if( BellmanFord( Graph, i, A, vis ) ){\n          res = false;\n        }\n      }\n    }\n\n    if( res ){\n      puts(\"Yes\");\n    }else{\n      puts(\"No\");\n    }\n                 \n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_UN = MAX_N * 2;\n\nconst int INF = 1 << 28;\n\n/* typedef */\n\ntypedef map<string,int> msi;\n\n/* global variables */\n\nint n, un;\nmsi umap;\nint dp[MAX_UN][MAX_UN];\n\n/* subroutines */\n\nint unit2id(string unit) {\n  msi::iterator mit = umap.find(unit);\n  if (mit == umap.end()) {\n    umap[unit] = un;\n    return un++;\n  }\n  return mit->second;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    un = 0;\n    umap.clear();\n\n    for (int i = 0; i < 2 * n; i++) {\n      for (int j = 0; j < 2 * n; j++) dp[i][j] = INF;\n      dp[i][i] = 0;\n    }\n\n    for (int i = 0; i < n; i++) {\n      string dmy0, ua, dmy1, exp, ub;\n      cin >> dmy0 >> ua >> dmy1 >> exp >> ub;\n\n      int aid = unit2id(ua);\n      int bid = unit2id(ub);\n\n      int sign = 1;\n      int e = 0;\n      int pos = 3;\n      if (exp[pos] == '-') {\n\tsign = -1;\n\tpos++;\n      }\n      while (pos < exp.length())\n\te = (10 * e) + (exp[pos++] - '0');\n      e *= sign;\n\n      dp[aid][bid] = e;\n      dp[bid][aid] = -e;\n      //printf(\"aid=%d,bid=%d,e=%d\\n\", aid, bid, e);\n    }\n\n    bool ok = true;\n    for (int k = 0; ok && k < un; k++)\n      for (int i = 0; ok && i < un; i++)\n\tfor (int j = 0; ok && j < un; j++) {\n\t  if (dp[i][k] < INF && dp[k][j] < INF) {\n\t    int dij = dp[i][k] + dp[k][j];\n\t    if (dp[i][j] >= INF) {\n\t      dp[i][j] = dij;\n\t      dp[j][i] = -dij;\n\t    }\n\t    else if (dp[i][j] != dij) {\n\t      ok = false;\n\t      //printf(\"i,j,k=%d,%d,%d: %d,%d,%d\\n\",\n\t      //i, j, k, dp[i][j], dp[i][k], dp[k][j]);\n\t    }\n\t  }\n\t}\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<map>\n#include<string>\nusing namespace std;\n\n#define INF 100000\n\nint main()\n{\t\n\tint n;\n\tstring temp;\n\tint a;\n\tint cost[201][201],minicost[201];\n\twhile(cin>>n && n!=0){\n\n\t\tfor(int i=0;i<=200;i++){\n\t\t\tfor(int j=0;j<=200;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t\tminicost[i]=INF;\n\t\t}\n\n\n\t\tmap<string,int> Idx;\n\t\tint num=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a;//1\n\t\t\tstring s,t,p; cin>>s>>temp>>p>>t;\n\t\t\tif(!Idx.count(s)){Idx[s]=num++;}\n\t\t\tif(!Idx.count(t)){Idx[t]=num++;}\n\t\t\tstd::istringstream is(p);\n\t\t\tint k;\n\t\t\tchar taa;\n\t\t\tis>>a>>taa>>k;\n\t\t\tcost[Idx[s]][Idx[t]]=k;\n\t\t\tcost[Idx[t]][Idx[s]]=-k;\n\t\t}\n\n\t\tint count=0;\n\t\twhile(true){\n\t\t\tbool update=false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n//\t\t\t\t\tif(cost[i][j]<INF){\n\t\t\t\t\t\tif(minicost[j]>minicost[i]+cost[i][j]){\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\tminicost[j]=minicost[i]+cost[i][j];\n//\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update){cout<<\"Yes\"<<endl;break;}\n\t\t\tcount++;\n\t\t\tif(count>n+1){cout<<\"No\"<<endl;break;}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nbool visited[200];\nint c[200];\n\nbool dfs(vector<vector<pair<int, int> > > &edge, int now, int cost) {\n    if (visited[now])return cost == c[now];\n    c[now] = cost;\n    visited[now] = true;\n    bool res = true;\n    rep(i, edge[now].size()) {\n        int next = edge[now][i].first;\n        int ncost = edge[now][i].second;\n        res &= dfs(edge, next, cost + ncost);\n    }\n    return res;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    int n;\n    while(1) {\n        cin >> n;\n        map<string, int> v;\n        vector<vector<pair<int, int> > > edge(2*n);\n        if (n == 0)break;\n        int cnt = 0;\n        rep(i,n) {\n            int idummy;\n            char cdummy;\n            string s[2],sdummy;\n            int cost;\n            cin >> idummy >> s[0] >> sdummy >> idummy >> cdummy >> cost >> s[1];\n            rep(j,2) {\n                if (v.find(s[j]) == v.end()) {\n                    v[s[j]] = cnt;\n                    cnt++;\n                }\n            }\n            edge[v[s[0]]].push_back(make_pair(v[s[1]], cost));\n            edge[v[s[1]]].push_back(make_pair(v[s[0]], -cost));\n        }\n        bool ok = true;\n        rep(i, cnt) {\n            rep(j,cnt) {\n                visited[j] = false;\n            }\n            ok &= dfs(edge, i, 0);\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nbool warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n                // Ç¿çàINFæè¬³­Èé\n                if(prv!=INF&&d[j][i]+d[i][k]<INF){\n                    if(prv!=d[j][i]+d[i][k]){\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0){\n                d[dict[a]][dict[b]]=-cost;\n            }\n            else{\n                d[dict[b]][dict[a]]=cost;\n            }\n        }\n        V=idx;\n        bool f=warshall_floyd();\n        if(!f)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nmap<string,int> done;\nmap<string , vector< pair<string,int> > > graph;\nbool flag;\n\nvoid dfs(string p,int cost){\n\tif(done.find(p) != done.end()){\n\t\tif(cost != done[p]) flag = false;\n\t\treturn;\n\t}else{\n\t\tdone[p] = cost;\n\t}\n\tvector<pair<string,int> > r = graph[p];\n\tfor(int i = 0 ; i < r.size() ; i++){\n\t\tdfs( r[i].first , cost + r[i].second );\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n , n){\n\t\tgraph.clear();\n\t\tvector<string> vertex;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a,b,c,d;\n\t\t\tcin >> d >> a >> d >> c >> b;\n\t\t\tc = c.substr(c.find(\"^\")+1);\n\t\t\tint cost = atoi(c.c_str());\n\t\t\tgraph[b].push_back(make_pair(a,cost));\n\t\t\t//graph[a].push_back(make_pair(b,-cost));\n\t\t\tvertex.push_back(a);\n\t\t\tvertex.push_back(b);\n\t\t}\n\t\tsort(vertex.begin(),vertex.end());\n\t\tvertex.erase(unique(vertex.begin(),vertex.end()),vertex.end());\n\t\tbool ans = true;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdone.clear();\n\t\t\tflag = true;\n\t\t\tdfs(vertex[i] , 0);\n\t\t\tans &= flag;\n\t\t}\n\t\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int nn = 0;\n    string str;\n    getline(cin,str);\n    map<string,int> m;\n    vector<vector<int> > v;\n    v.assign(n*2, vector<int>(n*2,INF));\n    while(n--){\n      string str2, str3;\n      bool f = false, f2 = false, minus = false;\n      int a = 0;\n      getline(cin,str);\n\n      for(int i=2;i<str.size();i++){\n\tif(!f && !f2 && str[i] != ' '){\n\t  str2 += str[i];\n\t  //str2.insert(str2.size(),1,str[i]);\n\t}\n\telse if(!f && !f2 && str[i] == ' '){\n\t  f = true;\n\t  i += 6;\n\t  if(str[i] == '-'){\n\t    minus = true;\n\t    i++;\n\t    a = str[i] - '0';\n\t    a *= -1;\n\t  }\n\t  else a = str[i] - '0';\n\t}\n\telse if(!f2 && str[i] != ' '){\n\t  a *= 10;\n\t  if(minus) a -= str[i] - '0';\n\t  else a += str[i] - '0';\n\t}\n\telse if(!f2 && str[i] == ' ') f2 = true;\n\telse{\n\t  str3 += str[i];\n\t  //str3.insert(str3.size(),1,str[i]);\n\t}\n      }\n      if(m.find(str2) == m.end()) m[str2] = nn++;\n      if(m.find(str3) == m.end()) m[str3] = nn++;\n      //cout << str2 << \" \" << str3 << \" \" << a << endl;\n      v[m[str2]][m[str3]] = a;\n      v[m[str3]][m[str2]] = -1 * a;\n    }\n\n    bool ans = true;\n\n    for(int k=0;k<v.size();k++){\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v.size();j++){\n\t  if(i != j && v[i][j] == INF && v[i][k] < INF && v[k][j] < INF) v[i][j] = v[i][k] + v[k][j];\n\t}\n      }\n    }\n\n    for(int k=0;k<v.size();k++){\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v.size();j++){\n\t  if(v[i][j] >= INF || v[i][k] >= INF || v[k][j] >= INF) continue;\n\t  if(v[i][j] != v[i][k] + v[k][j]){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    /*for(int i=0;i<v.size();i++){\n      for(int j=0;j<v.size();j++){\n\tif(v[i][j] == INF) cout << \" I \";\n\telse printf(\"%2d \",v[i][j]);\n      }\n      cout << endl;\n      }*/\n\n    if(ans) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nmap <string,int> M;\nvector <P> e[101];\nbool used[101];\nint C[101];\n\nbool check(int ima,int prev,int cost){\n  int size=e[ima].size();\n  if(used[ima])return (cost-C[ima])==0;\n  used[ima]=1,C[ima]=cost;\n\n  for(int i=0;i<size;i++){\n    int nx=e[ima][i].f;\n    if(nx!=prev&&!check(nx,ima,cost+e[ima][i].s))return 0;\n  }\n  return 1;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){;\n    for(int i=0;i<100;i++)e[i].clear();\n    M.clear();\n\n    int N=0;\n    for(int i=0;i<n;i++){\n      string a,b,c,d,E;\n      cin>>a>>b>>c>>d>>E;\n      if(!M.count(b))M[b]=N++;\n      if(!M.count(E))M[E]=N++;\n      int num=0,j=3,flg=1;\n      if(d[3]=='-')flg=-1,j=4;\n      while(j<d.size())num=num*10+d[j++]-'0';\n      e[M[b]].push_back(P(M[E],num*flg));\n      e[M[E]].push_back(P(M[b],-num*flg));\n    }\n\n    int ans=1;\n    for(int i=0;i<N;i++){\n      memset(used,0,sizeof(used));\n      memset(C,0,sizeof(C));\n      ans*=check(i,-1,0);\n    }\n    cout <<(ans? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\nusing T = tuple<int, int, int>;\n\nint main() {\n        int n;\n        while (scanf(\"%d\", &n) && n) {\n                getchar();\n                map<string, int> mp;\n                int nodes = 0;\n                vector<T> es;\n                for (int i = 0; i < n; i ++) {\n                        char ss[1024], tt[1024];\n                        int val;\n                        scanf(\"1 %s = 10^%d %s\", ss, &val, tt);\n                        getchar();\n                        string s = ss;\n                        string t = tt;\n                        if (!mp.count(s)) mp[s] = nodes ++;\n                        if (!mp.count(t)) mp[t] = nodes ++;\n                        es.push_back(make_tuple(mp[s], mp[t], val));\n                }\n                vector<vector<pair<int, int>>> g(nodes);\n                for (int i = 0; i < n; i ++) {\n                        int a, b, d;\n                        tie(a, b, d) = es[i];\n                        g[a].emplace_back(b, d);\n                        g[b].emplace_back(a, -d);\n                }\n                vector<bool> used(nodes, false);\n                vector<int> dist(nodes);\n                bool ans = true;\n                function<void (int, int)> dfs = [&](int u, int d) {\n                        used[u] = true;\n                        dist[u] = d;\n                        for (auto e : g[u]) {\n                                if (!used[e.first]) {\n                                        dfs(e.first, d + e.second);\n                                } else if (dist[e.first] != d + e.second) {\n                                        ans = false;\n                                }\n                        }\n                };\n                for (int i = 0; i < nodes; i ++) if (!used[i]) {\n                        dfs(i, 0);\n                }\n                puts(ans ? \"Yes\" : \"No\");\n        }\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tstring lhs;\n\tstring rhs;\n\tint power;\n\tData(string _l,string _r, int _p){\n\t\tlhs = _l;\n\t\trhs = _r;\n\t\tpower = _p;\n\t}\n};\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Data> relations;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint num;\n\t\t\tstring lhs;\n\t\t\tstring eq;\n\t\t\tstring rhs;\n\t\t\tstring tmp;\n\n\t\t\tcin >> num >> lhs >> eq >> tmp >> rhs;\n\t\t\tint base,pow;\n\t\t\tsscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n\t\t\trelations.push_back(Data(lhs,rhs,pow));\n\t\t}\n\n\t\tmap<string,vector<int> > vals;\n\n\t\tbool isok = true;\n\t\tvals[relations[0].rhs].push_back(1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(vals[relations[j].rhs].size() > 0){\n\t\t\t\t\tvals[relations[j].lhs].push_back(relations[j].power + vals[relations[j].rhs][0]);\n\t\t\t\t\tsort(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t\tvector<int>::iterator it = unique(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t\tvals[relations[j].lhs].resize( it - vals[relations[j].lhs].begin() );\n\n\t\t\t\t\tif(vals[relations[j].lhs].size() > 1) isok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(vals[relations[j].lhs].size() > 0){\n\t\t\t\t\tvals[relations[j].rhs].push_back(-relations[j].power + vals[relations[j].lhs][0]);\n\t\t\t\t\tsort(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t\tvector<int>::iterator it = unique(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t\tvals[relations[j].rhs].resize( it - vals[relations[j].rhs].begin() );\n\n\t\t\t\t\tif(vals[relations[j].rhs].size() > 1) isok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconstexpr int MAX = 514;\nconstexpr int UNVISITED = (1 << 25);\n\nstruct Edge {\n    int to, cost;\n    Edge() {}\n    Edge(int to, int cost) :\n        to{to}, cost{cost} {}\n};\n\nvector<Edge> G[MAX];\nint dist[MAX];\n\nbool dfs(int v, int p, int d)\n{\n    if (dist[v] != UNVISITED) {\n        return (dist[v] != d);\n    }\n    \n    dist[v] = d;\n    for (const auto& g : G[v]) {\n        if (g.to == p) continue;\n        if (dfs(g.to, v, d + g.cost)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool run()\n{\n    int N;\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        G[i].clear();\n    }\n    \n    int n = 0;\n    map<string, int> s2i;\n    \n    string t, u, v;\n    for (int i = 0; i < N; i++) {\n        cin >> u >> u;\n\n        if (s2i.count(u) == 0) {\n            s2i[u] = n++;\n        }\n        \n        cin >> t >> t >> v;\n        t = t.substr(3);\n\n        if (s2i.count(v) == 0) {\n            s2i[v] = n++;\n        }\n        \n        int num = stoi(t);        \n        G[s2i[v]].emplace_back(s2i[u], -num);\n        G[s2i[u]].emplace_back(s2i[v], num);\n    }\n   \n    bool ok = 1;\n    for (int i = 0; i < n; i++) {\n        fill(dist, dist + MAX, UNVISITED);\n        if (dfs(i, -1, 0)) {\n            ok = 0;\n            break;\n        }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n\nint main()\n{\n    while (run())\n        ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntemplate <typename T>\nstruct UF {\n  int n;\n  T d;\n  vector<int> r, p;\n  vector<T> ws;\n  UF() {}\n  UF(int sz, T d_) :\n    n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n  int find(int x) {\n    if ( x == p[x] ) {\n      return x;\n    } else {\n      int t = find(p[x]);\n      ws[x] += ws[p[x]];\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x) {\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w) {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x); y = find(y);\n    if ( x == y ) return;\n    if ( r[x] < r[y] ) swap(x, y), w = -w;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x, int y) {\n    return weight(y) - weight(x);    \n  }\n};\n\nsigned main() {\n  int n;\n  while ( cin >> n, n ) {\n    bool flag = true;    \n    UF<int> uf(2*n+1, 0);\n    map<string, int> stoi;\n    int cnt = 0;\n    for ( int i = 0; i < n; i++ ) {\n      int a;\n      string b, c, d, e;\n      cin >> a >> b >> c >> d >> e;      \n      if ( !flag ) continue;\n      if ( !stoi.count(b) ) stoi[b] = cnt++;\n      if ( !stoi.count(e) ) stoi[e] = cnt++;\n\n      int numd = 0;\n      for ( int i = 0; i < (int)d.size(); i++ ) {\n\tif ( d[i] == '^' ) {\n\t  i++;\t  \n\t  int mi = 1;\t  \n\t  if ( d[i] == '-' ) mi = -1, i++;\n\t  for ( ; i < (int)d.size(); i++ ) {\n\t    numd *= 10;\n\t    numd += d[i]-'0';\t    \n\t  }\n\t  numd *= mi;       \n\t}\n      }\n      // cout << stoi[b] << \" \" <<  stoi[e] << endl;\n      if ( uf.same(stoi[b], stoi[e]) && uf.diff(stoi[b], stoi[e]) != numd ) {\t\n\tflag = false;\n\tcontinue;\t\n      }\n      uf.unite(stoi[b], stoi[e], numd);\n      // cout << uf.diff(stoi[e], stoi[b]) << endl;\n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<set>\n#include<cstdio>\n#include<cassert>\n#define F first\n#define S second\n#define inf (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nstruct P\n{\n  string unit;\n  int mpower;\n  int upower;\n  P(string unit=\"$\",int upower=-inf,int mpower=-inf):unit(unit),upower(upower),mpower(mpower){}\n};\nvector<vector<P> > G(110);\nmap<string,int> exist;\n\nint toPower(string s)\n{\n  if(s == \"1\")return 0;\n  int pos = 0;\n  rep(i,s.size())\n    {\n      if(s[i] == '^')\n\t{\n\t  pos = i+1;\n\t  break;\n\t}\n    }\n  return (atoi)(s.substr(pos,s.size()-pos).c_str());\n}\n\nbool used[110];\nint isok;//-1 -> No, 0 => Not yet, 1 -> Ok\n\nvoid dfs(string now,string target,int power,int target_power)\n{\n  if(isok != 0)return;\n  if(now == target)\n    {\n      isok = (power == target_power?1:-1);\n      return;\n    }\n  int index = exist[now];\n  if(used[index])return;\n  used[index] = true;\n\n  rep(i,G[index].size())\n    {\n      P p = G[index][i];\n      int next_index = exist[p.unit];\n      if(used[next_index])continue;\n      dfs(p.unit,target,power+(p.mpower==0?p.upower:-p.mpower),target_power );\n    }\n}\n\nbool check(string u1,string u2,int power)\n{\n  rep(i,110)used[i] = false;\n  isok = 0;\n\n  dfs(u1,u2,0,power);\n  return isok == 1;\n}\n\nbool reachable;\n\nvoid move(int now,int target)\n{\n  if(now == target)\n    {\n      reachable = true;\n      return;\n    }\n\n  if(used[now])return;\n  used[now] = true;\n  rep(i,G[now].size())\n    {\n      //assert(exist.count(G[now][i].unit));\n\n      move(exist[G[now][i].unit],target);\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N , N)\n    {\n      rep(i,N)G[i].clear();\n      int index = 0;\n      exist.clear();\n      bool result = true;\n      rep(i,N)\n\t{\n\t  string v1,unit1,v2,unit2,eq;\n\t  cin >> v1 >> unit1 >> eq >> v2 >> unit2;\n\n\t  assert(unit1 != unit2);\n\t  if(!result)continue;\n\t  //cout << toPower(v1) << \" \" << unit1 << \" = \"<< toPower(v2) << \" \" << unit2 << endl;\n\t  if(exist.count(unit1) && exist.count(unit2))\n\t    {\n\t      rep(i,N)used[i] = false;\n\t      reachable = false;\n\t      move(exist[unit1],exist[unit2]);\n\t      if(reachable)\n\t\t{\n\t\t  int p1 = toPower(v1);\n\t\t  int p2 = toPower(v2);\n\t\t  result = check(unit1,unit2,p2);\n\t\t  //cout << \"result = \" << result << endl;\n\t\t}\n\t      continue;\n\t    }\n\n\t  //cout << \"not exists\" << endl;\n\t  if(!exist.count(unit1))exist[unit1] = index++;\n\t  if(!exist.count(unit2))exist[unit2] = index++;\n\t  int index1 = exist[unit1];\n\t  int index2 = exist[unit2];\n\t  G[index1].push_back(P(unit2,toPower(v2),toPower(v1)));\n\t  G[index2].push_back(P(unit1,toPower(v1),toPower(v2)));\n\t}\n      cout << (result?\"Yes\":\"No\") << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n#define mp         make_pair\n\ntemplate<class T> void pp(T a,int n){rep(i,n)cout<<a[i]<<' ';cout<<endl;}\ntypedef long long ll;\n\nconst int inf = (1 << 29);\nconst int N = 200;\n\nclass Edge{\npublic:\n  int f,t,c;\n};\n\nint cost[N][N];\nvoid wf(int n){\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n}\n\nint getname(string &in,map<string,int> & M){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index;\n  return M[in];\n}\n\n\n\nbool getdata(int n,map<string,int> & M,vector<Edge> &in){    \n  bool contra=false;\n  rep(i,n){\n    string from,to;\n    int f,t,c;\n    int idum;char cdum;\n    cin>>idum>>from>>cdum>>idum>>cdum>>c>>to;\n    f=getname(from,M);\n    t=getname(to,M);\n    if(c < 0)swap(f,t),c*=-1;\n    in.pb((Edge){f,t,c});\n    if (cost[f][t] != inf)contra=true;\n    cost[f][t]=c;\n    cost[t][f]=-c;\n  }\n  return contra;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,N){\n      rep(j,N)cost[i][j]=inf;\n      cost[i][i]=0;\n    }\n    map<string,int> M;\n    vector<Edge> in;\n    bool iscontra=getdata(n,M,in);\n    wf(M.size());\n    bool isok=true;\n\n    n = M.size();\n\n\n    rep(i,n && isok){\n      rep(j,n && isok){\n\tif (i == j)continue;\n\tif (cost[i][j] == inf)continue;\n\trep(k,n && isok){\n\t  if (cost[i][k] >= inf/2 || cost[k][j] >= inf/2)continue;\n\t  if (cost[i][j] != cost[i][k]+cost[k][j]){\n\t    //cout << i<<\" \" << k <<\" \" << j << endl;\n\t    //\t    cout << cost[i][j] <<\" \" << cost[i][k]<<\" \" << cost[k][j] <<endl;\n\n\t    isok=false;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    \n\n\n    if (isok&&!iscontra)puts(\"Yes\");\n    else puts(\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "template<int Size = 1000000, typename WeightType = int>\nclass WeightedUnionFind {\n    int par[Size], rank[Size], sizes[Size];\n    WeightType wei[Size];\n    \npublic:\n\tWeightedUnionFind() = default;\n\tWeightedUnionFind(const WeightedUnionFind&) = default;\n\tWeightedUnionFind(WeightedUnionFind&&) = default;\n\tWeightedUnionFind& operator = (const WeightedUnionFind&) = default;\n\tWeightedUnionFind& operator = (WeightedUnionFind&&) = default;\n\n    WeightedUnionFind(int size) {\n\t\tinit(size);\n\t}\n \n\tvoid init(int size) {\n        for(int i = 0; i < size; ++i) {\n            par[i] = i;\n            rank[i] = 0;\n            sizes[i] = 1;\n            wei[i] = 0;\n        }\n    }\n    \n    int find(int x) {\n        if(par[x] == x) {\n            return x;\n        }else {\n            int p = find(par[x]);\n            \n            wei[x] += wei[par[x]];\n            \n            return par[x] = p;\n        }\n    }\n    \n    WeightType weight(int x) {\n        find(x);\n        \n        return wei[x];\n    }\n    \n    void unite(int x, int y, WeightType w) {\n        w += weight(x); \n        w -= weight(y);\n        x = find(x);\n        y = find(y);\n        \n        if(x == y) return;\n        \n        if(rank[x] < rank[y]) {\n            par[x] = y;\n            sizes[y] += sizes[x];\n            wei[x] = -w;\n        }else {\n            par[y] = x;\n            sizes[x] += sizes[y];\n            wei[y] = w;\n            if(rank[x] == rank[y]) ++rank[x];\n        }\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    int size(int x) {\n        return sizes[find(x)];\n    }\n    \n    WeightType diff(int x, int y, WeightType disabledVal = static_cast<WeightType>(-1)) {\n        if(!same(x, y)) {\n            return disabledVal;\n        }\n        \n        return weight(x) - weight(y);\n    }\n};\n#include <iostream>\n#include <vector>\n#include <map>\n#include <vector>\n\nint n;\nint main() {\n    while(std::cin >> n, n) {\n        WeightedUnionFind<1000> tree(n);\n        int cnt = 0;\n        std::map<std::string, int> extm;\n        \n        bool flag = true;\n        for(int i = 0; i < n; ++i) {\n        std::string tmp, times, lhs, rhs;\n        std::cin >> tmp >> lhs >> tmp >> times >> rhs;\n        \n        int t = std::stoi(times.substr(times.find(\"^\") + 1));\n\n        int lhs_i, rhs_i;\n        if(!extm.count(lhs))\n            extm[lhs] = cnt, lhs_i = cnt, ++cnt;\n        else\n            lhs_i = extm[lhs];\n        \n        if(!extm.count(rhs))\n            extm[rhs] = cnt, rhs_i = cnt, ++cnt;\n        else\n            rhs_i = extm[rhs];\n\n        if(tree.same(lhs_i, rhs_i)) {\n            if(tree.diff(lhs_i, rhs_i) != t) {\n                flag = false;\n            }\n        }else {\n            tree.unite(rhs_i, lhs_i, t);\n        }\n        }\n        \n        std::cout << (flag ? \"Yes\" : \"No\") << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// string => int\nint s_to_i(const string& s){\n\tbool is_negative = false;\n\tint n = 0;\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( i == 0 && s[i] == '-' ){\n\t\t\tis_negative = true;\n\t\t\tcontinue;\n\t\t}\n\t\tn = n * 10 + s[i] - '0';\n\t}\n\treturn is_negative? -n : n ;\n}\n\nconst int MAX_V = 300;\nconst int INF = 1e+8;\nmap<string,int> h;\nint V = 0;\nint G[MAX_V][MAX_V];\n\nvoid init(){\n\th.clear();\n\tV = 0;\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tfor(int j=0 ; j < MAX_V ; j++ ){\n\t\t\tG[i][j] = (i == j)? 0 : INF ;\n\t\t}\n\t}\n}\n\nvoid add_edge(string A, string B, int cost){\n\tint u, v;\n\tif( h.count(A) ){\n\t\tu = h[A];\n\t}else{\n\t\th[A] = V++;\n\t\tu = h[A];\n\t}\n\tif( h.count(B) ){\n\t\tv = h[B];\n\t}else{\n\t\th[B] = V++;\n\t\tv = h[B];\n\t}\n\tG[u][v] = cost;\n\tG[v][u] = -cost;\n}\n\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\t// テ・ツ按敕ヲツ慊淌・ツ個?\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tstring one, A, equal, x, B;\n\t\t\tcin >> one >> A >> equal >> x >> B;\n\t\t\tx = x.substr(3);\n\t\t\tadd_edge(A, B, s_to_i(x));\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k < V ; k++ ){\n\t\t\tfor(int i=0 ; i < V ; i++ ){\n\t\t\t\tfor(int j=0 ; j < V ; j++ ){\n\t\t\t\t\tG[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\tfor(int i=0 ; i < V ; i++ ){\n\t\t\tif( G[i][i] < 0 ) ans = false;\n\t\t}\n\t\tcout << (ans? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " REP(i,count){\n      vector<string>::iterator \n        it1 = find(tani.begin(),tani.end(),date2[i][0]), \n        it2 = find(tani.begin(),tani.end(),date2[i][1]);\n      bool f1 = (it1 != tani.end());\n      bool f2 = (it2 != tani.end());\n      int ind1 = ind[distance(tani.begin(),it1)];\n      int ind2 = ind[distance(tani.begin(),it2)];\n      if(f1&&f2&&ind2-ind1!=date[i])\n        flag = false;\n      else if(f1&&!f2){\n        ind.push_back(ind1 + date[i]);\n        tani.push_back(date2[i][1]);\n        cccc--;\n      }else if(!f1&&f2){\n        ind.push_back(ind2 - date[i]);\n        tani.push_back(date2[i][0]);\n        cccc--;\n      }\n    }\n    }\n    if(flag) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nbool visited[200];\nint c[200];\n\nbool dfs(vector<vector<pair<int, int> > > &edge, int now, int cost) {\n    if (visited[now])return cost == c[now];\n    c[now] = cost;\n    visited[now] = true;\n    bool res = true;\n    rep(i, edge[now].size()) {\n        int next = edge[now][i].first;\n        int ncost = edge[now][i].second;\n        res &= dfs(edge, next, cost + ncost);\n    }\n    return res;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    int n;\n    while(1) {\n        cin >> n;\n        map<string, int> v;\n        vector<vector<pair<int, int> > > edge(2*n);\n        if (n == 0)break;\n        int cnt = 0;\n        rep(i,n) {\n            int idummy;\n            char cdummy;\n            string s[2],sdummy;\n            int cost;\n            cin >> idummy >> s[0] >> sdummy >> idummy >> cdummy >> cost >> s[1];\n            rep(j,2) {\n                if (v.find(s[j]) == v.end()) {\n                    v[s[j]] = cnt;\n                    cnt++;\n                }\n            }\n            edge[v[s[0]]].push_back(make_pair(v[s[1]], cost));\n            edge[v[s[1]]].push_back(make_pair(v[s[0]], -cost));\n        }\n        bool ok = true;\n        rep(i, cnt) {\n            rep(j,100) {\n                visited[j] = false;\n            }\n            ok &= dfs(edge, i, 0);\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n            }\n        }\n    }\n}\n\nbool passed[101];\nbool no;\nvoid dfs(int s){\n    passed[s]=true;\n    for(int i = 0; i < V; i++){\n        if(i==s)continue;\n        if(d[s][i]!=INF){\n            if(passed[i]){\n                no=true;\n                return;\n            }\n            dfs(i);\n            if(no)\n                return;\n        }\n    }\n    passed[s]=false;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0){\n                d[dict[a]][dict[b]]=-cost;\n                d[dict[b]][dict[a]]=cost;\n\t    }\n            else{\n                d[dict[b]][dict[a]]=cost;\n                d[dict[a]][dict[b]]=-cost;\n\t    }\n        }\n        V=idx;\n        no=false;\n        for(int i = 0; i < idx; i++){\n            fill(passed,passed+201,false);\n            dfs(idx);\n        }\n        warshall_floyd();\n        for(int i = 0; i < idx; i++){\n            for(int j = 0;  j< idx; j++){\n                int dist=d[i][j];\n                if(i==j)\n\t\t  continue;\n                for(int k = 0; k < idx; k++){\n\t\t  if(dist<INF&&d[i][k]<INF&&d[k][j]<INF){\n\t\t    if(dist!=d[i][k]+d[k][j]){\n\t\t      no=true;\n\t\t    }\n\t\t  }\n\t\t  if(no)\n\t\t    break;\n                }\n                if(no)\n\t\t  break;\n            }\n            if(no)break;\n        }\n\t\n        if(no)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nmap<string,vector<pair<string,int> > > b;\nmap<string,int> c;\nint fn(string s,int p){\n  int i;\n  if(c.count(s)){\n    if(c[s]!=p)\n      return 1;\n    else\n      return 0;\n  }else{\n    c[s]=p;\n    for(i=0;i<(int)b[s].size();i++){\n      if(fn(b[s][i].first,p+b[s][i].second))\n\treturn 1;\n    }\n    return 0;\n  }\n}\nint main(){\n  int i;\n  int n;\n  while(cin>>n,n){\n    set<string> a;\n    b.clear();\n    for(i=0;i<n;i++){\n      string s,t;\n      char c;\n      int p;\n      cin>>s>>s>>c>>c>>c>>c>>p>>t;\n      a.insert(s);\n      a.insert(t);\n      b[s].push_back(make_pair(t,-p));\n      b[t].push_back(make_pair(s,p));\n    }\n    set<string>::iterator it;\n    for(it=a.begin();it!=a.end();it++){\n      c.clear();\n      if(fn(*it,0))\n\tbreak;\n    }\n    if(it!=a.end())\n      cout<<\"No\"<<endl;\n    else\n      cout<<\"Yes\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "template<int Size = 1000000, typename WeightType = int>\nclass WeightedUnionFind {\n    int par[Size], rank[Size], sizes[Size];\n    WeightType wei[Size];\n    \npublic:\n\tWeightedUnionFind() = default;\n\tWeightedUnionFind(const WeightedUnionFind&) = default;\n\tWeightedUnionFind(WeightedUnionFind&&) = default;\n\tWeightedUnionFind& operator = (const WeightedUnionFind&) = default;\n\tWeightedUnionFind& operator = (WeightedUnionFind&&) = default;\n \n    WeightedUnionFind(int size) {\n\t\tinit(size);\n\t}\n \n\tvoid init(int size) {\n        for(int i = 0; i < size; ++i) {\n            par[i] = i;\n            rank[i] = 0;\n            sizes[i] = 1;\n            wei[i] = 0;\n        }\n    }\n    \n    int find(int x) {\n        if(par[x] == x) {\n            return x;\n        }else {\n            int p = find(par[x]);\n            \n            wei[x] += wei[par[x]];\n            \n            return par[x] = p;\n        }\n    }\n    \n    WeightType weight(int x) {\n        find(x);\n        \n        return wei[x];\n    }\n    \n    void unite(int x, int y, WeightType w) {\n        w += weight(x); \n        w -= weight(y);\n        x = find(x);\n        y = find(y);\n        \n        if(x == y) return;\n        \n        if(rank[x] < rank[y]) {\n            par[x] = y;\n            sizes[y] += sizes[x];\n            wei[x] = -w;\n        }else {\n            par[y] = x;\n            sizes[x] += sizes[y];\n            wei[y] = w;\n            if(rank[x] == rank[y]) ++rank[x];\n        }\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    int size(int x) {\n        return sizes[find(x)];\n    }\n    \n    WeightType diff(int x, int y, WeightType disabledVal = static_cast<WeightType>(-1)) {\n        if(!same(x, y)) {\n            return disabledVal;\n        }\n        \n        return weight(x) - weight(y);\n    }\n};\n\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n\nint n;\n\nint main() {\n    while(std::cin >> n, n) {\n        std::string tmp, lhs, rhs, times_raw;\n        int cnt = 0;\n        std::map<std::string, int> units;\n        WeightedUnionFind<256> tree(n * 2);\n        bool flag = true;\n        \n        for(int i = 0; i < n; ++i) {\n            std::cin >> tmp >> lhs >> tmp >> times_raw >> rhs;\n            \n            if(!flag)\n                continue;\n            \n            int times = std::stoi(times_raw.substr(times_raw.find(\"^\") + 1));\n            int l, r;\n            if(units.count(lhs)) {\n                l = units[lhs];\n            }else {\n                l = units[lhs] = cnt, ++cnt;\n            }\n            \n            if(units.count(rhs)) {\n                r = units[rhs];\n            }else {\n                r = units[rhs] = cnt, ++cnt;\n            }\n            if(tree.same(l, r)) {\n                if(tree.diff(l, r) != times) {\n                    flag = false;\n                }\n            }else {\n                tree.unite(r, l, times);\n            }\n        }\n        \n        std::cout << (flag ? \"Yes\" : \"No\") << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nstruct edge{\n\tint from;\n\tint cost;\n\tint to;\n};\n\nmap<string, int> mp;\nint d[101];\nvector<edge> es;\n\nint main(){\n\tint n;\n\tint a, b, size;\n\tstring t1, t2, t3, t4;\n\tedge e1, e2;\n\twhile(cin >> n && n){\n\t\tint count = 1;\n\t\tmp.clear();\n\t\tes.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> a >> t1 >> t2 >> t3 >> t4;\n\t\t\tstring s(t3.begin() + 3, t3.end());\n\t\t\tstringstream ss;\n\t\t\tss << s;\n\t\t\tss >> b;\n\t\t\tif(mp[t1] == 0) mp[t1] = count++;\n\t\t\tif(mp[t4] == 0) mp[t4] = count++;\n\t\t\te1.from = mp[t4];\n\t\t\te1.cost = b;\n\t\t\te1.to = mp[t1];\n\t\t\tes.push_back(e1);\n\t\t\te2.from = mp[t1];\n\t\t\te2.cost = -b;\n\t\t\te2.to = mp[t4];\n\t\t\tes.push_back(e2);\n\t\t}\n\t\tsize = es.size();\n\t\tfill(d, d + count, 0);\n\t\tbool update = true;\n\t\tfor(int i = 0; i <= 2 * n; i++){\n\t\t\tupdate = false;\n\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\tedge e = es[j];\n\t\t\t\tint s = e.from, t = e.to;\n\t\t\t\tif(d[t] > d[s] + e.cost){\n\t\t\t\t\td[t] = d[s] + e.cost;\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tcout << t << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\t\tif(update) cout << \"No\" << endl;\n\t\telse cout << \"Yes\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int, int> pii;\n\nstruct UnionFind_W {\n\tvector<pii> data;\n\tUnionFind_W(int size) : data(size, { -1,0 }) { }\n\tbool unionSet(int x, int y, int d) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tint ox = x,oy =y;\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tdata[x].first += data[y].first;\n\t\t\tdata[y].second = data[ox].second - data[oy].second+ d;\n\t\t\tdata[y].first = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tint findSet(int x, int y) { //x??????y?????????\n\t\tint rx = root(x), ry = root(y);\n\t\tif (rx == ry) {\n\t\t\treturn data[x].second - data[y].second;\n\t\t}\n\t\treturn INT_MAX;\n\t}\n\tint root(int x) {\n\t\tif (data[x].first < 0)\n\t\t\treturn x;\n\t\tint op = data[x].first;\n\t\tdata[x].first = root(data[x].first);\n\t\tdata[x].second += data[op].second;\n\t\treturn data[x].first;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)].first;\n\t}\n};\n\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n)) {\n\t\tif (!n)\n\t\t\treturn 0;\n\t\n\t\tUnionFind_W uf(n*2);\n\t\tmap<string, int> unit;\n\t\tchar str[17],str2[17];\n\t\tbool f = 1;\n\t\tREP(i, n) {\n\t\t\tint d;\n\t\t\tscanf(\"%*d%s%*s%*d%*c%d%s\", str, &d, str2);\n\t\t\tif (!unit.count(str))\n\t\t\t\tunit[str] = unit.size();\n\t\t\tif (!unit.count(str2))\n\t\t\t\tunit[str2] = unit.size();\n\n\t\t\tint he = uf.findSet(unit[str], unit[str2]);\n\t\t\tif (he == INT_MAX) {\n\t\t\t\tuf.unionSet(unit[str], unit[str2], d);\n\t\t\t}\n\t\t\telse if (he != -d) {\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\tf = 0;\n\t\t\t\trep(j, i, n-1) {\n\t\t\t\t\tscanf(\"%*d%s%*s%*d%*c%d%s\", str, &d, str2);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t\tprintf(\"Yes\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int hoge[2*n];\n    UnionFind uf(2*n);\n    map<string,int> id;\n    int cnt = 0;\n    bool f = 0;\n    REP(i,n) {\n      int tmp;\n      string tmps, s1,s2,xx;\n      cin>>tmp>>s1>>tmps>>xx>>s2;\n      int x = atoi(xx.substr(3).c_str());\n    \n      if (id.count(s1)==0 && id.count(s2)==0) {\n        id[s1] = cnt++;\n        id[s2] = cnt++;\n        hoge[id[s1]] = 0;\n        hoge[id[s2]] = -x;\n      } else if (id.count(s1)==0) {\n        id[s1] = cnt++;\n        hoge[id[s1]] = hoge[id[s2]] + x;\n      } else if (id.count(s2)==0) {\n        id[s2] = cnt++;\n        hoge[id[s2]] = hoge[id[s1]] - x;\n      } else {\n        if (uf.findSet(id[s1], id[s2])) {\n          if (hoge[id[s1]] != hoge[id[s2]] + x) {\n            f = 1;\n          }\n        } else {\n          int tmp = hoge[id[s1]] - hoge[id[s2]];\n          REP(j, cnt) {\n            if (uf.findSet(id[s2], j)) {\n              hoge[j] += tmp - x;\n            }\n          }\n        }\n      }\n      uf.unionSet(id[s1], id[s2]);\n      // printf(\"%d,%d\\n\", uf.root(id[s1]), uf.root(id[s2]));\n      // FOR(it, id) {\n      //   cout << it->first << \" \" << it->second << \" \" << hoge[it->second] << endl;\n      // }\n      // cout << endl;\n    }\n    if(f)\n      cout << \"No\" << endl;\n    else\n      cout << \"Yes\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 100*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n};\n\nbool relax(const vector<vector<pair<int,int> > > &graph, vector<int> &dist) {\n    const int N = graph.size();\n    bool updated = false;\n    for(int i = 0; i < N; ++i) {\n        const vector<pair<int,int> > &edges = graph[i];\n        for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n            const int nc = dist[i] + it->second;\n            if(dist[it->first] > nc) {\n                dist[it->first] = nc;\n                updated = true;\n            }\n        }\n    }\n    return updated;\n}\n\nvector<vector<pair<int,int> > > v(100);\nvector<int> dist(100);\nvector<unsigned char> visited(100);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < N; ++i) {\n            v[i].clear();\n            dist[i] = INF;\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            char unit_left[32], unit_right[32];\n            int ord;\n            sscanf(line.c_str(), \"%*d %s = %*d^%d %s \", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        // テ」ツ?敕」ツつ古」ツ?榲」ツつ古」ツ?ョテゥツ?」テァツオツ静ヲツ按静・ツ按?」ツ?ォテ」ツ?、テ」ツ?催ッツシツ?テ」ツδ偲」ツδシテ」ツδ嘉」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ィテ」ツ?凖」ツつ凝ッツシツ?\n        fill(visited.begin(), visited.end(), 0);\n        queue<int> q;\n        for(int i = 0; i < N; ++i) {\n            if(!visited[i]) {\n                dist[i] = 0;\n                visited[i] = 1;\n                q.push(i);\n                while(!q.empty()) {\n                    int cur = q.front();\n                    q.pop();\n                    const vector<pair<int,int> > &edges = v[cur];\n                    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                        if(!visited[it->first]) {\n                            visited[it->first] = 1;\n                            q.push(it->first);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Bellman-ford\n        for(int phase = 0; phase < N; ++phase) {\n            if(!relax(v, dist)) break;\n        }\n        if(relax(v, dist)) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n  string s, t;\n  int c;\n} Unit;\n\nint main()\n{\n  const int INF = 1 << 29;\n\n  int N;\n  while (~scanf(\"%d\", &N)) {\n    if (N == 0)\n      break;\n\n    map<string, int> toIndex;\n    vector<Unit> unit(N);\n    for (int i = 0; i < N; ++i) {\n      string s, t, c;\n      cin >> t >> t >> c >> c >> s;\n      int cc = atoi(c.substr(c.find_first_of(\"^\")+1).c_str());\n      unit[i].s = s;\n      unit[i].t = t;\n      unit[i].c = cc;\n      if (toIndex.find(s) == toIndex.end())\n\ttoIndex[s] = toIndex.size()-1;\n      if (toIndex.find(t) == toIndex.end())\n\ttoIndex[t] = toIndex.size()-1;\n    }\n\n    vector<vector<int> > cost(toIndex.size(), vector<int>(toIndex.size(), INF));\n    for (int i = 0; i < cost.size(); ++i)\n      cost[i][i] = 0;\n\n    for (int i = 0; i < N; ++i) {\n      int s = toIndex.find(unit[i].s)->second;\n      int t = toIndex.find(unit[i].t)->second;\n      cost[s][t] = unit[i].c;\n      cost[t][s] = -unit[i].c;\n    }\n\n    for (unsigned int k = 0; k < cost.size(); ++k) {\n      for (unsigned int i = 0; i < cost.size(); ++i) {\n\tfor (unsigned int j = 0; j < cost.size(); ++j)\n\t  cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n      }\n    }\n\n    bool yes = true;\n    for (unsigned int i = 0; i < cost.size() && true; ++i) {\n      for (unsigned int j = i+1; j < cost.size() && true; ++j) {\n\tif (cost[i][j] >= 100000000 || cost[j][i] >= 100000000)\n\t  continue;\n\tif (cost[i][j] != -cost[j][i])\n\t  yes = false;\n      }\n    }\n\n    if (yes)\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nbool visited[100];\nint c[100];\n\nbool dfs(vector<vector<pair<int, int> > > &edge, int now, int cost) {\n    if (visited[now])return cost == c[now];\n    c[now] = cost;\n    visited[now] = true;\n    bool res = true;\n    rep(i, edge[now].size()) {\n        int next = edge[now][i].first;\n        int ncost = edge[now][i].second;\n        res &= dfs(edge, next, cost + ncost);\n    }\n    return res;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    int n;\n    while(1) {\n        cin >> n;\n        map<string, int> v;\n        vector<vector<pair<int, int> > > edge(n);\n        if (n == 0)break;\n        int cnt = 0;\n        rep(i,n) {\n            int idummy;\n            char cdummy;\n            string s[2],sdummy;\n            int cost;\n            cin >> idummy >> s[0] >> sdummy >> idummy >> cdummy >> cost >> s[1];\n            rep(j,2) {\n                if (v.find(s[j]) == v.end()) {\n                    v[s[j]] = cnt;\n                    cnt++;\n                }\n            }\n            edge[v[s[0]]].push_back(make_pair(v[s[1]], cost));\n            edge[v[s[1]]].push_back(make_pair(v[s[0]], -cost));\n        }\n        bool ok = true;\n        rep(i, n) {\n            rep(j,100) {\n                visited[j] = false;\n            }\n            ok &= dfs(edge, i, 0);\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#define N 210\nusing namespace std;\n\nint n,m;\nint d[N][N];\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int k=0;k<m;k++ )\n    for( int i=0;i<m;i++ )\n      for( int j=0;j<m;j++ )\n\td[i][j] = min( d[i][j],d[i][k]+d[k][j] );\n\n  for( int i=0;i<m;i++ )\n    if( d[i][i]<0 )\n      return false;\n  return true;\n}\n\nint main(){\n  string a,b, s;\n  int x;\n  char c;\n\n  while( cin>>n && n ){\n    m=n*2;\n    for( int i=0;i<N;i++ ){\n      for( int j=0;j<N;j++ )\n\td[i][j] = 100000000;\n      d[i][i] = 0;\n    }\n    map<string,int> units; // units[ a ] でaの配列番号が分かる\n    m=0;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c;  // 10^\n      cin >> x >> b;  // [x] [B];\n\n      if( units.find( a )==units.end() )\n\tunits[a] = m++;\n      if( units.find( b )==units.end() )\n\tunits[b] = m++;\n\n      int an=units[a], bn=units[b];\n      \n      d[an][bn] = -x;\n      d[bn][an] =  x;\n    }\n\n    if( check() ) cout << \"Yes\" << endl;\n    else          cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <sstream>\n#include <map>\nusing namespace std;\n\ntemplate<typename T>\nstruct WeightedUnionFind {\n    vector<int> data;\n    vector<T> ws;\n    WeightedUnionFind(int sz) : data(sz, -1), ws(sz) { }\n    bool merge(int x, int y, T w) {             // ws(y) = ws(x) + w\n        w += weight(x); w -= weight(y);\n        if ((x = root(x)) == (y = root(y))) return false;\n        if (data[x] > data[y]) swap(x, y), w = -w;\n        data[x] += data[y]; data[y] = x; ws[y] = w;\n        return true;\n    }\n    bool find(int x, int y) { return root(x) == root(y); }\n    T diff(int x, int y) { return weight(y) - weight(x); }\n    T weight(int t) { root(t); return ws[t]; }\n    int root(int k) {\n        if (data[k] < 0) return k;\n        int par = root(data[k]);\n        ws[k] += ws[data[k]];\n        return data[k] = par;\n    }\n};\n\ntemplate<typename F, typename T>\nvoid convert(const F &f, T &t) { stringstream ss; ss << f; ss >> t; }\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        bool ok = true;\n        WeightedUnionFind<int> wuf(200);\n        map<string, int> str2id;\n        int cnt = 0;\n        for (int i = 0; i < N; ++i) {\n            string one, unit1, equal, val, unit2;\n            cin >> one >> unit1 >> equal >> val >> unit2;\n            if (!str2id.count(unit1)) str2id[unit1] = cnt++;\n            int id1 = str2id[unit1];\n            if (!str2id.count(unit2)) str2id[unit2] = cnt++;\n            int id2 = str2id[unit2];\n            int diff;\n            convert(val.substr(3), diff);\n            if (wuf.find(id1, id2)) {\n                int curdiff = wuf.diff(id1, id2);\n                if (diff != curdiff) ok = false;\n            } else {\n                wuf.merge(id1, id2, diff);\n            }\n        }\n        puts(ok ? \"Yes\" : \"No\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <utility>\n#include <algorithm>\n#define P pair<string,int>\n#define N 110\nusing namespace std;\n\nint n,m;\nint d[N][N];\nmap<string,int> units; // units[ a ] でaの配列番号が分かる\n\nbool check(){ /* 誤った規則があればfalse */\n\n  for( int k=0;k<m;k++ )\n    for( int i=0;i<m;i++ )\n      for( int j=0;j<m;j++ )\n\td[i][j] = min( d[i][j],d[i][k]+d[k][j] );\n\n  for( int i=0;i<m;i++ )\n    if( d[i][i]!=0 )\n      return false;\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    for( int i=0;i<N;i++ )for( int j=0;j<N;j++ ) d[i][j]=1000;\n\n    units.clear(); m=0;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c;  // 10^\n      cin >> x >> b;  // [x] [B];\n\n      if( units.find( a )==units.end() )\n\tunits.insert( P(a,m++) );\n      if( units.find( b )==units.end() )\n\tunits.insert( P(b,m++) );\n\n      int an=units[a], bn=units[b];\n      d[an][bn] =  x;\n      d[bn][an] = -x;\n    }\n\n    if( check() ) cout << \"Yes\" << endl;\n    else          cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#define P pair<string,int>\n#define PP pair<int,int>\n#define DEBUG false\nusing namespace std;\n\nint n;\nvector<PP> rl[110]; // 単位間の関係\nvector<string> v; // 一応単位の文字列を保持.インデックスはunitsと同じ。\n\nstring tab(int len){\n  string r=\"\";  for( int  i=0;i<len;i++ ) r+=\"  \";\n  return r;\n}\n\n\n/* 単位系が誤っているとfalseを返す */\nbool dfs(int i, int sum, int initP,int depth){\n  if( depth==102 ) return false;\n\n  if(DEBUG)\n    cout << tab(depth) << v[i] << \" sum=\"<< sum << \" dpth=\" << depth << endl;\n  if( i==initP ){\n    if( sum==0 ) return true;\n    else return false;\n  }else{\n    if( sum==0 ) return false;\n  }\n\n  if( rl[i].size()<=1 )    return true;\n  depth++;\n  for( int j=0;j<(int)rl[i].size();j++ ){\n    if( rl[i][j].second>0 ) continue;\n    int nS = sum + rl[i][j].second;\n    if( dfs( rl[i][j].first,nS,initP,depth)==false )\n      return false;\n  }\n  return true;\n}\n\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int i=0;i<n;i++ ){\n    if( rl[i].size()<=1 ) continue;\n\n    if(DEBUG)cout << v[i] << \" ************************\" << endl;\n    for( int j=0;j<(int)rl[i].size();j++ ){\n      if( rl[i][j].second<0 ) continue;\n\n      if( dfs(rl[i][j].first,rl[i][j].second,i,1)==false )\n\treturn false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    map<string,int> units; // units[ a ] でaの配列番号が分かる\n    map<string,int>::iterator it;\n\n    v.clear();\n    for( int i=0;i<n;i++ )\n      rl[i].clear();\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() ){\n\tunits.insert( P(a,(int)units.size()) ); v.push_back( a );\n      }\n      if( (it=units.find( b ))==units.end() ){\n\tunits.insert( P(b,(int)units.size()) ); v.push_back( b );\n      }\n      int an=units[a], bn=units[b];\n      rl[ an ].push_back( PP(bn,x) );  rl[ bn ].push_back( PP(an,-x) );\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <string>\n\nusing namespace std;\n\npair<int, int> par[256];\n\nvoid init(int n)\n{\n\tfor (int i = 0; i < n; i++){\n\t\tpar[i] = make_pair(i, 0);\n\t}\n}\n\npair<int, int> find(int x)\n{\n\tif (par[x].first == x) return (par[x]);\n\tpair<int, int> ret = find(par[x].first);\n\treturn (par[x] = make_pair(ret.first, par[x].second + ret.second));\n}\n\nbool same(int u, int v)\n{\n\treturn (find(u).first == find(v).first);\n}\n\nvoid merge(int u, int v, int val)\n{\n\tpair<int, int> uu = find(u);\n\tpair<int, int> vv = find(v);\n\t\n\tif (uu.first == vv.first) return;\n\t\n\tpar[uu.first] = make_pair(vv.first, vv.second + val);\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\tgetchar();\n\t\t\n\t\tmap<string, int> mp;\n\t\tinit(2 * n);\n\t\tbool ok = true;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tchar s[1024], t[1024];\n\t\t\tint val;\n\t\t\t\n\t\t\tscanf(\"1 %s = 10^%d %s\", s, &val, t);\n\t\t\tgetchar();\n\t\t\t\n\t\t\tstring ss = s, st = t;\n\t\t\tif (!mp.count(ss)){\n\t\t\t\tint ct = mp.size();\n\t\t\t\tmp[ss] = ct;\n\t\t\t}\n\t\t\tif (!mp.count(st)){\n\t\t\t\tint ct = mp.size();\n\t\t\t\tmp[st] = ct;\n\t\t\t}\n\t\t\t\n\t\t\tint u = mp[ss], v = mp[st];\n\t\t\tif (same(u, v)){\n\t\t\t\tif (par[u].second - par[v].second != val) ok = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmerge(u, v, val);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <map>\n \nusing namespace std;\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n \ntypedef pair<int, int> P;\n \nint d[201][201];\n \nconst int INF = 1<<29;\nint main(){\n    int n;\n    while(cin >> n, n){\n        rep(i, 101) rep(j, 101) d[i][j] = INF;\n        map<string, int> num;\n        int idx = 0;\n        bool ans = true;\n        rep(i, n){\n            string a, b;\n            string c;\n            cin >> c >> a >> c >> c >> b;\n            if(!num[a]) num[a] = ++idx;\n            if(!num[b]) num[b] = ++idx;\n            int x = atoi(c.substr(3).c_str());\n            // a = b+x\n            int l = num[a], r = num[b];\n\t\t\td[l][l] = d[r][r] = 0;\n            rep(k, 2){\n                d[l][r] = x;\n                swap(l, r);\n                x = -x;\n            }\n            for(int j = 1; j <= idx; j++){\n                for(int k = 1; k <= idx; k++){\n                    if(d[k][j] == INF) continue;\n                    for(int l = 1; l <= idx; l++){\n                        if(d[j][l] == INF) continue;\n                        d[k][l] = min(d[k][l], d[k][j]+d[j][l]);\n                    }\n                }\n            }\n            for(int j = 1; j <= idx; j++){\n\t\t\t\tif(d[j][j] != 0) ans = false;\n\t\t\t}\n        }\n \n        cout << (ans?\"Yes\":\"No\") << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint GetPower(string);\nint AtoiString(const string);\nbool UnitSystem(const string, const string, int,\n\t\tint*, map<string, pair<int, int> >*);\n\nint main(){\n  int i, n, one, power, group;\n  bool correct;\n  string unit1, unit2, str_power, equal;\n  map<string, pair<int, int> > data;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n\n    for(i=0, group=0, correct=true; i<n; ++i){\n      cin >> one >> unit1 >> equal >> str_power >> unit2;\n      if(!correct) continue;\n      power = GetPower(str_power);\n      if(power >= 0)\n\tcorrect = UnitSystem(unit1, unit2, power, &group, &data);\n      else\n\tcorrect = UnitSystem(unit2, unit1, -power, &group, &data);\n    }\n\n    if(correct) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    data.clear();\n  }\n  return 0;\n}\n\nint GetPower(string str){\n  str.erase(str.begin(), str.begin()+3);\n  if(str[0] == '-'){\n    str.erase(str.begin());\n    return - AtoiString(str);\n  }else{\n    return AtoiString(str);\n  }\n}\n\nint AtoiString(const string s){\n  int i, x, d;\n  for(i=s.size()-1, x=0, d=1; i>=0; --i, d*=10)\n    x += ((s[i] - 48) * d);\n  return x;\n}\n\nbool UnitSystem(const string unit1, const string unit2, int power,\n\t\tint* group, map<string, pair<int, int> >* data){\n  map<string, pair<int, int> >::iterator i, j;\n  i = data->find(unit1);\n  j = data->find(unit2);\n\n  if(i != data->end() && j != data->end()){\n    if(i->second.first == j->second.first){\n      if(power == j->second.second - i->second.second) return true;\n      else return false;\n    }\n    int new_group = i->second.first;\n    int old_group = j->second.first;\n    int add_power = i->second.second;\n    for(i=data->begin(); i!=data->end(); ++i){\n      if(i->second.first == old_group){\n\ti->second.first = new_group;\n\ti->second.second += add_power;\n      }\n    }\n    return true;\n  }\n  if(i != data->end()){\n    data->insert(make_pair(unit2, make_pair(i->second.first,\n\t\t\t\t\t    i->second.second + power)));\n    return true;\n  }\n  if(j != data->end()){\n    data->insert(make_pair(unit1, make_pair(j->second.first,\n\t\t\t\t\t    j->second.second - power)));\n    return true;\n  }\n  data->insert(make_pair(unit1, make_pair(*group, 0)));\n  data->insert(make_pair(unit2, make_pair(*group, power)));\n  ++*group;\n  return true;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint loc;\n};\n\nint N;\nchar name_table[200][17];\nchar left_table[100][17],relative[100][17],right_table[100][17];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nInfo info[200];\nbool used[100];\n\nint get_relative(char buf[17]){\n\n\tint ret = 0;\n\n\tif(buf[3] == '-'){\n\t\tfor(int i = 4; buf[i] != '\\0'; i++){\n\t\t\tret = 10*ret+buf[i]-'0';\n\t\t}\n\t\tret*= -1;\n\t}else{\n\t\tfor(int i = 3; buf[i] != '\\0'; i++){\n\t\t\tret = 10*ret+buf[i]-'0';\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 100; i++){\n\t\tinfo[i].loc = -1;\n\t\tused[i] = false;\n\t}\n\n\tint tmp;\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %s %s %s %s\",&tmp,left_table[i],buf,relative[i],right_table[i]);\n\t}\n\n\tstrcpy(name_table[0],left_table[0]);\n\tstrcpy(name_table[1],right_table[0]);\n\n\tint index = 2;\n\ttmp = get_relative(relative[0]);\n\tinfo[0].loc = 10000;\n\tinfo[1].loc = 10000-tmp;\n\tused[0] = true;\n\n\tint used_num = 1;\n\tint left_index,right_index;\n\tint eq_num;\n\n\tbool FLG;\n\n\twhile(used_num < N){\n\n\t\tFLG = false;\n\n\t\tfor(int i = 1; i < N; i++){\n\t\t\tif(used[i])continue;\n\n\t\t\tleft_index = -1;\n\t\t\tfor(int k = 0; k < index; k++){\n\t\t\t\tif(strCmp(name_table[k],left_table[i])){\n\t\t\t\t\tleft_index = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tright_index = -1;\n\t\t\tfor(int k = 0; k < index; k++){\n\t\t\t\tif(strCmp(name_table[k],right_table[i])){\n\t\t\t\t\tright_index = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(left_index != -1 || right_index != -1){\n\t\t\t\tFLG = true;\n\t\t\t\teq_num = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tif(used[i])continue;\n\n\t\t\t\teq_num = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tused[eq_num] = true;\n\t\t\tused_num++;\n\n\t\t\tstrcpy(name_table[index],left_table[eq_num]);\n\t\t\tstrcpy(name_table[index+1],right_table[eq_num]);\n\t\t\ttmp = get_relative(relative[eq_num]);\n\t\t\tinfo[index].loc = 10000;\n\t\t\tinfo[index+1].loc = info[index].loc-tmp;\n\t\t\tindex += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tused[eq_num] = true;\n\t\tused_num++;\n\n\t\tif(left_index == -1){\n\t\t\tstrcpy(name_table[index],left_table[eq_num]);\n\t\t\ttmp = get_relative(relative[eq_num]);\n\t\t\tinfo[index].loc = info[right_index].loc+tmp;\n\t\t\tindex++;\n\t\t}else if(right_index == -1){\n\t\t\tstrcpy(name_table[index],right_table[eq_num]);\n\t\t\ttmp = get_relative(relative[eq_num]);\n\t\t\tinfo[index].loc = info[left_index].loc-tmp;\n\t\t\tindex++;\n\t\t}else{\n\t\t\ttmp = get_relative(relative[eq_num]);\n\n\t\t\tif(info[left_index].loc-info[right_index].loc != tmp){\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"Yes\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint n,m,e[200][200];\n\nint main()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tmap<string,int> id;\n\t\trep(i,2*n)rep(j,2*n)e[i][j]=inf;\n\t\t\n\t\tstring u1,u2,t; m=0;\n\t\trep(i,n)\n\t\t{\n\t\t\tcin>>t>>u1>>t>>t>>u2;\n\t\t\tif(!id.count(u1))id[u1]=m++;\n\t\t\tif(!id.count(u2))id[u2]=m++;\n\t\t\te[id[u1]][id[u2]]=atoi(t.substr(3).c_str());\n\t\t\te[id[u2]][id[u1]]=-e[id[u1]][id[u2]];\n\t\t}\n\t\trep(k,m)rep(i,m)rep(j,m)e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\t\tbool f=0;\n\t\trep(i,m)if(e[i][i]!=inf&&e[i][i]!=0)f=1;\n\t\tputs(f?\"No\":\"Yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\nconst int MAX_M = 201;\nconst int INF = 1<<24;\nmap<string, int> id;\nint G[MAX_M][MAX_M];\nint M;\n\nint getId(string s) {\n  if(id.find(s) == id.end()) {\n    id[s] = M++;\n  }\n  return id[s];\n}\n\nbool solve() {\n  for(int k = 0; k < M; ++k) {\n    for(int s = 0; s < M; ++s) {\n      for(int d = 0; d < M; ++d) {\n\tif(G[s][k] == INF || G[k][d] == INF) continue;\n\tif(G[s][d] == INF) {\n\t  G[s][d] = G[s][k] + G[k][d];\n\t} else if(G[s][d] != G[s][k] + G[k][d]) {\n\t  return false;\n\t}\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    M = 0;\n    id.clear();\n    fill(G[0], G[MAX_M], INF);\n    for(int i = 0; i < N; ++i) {\n      string in[5];\n      for(int j = 0; j < 5; ++j) cin >> in[j];\n      int a = getId(in[1]);\n      int b = getId(in[4]);\n      int cost = atoi((in[3].substr(3)).c_str());\n      G[a][b] = cost;\n      G[b][a] = -cost;\n    }\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n                //// Ç¿çàINFæè¬³­Èé\n                //if(prv!=INF&&d[j][i]+d[i][k]<INF){\n                //    if(prv!=d[j][i]+d[i][k]){\n                //        return false;\n                //    }\n                //}\n            }\n        }\n    }\n//    return true;\n}\n\nbool passed[101];\nbool no;\nvoid dfs(int s){\n    passed[s]=true;\n    for(int i = 0; i < V; i++){\n        if(i==s)continue;\n        if(d[s][i]!=INF){\n            if(passed[i]){\n                no=true;\n                return;\n            }\n            dfs(i);\n            if(no)\n                return;\n        }\n    }\n    passed[s]=false;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0){\n                d[dict[a]][dict[b]]=-cost;\n                d[dict[b]][dict[a]]=cost;\n\t    }\n            else{\n                d[dict[b]][dict[a]]=cost;\n                d[dict[a]][dict[b]]=-cost;\n\t    }\n        }\n        V=idx;\n        no=false;\n        for(int i = 0; i < idx; i++){\n            fill(passed,passed+101,false);\n            dfs(idx);\n        }\n        warshall_floyd();\n        for(int i = 0; i < idx; i++){\n            for(int j = 0;  j< idx; j++){\n                int dist=d[i][j];\n                if(i==j)\n\t\t  continue;\n                for(int k = 0; k < idx; k++){\n\t\t  if(dist<INF&&d[i][k]<INF&&d[k][j]<INF){\n\t\t    if(dist!=d[i][k]+d[k][j]){\n\t\t      no=true;\n\t\t    }\n\t\t  }\n\t\t  if(no)\n\t\t    break;\n                }\n                if(no)\n\t\t  break;\n            }\n            if(no)break;\n        }\n\t\n        if(no)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#define P pair<string,int>\n#define PP pair<int,int>\n#define DEBUG false\nusing namespace std;\n\nint n;\nvector<PP> rl[110]; // 単位間の関係\nvector<string> v; // 一応単位の文字列を保持.インデックスはunitsと同じ。\n\nstring tab(int len){\n  string r=\"\";  for( int  i=0;i<len;i++ ) r+=\"  \";\n  return r;\n}\n\n/* 単位系が誤っているとfalseを返す */\nbool dfs(int i, int sum, int initP,int depth){\n  if( depth==101 ) return true;\n\n  if(DEBUG)\n    cout << tab(depth) << v[i] << \" sum=\"<< sum << \" dpth=\" << depth << endl;\n  if( i==initP ){\n    if( sum==0 ) return true;\n    else return false;\n  }else{\n    if( sum==0 ) return false;\n  }\n\n  if( rl[i].size()<=1 )    return true;\n  depth++;\n  for( int j=0;j<(int)rl[i].size();j++ ){\n    if( rl[i][j].second>0 ) continue;\n    int nS = sum + rl[i][j].second;\n    if( dfs( rl[i][j].first,nS,initP,depth)==false )\n      return false;\n  }\n  return true;\n}\n\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int i=0;i<n;i++ ){\n    if( rl[i].size()<=1 ) continue;\n\n    if(DEBUG)cout << v[i] << \" ************************\" << endl;\n    for( int j=0;j<(int)rl[i].size();j++ ){\n      if( rl[i][j].second<0 ) continue;\n\n      if( dfs(rl[i][j].first,rl[i][j].second,i,1)==false )\n\treturn false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    map<string,int> units; // units[ a ] でaの配列番号が分かる\n    map<string,int>::iterator it;\n\n    v.clear();\n    for( int i=0;i<n;i++ )\n      rl[i].clear();\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() ){\n\tunits.insert( P(a,(int)units.size()) ); v.push_back( a );\n      }\n      if( (it=units.find( b ))==units.end() ){\n\tunits.insert( P(b,(int)units.size()) ); v.push_back( b );\n      }\n      int an=units[a], bn=units[b];\n      rl[ an ].push_back( PP(bn,x) );  rl[ bn ].push_back( PP(an,-x) );\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\n\nint main() {\n\t\n\twhile (true) {\n\t\tint T;cin>>T;\n\t\tif(!T)break;\n\t\tmap<string,int>mp;\n\t\tint id=0;\n\t\taUnionFind uf(1000);\n\t\tbool ok=true;\n\t\twhile (T--) {\n\t\t\tstring one,name1,eq,num,name2;\n\t\t\tcin>>one>>name1>>eq>>num>>name2;\n\n\t\t\tif (mp.find(name1) == mp.end()) {\n\t\t\t\tmp[name1]=id++;\n\t\t\t}\n\t\t\tif (mp.find(name2) == mp.end()) {\n\t\t\t\tmp[name2]=id++;\n\t\t\t}\n\n\t\t\tstring n_st(num);\n\t\t\tint anum=stoi(n_st.substr(3));\n\n\t\t\tif (uf.root(mp[name1]).first != uf.root(mp[name2]).first) {\n\t\t\t\tuf.unionSet(mp[name1],mp[name2],anum);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (uf.root(mp[name1]).second + anum == uf.root(mp[name2]).second) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int, int> pii;\n\nstruct UnionFind_W {\n\tvector<pii> data;\n\tUnionFind_W(int size) : data(size, { -1,0 }) { }\n\tbool unionSet(int x, int y, int d) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tint ox = x;\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tdata[x].first += data[y].first;\n\t\t\tdata[y].second = data[ox].second + d; data[y].first = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tint findSet(int x, int y) { //x??????y?????????\n\t\tint rx = root(x), ry = root(y);\n\t\tif (rx == ry) {\n\t\t\treturn data[x].second - data[y].second;\n\t\t}\n\t\treturn INT_MAX;\n\t}\n\tint root(int x) {\n\t\tif (data[x].first < 0)\n\t\t\treturn x;\n\t\tint op = data[x].first;\n\t\tdata[x].first = root(data[x].first);\n\t\tdata[x].second += data[op].second;\n\t\treturn data[x].first;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)].first;\n\t}\n};\n\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n)) {\n\t\tif (!n)\n\t\t\treturn 0;\n\t\n\t\tUnionFind_W uf(n*2);\n\t\tmap<string, int> unit;\n\t\tchar str[17],str2[17];\n\t\tbool f = 1;\n\t\tREP(i, n) {\n\t\t\tint d;\n\t\t\tscanf(\"%*d%s%*s%*d%*c%d%s\", str, &d, str2);\n\t\t\tif (!unit.count(str))\n\t\t\t\tunit[str] = unit.size();\n\t\t\tif (!unit.count(str2))\n\t\t\t\tunit[str2] = unit.size();\n\n\t\t\tint he = uf.findSet(unit[str], unit[str2]);\n\t\t\tif (he == INT_MAX) {\n\t\t\t\tuf.unionSet(unit[str], unit[str2], d);\n\t\t\t}\n\t\t\telse if (he != -d) {\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\tf = 0;\n\t\t\t\trep(j, i, n-1) {\n\t\t\t\t\tscanf(\"%*d%s%*s%*d%*c%d%s\", str, &d, str2);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t\tprintf(\"Yes\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<map>\n#include<string>\nusing namespace std;\n\n#define INF 100000000\n\nint main()\n{\t\n\tint n;\n\tstring temp;\n\tint a;\n\tint cost[201][201],minicost[201];\n\twhile(cin>>n && n!=0){\n\n\t\tfor(int i=0;i<=200;i++){\n\t\t\tfor(int j=0;j<=200;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t\tminicost[i]=INF;\n\t\t}\n\n\n\t\tmap<string,int> Idx;\n\t\tint num=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a;//1\n\t\t\tstring s,t,p; cin>>s>>temp>>p>>t;\n\t\t\tif(!Idx.count(s)){Idx[s]=num++;}\n\t\t\tif(!Idx.count(t)){Idx[t]=num++;}\n\t\t\tstd::istringstream is(p);\n\t\t\tint k;\n\t\t\tchar taa;\n\t\t\tis>>a>>taa>>k;\n\t\t\tcost[Idx[s]][Idx[t]]=k;\n\t\t\tcost[Idx[t]][Idx[s]]=-k;\n\t\t}\n\n\t\tint count=0;\n\t\twhile(true){\n\t\t\tbool update=false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(cost[i][j]<INF){\n\t\t\t\t\t\tif(minicost[j]>minicost[i]+cost[i][j]){\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\tminicost[j]=minicost[i]+cost[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update){cout<<\"Yes\"<<endl;break;}\n\t\t\tcount++;\n\t\t\tif(count>n+1){cout<<\"No\"<<endl;break;}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nint main(){\n  while(true){\n    int n,m=0;\n    int a,b,e;\n    string s1,s2;\n    char c,d;\n    int i,j,k;\n    cin>>n;\n    if(!n)break;\n    int graph[200][200];\n    for(i=0;i<200;i++)\n      for(j=0;j<200;j++)\n\tgraph[i][j] = 10000000;\n    vector<string> names(200);\n    for(i=0;i<n;i++){\n      cin>>a>>s1>>c>>b>>d>>e>>s2;\n      j=0,k=0;\n      for(;j<m;j++)if(names[j]==s1)break;\n      if(j==m){\n\tnames[j] = s1;\n\tm++;\n      }\n      for(;k<m;k++)if(names[k]==s2)break;\n      if(k==m){\n\tnames[k] = s2;\n\tm++;\n      }\n      graph[k][j] = e;\n      graph[j][k] = -e;\n    }\n    for(k=0;k<m;k++){\n      for(i=0;i<m;i++){\n\tfor(j=0;j<m;j++){\n\t  if(graph[i][k]+graph[k][j]<graph[i][j])graph[i][j]=graph[i][k]+graph[k][j];\n\t}\n      }\n    }\n    bool bb = true;\n    for(i=0;i<m;i++)\n      if(graph[i][i]<0)bb=false;\n    if(bb)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n  string s, t;\n  int c;\n} Unit;\n\nint main()\n{\n  const int INF = 1 << 29;\n\n  int N;\n  while (~scanf(\"%d\", &N)) {\n    if (N == 0)\n      break;\n\n    map<string, int> toIndex;\n    vector<Unit> unit(N);\n    for (int i = 0; i < N; ++i) {\n      string s, t, c;\n      cin >> t >> t >> c >> c >> s;\n      int cc = atoi(c.substr(c.find_first_of(\"^\")+1).c_str());\n      unit[i].s = s;\n      unit[i].t = t;\n      unit[i].c = cc;\n      if (toIndex.find(s) == toIndex.end())\n\ttoIndex[s] = toIndex.size()-1;\n      if (toIndex.find(t) == toIndex.end())\n\ttoIndex[t] = toIndex.size()-1;\n    }\n\n    vector<vector<int> > cost(toIndex.size(), vector<int>(toIndex.size(), INF));\n    for (int i = 0; i < cost.size(); ++i)\n      cost[i][i] = 0;\n\n    for (int i = 0; i < N; ++i) {\n      int s = toIndex.find(unit[i].s)->second;\n      int t = toIndex.find(unit[i].t)->second;\n      cost[s][t] = unit[i].c;\n      cost[t][s] = -unit[i].c;\n    }\n\n    for (unsigned int k = 0; k < cost.size(); ++k) {\n      for (unsigned int i = 0; i < cost.size(); ++i) {\n\tfor (unsigned int j = 0; j < cost.size(); ++j)\n\t  cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n      }\n    }\n\n    bool yes = true;\n    for (unsigned int i = 0; i < cost.size() && true; ++i) {\n      for (unsigned int j = i+1; j < cost.size() && true; ++j) {\n\tif (cost[i][j] != -cost[j][i])\n\t  yes = false;\n      }\n    }\n\n    if (yes)\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <list>\n\n\nint* find(\n    std::unordered_map<std::string, std::unordered_map<std::string, int> > *map,\n    const std::string &s1, const std::string &s2)\n{\n    auto it1 = map->find(s1);\n    if (it1 == map->end()) return NULL;\n\n    auto it2 = it1->second.find(s2);\n    return (it2 == it1->second.end()) ? NULL : &it2->second;\n}\n\n\nbool walk(\n    std::unordered_map<std::string, std::unordered_map<std::string, int> > *map,\n    const std::tuple<std::string, std::string, int> &t)\n{\n    const std::string &s0 = std::get<0>(t);\n    const std::string &s1 = std::get<1>(t);\n    int mag1 = std::get<2>(t);\n\n    int *old = find(map, s0, s1);\n    if (old == NULL)\n    {\n        (*map)[s0][s1] = mag1;\n        (*map)[s1][s0] = -mag1;\n    }\n    else if (*old != mag1)\n        return false;\n\n    std::list<std::tuple<std::string, std::string, int> > next;\n        \n    for (auto x : map->at(s0))\n    {\n        const std::string &s2 = x.first;\n        int mag2 = x.second;\n        \n        if (s1 != s2)\n        if (find(map, s1, s2) == NULL)\n            next.push_back(std::make_tuple(s1, s2, -mag1 + mag2));\n    }\n    \n    for (auto x : map->at(s1))\n    {\n        const std::string &s2 = x.first;\n        int mag2 = x.second;\n        \n        if (s0 != s2)\n        if (find(map, s0, s2) == NULL)\n            next.push_back(std::make_tuple(s0, s2, mag1 + mag2));\n    }\n\n    for (auto t : next)\n        if (!walk(map, t))\n            return false;\n\n    return true;\n}\n\n\nint main()\n{\n    char line[256];\n    \n    while (not std::cin.eof())\n    {\n        int n;\n        std::cin >> n;\n        if (n == 0) break;\n\n        std::list<std::tuple<std::string, std::string, int> > inputs;\n        \n        for (int i = 0; i < n; ++i)\n        {\n            int x;\n            std::string s1, s2;\n            \n            std::cin.ignore(2);\n            std::cin >> s1;\n            std::cin.ignore(6);\n            std::cin >> x >> s2;\n\n            inputs.push_back(std::make_tuple(s1, s2, x));\n        }\n\n        std::unordered_map<std::string,\n            std::unordered_map<std::string, int> > map;\n        bool is_valid(true);\n        \n        for (auto x : inputs)\n            if (!walk(&map, x))\n            {\n                is_valid = false;\n                break;\n            }\n\n        std::cout << (is_valid ? \"Yes\" : \"No\") << std::endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int nn = 0;\n    string str;\n    getline(cin,str);\n    map<string,int> m;\n    //vector<vector<int> > v;\n    //v.assign(n, vector<int>(n,INF));\n    vector<int> v[100];\n    for(int i=0;i<n;i++) v[i].assign(n,INF);\n    while(n--){\n      string str2, str3;\n      bool f = false, f2 = false, minus = false;\n      int a = 0;\n      getline(cin,str);\n\n      for(int i=2;i<str.size();i++){\n\tif(!f && !f2 && str[i] != ' '){\n\t  //str2 += str[i];\n\t  str2.insert(str2.size(),1,str[i]);\n\t}\n\telse if(!f && !f2 && str[i] == ' '){\n\t  f = true;\n\t  i += 6;\n\t  if(str[i] == '-'){\n\t    minus = true;\n\t    i++;\n\t    a = str[i] - '0';\n\t    a *= -1;\n\t  }\n\t  else a = str[i] - '0';\n\t}\n\telse if(!f2 && str[i] != ' '){\n\t  a *= 10;\n\t  if(minus) a -= str[i] - '0';\n\t  else a += str[i] - '0';\n\t}\n\telse if(!f2 && str[i] == ' ') f2 = true;\n\telse{\n\t  //str3 += str[i];\n\t  str3.insert(str3.size(),1,str[i]);\n\t}\n      }\n      if(m.find(str2) == m.end()) m[str2] = nn++;\n      if(m.find(str3) == m.end()) m[str3] = nn++;\n      //cout << str2 << \" \" << str3 << \" \" << a << endl;\n      v[m[str2]][m[str3]] = a;\n      v[m[str3]][m[str2]] = -1 * a;\n    }\n\n    bool ans = true;\n\n    for(int k=0;k<v[0].size();k++){\n      for(int i=0;i<v[0].size();i++){\n\tfor(int j=0;j<v[0].size();j++){\n\t  if(i != j && v[i][j] == INF && v[i][k] < INF && v[k][j] < INF) v[i][j] = v[i][k] + v[k][j];\n\t}\n      }\n    }\n\n    for(int k=0;k<v[0].size();k++){\n      for(int i=0;i<v[0].size();i++){\n\tfor(int j=0;j<v[0].size();j++){\n\t  if(v[i][j] >= INF || v[i][k] >= INF || v[k][j] >= INF) continue;\n\t  if(v[i][j] != v[i][k] + v[k][j]){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    /*for(int i=1;i<v.size();i++){\n      for(int j=1;j<v.size();j++){\n\tif(v[i][j] == INF) cout << \" I \";\n\telse printf(\"%2d \",v[i][j]);\n      }\n      cout << endl;\n      }*/\n\n    if(ans) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<set>\n#include<cstdio>\n#include<cassert>\n#define F first\n#define S second\n#define inf (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nstruct P\n{\n  string unit;\n  int mpower;\n  int upower;\n  P(string unit=\"$\",int upower=-inf,int mpower=-inf):unit(unit),upower(upower),mpower(mpower){}\n};\nvector<vector<P> > G(110);\nmap<string,int> exist;\n\nint toPower(string s)\n{\n  if(s == \"1\")return 0;\n  int pos = 0;\n  rep(i,s.size())\n    {\n      if(s[i] == '^')\n\t{\n\t  pos = i+1;\n\t  break;\n\t}\n    }\n  return (atoi)(s.substr(pos,s.size()-pos).c_str());\n}\n\nbool used[110];\nint isok;//-1 -> No, 0 => Not yet, 1 -> Ok\n\nvoid dfs(string now,string target,int power,int target_power)\n{\n  if(isok != 0)return;\n  if(now == target)\n    {\n      isok = (power == target_power?1:-1);\n      return;\n    }\n  int index = exist[now];\n  if(used[index])return;\n  used[index] = true;\n\n  rep(i,G[index].size())\n    {\n      P p = G[index][i];\n      int next_index = exist[p.unit];\n      if(used[next_index])continue;\n      dfs(p.unit,target,power+(p.mpower==0?p.upower:-p.mpower),target_power );\n    }\n}\n\nbool check(string u1,string u2,int power)\n{\n  rep(i,110)used[i] = false;\n  isok = 0;\n\n  dfs(u1,u2,0,power);\n  return isok == 1;\n}\n\nbool reachable;\n\nvoid move(int now,int target)\n{\n  if(now == target)\n    {\n      reachable = true;\n      return;\n    }\n\n  if(used[now])return;\n  used[now] = true;\n  rep(i,G[now].size())\n    {\n      //assert(exist.count(G[now][i].unit));\n\n      move(exist[G[now][i].unit],target);\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N , N)\n    {\n      rep(i,N)G[i].clear();\n      int index = 0;\n      exist.clear();\n      bool result = true;\n      rep(i,N)\n\t{\n\t  string v1,unit1,v2,unit2,eq;\n\t  cin >> v1 >> unit1 >> eq >> v2 >> unit2;\n\n\t  assert(unit1 != unit2);\n\t  if(!result)continue;\n\t  //cout << toPower(v1) << \" \" << unit1 << \" = \"<< toPower(v2) << \" \" << unit2 << endl;\n\t  if(exist.count(unit1) && exist.count(unit2))\n\t    {\n\t      rep(i,N)used[i] = false;\n\t      reachable = false;\n\t      move(exist[unit1],exist[unit2]);\n\t      if(reachable)\n\t\t{\n\t\t  int p1 = toPower(v1);\n\t\t  int p2 = toPower(v2);\n\t\t  result = check(unit1,unit2,p2);\n\t\t  //cout << \"result = \" << result << endl;\n\t\t}\n\t      else\n\t\t{\n\t\t  goto Insert;\n\t\t}\n\t      continue;\n\t    }\n\n\t  //cout << \"not exists\" << endl;\n\t  if(!exist.count(unit1))exist[unit1] = index++;\n\t  if(!exist.count(unit2))exist[unit2] = index++;\n\tInsert:;\n\t  int index1 = exist[unit1];\n\t  int index2 = exist[unit2];\n\t  G[index1].push_back(P(unit2,toPower(v2),toPower(v1)));\n\t  G[index2].push_back(P(unit1,toPower(v1),toPower(v2)));\n\t}\n      cout << (result?\"Yes\":\"No\") << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nmap<string,vector<pair<string,int> > > b;\nmap<string,int> c;\nint fn(string s,int p){\n  int i;\n  if(c.count(s)){\n    if(c[s]!=p)\n      return 1;\n    else\n      return 0;\n  }else{\n    c[s]=p;\n    for(i=0;i<(int)b[s].size();i++){\n      if(fn(b[s][i].first,p+b[s][i].second))\n\treturn 1;\n    }\n    c.erase(s);\n    return 0;\n  }\n}\nint main(){\n  int i;\n  int n;\n  while(cin>>n,n){\n    set<string> a;\n    b.clear();\n    for(i=0;i<n;i++){\n      string s,t;\n      char c;\n      int p;\n      cin>>s>>s>>c>>c>>c>>c>>p>>t;\n      a.insert(s);\n      a.insert(t);\n      b[s].push_back(make_pair(t,-p));\n      b[t].push_back(make_pair(s,p));\n    }\n    set<string>::iterator it;\n    for(it=a.begin();it!=a.end();it++){\n      c.clear();\n      if(fn(*it,0))\n\tbreak;\n    }\n    if(it!=a.end())\n      cout<<\"No\"<<endl;\n    else\n      cout<<\"Yes\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#define P pair<string,int>\n#define PP pair<int,int>\n#define DEBUG false\nusing namespace std;\n\nint n;\nvector<PP> rl[110]; // 単位間の関係\nvector<string> v; // 一応単位の文字列を保持.インデックスはunitsと同じ。\n\nstring tab(int len){\n  string r=\"\";  for( int  i=0;i<len;i++ ) r+=\"  \";\n  return r;\n}\n\n\n/* 単位系が誤っているとfalseを返す */\nbool dfs(int i, int sum, int initP,int depth){\n  if( depth==110 ) return false;\n\n  if(DEBUG)\n    cout << tab(depth) << v[i] << \" sum=\"<< sum << \" dpth=\" << depth << endl;\n  if( i==initP ){\n    if( sum==0 ) return true;\n    else return false;\n  }else{\n    if( sum==0 ) return false;\n  }\n\n  if( rl[i].size()<=1 )    return true;\n  depth++;\n  for( int j=0;j<(int)rl[i].size();j++ ){\n    if( rl[i][j].second>0 ) continue;\n    int nS = sum + rl[i][j].second;\n    if( dfs( rl[i][j].first,nS,initP,depth)==false )\n      return false;\n  }\n  return true;\n}\n\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int i=0;i<n;i++ ){\n    if( rl[i].size()<=1 ) continue;\n\n    if(DEBUG)cout << v[i] << \" ************************\" << endl;\n    for( int j=0;j<(int)rl[i].size();j++ ){\n      if( rl[i][j].second<0 ) continue;\n\n      if( dfs(rl[i][j].first,rl[i][j].second,i,1)==false )\n\treturn false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    map<string,int> units; // units[ a ] でaの配列番号が分かる\n    map<string,int>::iterator it;\n\n    v.clear();\n    for( int i=0;i<n;i++ )\n      rl[i].clear();\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() ){\n\tunits.insert( P(a,(int)units.size()) ); v.push_back( a );\n      }\n      if( (it=units.find( b ))==units.end() ){\n\tunits.insert( P(b,(int)units.size()) ); v.push_back( b );\n      }\n      int an=units[a], bn=units[b];\n      rl[ an ].push_back( PP(bn,x) );  rl[ bn ].push_back( PP(an,-x) );\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \n\nint main(void){  \n  int N;\n  while(cin>>N){\n    if(!N) break;\n    vector<string> tani;\n    vector<int> ind;\n    bool flag = true;\n    bool first = true;\n    int tmp;\n    string tmp2;\n    while(N--){\n      string tani1,tani2;\n      int index;\n      cin>>tmp;\n      cin>>tani1;\n      cin>>tmp2;\n      cin>>tmp2;\n      index = (tmp2[3]!='-')?(tmp2[3]-'0'):('0' - tmp2[4]);\n      cin>>tani2;\n      if(first){\n        tani.push_back(tani1); tani.push_back(tani2);\n        ind.push_back(0); ind.push_back(index);\n        first = false;\n        continue;\n      }\n      vector<string>::iterator it1 = find(tani.begin(),tani.end(),tani1)\n        , it2 = find(tani.begin(),tani.end(),tani2);\n      bool f1 = (it1 != tani.end());\n      bool f2 = (it2 != tani.end());\n      int ind1 = ind[distance(tani.begin(),it1)];\n      int ind2 = ind[distance(tani.begin(),it2)];\n      if(f1){\n        if(f2){\n          if(ind2 - ind1 != index){\n            flag = false;\n          }\n        }else{\n          ind.push_back(ind1 + index);\n          tani.push_back(tani2);\n        }\n      }else{\n        if(f2){\n          ind.push_back(ind2 - index);\n          tani.push_back(tani1);\n        }\n      }\n    }\n    if(flag) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<set>\n#include<cstdio>\n#include<cassert>\n#define F first\n#define S second\n#define inf (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nstruct P\n{\n  string unit;\n  int mpower;\n  int upower;\n  P(string unit=\"$\",int upower=-inf,int mpower=-inf):unit(unit),upower(upower),mpower(mpower){}\n};\nvector<vector<P> > G(110);\nmap<string,int> exist;\n\nint toPower(string s)\n{\n  if(s == \"1\")return 0;\n  int pos = 0;\n  rep(i,s.size())\n    {\n      if(s[i] == '^')\n\t{\n\t  pos = i+1;\n\t  break;\n\t}\n    }\n  return (atoi)(s.substr(pos,s.size()-pos).c_str());\n}\n\nbool used[110];\nint isok;//-1 -> No, 0 => Not yet, 1 -> Ok\n\nvoid dfs(string now,string target,int power,int target_power)\n{\n  if(isok != 0)return;\n  if(now == target)\n    {\n      isok = (power == target_power?1:-1);\n      return;\n    }\n  int index = exist[now];\n  if(used[index])return;\n  used[index] = true;\n\n  rep(i,G[index].size())\n    {\n      P p = G[index][i];\n      int next_index = exist[p.unit];\n      if(used[next_index])continue;\n      dfs(p.unit,target,power+(p.mpower==0?p.upower:-p.mpower),target_power );\n    }\n}\n\nbool check(string u1,string u2,int power)\n{\n  rep(i,110)used[i] = false;\n  isok = 0;\n\n  dfs(u1,u2,0,power);\n  return isok == 1;\n}\n\nbool reachable;\n\nvoid move(int now,int target)\n{\n  if(now == target)\n    {\n      reachable = true;\n      return;\n    }\n\n  if(used[now])return;\n  used[now] = true;\n  rep(i,G[now].size())\n    {\n      //assert(exist.count(G[now][i].unit));\n\n      move(exist[G[now][i].unit],target);\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N , N)\n    {\n      rep(i,N)G[i].clear();\n      int index = 0;\n      exist.clear();\n      bool result = true;\n      rep(i,N)\n\t{\n\t  string v1,unit1,v2,unit2,eq;\n\t  cin >> v1 >> unit1 >> eq >> v2 >> unit2;\n\n\t  assert(unit1 != unit2);\n\t  if(!retult)continue;\n\t  //cout << toPower(v1) << \" \" << unit1 << \" = \"<< toPower(v2) << \" \" << unit2 << endl;\n\t  if(exist.count(unit1) && exist.count(unit2))\n\t    {\n\t      rep(i,N)used[i] = false;\n\t      reachable = false;\n\t      move(exist[unit1],exist[unit2]);\n\t      if(reachable)\n\t\t{\n\t\t  int p1 = toPower(v1);\n\t\t  int p2 = toPower(v2);\n\t\t  result = check(unit1,unit2,p2);\n\t\t  //cout << \"result = \" << result << endl;\n\t\t}\n\t      continue;\n\t    }\n\n\t  //cout << \"not exists\" << endl;\n\t  if(!exist.count(unit1))exist[unit1] = index++;\n\t  if(!exist.count(unit2))exist[unit2] = index++;\n\t  int index1 = exist[unit1];\n\t  int index2 = exist[unit2];\n\t  G[index1].push_back(P(unit2,toPower(v2),toPower(v1)));\n\t  G[index2].push_back(P(unit1,toPower(v1),toPower(v2)));\n\t}\n      cout << (result?\"Yes\":\"No\") << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvector<vector<Edge> > edges;\nvector<bool> check;\n\nbool checkNg(int s, int t, int rest)\n{\n    check[s] = true;\n    if(s == t)\n        return rest != 0;\n\n    for(unsigned i=0; i<edges[s].size(); ++i){\n        int next = edges[s][i].to;\n        if(check[next])\n            continue;\n        if(checkNg(next, t, rest - edges[s][i].cost))\n            return true;\n    }\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        bool ok = true;\n        map<string, int> index;\n        edges.assign(n*2, vector<Edge>(0));\n        for(int i=0; i<n; ++i){\n            string s1, s2;\n            int x;\n            char c;\n            cin >> c >> s1 >> c >> c >> c >> c >> x >> s2;\n\n            int k1, k2;\n            if(index.find(s1) == index.end()){\n                k1 = index.size();\n                index[s1] = k1;\n            }else{\n                k1 = index[s1];\n            }\n            if(index.find(s2) == index.end()){\n                k2 = index.size();\n                index[s2] = k2;\n            }else{\n                k2 = index[s2];\n            }\n\n            check.assign(2*n, false);\n            if(checkNg(k1, k2, x))\n                ok = false;\n\n            edges[k1].push_back(Edge(k2, x));\n            edges[k2].push_back(Edge(k1, -x));\n        }\n\n        if(ok)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nmap<string,int> done;\nmap<string , vector< pair<string,int> > > graph;\nbool flag;\n\nvoid dfs(string p,int cost){\n\tif(done.find(p) != done.end()){\n\t\tif(cost != done[p]) flag = false;\n\t\treturn;\n\t}else{\n\t\tdone[p] = cost;\n\t}\n\tvector<pair<string,int> > r = graph[p];\n\tfor(int i = 0 ; i < r.size() ; i++){\n\t\tdfs( r[i].first , cost + r[i].second );\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n , n){\n\t\tgraph.clear();\n\t\tvector<string> vertex;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a,b,c,d;\n\t\t\tcin >> d >> a >> d >> c >> b;\n\t\t\tc = c.substr(c.find(\"^\")+1);\n\t\t\tint cost = atoi(c.c_str());\n\t\t\tgraph[b].push_back(make_pair(a,cost));\n\t\t\tgraph[a].push_back(make_pair(b,-cost));\n\t\t\tvertex.push_back(a);\n\t\t\tvertex.push_back(b);\n\t\t}\n\t\tsort(vertex.begin(),vertex.end());\n\t\tvertex.erase(unique(vertex.begin(),vertex.end()),vertex.end());\n\t\tbool ans = true;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdone.clear();\n\t\t\tflag = true;\n\t\t\tdfs(vertex[i] , 0);\n\t\t\tans &= flag;\n\t\t}\n\t\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int INF = 1e9 + 7;\n\nmap<int, int> v, parent, dist;\nmap<string, int> M;\n\n// P(parent, dist)\nP find(int a){\n  if(parent[a] == a) return P(a, dist[a]);\n  P p = find(parent[a]);\n  parent[a] = p.first;\n  dist[a] += p.second;\n  return P(p.first, dist[a]);\n}\n\nbool same(int a, int b){ return find(a).first == find(b).first; }\n\nvoid merge(int a, int b, int dd){\n  if(same(a, b)) return ;\n  P pa = find(a), pb = find(b);\n  int d = dd - pb.second + pa.second;\n  if(d < 0){\n    d *= -1;\n    swap(pa, pb);\n  }\n  parent[pb.first] = pa.first;\n  dist[pb.first] = d;\n}\n\nint distance(int a, int b){\n  if(!same(a, b)) return INF;\n  return find(b).second - find(a).second;\n}\n\nint get_number(string &s){\n  if(M.find(s) != M.end()) return M[s];\n  int num = M.size();\n  M[s] = num;\n  parent[num] = num;\n  return num;\n}\n\nint get_distance(string &s){\n  int idx = 0;\n  while(s[idx++] != '^') ;\n  return atoi(s.substr(idx).c_str());\n}\n\nvoid input(string &as, int &d, string &bs){\n  string s, tmp;\n  cin >>tmp >>as >>tmp >>s >>bs;\n  d = get_distance(s);\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    bool ans = true;\n    REP(i, N){\n      string as, bs; int d;\n      input(as, d, bs);\n      int a = get_number(as), b = get_number(bs);\n      //cout <<as <<\", \" <<d <<\", \" <<bs <<\", \" <<a <<\", \" <<b <<\" | \" <<same(a, b) <<\", \" <<distance(a, b) <<endl;\n      if(same(a, b)) { if(distance(a, b) != d) ans = false; }\n      else merge(a, b, d);\n    }\n    cout <<(ans ? \"Yes\" : \"No\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint n;\nmap<string, int> stoi;\nbool visited[200][200];\nint cost[200];\nint G[200][200];\n\nint conv(string& str){\n  int res = 1;\n  for(int i=0;i<str.size();i++){\n    if(str[i] == '^'){\n      if(str[i+1] == '-'){\n\tres *= -1;\n\ti++;\n      }\n      res *= atoi(str.substr(i+1).c_str());\n    }\n  }\n  return res;\n}\n\nbool dfs(int p, int cos){\n  if(cost[p] == INF) cost[p] = cos;\n  if(cost[p] != cos) return false;\n  for(int i=0;i<n;i++){\n    if(visited[p][i]) continue;\n    if(G[p][i] == INF) continue;\n    visited[p][i] = visited[i][p] = true;\n    if(!dfs(i, cos + G[p][i])) return false;\n  }\n  return true;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(G[0], G[200], INF);\n    int size = 0;\n    for(int i=0;i<n;i++){\n      string a, b;\n      int in;\n      cin >> a;\n      cin >> a;\n      cin >> b;\n      cin >> b;\n      in = conv(b);\n      cin >> b;\n      int c, d;\n      if(stoi.find(a) == stoi.end()){\n\tstoi[a] = size++;\n      }\n      if(stoi.find(b) == stoi.end()){\n\tstoi[b] = size++;\n      }\n      c = stoi[a];\n      d = stoi[b];\n      G[c][d] = in;\n      G[d][c] = -in;\n    }\n    bool ans = true;\n    for(int i=0;i<n;i++){\n      fill(visited[0], visited[200], false);\n      fill(cost, cost+200, INF);\n      if(!dfs(i, 0)){\n\tans = false;\n\tbreak;\n      }\n    }\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nmap <string,int> M;\nvector <P> e[201];\nint C[201],used[201];\n\nbool check(int ima,int cost){\n  if(used[ima])return (cost-C[ima])==0;\n  used[ima]=1,C[ima]=cost;\n  for(int i=0;i<e[ima].size();i++)\n    if(!check(e[ima][i].f,cost+e[ima][i].s))return 0;\n  return 1;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){;\n    for(int i=0;i<2*n;i++)e[i].clear();\n    M.clear();\n\n    int N=0;\n    for(int i=0;i<n;i++){\n      string a,b,c,d,E;\n      cin>>a>>b>>c>>d>>E;\n      if(!M.count(b))M[b]=N++;\n      if(!M.count(E))M[E]=N++;\n      int num=0,j=3,flg=1;\n      if(d[3]=='-')flg=-1,j=4;\n      while(j<d.size())num=num*10+d[j++]-'0';\n      e[M[b]].push_back(P(M[E],num*flg));\n      e[M[E]].push_back(P(M[b],-num*flg));\n    }\n\n    int ans=1;\n    for(int i=0;i<N;i++){\n      memset(used,0,sizeof(used)),memset(C,0,sizeof(C));\n      ans*=check(i,0);\n    }\n    cout <<(ans? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nvector<pair<int, int> > edge[1000];\nchar str1[100];\nchar str2[100];\nint dist[1000];\n\nbool dfs(int now, int cost) {\n  if (dist[now] != 0x0f0f0f0f) {\n    return dist[now] == cost;\n  }\n  dist[now] = cost;\n  FORIT(it, edge[now]) {\n    if (!dfs(it->first, cost + it->second)) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\nREP(i, 1000) { edge[i].clear(); }\n  map<string, int> open;\n  int m = 0;\n  REP(i, n) {\n    int cost;\n    scanf(\" 1 %s = 10^ %d %s\", str1, &cost, str2);\n    if (!open.count((string)str1)) { open[(string)str1] = m++; }\n    if (!open.count((string)str2)) { open[(string)str2] = m++; }\n    int l = open[(string)str1];\n    int r = open[(string)str2];\n    edge[l].push_back(make_pair(r, -cost));\n    edge[r].push_back(make_pair(l, cost));\n  }\n  MEMSET(dist, 0x0f);\n  REP(i, m) {\n    if (dist[i] != 0x0f0f0f0f) { continue; }\n    if (dfs(i, 0)) {\n    } else {\n      puts(\"No\");\n      goto next;\n    }\n  }\n  puts(\"Yes\");\nnext:;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nmap <string,int> M;\nvector <P> e[301];\nint C[301],used[301];\n\nbool check(int ima,int cost){\n  int size=e[ima].size();\n  if(used[ima])return (cost-C[ima])==0;\n  used[ima]=1,C[ima]=cost;\n  for(int i=0;i<size;i++)\n    if(!check(e[ima][i].f,cost+e[ima][i].s))return 0;\n  return 1;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){;\n    for(int i=0;i<300;i++)e[i].clear();\n    M.clear();\n\n    int N=0;\n    for(int i=0;i<n;i++){\n      string a,b,c,d,E;\n      cin>>a>>b>>c>>d>>E;\n      if(!M.count(b))M[b]=N++;\n      if(!M.count(E))M[E]=N++;\n      int num=0,j=3,flg=1;\n      if(d[3]=='-')flg=-1,j=4;\n      while(j<d.size())num=num*10+d[j++]-'0';\n      e[M[b]].push_back(P(M[E],num*flg));\n      e[M[E]].push_back(P(M[b],-num*flg));\n    }\n\n    int ans=1;\n    for(int i=0;i<N;i++){\n      memset(used,0,sizeof(used));\n      memset(C,0,sizeof(C));\n      ans*=check(i,0);\n    }\n    cout <<(ans? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <string>\n\nusing namespace std;\n\npair<int, int> par[256];\n\nvoid init(int n)\n{\n\tfor (int i = 0; i < n; i++){\n\t\tpar[i] = make_pair(i, 0);\n\t}\n}\n\npair<int, int> find(int x)\n{\n\tif (par[x].first == x) return (par[x]);\n\tpair<int, int> ret = find(par[x].first);\n\treturn (par[x] = make_pair(ret.first, par[x].second + ret.second));\n}\n\nbool same(int u, int v)\n{\n\treturn (find(u).first == find(v).first);\n}\n\nvoid merge(int u, int v, int val)\n{\n\tpair<int, int> uu = find(u);\n\tpair<int, int> vv = find(v);\n\t\n\tif (uu.first == vv.first) return;\n\t\n\tpar[uu.first] = make_pair(vv.first, vv.second + val);\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\tgetchar();\n\t\t\n\t\tmap<string, int> mp;\n\t\tinit(256);\n\t\tbool ok = true;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tchar s[1024], t[1024];\n\t\t\tint val;\n\t\t\t\n\t\t\tscanf(\"1 %s = 10^%d %s\", s, &val, t);\n\t\t\tgetchar();\n\t\t\t\n\t\t\tstring ss = s, st = t;\n\t\t\tif (!mp.count(ss)){\n\t\t\t\tint ct = mp.size();\n\t\t\t\tmp[ss] = ct;\n\t\t\t}\n\t\t\tif (!mp.count(st)){\n\t\t\t\tint ct = mp.size();\n\t\t\t\tmp[st] = ct;\n\t\t\t}\n\t\t\t\n\t\t\tint u = mp[ss], v = mp[st];\n\t\t\tif (same(u, v)){\n\t\t\t\tif (par[u].second - par[v].second != val) ok = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmerge(u, v, val);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b)a=b;};\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b)a=b;};\n\ntemplate <typename T>\nstruct WeightedUnionFind{\n  int n;\n  T d;\n  vector<int> r, p;\n  vector<T> ws;\n  WeightedUnionFind(){}\n  WeightedUnionFind(int sz, T d_):\n    n(sz), d(d_), r(n, 1), p(n), ws(n, d){iota(p.begin(), p.end(), 0);}\n\n  int find(int x){\n    if(x == p[x]){\n      return x;\n    }else{\n      int t = find(p[x]);\n      ws[x] += ws[ p[x] ];\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x){\n    find(x);\n    return ws[x];\n  }\n\n  int same(int x,int y){\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w){\n    w += weight(x);\n    w -= weight(y);\n    x = find(x); y = find(y);\n    if(x == y) return;\n    if(r[x] < r[y]) swap(x, y), w = -w;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x,int y){\n    return weight(y) - weight(x);\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n;\n  while(cin>>n,n){\n    WeightedUnionFind<int> uf(n*2,0);\n    int sz=0;\n    map<string,int> idx;\n\n    int flg=1;\n    for(int i=0;i<n;i++){\n      string a,b,c,d,e;\n      cin>>a>>b>>c>>d>>e;\n      if(!idx.count(b)) idx[b]=sz++;\n      if(!idx.count(e)) idx[e]=sz++;\n\n      int dif=stoi(d.substr(3));\n      if(!uf.same(idx[b],idx[e])){\n        uf.unite(idx[b],idx[e],dif);\n      }else{\n        int act=uf.diff(idx[b],idx[e]);\n        //cout<<act<<\" \"<<dif<<endl;\n        flg&=(dif==act);\n      }\n    }\n    cout<<(flg?\"Yes\":\"No\")<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconstexpr int MAX = 514;\nconstexpr int INF = (1 << 25);\n\nstruct Edge {\n    int to, cost;\n    Edge() {}\n    Edge(int to, int cost) :\n        to{to}, cost{cost} {}\n};\n\nvector<Edge> G[MAX];\nint dist[MAX];\n\nbool dfs(int v, int p, int d)\n{\n    if (dist[v] != INF) {\n        return (dist[v] != d);\n    }\n    \n    dist[v] = d;\n\n    for (auto& g : G[v]) {\n        if (g.to == p) continue;\n        if (dfs(g.to, v, d + g.cost)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool run()\n{\n    int N;\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n\n    for (int i = 0; i < N; i++) {\n        G[i].clear();\n    }\n    \n    map<string, int> s2i;\n    \n    string t, u, v;\n    for (int i = 0; i < N; i++) {\n        cin >> u >> u;\n\n        if (s2i.count(u) == 0) {\n            s2i[u] = s2i.size();\n        }\n        \n        cin >> t >> t >> v;\n        t = t.substr(3);\n\n        if (s2i.count(v) == 0) {\n            s2i[v] = s2i.size();\n        }\n        \n        int num = stoi(t);        \n        G[s2i[v]].emplace_back(s2i[u], -num);\n        G[s2i[u]].emplace_back(s2i[v], num);\n    }\n    \n    N = s2i.size();\n    bool ok = 1;\n    for (int i = 0; i < N; i++) {\n        fill(dist, dist + N, INF);\n        if (dfs(i, -1, 0)) {\n            ok = 0;\n            break;\n        }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n\nint main()\n{\n    while (run())\n        ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#define N 210\nusing namespace std;\n\nint n,m;\nint d[N][N];\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int k=0;k<m;k++ )\n    for( int i=0;i<m;i++ )\n      for( int j=0;j<m;j++ )\n\td[i][j] = min( d[i][j],d[i][k]+d[k][j] );\n\n  for( int i=0;i<m;i++ )\n    if( d[i][i]<0 )\n      return false;\n  return true;\n}\n\nint main(){\n  string a,b, s;\n  int x;\n  char c;\n\n  while( cin>>n && n ){\n    m=n*2;\n    for( int i=0;i<m;i++ ){\n      for( int j=0;j<m;j++ )\n\td[i][j]=1000;\n    }\n    map<string,int> units; // units[ a ] でaの配列番号が分かる\n    m=0;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c;  // 10^\n      cin >> x >> b;  // [x] [B];\n\n      if( units.find( a )==units.end() )\n\tunits[a] = m++;\n      if( units.find( b )==units.end() )\n\tunits[b] = m++;\n\n      int an=units[a], bn=units[b];\n      \n      d[an][bn] =  x;\n      d[bn][an] = -x;\n    }\n\n    if( check() ) cout << \"Yes\" << endl;\n    else          cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint n,m,e[100][100];\n\nint main()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tmap<string,int> id;\n\t\trep(i,n)rep(j,n)e[i][j]=inf;\n\t\t\n\t\tstring u1,u2,t; m=0;\n\t\trep(i,n)\n\t\t{\n\t\t\tcin>>t>>u1>>t>>t>>u2;\n\t\t\tif(!id.count(u1))id[u1]=m++;\n\t\t\tif(!id.count(u2))id[u2]=m++;\n\t\t\te[id[u1]][id[u2]]=atoi(t.substr(3).c_str());\n\t\t\te[id[u2]][id[u1]]=-e[id[u1]][id[u2]];\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\t\tbool f=0;\n\t\trep(i,n)if(e[i][i]!=inf&&e[i][i]!=0)f=1;\n\t\tputs(f?\"No\":\"Yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\n\n\nconst int INF = 100000000;\nconst long long INFL = 100000000000000LL;\n\nint n;\nint size;\nmap<string, int> stoi;\nbool visited[200][200];\nlong long cost[200];\nint G[200][200];\n\nint conv(string& str){\n  return atoi(str.substr(3).c_str());\n}\n\nbool dfs(int p, long long cos){\n  if(cost[p] == INFL) cost[p] = cos;\n  if(cost[p] != cos) return false;\n  for(int i=0;i<size;i++){\n    if(i == p) continue;\n    if(visited[p][i]) continue;\n    if(G[p][i] == INF) continue;\n    visited[p][i] = visited[p][i] = true;\n    if(!dfs(i, cos + G[p][i])) return false;\n  }\n  return true;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(G[0], G[200], INF);\n    stoi.clear();\n    size = 0;\n    bool ans = true;\n    for(int i=0;i<n;i++){\n      string a, b;\n      int in;\n      cin >> a;\n      cin >> a;\n      cin >> b;\n      cin >> b;\n      in = conv(b);\n      cin >> b;\n      int c, d;\n      if(stoi.find(a) == stoi.end()){\n\tstoi[a] = size++;\n      }\n      if(stoi.find(b) == stoi.end()){\n\tstoi[b] = size++;\n      }\n      c = stoi[a];\n      d = stoi[b];\n      if(c == d && in != 0) ans = false;\n      G[c][d] = in;\n      G[d][c] = -in;\n    }\n    if(ans){\n      for(int i=0;i<size;i++){\n\tfill(visited[0], visited[200], false);\n\tfill(cost, cost+200, INFL);\n\tif(!dfs(i, 0LL)){\n\t  ans = false;\n\t  break;\n\t}\n      }\n    }\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint x[100];\nstring t1[100], t2[100];\nint g[200][200];\n\nint main() {\n  int n;\n  while(scanf(\"%d\",&n),n) {\n    REP(i,n) {\n      char s1[20],s2[20];\n      scanf(\"%*d %s %*c%*d%*c%d %s\", s1, x+i, s2);\n      t1[i] = string(s1);\n      t2[i] = string(s2);\n    }\n    REP(i,2*n)REP(j,2*n) g[i][j]=INF;\n    REP(i,n)g[i][i]=0;\n    bool f = 1;\n    map<string, int> mp;\n    int num = 0;\n    REP(i,n) {\n      if (mp.count(t1[i]) == 0) mp[t1[i]] = num++;\n      if (mp.count(t2[i]) == 0) mp[t2[i]] = num++;\n      int a = mp[t1[i]];\n      int b = mp[t2[i]];\n\n      \n      if (g[a][b] != INF) {\n        if (g[a][b] != x[i]) {\n          f = 0;\n          break;\n        }\n      } else {\n        g[a][b] = x[i];\n        g[b][a] = -x[i];\n        REP(i,num) {\n          REP(j,num) {\n            if (g[i][a] != INF && g[b][j] != INF) {\n              g[i][j] = g[i][a] + g[a][b] + g[b][j];\n              g[j][i] = -g[i][j];\n            } else if (g[i][b] != INF && g[a][j] != INF) {\n              g[i][j] = g[i][b] + g[b][a] + g[a][j];\n              g[j][i] = -g[i][j];\n            }\n          }\n        }\n      }\n      // REP(i,num) {\n      //   REP(j,num) {\n      //     if (g[i][j] == INF) cout << \"*\" << \" \";\n      //     else cout << g[i][j] << \" \";\n      //   }\n      //   cout << endl;\n      // }\n      // cout << endl;\n    }\n    cout << (f?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int INF = 1e9 + 7;\n\nmap<int, int> v, parent, dist;\nmap<string, int> M;\n\n// P(parent, dist)\nP find(int a){\n  if(parent[a] == a) return P(a, dist[a]);\n  P p = find(parent[a]);\n  parent[a] = p.first;\n  dist[a] += p.second;\n  return P(p.first, dist[a]);\n}\n\nbool same(int a, int b){ return find(a).first == find(b).first; }\n\nvoid merge(int a, int b, int dd){\n  if(same(a, b)) return ;\n  P pa = find(a), pb = find(b);\n  int d = dd - pb.second + pa.second;\n  if(d < 0){\n    d *= -1;\n    swap(pa, pb);\n  }\n  parent[pb.first] = pa.first;\n  dist[pb.first] = d;\n}\n\nint distance(int a, int b){\n  if(!same(a, b)) return INF;\n  return find(b).second - find(a).second;\n}\n\nvoid init_union_find(int V){\n  v = map<int, int>();\n  parent = map<int, int>();\n  dist = map<int, int>();\n  REP(i, V) parent[i] = i;\n}\n\nint number(string &s){\n  if(M.find(s) != M.end()) return M[s];\n  int num = M.size();\n  M[s] = num;\n  parent[num] = num;\n  return num;\n}\n\nint get_distance(string &s){\n  int idx = 0;\n  while(s[idx++] != '^') ;\n  return atoi(s.substr(idx).c_str());\n}\n\nvoid input(string &as, int &d, string &bs){\n  string s, tmp;\n  cin >>tmp >>as >>tmp >>s >>bs;\n  d = get_distance(s);\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    bool ans = true;\n    REP(i, N){\n      string as, bs; int d;\n      input(as, d, bs);\n      int a = number(as), b = number(bs);\n      //cout <<as <<\", \" <<d <<\", \" <<bs <<\", \" <<a <<\", \" <<b <<\" | \" <<same(a, b) <<\", \" <<distance(a, b) <<endl;\n      if(same(a, b)) { if(distance(a, b) != d) ans = false; }\n      else merge(a, b, d);\n    }\n    cout <<(ans ? \"Yes\" : \"No\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tstring lhs;\n\tstring rhs;\n\tint power;\n\tData(string _l,string _r, int _p){\n\t\tlhs = _l;\n\t\trhs = _r;\n\t\tpower = _p;\n\t}\n};\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Data> relations;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint num;\n\t\t\tstring lhs;\n\t\t\tstring eq;\n\t\t\tstring rhs;\n\t\t\tstring tmp;\n\n\t\t\tcin >> num >> lhs >> eq >> tmp >> rhs;\n\t\t\tint base,pow;\n\t\t\tsscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n\t\t\trelations.push_back(Data(lhs,rhs,pow));\n\t\t}\n\n\t\tmap<string,vector<int> > vals;\n\n\t\tbool isok = true;\n\t\tvals[relations[0].rhs].push_back(0);\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<vals[relations[j].rhs].size();k++){\n\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\tvals[relations[j].lhs].push_back(relations[j].power + vals[relations[j].rhs][k]);\n\t\t\t}\n\t\t\tsort(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\tvector<int>::iterator it = unique(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\tvals[relations[j].lhs].resize( it - vals[relations[j].lhs].begin() );\n\n\t\t\tif(vals[relations[j].lhs].size() > 1) isok = false;\n\t\t}\n\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<vals[relations[j].lhs].size();k++){\n\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\tvals[relations[j].rhs].push_back(-relations[j].power + vals[relations[j].lhs][k]);\n\t\t\t}\n\t\t\tsort(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\tvector<int>::iterator it = unique(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\tvals[relations[j].rhs].resize( it - vals[relations[j].rhs].begin() );\n\n\t\t\tif(vals[relations[j].rhs].size() > 1) isok = false;\n\t\t}\n\n\t\t\t\tvals[relations[0].rhs].push_back(0);\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<vals[relations[j].rhs].size();k++){\n\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\tvals[relations[j].lhs].push_back(relations[j].power + vals[relations[j].rhs][k]);\n\t\t\t}\n\t\t\tsort(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\tvector<int>::iterator it = unique(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\tvals[relations[j].lhs].resize( it - vals[relations[j].lhs].begin() );\n\n\t\t\tif(vals[relations[j].lhs].size() > 1) isok = false;\n\t\t}\n\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<vals[relations[j].lhs].size();k++){\n\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\tvals[relations[j].rhs].push_back(-relations[j].power + vals[relations[j].lhs][k]);\n\t\t\t}\n\t\t\tsort(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\tvector<int>::iterator it = unique(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\tvals[relations[j].rhs].resize( it - vals[relations[j].rhs].begin() );\n\n\t\t\tif(vals[relations[j].rhs].size() > 1) isok = false;\n\t\t}\n\t\tprintf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<map>\nusing namespace std;\nchar in[30];\nint UF[300];\nint w[300];\npair<int,int> FIND(int a){\n\tif(UF[a]<0)return make_pair(a,0);\n\tpair<int,int>ret=FIND(UF[a]);\n\tret.second+=w[a];\n\treturn ret;\n}\nbool ok=true;\nvoid UNION(int a,int b,int c){\n\tpair<int,int>A=FIND(a);\n\tpair<int,int>B=FIND(b);\n\tint d=A.first;\n\tint e=B.first;\n\tint f=A.second+c-B.second;\n\tif(d==e){\n\t\tif(B.second-c!=A.second)ok=false;\n\t\treturn;\n\t}\n\tUF[a]+=UF[b];\n\tUF[b]=a;\n\tw[b]=f;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<string,int>m;\n\t\tint sz=0;ok=true;\n\t\tfor(int i=0;i<300;i++){\n\t\t\tUF[i]=-1;w[i]=0;\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s%s\",in,in);\n\t\t\tstring A=in;\n\t\t\tint C=0;\n\t\t\tscanf(\"%s%s\",in,in);\n\t\t\tif(in[1]==0)C=0;\n\t\t\telse{\n\t\t\t\tsscanf(in,\"%d^%d\",&C,&C);\n\t\t\t}\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring B=in;\n\t\t\tint p,q;\n\t\t\tif(!m.count(A)){\n\t\t\t\tp=sz;\n\t\t\t\tm[A]=sz++;\n\t\t\t}else p=m[A];\n\t\t\tif(!m.count(B)){\n\t\t\t\tq=sz;\n\t\t\t\tm[B]=sz++;\n\t\t\t}else q=m[B];\n\t\t\tUNION(p,q,C);\n\t\t//\tif(!ok)printf(\"%d\\n\",i);\n\t\t}\n\t\tif(ok)printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define\tmp\t\tmake_pair\n#define\tpb\t\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=999;\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint unum=0;\n\t\tpair<pii,int> edge[200];\n\t\tmap<string,int> name;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint pw;\n\t\t\tchar u1[17],u2[17];\n\t\t\tscanf(\"%*d %s %*c %*d%*c%d %s\",u1,&pw,u2);\n\n\t\t\tint id1,id2;\n\t\t\tif(name.count(u1)==0)\tname[u1]=unum++;\n\t\t\tid1=name[u1];\n\t\t\tif(name.count(u2)==0)\tname[u2]=unum++;\n\t\t\tid2=name[u2];\n\n\t\t\tif(pw<0)\tswap(id1,id2),pw=-pw;\n\t\t\tedge[i]=mp(mp(id1,id2),pw);\n\t\t}\n\n\t\tbool ok=true;\n\t\tstatic int wf[200][200];\n\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++)\twf[i][j]=(i==j?0:inf);\n\t\tfor(int k=0;k<n;k++){\n\t\t\tint from=edge[k].first.first,to=edge[k].first.second,dis=edge[k].second;\n\t\t\tif(wf[from][to]==inf){\n\t\t\t\twf[from][to]=dis;\n\t\t\t\twf[to][from]=dis;\n\t\t\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++){\n\t\t\t\t\tif(wf[i][from]==inf || wf[to][j]==inf)\tcontinue;\n\t\t\t\t\twf[i][j]=min(wf[i][j],wf[i][from]+dis+wf[to][j]);\n\t\t\t\t\twf[j][i]=-wf[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(wf[from][to]!=dis){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 200*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n\n    int size() const { return id; }\n};\n\n// テァツ淞崚ァツ崢セテ」ツ?ョテ」ツ?づ」ツつ凝ヲツ崢エテヲツ鳴ーテ」ツ?古ァツ卍コティツヲツ凝」ツ?陛」ツつ古」ツ?淌」ツつ?true\nbool relax(const vector<vector<pair<int,int> > > &graph, vector<int> &dist, int N) {\n    for(int i = 0; i < N; ++i) {\n        const vector<pair<int,int> > &edges = graph[i];\n        if(dist[i] == INF) continue;\n        for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n            const int nc = dist[i] + it->second;\n            if(dist[it->first] == INF) {\n                dist[it->first] = nc;\n            } else if(dist[it->first] != nc) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvector<vector<pair<int,int> > > v(200);\nvector<int> dist(200);\nvector<unsigned char> visited(200);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < N; ++i) {\n            v[i].clear();\n            dist[i] = INF;\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            for(string::iterator it = line.begin(); it != line.end(); ++it) {\n                if(*it == '=' || *it == '^') *it = ' ';\n            }\n            istringstream is(line);\n            string unit_left, unit_right;\n            int ord;\n            int tmp;\n            is >> tmp >> unit_left >> tmp >> ord >> unit_right;\n            //sscanf(line.c_str(), \"%*d %s = %*d^%d %s \", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        const int M = dict.size();\n        // テ」ツ?敕」ツつ古」ツ?榲」ツつ古」ツ?ョテゥツ?」テァツオツ静ヲツ按静・ツ按?」ツ?ォテ」ツ?、テ」ツ?催ッツシツ?テ」ツδ偲」ツδシテ」ツδ嘉」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ィテ」ツ?凖」ツつ凝ッツシツ?\n        fill(visited.begin(), visited.end(), 0);\n        queue<int> q;\n        for(int i = 0; i < M; ++i) {\n            if(!visited[i]) {\n                dist[i] = 0;\n                visited[i] = 1;\n                q.push(i);\n                while(!q.empty()) {\n                    int cur = q.front();\n                    q.pop();\n                    const vector<pair<int,int> > &edges = v[cur];\n                    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                        if(!visited[it->first]) {\n                            visited[it->first] = 1;\n                            q.push(it->first);\n                        }\n                    }\n                }\n            }\n        }\n\n        bool ok = true;\n        for(int phase = 0; phase < M; ++phase) {\n            if(relax(v, dist, M)) {\n                ok = false;\n                break;\n            }\n        }\n        if(!ok) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b)a=b;};\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b)a=b;};\n\ntemplate <typename T>\nstruct WeightedUnionFind{\n  int n;\n  T d;\n  vector<int> r, p;\n  vector<T> ws;\n  WeightedUnionFind(){}\n  WeightedUnionFind(int sz, T d_):\n    n(sz), d(d_), r(n, 1), p(n), ws(n, d){iota(p.begin(), p.end(), 0);}\n\n  int find(int x){\n    if(x == p[x]){\n      return x;\n    }else{\n      int t = find(p[x]);\n      ws[x] += ws[ p[x] ];\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x){\n    find(x);\n    return ws[x];\n  }\n\n  int same(int x,int y){\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w){\n    w += weight(x);\n    w -= weight(y);\n    x = find(x); y = find(y);\n    if(x == y) return;\n    if(r[x] < r[y]) swap(x, y), w = -w;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x,int y){\n    return weight(y) - weight(x);\n  }\n};\n  \nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n;\n  while(cin>>n,n){\n    WeightedUnionFind<int> uf(n*2,0);\n    int sz=0;\n    map<string,int> idx;\n\n    int flg=1;\n    for(int i=0;i<n;i++){\n      string a,b,c,d,e;\n      cin>>a>>b>>c>>d>>e;\n      if(!idx.count(b)) idx[b]=sz++;\n      if(!idx.count(e)) idx[e]=sz++;\n\n      int dif=stoi(d.substr(3));\n      if(!uf.same(idx[b],idx[e])){\n        uf.unite(idx[b],idx[e],dif);        \n      }else{\n        int act=uf.diff(idx[b],idx[e]);\n        //cout<<act<<\" \"<<dif<<endl;\n        flg&=(dif==act);\n      }\n    }\n    cout<<(flg?\"Yes\":\"No\")<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct Node{\n  vector<int> con;\n  vector<int> cost;\n};\n\nconst int inf = 1<<27;\n\nbool BellmanFord(const vector<Node> &Graph, int s, int A[], bool vis[])\n{\n  bool ret = false;\n  const int n = Graph.size();\n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int e = 0; e < (int)Graph[i].con.size(); ++e){\n        int dst = Graph[i].con[e];\n        int src = i;\n        if( A[dst] > A[src] + Graph[i].cost[e] ){\n          A[dst] = A[src] + Graph[i].cost[e];\n          \n          if( k == n-1 ){\n            A[dst] = -inf;\n            ret = true;\n          }\n        }\n      }\n    }\n  \n  }\n  return ret;\n}\n\nint main()\n{\n  int n;\n  while(cin>>n&&n){\n    // A km = 10^B km\n    // A == 1 , B == 0\n    int id = 0;\n    vector<Node> Graph(200);\n    map<string,int> D;\n    for(int i = 0; i < n; ++i){\n      char c;\n      string A,B;\n      int power;\n      cin >> c >> A >> c >> c >> c >> c >> power >> B;\n      //cout << A << ' ' << power << ' ' << B << endl;\n      if( D.find(A) == D.end() ){\n        D[A] = id++;\n      }\n      if( D.find(B) == D.end() ){\n        D[B] = id++;\n      }\n      Graph[D[A]].con.push_back( D[B] );\n      Graph[D[A]].cost.push_back( power );\n      Graph[D[B]].con.push_back( D[A] );\n      Graph[D[B]].cost.push_back( -power );\n    }\n    Graph.resize( id );\n    bool vis[id];\n    int A[id];\n    for(int i = 0; i < id; ++i){\n      vis[i] = false;\n      A[i] = inf*2;\n    }\n    bool res = true;\n    for(int i = 0; i < id; ++i){\n      if( !vis[i] ){\n        if( BellmanFord( Graph, i, A, vis ) ){\n          res = false;\n        }\n      }\n    }\n\n    if( res ){\n      puts(\"Yes\");\n    }else{\n      puts(\"No\");\n    }\n                 \n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n// #define DEBUG\n\ntypedef pair <int, int> EDGE;\ntypedef map <EDGE, int> EDGES;\ntypedef map <string, int> HASH;\n\nconst int INF = 1 << 28;\n\nEDGES G;\nHASH H;\n\n// return edge data\nEDGE get_edge( int a, int b ) { return make_pair( a, b ); }\nEDGE get_edge( string a, string b ) { return make_pair( H[a], H[b] );}\n\n// for input\nvoid input( string& a, string& b, int& x )\n{\n\tint g1, g3;\n\tchar g2, g4;\n\tcin >> g1 >> a >> g2 >> g3 >> g4 >> x >> b;\n\tcin.clear();\n\tcin.ignore();\n}\n\nint main( void )\n{\n\tstring a, b;\n\tint x, n;\n#ifdef DEBUG\n\tint loop_cnt = 0;\n#endif\n\n\twhile ( cin >> n && n )\n\t{\n#ifdef DEBUG\n\t\tloop_cnt++;\n\t\tcout << loop_cnt << \"ñÚÌÀs\" << endl;\n#endif\n\t\t// initialize\n\t\tG = EDGES();\n\t\tH = HASH();\n\n\t\tint number = 0;\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tinput( a, b, x );\n\t\t\t// cout << \"a = \" << a << \", b = \" << b << \" is \" << x << endl;\n\n\t\t\tif ( H.find( a ) == H.end() )\n\t\t\t{\n\t\t\t\tH[a] = number;\n\t\t\t\tnumber++;\n\t\t\t}\n\t\t\tif ( H.find( b ) == H.end() )\n\t\t\t{\n\t\t\t\tH[b] = number;\n\t\t\t\tnumber++;\n\t\t\t}\n\n\t\t\t// initialize\n\t\t\tG[get_edge(a,b)] = x;\n\t\t\tG[get_edge(b,a)] = -x;\n\t\t}\n\n\t\t// initialize\n\t\tfor ( int i = 0; i < number; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < number; j++ )\n\t\t\t{\n\t\t\t\tif ( G.find( get_edge(i,j) ) == G.end() ) G[get_edge(i,j)] = INF;\n\t\t\t}\n\t\t}\n\n\t\tEDGES P = G;\n\t\t// Warshall-Floyd Algorithm\n\t\tfor ( int k = 0; k < number; k++ )\n\t\t{\n\t\t\tfor ( int i = 0; i < number; i++ )\n\t\t\t{\n\t\t\t\tfor ( int j = 0; j < number; j++ )\n\t\t\t\t{\n\t\t\t\t\tif ( i == k || j == k ) continue;\n\t\t\t\t\tif ( P[get_edge(i,k)] == INF || P[get_edge(k,j)] == INF ) continue;\n\t\t\t\t\tif ( P[get_edge(i,j)] == INF )\n\t\t\t\t\t{\n\t\t\t\t\t\tP[get_edge(i,j)] = P[get_edge(i,k)] + P[get_edge(k,j)];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tP[get_edge(i,j)] = min( P[get_edge(i,j)], P[get_edge(i,k)] + P[get_edge(k,j)] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// end of WF Algorithm\n\n\t\t// for debug\n#ifdef DEBUG\n\t\tcout << \"³ÌOt\" << endl;\n\t\tfor ( int i = 0; i < number; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < number; j++ )\n\t\t\t{\n\t\t\t\tif ( G[get_edge(i,j)] == INF ) cout << \"x \";\n\t\t\t\telse cout << G[get_edge(i,j)] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n#endif\n\t\t// for debug\n#ifdef DEBUG\n\t\tcout << \"ASYKpã\" << endl;\n\t\tfor ( int i = 0; i < number; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < number; j++ )\n\t\t\t{\n\t\t\t\tif ( P[get_edge(i,j)] == INF ) cout << \"x \";\n\t\t\t\telse cout << P[get_edge(i,j)] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n#endif\n\n\t\t// check\n\t\tbool is_correct = true;\n\t\tfor ( int i = 0; is_correct && i < number; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; is_correct && j < number; j++ )\n\t\t\t{\n\t\t\t\tif ( G[get_edge(i,j)] == INF ) continue;\n\t\t\t\tif ( G[get_edge(i,j)] != P[get_edge(i,j)] ) is_correct = false;\n\t\t\t}\n\t\t}\n\n\t\tcout << ( is_correct ? \"Yes\" : \"No\" ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "template<int Size = 1000000, typename WeightType = int>\nclass WeightedUnionFind {\n    int par[Size], rank[Size], sizes[Size];\n    WeightType wei[Size];\n    \npublic:\n\tWeightedUnionFind() = default;\n\tWeightedUnionFind(const WeightedUnionFind&) = default;\n\tWeightedUnionFind(WeightedUnionFind&&) = default;\n\tWeightedUnionFind& operator = (const WeightedUnionFind&) = default;\n\tWeightedUnionFind& operator = (WeightedUnionFind&&) = default;\n \n    WeightedUnionFind(int size) {\n\t\tinit(size);\n\t}\n \n\tvoid init(int size) {\n        for(int i = 0; i < size; ++i) {\n            par[i] = i;\n            rank[i] = 0;\n            sizes[i] = 1;\n            wei[i] = 0;\n        }\n    }\n    \n    int find(int x) {\n        if(par[x] == x) {\n            return x;\n        }else {\n            int p = find(par[x]);\n            \n            wei[x] += wei[par[x]];\n            \n            return par[x] = p;\n        }\n    }\n    \n    WeightType weight(int x) {\n        find(x);\n        \n        return wei[x];\n    }\n    \n    void unite(int x, int y, WeightType w) {\n        w += weight(x); \n        w -= weight(y);\n        x = find(x);\n        y = find(y);\n        \n        if(x == y) return;\n        \n        if(rank[x] < rank[y]) {\n            par[x] = y;\n            sizes[y] += sizes[x];\n            wei[x] = -w;\n        }else {\n            par[y] = x;\n            sizes[x] += sizes[y];\n            wei[y] = w;\n            if(rank[x] == rank[y]) ++rank[x];\n        }\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    int size(int x) {\n        return sizes[find(x)];\n    }\n    \n    WeightType diff(int x, int y, WeightType disabledVal = static_cast<WeightType>(-1)) {\n        if(!same(x, y)) {\n            return disabledVal;\n        }\n        \n        return weight(x) - weight(y);\n    }\n};\n\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n\nint n;\n\nint main() {\n    while(std::cin >> n, n) {\n        std::string tmp, lhs, rhs, times_raw;\n        int cnt = 0;\n        std::map<std::string, int> units;\n        WeightedUnionFind<256> tree(n);\n        bool flag = true;\n        \n        for(int i = 0; i < n; ++i) {\n            std::cin >> tmp >> lhs >> tmp >> times_raw >> rhs;\n            \n            if(!flag)\n                break;\n            \n            int times = std::stoi(times_raw.substr(times_raw.find(\"^\") + 1));\n            int l, r;\n            if(units.count(lhs)) {\n                l = units[lhs];\n            }else {\n                l = units[lhs] = cnt, ++cnt;\n            }\n            \n            if(units.count(rhs)) {\n                r = units[rhs];\n            }else {\n                r = units[rhs] = cnt, ++cnt;\n            }\n            \n            if(tree.same(l, r)) {\n                if(tree.diff(l, r) != times) {\n                    flag = false;\n                }\n            }else {\n                tree.unite(r, l, times);\n            }\n        }\n        \n        std::cout << (flag ? \"Yes\" : \"No\") << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// UTPC2010 D. ツ鳴ウツ鳴オツ渉つづ按単ツ暗環系\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tstring s, t, r;\n\t\tmap<string, int> mp;\n\t\tvector< vector< pair<int,int> > > vp;\n\t\tint size = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s >> s >> t >> t >> r;\n\t\t\tif(!mp.count(s)) { mp[s] = size++; vp.push_back(vector< pair<int,int> >()); }\n\t\t\tif(!mp.count(r)) { mp[r] = size++; vp.push_back(vector< pair<int,int> >()); }\n\t\t\tt[2] = ' ';\n\t\t\tistringstream iss(t);\n\t\t\tint a; iss >> a >> a;\n\t\t\tvp[mp[s]].push_back(make_pair(mp[r], a));\n\t\t\tvp[mp[r]].push_back(make_pair(mp[s],-a));\n\t\t}\n\t\tbool ok = true;\n\t\tvector<bool> visit(size, false);\n\t\tvector<int>  calc(size, 0);\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(visit[i]) continue;\n\t\t\tqueue<int> qu; qu.push(i);\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint c = qu.front(); qu.pop();\n\t\t\t\tif(visit[c]) continue;\n\t\t\t\tvisit[c] = true;\n\t\t\t\tfor(int j=0;j<vp[c].size();j++){\n\t\t\t\t\tint nxt = vp[c][j].first;\n\t\t\t\t\tif(visit[nxt]) {\n\t\t\t\t\t\tif(calc[nxt]!=calc[c]+vp[c][j].second) ok = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcalc[nxt] = calc[c]+vp[c][j].second;\n\t\t\t\t\t\tqu.push(nxt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <unordered_map>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef string key;\n\nchar b1[99],b2[99];\nvoid main2(int n){\n\tunordered_map<key,deque<pair<key,long long>>>m;\n\tfor(;n;n--){\n\t\tint d;\n\t\tscanf(\" 1 %s = 10^%d %s\",b1,&d,b2);\n\t\tstring s1=b1,s2=b2;\n\t\tm[s1].emplace_back(s2,d);\n\t\tm[s2].emplace_back(s1,-d);\n\t}\n\tfor(;!m.empty();){\n\t\tauto s=m.begin()->first;\n\t\tdeque<pair<key,long long>>st={{s,0}};\n\t\tunordered_map<key,long long>memo={{s,0}};\n\t\tfor(;!st.empty();){\n\t\t\tauto p=*st.begin();st.pop_front();\n\t\t\tauto cur=p.first;long long d=p.second;\n\t\t\tfor(auto &e:m[cur]){\n\t\t\t\tif(memo.find(e.first)==memo.end()){\n\t\t\t\t\tst.emplace_back(e.first,d+e.second);\n\t\t\t\t\tmemo[e.first]=d+e.second;\n\t\t\t\t}else if(memo[e.first]!=d+e.second){\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto &e:memo)m.erase(m.find(e.first));\n\t}\n\tputs(\"Yes\");\n}\nint main(){int n;for(;~scanf(\"%d\",&n)&&n;)main2(n);}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nbool warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n                // Ç¿çàINFæè¬³­Èé\n                if(prv!=INF&&d[j][i]+d[i][k]<INF){\n                    if(prv!=d[j][i]+d[i][k]){\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\nbool passed[101];\nbool no;\nvoid dfs(int s){\n    passed[s]=true;\n    for(int i = 0; i < V; i++){\n        if(i==s)continue;\n        if(d[s][i]!=INF){\n            if(passed[i]){\n                no=true;\n                return;\n            }\n            dfs(i);\n            if(no)\n                return;\n        }\n    }\n    passed[s]=false;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0)\n                d[dict[a]][dict[b]]=-cost;\n            else\n                d[dict[b]][dict[a]]=cost;\n        }\n        V=idx;\n        fill(passed,passed+101,false);\n        vector<int> roots;\n        for(int j = 0; j < idx; j++){\n            int cnt=0;\n            for(int i = 0; i < idx; i++){\n                if(i==j)continue;\n                if(d[i][j]!=INF)\n                    cnt++;\n            }\n            if(cnt==0)\n                roots.push_back(j);\n        }\n        no=false;\n        for(int i = 0; i < roots.size(); i++){\n            dfs(roots[i]);\n        }\n        bool f=warshall_floyd();\n        if(!f||no)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 301;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n            }\n        }\n    }\n}\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n\t      dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0){\n                d[dict[a]][dict[b]]=-cost;\n                d[dict[b]][dict[a]]=cost;\n\t    }\n            else{\n                d[dict[b]][dict[a]]=cost;\n                d[dict[a]][dict[b]]=-cost;\n\t    }\n        }\n        V=idx;\n        bool no=false;\n        warshall_floyd();\n\t// ÌÂHª êÎno\n\tfor(int i = 0; i < idx; i++)\n\t  if(d[i][i]<0)no=true;\n\tif(no)\n\t  cout<<\"No\"<<endl;\n\telse\n\t  cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 200*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n\n    int size() const { return id; }\n};\n\nbool relax(const vector<vector<pair<int,int> > > &graph, vector<int> &dist, int N) {\n    bool updated = false;\n    for(int i = 0; i < N; ++i) {\n        const vector<pair<int,int> > &edges = graph[i];\n        for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n            const int nc = dist[i] + it->second;\n            if(dist[it->first] > nc) {\n                dist[it->first] = nc;\n                updated = true;\n            }\n        }\n    }\n    return updated;\n}\n\nvector<vector<pair<int,int> > > v(200);\nvector<int> dist(200);\nvector<unsigned char> visited(200);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < N; ++i) {\n            v[i].clear();\n            dist[i] = INF;\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            for(string::iterator it = line.begin(); it != line.end(); ++it) {\n                if(*it == '=' || *it == '^') *it = ' ';\n            }\n            istringstream is(line);\n            string unit_left, unit_right;\n            int ord;\n            int tmp;\n            is >> tmp >> unit_left >> tmp >> ord >> unit_right;\n            //sscanf(line.c_str(), \"%*d %s = %*d^%d %s \", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        const int M = dict.size();\n        // テ」ツ?敕」ツつ古」ツ?榲」ツつ古」ツ?ョテゥツ?」テァツオツ静ヲツ按静・ツ按?」ツ?ォテ」ツ?、テ」ツ?催ッツシツ?テ」ツδ偲」ツδシテ」ツδ嘉」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ィテ」ツ?凖」ツつ凝ッツシツ?\n        fill(visited.begin(), visited.end(), 0);\n        queue<int> q;\n        for(int i = 0; i < M; ++i) {\n            if(!visited[i]) {\n                dist[i] = 0;\n                visited[i] = 1;\n                q.push(i);\n                while(!q.empty()) {\n                    int cur = q.front();\n                    q.pop();\n                    const vector<pair<int,int> > &edges = v[cur];\n                    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                        if(!visited[it->first]) {\n                            visited[it->first] = 1;\n                            q.push(it->first);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Bellman-ford\n        for(int phase = 0; phase < M; ++phase) {\n            if(!relax(v, dist, M)) break;\n        }\n        bool ok = !relax(v, dist, M);\n        if(ok) {\n            for(int i = 0; i < M; ++i) {\n                const vector<pair<int,int> > &edges = v[i];\n                for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                    if(dist[i] + it->second != dist[it->first]) {\n                        ok = false;\n                        goto end;\n                    }\n                }\n            }\n        }\nend:\n        if(!ok) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#define N 210\nusing namespace std;\n\nint n,m;\nint d[N][N];\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int k=0;k<m;k++ )\n    for( int i=0;i<m;i++ )\n      for( int j=0;j<m;j++ )\n\td[i][j] = min( d[i][j],d[i][k]+d[k][j] );\n\n  for( int i=0;i<m;i++ )\n    if( d[i][i]<0 )\n      return false;\n  return true;\n}\n\nint main(){\n  string a,b, s;\n  int x;\n  char c;\n\n  while( cin>>n && n ){\n    for( int i=0;i<N;i++ ){\n      for( int j=0;j<N;j++ )\n\td[i][j]=1000;\n      d[i][i] = 0;\n    }\n    map<string,int> units; // units[ a ] でaの配列番号が分かる\n    m=0;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c;  // 10^\n      cin >> x >> b;  // [x] [B];\n\n      if( units.find( a )==units.end() )\n\tunits[a] = m++;\n      if( units.find( b )==units.end() )\n\tunits[b] = m++;\n\n      int an=units[a], bn=units[b];\n      d[an][bn] =  x;\n      d[bn][an] = -x;\n    }\n\n    if( check() ) cout << \"Yes\" << endl;\n    else          cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 100*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n\n    int size() const { return id; }\n};\n\nbool relax(const vector<vector<pair<int,int> > > &graph, vector<int> &dist, int N) {\n    bool updated = false;\n    for(int i = 0; i < N; ++i) {\n        const vector<pair<int,int> > &edges = graph[i];\n        for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n            const int nc = dist[i] + it->second;\n            if(dist[it->first] > nc) {\n                dist[it->first] = nc;\n                updated = true;\n            }\n        }\n    }\n    return updated;\n}\n\nvector<vector<pair<int,int> > > v(200);\nvector<int> dist(200);\nvector<unsigned char> visited(200);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < N; ++i) {\n            v[i].clear();\n            dist[i] = INF;\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            for(string::iterator it = line.begin(); it != line.end(); ++it) {\n                if(*it == '=' || *it == '^') *it = ' ';\n            }\n            istringstream is(line);\n            string unit_left, unit_right;\n            int ord;\n            int tmp;\n            is >> tmp >> unit_left >> tmp >> ord >> unit_right;\n            //sscanf(line.c_str(), \"%*d %s = %*d^%d %s \", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        const int M = dict.size();\n        // テ」ツ?敕」ツつ古」ツ?榲」ツつ古」ツ?ョテゥツ?」テァツオツ静ヲツ按静・ツ按?」ツ?ォテ」ツ?、テ」ツ?催ッツシツ?テ」ツδ偲」ツδシテ」ツδ嘉」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ィテ」ツ?凖」ツつ凝ッツシツ?\n        fill(visited.begin(), visited.end(), 0);\n        queue<int> q;\n        for(int i = 0; i < M; ++i) {\n            if(!visited[i]) {\n                dist[i] = 0;\n                visited[i] = 1;\n                q.push(i);\n                while(!q.empty()) {\n                    int cur = q.front();\n                    q.pop();\n                    const vector<pair<int,int> > &edges = v[cur];\n                    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                        if(!visited[it->first]) {\n                            visited[it->first] = 1;\n                            q.push(it->first);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Bellman-ford\n        for(int phase = 0; phase < M; ++phase) {\n            if(!relax(v, dist, M)) break;\n        }\n        if(relax(v, dist, M)) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nint main(){\n  while(true){\n    int n,m=0;\n    int a,b,e;\n    string s1,s2;\n    char c,d;\n    int i,j,k;\n    cin>>n;\n    if(!n)break;\n    int graph[200][200];\n    for(i=0;i<200;i++)\n      for(j=0;j<200;j++)\n\tgraph[i][j] = 10000000;\n    vector<string> names(200);\n    for(i=0;i<n;i++){\n      cin>>a>>s1>>c>>b>>d>>e>>s2;\n      j=0,k=0;\n      for(;j<m;j++)if(names[j]==s1)break;\n      if(j==m){\n\tnames[j] = s1;\n\tm++;\n      }\n      for(;k<m;k++)if(names[k]==s2)break;\n      if(k==m){\n\tnames[k] = s2;\n\tm++;\n      }\n      graph[k][j] = e;\n      graph[j][k] = -e;\n    }\n    for(k=0;k<m;k++){\n      for(i=0;i<m;i++){\n\tfor(j=0;j<m;j++){\n\t  if(graph[i][k]+graph[k][j]<graph[i][j])graph[i][j]=graph[i][k]+graph[k][j];\n\t}\n      }\n    }\n    bool bb = true;\n    for(i=0;i<m;i++)\n      if(graph[i][i]<0)bb=false;\n    if(bb)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tstring lhs;\n\tstring rhs;\n\tint power;\n\tData(string _l,string _r, int _p){\n\t\tlhs = _l;\n\t\trhs = _r;\n\t\tpower = _p;\n\t}\n};\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Data> relations;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint num;\n\t\t\tstring lhs;\n\t\t\tstring eq;\n\t\t\tstring rhs;\n\t\t\tstring tmp;\n\n\t\t\tcin >> num >> lhs >> eq >> tmp >> rhs;\n\t\t\tint base,pow;\n\t\t\tsscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n\t\t\trelations.push_back(Data(lhs,rhs,pow));\n\t\t}\n\n\t\tmap<string,set<int> > vals;\n\n\t\tbool isok = true;\n\t\tvals[relations[0].rhs].insert(0);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(set<int>::iterator it = vals[relations[j].rhs].begin();it != vals[relations[j].rhs].end();it++){\n\t\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\t\tvals[relations[j].lhs].insert(relations[j].power + *it);\n\t\t\t\t\tif(vals[relations[j].lhs].size() > 1){ \n\t\t\t\t\t\tisok = false;\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//sort(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t//vector<int>::iterator it = unique(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t//vals[relations[j].lhs].resize( it - vals[relations[j].lhs].begin() );\n\n\t\t\t\t//if(vals[relations[j].lhs].size() > 1) isok = false;\n\t\t\t}\n\n\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(set<int>::iterator it = vals[relations[j].lhs].begin();it != vals[relations[j].lhs].end();it++){\n\t\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\t\tvals[relations[j].rhs].insert(-relations[j].power + *it);\n\t\t\t\t\tif(vals[relations[j].rhs].size() > 1){ \n\t\t\t\t\t\tisok = false;\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//sort(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t//vector<int>::iterator it = unique(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t//vals[relations[j].rhs].resize( it - vals[relations[j].rhs].begin() );\n\t\t\t\t//if(vals[relations[j].rhs].size() > 1) isok = false;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(vals.find(relations[j].lhs) == vals.end()\n\t\t\t\t|| vals.find(relations[j].rhs) == vals.end()){\n\t\t\t\t\tisok = false;\n\t\t\t}\n\t\t}\n\nfound:;\n\n\t\tprintf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tstring lhs;\n\tstring rhs;\n\tint power;\n\tData(string _l,string _r, int _p){\n\t\tlhs = _l;\n\t\trhs = _r;\n\t\tpower = _p;\n\t}\n};\n\nmap<string,int> gUnit;\nint gCount = 0;\n\nint dp[101][101];\n\nint unit2num(string str){\n\tif(gUnit.find(str) == gUnit.end()){\n\t\tgUnit[str]=gCount++;\n\t}\n\n\treturn gUnit[str];\n}\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tgCount = 0;\n\t\tgUnit.clear();\n\t\tmemset(dp,0x3f,sizeof(dp));\n\n\t\tvector<Data> relations;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint num;\n\t\t\tstring lhs;\n\t\t\tstring eq;\n\t\t\tstring rhs;\n\t\t\tstring tmp;\n\n\t\t\tcin >> num >> lhs >> eq >> tmp >> rhs;\n\t\t\tint base,pow;\n\t\t\tsscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n\t\t\trelations.push_back(Data(lhs,rhs,pow));\n\t\t}\n\n\t\tfor(int i=0;i<relations.size();i++){\n\t\t\tdp[unit2num(relations[i].lhs)][unit2num(relations[i].rhs)] = -relations[i].power;\n\t\t\tdp[unit2num(relations[i].rhs)][unit2num(relations[i].lhs)] = relations[i].power;\n\t\t}\n\n\t\tfor(int k=0;k<gCount;k++){\n\t\t\tfor(int i=0;i<gCount;i++){\n\t\t\t\tfor(int j=0;j<gCount;j++){\n\t\t\t\t\tdp[i][j] = min(dp[i][k] + dp[k][j],dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool isok = true;\n\t\tfor(int i=0;i<gCount;i++){\n\t\t\tif(dp[i][i] != 0) isok = false;\n\t\t}\n//\n//\n//\t\tmap<string,set<int> > vals;\n//\n//\t\tbool isok = true;\n//\t\tvals[relations[0].rhs].insert(0);\n//\n//\t\tfor(int i=0;i<n;i++){\n//\t\t\tfor(int j=0;j<n;j++){\n//\t\t\t\tfor(set<int>::iterator it = vals[relations[j].rhs].begin();it != vals[relations[j].rhs].end();it++){\n//\t\t\t\t\t//1 kilobyte = 10^3 byte\n//\t\t\t\t\tvals[relations[j].lhs].insert(relations[j].power + *it);\n//\t\t\t\t\tif(vals[relations[j].lhs].size() > 1){ \n//\t\t\t\t\t\tisok = false;\n//\t\t\t\t\t\tgoto found;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\t//sort(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n//\t\t\t\t//vector<int>::iterator it = unique(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n//\t\t\t\t//vals[relations[j].lhs].resize( it - vals[relations[j].lhs].begin() );\n//\n//\t\t\t\t//if(vals[relations[j].lhs].size() > 1) isok = false;\n//\t\t\t}\n//\n//\n//\t\t\tfor(int j=0;j<n;j++){\n//\t\t\t\tfor(set<int>::iterator it = vals[relations[j].lhs].begin();it != vals[relations[j].lhs].end();it++){\n//\t\t\t\t\t//1 kilobyte = 10^3 byte\n//\t\t\t\t\tvals[relations[j].rhs].insert(-relations[j].power + *it);\n//\t\t\t\t\tif(vals[relations[j].rhs].size() > 1){ \n//\t\t\t\t\t\tisok = false;\n//\t\t\t\t\t\tgoto found;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\t//sort(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n//\t\t\t\t//vector<int>::iterator it = unique(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n//\t\t\t\t//vals[relations[j].rhs].resize( it - vals[relations[j].rhs].begin() );\n//\t\t\t\t//if(vals[relations[j].rhs].size() > 1) isok = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\t\n//\t\tfor(int j=0;j<n;j++){\n//\t\t\tif(vals.find(relations[j].lhs) == vals.end()\n//\t\t\t\t|| vals.find(relations[j].rhs) == vals.end()){\n//\t\t\t\t\tisok = false;\n//\t\t\t}\n//\t\t}\n//\n//found:;\n\n\t\tprintf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\n\nconst int MAX_V = 101;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                d[i][j][k] = min(d[i][j][k],d[k][j][i]+d[j][i][k]);\n            }\n        }\n    }\n}\n\nconst int INF=1000000000;\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                for(int k = 0; k < MAX_V; k++){\n                    if(j==k)\n                        d[i][j][k]=0;\n                    else\n                        d[i][j][k]=INF;\n                }\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^'){\n                    cost=atoi(t.substr(j+1).c_str());\n                }\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())dict[b]=idx++;\n            for(int j = 0; j < MAX_V; j++){\n                if(cost<0){\n                    d[j][dict[a]][dict[b]]=-cost;\n                }\n                else{\n                    d[j][dict[b]][dict[a]]=cost;\n                }\n            }\n        }\n        V=idx;\n        warshall_floyd();\n        bool f=false;\n        for(int i = 0; i < idx; i++){\n            for(int j = 0; j < idx; j++){\n                // kðoRµÄS[·é\n                int path=d[0][i][j];\n                for(int k = 1; k < idx; k++){\n                    if(path!=d[k][i][j]){\n                        f=true;\n                        break;\n                    }\n                }\n                if(f)\n                    break;\n            }\n            if(f)\n                break;\n        }\n        if(f){\n            cout<<\"No\"<<endl;\n        }\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <list>\n\n\nint* find(\n    std::unordered_map<std::string, std::unordered_map<std::string, int> > *map,\n    const std::string &s1, const std::string &s2)\n{\n    auto it1 = map->find(s1);\n    if (it1 == map->end()) return NULL;\n\n    auto it2 = it1->second.find(s2);\n    return (it2 == it1->second.end()) ? NULL : &it2->second;\n}\n\n\nbool walk(\n    std::unordered_map<std::string, std::unordered_map<std::string, int> > *map,\n    const std::tuple<std::string, std::string, int> &t)\n{\n    const std::string &s0 = std::get<0>(t);\n    const std::string &s1 = std::get<1>(t);\n    int mag1 = std::get<2>(t);\n\n    int *old = find(map, s0, s1);\n    if (old == NULL)\n    {\n        (*map)[s0][s1] = mag1;\n        (*map)[s1][s0] = -mag1;\n    }\n    else if (*old != mag1)\n        return false;\n\n    std::list<const std::tuple<std::string, std::string, int> > next;\n        \n    for (auto x : map->at(s0))\n    {\n        const std::string &s2 = x.first;\n        int mag2 = x.second;\n        \n        if (s1 != s2)\n        if (find(map, s1, s2) == NULL)\n            next.push_back(std::make_tuple(s1, s2, -mag1 + mag2));\n    }\n    \n    for (auto x : map->at(s1))\n    {\n        const std::string &s2 = x.first;\n        int mag2 = x.second;\n        \n        if (s0 != s2)\n        if (find(map, s0, s2) == NULL)\n            next.push_back(std::make_tuple(s0, s2, mag1 + mag2));\n    }\n\n    for (auto t : next)\n        if (!walk(map, t))\n            return false;\n\n    return true;\n}\n\n\nint main()\n{\n    char line[256];\n    \n    while (not std::cin.eof())\n    {\n        int n;\n        std::cin >> n;\n        if (n == 0) break;\n\n        std::list<std::tuple<std::string, std::string, int> > inputs;\n        \n        for (int i = 0; i < n; ++i)\n        {\n            int x;\n            std::string s1, s2;\n            \n            std::cin.ignore(2);\n            std::cin >> s1;\n            std::cin.ignore(6);\n            std::cin >> x >> s2;\n\n            inputs.push_back(std::make_tuple(s1, s2, x));\n        }\n\n        std::unordered_map<std::string,\n            std::unordered_map<std::string, int> > map;\n        bool is_valid(true);\n        \n        for (auto x : inputs)\n            if (!walk(&map, x))\n            {\n                is_valid = false;\n                break;\n            }\n\n        std::cout << (is_valid ? \"Yes\" : \"No\") << std::endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#define mp make_pair\nusing namespace std;\nint main(){\n  int n,m=0;\n  int a,b,e;\n  string s1,s2;\n  char c,d;\n  while(true){\n    cin>>n;\n    if(!n)break;\n    int graph[200][200];\n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)\n\tgraph[i][j] = 100000;\n    vector<string> names(200);\n    for(int i=0;i<n;i++){\n      cin>>a>>s1>>c>>b>>d>>e>>s2;\n      int j=0,k=0;\n      for(;j<m;j++)if(names[j]==s1)break;\n      names[j] = s1;\n      if(j==m)m++;\n      for(;k<m;k++)if(names[k]==s2)break;\n      names[k] = s2;\n      if(k==m)m++;\n      graph[k][j] = e;\n      graph[j][k] = -e;\n    }\n    for(int k=0;k<m;k++){\n      for(int i=0;i<m;i++){\n\tfor(int j=0;j<m;j++){\n\t  if(graph[i][k]+graph[k][j]<graph[i][j])graph[i][j]=graph[i][k]+graph[k][j];\n\t}\n      }\n    }\n    bool bb = true;\n    for(int i=0;i<m;i++)\n      if(graph[i][i]<0)bb=false;\n    if(bb)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstruct E{int from,to,cost;};\n\nint N,n,d[200];\nchar c;\nstring s,s2;\nE e[200];\n\nint main(){\n\twhile(cin>>N){\n\t\tif(!N)return 0;\n\t\tset<string> sts;\n\t\tmap<string,int> tab;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>n>>s>>c>>n>>c>>n>>s2;\n\t\t\tif(sts.find(s)==sts.end()){\n\t\t\t\ttab[s]=sts.size();\n\t\t\t\tsts.insert(s);\n\t\t\t}\n\t\t\tif(sts.find(s2)==sts.end()){\n\t\t\t\ttab[s2]=sts.size();\n\t\t\t\tsts.insert(s2);\n\t\t\t}\n\t\t\te[i*2].from=tab[s];\n\t\t\te[i*2].to=tab[s2];\n\t\t\te[i*2].cost=n;\n\t\t\te[i*2+1].from=tab[s2];\n\t\t\te[i*2+1].to=tab[s];\n\t\t\te[i*2+1].cost=-1*n;\n\t\t}\n\t\tfill(d,d+sts.size(),0);\n\t\tbool f=0;\n\t\tfor(int i=0;i<sts.size();i++){\n\t\t\tfor(int j=0;j<2*N;j++){\n\t\t\t\tif(d[e[j].to]>d[e[j].from]+e[j].cost){\n\t\t\t\t\td[e[j].to]=d[e[j].from]+e[j].cost;\n\t\t\t\t\tif(i==sts.size()-1){f=1;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f)cout<<\"No\"<<endl;\n\t\telse cout<<\"Yes\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#define P pair<string,int>\n#define PP pair<int,int>\nusing namespace std;\n\nint n;\nvector<PP> rl[110]; // 単位間の関係\n\nmap<string,int> units; // units[ a ] でaの配列番号が分かる\nmap<string,int>::iterator it;\nset<int> st;\n\n/* 単位系が誤っているとfalseを返す */\nbool dfs(int i, int sum, int initP,int depth){\n  if( depth > n  ) return true;\n\n  if( i==initP ){\n    if( sum==0 ) return true;\n    else return false;\n  }\n\n  if( rl[i].size()<=1 )    return true;\n  depth++;\n  for( int j=0;j<(int)rl[i].size();j++ ){\n\n    if( st.find( rl[i][j].first )!= st.end() )\n       continue; // 既に通ったノード\n\n    st.insert( rl[i][j].first );\n    int nS = sum + rl[i][j].second;\n    if( dfs( rl[i][j].first,nS,initP,depth)==false )\n      return false;\n    st.erase( rl[i][j].first );\n  }\n  return true;\n}\n\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int i=0;i<n;i++ ){\n    if( rl[i].size()<=1 ) continue;\n\n    for( int j=0;j<(int)rl[i].size();j++ ){\n      if( rl[i][j].first<0 ) continue;\n      st.clear();\n      if( dfs(rl[i][j].first,rl[i][j].second,i,0)==false )\n\treturn false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    units.clear();\n    for( int i=0;i<n;i++ )      rl[i].clear();\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() )\n\tunits.insert( P(a,(int)units.size()) );\n      if( (it=units.find( b ))==units.end() )\n\tunits.insert( P(b,(int)units.size()) );\n\n      int an=units[a], bn=units[b];\n      rl[ an ].push_back( PP(bn,x) );  rl[ bn ].push_back( PP(an,-x) );\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstruct E{int from,to,cost;};\n\nint N,n,d[200];\nchar c;\nstring s,s2;\nE e[200];\n\nint main(){\n\twhile(cin>>N){\n\t\tif(!N)return 0;\n\t\tset<string> sts;\n\t\tmap<string,int> tab;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>n>>s>>c>>n>>c>>n>>s2;\n\t\t\tif(sts.find(s)==sts.end()){\n\t\t\t\ttab[s]=sts.size();\n\t\t\t\tsts.insert(s);\n\t\t\t}\n\t\t\tif(sts.find(s2)==sts.end()){\n\t\t\t\ttab[s2]=sts.size();\n\t\t\t\tsts.insert(s2);\n\t\t\t}\n\t\t\te[i*2].from=tab[s];\n\t\t\te[i*2].to=tab[s2];\n\t\t\te[i*2].cost=n;\n\t\t\te[i*2+1].from=tab[s2];\n\t\t\te[i*2+1].to=tab[s];\n\t\t\te[i*2+1].cost=-1*n;\n\t\t}\n\t\tmemset(d,0,sizeof(d));\n\t\tbool f=0;\n\t\tfor(int i=0;i<sts.size();i++){\n\t\t\tfor(int j=0;j<2*N;j++){\n\t\t\t\tif(d[e[j].to]>d[e[j].from]+e[j].cost){\n\t\t\t\t\td[e[j].to]=d[e[j].from]+e[j].cost;\n\t\t\t\t\tif(i==sts.size()-1){f=1;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f)cout<<\"No\"<<endl;\n\t\telse cout<<\"Yes\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#define P pair<string,int>\n#define DEBUG true\nusing namespace std;\n\nint n;\nint d[110][110];\n\nmap<string,int> units; // units[ a ] でaの配列番号が分かる\nmap<string,int>::iterator it;\n\nbool check(){ /* 誤った規則があればfalse */\n\n  int len = units.size();\n  for( int k=0;k<len;k++ )\n    for( int i=0;i<len;i++ )\n      for( int j=0;j<len;j++ )\n\td[i][j] = min( d[i][j],d[i][k]+d[k][j] );\n\n  for( int i=0;i<len;i++ )\n      if( d[i][i]!=0 )\n\treturn false;\n\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    units.clear();\n\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ) d[i][j]=1000;\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() )\n\tunits.insert( P(a,(int)units.size()) );\n      if( (it=units.find( b ))==units.end() )\n\tunits.insert( P(b,(int)units.size()) );\n\n      int an=units[a], bn=units[b];\n      d[an][bn]=x; d[bn][an]=-x;\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<string>v; int n, a[1000], b[1000], c[1000]; string s1[1000], s2[1000], t[1000];\nvector<int>u[1000]; int group[1000], dist[1000]; bool OK = true;\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\n\nvoid merge(int a, int b, int c) {\n\tif (group[a] == group[b]) { if ((dist[a] - dist[b]) != c)OK = false; return; }\n\tint w1 = group[a], w2 = group[b];\n\tint sa = (dist[a] - dist[b]) - c;\n\tfor (int i : u[w2])dist[i] += sa;\n\tfor (int i : u[w2])u[w1].push_back(i);\n\tfor (int i : u[w2])group[i] = w1;\n\tu[w2].clear();\n\tsort(u[w1].begin(), u[w1].end());\n\treturn;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; v.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring a1, a2; cin >> a1 >> s1[i] >> a2 >> t[i] >> s2[i];\n\t\t\tv.push_back(s1[i]); v.push_back(s2[i]);\n\t\t}\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); OK = true;\n\t\tfor (int i = 0; i < n; i++) { u[i].clear(); u[i].push_back(i); group[i] = i; a[i] = s(s1[i]); b[i] = s(s2[i]); c[i] = stoi(t[i].substr(3, t[i].size() - 3)); }\n\t\tfor (int i = 0; i < n; i++) { merge(a[i], b[i], c[i]); }\n\t\tif (OK == true)cout << \"Yes\" << endl; else cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#define mp make_pair\nusing namespace std;\nint main(){\n  int n,m=0;\n  int a,b,e;\n  string s1,s2;\n  char c,d;\n  while(true){\n    cin>>n;\n    if(!n)break;\n    int graph[100][100];\n    for(int i=0;i<100;i++)\n      for(int j=0;j<100;j++)\n\tgraph[i][j] = 100000;\n    vector<string> names(100);\n    for(int i=0;i<n;i++){\n      cin>>a>>s1>>c>>b>>d>>e>>s2;\n      int j=0,k=0;\n      for(;j<m;j++)if(names[j]==s1)break;\n      names[j] = s1;\n      if(j==m)m++;\n      for(;k<m;k++)if(names[k]==s2)break;\n      names[k] = s2;\n      if(k==m)m++;\n      graph[k][j] = e;\n      graph[j][k] = -e;\n    }\n    for(int k=0;k<m;k++){\n      for(int i=0;i<m;i++){\n\tfor(int j=0;j<m;j++){\n\t  if(graph[i][k]+graph[k][j]<graph[i][j])graph[i][j]=graph[i][k]+graph[k][j];\n\t}\n      }\n    }\n    bool bb = true;\n    for(int i=0;i<m;i++)\n      if(graph[i][i]<0)bb=false;\n    if(bb)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nunordered_map<string, int> converter;\nint convert(const string &s) {\n\tif(!converter.count(s)) converter.insert({s, converter.size()});\n\treturn converter[s];\n}\n\nclass union_find {\nprivate:\n\tstatic constexpr int INF = (1 << 29);\n\tvector<int> uf, pd;\npublic:\n\tunion_find(int n):uf(n, -1), pd(n, 0){}\n\n\tint find(int x) {\n\t\tif(uf[x] < 0) return x;\n\t\tconst int new_parent = find(uf[x]);\n\t\tpd[x] += pd[uf[x]];\n\t\treturn uf[x] = new_parent;\n\t}\n\n\tvoid unite(int x, int y, int d) {\n\t\tint rx = find(x), ry = find(y);\n\t\tif(rx == ry) return;\n\n\t\td += pd[x] - pd[y];\n\n\t\tif(uf[rx] > uf[ry]) swap(rx, ry), d = -d;\n\t\telse if(uf[rx] == uf[ry]) --uf[rx];\n\n\t\tpd[ry] = d;\n\t\tuf[ry] = rx;\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tint dist(int x, int y) {\n\t\tif(find(x) != find(y)) return INF;\n\t\treturn pd[y] - pd[x];\n\t}\n};\n\nbool judge(int n, const vector<int> &u, const vector<int> &v, const vector<int> &c) {\n\tunion_find uf(n);\n\tfor(unsigned i = 0; i < u.size(); ++i) {\n\t\tif(uf.same(u[i], v[i])) {\n\t\t\tif(uf.dist(u[i], v[i]) != c[i]) return false;\n\t\t}\n\t\telse {\n\t\t\tuf.unite(u[i], v[i], c[i]);\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tconverter.clear();\n\t\tvector<int> u(n), v(n), c(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint one;\n\t\t\tstring left_unit, equeal, a, right_unit;\n\t\t\tcin >> one >> left_unit >> equeal >> a >> right_unit;\n\t\t\tu[i] = convert(left_unit);\n\t\t\tv[i] = convert(right_unit);\n\t\t\tc[i] = stoi(a.substr(3));\n\t\t}\n\n\t\tcout << (judge(converter.size(), u, v, c) ? \"yes\" : \"no\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<set>\n#include<cstdio>\n#include<cassert>\n#define F first\n#define S second\n#define inf (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nstruct P\n{\n  string unit;\n  int mpower;\n  int upower;\n  P(string unit=\"$\",int upower=-inf,int mpower=-inf):unit(unit),upower(upower),mpower(mpower){}\n};\nvector<vector<P> > G(110);\nmap<string,int> exist;\n\nint toPower(string s)\n{\n  if(s == \"1\")return 0;\n  int pos = 0;\n  rep(i,s.size())\n    {\n      if(s[i] == '^')\n\t{\n\t  pos = i+1;\n\t  break;\n\t}\n    }\n  return (atoi)(s.substr(pos,s.size()-pos).c_str());\n}\n\nbool used[110];\nint isok;//-1 -> No, 0 => Not yet, 1 -> Ok\n\nvoid dfs(string now,string target,int power,int target_power)\n{\n  if(isok != 0)return;\n  if(now == target)\n    {\n      isok = (power == target_power?1:-1);\n      return;\n    }\n  int index = exist[now];\n  if(used[index])return;\n  used[index] = true;\n\n  rep(i,G[index].size())\n    {\n      P p = G[index][i];\n      int next_index = exist[p.unit];\n      if(used[next_index])continue;\n      dfs(p.unit,target,power+(p.mpower==0?p.upower:-p.mpower),target_power );\n    }\n}\n\nbool check(string u1,string u2,int power)\n{\n  rep(i,110)used[i] = false;\n  isok = 0;\n\n  dfs(u1,u2,0,power);\n  return isok == 1;\n}\n\nbool reachable;\n\nvoid move(int now,int target)\n{\n  if(now == target)\n    {\n      reachable = true;\n      return;\n    }\n\n  if(used[now])return;\n  used[now] = true;\n\n  rep(i,G[now].size())\n    {\n      if(exist.count(G[now][i].unit) == 0)continue;\n      assert(exist.count(G[now][i].unit));\n\n      move(exist[G[now][i].unit],target);\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N )\n    {\n      assert(N <= 100);\n      rep(i,N)G[i].clear();\n      int index = 0;\n      exist.clear();\n      bool result = true;\n      rep(i,N)\n\t{\n\t  string v1,unit1,v2,unit2,eq;\n\t  cin >> v1 >> unit1 >> eq >> v2 >> unit2;\n\n\t  if(unit1 == unit2)\n\t    {\n\t      if(v2 == \"10^0\")continue;\n\t      else            result = false;\n\t      continue;\n\t    }\n\t  //assert(unit1 != unit2);\n\t  if(!result)continue;\n\t  //cout << toPower(v1) << \" \" << unit1 << \" = \"<< toPower(v2) << \" \" << unit2 << endl;\n\t  if(exist.count(unit1) && exist.count(unit2))\n\t    {\n\t      rep(i,N)used[i] = false;\n\t      reachable = false;\n\t      move(exist[unit1],exist[unit2]);\n\t      if(reachable)\n\t\t{\n\t\t  int p1 = toPower(v1);\n\t\t  int p2 = toPower(v2);\n\t\t  result = check(unit1,unit2,p2);\n\t\t  //cout << \"result = \" << result << endl;\n\t\t}\n\t      else\n\t\t{\n\t\t  goto Insert;\n\t\t}\n\t      continue;\n\t    }\n\n\t  //cout << \"not exists\" << endl;\n\t  if(!exist.count(unit1))exist[unit1] = index++;\n\t  if(!exist.count(unit2))exist[unit2] = index++;\n\tInsert:;\n\t  int index1 = exist[unit1];\n\t  int index2 = exist[unit2];\n\t  G[index1].push_back(P(unit2,toPower(v2),toPower(v1)));\n\t  G[index2].push_back(P(unit1,toPower(v1),toPower(v2)));\n\t}\n      cout << (result?\"Yes\":\"No\") << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nmap <string,int> M;\nvector <P> e[101];\nbool used[101];\nint C[101];\n\nbool check(int ima,int prev,int cost){\n  int size=e[ima].size();\n  if(used[ima])return cost-C[ima]==0;\n  used[ima]=1,C[ima]=cost;\n  for(int i=0;i<size;i++){\n    int nx=e[ima][i].f;\n    if(nx!=prev&&!check(nx,ima,cost+e[ima][i].s))return 0;\n  }\n  return 1;\n}\n\nint main(){\n\n  int n;\n  while(cin>>n,n){;\n    for(int i=0;i<100;i++)e[i].clear();\n    M.clear();\n\n    int N=0;\n    for(int i=0;i<n;i++){\n      string a,b,c,d,E;\n      cin>>a>>b>>c>>d>>E;\n      if(!M.count(b))M[b]=N++;\n      if(!M.count(E))M[E]=N++;\n      int num=0,j=3,flg=1;\n      if(d[3]=='-')flg=-1,j=4;\n      while(j<d.size())num=num*10+d[j++]-'0';\n      e[M[b]].push_back(P(M[E],flg*num));\n      e[M[E]].push_back(P(M[b],-num*flg));\n    }\n    int ans=1;\n    for(int i=0;i<N;i++){\n      memset(used,0,sizeof(used));\n      memset(C,0,sizeof(C));\n      ans*=check(i,-1,0);\n    }\n    cout <<(ans? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint loc;\n};\n\nint N;\nchar name_table[200][17];\nchar left_table[100][17],relative[100][17],right_table[100][17];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nInfo info[200];\n\nint get_relative(char buf[17]){\n\n\tint ret = 0;\n\n\tif(buf[3] == '-'){\n\t\tfor(int i = 4; buf[i] != '\\0'; i++){\n\t\t\tret = 10*ret+buf[i]-'0';\n\t\t}\n\t\tret*= -1;\n\t}else{\n\t\tfor(int i = 3; buf[i] != '\\0'; i++){\n\t\t\tret = 10*ret+buf[i]-'0';\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 100; i++){\n\t\tinfo[i].loc = -1;\n\t}\n\n\tint tmp;\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %s %s %s %s\",&tmp,left_table[i],buf,relative[i],right_table[i]);\n\t}\n\n\tstrcpy(name_table[0],left_table[0]);\n\tstrcpy(name_table[1],right_table[0]);\n\n\tint index = 2;\n\ttmp = get_relative(relative[0]);\n\tinfo[0].loc = 10000;\n\tinfo[1].loc = 10000-tmp;\n\n\tint used_num = 1;\n\tint left_index,right_index;\n\tint eq_num;\n\n\tbool FLG;\n\n\tvector<int> V;\n\tfor(int i = 1; i < N; i++)V.push_back(i);\n\tint V_loc;\n\n\twhile(used_num < N){\n\n\t\tFLG = false;\n\n\t\tfor(int i = 0; i < V.size(); i++){\n\n\t\t\tleft_index = -1;\n\t\t\tfor(int k = 0; k < index; k++){\n\t\t\t\tif(strCmp(name_table[k],left_table[V[i]])){\n\t\t\t\t\tleft_index = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tright_index = -1;\n\t\t\tfor(int k = 0; k < index; k++){\n\t\t\t\tif(strCmp(name_table[k],right_table[V[i]])){\n\t\t\t\t\tright_index = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(left_index != -1 || right_index != -1){\n\t\t\t\tFLG = true;\n\t\t\t\teq_num = V[i];\n\t\t\t\tV_loc = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\n\t\t\t\teq_num = V[i];\n\t\t\t\tV_loc = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tV.erase(V.begin()+V_loc);\n\t\t\tused_num++;\n\n\t\t\tstrcpy(name_table[index],left_table[eq_num]);\n\t\t\tstrcpy(name_table[index+1],right_table[eq_num]);\n\t\t\ttmp = get_relative(relative[eq_num]);\n\t\t\tinfo[index].loc = 10000;\n\t\t\tinfo[index+1].loc = info[index].loc-tmp;\n\t\t\tindex += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tV.erase(V.begin()+V_loc);\n\t\tused_num++;\n\n\t\tif(left_index == -1){\n\t\t\tstrcpy(name_table[index],left_table[eq_num]);\n\t\t\ttmp = get_relative(relative[eq_num]);\n\t\t\tinfo[index].loc = info[right_index].loc+tmp;\n\t\t\tindex++;\n\t\t}else if(right_index == -1){\n\t\t\tstrcpy(name_table[index],right_table[eq_num]);\n\t\t\ttmp = get_relative(relative[eq_num]);\n\t\t\tinfo[index].loc = info[left_index].loc-tmp;\n\t\t\tindex++;\n\t\t}else{\n\t\t\ttmp = get_relative(relative[eq_num]);\n\n\t\t\tif(info[left_index].loc-info[right_index].loc != tmp){\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"Yes\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\n\nconst int INF = 1<<29;\nint main(){\n    int n;\n    while(cin >> n, n){\n        map<string, int> enc;\n        vector<vector<int>> path(200, vector<int>(200, INF));\n        int cnt = 0;\n        string x, a, b, c;\n        for(int i = 0; i < n; i++){\n            cin >> x >> a >> x >> c >> b;\n            int val = stoi(c.substr(3));\n            if(enc.count(a) == 0)   enc[a] = cnt++;\n            if(enc.count(b) == 0)   enc[b] = cnt++;\n            path[enc[a]][enc[b]] = val;\n            path[enc[b]][enc[a]] = -val;\n        }\n        // run dijkstra from all vertexes\n        bool valid = true;\n        for(int i = 0; i < cnt && valid; i++){\n            vector<int> dp(cnt, INF);\n            dp[i] = 0;\n            queue<int> q;\n            q.push(i);\n            while(valid && !q.empty()){\n                int pos = q.front(); q.pop();\n                for(int j = 0; j < cnt; j++){\n                    if(path[pos][j] == INF)   continue;\n                    if(dp[j] == INF){\n                        dp[j] = dp[pos]+path[pos][j];\n                        q.push(j);\n                    }else if(dp[pos]+path[pos][j] != dp[j]){\n                        valid = false;\n                        break;\n                    }\n                }\n            }\n        }\n        cout << (valid ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <utility>\n#include <algorithm>\n#define P pair<string,int>\n#define N 110\nusing namespace std;\n\nint n,m;\nint d[N][N];\nmap<string,int> units; // units[ a ] でaの配列番号が分かる\n\nbool check(){ /* 誤った規則があればfalse */\n\n  for( int k=0;k<m;k++ )\n    for( int i=0;i<m;i++ )\n      for( int j=0;j<m;j++ )\n\td[i][j] = min( d[i][j],d[i][k]+d[k][j] );\n\n  for( int i=0;i<m;i++ )\n    if( d[i][i]!=0 )\n      return false;\n  return true;\n}\n\nint main(){\n  string a,b, s;\n  int x;\n\n  while( cin>>n && n ){\n    for( int i=0;i<N;i++ )for( int j=0;j<N;j++ ) d[i][j]=1000;\n\n    units.clear(); m=0;\n    getline(cin,s); // 改行コードまで\n    for( int i=0;i<n;i++ ){\n      /*\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c;  // 10^\n      cin >> x >> b;  // [x] [B];\n      */\n      getline(cin,s);      //      cout << s << endl;\n\n      int j = s.find(\" \")+1;\n      a=\"\"; while( s[j]!=' ' ) a += s[j++];\n      j = s.find(\"^\")+1;\n      x = atoi( s.c_str()+j );\n      j = s.find( \" \",j )+1;\n      b=\"\";  while( j<(int)s.length() ) b+= s[j++];\n      //      cout << a << \" \" << x <<\" \" << b << endl;\n\n      if( units.find( a )==units.end() )\n\tunits.insert( P(a,m++) );\n      if( units.find( b )==units.end() )\n\tunits.insert( P(b,m++) );\n\n      int an=units[a], bn=units[b];\n      d[an][bn] =  x;\n      d[bn][an] = -x;\n    }\n\n    if( check() ) cout << \"Yes\" << endl;\n    else          cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<map>\n#include<string>\nusing namespace std;\n\n#define INF 10000000\n\nint main()\n{\t\n\n\tint n;\n\tstring temp;\n\tint a;\n\n\tint cost[200][200],minicost[200];\n\n\twhile(cin>>n && n!=0){\n\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t\tminicost[i]=INF;\n\t\t}\n\n\n\t\tmap<string,int> Idx;\n\t\tint num=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a;//1\n\t\t\tstring s,t,p; cin>>s>>temp>>p>>t;\n\t\t\tif(!Idx.count(s)){Idx[s]=num++;}\n\t\t\tif(!Idx.count(t)){Idx[t]=num++;}\n\t\t\tstd::istringstream is(p);  // \"10+10\"を読み込む\n\t\t\tint k;\n\t\t\tchar taa;\n\t\t\tis>>a>>taa>>k;\n\t\t\tcost[Idx[s]][Idx[t]]=k;\n\t\t\tcost[Idx[t]][Idx[s]]=-k;\n\t\t}\n\n\t\tint count=0;\n\t\tbool print=false;\n\t\twhile(true){\n\t\t\tbool update=false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(cost[i][j]<INF){\n\t\t\t\t\t\tif(minicost[j]<minicost[i]+cost[i][j]){\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\tminicost[j]=minicost[i]+cost[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update){cout<<\"Yes\"<<endl;print=true;break;}\n\t\t\tcount++;\n\t\t\tif(count>n+1) break;\n\t\t}\n\t\tif(!print)cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <map>\n \nusing namespace std;\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n \ntypedef pair<int, int> P;\n \nint d[201][201];\n \nconst int INF = 1<<29;\nint main(){\n    int n;\n    while(cin >> n, n){\n        rep(i, 101) rep(j, 101) d[i][j] = INF;\n        map<string, int> num;\n        int idx = 0;\n        bool ans = true;\n        rep(i, n){\n            string a, b;\n            string c;\n            cin >> c >> a >> c >> c >> b;\n            if(!num[a]) num[a] = ++idx;\n            if(!num[b]) num[b] = ++idx;\n            int x = atoi(c.substr(3).c_str());\n            // a = b+x\n            int l = num[a], r = num[b];\n\t\t\td[l][l] = d[r][r] = 0;\n            rep(k, 2){\n                if(d[l][r] == INF){\n                    d[l][r] = x;\n                }else{\n                    if(d[l][r] != x) ans = false;\n                }\n                swap(l, r);\n                x = -x;\n            }\n            for(int j = 1; j <= idx; j++){\n                for(int k = 1; k <= idx; k++){\n                    if(d[k][j] == INF) continue;\n                    for(int l = 1; l <= idx; l++){\n                        if(d[j][l] == INF) continue;\n                        d[k][l] = min(d[k][l], d[k][j]+d[j][l]);\n                    }\n                }\n            }\n            for(int j = 1; j <= idx; j++){\n\t\t\t\tif(d[j][j] != 0) ans = false;\n\t\t\t}\n        }\n \n        cout << (ans?\"Yes\":\"No\") << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#define N 210\nusing namespace std;\n\nint n,m;\nint d[N][N];\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int k=0;k<m;k++ )\n    for( int i=0;i<m;i++ )\n      for( int j=0;j<m;j++ )\n\td[i][j] = min( d[i][j],d[i][k]+d[k][j] );\n\n  for( int i=0;i<m;i++ )\n    if( d[i][i]<0 )\n      return false;\n  return true;\n}\n\nint main(){\n  string a,b, s;\n  int x;\n  char c;\n\n  while( cin>>n && n ){\n    m=n*2;\n    for( int i=0;i<m;i++ ){\n      for( int j=0;j<m;j++ )\n\td[i][j]=1000;\n      d[i][i] = 0;\n    }\n    map<string,int> units; // units[ a ] でaの配列番号が分かる\n    m=0;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c;  // 10^\n      cin >> x >> b;  // [x] [B];\n\n      if( units.find( a )==units.end() )\n\tunits[a] = m++;\n      if( units.find( b )==units.end() )\n\tunits[b] = m++;\n\n      int an=units[a], bn=units[b];\n      \n      d[an][bn] =  x;\n      d[bn][an] = -x;\n    }\n\n    if( check() ) cout << \"Yes\" << endl;\n    else          cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n                //// Ç¿çàINFæè¬³­Èé\n                //if(prv!=INF&&d[j][i]+d[i][k]<INF){\n                //    if(prv!=d[j][i]+d[i][k]){\n                //        return false;\n                //    }\n                //}\n            }\n        }\n    }\n//    return true;\n}\n\nbool passed[101];\nbool no;\nvoid dfs(int s){\n    passed[s]=true;\n    for(int i = 0; i < V; i++){\n        if(i==s)continue;\n        if(d[s][i]!=INF){\n            if(passed[i]){\n                no=true;\n                return;\n            }\n            dfs(i);\n            if(no)\n                return;\n        }\n    }\n    passed[s]=false;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0)\n                d[dict[a]][dict[b]]=-cost;\n            else\n                d[dict[b]][dict[a]]=cost;\n        }\n        V=idx;\n        vector<int> roots;\n        for(int j = 0; j < idx; j++){\n            int cnt=0;\n            for(int i = 0; i < idx; i++){\n                if(i==j)continue;\n                if(d[i][j]!=INF)\n                    cnt++;\n            }\n            if(cnt==0)\n                roots.push_back(j);\n        }\n        no=false;\n        for(int i = 0; i < roots.size(); i++){\n            fill(passed,passed+101,false);\n            dfs(roots[i]);\n        }\n        warshall_floyd();\n        for(int i = 0; i < idx; i++){\n            for(int j = 0;  j< idx; j++){\n                int dist=d[i][j];\n                if(i==j)\n                    continue;\n                for(int k = 0; k < idx; k++){\n                    if(dist<INF&&d[i][k]<INF&&d[k][j]<INF){\n                        if(dist!=d[i][k]+d[k][j])\n                            no=true;\n                    }\n                    if(no)\n                        break;\n                }\n                if(no)\n                    break;\n            }\n            if(no)break;\n        }\n\n        if(no)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \n\nint main(void){  \n  int N;\n  while(cin>>N){\n    if(!N) break;\n    vector<string> tani;\n    vector<int> ind;\n    bool flag = true;\n    bool first = true;\n    int tmp;\n    string tmp2;\n    int count=0;\n    int date[100];\n    string date2[100][2];\n    while(N--){\n      string tani1,tani2;\n      int index;\n      cin>>tmp;\n      cin>>tani1;\n      cin>>tmp2;\n      cin>>tmp2;\n      index = (tmp2[3]!='-')?(tmp2[3]-'0'):('0' - tmp2[4]);\n      cin>>tani2;\n      if(first){\n        tani.push_back(tani1); tani.push_back(tani2);\n        ind.push_back(0); ind.push_back(index);\n        first = false;\n        continue;\n      }\n      vector<string>::iterator it1 = find(tani.begin(),tani.end(),tani1)\n        , it2 = find(tani.begin(),tani.end(),tani2);\n      bool f1 = (it1 != tani.end());\n      bool f2 = (it2 != tani.end());\n      int ind1 = ind[distance(tani.begin(),it1)];\n      int ind2 = ind[distance(tani.begin(),it2)];\n      if(f1){\n        if(f2){\n          if(ind2 - ind1 != index){\n            flag = false;\n          }\n        }else{\n          ind.push_back(ind1 + index);\n          tani.push_back(tani2);\n        }\n      }else{\n        if(f2){\n          ind.push_back(ind2 - index);\n          tani.push_back(tani1);\n        }else{\n          date[count] = index;\n          date2[count][0] = tani1;\n          date2[count][1] = tani2;\n          count++;\n        }\n      }\n    }\n    bool flag5 = false;\n    do{\n      flag5 = false;\n    REP(i,count){\n      vector<string>::iterator \n        it1 = find(tani.begin(),tani.end(),date2[i][0]), \n        it2 = find(tani.begin(),tani.end(),date2[i][1]);\n      bool f1 = (it1 != tani.end());\n      bool f2 = (it2 != tani.end());\n      int ind1 = ind[distance(tani.begin(),it1)];\n      int ind2 = ind[distance(tani.begin(),it2)];\n      if(f1&&f2){\n        if(ind2-ind1!=date[i])flag = false;\n      }else if(f1&&!f2){\n        ind.push_back(ind1 + date[i]);\n        tani.push_back(date2[i][1]);\n      }else if(!f1&&f2){\n        ind.push_back(ind2 - date[i]);\n        tani.push_back(date2[i][0]);\n      }else{\n        flag5 = true;\n      }\n    }\n    }while(flag5);\n    if(flag) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nmap <string,int> M;\nvector <P> e[301];\nint C[301],used[301];\n\nbool check(int ima,int cost){\n  int size=e[ima].size();\n  if(used[ima])return (cost-C[ima])==0;\n  used[ima]=1,C[ima]=cost;\n  for(int i=0;i<size;i++)\n    if(!check(e[ima][i].f,cost+e[ima][i].s))return 0;\n  return 1;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){;\n    for(int i=0;i<100;i++)e[i].clear();\n    M.clear();\n\n    int N=0;\n    for(int i=0;i<n;i++){\n      string a,b,c,d,E;\n      cin>>a>>b>>c>>d>>E;\n      if(!M.count(b))M[b]=N++;\n      if(!M.count(E))M[E]=N++;\n      int num=0,j=3,flg=1;\n      if(d[3]=='-')flg=-1,j=4;\n      while(j<d.size())num=num*10+d[j++]-'0';\n      e[M[b]].push_back(P(M[E],num*flg));\n      e[M[E]].push_back(P(M[b],-num*flg));\n    }\n\n    int ans=1;\n    for(int i=0;i<N;i++){\n      memset(used,0,sizeof(used));\n      memset(C,0,sizeof(C));\n      ans*=check(i,0);\n    }\n    cout <<(ans? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tstring lhs;\n\tstring rhs;\n\tint power;\n\tData(string _l,string _r, int _p){\n\t\tlhs = _l;\n\t\trhs = _r;\n\t\tpower = _p;\n\t}\n};\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Data> relations;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint num;\n\t\t\tstring lhs;\n\t\t\tstring eq;\n\t\t\tstring rhs;\n\t\t\tstring tmp;\n\n\t\t\tcin >> num >> lhs >> eq >> tmp >> rhs;\n\t\t\tint base,pow;\n\t\t\tsscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n\t\t\trelations.push_back(Data(lhs,rhs,pow));\n\t\t}\n\n\t\tmap<string,vector<int> > vals;\n\n\t\tbool isok = true;\n\t\tvals[relations[0].rhs].push_back(1);\n\t\t//for(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(vals[relations[j].rhs].size() > 0){\n\t\t\t\t\tvals[relations[j].lhs].push_back(relations[j].power + vals[relations[j].rhs][0]);\n\t\t\t\t\tsort(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t\tvector<int>::iterator it = unique(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t\tvals[relations[j].lhs].resize( it - vals[relations[j].lhs].begin() );\n\n\t\t\t\t\tif(vals[relations[j].lhs].size() > 1) isok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t//}\n\n\t\t//for(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(vals[relations[j].lhs].size() > 0){\n\t\t\t\t\tvals[relations[j].rhs].push_back(-relations[j].power + vals[relations[j].lhs][0]);\n\t\t\t\t\tsort(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t\tvector<int>::iterator it = unique(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t\tvals[relations[j].rhs].resize( it - vals[relations[j].rhs].begin() );\n\n\t\t\t\t\tif(vals[relations[j].rhs].size() > 1) isok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t//}\n\n\t\tprintf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <map>\n \nusing namespace std;\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n \ntypedef pair<int, int> P;\n \nint d[201][201];\n \nconst int INF = 1<<29;\nint main(){\n    int n;\n    while(cin >> n, n){\n        rep(i, 201) rep(j, 201) d[i][j] = INF;\n        map<string, int> num;\n        int idx = 0;\n        bool ans = true;\n        rep(i, n){\n            string a, b;\n            string c;\n            cin >> c >> a >> c >> c >> b;\n            if(!num[a]) num[a] = ++idx;\n            if(!num[b]) num[b] = ++idx;\n            int x = atoi(c.substr(3).c_str());\n            // a = b+x\n            int l = num[a], r = num[b];\n\t\t\td[l][l] = d[r][r] = 0;\n            rep(k, 2){\n                d[l][r] = x;\n                swap(l, r);\n                x = -x;\n            }\n            for(int j = 1; j <= idx; j++){\n                for(int k = 1; k <= idx; k++){\n                    if(d[k][j] == INF) continue;\n                    for(int l = 1; l <= idx; l++){\n                        if(d[j][l] == INF) continue;\n                        d[k][l] = min(d[k][l], d[k][j]+d[j][l]);\n                    }\n                }\n            }\n            for(int j = 1; j <= idx; j++){\n\t\t\t\tif(d[j][j] != 0) ans = false;\n\t\t\t}\n        }\n \n        cout << (ans?\"Yes\":\"No\") << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <limits>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n// 隣接リストを用いたグラフ構造\n// （Weight は、可換群（アーベル群）... operator+, operator- が実装されていること）\n// （ABEL_UNITY は、可換群（アーベル群）Weight の単位元）\ntemplate <typename Weight = int, Weight ABEL_UNITY = 0>\nstruct PotentialUnionFind\n{\n\t// 第i頂点が属するグループの親\n\tvector<int> parent;\n\t// 第i頂点のランク（ぶらさがる木の最大深さ）\n\tvector<int> rank;\n\t// 第i頂点の親との重みの差\n\tvector<Weight> diffWeight;\n\n\t// n個の頂点を事前に生成する\n\tvoid resize (size_t n)\n\t{\n\t\tparent.reserve(n);\n\t\tfor (int i=parent.size(); i<n; ++i)\n\t\t{\n\t\t\tparent.push_back(i);\n\t\t}\n\n\t\trank.resize(n, 0);\n\t\tdiffWeight.resize(n, ABEL_UNITY);\n\t}\n\n\t// 頂点n個分のメモリ領域を事前に確保する\n\tvoid reserve (size_t n)\n\t{\n\t\tparent.reserve(n);\n\t\trank.reserve(n);\n\t\tdiffWeight.reserve(n);\n\t}\n\n\t// 頂点を1つ追加する（返り値は頂点番号）\n\tint addVertex ()\n\t{\n\t\tint index = parent.size();\n\t\tparent.push_back(index);\n\t\trank.push_back(0);\n\t\tdiffWeight.push_back(ABEL_UNITY);\n\t\treturn index;\n\t}\n\n\t// グループの親\n\tint root (int vertex)\n\t{\n\t\tif (vertex == parent[vertex])\n\t\t{\n\t\t\treturn vertex;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint r = root(parent[vertex]);\n\t\t\tdiffWeight[vertex] += diffWeight[parent[vertex]]; // 重みの累積和をとる\n\n\t\t\t// 経路圧縮\n\t\t\treturn parent[vertex] = r;\n\t\t}\n\t}\n\n\t// 同じグループに属しているか\n\tbool isSame (int vertex1, int vertex2)\n\t{\n\t\treturn root(vertex1) == root(vertex2);\n\t}\n\n\t// vertex1 から vertex2 への重みの変分が weight となる\n\t// ように、グループを結合\n\tbool merge (int vertex1, int vertex2, Weight weight)\n\t{\n\t\t// 親の重みの差を計算\n\t\tweight += this->weight(vertex1);\n\t\tweight -= this->weight(vertex2);\n\n\t\t// グループの親の取得\n\t\tvertex1 = root(vertex1);\n\t\tvertex2 = root(vertex2);\n\n\t\t// 親が既に同じときはマージ済み\n\t\tif (vertex1 == vertex2) return false;\n\n\t\t// 深さの大きいほうを vertex1 にして\n\t\tif (rank[vertex1] < rank[vertex2])\n\t\t{\n\t\t\tswap(vertex1, vertex2);\n\t\t\tweight = -weight;\n\t\t}\n\t\t// 深さが同じなら vertex1 を持ち上げて\n\t\telse if (rank[vertex1] == rank[vertex2]) ++rank[vertex1];\n\n\t\t// vertex2 を vertex1 にぶら下げる\n\t\tparent[vertex2] = vertex1;\n\t\tdiffWeight[vertex2] = weight;\n\n\t\treturn true;\n\t}\n\n\t// 頂点の重み\n\tWeight weight (int vertex)\n\t{\n\t\t// 経路圧縮と重み累積和の計算\n\t\troot(vertex);\n\t\treturn diffWeight[vertex];\t\n\t}\n\n\t// vertex1 から vertex2 への重みの変分\n\tWeight diff (int vertex1, int vertex2)\n\t{\n\t\treturn weight(vertex2) - weight(vertex1);\n\t}\n};\n\n// 使用例（AOJ 2207 無矛盾な単位系）\n\nint main ()\n{\n\tint n;\n\twhile (true)\n\t{\n\t\tcin >> n;\n\t\tif (0 == n) break;\n\n\t\tPotentialUnionFind<int> unionfind;\n\t\tunionfind.reserve(200);\n\n\t\tunordered_map<string, int> unit;\n\n\t\tstring _, unit1, value, unit2;\n\t\tbool ok = true;\n\t\tfor (int i=0; i<n; ++i)\n\t\t{\n\t\t\tcin >> _ >> unit1 >> _ >> value >> unit2;\n\n\t\t\tif (!ok) continue;\n\n\t\t\t// 単位の登録\n\t\t\tif (unit.end() == unit.find(unit1))\n\t\t\t{\n\t\t\t\tunit[unit1] = unionfind.addVertex();\n\t\t\t}\n\t\t\tif (unit.end() == unit.find(unit2))\n\t\t\t{\n\t\t\t\tunit[unit2] = unionfind.addVertex();\n\t\t\t}\n\n\t\t\t// 指数のみ取得\n\t\t\tint diff;\n\t\t\tstringstream(value.substr(3)) >> diff;\n\n\t\t\tint id1 = unit[unit1];\n\t\t\tint id2 = unit[unit2];\n\n\t\t\t// 単位に関係があるなら\n\t\t\tif (unionfind.isSame(id1, id2))\n\t\t\t{\n\t\t\t\tint current_diff = unionfind.diff(id1, id2);\n\t\t\t\tif (diff != current_diff) ok = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tunionfind.merge(id1, id2, diff);\n\t\t\t}\n\t\t}\n\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tstring lhs;\n\tstring rhs;\n\tint power;\n\tData(string _l,string _r, int _p){\n\t\tlhs = _l;\n\t\trhs = _r;\n\t\tpower = _p;\n\t}\n};\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Data> relations;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint num;\n\t\t\tstring lhs;\n\t\t\tstring eq;\n\t\t\tstring rhs;\n\t\t\tstring tmp;\n\n\t\t\tcin >> num >> lhs >> eq >> tmp >> rhs;\n\t\t\tint base,pow;\n\t\t\tsscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n\t\t\trelations.push_back(Data(lhs,rhs,pow));\n\t\t}\n\n\t\tmap<string,vector<int> > vals;\n\n\t\tbool isok = true;\n\t\tvals[relations[0].rhs].push_back(1);\n\t\t//for(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(vals[relations[j].rhs].size() > 0){\n\t\t\t\t\tvals[relations[j].lhs].push_back(relations[j].power + vals[relations[j].rhs][0]);\n\t\t\t\t\tsort(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t\tvector<int>::iterator it = unique(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\t\t\tvals[relations[j].lhs].resize( it - vals[relations[j].lhs].begin() );\n\n\t\t\t\t\tif(vals[relations[j].lhs].size() > 1) isok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t//}\n\n\t\t//for(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(vals[relations[j].lhs].size() > 0){\n\t\t\t\t\tvals[relations[j].rhs].push_back(-relations[j].power + vals[relations[j].lhs][0]);\n\t\t\t\t\tsort(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t\tvector<int>::iterator it = unique(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\t\t\tvals[relations[j].rhs].resize( it - vals[relations[j].rhs].begin() );\n\n\t\t\t\t\tif(vals[relations[j].rhs].size() > 1) isok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t//}\n\n\t\tprintf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for(int i = 0; i < n; ++i) {\n            par[i] = i; rank[i] = 0; diff_weight[i] = SUM_UNITY;\n        }\n    }\n\n    int find(int x) {\n        if(par[x] == x) return x;\n        else {\n            int r = find(par[x]);\n            diff_weight[x] += diff_weight[par[x]];  // 累積和を取る\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        find(x);\n        return diff_weight[x];\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    bool unite(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y); // xとyそれぞれについて、rootとの重み差分を補正\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        if(rank[x] < rank[y]) swap(x, y), w = -w;   // rank[x] >= rank[y]になるようにswap\n        if(rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w; // xがyの親になるので、xとyの差分をdiff_weight[y]に記録\n        return true;\n    }\n\n    // 重みを取得する\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint n;\n\nint xcalc(string z) {\n    int zlen = z.length();\n    int zfin = zlen - 3;\n    string subz = z.substr(3, zfin);\n    int ret = 0;\n    if(subz.at(0) == '-') {\n        subz.at(0) = '0';\n        ret = stoi(subz);\n        ret = -ret;\n    }else {\n        ret = stoi(subz);\n    }\n    return ret;\n}\n\nint main() {\n    while(1) {\n        cin >> n;\n        if(n == 0) break;\n        UnionFind<ll> uf(200);\n        bool flg = true;\n        map<string, int> mdata;\n        int cnt = 0;\n        for(int i = 0; i < n; ++i) {\n            int one;\n            string A, eq, x, B;\n            cin >> one >> A >> eq >> x >> B;\n            if(mdata[A] == 0) {\n                mdata[A] = cnt+1; cnt++;\n            }\n            if(mdata[B] == 0) {\n                mdata[B] = cnt+1; cnt++;\n            }\n\n            int ch = xcalc(x);\n            if(uf.same(mdata[A]-1, mdata[B]-1)) {\n                // もし繋がっていたら\n                if(uf.diff(mdata[A]-1, mdata[B]-1) != ch) flg = false;\n            }else {\n                // 繋がっていなかったら\n                uf.unite(mdata[A]-1, mdata[B]-1, ch);\n            }\n        }\n\n        if(flg) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int INF = 1e9 + 7;\n\nmap<int, int> v, parent, dist;\nmap<string, int> M;\n\n// P(parent, dist)\nP find(int a){\n  if(parent[a] == a) return P(a, dist[a]);\n  P p = find(parent[a]);\n  parent[a] = p.first;\n  dist[a] += p.second;\n  return P(p.first, dist[a]);\n}\n\nbool same(int a, int b){ return find(a).first == find(b).first; }\n\nvoid merge(int a, int b, int dd){\n  if(same(a, b)) return ;\n  P pa = find(a), pb = find(b);\n  int d = dd - pb.second + pa.second;\n  if(d < 0){\n    d *= -1;\n    swap(pa, pb);\n  }\n  parent[pb.first] = pa.first;\n  dist[pb.first] = d;\n}\n\nint distance(int a, int b){\n  if(!same(a, b)) return INF;\n  return find(b).second - find(a).second;\n}\n\nvoid init_union_find(){\n  v = map<int, int>();\n  parent = map<int, int>();\n  dist = map<int, int>();\n  M = map<string, int>();\n}\n\nint number(string &s){\n  if(M.find(s) != M.end()) return M[s];\n  int num = M.size();\n  M[s] = num;\n  parent[num] = num;\n  return num;\n}\n\nint get_distance(string &s){\n  int idx = 0;\n  while(s[idx++] != '^') ;\n  return atoi(s.substr(idx).c_str());\n}\n\nvoid input(string &as, int &d, string &bs){\n  string s, tmp;\n  cin >>tmp >>as >>tmp >>s >>bs;\n  d = get_distance(s);\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    init_union_find();\n    bool ans = true;\n    REP(i, N){\n      string as, bs; int d;\n      input(as, d, bs);\n      int a = number(as), b = number(bs);\n      if(same(a, b)) { if(distance(a, b) != d) ans = false; }\n      else merge(a, b, d);\n    }\n    cout <<(ans ? \"Yes\" : \"No\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n                //// Ç¿çàINFæè¬³­Èé\n                //if(prv!=INF&&d[j][i]+d[i][k]<INF){\n                //    if(prv!=d[j][i]+d[i][k]){\n                //        return false;\n                //    }\n                //}\n            }\n        }\n    }\n//    return true;\n}\n\nbool passed[101];\nbool no;\nvoid dfs(int s){\n    passed[s]=true;\n    for(int i = 0; i < V; i++){\n        if(i==s)continue;\n        if(d[s][i]!=INF){\n            if(passed[i]){\n                no=true;\n                return;\n            }\n            dfs(i);\n            if(no)\n                return;\n        }\n    }\n    passed[s]=false;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0)\n                d[dict[a]][dict[b]]=-cost;\n            else\n                d[dict[b]][dict[a]]=cost;\n        }\n        V=idx;\n        vector<int> roots;\n        for(int j = 0; j < idx; j++){\n            int cnt=0;\n            for(int i = 0; i < idx; i++){\n                if(i==j)continue;\n                if(d[i][j]!=INF)\n                    cnt++;\n            }\n            if(cnt==0)\n                roots.push_back(j);\n        }\n        no=false;\n        for(int i = 0; i < roots.size(); i++){\n            fill(passed,passed+101,false);\n            dfs(roots[i]);\n        }\n        if(roots.size()==0)\n            no=true;\n        warshall_floyd();\n        for(int i = 0; i < idx; i++){\n            for(int j = 0;  j< idx; j++){\n                int dist=d[i][j];\n                if(i==j)\n                    continue;\n                for(int k = 0; k < idx; k++){\n                    if(dist<INF&&d[i][k]<INF&&d[k][j]<INF){\n                        if(dist!=d[i][k]+d[k][j])\n                            no=true;\n                    }\n                    if(no)\n                        break;\n                }\n                if(no)\n                    break;\n            }\n            if(no)break;\n        }\n\n        if(no)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 100*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n};\n\nbool relax(const vector<vector<pair<int,int> > > &graph, vector<int> &dist, int N) {\n    bool updated = false;\n    for(int i = 0; i < N; ++i) {\n        const vector<pair<int,int> > &edges = graph[i];\n        for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n            const int nc = dist[i] + it->second;\n            if(dist[it->first] > nc) {\n                dist[it->first] = nc;\n                updated = true;\n            }\n        }\n    }\n    return updated;\n}\n\nvector<vector<pair<int,int> > > v(100);\nvector<int> dist(100);\nvector<unsigned char> visited(100);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < N; ++i) {\n            v[i].clear();\n            dist[i] = INF;\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            for(string::iterator it = line.begin(); it != line.end(); ++it) {\n                if(*it == '=' || *it == '^') *it = ' ';\n            }\n            istringstream is(line);\n            string unit_left, unit_right;\n            int ord;\n            int tmp;\n            is >> tmp >> unit_left >> tmp >> ord >> unit_right;\n            //sscanf(line.c_str(), \"%*d %s = %*d^%d %s \", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        // テ」ツ?敕」ツつ古」ツ?榲」ツつ古」ツ?ョテゥツ?」テァツオツ静ヲツ按静・ツ按?」ツ?ォテ」ツ?、テ」ツ?催ッツシツ?テ」ツδ偲」ツδシテ」ツδ嘉」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ィテ」ツ?凖」ツつ凝ッツシツ?\n        fill(visited.begin(), visited.end(), 0);\n        queue<int> q;\n        for(int i = 0; i < N; ++i) {\n            if(!visited[i]) {\n                dist[i] = 0;\n                visited[i] = 1;\n                q.push(i);\n                while(!q.empty()) {\n                    int cur = q.front();\n                    q.pop();\n                    const vector<pair<int,int> > &edges = v[cur];\n                    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                        if(!visited[it->first]) {\n                            visited[it->first] = 1;\n                            q.push(it->first);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Bellman-ford\n        for(int phase = 0; phase < N; ++phase) {\n            if(!relax(v, dist, N)) break;\n        }\n        if(relax(v, dist, N)) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <functional>\n#include <string>\n#include <map>\nusing namespace std;\n\n//===\n//#include <vector>\n//#include <functional>\ntemplate<typename Abel>\nstruct WeightedUnionFind {\n    using OP = function<Abel(Abel, Abel)>;\n\n    vector<int> parent;\n    vector<Abel> diff_weight; // distance from root\n    const OP add;\n    const OP sub;\n    const Abel e;\n    \n    WeightedUnionFind(int nmemb,\n                      const Abel &e = 0,\n                      const OP &add = [](Abel x, Abel y){return x+y;},\n                      const OP &sub = [](Abel x, Abel y){return x-y;}):\n        e(e), add(add), sub(sub)\n    {\n        parent.assign(nmemb, -1);\n        diff_weight.assign(nmemb, e);\n    };\n\n    int root(int x) {\n        if (parent[x] < 0) {\n            return x;\n        }\n        \n        int p = root(parent[x]);\n        diff_weight[x] = add(diff_weight[x], diff_weight[parent[x]]);\n        parent[x] = p;\n\n        return p;\n    };\n\n    bool unite(int x, int y, Abel w) {\n        Abel wx = weight(x);\n        Abel wy = weight(y);\n        x = root(x);\n        y = root(y);\n\n        if (x == y) return false;\n        w = sub(add(w, wx), wy);\n        if (size(x) < size(y)) swap(x, y), w = -w;\n\n        parent[x] += parent[y];\n        parent[y] = x;\n        diff_weight[y] = w;\n        \n        return true;\n    };\n    \n    bool same(int x, int y) {\n        return root(x) == root(y);\n    };\n    \n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    };\n\n    Abel diff(int x, int y) {\n        return sub(weight(y), weight(x));\n    };\n\n    int size(int x) {\n        return -parent[root(x)];\n    };\n};\n//===\n\ntypedef long long ll;\n\n// verify AtCoder Beginner Contest 087 D\nint abc087D(void)\n{\n    WeightedUnionFind<ll> uf(1000005);\n    ll n, m;\n    ll l, r, d;\n\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        cin >> l >> r >> d;\n\n        uf.unite(l, r, d);\n\n        if (uf.diff(l, r) != d) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"Yes\" << endl;\n\n    return 0;\n}\n\n// verify AOJ_DSL_1_B\nint AOJ_DSL1B(void)\n{\n    int n, q;\n    ll com, x, y, w;\n\n    cin >> n >> q;\n    \n    WeightedUnionFind<ll> uf(n);\n\n    while (q--) {\n        cin >> com;\n\n        if (com == 0) {\n            cin >> x >> y >> w;\n            uf.unite(x, y, w);\n        }\n        else {\n            cin >> x >> y;\n            if (uf.same(x, y)) {\n                cout << uf.diff(x, y) << endl;\n            }\n            else {\n                cout << '?' << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n\n// verify UTPC2010 D\nint UTPC2010D(void)\n{\n    int n;\n    while (cin >> n, n != 0) {\n        map<string, int> mp;\n        string s, t;\n        int id = 1;\n        ll cost;\n        WeightedUnionFind<ll> uf(n * 2 + 5);\n        bool f = true;\n\n        for (int i = 0; i < n; i++) {\n            scanf(\"%*d\"); // '1'\n            cin >> s; //\n            scanf(\" %*c \"); // '='\n            scanf(\"10^ %lld\", &cost);\n            cin >> t;\n\n            if (mp.count(s) == 0) {\n                mp[s] = id++;\n            }\n            if (mp.count(t) == 0) {\n                mp[t] = id++;\n            }\n\n            uf.unite(mp[s], mp[t], cost);\n\n            if (uf.diff(mp[s], mp[t]) != cost) {\n                f = false;\n            }\n        }\n\n        if (f) {\n            cout << \"Yes\" << endl;\n        }\n        else {\n            cout << \"No\" << endl;\n        }\n    }\n\n    return 0;\n}\n\nint main()\n{\n    //return abc087D();\n    //return AOJ_DSL1B();\n    return UTPC2010D();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define\tmp\t\tmake_pair\n#define\tpb\t\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=999;\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint unum=0;\n\t\tpair<pii,int> edge[100];\n\t\tmap<string,int> name;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint pw;\n\t\t\tchar u1[17],u2[17];\n\t\t\tscanf(\"%*d %s %*c %*d%*c%d %s\",u1,&pw,u2);\n\n\t\t\tint id1,id2;\n\t\t\tif(name.count(u1)==0)\tname[u1]=unum++;\n\t\t\tid1=name[u1];\n\t\t\tif(name.count(u2)==0)\tname[u2]=unum++;\n\t\t\tid2=name[u2];\n\n\t\t\tedge[i]=mp(mp(id1,id2),pw);\n\t\t}\n\n\t\tbool ok=true;\n\t\tstatic int wf[200][200];\n\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++)\twf[i][j]=(i==j?0:inf);\n\t\tfor(int k=0;k<n;k++){\n\t\t\tint from=edge[k].first.first,to=edge[k].first.second,dis=edge[k].second;\n\t\t\tif(wf[from][to]==inf){\n\t\t\t\twf[from][to]=dis;\n\t\t\t\twf[to][from]=-dis;\n\t\t\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++){\n\t\t\t\t\tif(wf[i][from]==inf || wf[to][j]==inf)\tcontinue;\n\t\t\t\t\twf[i][j]=min(wf[i][j],wf[i][from]+dis+wf[to][j]);\n\t\t\t\t\twf[j][i]=-wf[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(wf[from][to]!=dis){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// UTPC2010 D. ツ鳴ウツ鳴オツ渉つづ按単ツ暗環系\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin >> n){\n\t\tstring s, t, r;\n\t\tmap<string, int> mp;\n\t\tvector< vector< pair<int,int> > > vp;\n\t\tint size = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s >> s >> t >> t >> r;\n\t\t\tif(!mp.count(s)) { mp[s] = size++; vp.push_back(vector< pair<int,int> >()); }\n\t\t\tif(!mp.count(r)) { mp[r] = size++; vp.push_back(vector< pair<int,int> >()); }\n\t\t\tt[2] = ' ';\n\t\t\tistringstream iss(t);\n\t\t\tint a; iss >> a >> a;\n\t\t\tvp[mp[s]].push_back(make_pair(mp[r], a));\n\t\t\tvp[mp[r]].push_back(make_pair(mp[s],-a));\n\t\t}\n\t\tbool ok = true;\n\t\tvector<bool> visit(size, false);\n\t\tvector<int>  calc(size, 0);\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(visit[i]) continue;\n\t\t\tqueue<int> qu; qu.push(i);\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint c = qu.front(); qu.pop();\n\t\t\t\tif(visit[c]) continue;\n\t\t\t\tvisit[c] = true;\n\t\t\t\tfor(int j=0;j<vp[c].size();j++){\n\t\t\t\t\tint nxt = vp[c][j].first;\n\t\t\t\t\tif(visit[nxt]) {\n\t\t\t\t\t\tif(calc[nxt]!=calc[c]+vp[c][j].second) ok = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcalc[nxt] = calc[c]+vp[c][j].second;\n\t\t\t\t\t\tqu.push(nxt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lp(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nconst int INF=1e9;\nstruct edge{\n    int to, cost;\n};\nstring a[105], b[105];\nint c[105];\nvector<edge> G[210];\n\nbool dfs(int v, vector<int> &dist)\n{\n    for(edge e:G[v]){\n        if(dist[e.to]==INF){\n            dist[e.to]=dist[v]+e.cost;\n            if(!dfs(e.to, dist)) return false;\n        }else{\n            if(dist[e.to]!=dist[v]+e.cost){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main()\n{\nwhile(true)\n{\n    int N; cin>>N;\n    if(N==0) break;\n\n    vector<string> vs;\n    for(int i=0;i<N;i++){\n      int x,y;\n      string s1,s2,s3,s4;\n      cin>>x>>s1>>s2>>s3>>s4;\n      lp(i,s3.size()){\n        if(s3[i]=='^'){\n          s3=s3.substr(i+1,s3.size()-i-1);\n          y=stoi(s3);\n          break;\n        }\n      }\n      a[i]=s1;\n      b[i]=s4;\n      c[i]=y;\n      vs.push_back(a[i]);\n      vs.push_back(b[i]);\n      //cout<<a[i]<<' '<<b[i]<<' '<<c[i]<<endl;\n    }\n    sort(vs.begin(), vs.end());\n    vs.erase(unique(vs.begin(), vs.end()), vs.end());\n\n    map<string, int> mp;\n    for(int i=0;i<vs.size();i++){\n        mp[vs[i]]=i;\n    }\n\n    int V=vs.size();\n    for(int i=0;i<V;i++){\n        G[i].clear();\n    }\n    for(int i=0;i<N;i++){\n        int v=mp[a[i]];\n        int u=mp[b[i]];\n        G[v].push_back({u, c[i]});\n        G[u].push_back({v, -c[i]});\n    }\n/*\n    for(int i=0;i<V;i++){\n        cout<<i<<' ';\n        for(edge e:G[i]){\n            cout<<e.to<<' '<<e.cost<<endl;\n        }\n        cout<<\"----------\"<<endl;\n    }\n*/\n    vector<int> dist(V, INF);\n    bool ok=true;\n    for(int i=0;i<V;i++){\n        if(dist[i]!=INF) continue;\n        dist[i]=0;\n        if(!dfs(i, dist)){\n            ok=false;\n        }\n    }\n    cout<<(ok? \"Yes\":\"No\")<<endl;\n}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nint main(){\n  int n,m;\n  int a,b,e;\n  string s1,s2;\n  char c,d;\n  while(true){\n    cin>>n;\n    m=0;\n    if(!n)break;\n    int graph[200][200];\n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)\n\tgraph[i][j] = 1000000;\n    vector<string> names(200);\n    for(int i=0;i<n;i++){\n      cin>>a>>s1>>c>>b>>d>>e>>s2;\n      int j=0,k=0;\n      for(;j<m;j++)if(names[j]==s1)break;\n      names[j] = s1;\n      if(j==m)m++;\n      for(;k<m;k++)if(names[k]==s2)break;\n      names[k] = s2;\n      if(k==m)m++;\n      graph[k][j] = e;\n      graph[j][k] = -e;\n    }\n    for(int k=0;k<m;k++){\n      for(int i=0;i<m;i++){\n\tfor(int j=0;j<m;j++){\n\t  if(graph[i][k]+graph[k][j]<graph[i][j])graph[i][j]=graph[i][k]+graph[k][j];\n\t}\n      }\n    }\n    bool bb = true;\n    for(int i=0;i<m;i++)\n      if(graph[i][i]<0)bb=false;\n    if(bb)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=100000000;\nconst int MAX_V = 301;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n            }\n        }\n    }\n}\n\nbool passed[MAX_V];\nbool no;\nvoid dfs(int s){\n    passed[s]=true;\n    for(int i = 0; i < V; i++){\n        if(i==s)continue;\n        if(d[s][i]!=INF){\n            if(passed[i]){\n                no=true;\n                return;\n            }\n            dfs(i);\n            if(no)\n                return;\n        }\n    }\n    passed[s]=false;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int j = 0; j < MAX_V; j++){\n            for(int k = 0; k < MAX_V; k++){\n                if(j==k)\n                    d[j][k]=0;\n                else\n                    d[j][k]=INF;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n\t      dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0){\n                d[dict[a]][dict[b]]=-cost;\n                d[dict[b]][dict[a]]=cost;\n\t    }\n            else{\n                d[dict[b]][dict[a]]=cost;\n                d[dict[a]][dict[b]]=-cost;\n\t    }\n        }\n        V=idx;\n        no=false;\n        for(int i = 0; i < idx; i++){\n            fill(passed,passed+MAX_V,false);\n            dfs(idx);\n        }\n        warshall_floyd();\n        for(int i = 0; i < idx; i++){\n            for(int j = 0;  j< idx; j++){\n                int dist=d[i][j];\n                if(i==j)\n\t\t  continue;\n                for(int k = 0; k < idx; k++){\n\t\t  if(dist<INF&&d[i][k]<INF&&d[k][j]<INF){\n\t\t    if(dist!=d[i][k]+d[k][j]){\n\t\t      no=true;\n\t\t    }\n\t\t  }\n\t\t  if(no)\n\t\t    break;\n                }\n                if(no)\n\t\t  break;\n            }\n            if(no)break;\n        }\n        if(no)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\ntemplate<class Abel> struct UnionFind {\n\tvector<int> par;\n\tvector<int> rank;\n\tvector<Abel> diff_weight;\n\n\tUnionFind(int n = 1, Abel SUM_UNITY = 0) {\n\t\tinit(n, SUM_UNITY);\n\t}\n\n\tvoid init(int n = 1, Abel SUM_UNITY = 0) {\n\t\tpar.resize(n); rank.resize(n); diff_weight.resize(n);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n\t}\n\n\tint root(int x) {\n\t\tif (par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\tint r = root(par[x]);\n\t\t\tdiff_weight[x] += diff_weight[par[x]];\n\t\t\treturn par[x] = r;\n\t\t}\n\t}\n\n\tAbel weight(int x) {\n\t\troot(x);\n\t\treturn diff_weight[x];\n\t}\n\n\tbool issame(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tbool merge(int x, int y, Abel w) {\n\t\tw += weight(x); w -= weight(y);\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (rank[x] < rank[y]) swap(x, y), w = -w;\n\t\tif (rank[x] == rank[y]) ++rank[x];\n\t\tpar[y] = x;\n\t\tdiff_weight[y] = w;\n\t\treturn true;\n\t}\n\n\tAbel diff(int x, int y) {\n\t\treturn weight(y) - weight(x);\n\t}\n};\n\nint main() {\n    int N;\n    while (cin >> N) {\n        if (N == 0) break;\n        bool ok = true;\n        UnionFind<int> uf(200); // 単位個数は最悪で 200 個\n        map<string,int> str2id; // 単位 -> id の対応\n        int final_id = 0;\n        for (int i = 0; i < N; ++i) {\n            string ichi, unit1, equal, val, unit2;\n            cin >> ichi >> unit1 >> equal >> val >> unit2;\n        \n            // 1個目の単位の番号\n            if (!str2id.count(unit1)) {\n                str2id[unit1] = final_id++;\n            }\n            int id1 = str2id[unit1];\n        \n            // 2個目の単位の番号\n            if (!str2id.count(unit2)) {\n                str2id[unit2] = final_id++;\n            }\n            int id2 = str2id[unit2];\n        \n            // 単位換算\n            stringstream si(val.substr(3));\n            int diff;\n            si >> diff; // \"1 kilometre = 10^3 metre\" の 3 の部分を取得\n        \n            // 重み付き Union-Find 木の処理\n            if (uf.issame(id1, id2)) {\n                int curdiff = uf.diff(id1, id2);\n                if (diff != curdiff) ok = false;\n            }\n            else {\n                uf.merge(id1, id2, diff);\n            }\n        }\n        \n        if (ok) puts(\"Yes\");\n        else puts(\"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<map>\n#include<string>\nusing namespace std;\n\n#define INF 10000000\n\nint main()\n{\t\n\n\tint n;\n\tstring temp;\n\tint a;\n\n\tint cost[200][200],minicost[200];\n\n\twhile(cin>>n && n!=0){\n\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t\tminicost[i]=INF;\n\t\t}\n\n\n\t\tmap<string,int> Idx;\n\t\tint num=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a;//1\n\t\t\tstring s,t,p; cin>>s>>temp>>p>>t;\n\t\t\tif(!Idx.count(s)){Idx[s]=num++;}\n\t\t\tif(!Idx.count(t)){Idx[t]=num++;}\n\t\t\tstd::istringstream is(p);  // \"10+10\"を読み込む\n\t\t\tint k;\n\t\t\tchar taa;\n\t\t\tis>>a>>taa>>k;\n\t\t\tcost[Idx[s]][Idx[t]]=k;\n\t\t\tcost[Idx[t]][Idx[s]]=-k;\n\t\t}\n\n\t\tint count=0;\n\t\twhile(true){\n\t\t\tbool update=false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(cost[i][j]<INF){\n\t\t\t\t\t\tif(minicost[j]<minicost[i]+cost[i][j]){\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\tminicost[j]=minicost[i]+cost[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif(count>n+10){cout<<\"No\"<<endl;break;}\n\t\t\tif(!update){cout<<\"Yes\"<<endl;break;}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint n,m,e[200][200];\n\nint main()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tmap<string,int> id;\n\t\trep(i,n)rep(j,n)e[i][j]=inf;\n\t\t\n\t\tstring u1,u2,t; m=0;\n\t\trep(i,n)\n\t\t{\n\t\t\tcin>>t>>u1>>t>>t>>u2;\n\t\t\tif(!id.count(u1))id[u1]=m++;\n\t\t\tif(!id.count(u2))id[u2]=m++;\n\t\t\te[id[u1]][id[u2]]=atoi(t.substr(3).c_str());\n\t\t\te[id[u2]][id[u1]]=-e[id[u1]][id[u2]];\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\t\tbool f=0;\n\t\trep(i,n)if(e[i][i]!=inf&&e[i][i]!=0)f=1;\n\t\tputs(f?\"No\":\"Yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int nn = 0;\n    string str;\n    getline(cin,str);\n    map<string,int> m;\n    vector<vector<int> > v;\n    v.assign(n+1, vector<int>(n+1,INF));\n    while(n--){\n      string str2,str3;\n      bool f = false, f2 = false, minus = false;\n      int a = 0;\n      getline(cin,str);\n      for(int i=2;i<str.size();i++){\n\tif(!f && !f2 && str[i] != ' ') str2 += str[i];\n\telse if(!f && !f2 && str[i] == ' '){\n\t  f = true;\n\t  i += 6;\n\t  if(str[i] == '-'){\n\t    minus = true;\n\t    i++;\n\t    a = str[i] - '0';\n\t    a *= -1;\n\t  }\n\t  else a = str[i] - '0';\n\t}\n\telse if(!f2 && str[i] != ' '){\n\t  a *= 10;\n\t  if(minus) a -= str[i] - '0';\n\t  else a += str[i] - '0';\n\t}\n\telse if(!f2 && str[i] == ' ') f2 = true;\n\telse str3 += str[i];\n      }\n      if(m[str2] == 0) m[str2] = ++nn;\n      if(m[str3] == 0) m[str3] = ++nn;\n      //cout << m[str2] << \" \" << m[str3] << \" \" << a << endl;\n      v[m[str2]][m[str3]] = a;\n      v[m[str3]][m[str2]] = -1 * a;\n    }\n\n    bool ans = true;\n\n    for(int k=1;k<v.size();k++){\n      for(int i=1;i<v.size();i++){\n\tfor(int j=1;j<v.size();j++){\n\t  if(i != j && v[i][j] == INF && v[i][k] < INF && v[k][j] < INF) v[i][j] = v[i][k] + v[k][j];\n\t}\n      }\n    }\n\n    for(int k=1;k<v.size();k++){\n      for(int i=1;i<v.size();i++){\n\tfor(int j=1;j<v.size();j++){\n\t  if(v[i][j] >= INF || v[i][k] >= INF || v[k][j] >= INF) continue;\n\t  if(v[i][j] != v[i][k] + v[k][j]){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    /*for(int i=1;i<v.size();i++){\n      for(int j=1;j<v.size();j++){\n\tif(v[i][j] == INF) cout << \" I \";\n\telse printf(\"%2d \",v[i][j]);\n      }\n      cout << endl;\n      }*/\n\n    if(ans) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tstring lhs;\n\tstring rhs;\n\tint power;\n\tData(string _l,string _r, int _p){\n\t\tlhs = _l;\n\t\trhs = _r;\n\t\tpower = _p;\n\t}\n};\n\nmap<string,int> gUnit;\nint gCount = 0;\n\nint dp[101][101];\n\nint unit2num(string str){\n\tif(gUnit.find(str) == gUnit.end()){\n\t\tgUnit[str]=gCount++;\n\t}\n\n\treturn gUnit[str];\n}\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tgCount = 0;\n\t\tgUnit.clear();\n\t\tmemset(dp,0x3f,sizeof(dp));\n\n\t\tvector<Data> relations;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint num;\n\t\t\tstring lhs;\n\t\t\tstring eq;\n\t\t\tstring rhs;\n\t\t\tstring tmp;\n\n\t\t\tcin >> num >> lhs >> eq >> tmp >> rhs;\n\t\t\tint base,pow;\n\t\t\tsscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n\t\t\trelations.push_back(Data(lhs,rhs,pow));\n\t\t}\n\n\t\tfor(int i=0;i<relations.size();i++){\n\t\t\tdp[unit2num(relations[i].lhs)][unit2num(relations[i].rhs)] = -relations[i].power;\n\t\t\tdp[unit2num(relations[i].rhs)][unit2num(relations[i].lhs)] = relations[i].power;\n\t\t}\n\n\t\tfor(int k=0;k<gCount;k++){\n\t\t\tfor(int i=0;i<gCount;i++){\n\t\t\t\tfor(int j=0;j<gCount;j++){\n\t\t\t\t\tdp[i][j] = min(dp[i][k] + dp[k][j],dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool isok = true;\n\t\tfor(int i=0;i<gCount;i++){\n\t\t\tif(dp[i][i] != 0) isok = false;\n\t\t}\n\n\t\tprintf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<map>\n#include<string>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint main(){\n  int n;\n  while(cin>>n, n){\n    int m = 0;\n    vector<vector<int> > g(200, vector<int>(200, INT_MAX));\n    map<string,int> type;\n    bool ans = true;\n\n    REP(i,n){\n      int o1, o2, o3;\n      string t1, t2;\n      char h;\n      cin>>o1>>t1>>h>>o2>>h>>o3>>t2;\n\n      //printf(\"1 %s = %d^%d %s\\n\",t1.c_str(), o2, o3, t2.c_str());\n      int ti1, ti2;\n      if(type.find(t1) == type.end()) type[t1] = m++;\n      ti1 = type[t1];\n      if(type.find(t2) == type.end()) type[t2] = m++;\n      ti2 = type[t2];\n\n      if(g[ti1][ti2] != INT_MAX && g[ti1][ti2] !=  o3) ans = false;\n      if(g[ti2][ti1] != INT_MAX && g[ti2][ti1] != -o3) ans = false;\n      \n      if(o3 > 0) g[ti1][ti2] =  o3;\n      else       g[ti2][ti1] = -o3;\n    }\n\n    if(ans) REP(k,m) REP(i,m) REP(j,m){\n\tif(g[i][k] != INT_MAX && g[k][j] != INT_MAX){\n\t  if(g[i][j] == INT_MAX){\n\t    g[i][j] = g[i][k] + g[k][j];\n\t  }else{\n\t    if(g[i][j] != g[i][k] + g[k][j])\n\t      ans = false;\n\t  }\n\t}\n    }\n\n    cout << (ans?\"Yes\":\"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#define P pair<string,int>\n#define PP pair<int,int>\nusing namespace std;\n\nint n;\nvector<PP> rl[110]; // 単位間の関係\n\n/* 単位系が誤っているとfalseを返す */\nbool dfs(int i, int sum, int initP,int depth){\n\n  if( depth==n+1 ) return false;\n\n  if( i==initP ){\n    if( sum==0 ) return true;\n    else return false;\n  }else{\n    if( sum==0 ) return false;\n  }\n\n  if( rl[i].size()<=1 )    return true;\n  depth++;\n  for( int j=0;j<(int)rl[i].size();j++ ){\n    if( rl[i][j].second>0 ) continue;\n    int nS = sum + rl[i][j].second;\n    if( dfs( rl[i][j].first,nS,initP,depth)==false )\n      return false;\n  }\n  return true;\n}\n\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int i=0;i<n;i++ ){\n    if( rl[i].size()<=1 ) continue;\n\n    for( int j=0;j<(int)rl[i].size();j++ ){\n      if( rl[i][j].second<0 ) continue;\n\n      if( dfs(rl[i][j].first,rl[i][j].second,i,0)==false )\n\treturn false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    map<string,int> units; // units[ a ] でaの配列番号が分かる\n    map<string,int>::iterator it;\n\n    for( int i=0;i<n;i++ )      rl[i].clear();\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() )\n\tunits.insert( P(a,(int)units.size()) );\n      if( (it=units.find( b ))==units.end() )\n\tunits.insert( P(b,(int)units.size()) );\n\n      int an=units[a], bn=units[b];\n      rl[ an ].push_back( PP(bn,x) );  rl[ bn ].push_back( PP(an,-x) );\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define\tmp\t\tmake_pair\n#define\tpb\t\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=1<<29;\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint unum=0;\n\t\tpair<pii,int> edge[200];\n\t\tmap<string,int> name;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint pw;\n\t\t\tchar u1[17],u2[17];\n\t\t\tscanf(\"%*d %s %*c %*d%*c%d %s\",u1,&pw,u2);\n\n\t\t\tint id1,id2;\n\t\t\tif(name.count(u1)==0)\tname[u1]=unum++;\n\t\t\tid1=name[u1];\n\t\t\tif(name.count(u2)==0)\tname[u2]=unum++;\n\t\t\tid2=name[u2];\n\n\t\t\tedge[i]=mp(mp(id1,id2),pw);\n\t\t}\n\n\t\tbool ok=true;\n\t\tstatic int wf[200][200];\n\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++)\twf[i][j]=(i==j?0:inf);\n\t\tfor(int k=0;k<n;k++){\n\t\t\tint from=edge[k].first.first,to=edge[k].first.second,dis=edge[k].second;\n\t\t\tif(wf[from][to]==inf){\n\t\t\t\twf[from][to]=dis;\n\t\t\t\twf[to][from]=dis;\n\t\t\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++){\n\t\t\t\t\tif(wf[i][from]==inf || wf[to][j]==inf)\tcontinue;\n\t\t\t\t\twf[i][j]=min(wf[i][j],wf[i][from]+dis+wf[to][j]);\n\t\t\t\t\twf[j][i]=-wf[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(wf[from][to]!=dis){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntemplate <typename T>\nstruct UF {\n  int n;\n  T d;\n  vector<int> r, p;\n  vector<T> ws;\n  UF() {}\n  UF(int sz, T d_) :\n    n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n  int find(int x) {\n    if ( x == p[x] ) {\n      return x;\n    } else {\n      int t = find(p[x]);\n      ws[x] += ws[p[x]];\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x) {\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w) {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x); y = find(y);\n    if ( x == y ) return;\n    if ( r[x] < r[y] ) swap(x, y), w = -w;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x, int y) {\n    return weight(y) - weight(x);    \n  }\n};\n\nsigned main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tUF<int> U(2*n,0);\n\t\tmap<string,int>M;\n\t\tint cnt=0,F=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a,D;\n\t\t\tstring b,c,e,d;\n\t\t\tcin>>a>>b>>c>>d>>e;\n\t\t\td=d.substr(3);\n\t\t\tstringstream SS(d);\n\t\t\tSS>>D;\n\t\t\t//cout<<D<<endl;\n\t\t\tif(!M.count(b)) M[b]=cnt++;\n\t\t\tif(!M.count(e)) M[e]=cnt++;\n\t\t\tif(U.same(M[b],M[e])&&U.diff(M[b],M[e])!=D)F=1;\n\t\t\tU.unite(M[b],M[e],D);\n\t\t\t//cout<<F<<endl;\n\t\t}\n\t\tif(F)goto L;\n\t\tcout<<\"Yes\"<<endl;\n\t\tif(0){\n\t\t\tL:;\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<set>\n#include<cstdio>\n#include<cassert>\n#define F first\n#define S second\n#define inf (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nstruct P\n{\n  string unit;\n  int mpower;\n  int upower;\n  P(string unit=\"$\",int upower=-inf,int mpower=-inf):unit(unit),upower(upower),mpower(mpower){}\n};\nvector<vector<P> > G(110);\nmap<string,int> exist;\n\nint toPower(string s)\n{\n  if(s == \"1\")return 0;\n  int pos = 0;\n  rep(i,s.size())\n    {\n      if(s[i] == '^')\n\t{\n\t  pos = i+1;\n\t  break;\n\t}\n    }\n  return (atoi)(s.substr(pos,s.size()-pos).c_str());\n}\n\nbool used[110];\nint isok;//-1 -> No, 0 => Not yet, 1 -> Ok\n\nvoid dfs(string now,string target,int power,int target_power)\n{\n  if(isok != 0)return;\n  if(now == target)\n    {\n      isok = (power == target_power?1:-1);\n      return;\n    }\n  int index = exist[now];\n  if(used[index])return;\n  used[index] = true;\n\n  rep(i,G[index].size())\n    {\n      P p = G[index][i];\n      int next_index = exist[p.unit];\n      if(used[next_index])continue;\n      dfs(p.unit,target,power+(p.mpower==0?p.upower:-p.mpower),target_power );\n    }\n}\n\nbool check(string u1,string u2,int power)\n{\n  rep(i,110)used[i] = false;\n  isok = 0;\n\n  dfs(u1,u2,0,power);\n  return isok == 1;\n}\n\nbool reachable;\n\nvoid move(int now,int target)\n{\n  if(now == target)\n    {\n      reachable = true;\n      return;\n    }\n\n  if(used[now])return;\n  used[now] = true;\n  rep(i,G[now].size())\n    {\n      if(exist.count(G[now][i].unit) == 0)continue;\n      assert(exist.count(G[now][i].unit));\n\n      move(exist[G[now][i].unit],target);\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N , N)\n    {\n      assert(N <= 100);\n      rep(i,N)G[i].clear();\n      int index = 0;\n      exist.clear();\n      bool result = true;\n      rep(i,N)\n\t{\n\t  string v1,unit1,v2,unit2,eq;\n\t  cin >> v1 >> unit1 >> eq >> v2 >> unit2;\n\n\t  assert(unit1 != unit2);\n\t  if(!result)continue;\n\t  //cout << toPower(v1) << \" \" << unit1 << \" = \"<< toPower(v2) << \" \" << unit2 << endl;\n\t  if(exist.count(unit1) && exist.count(unit2))\n\t    {\n\t      rep(i,N)used[i] = false;\n\t      reachable = false;\n\t      move(exist[unit1],exist[unit2]);\n\t      if(reachable)\n\t\t{\n\t\t  int p1 = toPower(v1);\n\t\t  int p2 = toPower(v2);\n\t\t  result = check(unit1,unit2,p2);\n\t\t  //cout << \"result = \" << result << endl;\n\t\t}\n\t      else\n\t\t{\n\t\t  goto Insert;\n\t\t}\n\t      continue;\n\t    }\n\n\t  //cout << \"not exists\" << endl;\n\t  if(!exist.count(unit1))exist[unit1] = index++;\n\t  if(!exist.count(unit2))exist[unit2] = index++;\n\tInsert:;\n\t  int index1 = exist[unit1];\n\t  int index2 = exist[unit2];\n\t  G[index1].push_back(P(unit2,toPower(v2),toPower(v1)));\n\t  G[index2].push_back(P(unit1,toPower(v1),toPower(v2)));\n\t}\n      cout << (result?\"Yes\":\"No\") << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n#include<map>\nusing namespace std;\n\n#define INF 100000000\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\n\nint stoi(string s){\n  stringstream ss(s);\n  int res;\n  ss >> res;\n  return res;\n}\n\nP par[210];\nint rank[210];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n\nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n\nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n\nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n  \n  if(same(x.fs,y.fs)){\n    //cout << x.sc << \" \" << y.sc << \" \" << cost << endl;\n    if( (x.sc || y.sc) && x.sc - y.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,-par[b].sc+cost);\n    }else{\n      par[y.fs] = P(x.fs,par[a].sc-cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nint g[210][210];\nint n,c[110],f,t;\nstring a[110],b[110],tmp;\nmap<string,int> m;\n\nint main(){\n  int i;\n  while(cin >> n,n){\n    m.clear();\n    for(i=0;i<n;i++){\n      cin >> tmp; cin >> a[i]; cin >> tmp;\n      cin >> tmp; c[i] = stoi(tmp.substr(3,tmp.size()-3));\n      cin >> b[i];\n    }\n    for(i=0;i<n;i++){\n      if(m.find(a[i])==m.end())m[a[i]] = m.size()-1;\n      if(m.find(b[i])==m.end())m[b[i]] = m.size()-1;\n    }\n    init(m.size());\n    for(i=0;i<n;i++){\n      if(!unite(m[a[i]],m[b[i]],c[i])){\n\tcout << \"No\" << endl;\n\tbreak;\n      }\n      /*\n      for(int j=0;j<m.size();j++)cout << par[j].fs << \" \" << par[j].sc << endl;\n      cout << endl;\n      */\n    }\n    if(i==n)cout << \"Yes\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nmap<string, vector<pair<string,int> > >m; //no direction graph\n\nchar b1[17],b2[17];\nvoid main2(int n){\n\tm.clear();\n\tstring s1,s2;\n\tfor(;n;n--){\n\t\tint d;\n\t\tscanf(\" 1 %s = 10^%d %s\",b1,&d,b2);\n\t\ts1=b1,s2=b2;\n\t\tm[s1].push_back(make_pair(s2,d));\n\t\tm[s2].push_back(make_pair(s1,-d));\n\t}\n\tvector<pair<string,int> >st={{s1,0}};\n\tmap<string,int>memo={{s1,0}};\n\tfor(;!st.empty();){\n\t\tauto p=*st.rbegin();st.pop_back();\n\t\tstring cur=p.first;int d=p.second;\n\t\tfor(auto &e:m[cur]){\n\t\t\tif(memo.find(e.first)==memo.end()){\n\t\t\t\tst.emplace_back(e.first,d+e.second);\n\t\t\t\tmemo[e.first]=d+e.second;\n\t\t\t}else if(memo[e.first]!=d+e.second){\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\nint main(){int n;for(;scanf(\"%d\",&n),n;)main2(n);}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int nn = 0;\n    string str;\n    getline(cin,str);\n    map<string,int> m;\n    vector<vector<int> > v;\n    v.assign(n, vector<int>(n,INF));\n    while(n--){\n      string str2,str3;\n      bool f = false, f2 = false, minus = false;\n      int a = 0;\n      getline(cin,str);\n      for(int i=2;i<str.size();i++){\n\tif(!f && !f2 && str[i] != ' ') str2 += str[i];\n\telse if(!f && !f2 && str[i] == ' '){\n\t  f = true;\n\t  i += 6;\n\t  if(str[i] == '-'){\n\t    minus = true;\n\t    i++;\n\t    a = str[i] - '0';\n\t    a *= -1;\n\t  }\n\t  else a = str[i] - '0';\n\t}\n\telse if(!f2 && str[i] != ' '){\n\t  a *= 10;\n\t  if(minus) a -= str[i] - '0';\n\t  else a += str[i] - '0';\n\t}\n\telse if(!f2 && str[i] == ' ') f2 = true;\n\telse str3 += str[i];\n      }\n      if(m.find(str2) == m.end()) m[str2] = nn++;\n      if(m.find(str3) == m.end()) m[str3] = nn++;\n      //cout << m[str2] << \" \" << m[str3] << \" \" << a << endl;\n      v[m[str2]][m[str3]] = a;\n      v[m[str3]][m[str2]] = -1 * a;\n    }\n\n    bool ans = true;\n\n    for(int k=0;k<v.size();k++){\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v.size();j++){\n\t  if(i != j && v[i][j] == INF && v[i][k] < INF && v[k][j] < INF) v[i][j] = v[i][k] + v[k][j];\n\t}\n      }\n    }\n\n    for(int k=0;k<v.size();k++){\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v.size();j++){\n\t  if(v[i][j] >= INF || v[i][k] >= INF || v[k][j] >= INF) continue;\n\t  if(v[i][j] != v[i][k] + v[k][j]){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    /*for(int i=1;i<v.size();i++){\n      for(int j=1;j<v.size();j++){\n\tif(v[i][j] == INF) cout << \" I \";\n\telse printf(\"%2d \",v[i][j]);\n      }\n      cout << endl;\n      }*/\n\n    if(ans) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\n\n\nconst int INF = 100000000;\nconst long long INFL = 100000000000000LL;\n\nint n;\nmap<string, int> stoi;\nbool visited[200][200];\nlong long cost[200];\nint G[200][200];\n\nint conv(string& str){\n  return atoi(str.substr(3).c_str());\n}\n\nbool dfs(int p, long long cos){\n  if(cost[p] == INFL) cost[p] = cos;\n  if(cost[p] != cos) return false;\n  for(int i=0;i<n;i++){\n    if(i == p) continue;\n    if(visited[p][i]) continue;\n    if(G[p][i] == INF) continue;\n    visited[p][i] = true;\n    if(!dfs(i, cos + G[p][i])) return false;\n  }\n  return true;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(G[0], G[200], INF);\n    stoi.clear();\n    int size = 0;\n    bool ans = true;\n    for(int i=0;i<n;i++){\n      string a, b;\n      int in;\n      cin >> a;\n      cin >> a;\n      cin >> b;\n      cin >> b;\n      in = conv(b);\n      cin >> b;\n      int c, d;\n      if(stoi.find(a) == stoi.end()){\n\tstoi[a] = size++;\n      }\n      if(stoi.find(b) == stoi.end()){\n\tstoi[b] = size++;\n      }\n      if(c == d && in != 0) ans = false;\n      c = stoi[a];\n      d = stoi[b];\n      G[c][d] = in;\n      G[d][c] = -in;\n    }\n    if(ans){\n      for(int i=0;i<n;i++){\n\tfill(visited[0], visited[200], false);\n\tfill(cost, cost+200, INFL);\n\tif(!dfs(i, 0LL)){\n\t  ans = false;\n\t  break;\n\t}\n      }\n    }\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\nconst int INF=1000000000;\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nbool warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                int prv=d[j][k];\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n                if(prv!=INF&&d[j][i]+d[i][k]<INF){\n                    if(prv!=d[j][i]+d[i][k]){\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                for(int k = 0; k < MAX_V; k++){\n                    if(j==k)\n                        d[j][k]=0;\n                    else\n                        d[j][k]=INF;\n                }\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            if(cost<0){\n                d[dict[a]][dict[b]]=-cost;\n            }\n            else{\n                d[dict[b]][dict[a]]=cost;\n            }\n        }\n        V=idx;\n        bool f=warshall_floyd();\n        //bool f=false;\n        //for(int i = 0; i < idx; i++){\n        //    for(int j = 0; j < idx; j++){\n        //        // kðoRµÄS[·é\n        //        int path=d[0][i][j];\n        //        if(path==INF)\n        //            continue;\n        //        for(int k = 1; k < idx; k++){\n        //            if(d[k][i][j]==INF)\n        //                continue;\n        //            if(path!=d[k][i][j]){\n        //                f=true;\n        //                break;\n        //            }\n        //        }\n        //        if(f)\n        //            break;\n        //    }\n        //    if(f)\n        //        break;\n        //}\n        if(!f)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\nconst int INF = 1 << 28;\n\nint n; \nvector<Pr> g[200];\nmap<string, int> mp;\nint dist[200];\n\nbool check(int v, int p)\n{\n\tif (dist[v] != INF) return dist[v] == p;\n\tdist[v] = p;\n\t\n\tfor (auto &e : g[v]){\n\t\tint to = e.first;\n\t\tint cost = e.second;\n\t\tif (!check(to, p + cost)) return false;\n\t}\n\t\n\treturn true;\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &n), n){\n\t\tfill_n(g, 200, vector<Pr>());\n\t\tmp.clear();\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tvector<string> v;\n\t\t\tfor (int j = 0; j < 5; j++){\n\t\t\t\tstring str;\n\t\t\t\tcin >> str;\n\t\t\t\tv.push_back(str);\n\t\t\t}\n\t\t\tstring a = v[1];\n\t\t\tstring b = v[4];\n\t\t\tint p = atoi(v[3].c_str() + 3);\n\t\t\tint f, t;\n\t\t\tif (mp.count(a)) f = mp[a];\n\t\t\telse f = mp[a] = mp.size() - 1;\n\t\t\tif (mp.count(b)) t = mp[b];\n\t\t\telse t = mp[b] = mp.size() - 1;\n\t\t\tg[f].push_back(Pr(t, p));\n\t\t\tg[t].push_back(Pr(f, -p));\n\t\t}\n\t\t\n\t\tfill_n(dist, mp.size(), INF);\n\t\tbool res = true;\n\t\tfor (int i = 0; i < mp.size(); i++){\n\t\t\tif (dist[i] == INF){\n\t\t\t\tres &= check(i, 0);\n\t\t\t}\n\t\t}\n\t\tputs(res ? \"Yes\" : \"No\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nstruct edge{\n\tint from;\n\tint cost;\n\tint to;\n};\n\nmap<string, int> mp;\nint d[1000];\nvector<edge> es;\n\nint main(){\n\tint n;\n\tint a, b, size;\n\tstring t1, t2, t3, t4;\n\tedge e1, e2;\n\twhile(cin >> n && n){\n\t\tint count = 1;\n\t\tmp.clear();\n\t\tes.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> a >> t1 >> t2 >> t3 >> t4;\n\t\t\tstring s(t3.begin() + 3, t3.end());\n\t\t\tstringstream ss;\n\t\t\tss << s;\n\t\t\tss >> b;\n\t\t\tif(mp[t1] == 0) mp[t1] = count++;\n\t\t\tif(mp[t4] == 0) mp[t4] = count++;\n\t\t\te1.from = mp[t4];\n\t\t\te1.cost = b;\n\t\t\te1.to = mp[t1];\n\t\t\tes.push_back(e1);\n\t\t\te2.from = mp[t1];\n\t\t\te2.cost = -b;\n\t\t\te2.to = mp[t4];\n\t\t\tes.push_back(e2);\n\t\t}\n\t\tsize = es.size();\n\t\tfill(d, d + 1000, 0);\n\t\tbool update = true;\n\t\tfor(int i = 0; i <= 2 * n; i++){\n\t\t\tupdate = false;\n\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\tedge e = es[j];\n\t\t\t\tint s = e.from, t = e.to;\n\t\t\t\tif(d[t] > d[s] + e.cost){\n\t\t\t\t\td[t] = d[s] + e.cost;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\t\tif(update) cout << \"No\" << endl;\n\t\telse cout << \"Yes\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n \nclass Data{\npublic:\n  string lhs;\n  string rhs;\n  int power;\n  Data(string _l,string _r, int _p){\n    lhs = _l;\n    rhs = _r;\n    power = _p;\n  }\n};\n \nmap<string,int> gUnit;\nint gCount = 0;\n \nint dp[101][101];\n \nint unit2num(string str){\n  if(gUnit.find(str) == gUnit.end()){\n    gUnit[str]=gCount++;\n  }\n \n  return gUnit[str];\n}\n \nint main(){\n  int n;\n \n  while(~scanf(\"%d\",&n)){\n    if(n==0) break;\n    gCount = 0;\n    gUnit.clear();\n    memset(dp,0x3f,sizeof(dp));\n \n    vector<Data> relations;\n    for(int i=0;i<n;i++){\n      int num;\n      string lhs;\n      string eq;\n      string rhs;\n      string tmp;\n \n      cin >> num >> lhs >> eq >> tmp >> rhs;\n      int base,pow;\n      sscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n      relations.push_back(Data(lhs,rhs,pow));\n    }\n \n    for(int i=0;i<relations.size();i++){\n      dp[unit2num(relations[i].lhs)][unit2num(relations[i].rhs)] = -relations[i].power;\n      dp[unit2num(relations[i].rhs)][unit2num(relations[i].lhs)] = relations[i].power;\n    }\n \n    for(int k=0;k<gCount;k++){\n      for(int i=0;i<gCount;i++){\n\tfor(int j=0;j<gCount;j++){\n\t  dp[i][j] = min(dp[i][k] + dp[k][j],dp[i][j]);\n\t}\n      }\n    }\n \n    bool isok = true;\n    for(int i=0;i<gCount;i++){\n      if(dp[i][i] != 0) isok = false;\n    }\n    printf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<map>\n#include<string>\nusing namespace std;\n\n#define INF 100000000\n\nint main()\n{\t\n\tint n;\n\tstring temp;\n\tint a;\n\tint cost[201][201],minicost[201];\n\twhile(cin>>n && n!=0){\n\n\t\tfor(int i=0;i<=200;i++){\n\t\t\tfor(int j=0;j<=200;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t\tminicost[i]=INF;\n\t\t}\n\n\n\t\tmap<string,int> Idx;\n\t\tint num=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a;//1\n\t\t\tstring s,t,p; cin>>s>>temp>>p>>t;\n\t\t\tif(!Idx.count(s)){Idx[s]=num++;}\n\t\t\tif(!Idx.count(t)){Idx[t]=num++;}\n\t\t\tstd::istringstream is(p);\n\t\t\tint k;\n\t\t\tchar taa;\n\t\t\tis>>a>>taa>>k;\n\t\t\tcost[Idx[s]][Idx[t]]=k;\n\t\t\tcost[Idx[t]][Idx[s]]=-k;\n\t\t}\n\n\t\tint count=0;\n\t\twhile(true){\n\t\t\tbool update=false;\n\t\t\tfor(int i=0;i<num;i++){\n\t\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\t\tif(cost[i][j]<INF){\n\t\t\t\t\t\tif(minicost[j]>minicost[i]+cost[i][j]){\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\tminicost[j]=minicost[i]+cost[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update){cout<<\"Yes\"<<endl;break;}\n\t\t\tcount++;\n\t\t\tif(count>n+1){cout<<\"No\"<<endl;break;}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<map>\n#include<string>\nusing namespace std;\n\n#define INF 100000\n\nint main()\n{\t\n\tint n;\n\tstring temp;\n\tint a;\n\tint cost[201][201],minicost[201];\n\twhile(cin>>n && n!=0){\n\n\t\tfor(int i=0;i<=200;i++){\n\t\t\tfor(int j=0;j<=200;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t\tminicost[i]=INF;\n\t\t}\n\n\n\t\tmap<string,int> Idx;\n\t\tint num=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a;//1\n\t\t\tstring s,t,p; cin>>s>>temp>>p>>t;\n\t\t\tif(!Idx.count(s)){Idx[s]=num++;}\n\t\t\tif(!Idx.count(t)){Idx[t]=num++;}\n\t\t\tstd::istringstream is(p);\n\t\t\tint k;\n\t\t\tchar taa;\n\t\t\tis>>a>>taa>>k;\n\t\t\tcost[Idx[s]][Idx[t]]=k;\n\t\t\tcost[Idx[t]][Idx[s]]=-k;\n\t\t}\n\n\t\tint count=0;\n\t\twhile(true){\n\t\t\tbool update=false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(cost[i][j]<INF){\n\t\t\t\t\t\tif(minicost[j]>minicost[i]+cost[i][j]){\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\tminicost[j]=minicost[i]+cost[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update){cout<<\"Yes\"<<endl;break;}\n\t\t\tcount++;\n\t\t\tif(count>n+1){cout<<\"No\"<<endl;break;}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#define P pair<string,int>\n#define PP pair<int,int>\nusing namespace std;\n\nint n;\nvector<PP> rl[110]; // 単位間の関係\n\nmap<string,int> units; // units[ a ] でaの配列番号が分かる\nmap<string,int>::iterator it;\nset<int> st;\nset<int> en;\n\n/* 単位系が誤っているとfalseを返す */\nbool dfs(int i, int sum, int initP,int depth){\n  if( depth > n  ) return true;\n\n  if( i==initP ){\n    if( sum==0 ) return true;\n    else return false;\n  }else{\n    if( sum==0 ) return false;\n  }\n\n  if( rl[i].size()<=1 )    return true;\n  depth++;\n  for( int j=0;j<(int)rl[i].size();j++ ){\n    //    if( rl[i][j].second>0 )      continue;\n    if( st.find( rl[i][j].first )!= st.end() )\n       continue; // 既に通ったノード\n\n    st.insert( rl[i][j].first );\n    int nS = sum + rl[i][j].second;\n    if( dfs( rl[i][j].first,nS,initP,depth)==false )\n      return false;\n    st.erase( rl[i][j].first );\n  }\n  return true;\n}\n\n\nbool check(){ /* 誤った規則があればfalse */\n\n  en.clear();\n  for( int i=0;i<n;i++ ){\n    if( rl[i].size()<=1 ) continue;\n\n    for( int j=0;j<(int)rl[i].size();j++ ){\n      if( rl[i][j].first<0 ) continue;\n      if( en.find( rl[i][j].first )!=en.end() )\n\tcontinue;\n\n      st.clear();\n      if( dfs(rl[i][j].first,rl[i][j].second,i,0)==false )\n\treturn false;\n      \n      set<int>::iterator itr = st.begin();\n      while( itr != st.end() ){\n\ten.insert( *itr ); ++itr;\n      }\n    }\n  }\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    units.clear();\n    for( int i=0;i<n;i++ )      rl[i].clear();\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() )\n\tunits.insert( P(a,(int)units.size()) );\n      if( (it=units.find( b ))==units.end() )\n\tunits.insert( P(b,(int)units.size()) );\n\n      int an=units[a], bn=units[b];\n      rl[ an ].push_back( PP(bn,x) );  rl[ bn ].push_back( PP(an,-x) );\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tstring lhs;\n\tstring rhs;\n\tint power;\n\tData(string _l,string _r, int _p){\n\t\tlhs = _l;\n\t\trhs = _r;\n\t\tpower = _p;\n\t}\n};\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Data> relations;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint num;\n\t\t\tstring lhs;\n\t\t\tstring eq;\n\t\t\tstring rhs;\n\t\t\tstring tmp;\n\n\t\t\tcin >> num >> lhs >> eq >> tmp >> rhs;\n\t\t\tint base,pow;\n\t\t\tsscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n\t\t\trelations.push_back(Data(lhs,rhs,pow));\n\t\t}\n\n\t\tmap<string,vector<int> > vals;\n\n\t\tbool isok = true;\n\t\tvals[relations[0].rhs].push_back(0);\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<vals[relations[j].rhs].size();k++){\n\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\tvals[relations[j].lhs].push_back(relations[j].power + vals[relations[j].rhs][k]);\n\t\t\t}\n\t\t\tsort(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\tvector<int>::iterator it = unique(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\tvals[relations[j].lhs].resize( it - vals[relations[j].lhs].begin() );\n\n\t\t\tif(vals[relations[j].lhs].size() > 1) isok = false;\n\t\t}\n\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<vals[relations[j].lhs].size();k++){\n\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\tvals[relations[j].rhs].push_back(-relations[j].power + vals[relations[j].lhs][k]);\n\t\t\t}\n\t\t\tsort(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\tvector<int>::iterator it = unique(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\tvals[relations[j].rhs].resize( it - vals[relations[j].rhs].begin() );\n\n\t\t\tif(vals[relations[j].rhs].size() > 1) isok = false;\n\t\t}\n\t\tprintf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nmap<string, vector<pair<string,int> > >m; //no direction graph\nvector<string> memo;\n\nint dfs(string &now, string &goal, int d){\n\tvector<pair<string,int> >v=m[now];\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i].first==goal&&v[i].second!=d)return 1;\n\t\tif(find(memo.begin(),memo.end(),v[i].first)==memo.end()){\n\t\t\tmemo.push_back(v[i].first);\n\t\t\tif(dfs(v[i].first,goal,d-v[i].second))return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar b1[17],b2[17];\nvoid main2(int n){\n\tm.clear();memo.clear();\n\tint d,e=0;\n\tfor(;n;n--){\n\t\tscanf(\" 1 %s = 10^%d %s\",b1,&d,b2);\n\t\tif(!e){\n\t\t\tstring s1=b1,s2=b2;\n\t\t\tmemo.clear();\n\t\t\tif(dfs(s1,s2,d))e=1;\n\t\t\tm[s1].push_back(make_pair(s2,d));\n\t\t\tm[s2].push_back(make_pair(s1,-d));\n\t\t}\n\t}\n\tputs(e?\"No\":\"Yes\");\n}\nmain(){int n;for(;scanf(\"%d\",&n),n;)main2(n);}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<set>\n#include<cstdio>\n#include<cassert>\n#define F first\n#define S second\n#define inf (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nstruct P\n{\n  string unit;\n  int mpower;\n  int upower;\n  P(string unit=\"$\",int upower=-inf,int mpower=-inf):unit(unit),upower(upower),mpower(mpower){}\n};\nvector<vector<P> > G(110);\nmap<string,int> exist;\n\nint toPower(string s)\n{\n  if(s == \"1\")return 0;\n  int pos = 0;\n  rep(i,s.size())\n    {\n      if(s[i] == '^')\n\t{\n\t  pos = i+1;\n\t  break;\n\t}\n    }\n  return (atoi)(s.substr(pos,s.size()-pos).c_str());\n}\n\nbool used[110];\nint isok;//-1 -> No, 0 => Not yet, 1 -> Ok\n\nvoid dfs(string now,string target,int power,int target_power)\n{\n  if(isok != 0)return;\n  if(now == target)\n    {\n      isok = (power == target_power?1:-1);\n      return;\n    }\n  int index = exist[now];\n  if(used[index])return;\n  used[index] = true;\n\n  rep(i,G[index].size())\n    {\n      P p = G[index][i];\n      int next_index = exist[p.unit];\n      if(used[next_index])continue;\n      dfs(p.unit,target,power+(p.mpower==0?p.upower:-p.mpower),target_power );\n    }\n}\n\nbool check(string u1,string u2,int power)\n{\n  rep(i,110)used[i] = false;\n  isok = 0;\n\n  dfs(u1,u2,0,power);\n  return isok == 1;\n}\n\nbool reachable;\n\nvoid move(int now,int target)\n{\n  if(now == target)\n    {\n      reachable = true;\n      return;\n    }\n\n  if(used[now])return;\n  used[now] = true;\n  rep(i,G[now].size())\n    {\n      if(exist.count(G[now][i].unit) == 0)continue;\n      assert(exist.count(G[now][i].unit));\n\n      move(exist[G[now][i].unit],target);\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N , N)\n    {\n      rep(i,N)G[i].clear();\n      int index = 0;\n      exist.clear();\n      bool result = true;\n      rep(i,N)\n\t{\n\t  string v1,unit1,v2,unit2,eq;\n\t  cin >> v1 >> unit1 >> eq >> v2 >> unit2;\n\n\t  assert(unit1 != unit2);\n\t  if(!result)continue;\n\t  //cout << toPower(v1) << \" \" << unit1 << \" = \"<< toPower(v2) << \" \" << unit2 << endl;\n\t  if(exist.count(unit1) && exist.count(unit2))\n\t    {\n\t      rep(i,N)used[i] = false;\n\t      reachable = false;\n\t      move(exist[unit1],exist[unit2]);\n\t      if(reachable)\n\t\t{\n\t\t  int p1 = toPower(v1);\n\t\t  int p2 = toPower(v2);\n\t\t  result = check(unit1,unit2,p2);\n\t\t  //cout << \"result = \" << result << endl;\n\t\t}\n\t      else\n\t\t{\n\t\t  goto Insert;\n\t\t}\n\t      continue;\n\t    }\n\n\t  //cout << \"not exists\" << endl;\n\t  if(!exist.count(unit1))exist[unit1] = index++;\n\t  if(!exist.count(unit2))exist[unit2] = index++;\n\tInsert:;\n\t  int index1 = exist[unit1];\n\t  int index2 = exist[unit2];\n\t  G[index1].push_back(P(unit2,toPower(v2),toPower(v1)));\n\t  G[index2].push_back(P(unit1,toPower(v1),toPower(v2)));\n\t}\n      cout << (result?\"Yes\":\"No\") << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#define P pair<string,int>\n#define PP pair<int,int>\nusing namespace std;\n\nint n;\nvector<PP> rl[110]; // 単位間の関係\n\nmap<string,int> units; // units[ a ] でaの配列番号が分かる\nmap<string,int>::iterator it;\nset<int> st; // これまでに通ったノード\n\nstring tab(int n){\n  string r;  for( int j=0;j<n;j++ ) r+=\"  \";\n  return r;\n}\n\n/* 単位系が誤っているとfalseを返す */\nbool dfs(int i, int sum, int initP,int depth){\n\n  /*\n  cout << tab(depth) << \" i=\" << i << \" sum=\" << sum << \" P=\"<< initP\n       << \" size=\" << st.size() <<\" [\";\n  set<int>::iterator itr = st.begin();\n  while( itr!=st.end() ){\n    cout << \" \" << *itr ; itr++;\n  }\n  cout << \" ]\" << endl;\n  */\n\n  if( i==initP ){\n    if( sum==0 ) return true;\n    else return false;\n  }\n  // else if(sum==0) return false とはならない\n\n  if( rl[i].size()<=1 )    return true;\n  depth++;\n  for( int j=0;j<(int)rl[i].size();j++ ){\n    //    if( rl[i][j].second>0 ) continue; +-+- =0の時を判定できない\n    if( st.find(rl[i][j].first)!=st.end() ){\n      //      cout << tab(depth) << \" * \" << rl[i][j].first << endl;\n      continue; // 既に通ったノード\n    }\n\n    st.insert( rl[i][j].first );\n    int nS = sum + rl[i][j].second;\n    if( dfs( rl[i][j].first,nS,initP,depth)==false )\n      return false;\n    st.erase( rl[i][j].first );\n  }\n  return true;\n}\n\n\nbool check(){ /* 誤った規則があればfalse */\n  for( int i=0;i<n;i++ ){\n    if( rl[i].size()<=1 ) continue;\n\n    for( int j=0;j<(int)rl[i].size();j++ ){\n      if( rl[i][j].second<=0 ) continue;\n\n      st.clear();\n      st.insert( rl[i][j].first );\n      if( dfs(rl[i][j].first,rl[i][j].second,i,0)==false )\n\treturn false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  string a,b;\n  int x;\n  char c;\n\n  while( cin>>n,n ){\n    units.clear();\n    for( int i=0;i<n;i++ )      rl[i].clear();\n\n    for( int i=0;i<n;i++ ){\n      cin >> x >> a >> c; // 1 [A] =\n      cin >> x >> c >> x >> b; // 10^[x] [B];\n\n      if( (it=units.find( a ))==units.end() )\n\tunits.insert( P(a,(int)units.size()) );\n      if( (it=units.find( b ))==units.end() )\n\tunits.insert( P(b,(int)units.size()) );\n\n      int an=units[a], bn=units[b];\n      rl[ an ].push_back( PP(bn,x) );  rl[ bn ].push_back( PP(an,-x) );\n    }\n\n    if( check() )\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nmap<string, vector<pair<string,int> > >m; //no direction graph\n\nchar b1[99],b2[99];\nvoid main2(int n){\n\tm.clear();\n\tstring s1,s2;\n\tfor(;n;n--){\n\t\tint d;\n\t\tscanf(\" 1 %s = 10^%d %s\",b1,&d,b2);\n\t\ts1=b1,s2=b2;\n\t\tm[s1].push_back(make_pair(s2,d));\n\t\tm[s2].push_back(make_pair(s1,-d));\n\t}\n\tfor(;!m.empty();){\n\t\tstring s=m.begin()->first;\n\t\tvector<pair<string,int> >st={{s,0}};\n\t\tmap<string,int>memo={{s,0}};\n\t\tfor(;!st.empty();){\n\t\t\tauto p=*st.rbegin();st.pop_back();\n\t\t\tstring cur=p.first;int d=p.second;\n\t\t\tmemo[cur]=d;\n\t\t\tfor(auto &e:m[cur]){\n\t\t\t\tif(memo.find(e.first)==memo.end()){\n\t\t\t\t\tst.emplace_back(e.first,d+e.second);\n\t\t\t\t}else if(memo[e.first]!=d+e.second){\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto &e:memo)m.erase(m.find(e.first));\n\t}\n\tputs(\"Yes\");\n}\nint main(){int n;for(;~scanf(\"%d\",&n)&&n;)main2(n);}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nunordered_map<string, int> converter;\nint convert(const string &s) {\n\tif(!converter.count(s)) converter.insert({s, converter.size()});\n\treturn converter[s];\n}\n\nclass union_find {\nprivate:\n\tstatic constexpr int INF = (1 << 29);\n\tvector<int> uf, pd;\npublic:\n\tunion_find(int n):uf(n, -1), pd(n, 0){}\n\n\tint find(int x) {\n\t\tif(uf[x] < 0) return x;\n\t\tconst int new_parent = find(uf[x]);\n\t\tpd[x] += pd[uf[x]];\n\t\treturn uf[x] = new_parent;\n\t}\n\n\tvoid unite(int x, int y, int d) {\n\t\tint rx = find(x), ry = find(y);\n\t\tif(rx == ry) return;\n\n\t\td += pd[x] - pd[y];\n\n\t\tif(uf[rx] > uf[ry]) swap(rx, ry), d = -d;\n\t\telse if(uf[rx] == uf[ry]) --uf[rx];\n\n\t\tpd[ry] = d;\n\t\tuf[ry] = rx;\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tint dist(int x, int y) {\n\t\tif(find(x) != find(y)) return INF;\n\t\treturn pd[y] - pd[x];\n\t}\n};\n\nbool judge(int n, const vector<int> &u, const vector<int> &v, const vector<int> &c) {\n\tunion_find uf(n);\n\tfor(unsigned i = 0; i < u.size(); ++i) {\n\t\tif(uf.same(u[i], v[i])) {\n\t\t\tif(uf.dist(u[i], v[i]) != c[i]) return false;\n\t\t}\n\t\telse {\n\t\t\tuf.unite(u[i], v[i], c[i]);\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tconverter.clear();\n\t\tvector<int> u(n), v(n), c(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint one;\n\t\t\tstring left_unit, equeal, a, right_unit;\n\t\t\tcin >> one >> left_unit >> equeal >> a >> right_unit;\n\t\t\tu[i] = convert(left_unit);\n\t\t\tv[i] = convert(right_unit);\n\t\t\tc[i] = stoi(a.substr(3));\n\t\t}\n\n\t\tcout << (judge(converter.size(), u, v, c) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 100*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n};\n\nbool relax(const vector<vector<pair<int,int> > > &graph, vector<int> &dist, int N) {\n    bool updated = false;\n    for(int i = 0; i < N; ++i) {\n        const vector<pair<int,int> > &edges = graph[i];\n        for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n            const int nc = dist[i] + it->second;\n            if(dist[it->first] > nc) {\n                dist[it->first] = nc;\n                updated = true;\n            }\n        }\n    }\n    return updated;\n}\n\nvector<vector<pair<int,int> > > v(200);\nvector<int> dist(200);\nvector<unsigned char> visited(200);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < N; ++i) {\n            v[i].clear();\n            dist[i] = INF;\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            for(string::iterator it = line.begin(); it != line.end(); ++it) {\n                if(*it == '=' || *it == '^') *it = ' ';\n            }\n            istringstream is(line);\n            string unit_left, unit_right;\n            int ord;\n            int tmp;\n            is >> tmp >> unit_left >> tmp >> ord >> unit_right;\n            //sscanf(line.c_str(), \"%*d %s = %*d^%d %s \", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        // テ」ツ?敕」ツつ古」ツ?榲」ツつ古」ツ?ョテゥツ?」テァツオツ静ヲツ按静・ツ按?」ツ?ォテ」ツ?、テ」ツ?催ッツシツ?テ」ツδ偲」ツδシテ」ツδ嘉」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ィテ」ツ?凖」ツつ凝ッツシツ?\n        fill(visited.begin(), visited.end(), 0);\n        queue<int> q;\n        for(int i = 0; i < N; ++i) {\n            if(!visited[i]) {\n                dist[i] = 0;\n                visited[i] = 1;\n                q.push(i);\n                while(!q.empty()) {\n                    int cur = q.front();\n                    q.pop();\n                    const vector<pair<int,int> > &edges = v[cur];\n                    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                        if(!visited[it->first]) {\n                            visited[it->first] = 1;\n                            q.push(it->first);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Bellman-ford\n        for(int phase = 0; phase < N; ++phase) {\n            if(!relax(v, dist, N)) break;\n        }\n        if(relax(v, dist, N)) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define\tmp\t\tmake_pair\n#define\tpb\t\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=1<<29;\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint unum=0;\n\t\tpair<pii,int> edge[100];\n\t\tmap<string,int> name;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint pw;\n\t\t\tchar u1[17],u2[17];\n\t\t\tscanf(\"%*d %s %*c %*d%*c%d %s\",u1,&pw,u2);\n\n\t\t\tint id1,id2;\n\t\t\tif(name.count(u1)==0)\tname[u1]=unum++;\n\t\t\tid1=name[u1];\n\t\t\tif(name.count(u2)==0)\tname[u2]=unum++;\n\t\t\tid2=name[u2];\n\n\t\t\tedge[i]=mp(mp(id1,id2),pw);\n\t\t}\n\n\t\tbool ok=true;\n\t\tstatic int wf[200][200];\n\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++)\twf[i][j]=(i==j?0:inf);\n\t\tfor(int k=0;k<n;k++){\n\t\t\tint from=edge[k].first.first,to=edge[k].first.second,dis=edge[k].second;\n\t\t\tif(wf[from][to]==inf){\n\t\t\t\twf[from][to]=dis;\n\t\t\t\twf[to][from]=-dis;\n\t\t\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++){\n\t\t\t\t\tif(wf[i][from]==inf || wf[to][j]==inf)\tcontinue;\n\t\t\t\t\twf[i][j]=min(wf[i][j],wf[i][from]+dis+wf[to][j]);\n\t\t\t\t\twf[j][i]=-wf[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(wf[from][to]!=dis){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\nfor(int i=0;i<unum;i++){for(int j=0;j<unum;j++)printf(\"%3d \",wf[i][j]);puts(\"\");}puts(\"\");\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint n;\nmap<string, int> stoi;\nbool visited[200][200];\nint cost[200];\nint G[200][200];\n\nint conv(string& str){\n  int res = 1;\n  for(int i=0;i<str.size();i++){\n    if(str[i] == '^'){\n      if(str[i+1] == '-'){\n\tres *= -1;\n\ti++;\n      }\n      res *= atoi(str.substr(i+1).c_str());\n    }\n  }\n  return res;\n}\n\nbool dfs(int p, int cos){\n  if(cost[p] == INF) cost[p] = cos;\n  if(cost[p] != cos) return false;\n  for(int i=0;i<n;i++){\n    if(visited[p][i]) continue;\n    if(G[p][i] == INF) continue;\n    visited[p][i] = visited[i][p] = true;\n    if(!dfs(i, cos + G[p][i])) return false;\n  }\n  return true;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(G[0], G[200], INF);\n    int size = 0;\n    for(int i=0;i<n;i++){\n      string a, b;\n      int in;\n      cin >> a;\n      cin >> a;\n      cin >> b;\n      cin >> b;\n      in = conv(b);\n      cin >> b;\n      int c, d;\n      if(stoi.find(a) == stoi.end()){\n\tstoi[a] = size++;\n      }\n      if(stoi.find(b) == stoi.end()){\n\tstoi[b] = size++;\n      }\n      c = stoi[a];\n      d = stoi[b];\n      G[c][d] = in;\n      G[d][c] = -in;\n    }\n    bool ans = true;\n    for(int i=0;i<n;i++){\n      fill(visited[0], visited[200], false);\n      fill(cost, cost+200, INF);\n      if(!dfs(i, 0)){\n\tans = false;\n\tbreak;\n      }\n    }\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint G[200][200];\nint tmp[200][200];\n\nmap<string,int> mp;\n\nint func(string s){\n  if(mp.count(s)==0){\n    int res=mp.size();\n    mp[s]=res;\n    return res;\n  }else{\n    return mp[s];\n  }\n}\n\nint getNum(string s){\n  for(int i=0;i<(int)s.size();i++)\n    if(s[i]=='^')s[i]=' ';\n  stringstream ss(s);\n  int res;\n  ss>>res;\n  ss>>res;\n  return res;\n}\n\nvoid init(){\n  fill(G[0],G[200], 1e9);\n  mp.clear();\n  for(int i=0;i<200;i++)\n    G[i][i]=0;\n}\n\nint main(){\n  int n;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    bool ans=true;\n    for(int i=0;i<n;i++){\n      string A,B,C,D,E;\n      cin>>A>>B>>C>>D>>E;\n      int a=func(B);\n      int b=func(E);\n      int c=getNum(D);\n      if(G[b][a]!=1e9&&G[b][a]!=c)ans=false;\n      G[b][a]=c;\n      G[a][b]=-c;\n    }\n    int size=mp.size();\n    for(int i=0;i<size;i++){\n      for(int j=0;j<size;j++){\n        tmp[i][j]=G[i][j];\n      }\n    }\n    \n    for(int k=0;k<size;k++)\n      for(int i=0;i<size;i++)\n        for(int j=0;j<size;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n    for(int i=0;i<size;i++)\n      for(int j=0;j<size;j++)\n        if(tmp[i][j]!=1e9 && G[i][j]!=tmp[i][j])ans=false;\n\n    cout<< (ans?\"Yes\":\"No\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <string>\n\nusing namespace std;\n\npair<int, int> par[256];\n\nvoid init(int n)\n{\n\tfor (int i = 0; i < n; i++){\n\t\tpar[i] = make_pair(i, 0);\n\t}\n}\n\npair<int, int> find(int x)\n{\n\tif (par[x].first == x) return (par[x]);\n\tpair<int, int> ret = find(par[x].first);\n\treturn (par[x] = make_pair(ret.first, par[x].second + ret.second));\n}\n\nbool same(int u, int v)\n{\n\treturn (find(u).first == find(v).first);\n}\n\nvoid merge(int u, int v, int val)\n{\n\tpair<int, int> uu = find(u);\n\tpair<int, int> vv = find(v);\n\t\n\tif (uu.first == vv.first) return;\n\t\n\tpar[uu.first] = make_pair(vv.first, vv.second + val);\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\tgetchar();\n\t\t\n\t\tmap<string, int> mp;\n\t\tinit(n);\n\t\tbool ok = true;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tchar s[1024], t[1024];\n\t\t\tint val;\n\t\t\t\n\t\t\tscanf(\"1 %s = 10^%d %s\", &s, &val, &t);\n\t\t\tgetchar();\n\t\t\t\n\t\t\tstring ss = s, st = t;\n\t\t\tif (!mp.count(ss)){\n\t\t\t\tint ct = mp.size();\n\t\t\t\tmp[ss] = ct;\n\t\t\t}\n\t\t\tif (!mp.count(st)){\n\t\t\t\tint ct = mp.size();\n\t\t\t\tmp[st] = ct;\n\t\t\t}\n\t\t\t\n\t\t\tint u = mp[ss], v = mp[st];\n\t\t\tif (same(u, v)){\n\t\t\t\tif (par[u].second - par[v].second != val) ok = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmerge(u, v, val);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n#include<map>\nusing namespace std;\n\n#define INF 100000000\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\n\nint stoi(string s){\n  stringstream ss(s);\n  int res;\n  ss >> res;\n  return res;\n}\n\nP par[210];\nint rank[210];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n\nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n\nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n\nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n  \n  if(same(x.fs,y.fs)){\n    //cout << x.sc << \" \" << y.sc << \" \" << cost << endl;\n    if(x.sc - y.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,par[b].sc+cost);\n    }else{\n      par[y.fs] = P(x.fs,par[a].sc-cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nint g[210][210];\nint n,c[110],f,t;\nstring a[110],b[110],tmp;\nmap<string,int> m;\n\nint main(){\n  int i;\n  while(cin >> n,n){\n    m.clear();\n    for(i=0;i<n;i++){\n      cin >> tmp; cin >> a[i]; cin >> tmp;\n      cin >> tmp; c[i] = stoi(tmp.substr(3,tmp.size()-3));\n      cin >> b[i];\n    }\n    for(i=0;i<n;i++){\n      if(m.find(a[i])==m.end())m[a[i]] = m.size()-1;\n      if(m.find(b[i])==m.end())m[b[i]] = m.size()-1;\n    }\n    init(m.size());\n    for(i=0;i<n;i++){\n      if(!unite(m[a[i]],m[b[i]],c[i])){\n\tcout << \"No\" << endl;\n\tbreak;\n      }\n      /*\n      for(int j=0;j<m.size();j++)cout << par[j].fs << \" \" << par[j].sc << endl;\n      cout << endl;\n      */\n    }\n    if(i==n)cout << \"Yes\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define\tmp\t\tmake_pair\n#define\tpb\t\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=1<<29;\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint unum=0;\n\t\tpair<pii,int> edge[100];\n\t\tmap<string,int> name;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint pw;\n\t\t\tchar u1[17],u2[17];\n\t\t\tscanf(\"%*d %s %*c %*d%*c%d %s\",u1,&pw,u2);\n\n\t\t\tint id1,id2;\n\t\t\tif(name.count(u1)==0)\tname[u1]=unum++;\n\t\t\tid1=name[u1];\n\t\t\tif(name.count(u2)==0)\tname[u2]=unum++;\n\t\t\tid2=name[u2];\n\n\t\t\tedge[i]=mp(mp(id1,id2),pw);\n\t\t}\n\n\t\tbool ok=true;\n\t\tstatic int wf[200][200];\n\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++)\twf[i][j]=(i==j?0:inf);\n\t\tfor(int k=0;k<n;k++){\n\t\t\tint from=edge[k].first.first,to=edge[k].first.second,dis=edge[k].second;\n\t\t\tif(wf[from][to]==inf){\n\t\t\t\twf[from][to]=dis;\n\t\t\t\twf[to][from]=-dis;\n\t\t\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++){\n\t\t\t\t\tif(wf[i][from]==inf || wf[to][j]==inf)\tcontinue;\n\t\t\t\t\twf[i][j]=min(wf[i][j],wf[i][from]+dis+wf[to][j]);\n\t\t\t\t\twf[j][i]=-wf[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(wf[from][to]!=dis){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nvector<pair<int, int> > edge[1000];\nchar str1[100];\nchar str2[100];\nint dist[1000];\n\nbool dfs(int now, int cost) {\n  if (dist[now] != 0x0f0f0f0f) {\n    return dist[now] == cost;\n  }\n  dist[now] = cost;\n  FORIT(it, edge[now]) {\n    if (!dfs(it->first, cost + it->second)) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\n  map<string, int> open;\n  int m = 0;\n  REP(i, n) {\n    int cost;\n    scanf(\" 1 %s = 10^ %d %s\", str1, &cost, str2);\n    if (!open.count((string)str1)) { open[(string)str1] = m++; }\n    if (!open.count((string)str2)) { open[(string)str2] = m++; }\n    int l = open[(string)str1];\n    int r = open[(string)str2];\n    edge[l].push_back(make_pair(r, -cost));\n    edge[r].push_back(make_pair(l, cost));\n  }\n  MEMSET(dist, 0x0f);\n  REP(i, m) {\n    if (dist[i] != 0x0f0f0f0f) { continue; }\n    if (dfs(i, 0)) {\n    } else {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\ntemplate<class T>\nclass mapping{\n  std::map<T, int> _m;\n  int _off;\npublic:\n  mapping(int offset = 0) : _m(), _off(offset) {}\n  int getId(const T &item){\n    int ret;\n\n    if(_m.count(item) == 0){\n      ret = _off + _m.size();\n      _m[item] = ret;\n    }else{\n      ret = _m[item];\n    }\n\n    return ret;\n  }\n\n  int getNextId() const { return _off + _m.size(); }\n};\n\n#define UNKNOWN (1000)\n\nint main(){\n  int n;\n  while(scanf(\"%d \", &n), n){\n    mapping<string> id;\n    vector<vector<int> > d(2 * n, vector<int>(2 * n, UNKNOWN));\n\n    REP(i,n){\n      char buff1[20];\n      char buff2[20];\n      int  dist;\n\n      scanf(\"1 %s = 10^%d %s \", buff1, &dist, buff2);\n      //printf(\"1 %s = 10^%d %s\\n\", buff1, dist, buff2);\n\n      int id1 = id.getId(buff1);\n      int id2 = id.getId(buff2);\n\n      d[id1][id2] =  dist;\n      d[id2][id1] = -dist;\n    }\n\n    const int m = id.getNextId();\n    bool ans = true;\n\n    REP(k,m) REP(i,m) REP(j,m){\n      const int &a = d[i][k];\n      const int &b = d[k][j];\n      int &c = d[i][j];\n\n      if(a != UNKNOWN && b != UNKNOWN){\n        if(c == UNKNOWN){\n          c = a + b;\n        }else{\n          if(c != a + b){\n            ans = false;\n          }\n        }\n      }\n    }\n\n  end:\n    puts(ans ? \"YES\" : \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\ninline long long tonum(string s) {long long v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string tostr(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n\n\ntemplate<class T> struct Edge {\n    int from, to;\n    T cost;\n    Edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n    friend bool operator < (const Edge &e1, const Edge &e2) {return e1.cost < e2.cost;}\n    friend bool operator > (const Edge &e1, const Edge &e2) {return e1.cost > e2.cost;}\n    friend ostream& operator << (ostream& s, const Edge<T>& E) {\n        return s << E.from << \"->\" << E.to << '(' << E.cost << ')';\n    }\n};\n\nconst int MAX_V = 300;\ntemplate<class T> struct Graph {\n    int V;\n    vector<Edge<T> > list[MAX_V];\n    \n    Graph(int n = 0) : V(n) {}\n    void init(int n = 0) {V = n; for (int i = 0; i < MAX_V; ++i) list[i].clear();}\n    void resize(int n = 0) {V = n;}\n    inline vector<Edge<T> >& operator [] (int i) {return list[i];}\n    \n    void direct(int f, int t, T c) {\n        list[f].push_back(Edge<T>(f,t,c));\n        list[t].push_back(Edge<T>(t,f,-c));\n    }\n    \n    friend ostream& operator << (ostream& s, const Graph& G) {\n        s << endl; for (int i = 0; i < G.V; ++i) {s << i << \" : \" << G.list[i] << endl;}return s;\n    }\n};\n\nGraph<int> G;\n\n\n\nint n;\nstring str;\n\nbool ok = true;\nbool seen[MAX_V];\nint dist[MAX_V];\nvoid rec(int v) {\n    seen[v] = true;\n    \n    //cout << v << \" : \" << dist[v] << endl;\n    \n    vint next;\n    for (int i = 0; i < G[v].size(); ++i) {\n        int to = G[v][i].to, c = G[v][i].cost;\n        \n        if (!seen[to]) {\n            dist[to] = dist[v] + c;\n            next.push_back(to);\n        }\n        else if ( dist[to] != dist[v] + c) ok = false;\n    }\n    for (int i = 0; i < next.size(); ++i) rec(next[i]);\n}\n\nint main() {\n    //freopen( \"/Users/macuser/Dropbox/Contest/input.in\", \"r\", stdin );\n    while (scanf(\"%d\\n\", &n) != EOF) {\n        if (n == 0) break;\n        G.init(110);\n        \n        map<string,int> ma;\n        int it = 0;\n        for (int i = 0; i < n; ++i) {\n            getline(cin, str);\n            \n            istringstream sin(str);\n            string pre, s1, equ, ratio, s2;\n            sin >> pre >> s1 >> equ >> ratio >> s2;\n            \n            //cout << pre << \", \" << s1 << \", \" << equ << \", \" << ratio << \", \" << s2 << endl;\n            \n            ratio = ratio.substr(3);\n            int num = tonum(ratio);\n            \n            //COUT(num);\n            \n            if (!ma.count(s1)) ma[s1] = it++;\n            if (!ma.count(s2)) ma[s2] = it++;\n            \n            G.direct(ma[s1], ma[s2], num);\n        }\n        G.resize(it);\n        \n        //COUT(G);\n\n        ok = true;\n        memset(seen, 0, sizeof(seen));\n        memset(dist, -1, sizeof(dist));\n        for (int i = 0; i < it; ++i) {\n            if (!seen[i]) {\n                dist[i] = 0;\n                rec(i);\n            }\n        }\n        if (ok) puts(\"Yes\");\n        else puts(\"No\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 100*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n};\n\nbool relax(const vector<vector<pair<int,int> > > &graph, vector<int> &dist) {\n    const int N = graph.size();\n    bool updated = false;\n    for(int i = 0; i < N; ++i) {\n        const vector<pair<int,int> > &edges = graph[i];\n        for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n            const int nc = dist[i] + it->second;\n            if(dist[it->first] > nc) {\n                dist[it->first] = nc;\n                updated = true;\n            }\n        }\n    }\n    return updated;\n}\n\nvector<vector<pair<int,int> > > v(100, vector<pair<int,int> >(100));\nvector<int> dist(100);\nvector<unsigned char> visited(100);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < N; ++i) {\n            v[i].clear();\n            dist[i] = INF;\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            char unit_left[32], unit_right[32];\n            int ord;\n            sscanf(line.c_str(), \"%*d %s = %*d^%d %s\", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        // テ」ツ?敕」ツつ古」ツ?榲」ツつ古」ツ?ョテゥツ?」テァツオツ静ヲツ按静・ツ按?」ツ?ォテ」ツ?、テ」ツ?催ッツシツ?テ」ツδ偲」ツδシテ」ツδ嘉」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ィテ」ツ?凖」ツつ凝ッツシツ?\n        fill(visited.begin(), visited.end(), false);\n        queue<int> q;\n        for(int i = 0; i < N; ++i) {\n            if(!visited[i]) {\n                dist[i] = 0;\n                visited[i] = true;\n                q.push(i);\n                while(!q.empty()) {\n                    int cur = q.front();\n                    q.pop();\n                    const vector<pair<int,int> > &edges = v[cur];\n                    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n                        if(!visited[it->first]) {\n                            visited[it->first] = true;\n                            q.push(it->first);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Bellman-ford\n        for(int phase = 0; phase < N; ++phase) {\n            if(!relax(v, dist)) break;\n        }\n        if(relax(v, dist)) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tstring lhs;\n\tstring rhs;\n\tint power;\n\tData(string _l,string _r, int _p){\n\t\tlhs = _l;\n\t\trhs = _r;\n\t\tpower = _p;\n\t}\n};\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Data> relations;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint num;\n\t\t\tstring lhs;\n\t\t\tstring eq;\n\t\t\tstring rhs;\n\t\t\tstring tmp;\n\n\t\t\tcin >> num >> lhs >> eq >> tmp >> rhs;\n\t\t\tint base,pow;\n\t\t\tsscanf(tmp.c_str(),\"%d^%d\",&base,&pow);\n\t\t\trelations.push_back(Data(lhs,rhs,pow));\n\t\t}\n\n\t\tmap<string,vector<int> > vals;\n\n\t\tbool isok = true;\n\t\tvals[relations[0].rhs].push_back(0);\n\n\t\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<vals[relations[j].rhs].size();k++){\n\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\tvals[relations[j].lhs].push_back(relations[j].power + vals[relations[j].rhs][k]);\n\t\t\t}\n\t\t\tsort(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\tvector<int>::iterator it = unique(vals[relations[j].lhs].begin(),vals[relations[j].lhs].end());\n\t\t\tvals[relations[j].lhs].resize( it - vals[relations[j].lhs].begin() );\n\n\t\t\tif(vals[relations[j].lhs].size() > 1) isok = false;\n\t\t}\n\n\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<vals[relations[j].lhs].size();k++){\n\t\t\t\t//1 kilobyte = 10^3 byte\n\t\t\t\tvals[relations[j].rhs].push_back(-relations[j].power + vals[relations[j].lhs][k]);\n\t\t\t}\n\t\t\tsort(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\tvector<int>::iterator it = unique(vals[relations[j].rhs].begin(),vals[relations[j].rhs].end());\n\t\t\tvals[relations[j].rhs].resize( it - vals[relations[j].rhs].begin() );\n\t\t\tif(vals[relations[j].rhs].size() > 1) isok = false;\n\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#define N 210\nusing namespace std;\n\nint n, m;\nint d[N][N];\n\nbool check(){\n\tfor (int k = 0; k < m; k++){\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++){\n\t\tif (d[i][i] < 0){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tstring a, b, s;\n\tint x;\n\tchar c;\n\n\twhile (cin >> n && n){\n\t\tm = n * 2;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\td[i][j] = 100000000;\n\t\t\t}\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tmap<string, int> units;\n\t\tm = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x >> a >> c;\n\t\t\tcin >> x >> c;\n\t\t\tcin >> x >> b;\n\n\t\t\tif (units.find(a) == units.end()){\n\t\t\t\tunits[a] = m++;\n\t\t\t}\n\t\t\tif (units.find(b) == units.end()){\n\t\t\t\tunits[b] = m++;\n\t\t\t}\n\n\t\t\tint an = units[a], bn = units[b];\n\n\t\t\td[an][bn] = -x;\n\t\t\td[bn][an] = x;\n\t\t}\n\n\t\tif (check()){\n\t\t\tcout << \"Yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"No\" << endl; \n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<sstream>\n#include<map>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint x[222];\nstring a[222], b[222];\nmap<string, int> mp;\nint mem[222];\n\nint main() {\n  int n;\n  string buf;\n  stringstream ss;\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n    rep (i, n) {\n      cin >> buf;\n      cin >> a[i];\n      cin >> buf;\n      cin >> buf;\n      ss.clear();\n      ss << buf.substr(3);\n      ss >> x[i];\n      cin >> b[i];\n      a[n + i] = b[i];\n      b[n + i] = a[i];\n      x[n + i] = -x[i];\n    }\n    mp.clear();\n    rep (i, 2 * n) mem[i] = 100000000;\n    bool ok = true;\n    int count = 0;\n    rep (i, 2 * n) {\n      if (mp.count(a[i]) == 0) {\n\tqueue<pair<string, int> > que;\n\tque.push(make_pair(a[i], 0));\n\twhile (!que.empty()) {\n\t  pair<string, int> now = que.front();\n\t  //cout << now.first << \" \" << now.second << endl;\n\t  que.pop();\n\t  if (mp.count(now.first)) {\n\t    if (mem[mp[now.first]] != now.second) ok = false;\n\t  } else {\n\t    mp[now.first] = count;\n\t    mem[count] = now.second;\n\t    ++count;\n\t    rep (i, 2 * n) if (a[i] == now.first) que.push(make_pair(b[i], now.second + x[i]));\n\t  }\n\t}\n      }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nmap<string, vector<pair<string,int> > >m; //no direction graph\nvector<string> memo;\n\nint dfs(string &now, string &goal, int d){\n\tvector<pair<string,int> >v=m[now];\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i].first==goal&&v[i].second!=d)return 1;\n\t\tif(find(memo.begin(),memo.end(),v[i].first)==memo.end()){\n\t\t\tmemo.push_back(v[i].first);\n\t\t\tif(dfs(v[i].first,goal,d-v[i].second))return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar b1[17],b2[17];\nvoid main2(int n){\n\tint d,e=0;\n\tfor(;n;n--){\n\t\tscanf(\" 1 %s = 10^%d %s\",b1,&d,b2);\n\t\tstring s1=b1,s2=b2;\n\t\tmemo.clear();\n\t\tif(dfs(s1,s2,d))e=1;\n\t\tm[s1].push_back(make_pair(s2,d));\n\t\tm[s2].push_back(make_pair(s1,-d));\n\t}\n\tputs(e?\"No\":\"Yes\");\n}\nmain(){int n;for(;scanf(\"%d\",&n),n;)main2(n);}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nmap<string,int> done;\nmap<string , vector< pair<string,int> > > graph;\nbool flag;\n\nvoid dfs(string p,int cost){\n\tif(done.find(p) != done.end()){\n\t\tif(cost != done[p]) flag = false;\n\t\treturn;\n\t}else{\n\t\tdone[p] = cost;\n\t}\n\tvector<pair<string,int> > r = graph[p];\n\tfor(int i = 0 ; i < r.size() ; i++){\n\t\tdfs( r[i].first , cost + r[i].second );\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n , n){\n\t\tvector<string> vertex;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a,b,c,d;\n\t\t\tcin >> d >> a >> d >> c >> b;\n\t\t\tc = c.substr(c.find(\"^\")+1);\n\t\t\tint cost = atoi(c.c_str());\n\t\t\tgraph[b].push_back(make_pair(a,cost));\n\t\t\tvertex.push_back(a);\n\t\t\tvertex.push_back(b);\n\t\t}\n\t\tsort(vertex.begin(),vertex.end());\n\t\tvertex.erase(unique(vertex.begin(),vertex.end()),vertex.end());\n\t\tbool ans = true;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdone.clear();\n\t\t\tflag = true;\n\t\t\tdfs(vertex[i] , 0);\n\t\t\tans &= flag;\n\t\t}\n\t\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\nusing VS = vector<string>;\nusing PII = pair<ll, ll>;\n\n// tourist set\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// tourist set end\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<'\\n'\n#define p2(s, t) cout << (s) << \" \" << (t) << '\\n'\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << '\\n'\n#define p_yes() p(\"Yes\")\n#define p_no() p(\"No\")\n#define SZ(x) ((int)(x).size())\n#define SORT(A) sort(ALL(A))\n#define RSORT(A) sort(ALL(A), greater<ll>())\n#define MP make_pair\n\nvoid no(){p_no(); exit(0);}\nvoid yes(){p_yes(); exit(0);}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\nconst double PI = acos(-1);\n\nstruct WeightedUnionFind{\n    VI par;\n    VI rank;\n    VI diff_weight;\n\n    WeightedUnionFind(ll sz){\n        init(sz);\n    }\n\n    void init(ll sz){\n        par.resize(sz);\n        rank.resize(sz);\n        diff_weight.resize(sz);\n        FOR(i, 0, sz){\n            par[i] = i;\n            rank[i] = 0;\n            diff_weight[i] = 0;\n        }\n    }\n\n    int root(ll x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            ll r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    ll weight(ll x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool is_same(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    // weight(y) - weight(x) = w となるように merge する\n    bool merge(ll x, ll y, ll w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    ll diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll N; \n    \n    while(cin>>N){\n      if(N==0) return 0;\n\n      ll id=0;\n      map<string, ll> mp;\n      WeightedUnionFind uf(200);\n      bool ok=true;\n\n      rep(i, N){\n        string a,b,c,d,e;\n        cin>>a>>b>>c>>d>>e;\n        ll dist = stoll(d.substr(3));\n\n        if(mp.count(b)==0){\n          mp[b] = id;\n          id++;\n        }\n        if(mp.count(e)==0){\n          mp[e] = id;\n          id++;\n        }\n\n        ll id0 = mp[b];\n        ll id1 = mp[e];\n\n        if(uf.is_same(id0, id1)){\n          ll diff = uf.diff(id0, id1);\n          if(diff!=dist){\n            ok = false;\n          }\n        }else{\n          uf.merge(id0, id1, dist);\n        }\n      }\n\n      if(ok){\n        p_yes();\n      }else{\n        p_no();\n      }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nstruct edge{\n\tint from;\n\tint cost;\n\tint to;\n};\n\nmap<string, int> mp;\nint d[200];\nvector<edge> es;\n\nint main(){\n\tint n;\n\tint a, b, size;\n\tstring t1, t2, t3, t4;\n\tedge e1, e2;\n\twhile(cin >> n && n){\n\t\tint count = 1;\n\t\tmp.clear();\n\t\tes.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> a >> t1 >> t2 >> t3 >> t4;\n\t\t\tstring s(t3.begin() + 3, t3.end());\n\t\t\tstringstream ss;\n\t\t\tss << s;\n\t\t\tss >> b;\n\t\t\tif(mp[t1] == 0) mp[t1] = count++;\n\t\t\tif(mp[t4] == 0) mp[t4] = count++;\n\t\t\te1.from = mp[t4];\n\t\t\te1.cost = b;\n\t\t\te1.to = mp[t1];\n\t\t\tes.push_back(e1);\n\t\t\te2.from = mp[t1];\n\t\t\te2.cost = -b;\n\t\t\te2.to = mp[t4];\n\t\t\tes.push_back(e2);\n\t\t}\n\t\tsize = es.size();\n\t\tfill(d, d + count, 0);\n\t\tbool update = true;\n\t\tfor(int i = 0; i <= 2 * n; i++){\n\t\t\tupdate = false;\n\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\tedge e = es[j];\n\t\t\t\tint s = e.from, t = e.to;\n\t\t\t\tif(d[t] > d[s] + e.cost){\n\t\t\t\t\td[t] = d[s] + e.cost;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\t\tif(update) cout << \"No\" << endl;\n\t\telse cout << \"Yes\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 200*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n\n    int size() const { return id; }\n};\n\nbool dfs(int pos, int val, const vector<vector<pair<int,int> > > &graph, vector<int> &dist) {\n    if(dist[pos] != INF) return dist[pos] == val;\n    dist[pos] = val;\n    const vector<pair<int,int> > &edges = graph[pos];\n    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n        int nc = val + it->second;\n        if(!dfs(it->first, nc, graph, dist)) return false;\n    }\n    return true;\n}\n\nvector<vector<pair<int,int> > > v(200);\nvector<int> dist(200);\nvector<unsigned char> visited(200);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < 2*N; ++i) {\n            v[i].clear();\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            for(string::iterator it = line.begin(); it != line.end(); ++it) {\n                if(*it == '=' || *it == '^') *it = ' ';\n            }\n            istringstream is(line);\n            string unit_left, unit_right;\n            int ord;\n            int tmp;\n            is >> tmp >> unit_left >> tmp >> ord >> unit_right;\n            //sscanf(line.c_str(), \"%*d %s = %*d^%d %s \", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        const int M = dict.size();\n        bool ok = true;\n        fill(dist.begin(), dist.end(), INF);\n        for(int i = 0; i < M; ++i) {\n            if(dist[i] == INF) {\n                if(!dfs(i, 0, v, dist)) {\n                    ok = false;\n                    break;\n                }\n            }\n        }\n\n        if(!ok) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef string key;\n\nchar b1[99],b2[99];\nvoid main2(int n){\n\tmap<key,vector<pair<key,long long>>>m;\n\tfor(;n;n--){\n\t\tint d;\n\t\tscanf(\" 1 %s = 10^%d %s\",b1,&d,b2);\n\t\tstring s1=b1,s2=b2;\n\t\tm[s1].emplace_back(s2,d);\n\t\tm[s2].emplace_back(s1,-d);\n\t}\n\tfor(;!m.empty();){\n\t\tauto s=m.begin()->first;\n\t\tvector<pair<key,long long> >st={{s,0}};\n\t\tmap<key,long long>memo={{s,0}};\n\t\tfor(;!st.empty();){\n\t\t\tauto p=*st.rbegin();st.pop_back();\n\t\t\tauto cur=p.first;long long d=p.second;\n\t\t\tmemo[cur]=d;\n\t\t\tfor(auto &e:m[cur]){\n\t\t\t\tif(memo.find(e.first)==memo.end()){\n\t\t\t\t\tst.emplace_back(e.first,d+e.second);\n\t\t\t\t}else if(memo[e.first]!=d+e.second){\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto &e:memo)m.erase(m.find(e.first));\n\t}\n\tputs(\"Yes\");\n}\nint main(){int n;for(;~scanf(\"%d\",&n)&&n;)main2(n);}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\n\n\nconst int INF = 100000000;\nconst long long INFL = 1000000000000LL;\n\nint n;\nmap<string, int> stoi;\nbool visited[200][200];\nlong long cost[200];\nint G[200][200];\n\nint conv(string& str){\n  return atoi(str.substr(3).c_str());\n}\n\nbool dfs(int p, long long cos){\n  if(cost[p] == INFL) cost[p] = cos;\n  if(cost[p] != cos) return false;\n  for(int i=0;i<n;i++){\n    if(i == p) continue;\n    if(visited[p][i]) continue;\n    if(G[p][i] == INF) continue;\n    visited[p][i] = true;\n    if(!dfs(i, cos + G[p][i])) return false;\n  }\n  return true;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(G[0], G[200], INF);\n    int size = 0;\n    bool ans = true;\n    for(int i=0;i<n;i++){\n      string a, b;\n      int in;\n      cin >> a;\n      cin >> a;\n      cin >> b;\n      cin >> b;\n      in = conv(b);\n      cin >> b;\n      int c, d;\n      if(stoi.find(a) == stoi.end()){\n\tstoi[a] = size++;\n      }\n      if(stoi.find(b) == stoi.end()){\n\tstoi[b] = size++;\n      }\n      if(c == d && in != 0) ans = false;\n      c = stoi[a];\n      d = stoi[b];\n      G[c][d] = in;\n      G[d][c] = -in;\n    }\n    if(ans){\n      fill(visited[0], visited[200], false);\n      fill(cost, cost+200, INFL);\n      for(int i=0;i<n;i++){\n\tif(cost[i] != INFL) continue;\n\tif(!dfs(i, 0LL)){\n\t  ans = false;\n\t  break;\n\t}\n      }\n    }\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\nconst int MAX_M = 101;\nconst int INF = 1<<24;\nmap<string, int> id;\nint G[MAX_M][MAX_M];\nint M;\n\n\nint getId(string s) {\n  if(id.find(s) == id.end()) {\n    id[s] = M++;\n  }\n  return id[s];\n}\n\nbool dfs(int p, int cost, int s, int d, bool IF = true) {\n  static bool vis[MAX_M];\n  if(IF) {\n    fill(vis, vis+M, false);\n    vis[p] =  true;\n  }\n  if(p == d) {\n    return cost == G[s][d];\n  }\n  for(int i = 0; i < M; ++i) {\n    if(vis[i]) continue;\n    if(G[p][i] == INF) continue;\n    vis[i] = true;\n    if(!dfs(i, cost+G[p][i], s,d,false)) return false;\n    vis[i] = false;\n  }\n  return true;\n}\n\nbool solve() {\n  for(int s = 0; s < M; ++s) {\n    for(int d = 0; d < M; ++d) {\n      if(s == d) continue;\n      if(G[s][d] == INF) continue;\n      if(!dfs(s,0,s,d)) return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    M = 0;\n    id.clear();\n    fill(G[0], G[MAX_M], INF);\n    for(int i = 0; i < N; ++i) {\n      string in[5];\n      for(int j = 0; j < 5; ++j) cin >> in[j];\n      int a = getId(in[1]);\n      int b = getId(in[4]);\n      int cost = atoi((in[3].substr(3)).c_str());\n      G[a][b] = cost;\n      G[b][a] = -cost;\n    }\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconstexpr int MAX = 514;\nconstexpr int INF = (1 << 25);\n\nstruct Edge {\n    int to, cost;\n    Edge() {}\n    Edge(int to, int cost) :\n        to{to}, cost{cost} {}\n};\n\nvector<Edge> G[MAX];\nint dist[MAX];\n\nbool dfs(int v, int p, int d)\n{\n    if (dist[v] != INF) {\n        return (dist[v] != d);\n    }\n    \n    dist[v] = d;\n    bool res = 0;\n    for (const auto& g : G[v]) {\n        if (g.to == p) continue;\n        res |= dfs(g.to, v, d + g.cost); \n    }\n    return res;\n}\n\nbool run()\n{\n    int N;\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        G[i].clear();\n    }\n    \n    map<string, int> s2i;\n    \n    string t, u, v;\n    for (int i = 0; i < N; i++) {\n        cin >> u >> u;\n\n        if (s2i.count(u) == 0) {\n            s2i[u] = s2i.size();\n        }\n        \n        cin >> t >> t >> v;\n        t = t.substr(3);\n\n        if (s2i.count(v) == 0) {\n            s2i[v] = s2i.size();\n        }\n        \n        int num = stoi(t);        \n        G[s2i[v]].emplace_back(s2i[u], -num);\n        G[s2i[u]].emplace_back(s2i[v], num);\n    }\n    \n    N = s2i.size();\n    bool ok = 1;\n    for (int i = 0; i < N; i++) {\n        fill(dist, dist + N, INF);\n        if (dfs(i, -1, 0)) {\n            ok = 0;\n            break;\n        }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n\nint main()\n{\n    while (run())\n        ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<climits>\n#include<string>\n#include<algorithm>\n#include<map>\nusing namespace std;\ntypedef map<string,int>M;\nconst int N=200,X=INT_MAX/6;\nint main()\n{\n\tint x[N][N],n,i,j,k,a,b;\n\tchar s[64],t[64];\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tfor(i=0;i<N;++i)for(j=0;j<N;++j)x[i][j]=X;\n\t\tM m;\n\t\tM::iterator ite;\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\" 1 %s = 10^%d %s\",s,&k,t);\n\t\t\tif((ite=m.find(s))==m.end())\n\t\t\t{\n\t\t\t\ta=m.size();\n\t\t\t\tm[s]=a;\n\t\t\t}\n\t\t\telse a=ite->second;\n\t\t\tif((ite=m.find(t))==m.end())\n\t\t\t{\n\t\t\t\tb=m.size();\n\t\t\t\tm[t]=b;\n\t\t\t}\n\t\t\telse b=ite->second;\n\t\t\tx[a][b]=k;\n\t\t\tx[b][a]=-k;\n\t\t}\n\t\tb=m.size();\n\t\tfor(k=0;k<b;++k)for(i=0;i<b;++i)for(j=0;j<b;++j)\n\t\t\tx[i][j]=min(x[i][j],x[i][k]+x[k][j]);\n\t\tfor(a=i=0;i<b;++i)if(x[i][i]<0){a=1;break;}\n\t\tputs(a?\"No\":\"Yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int nn = 0;\n    string str;\n    getline(cin,str);\n    map<string,int> m;\n    vector<vector<int> > v;\n    v.assign(n, vector<int>(n,INF));\n    while(n--){\n      string str2 = \"\", str3 = \"\";\n      bool f = false, f2 = false, minus = false;\n      int a = 0;\n      getline(cin,str);\n      for(int i=2;i<str.size();i++){\n\tif(!f && !f2 && str[i] != ' ') str2 += str[i];\n\telse if(!f && !f2 && str[i] == ' '){\n\t  f = true;\n\t  i += 6;\n\t  if(str[i] == '-'){\n\t    minus = true;\n\t    i++;\n\t    a = str[i] - '0';\n\t    a *= -1;\n\t  }\n\t  else a = str[i] - '0';\n\t}\n\telse if(!f2 && str[i] != ' '){\n\t  a *= 10;\n\t  if(minus) a -= str[i] - '0';\n\t  else a += str[i] - '0';\n\t}\n\telse if(!f2 && str[i] == ' ') f2 = true;\n\telse str3 += str[i];\n      }\n      if(m.find(str2) == m.end()) m[str2] = nn++;\n      if(m.find(str3) == m.end()) m[str3] = nn++;\n      //cout << m[str2] << \" \" << m[str3] << \" \" << a << endl;\n      v[m[str2]][m[str3]] = a;\n      v[m[str3]][m[str2]] = -1 * a;\n    }\n\n    bool ans = true;\n\n    for(int k=0;k<v.size();k++){\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v.size();j++){\n\t  if(i != j && v[i][j] == INF && v[i][k] < INF && v[k][j] < INF) v[i][j] = v[i][k] + v[k][j];\n\t}\n      }\n    }\n\n    for(int k=0;k<v.size();k++){\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v.size();j++){\n\t  if(v[i][j] >= INF || v[i][k] >= INF || v[k][j] >= INF) continue;\n\t  if(v[i][j] != v[i][k] + v[k][j]){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    /*for(int i=1;i<v.size();i++){\n      for(int j=1;j<v.size();j++){\n\tif(v[i][j] == INF) cout << \" I \";\n\telse printf(\"%2d \",v[i][j]);\n      }\n      cout << endl;\n      }*/\n\n    if(ans) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<int, int> P;\n\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    char s[100000];\n    char t[100000];\n    vector<P> edge[200];\n    map<string, int> id;\n    REP(i, N){\n      int n, v1, v2;\n      scanf(\" 1 %s = 10^%d %s \", s, &n, t);\n      string u1(s);\n      string u2(t);\n      if(!id.count(u1)){\n        int tmp = id.size();\n        id[u1] = tmp;\n      }\n      if(!id.count(u2)){\n        int tmp = id.size();\n        id[u2] = tmp;\n      }\n      v1 = id[u1], v2 = id[u2];\n      edge[v1].push_back(P(v2, n));\n      edge[v2].push_back(P(v1, -n));\n    }\n    int M = id.size();\n    vector<int> value(M);\n    fill(value.begin(), value.end(), INF);\n    bool ans = true;\n    REP(i, M)if(value[i] == INF){\n      queue<P> que;\n      que.push(P(i, 0));\n      while(!que.empty()){\n        P p = que.front(); que.pop();\n        int idx = p.first, t = p.second;\n        if(value[idx] != INF){\n          if(value[idx] != t) ans = false;\n          continue;\n        }\n        value[idx] = t;\n        REP(j, edge[idx].size()){\n          P e = edge[idx][j];\n          que.push(P(e.first, t + e.second));\n        }\n      }\n    }\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\ntemplate<class T>\nclass mapping{\n  std::map<T, int> _m;\n  int _off;\npublic:\n  mapping(int offset = 0) : _m(), _off(offset) {}\n  int getId(const T &item){\n    int ret;\n\n    if(_m.count(item) == 0){\n      ret = _off + _m.size();\n      _m[item] = ret;\n    }else{\n      ret = _m[item];\n    }\n\n    return ret;\n  }\n\n  int getNextId() const { return _off + _m.size(); }\n};\n\n#define UNKNOWN (1000)\n\nint main(){\n  int n;\n  while(scanf(\"%d \", &n), n){\n    mapping<string> id;\n    vector<vector<int> > d(n, vector<int>(n, UNKNOWN));\n\n    REP(i,n){\n      char buff1[20];\n      char buff2[20];\n      int  dist;\n\n      scanf(\"1 %s = 10^%d %s \", buff1, &dist, buff2);\n      //printf(\"1 %s = 10^%d %s\\n\", buff1, dist, buff2);\n\n      int id1 = id.getId(buff1);\n      int id2 = id.getId(buff2);\n\n      d[id1][id2] =  dist;\n      d[id2][id1] = -dist;\n    }\n\n    const int m = id.getNextId();\n    bool ans = true;\n\n    REP(k,m) REP(i,m) REP(j,m){\n      const int &a = d[i][k];\n      const int &b = d[k][j];\n      int &c = d[i][j];\n\n      if(a != UNKNOWN && b != UNKNOWN){\n        if(c == UNKNOWN){\n          c = a + b;\n        }else{\n          if(c != a + b){\n            ans = false;\n          }\n        }\n      }\n    }\n\n  end:\n    puts(ans ? \"YES\" : \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\n\nconst int MAX_V = 201;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n                d[i][j][k] = min(d[i][j][k],d[k][j][i]+d[j][i][k]);\n            }\n        }\n    }\n}\n\nconst int INF=1000000000;\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        int idx=0;\n        map<string,int> dict;\n        string s,a,b,t;\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                for(int k = 0; k < MAX_V; k++){\n                    if(j==k)\n                        d[i][j][k]=0;\n                    else\n                        d[i][j][k]=INF;\n                }\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin>>s;\n            cin>>a;\n            if(dict.find(a)==dict.end())\n                dict[a]=idx++;\n            cin>>s;\n            cin>>t;\n            int cost;\n            for(int j = 0; j < t.size(); j++){\n                if(t[j]=='^')\n                    cost=atoi(t.substr(j+1).c_str());\n            }\n            cin>>b;\n            if(dict.find(b)==dict.end())\n                dict[b]=idx++;\n            for(int j = 0; j < MAX_V; j++){\n                if(cost<0)\n                    d[j][dict[a]][dict[b]]=-cost;\n                else\n                    d[j][dict[b]][dict[a]]=cost;\n            }\n        }\n        V=idx;\n        warshall_floyd();\n        bool f=false;\n        for(int i = 0; i < idx; i++){\n            for(int j = 0; j < idx; j++){\n                // kðoRµÄS[·é\n                int path=d[0][i][j];\n                for(int k = 1; k < idx; k++){\n                    if(path!=d[k][i][j]){\n                        f=true;\n                        break;\n                    }\n                }\n                if(f)\n                    break;\n            }\n            if(f)\n                break;\n        }\n        if(f)\n            cout<<\"No\"<<endl;\n        else\n            cout<<\"Yes\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst double pi=3.141592653589793;\ntypedef unsigned long long ull;\ntypedef long double ldouble;\nconst ll INF=1e18;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main(){\n    int n, id1, id2, o, ids;\n    string str1, str2, tani1, tani2, okisa;\n    bool ans;\n    istringstream ss;\n    map<string, int> mp;\n    UnionFind<int> uf(205);\n    while(cin >> n){\n        if(n == 0) break;\n        mp.clear();\n        uf.init(205);\n        ans = true;\n        ids = 0;\n        rep(i, n){\n            cin >> str1 >> tani1 >> str2 >> okisa >> tani2;\n\n            // id設定\n            if(mp.count(tani1) == 0) {\n                mp[tani1] = ids;\n                id1 = ids;\n                ids++;\n            }\n            else id1 = mp[tani1];\n            if(mp.count(tani2) == 0) {\n                mp[tani2] = ids;\n                id2 = ids;\n                ids++;\n            }\n            else id2 = mp[tani2];\n\n            istringstream(okisa.substr(3)) >> o;\n\n            if(uf.issame(id1, id2)){\n                if(uf.diff(id1, id2) != o){\n                    ans = false;\n                    //break;\n                }\n            }\n            else {\n                uf.merge(id1, id2, o);\n            }\n\n        }\n        if(ans) puts(\"Yes\");\n        else puts(\"No\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n#include<queue>\n#include<sstream>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef pair<ll,ll> LLP;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\n#define INF 1000000000007\n#define MOD 1000000007\n#define ARRAY_MAX 3005\n\n\n//重み付きUnion-Find\nstruct Potential_UnionFind{\n\n    vector<int> par;//親\n    vector<int> rank;//高さ\n    vector<int> diff_weight;//根からの重み\n\n    void init(int n) {\n        par.resize(n);\n        rank.resize(n);\n        diff_weight.resize(n);\n        REP(i,n){\n            par[i] = i;\n            rank[i] = 0;\n            diff_weight[i] = 0;\n        }\n    }\n\n    int root(int x) {//親を探す\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    int weight(int x) {\n        //親からの重みを返す\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x,int y) {\n        //同じ親を持つ要素かどうか\n        return root(x) == root(y);\n    }\n\n    void merge(int x, int y,int w) {\n        //weight(y) - weight(x) = wとなるようにつなげる\n        int rx = root(x);\n        int ry = root(y);\n        \n        if(rank[rx] < rank[ry]){\n            diff_weight[rx] = -w - weight(x) + weight(y);\n            par[rx] = ry;\n        }else{\n            diff_weight[ry] = w + weight(x) - weight(y);\n            par[ry] = rx;\n            if(rank[rx] == rank[ry]){\n                rank[rx]++;\n            }\n        }\n    }\n\n    int diff(int x, int y) {\n        //weight(y) - weight(x)を返す\n        return weight(y) - weight(x);\n    }\n};\n\n\nint main(){\n\n    \n    int n;\n    while(cin >> n,n){\n        Potential_UnionFind tree;\n        tree.init(205);\n        bool ans = true;\n\t\tmap<string,int> mp;\n\t\tint id_number = 0;\n\n        for(int i = 0;i < n;i++){\n\n\t\t\tstring one,unit1,equal,two,unit2;\n\t\t\tcin >> one >> unit1 >> equal >> two >> unit2;\n\n\t\t\t//左辺の単位\n\t\t\tif(mp.find(unit1) == mp.end()){\n\t\t\t\tmp[unit1] = id_number;\n\t\t\t\tid_number++;\n\t\t\t}\n\n\t\t\tint id1 = mp[unit1];//単位の番号\n\n\t\t\t//右辺の単位\n\t\t\tif(mp.find(unit2) == mp.end()){\n\t\t\t\tmp[unit2] = id_number;\n\t\t\t\tid_number++;\n\t\t\t}\n\n\t\t\tint id2 = mp[unit2];//単位の番号\n\n\t\t\tstring ratio = two.substr(3);\n\t\t\t//cout << ratio << endl;\n\n\t\t\tint ratio_num = stoi(ratio);\n\n\t\t\tif(tree.issame(id1,id2)){\n\t\t\t\tif(tree.diff(id1,id2) != ratio_num){\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttree.merge(id1,id2,ratio_num);\n\t\t\t}\n        }\n\t\tif(ans){\n\t\t\tcout << \"Yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"No\" << endl;\n\t\t}\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<map>\n#include<string>\nusing namespace std;\n\n#define INF 100000000\n\nint main()\n{\t\n\n\tint n;\n\tstring temp;\n\tint a;\n\n\tint cost[200][200],minicost[200];\n\n\twhile(cin>>n && n!=0){\n\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t\tminicost[i]=INF;\n\t\t}\n\n\n\t\tmap<string,int> Idx;\n\t\tint num=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a;//1\n\t\t\tstring s,t,p; cin>>s>>temp>>p>>t;\n\t\t\tif(!Idx.count(s)){Idx[s]=num++;}\n\t\t\tif(!Idx.count(t)){Idx[t]=num++;}\n\t\t\tstd::istringstream is(p);  // \"10+10\"を読み込む\n\t\t\tint k;\n\t\t\tchar taa;\n\t\t\tis>>a>>taa>>k;\n\t\t\tcost[Idx[s]][Idx[t]]=k;\n\t\t\tcost[Idx[t]][Idx[s]]=-k;\n\t\t}\n\n\t\tint count=0;\n\t\tbool print=false;\n\t\twhile(true){\n\t\t\tbool update=false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(cost[i][j]<INF){\n\t\t\t\t\t\tif(minicost[j]<minicost[i]+cost[i][j]){\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\tminicost[j]=minicost[i]+cost[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update){cout<<\"Yes\"<<endl;print=true;break;}\n\t\t\tcount++;\n\t\t\tif(count>n) break;\n\t\t}\n\t\tif(!print)cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<string>v; int n, a[1000], b[1000], c[1000]; string s1[1000], s2[1000], t[1000];\nvector<int>u[1000]; int group[1000], dist[1000]; bool OK = true;\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\n\nvoid merge(int a, int b, int c) {\n\tif (group[a] == group[b]) { if (dist[a] - dist[b] != c)OK = false; }\n\tint sa = (dist[a] - dist[b]) - c;\n\tfor (int i : u[group[b]])dist[i] += sa;\n\tfor (int i : u[group[b]])u[group[a]].push_back(i); int w = group[b];\n\tfor (int i : u[w])group[i] = group[a];\n\tu[w].clear();\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; v.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring a1, a2; cin >> a1 >> s1[i] >> a2 >> t[i] >> s2[i];\n\t\t\tv.push_back(s1[i]); v.push_back(s2[i]);\n\t\t}\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); OK = true;\n\t\tfor (int i = 0; i < n; i++) { u[i].clear(); u[i].push_back(i); group[i] = i; a[i] = s(s1[i]); b[i] = s(s2[i]); c[i] = stoi(t[i].substr(3, t[i].size() - 3)); }\n\t\tfor (int i = 0; i < n; i++) { merge(a[i], b[i], c[i]); }\n\t\tif (OK == true)cout << \"Yes\" << endl; else cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <map>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef string key;\n\nchar b1[99],b2[99];\nvoid main2(int n){\n\tmap<key,deque<pair<key,long long>>>m;\n\tfor(;n;n--){\n\t\tint d;\n\t\tscanf(\" 1 %s = 10^%d %s\",b1,&d,b2);\n\t\tstring s1=b1,s2=b2;\n\t\tm[s1].emplace_back(s2,d);\n\t\tm[s2].emplace_back(s1,-d);\n\t}\n\tfor(;!m.empty();){\n\t\tauto s=m.begin()->first;\n\t\tdeque<pair<key,long long>>st={{s,0}};\n\t\tmap<key,long long>memo={{s,0}};\n\t\tfor(;!st.empty();){\n\t\t\tauto p=*st.begin();st.pop_front();\n\t\t\tauto cur=p.first;long long d=p.second;\n\t\t\tmemo[cur]=d;\n\t\t\tfor(auto &e:m[cur]){\n\t\t\t\tif(memo.find(e.first)==memo.end()){\n\t\t\t\t\tst.emplace_back(e.first,d+e.second);\n\t\t\t\t}else if(memo[e.first]!=d+e.second){\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto &e:memo)m.erase(m.find(e.first));\n\t}\n\tputs(\"Yes\");\n}\nint main(){int n;for(;~scanf(\"%d\",&n)&&n;)main2(n);}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \n\nint main(void){  \n  int N;\n  while(cin>>N){\n    if(!N) break;\n    vector<string> tani;\n    vector<int> ind;\n    bool flag = true;\n    bool first = true;\n    int tmp;\n    string tmp2;\n    int count=0;\n    int date[100];\n    string date2[100][2];\n    while(N--){\n      string tani1,tani2;\n      int index;\n      cin>>tmp;\n      cin>>tani1;\n      cin>>tmp2;\n      cin>>tmp2;\n      index = (tmp2[3]!='-')?(tmp2[3]-'0'):('0' - tmp2[4]);\n      cin>>tani2;\n      if(first){\n        tani.push_back(tani1); tani.push_back(tani2);\n        ind.push_back(0); ind.push_back(index);\n        first = false;\n        continue;\n      }\n      vector<string>::iterator it1 = find(tani.begin(),tani.end(),tani1)\n        , it2 = find(tani.begin(),tani.end(),tani2);\n      bool f1 = (it1 != tani.end());\n      bool f2 = (it2 != tani.end());\n      int ind1 = ind[distance(tani.begin(),it1)];\n      int ind2 = ind[distance(tani.begin(),it2)];\n      if(f1){\n        if(f2){\n          if(ind2 - ind1 != index){\n            flag = false;\n          }\n        }else{\n          ind.push_back(ind1 + index);\n          tani.push_back(tani2);\n        }\n      }else{\n        if(f2){\n          ind.push_back(ind2 - index);\n          tani.push_back(tani1);\n        }else{\n          date[count] = index;\n          date2[count][0] = tani1;\n          date2[count][1] = tani2;\n          count++;\n        }\n      }\n    }\n    REP(i,count){\n      vector<string>::iterator it1 = \n        find(tani.begin(),tani.end(),date2[i][0]), \n        it2 = find(tani.begin(),tani.end(),date2[i][1]);\n      bool f1 = (it1 != tani.end());\n      bool f2 = (it2 != tani.end());\n      int ind1 = ind[distance(tani.begin(),it1)];\n      int ind2 = ind[distance(tani.begin(),it2)];\n      if(f1&&f2&&ind2-ind1!=date[i])\n        flag = false;\n    }\n    if(flag) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 250\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,int> m;\nint n,x,s2,num,s;\nbool ans,used[N];\nvector<P> e[N];\nstring s1,s3;\n\n\nvoid dfs(int x,int y,int sum){\n  if(x==y){\n    s=sum;\n    return;\n  }\n  if(used[x])return;\n  used[x]=true;\n  for(int i=0;i<e[x].size();i++)\n    dfs(e[x][i].first,y,sum+e[x][i].second);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    num=0;\n    ans=true;\n    for(int i=0;i<n;i++){\n      cin>>s3>>s1>>s3;\n      scanf(\" 10^%d\",&s2); cin>>s3;\n      if(m.find(s1)!=m.end()&&m.find(s3)!=m.end()){\n\ts=-1;\n\tmemset(used,0,sizeof(used));\n\tdfs(m[s1],m[s3],0);\n\tif(s!=-1&&s!=s2)ans=false;\n      }\n      if(m.find(s1)==m.end())m[s1]=num++;\n      if(m.find(s3)==m.end())m[s3]=num++;\n      e[m[s1]].push_back(P(m[s3],s2));\n      e[m[s3]].push_back(P(m[s1],-s2));\n    }\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    for(int i=0;i<N;i++)e[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<map>\n#include<string>\nusing namespace std;\n\n#define INF 10000000\n\nint main()\n{\t\n\n\tint n;\n\tstring temp;\n\tint a;\n\n\tint cost[200][200],minicost[200];\n\n\twhile(cin>>n && n!=0){\n\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t\tminicost[i]=INF;\n\t\t}\n\n\n\t\tmap<string,int> Idx;\n\t\tint num=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a;//1\n\t\t\tstring s,t,p; cin>>s>>temp>>p>>t;\n\t\t\tif(!Idx.count(s)){Idx[s]=num++;}\n\t\t\tif(!Idx.count(t)){Idx[t]=num++;}\n\t\t\tstd::istringstream is(p);  // \"10+10\"を読み込む\n\t\t\tint k;\n\t\t\tchar taa;\n\t\t\tis>>a>>taa>>k;\n\t\t\tcost[Idx[s]][Idx[t]]=k;\n\t\t\tcost[Idx[t]][Idx[s]]=-k;\n\t\t}\n\n\t\tint count=0;\n\t\twhile(true){\n\t\t\tbool update=false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(cost[i][j]<INF){\n\t\t\t\t\t\tif(minicost[j]<minicost[i]+cost[i][j]){\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\tminicost[j]=minicost[i]+cost[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update){cout<<\"Yes\"<<endl;break;}\n\t\t\tcount++;\n\t\t\tif(count>n+10){cout<<\"No\"<<endl;break;}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n#include<map>\nusing namespace std;\n\n#define INF 100000000\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\n\nint stoi(string s){\n  stringstream ss(s);\n  int res;\n  ss >> res;\n  return res;\n}\n\nP par[210];\nint rank[210];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n\nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n\nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n\nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n  \n  if(same(x.fs,y.fs)){\n    //cout << a << \" \" << b << endl;\n    cout << x.sc << \" \" << y.sc << \" \" << cost << endl;\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,par[b].sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,par[a].sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nint g[210][210];\nint n,c[110],f,t;\nstring a[110],b[110],tmp;\nmap<string,int> m;\n\nint main(){\n  int i;\n  while(cin >> n,n){\n    m.clear();\n    for(i=0;i<n;i++){\n      cin >> tmp; cin >> a[i]; cin >> tmp;\n      cin >> tmp; c[i] = stoi(tmp.substr(3,tmp.size()-3));\n      cin >> b[i];\n    }\n    for(i=0;i<n;i++){\n      if(m.find(a[i])==m.end())m[a[i]] = m.size()-1;\n      if(m.find(b[i])==m.end())m[b[i]] = m.size()-1;\n    }\n\n    for(i=0;i<m.size();i++)\n      for(int j=0;j<m.size();j++)\n\tif(i==j)g[i][j] = 0;\n\telse g[i][j] = INF;\n\n    for(i=0;i<n;i++){\n      f = m[a[i]]; t = m[b[i]];\n      if(g[f][t] != INF){\n\tif(g[f][t] != c[i]){\n\t  cout << \"No\" << endl;\n\t  break;\n\t}\n      }else{\n\tg[f][t] = c[i];\n\tfor(int x=0;x<m.size();x++){\n\t  if(x!=t && g[x][f] != INF){\n\t    for(int y=0;y<m.size();y++){\n\t      if(y!=f && g[t][y] != INF){\n\t\tg[x][y] = g[x][f] + g[f][t] + g[t][y];\n\t      }\n\t    }\n\t  }\n\t}\n\n\tg[t][f] = -c[i];\n\tfor(int x=0;x<m.size();x++){\n\t  if(x!=f && g[x][t] != INF){\n\t    for(int y=0;y<m.size();y++){\n\t      if(y!=t && g[f][y] != INF){\n\t\tg[x][y] = g[x][t] + g[t][f] + g[f][y];\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(i==n)cout << \"Yes\" << endl;\n    /*\n    init(m.size());\n    for(i=0;i<n;i++){\n      if(!unite(m[a[i]],m[b[i]],c[i])){\n\tcout << \"No\" << endl;\n\tbreak;\n      }\n    }\n    \n    if(i==n)cout << \"Yes\" << endl;\n    */\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int INF = 1e9 + 7;\n\nmap<int, int> v, parent, dist;\nmap<string, int> M;\n\n// P(parent, dist)\nP find(int a){\n  if(parent[a] == a) return P(a, dist[a]);\n  P p = find(parent[a]);\n  parent[a] = p.first;\n  dist[a] += p.second;\n  return P(p.first, dist[a]);\n}\n\nbool same(int a, int b){ return find(a).first == find(b).first; }\n\nvoid merge(int a, int b, int dd){\n  if(same(a, b)) return ;\n  P pa = find(a), pb = find(b);\n  int d = dd - pb.second + pa.second;\n  if(d < 0){\n    d *= -1;\n    swap(pa, pb);\n  }\n  parent[pb.first] = pa.first;\n  dist[pb.first] = d;\n}\n\nint distance(int a, int b){\n  if(!same(a, b)) return INF;\n  return find(b).second - find(a).second;\n}\n\nint get_number(string &s){\n  if(M.find(s) != M.end()) return M[s];\n  int num = M.size();\n  M[s] = num;\n  parent[num] = num;\n  return num;\n}\n\nint get_distance(string &s){\n  int idx = 0;\n  while(s[idx++] != '^') ;\n  return atoi(s.substr(idx).c_str());\n}\n\nvoid input(string &as, int &d, string &bs){\n  string s, tmp;\n  cin >>tmp >>as >>tmp >>s >>bs;\n  d = get_distance(s);\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    bool ans = true;\n    REP(i, N){\n      string as, bs; int d;\n      input(as, d, bs);\n      int a = get_number(as), b = get_number(bs);\n      //cout <<as <<\", \" <<d <<\", \" <<bs <<\", \" <<a <<\", \" <<b <<\" | \" <<same(a, b) <<\", \" <<distance(a, b) <<endl;\n      if(same(a, b)) { if(distance(a, b) != d) ans = false; }\n      else merge(a, b, d);\n    }\n    cout <<(ans ? \"Yes\" : \"No\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define\tmp\t\tmake_pair\n#define\tpb\t\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=1<<29;\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint unum=0;\n\t\tpair<pii,int> edge[100];\n\t\tmap<string,int> name;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint pw;\n\t\t\tchar u1[17],u2[17];\n\t\t\tscanf(\"%*d %s %*c %*d%*c%d %s\",u1,&pw,u2);\n\n\t\t\tint id1,id2;\n\t\t\tif(name.count(u1)==0)\tname[u1]=unum++;\n\t\t\tid1=name[u1];\n\t\t\tif(name.count(u2)==0)\tname[u2]=unum++;\n\t\t\tid2=name[u2];\n\n\t\t\tedge[i]=mp(mp(id1,id2),pw);\n\t\t}\n\n\t\tstatic int wf[200][200];\n\t\tfor(int i=0;i<unum;i++)for(int j=0;j<unum;j++)\twf[i][j]=(i==j?0:inf);\n\t\tfor(int k=0;k<n;k++){\n\t\t\tint from=edge[k].first.first,to=edge[k].first.second,dis=edge[k].second;\n\t\t\twf[from][to]=dis;\n\t\t\twf[to][from]=-dis;\n\t\t}\n\t\tfor(int k=0;k<unum;k++)for(int i=0;i<unum;i++)for(int j=0;j<unum;j++){\n\t\t\twf[i][j]=min(wf[i][j],wf[i][k]+wf[k][j]);\n\t\t}\n\n\t\tbool ok=true;\n\t\tfor(int i=0;i<unum;i++)\tif(wf[i][i]<0)\tok=false;\n\n\t\tputs(ok?\"Yes\":\"No\");\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <map>\n \nusing namespace std;\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n \ntypedef pair<int, int> P;\n \nint d[201][201];\n \nconst int INF = 1<<29;\nint main(){\n    int n;\n    while(cin >> n, n){\n        rep(i, 201) rep(j, 201) d[i][j] = INF;\n        map<string, int> num;\n        int idx = 0;\n        bool ans = true;\n        rep(i, n){\n            string a, b;\n            string c;\n            cin >> c >> a >> c >> c >> b;\n            if(!num[a]) num[a] = ++idx;\n            if(!num[b]) num[b] = ++idx;\n            int x = atoi(c.substr(3).c_str());\n            // a = b+x\n            int l = num[a], r = num[b];\n            rep(k, 2){\n                if(d[l][r] == INF){\n                    d[l][r] = x;\n                }else{\n                    if(d[l][r] != x) ans = false;\n                }\n                swap(l, r);\n                x = -x;\n            }\n            for(int j = 1; j <= idx; j++){\n                for(int k = 1; k <= idx; k++){\n                    if(d[k][j] == INF) continue;\n                    for(int l = 1; l <= idx; l++){\n                        if(d[j][l] == INF) continue;\n                        d[k][l] = min(d[k][l], d[k][j]+d[j][l]);\n                    }\n                }\n            }\n        }\n \n        cout << (ans?\"Yes\":\"No\") << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\n\n\nconst int INF = 100000000;\nconst long long INFL = 100000000000000LL;\n\nint n;\nmap<string, int> stoi;\nbool visited[200][200];\nlong long cost[200];\nint G[200][200];\n\nint conv(string& str){\n  return atoi(str.substr(3).c_str());\n}\n\nbool dfs(int p, long long cos){\n  if(cost[p] == INFL) cost[p] = cos;\n  if(cost[p] != cos) return false;\n  for(int i=0;i<n;i++){\n    if(i == p) continue;\n    if(visited[p][i]) continue;\n    if(G[p][i] == INF) continue;\n    visited[p][i] = visited[p][i] = true;\n    if(!dfs(i, cos + G[p][i])) return false;\n  }\n  return true;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(G[0], G[200], INF);\n    stoi.clear();\n    int size = 0;\n    bool ans = true;\n    for(int i=0;i<n;i++){\n      string a, b;\n      int in;\n      cin >> a;\n      cin >> a;\n      cin >> b;\n      cin >> b;\n      in = conv(b);\n      cin >> b;\n      int c, d;\n      if(stoi.find(a) == stoi.end()){\n\tstoi[a] = size++;\n      }\n      if(stoi.find(b) == stoi.end()){\n\tstoi[b] = size++;\n      }\n      c = stoi[a];\n      d = stoi[b];\n      if(c == d && in != 0) ans = false;\n      G[c][d] = in;\n      G[d][c] = -in;\n    }\n    if(ans){\n      for(int i=0;i<n;i++){\n\tfill(visited[0], visited[200], false);\n\tfill(cost, cost+200, INFL);\n\tif(!dfs(i, 0LL)){\n\t  ans = false;\n\t  break;\n\t}\n      }\n    }\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint x[100];\nstring t1[100], t2[100];\nint g[200][200];\n\nint main() {\n  int n;\n  while(scanf(\"%d\",&n),n) {\n    REP(i,n) {\n      char s1[20],s2[20];\n      scanf(\"%*d %s %*c%*d%*c%d %s\", s1, x+i, s2);\n      t1[i] = string(s1);\n      t2[i] = string(s2);\n    }\n    REP(i,2*n)REP(j,2*n) g[i][j]=INF;\n    REP(i,2*n)g[i][i]=0;\n    bool f = 1;\n    map<string, int> mp;\n    int num = 0;\n    REP(i,n) {\n      if (mp.count(t1[i]) == 0) mp[t1[i]] = num++;\n      if (mp.count(t2[i]) == 0) mp[t2[i]] = num++;\n      int a = mp[t1[i]];\n      int b = mp[t2[i]];\n\n      \n      if (g[a][b] != INF) {\n        if (g[a][b] != x[i]) {\n          f = 0;\n          break;\n        }\n      } else {\n        g[a][b] = x[i];\n        g[b][a] = -x[i];\n        REP(i,num) {\n          REP(j,num) {\n            if (g[i][a] != INF && g[b][j] != INF) {\n              g[i][j] = g[i][a] + g[a][b] + g[b][j];\n              g[j][i] = -g[i][j];\n            } else if (g[i][b] != INF && g[a][j] != INF) {\n              g[i][j] = g[i][b] + g[b][a] + g[a][j];\n              g[j][i] = -g[i][j];\n            }\n          }\n        }\n      } \n    //   REP(i,num) {\n    //     REP(j,num) {\n    //       if (g[i][j] == INF) cout << \"*\" << \" \";\n    //       else cout << g[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    //   }\n    //   cout << endl;\n    }\n    cout << (f?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 200*100 + 100;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n\n    int size() const { return id; }\n};\n\nbool dfs(int pos, int val, const vector<vector<pair<int,int> > > &graph, vector<int> &dist) {\n    if(dist[pos] != INF) return dist[pos] == val;\n    dist[pos] = val;\n    const vector<pair<int,int> > &edges = graph[pos];\n    for(vector<pair<int,int> >::const_iterator it = edges.begin(); it != edges.end(); ++it) {\n        int nc = val + it->second;\n        if(!dfs(it->first, nc, graph, dist)) return false;\n    }\n    return true;\n}\n\nvector<vector<pair<int,int> > > v(200);\nvector<int> dist(200);\nvector<unsigned char> visited(200);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        cin.ignore();\n        for(int i = 0; i < N; ++i) {\n            v[i].clear();\n        }\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string line;\n            getline(cin, line);\n            for(string::iterator it = line.begin(); it != line.end(); ++it) {\n                if(*it == '=' || *it == '^') *it = ' ';\n            }\n            istringstream is(line);\n            string unit_left, unit_right;\n            int ord;\n            int tmp;\n            is >> tmp >> unit_left >> tmp >> ord >> unit_right;\n            //sscanf(line.c_str(), \"%*d %s = %*d^%d %s \", unit_left, &ord, unit_right);\n            const int id_left = dict.get(string(unit_left));\n            const int id_right = dict.get(string(unit_right));\n            v[id_left].push_back(make_pair(id_right, ord));\n            v[id_right].push_back(make_pair(id_left, -ord));\n        }\n\n        const int M = dict.size();\n        bool ok = true;\n        fill(dist.begin(), dist.end(), INF);\n        for(int i = 0; i < M; ++i) {\n            if(dist[i] == INF) {\n                if(!dfs(i, 0, v, dist)) {\n                    ok = false;\n                    break;\n                }\n            }\n        }\n\n        if(!ok) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2207\n  Title:Consistet Unit System\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\nint  n;\nint  unit_c;\nchar unit_name[200][17];\nint  relation[200][200];\n\nint regist(char *unit)\n{\n  int i;\n\n  for(i=0;i<unit_c;i++)\n    if(0==strcmp(unit,&unit_name[i][0]))\n       return(i);\n\n  strcpy(&unit_name[unit_c][0],unit);\n  unit_c++;\n  return(unit_c-1);\n}\nint solve()\n{\n  int i,j,k,flag;\n  \n  do\n    {\n      flag=0;\n      for(i=0;i<unit_c;i++)\n\tfor(j=0;j<unit_c;j++)\n\t  for(k=0;k<unit_c;k++)\n\t    if(i!=j && j!=k && k!=i)\n\t      if(relation[i][k]!=INT_MAX &&  relation[k][j]!=INT_MAX)\n\t\t  {\n\t\t    //printf(\":%d %d %d |%d+%d =%d\\n\",i,k,j,relation[i][k],\n\t\t    //   relation[k][j],relation[i][j]);\n\n\t\t    if(relation[i][j]==INT_MAX)\n\t\t      {\n\t\t\trelation[i][j]=relation[i][k]+relation[k][j];  \n\t\t\tflag=-1;\n\t\t      }\n\t\t    else if(relation[i][k]+relation[k][j]\n\t\t\t    != relation[i][j])\n\t\t      return(0);\n\t\t  }\n\t      \n    }  while(flag);\n    return(-1);\n}\nvoid dump()\n{\n  int i,j,r;\n\n  for(i=0;i<unit_c;i++)\n    printf(\"%d %s\\n\",i,&unit_name[i][0]);\n  for(i=0;i<unit_c;i++)\n    for(j=0;j<unit_c;j++)\n      if((r=relation[i][j])!=INT_MAX)\n\tprintf(\"%s~%s %d\\n\",&unit_name[i][0],&unit_name[j][0],r);\n\t\t \n}\n\nmain()\n{\n  int i,j,expo,un1,un2,ret;\n  char unit1[16],unit2[16];\n\n  while(scanf(\"%d \",&n) && n)\n    {\n      unit_c=0;\n      memset(unit_name, 0,200*17);\n      for(i=0;i<200;i++)\n\tfor(j=0;j<200;j++)\n\t  relation[i][j]=INT_MAX;\n      for(i=0;i<n;i++)\n\t{\n\t  scanf(\"1 %[a-z] = 10^%d %[a-z] \",unit1,&expo,unit2);\n\t  un1=regist(unit1);\n\t  un2=regist(unit2);\n\t  relation[un1][un2]=expo;\n\t  relation[un2][un1]=-expo;\n\t}\n      //printf(\"uc=%d\\n\",unit_c);\n      //dump();\n\n      ret=solve();\n      printf(\"%s\\n\",ret?\"Yes\":\"No\");\n     }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2207: Consistet Unit System\n// 2017.12.3 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define HASHSIZ 199\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash + HASHSIZ;\t\t\t// Hash table\n\nint lookup(char *s, int w, int id)\n{\n\tHASH *tp = hash + (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\twhile (tp->s != NULL) {\n\t\tif (strcmp(tp->s, s) == 0) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\n// <????????????Union Find>\n#define MAX 103\nint par[MAX], ws[MAX];\nint find(int x)\n{\n\tint p;\n\tif (par[x] < 0) return x;\n    p = find(par[x]), ws[x] += ws[par[x]];\n    return par[x] = p;\n}\n    \nint weight(int x)\n{\n    find(x); \n    return ws[x];\n}\n    \nint unite(int x, int y, int w)\n{\n\tint t;\n    w += weight(x), w -= weight(y);\n    x = find(x), y = find(y);\n    if (x == y) return 0;\n    if (par[y] < par[x]) t = x, x = y, y = t, w = -w;\n    par[x] += par[y], par[y] = x;\n    ws[y] = w;\n    return 1;\n}\n// </????????????Union Find>\n\nchar unit[102][18]; int sz;\n\nint main()\n{\n\tint n, i, j, k, minus, ans;\n\tchar buf[102], *p, *q;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tmemset(par, 0xff, sizeof(par));\n\t\tmemset(ws, 0, sizeof(ws));\n\t\tsz = 0; ans = 1;\n\t\twhile (n-- > 0) {\n\t\t\tfgets(buf, 100, stdin); p = buf+1;   // skip \"1\"\n\t\t\tif (!ans) continue;\n\t\t\twhile (isspace(*p)) p++;\n\t\t\tq = p; while (isalpha(*p)) p++;\n\t\t\t*p = 0;\tstrcpy(unit[sz], q);\n\t\t\tif ((i = lookup(unit[sz], p-q, sz)) < 0) i = sz++;\n\t\t\t\n\t\t\tp++; while (isspace(*p)) p++;\n\t\t\tp++; while (isspace(*p)) p++;\n\t\t\tp+=3;\t// skip \"10^\"\n\n\t\t\tminus = 0; if (*p == '-') minus = 1, p++;\n\t\t\tk = 0; while (isdigit(*p))  k = 10*k + (*p++ - '0');\n\t\t\tif (minus) k = -k;\n\n\t\t\twhile (isspace(*p)) p++;\n\t\t\tq = p; while (isalpha(*p)) p++;\n\t\t\t*p = 0;\tstrcpy(unit[sz], q);\n\t\t\tif ((j = lookup(unit[sz], p-q, sz)) < 0) j = sz++;\n\n\t\t\t// i = k * j ???\n\t\t\tif (find(i) == find(j)) {\n\t\t\t\tif (ws[i] - ws[j] != k) ans = 0;\n\t\t\t} else unite(j, i, k);\n\t\t}\n\t\tputs(ans ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2207\n  Title:Consistet Unit System\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\nint  n;\nint  unit_c;\nchar unit_name[200][17];\nint  relation[200][200];\n\nint regist(char *unit)\n{\n  int i;\n\n  for(i=0;i<unit_c;i++)\n    if(0==strcmp(unit,&unit_name[i][0]))\n       return(i);\n\n  strcpy(&unit_name[unit_c][0],unit);\n  unit_c++;\n  return(unit_c-1);\n}\nint solve()\n{\n  int i,j,k,flag;\n  \n  do\n    {\n      flag=0;\n      for(i=0;i<unit_c;i++)\n\tfor(j=0;j<unit_c;j++)\n\t  for(k=0;k<unit_c;k++)\n\t    if(i!=j && j!=k && k!=i)\n\t      if(relation[i][k]!=INT_MAX &&  relation[k][j]!=INT_MAX)\n\t\t  {\n\t\t    //printf(\":%d %d %d |%d+%d =%d\\n\",i,k,j,relation[i][k],\n\t\t    //   relation[k][j],relation[i][j]);\n\n\t\t    if(relation[i][j]==INT_MAX)\n\t\t      {\n\t\t\trelation[i][j]=relation[i][k]+relation[k][j];  \n\t\t\tflag=-1;\n\t\t      }\n\t\t    else if(relation[i][k]+relation[k][j]\n\t\t\t    != relation[i][j])\n\t\t      return(0);\n\t\t  }\n\t      \n    }  while(flag);\n    return(-1);\n}\nvoid dump()\n{\n  int i,j,r;\n\n  for(i=0;i<unit_c;i++)\n    printf(\"%d %s\\n\",i,&unit_name[i][0]);\n  \n  for(i=0;i<unit_c;i++)\n    for(j=0;j<unit_c;j++)\n      if((r=relation[i][j])!=INT_MAX)\n\tprintf(\"%s~%s %d\\n\",&unit_name[i][0],&unit_name[j][0],r);\n}\n\nmain()\n{\n  int i,j,expo,un1,un2,ret;\n  char unit1[17],unit2[17];\n\n  while(scanf(\"%d \",&n) && n)\n    {\n      unit_c=0;\n      memset(unit_name, 0,200*17);\n      for(i=0;i<200;i++)\n\tfor(j=0;j<200;j++)\n\t  relation[i][j]=INT_MAX;\n      for(i=0;i<n;i++)\n\t{\n\t  scanf(\"1 %[a-z] = 10^%d %[a-z] \",unit1,&expo,unit2);\n\t  un1=regist(unit1);\n\t  un2=regist(unit2);\n\t  relation[un1][un2]=expo;\n\t  relation[un2][un1]=-expo;\n\t}\n#ifdef DEBUG      \n      dump();\n#endif\n      ret=solve();\n      printf(\"%s\\n\",ret?\"Yes\":\"No\");\n     }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2207\n  Title:Consistet Unit System\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\nint N;\nchar unit[100][17];\nint unit_cnt;\nchar unit1[17];\nchar unit2[17];\nint relation[100][100];\n\ncheck_dilemma()\n{\n        int i,j,k,flag;\n\n        do {\n          flag=0;\n          for(i=0;i<unit_cnt;i++)\n                for(j=0;j<unit_cnt;j++)\n                {\n                        if(relation[i][j]==INT_MAX || i==j)\n                                continue;\n                        for(k=0;k<unit_cnt;k++)\n                        {\n                                //printf(\"IJK=%d %d %d\\n\",i,j,k);\n\n                                if(j==k)\n                                        continue;\n                                if(relation[j][k]!=INT_MAX)\n                                {\n                                        if(relation[i][k]==INT_MAX)\n                                        {\n                                                relation[i][k]=relation[i][j]+relation[j][k];\n                                                flag=1;\n                                        }\n                                        else if(relation[i][k]!=relation[i][j]+relation[j][k])\n                                                return(0);\n                                        \n                                }\n                        }\n                }\n        }\n        while(flag);\n\n        return(1);\n}\nfind_and_register(char u[])\n{\n        int i;\n\n        //printf(\"UNIT=%s:\",u);\n\n        for(i=0;i<unit_cnt;i++)\n                if(0==strcmp(&unit[i][0],u))\n                   return(i);\n                   \n        strcpy(&unit[unit_cnt][0],u);\n        return(unit_cnt++);\n}\nvoid init()\n{\n        int i,j;\n\n        for(i=0;i<100;i++)\n                for(j=0;j<100;j++)\n                        if(i==j)\n                                relation[i][j]=0;\n                        else\n                                relation[i][j]=INT_MAX;\n}\nvoid dump()\n{\n        int i,j;\n\n        for(i=0;i<unit_cnt;i++)\n                for(j=0;j<unit_cnt;j++)\n                        printf(\"%s %s %d\\n\",unit[i],unit[j],relation[i][j]);\n\n}\nmain()\n{\n        int i,j,ng,times,n1,n2,ret,x,y;\n\n        while(EOF!=scanf(\"%d\",&N) && N)\n        {\n                init();\n                ng=0;\n                unit_cnt=0;\n                for(i=0;i<N;i++)\n                {\n                        scanf(\"%d %s = %d^%d %s\",&x,unit1,&y,&times,unit2);\n                        \n                        n1=find_and_register(unit1);\n                        n2=find_and_register(unit2);\n                        \n                        if(relation[n1][n2]!=INT_MAX && relation[n1][n2]!=times) //dilemma\n                                ng=1;\n                        else if(n1==n2 && times!=0)\n                                ng=1;\n                        else\n                        {\n                                relation[n1][n2]=times;\n                                relation[n2][n1]=-times;\n                        }\n                }\n                if(ng)\n                        printf(\"No\\n\");\n                else if(unit_cnt<2)\n                        printf(\"Yes\\n\");\n                else\n                {\n                        ret=check_dilemma();\n                        printf(\"%s\\n\",ret?\"Yes\":\"No\");\n                }\n          dump();\n        }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2207\n  Title:Consistet Unit System\n  @kankichi573\n  13/10/22 RTE\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\nint N;\nchar unit[101][17];\nint unit_cnt;\nchar unit1[17];\nchar unit2[17];\nint relation[100][100];\n\ncheck_dilemma()\n{\n        int i,j,k,flag;\n\n        do {\n          flag=0;\n          for(i=0;i<unit_cnt;i++)\n                for(j=0;j<unit_cnt;j++)\n                {\n                        if(relation[i][j]==INT_MAX || i==j)\n                                continue;\n                        for(k=0;k<unit_cnt;k++)\n                        {\n                                //printf(\"IJK=%d %d %d\\n\",i,j,k);\n\n                                if(j==k)\n                                        continue;\n                                if(relation[j][k]!=INT_MAX)\n                                {\n                                        if(relation[i][k]==INT_MAX)\n                                        {\n                                                relation[i][k]=relation[i][j]+relation[j][k];\n                                                flag=1;\n                                        }\n                                        else if(relation[i][k]!=relation[i][j]+relation[j][k])\n                                                return(0);\n                                        \n                                }\n                        }\n                }\n        }\n        while(flag);\n\n        return(1);\n}\nfind_and_register(char u[])\n{\n        int i;\n\n        //printf(\"UNIT=%s:\",u);\n\n        for(i=0;i<unit_cnt;i++)\n                if(0==strcmp(&unit[i][0],u))\n                   return(i);\n                   \n        strcpy(&unit[unit_cnt][0],u);\n        return(unit_cnt++);\n}\nvoid init()\n{\n        int i,j;\n\n        for(i=0;i<100;i++)\n                for(j=0;j<100;j++)\n                        if(i==j)\n                                relation[i][j]=0;\n                        else\n                                relation[i][j]=INT_MAX;\n}\nvoid dump()\n{\n        int i,j;\n\n        for(i=0;i<unit_cnt;i++)\n                for(j=0;j<unit_cnt;j++)\n                        printf(\"%s %s %d\\n\",unit[i],unit[j],relation[i][j]);\n\n}\nmain()\n{\n        int i,j,ng,times,n1,n2,ret,x,y;\n\n        while(EOF!=scanf(\"%d\",&N) && N)\n        {\n                init();\n                ng=0;\n                unit_cnt=0;\n                for(i=0;i<N;i++)\n                {\n                        scanf(\"%d %s = %d^%d %s\",&x,unit1,&y,&times,unit2);\n                        \n                        n1=find_and_register(unit1);\n                        n2=find_and_register(unit2);\n                        \n                        if(relation[n1][n2]!=INT_MAX && relation[n1][n2]!=times) //dilemma\n                                ng=1;\n                        else if(n1==n2 && times!=0)\n                                ng=1;\n                        else\n                        {\n                                relation[n1][n2]=times;\n                                relation[n2][n1]=-times;\n                        }\n                }\n                if(ng)\n                        printf(\"No\\n\");\n                else if(unit_cnt<2)\n                        printf(\"Yes\\n\");\n                else\n                {\n                        ret=check_dilemma();\n                        printf(\"%s\\n\",ret?\"Yes\":\"No\");\n                }\n          dump();\n        }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2207: Consistet Unit System\n// 2017.12.3 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define HASHSIZ 607\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash + HASHSIZ;\t\t\t// Hash table\n\nint lookup(char *s, int w, int id)\n{\n\tHASH *tp = hash + (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\twhile (tp->s != NULL) {\n\t\tif (strcmp(tp->s, s) == 0) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\n// <????????????Union Find>\n#define MAX 300\nint par[MAX], ws[MAX];\nint find(int x)\n{\n\tint p;\n\tif (par[x] < 0) return x;\n    p = find(par[x]), ws[x] += ws[par[x]];\n    return par[x] = p;\n}\n    \nint weight(int x)\n{\n    find(x); \n    return ws[x];\n}\n    \nint unite(int x, int y, int w)\n{\n\tint t;\n    w += weight(x), w -= weight(y);\n    x = find(x), y = find(y);\n    if (x == y) return 0;\n    if (par[y] < par[x]) t = x, x = y, y = t, w = -w;\n    par[x] += par[y], par[y] = x;\n    ws[y] = w;\n    return 1;\n}\n// </????????????Union Find>\n\nchar unit[102][18]; int sz;\n\nint main()\n{\n\tint n, i, j, k, minus, ans;\n\tchar buf[102], *p, *q;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tmemset(par, 0xff, sizeof(par));\n\t\tmemset(ws, 0, sizeof(ws));\n\t\tsz = 0; ans = 1;\n\t\twhile (n-- > 0) {\n\t\t\tfgets(buf, 100, stdin); p = buf+1;   // skip \"1\"\n\t\t\tif (!ans) continue;\n\t\t\twhile (isspace(*p)) p++;\n\t\t\tq = p; while (isalpha(*p)) p++;\n\t\t\t*p = 0;\tstrcpy(unit[sz], q);\n\t\t\tif ((i = lookup(unit[sz], p-q, sz)) < 0) i = sz++;\n\t\t\t\n\t\t\tp++; while (isspace(*p)) p++;\n\t\t\tp++; while (isspace(*p)) p++;\n\t\t\tp+=3;\t// skip \"10^\"\n\n\t\t\tminus = 0; if (*p == '-') minus = 1, p++;\n\t\t\tk = 0; while (isdigit(*p))  k = 10*k + (*p++ - '0');\n\t\t\tif (minus) k = -k;\n\n\t\t\twhile (isspace(*p)) p++;\n\t\t\tq = p; while (isalpha(*p)) p++;\n\t\t\t*p = 0;\tstrcpy(unit[sz], q);\n\t\t\tif ((j = lookup(unit[sz], p-q, sz)) < 0) j = sz++;\n\n\t\t\t// i = k * j ???\n\t\t\tif (find(i) == find(j)) {\n\t\t\t\tif (ws[i] - ws[j] != k) ans = 0;\n\t\t\t} else unite(j, i, k);\n\t\t}\n\t\tputs(ans ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2207: Consistet Unit System\n// 2017.12.3 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define HASHSIZ 607\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash + HASHSIZ;\t\t\t// Hash table\n\nint lookup(char *s, int w, int id)\n{\n\tHASH *tp = hash + (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\twhile (tp->s != NULL) {\n\t\tif (strcmp(tp->s, s) == 0) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\n// <????????????Union Find>\n#define MAX 300\nint par[MAX], ws[MAX];\nint find(int x)\n{\n\tint p;\n\tif (par[x] < 0) return x;\n    p = find(par[x]), ws[x] += ws[par[x]];\n    return par[x] = p;\n}\n    \nint weight(int x)\n{\n    find(x); \n    return ws[x];\n}\n    \nint unite(int x, int y, int w)\n{\n\tint t;\n    w += weight(x), w -= weight(y);\n    x = find(x), y = find(y);\n    if (x == y) return 0;\n    if (par[y] < par[x]) t = x, x = y, y = t, w = -w;\n    par[x] += par[y], par[y] = x;\n    ws[y] = w;\n    return 1;\n}\n// </????????????Union Find>\n\nchar unit[MAX][18]; int sz;\n\nint main()\n{\n\tint n, i, j, k, minus, ans;\n\tchar buf[102], *p, *q;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tmemset(par, 0xff, sizeof(par));\n\t\tmemset(ws, 0, sizeof(ws));\n\t\tsz = 0; ans = 1;\n\t\twhile (n-- > 0) {\n\t\t\tfgets(buf, 100, stdin);\n\t\t\tif (!ans) continue;\n\n\t\t\tp = buf + 2;\t\t// skip \"1 \"\n\t\t\tq = p; while (isalpha(*p)) p++;\n\t\t\t*p = 0;\tstrcpy(unit[sz], q);\n\t\t\tif ((i = lookup(unit[sz], p-q, sz)) < 0) i = sz++;\n\t\t\t\n\t\t\tp += 6;\t\t\t// skip \" = 10^\"\n\t\t\tminus = 0; if (*p == '-') minus = 1, p++;\n\t\t\tk = 0; while (isdigit(*p))  k = 10*k + (*p++ & 0xf);\n\t\t\tif (minus) k = -k;\n\t\t\tp++;\n\n\t\t\tq = p; while (isalpha(*p)) p++;\n\t\t\t*p = 0;\tstrcpy(unit[sz], q);\n\t\t\tif ((j = lookup(unit[sz], p-q, sz)) < 0) j = sz++;\n\n\t\t\t// i = k * j ???\n\t\t\tif (find(i) == find(j)) {\n\t\t\t\tif (ws[i] - ws[j] != k) ans = 0;\n\t\t\t} else unite(j, i, k);\n\t\t}\n\t\tputs(ans ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2207\n  Title:Consistet Unit System\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\nint N;\nchar unit[100][17];\nint unit_cnt;\nchar unit1[17];\nchar unit2[17];\nint relation[100][100];\n\ncheck_dilemma()\n{\n        int i,j,k,flag;\n\n        do {\n          flag=0;\n          for(i=0;i<unit_cnt;i++)\n                for(j=0;j<unit_cnt;j++)\n                {\n                        if(relation[i][j]==INT_MAX || i==j)\n                                continue;\n                        for(k=0;k<unit_cnt;k++)\n                        {\n                                //printf(\"IJK=%d %d %d\\n\",i,j,k);\n\n                                if(j==k)\n                                        continue;\n                                if(relation[j][k]!=INT_MAX)\n                                {\n                                        if(relation[i][k]==INT_MAX)\n                                        {\n                                                relation[i][k]=relation[i][j]+relation[j][k];\n                                                flag=1;\n                                        }\n                                        else if(relation[i][k]!=relation[i][j]+relation[j][k])\n                                                return(0);\n                                        \n                                }\n                        }\n                }\n        }\n        while(flag);\n\n        return(1);\n}\nfind_and_register(char u[])\n{\n        int i;\n\n        //printf(\"UNIT=%s:\",u);\n\n        for(i=0;i<unit_cnt;i++)\n                if(0==strcmp(&unit[i][0],u))\n                   return(i);\n                   \n        strcpy(&unit[unit_cnt][0],u);\n        return(unit_cnt++);\n}\nvoid init()\n{\n        int i,j;\n\n        for(i=0;i<100;i++)\n                for(j=0;j<100;j++)\n                        if(i==j)\n                                relation[i][j]=0;\n                        else\n                                relation[i][j]=INT_MAX;\n}\nvoid dump()\n{\n        int i,j;\n\n        for(i=0;i<unit_cnt;i++)\n                for(j=0;j<unit_cnt;j++)\n                        printf(\"%s %s %d\\n\",unit[i],unit[j],relation[i][j]);\n\n}\nmain()\n{\n        int i,j,ng,times,n1,n2,ret,x,y;\n\n        init();\n\n        scanf(\"%d\",&N);\n        ng=0;\n        for(i=0;i<N;i++)\n        {\n                scanf(\"%d %s = %d^%d %s\",&x,unit1,&y,&times,unit2);\n                //printf(\"u1u2=%s %s\\n\",unit1,unit2);\n\n                n1=find_and_register(unit1);\n                n2=find_and_register(unit2);\n\n \n                //printf(\"N1N2=%d %d\\n\",n1,n2);\n\n                if(relation[n1][n2]!=INT_MAX && relation[n1][n2]!=times) //dilemma\n                        ng=1;\n                else if(n1==n2 && times!=0)\n                        ng=1;\n                else\n                {\n                        relation[n1][n2]=times;\n                        relation[n2][n1]=-times;\n                }\n        }\n        if(ng)\n                printf(\"No\\n\");\n        else if(unit_cnt<2)\n                printf(\"Yes\\n\");\n        else\n        {\n                ret=check_dilemma();\n                printf(\"%s\\n\",ret?\"Yes\":\"No\");\n        }\n        //dump();\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2207\n  Title:Consistet Unit System\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\nint N;\nchar unit[100][17];\nint unit_cnt;\nchar unit1[17];\nchar unit2[17];\nint relation[100][100];\n\ncheck_dilemma()\n{\n        int i,j,k,flag;\n\n        do {\n          flag=0;\n          for(i=0;i<unit_cnt;i++)\n                for(j=0;j<unit_cnt;j++)\n                {\n                        if(relation[i][j]==INT_MAX || i==j)\n                                continue;\n                        for(k=0;k<unit_cnt;k++)\n                        {\n                                //printf(\"IJK=%d %d %d\\n\",i,j,k);\n\n                                if(j==k)\n                                        continue;\n                                if(relation[j][k]!=INT_MAX)\n                                {\n                                        if(relation[i][k]==INT_MAX)\n                                        {\n                                                relation[i][k]=relation[i][j]+relation[j][k];\n                                                flag=1;\n                                        }\n                                        else if(relation[i][k]!=relation[i][j]+relation[j][k])\n                                                return(0);\n                                        \n                                }\n                        }\n                }\n        }\n        while(flag);\n\n        return(1);\n}\nfind_and_register(char u[])\n{\n        int i;\n\n        //printf(\"UNIT=%s:\",u);\n\n        for(i=0;i<unit_cnt;i++)\n                if(0==strcmp(&unit[i][0],u))\n                   return(i);\n                   \n        strcpy(&unit[unit_cnt][0],u);\n        return(unit_cnt++);\n}\nvoid init()\n{\n        int i,j;\n\n        for(i=0;i<100;i++)\n                for(j=0;j<100;j++)\n                        if(i==j)\n                                relation[i][j]=0;\n                        else\n                                relation[i][j]=INT_MAX;\n}\nvoid dump()\n{\n        int i,j;\n\n        for(i=0;i<unit_cnt;i++)\n                for(j=0;j<unit_cnt;j++)\n                        printf(\"%s %s %d\\n\",unit[i],unit[j],relation[i][j]);\n\n}\nmain()\n{\n        int i,j,ng,times,n1,n2,ret,x,y;\n        init();\n        while(EOF!=scanf(\"%d\",&N) && N)\n        {\n                ng=0;\n                for(i=0;i<N;i++)\n                {\n                        scanf(\"%d %s = %d^%d %s\",&x,unit1,&y,&times,unit2);\n                        \n                        n1=find_and_register(unit1);\n                        n2=find_and_register(unit2);\n                        \n                        if(relation[n1][n2]!=INT_MAX && relation[n1][n2]!=times) //dilemma\n                                ng=1;\n                        else if(n1==n2 && times!=0)\n                                ng=1;\n                        else\n                        {\n                                relation[n1][n2]=times;\n                                relation[n2][n1]=-times;\n                        }\n                }\n                if(ng)\n                        printf(\"No\\n\");\n                else if(unit_cnt<2)\n                        printf(\"Yes\\n\");\n                else\n                {\n                        ret=check_dilemma();\n                        printf(\"%s\\n\",ret?\"Yes\":\"No\");\n                }\n        //dump();\n        }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar unit[100][17];\nint ulen=0;\n\nint getnum(char *s)\n{\n    for (int i=0; i<ulen; i++)\n      if (strcmp(s, unit[i])==0) return i;\n    strcpy(unit[ulen], s);\n    return ulen++;\n}\n\nint main()\n{\n    int i, j, x, y, z, n, dx, dy, x0, y0;\n    char buf[64], *p;\n    char a[17], b[17];\n    int s[100],d[100];\n    while (1) {\n        ulen=0;\n        fgets(buf, 64, stdin);\n        if (buf[0]=='0') break;\n        for (n=0,p=buf; *p!='\\n'; n = n * 10 + *(p++) - '0');\n        for (i=0; i<n; s[i]=i,d[i]=0,i++);\n        for (i=0; i<n; i++) {\n            fgets(buf, 64, stdin);\n            for (j=0,p=buf+2; *p!=' '; a[j++]=*(p++));  a[j]=0;\n            while (*(p++)!='^');\n            z = 0;\n            if (*p=='-') for (p++; *p>='0'; z=z*10-(*(p++)-'0'));\n            else         for (; *p>='0'; z=z*10+*(p++)-'0');\n            for (j=0,p++; *p!='\\n'; b[j++]=*(p++));  b[j]=0;\n\t    x = getnum(a);\n\t    y = getnum(b);\n            for (x0=x,dx=0; s[x]!=x; dx+=d[x], x=s[x]);\n            s[x0]=x;\n            d[x0]=dx;\n            for (y0=y,dy=0; s[y]!=y; dy+=d[y], y=s[y]);\n            s[y0]=y;\n            d[y0]=dy;\n            if (x==y && dy-dx!=z) {\n\t      fputs(\"No\\n\", stdout);\n\t      for (j=i+1;j<n;j++) fgets(buf, 64, stdin);\n\t      break;\n            }\n            s[y] = x;\n            d[y] = z + d[x0] - d[y0];\n        }\n\tif (i==n) fputs(\"Yes\\n\", stdout);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar unit[200][17];\nint ulen=0;\n\nint getnum(char *s)\n{\n    for (int i=0; i<ulen; i++)\n      if (strcmp(s, unit[i])==0) return i;\n    strcpy(unit[ulen], s);\n    return ulen++;\n}\n\nint main()\n{\n    int i, j, x, y, z, n, dx, dy, x0, y0;\n    char buf[64], *p;\n    char a[17], b[17];\n    int s[200],d[200];\n    while (1) {\n        ulen=0;\n        fgets(buf, 64, stdin);\n        if (buf[0]=='0') break;\n        for (n=0,p=buf; *p!='\\n'; n = n * 10 + *(p++) - '0');\n        for (i=0; i<200; s[i]=i,d[i]=0,i++);\n        for (i=0; i<n; i++) {\n            fgets(buf, 64, stdin);\n            for (j=0,p=buf+2; *p!=' '; a[j++]=*(p++));  a[j]=0;\n            while (*(p++)!='^');\n            z = 0;\n            if (*p=='-') for (p++; *p>='0'; z=z*10-(*(p++)-'0'));\n            else         for (; *p>='0'; z=z*10+*(p++)-'0');\n            for (j=0,p++; *p!='\\n'; b[j++]=*(p++));  b[j]=0;\n\t    x = getnum(a);\n\t    y = getnum(b);\n            for (x0=x,dx=0; s[x]!=x; dx+=d[x], x=s[x]);\n            s[x0]=x;\n            d[x0]=dx;\n            for (y0=y,dy=0; s[y]!=y; dy+=d[y], y=s[y]);\n            s[y0]=y;\n            d[y0]=dy;\n            if (x==y && dy-dx!=z) {\n\t      fputs(\"No\\n\", stdout);\n\t      for (j=i+1;j<n;j++) fgets(buf, 64, stdin);\n\t      break;\n            }\n            s[y] = x;\n            d[y] = z + d[x0] - d[y0];\n        }\n\tif (i==n) fputs(\"Yes\\n\", stdout);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "\nfun main(args:Array<String>):Unit {\n    loop@while(true){\n        val n = readLine()!!.trim().toInt()\n        if (n == 0) return\n        val relation = Array(n){\n            val rel = readLine()!!.trim().split(' ')\n            Triple(rel[1], rel[3].split('^').last().toInt(), rel.last())\n        }\n        val map = mutableMapOf<String, UnionFindTree>()\n        for (i in 0 until n) {\n            val (left, diff, right) = relation[i]\n            if (map.getOrPut(left, { UnionFindTree() }).isNotParadoxical(map.getOrPut(right, { UnionFindTree() }), diff))\n                map[left]!!.merge(map[right]!!, diff)\n            else{\n                println(\"No\")\n                continue@loop\n            }\n        }\n        println(\"Yes\")\n\n    }\n}\nclass UnionFindTree{\n    private var mParent:UnionFindTree? = null\n    private var mPosition:Int = 0\n    private fun parent():Pair<Int, UnionFindTree> {\n        return when(mParent){\n            null -> Pair(0, this)\n            else -> {\n                val (d, p) = mParent!!.parent()\n                mPosition += d\n                mParent = p\n                Pair(mPosition, p)\n            }\n        }\n    }\n    fun isNotParadoxical(other:UnionFindTree, differ:Int):Boolean {\n        val (td, tp) = parent()\n        val (od, op) = other.parent()\n        return (tp != op) || (od + differ == td)\n    }\n    fun merge(other:UnionFindTree, differ:Int):Unit {\n        if (isNotParadoxical(other, differ)){\n            val (td, tp) = parent()\n            val (od, op) = other.parent()\n            if (tp != op){\n                tp.mParent = op\n                tp.mPosition = od - td + differ\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\n\npublic class Main {\n\t\n\tint n;\n\tString[] strs;\n\tHashMap<String, Integer> map;\n\tString[] ind2str;\n\tint NONVAL = (1<<28);\n\tint[][] d;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int c=0;;c++) {\n\t\t\tn = sc.nextInt();sc.nextLine();\n\t\t\tif(n ==0 ) break;\n\t\t\tstrs = new String[n];\n\t\t\tmap = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) strs[i] = sc.nextLine();\n\t\t\t\n\t\t\tif(c>29)debug(c);\n\t\t\tint p = 0;\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\tif(!map.containsKey(sp[1])) map.put(sp[1], p++);\n\t\t\t\tif(!map.containsKey(sp[4])) map.put(sp[4], p++);\n\t\t\t}\n\t\t\tint size = map.size();\n\t\t\td = new int[size][size];\n\t\t\tfor(int[] a: d) fill(a, NONVAL);\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\td[map.get(sp[1])][map.get(sp[4])] = Integer.parseInt(sp[3].substring(3));\n\t\t\t\td[map.get(sp[4])][map.get(sp[1])] = -Integer.parseInt(sp[3].substring(3));\n\t\t\t}\n\t\t\t\n\t\t\tn = size;\n\t\t\tfor(int i=0;i<n;i++) d[i][i] = 0;\n//\t\t\tdebug(d);\n\t\t\tboolean flg = true;\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\td[i][j] = min(d[i][k] + d[k][j], d[i][j]);\n\t\t\t}\n//\t\t\tdebug(d);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tflg &= d[i][i] < 0 ;\n\t\t\t}\n\t\t\tif(c>40)debug(flg);\n\t\t\tSystem.out.println((flg? \"No\": \"Yes\"));\n\t\t}\n\t\t\n\t}\n\n\tvoid debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tboolean noFlg = false;\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new HashMap< String, ArrayList<Edge> >();\n\n\t\t\twhile(n-- > 0){\n\t\t\t\tsc.next();\n\t\t\t\tString from = sc.next();\n\t\t\t\tsc.next();\n\t\t\t\tint cost = Integer.parseInt(sc.next().split(\"\\\\^\")[1]);\n\t\t\t\tString to = sc.next();\n\n\t\t\t\tif(noFlg) continue;\n\n\t\t\t\tint res = calCost(from,to,0,new HashSet<String>());\n\t\t\t\tif(res != Integer.MAX_VALUE && res != cost){\n\t\t\t\t\tnoFlg = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(map.get(from) == null) map.put(from,new ArrayList<Edge>());\n\t\t\t\tif(map.get(to) == null) map.put(to,new ArrayList<Edge>());\n\t\t\t\tmap.get(from).add(new Edge(from,to,cost));\n\t\t\t\tmap.get(to).add(new Edge(to,from,-cost));\n\t\t\t}\n\n\t\t\tSystem.out.println(noFlg ? \"No\" : \"Yes\");\n\t\t}\n\t}\n\n\tprivate static HashMap<String,ArrayList<Edge>> map;\n\n\tprivate static int calCost(String from,String to,int cost,HashSet<String> used){\n\t\tif(from.equals(to)) return cost;\n\t\tif(used.contains(from) || map.get(from) == null) return Integer.MAX_VALUE;\n\n\t\tused.add(from);\n\t\tfor(Edge e : map.get(from)){\n\t\t\tint res = calCost(e.to,to,cost+e.cost,used);\n\t\t\tif(res != Integer.MAX_VALUE) return res;\n\t\t}\n\n\t\treturn Integer.MAX_VALUE;\n\t}\n}\n\nclass Edge{\n\tString from,to;\n\tint cost;\n\n\tpublic Edge(String from,String to,int cost){\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic String toString(){\n\t\treturn String.format(\"[%s->%s,%d]\",from,to,cost);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "3\n1 km = 10^3 m\n1 m = 10^2 cm\n1 km = 10^5 cm\n7\n1 kilometre = 10^3 metre\n1 megametre = 10^3 kilometre\n1 metre = 10^-6 megametre\n1 terametre = 10^3 gigametre\n1 petametre = 10^3 terametre\n1 gigametre = 10^-6 petametre\n1 metre = 10^-15 petametre\n4\n1 a = 10^2 b\n1 a = 10^3 c\n1 b = 10^2 c\n1 c = 10^1 d\n4\n1 acm = 10^2 icpc\n1 icpc = 10^3 utpc\n1 utpc = 10^4 topcoder\n1 topcoder = 10^-1 acm\n0"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2207();\n\t}\n\tclass AOJ2207{\n\t\tint N;\n\t\tfinal int INF=1<<29;\n\t\tAOJ2207(){\n\t\t\twhile(true){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tArrayList<Edge> es=new ArrayList<Edge>();\n\t\t\tHashMap<String,Integer> map=new HashMap<String,Integer>();\n\t\t\tint kind=0;\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tsc.nextInt();\n\t\t\t\tString as=sc.next();\n\t\t\t\tint a=-1;\n\t\t\t\tif(map.containsKey(as))\ta=map.get(as);\n\t\t\t\telse{\n\t\t\t\t\ta=kind;\n\t\t\t\t\tmap.put(as, kind);\n\t\t\t\t\t++kind;\n\t\t\t\t}\n\t\t\t\tsc.next();\n\t\t\t\tint c=Integer.parseInt(sc.next().substring(3));\n\t\t\t\tString bs=sc.next();\n\t\t\t\tint b=-1;\n\t\t\t\tif(map.containsKey(bs))\tb=map.get(bs);\n\t\t\t\telse{\n\t\t\t\t\tb=kind;\n\t\t\t\t\tmap.put(bs, kind);\n\t\t\t\t\t++kind;\n\t\t\t\t}\n\t\t\t\tes.add(new Edge(a,b,c));\n\t\t\t\tes.add(new Edge(b,a,-c));\n\t\t\t}\n//\t\t\tSystem.out.println(es);\n\n\t\t\tbellmanFord bf=new bellmanFord(kind, es);\n\t\t\tObject obj=bf.shortestPath(0);\n\t\t\tSystem.out.println(obj==null? \"no\": \"yes\");\n\t\t}\n\t\tclass bellmanFord{\n\t\t\tfinal int INF=1<<29;\n\t\t\tint V,E;\n\t\t\tArrayList<Edge> es;\n\t\t\tint[] d;\n\t\t\tbellmanFord(int V,ArrayList<Edge> es){\n\t\t\t\tthis.V=V; this.es=es; this.E=es.size();\n\t\t\t}\n\t\t\t// startから到達可能な負の閉路があればnull．それ以外はstartからの最短経路．\n\t\t\tint[] shortestPath(int start){\n\t\t\t\td=new int[V];\n\t\t\t\tfor(int i=0; i<V; ++i)\td[i]=INF;\n\t\t\t\td[start]=0;\n\t\t\t\tfor(int i=1; i<=V; ++i){\n\t\t\t\t\tboolean update=false;\n\t\t\t\t\tfor(Edge e:es){\n\t\t\t\t\t\tif(d[e.from]<INF && d[e.to]>d[e.from]+e.cost){\n\t\t\t\t\t\t\td[e.to]=d[e.from]+e.cost;\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\tif(i==V)\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!update)\tbreak;\n\t\t\t\t}\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\tclass Edge implements Comparable<Edge>{\n\t\t\tint from,to,cost;\n\t\t\tEdge(int from,int to,int cost){\n\t\t\t\tthis.from=from;\tthis.to=to;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(Edge e){\n\t\t\t\treturn this.cost-e.cost;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn from+\"->\"+to+\":\"+cost;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.security.acl.Group;\nimport java.util.*;\n\n//@2207Problem D: ³µÈPÊn\npublic class Main {\n\n\t// 1 km = 10^3 m ÌÆ« kmÌsisuª0Å mª-3ÉÈé\n\tstatic class Tani {\n\t\tString name;\n\t\tint sisu;\n\t\tpublic Tani(String name, int sisu) {\n\t\t\tthis.name = name;\n\t\t\tthis.sisu = sisu;\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tList<Map<String, Tani>> group = new ArrayList<Map<String, Tani>>();\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tfor(;;) {\n\t\t\n\t\t\tString s = reader.readLine();\n\t\t\tint n = Integer.parseInt(s);\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tboolean mujun = false;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\ts = reader.readLine();\n\t\t\t\tString reg = \"1 ([a-z]+) = 10\\\\^(-?[0-9]*) ([a-z]+)\";\n\t\t\t\tString a = s.replaceAll(reg, \"$1\");\n\t\t\t\tString b = s.replaceAll(reg, \"$3\");\n\t\t\t\tint sisu = Integer.parseInt(s.replaceAll(reg, \"$2\"));\n//\t\t\t\tSystem.out.printf(\"%s\\n\", a);\n//\t\t\t\tSystem.out.printf(\"%s\\n\", b);\n//\t\t\t\tSystem.out.printf(\"%d\\n\", sisu);\n\n\t\t\t\tTani ta = null;\n\t\t\t\tTani tb = null;\n\t\t\t\tMap<String, Tani> mapa = null;\n\t\t\t\tMap<String, Tani> mapb = null;\n\t\t\t\tfor(int j = 0; j < group.size(); j++) { // SO[v©ç\n\t\t\t\t\tmapa = group.get(j);\n\t\t\t\t\tta = mapa.get(a);\n\t\t\t\t\tif (ta != null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < group.size(); j++) { // SO[v©ç\n\t\t\t\t\tmapb = group.get(j);\n\t\t\t\t\ttb = mapb.get(b);\n\t\t\t\t\tif (tb != null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ta == null && tb == null) {\n\t\t\t\t\t// VKo^\n\t\t\t\t\tMap<String, Tani> map = new HashMap<String, Tani>();\n\t\t\t\t\tmap.put(a, new Tani(a, 0));\n\t\t\t\t\tmap.put(b, new Tani(b, -sisu));\n\t\t\t\t\tgroup.add(map);\n\t\t\t\t}\n\t\t\t\telse if (tb == null) {\n\t\t\t\t\t// aªo^ÏÝ\n\t\t\t\t\tmapa.put(b, new Tani(b, -sisu + ta.sisu));\n\t\t\t\t}\n\t\t\t\telse if (ta == null) {\n\t\t\t\t\t// bªo^ÏÝ\n\t\t\t\t\tmapb.put(a, new Tani(a, sisu + tb.sisu));\n\t\t\t\t}\n\t\t\t\telse  { // ¼ûo^ÏÝ\n\t\t\t\t\tif (mapa == mapb) { // ¯êO[v\n\t\t\t\t\t\tif (ta.sisu - tb.sisu != sisu) { \n\t\t\t\t\t\t\tmujun = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse { // O[v¹\n\t\t\t\t\t\tfor(Map.Entry<String, Tani> entry: mapb.entrySet()) {\n\t\t\t\t\t\t\tTani t = entry.getValue();\n\t\t\t\t\t\t\tmapa.put(t.name, t);\n\t\t\t\t\t\t\tt.sisu += ta.sisu - tb.sisu - sisu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup.remove(mapb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%s\\n\", mujun?\"No\":\"Yes\");\n\t\t\t\n//\t\t\tSystem.out.printf(\"group num=%d\\n\", group.size());\n//\t\t\tfor(Map.Entry<String, Tani> entry: group.get(0).entrySet()) {\n//\t\t\t\tTani t = entry.getValue();\n//\t\t\t\tSystem.out.printf(\"%s %d\\n\", t.name, t.sisu);\n//\t\t\t}\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = Integer.valueOf(sc.nextLine());\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tint[][] cost = new int[200][200];\n\t\t\tfor(int i=0;i<200;i++) Arrays.fill(cost[i], Integer.MAX_VALUE);\n\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\tint p, q, r;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s = sc.nextLine().replace('^', ' ').split(\" \");\n\t\t\t\tif(list.contains(s[1])==false) list.add(s[1]);\n\t\t\t\tif(list.contains(s[5])==false) list.add(s[5]);\n\t\t\t\tp = list.indexOf(s[1]);\n\t\t\t\tq = list.indexOf(s[5]);\n\t\t\t\tr = Integer.valueOf(s[4]);\n\t\t\t\tcost[q][p] = r;\n\t\t\t\tcost[p][q] = -r;\n\t\t\t}\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\tint m = list.size();\n\t\t\tfor(int i=0;i<m;i++) cost[i][i] = 0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\t\tif(cost[j][i]!=Integer.MAX_VALUE && cost[i][k]!=Integer.MAX_VALUE){\n\t\t\t\t\t\t\tif(cost[j][k]==Integer.MAX_VALUE){\n\t\t\t\t\t\t\t\tcost[j][k] = cost[j][i]+cost[i][k];\n\t\t\t\t\t\t\t}else if(cost[j][k] != cost[j][i]+cost[i][k]){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tk = m;\n\t\t\t\t\t\t\t\tj = m;\n\t\t\t\t\t\t\t\ti = m;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag==false) System.out.println(\"Yes\");\n\t\t\telse System.out.println(\"No\");\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\n\npublic class Main {\n\t\n\tint n;\n\tString[] strs;\n\tHashMap<String, Integer> map;\n\tString[] ind2str;\n\tint NONVAL = -(1<<28);\n\tint[][] d;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();sc.nextLine();\n\t\t\tif(n ==0 ) break;\n\t\t\tstrs = new String[n];\n\t\t\tmap = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) strs[i] = sc.nextLine();\n\t\t\t\n\t\t\tint p = 0;\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\tif(!map.containsKey(sp[1])) map.put(sp[1], p++);\n\t\t\t\tif(!map.containsKey(sp[4])) map.put(sp[4], p++);\n\t\t\t}\n\t\t\tint size = map.size();\n\t\t\td = new int[size][size];\n\t\t\tfor(int[] a: d) fill(a, NONVAL);\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\td[map.get(sp[1])][map.get(sp[4])] = Integer.parseInt(sp[3].substring(3));\n\t\t\t\td[map.get(sp[4])][map.get(sp[1])] = -Integer.parseInt(sp[3].substring(3));\n\t\t\t}\n\t\t\t\n\t\t\tn = size;\n\t\t\tfor(int i=0;i<n;i++) d[i][i] = 0;\n\t\t\t\n//\t\t\tdebug(d);\n\t\t\t\n\t\t\tboolean flg = true;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tused = new boolean[n];\n\t\t\t\tdfs(i, 0, i);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) if( d[i][j] != -d[j][i] )flg = false;\n//\t\t\tfor(int[] a: d) debug(a);\n\t\t\tSystem.out.println((flg? \"Yes\": \"No\"));\n\t\t}\n\t\t\n\t}\n\t\n\tboolean flg;\n\tboolean[] used;\n\tvoid dfs(int i, int v, int r) {\n\t\tused[i] = true;\n\t\tfor(int j=0;j<n;j++) if( d[i][j] != NONVAL) {\n\t\t\tif(d[r][j] == NONVAL) {\n\t\t\t\td[r][j] = d[i][j] + v;\n\t\t\t}\n\t\t\tif(!used[j]) dfs(j, v + d[i][j], r);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    static int n;\n    static int[][] t;\n    static HashMap<String, Integer> map;\n    static final int MAX = 300;\n    static void init(){\n        map = new HashMap<String, Integer>();\n        t = new int[MAX][MAX];\n        for(int[] j : t) Arrays.fill(j, -1);\n    }\n    static int idxAt(String s){\n        if(!map.containsKey(s)){\n            map.put(s, map.size());\n        }\n        return map.get(s);\n    }\n\n    static void solve(){\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(t[i][k] == -1 || t[k][j] == -1 || !(i<k &&k<j)) continue;\n                    if(t[i][j] == -1) t[i][j] = t[i][k] + t[k][j];\n                    else if(t[i][j] != t[i][k] + t[k][j]){\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            }\n        }\n        out.println(\"Yes\");\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(in);\n        while(true){\n            n = sc.nextInt();\n            if(n == 0) break;\n\n            init();\n            for(int i=0;i<n;i++){\n                String a = sc.next();\n                String b = sc.next();\n                sc.next();\n                String c = sc.next();\n                String d = sc.next();\n\n                c = c.substring(c.indexOf(\"^\")+1);\n\n//                out.println(a +\" \" + b +\",\" + c + \" \" + d);\n\n                int ii = idxAt(b);\n                int jj = idxAt(d);\n\n                int cc = new Integer(c);\n                if(cc < 0){\n                    ii ^= jj; jj ^= ii; ii ^= jj;\n                    cc *= -1;\n                }\n\n                t[ii][jj] = cc;\n            }\n            n = map.size();\n            solve();\n        }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int MAX = 200;\n\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tMap<String, Integer> dict = new HashMap<String, Integer>();\n\t\t\n\t\tint[] from = new int[MAX];\n\t\tint[] to   = new int[MAX];\n\t\tint[] dist = new int[MAX];\n\t\tint[][] adj = new int[MAX][MAX];\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdict.clear();\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tsc.nextInt(); //1\n\t\t\t\t\n\t\t\t\t//A\n\t\t\t\tString from_str = sc.next();\n\t\t\t\tif(!dict.containsKey(from_str)){\n\t\t\t\t\tdict.put(from_str, count);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tfrom[i] = dict.get(from_str);\n\t\t\t\t\n\t\t\t\tsc.next(); //=\n\t\t\t\t\n\t\t\t\t//^~\n\t\t\t\tdist[i]= Integer.parseInt(sc.next().split(\"\\\\^\")[1]);\n\t\t\t\t\n\t\t\t\t//B\n\t\t\t\tString to_str = sc.next();\n\t\t\t\tif(!dict.containsKey(to_str)){\n\t\t\t\t\tdict.put(to_str, count);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tto[i] = dict.get(to_str);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\tfor(int j = 0; j < count; j++){\n\t\t\t\t\tadj[i][j] = i == j ? 0 : INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tadj[from[i]][to[i]] =  dist[i];\n\t\t\t\tadj[to[i]][from[i]] = -dist[i];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < count; k++){\n\t\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\t\tfor(int j = 0; j < count; j++){\n\t\t\t\t\t\tadj[i][j] = Math.min(adj[i][j], adj[i][k] + adj[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\tfor(int j = 0; j < count; j++){\n\t\t\t\t\tSystem.out.print(adj[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tboolean flag = false;\n\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\tif(adj[i][i] != 0){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(flag ? \"No\" : \"Yes\");\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\n\npublic class Main {\n\t\n\tint n;\n\tString[] strs;\n\tHashMap<String, Integer> map;\n\tString[] ind2str;\n\tint NONVAL = (1<<28);\n\tint[][] d;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int c=0;;c++) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n ==0 ) break;\n\t\t\tsc.nextLine();\n\t\t\tstrs = new String[n];\n\t\t\tmap = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) strs[i] = sc.nextLine();\n\t\t\t\n\t\t\tif(c>29)debug(c);\n\t\t\tint p = 0;\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\tif(!map.containsKey(sp[1])) map.put(sp[1], p++);\n\t\t\t\tif(!map.containsKey(sp[4])) map.put(sp[4], p++);\n\t\t\t}\n\t\t\tint size = map.size();\n\t\t\td = new int[size][size];\n\t\t\tfor(int[] a: d) fill(a, NONVAL);\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\td[map.get(sp[1])][map.get(sp[4])] = Integer.parseInt(sp[3].substring(3));\n\t\t\t\td[map.get(sp[4])][map.get(sp[1])] = -Integer.parseInt(sp[3].substring(3));\n\t\t\t}\n\t\t\t\n\t\t\tn = size;\n\t\t\tfor(int i=0;i<n;i++) d[i][i] = 0;\n//\t\t\tdebug(d);\n\t\t\tboolean flg = true;\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\td[i][j] = min(d[i][k] + d[k][j], d[i][j]);\n\t\t\t}\n//\t\t\tdebug(d);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tflg &= d[i][i] < 0 ;\n\t\t\t}\n\t\t\tif(c>40)debug(flg);\n\t\t\tSystem.out.println((flg? \"No\": \"Yes\"));\n\t\t}\n\t\t\n\t}\n\n\tvoid debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    static int n;\n    static int[][] t;\n    static HashMap<String, Integer> map;\n    static final int MAX = 300;\n    static final int INF = -(1<<29);\n    static void init(){\n        map = new HashMap<String, Integer>();\n        t = new int[MAX][MAX];\n        for(int[] j : t) Arrays.fill(j, INF);\n    }\n    static int idxAt(String s){\n        if(!map.containsKey(s)){\n            map.put(s, map.size());\n        }\n        return map.get(s);\n    }\n\n    static void solve(){\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(t[i][k] == INF || t[k][j] == INF) continue;\n                    if(t[i][j] == INF) t[i][j] = t[i][k] + t[k][j];\n                    else if(t[i][j] != t[i][k] + t[k][j]){\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            }\n        }\n        out.println(\"Yes\");\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(in);\n        while(true){\n            n = sc.nextInt();\n            if(n == 0) break;\n\n            init();\n            for(int i=0;i<n;i++){\n                String a = sc.next();\n                String b = sc.next();\n                sc.next();\n                String c = sc.next();\n                String d = sc.next();\n\n                c = c.substring(c.indexOf(\"^\")+1);\n\n                int ii = idxAt(b);\n                int jj = idxAt(d);\n\n\n                int cc = new Integer(c);\n                t[ii][jj] = cc;\n                t[jj][ii] = -cc;\n            }\n            n = map.size();\n            solve();\n        }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tString[][] tk = new String[n][5]; int p = 0;\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<5;j++)\n\t\t\t\ttk[i][j] = sc.next();\n\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif(!map.containsKey(tk[i][1])) map.put(tk[i][1], p++);\n\t\t\t\tif(!map.containsKey(tk[i][4])) map.put(tk[i][4], p++);\n\t\t\t}\n\n\t\t\tint[][] d = new int[p][p]; for(int[] a: d) fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\td[map.get(tk[i][1])][map.get(tk[i][4])] = Integer.parseInt(tk[i][3].substring(3));\n\t\t\t\td[map.get(tk[i][4])][map.get(tk[i][1])] = -Integer.parseInt(tk[i][3].substring(3));\n\t\t\t}\n\n\t\t\tfor(int i=0;i<p;i++) d[i][i] = 0;\n\n\t\t\tfor(int k=0;k<p;k++) for(int i=0;i<p;i++) for(int j=0;j<p;j++) {\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\n\t\t\tboolean flg = false;\n\t\t\tfor(int i=0;i<p;i++) flg |= d[i][i] < 0;\n\n\t\t\tSystem.out.println((flg? \"No\": \"Yes\"));\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.security.acl.Group;\nimport java.util.*;\n\n//@2207Problem D: ³µÈPÊn\npublic class Main {\n\n\t// 1 km = 10^3 m ÌÆ« kmÌsisuª0Å mª-3ÉÈé\n\tstatic class Tani {\n\t\tString name;\n\t\tint sisu;\n\t\tpublic Tani(String name, int sisu) {\n\t\t\tthis.name = name;\n\t\t\tthis.sisu = sisu;\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tList<Map<String, Tani>> group = new ArrayList<Map<String, Tani>>();\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tfor(;;) {\n\t\t\n\t\t\tString s = reader.readLine();\n\t\t\tint n = Integer.parseInt(s);\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tboolean mujun = false;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\ts = reader.readLine();\n\t\t\t\tString reg = \"1 ([a-z]+) = 10\\\\^(-?[0-9]*) ([a-z]+)\";\n\t\t\t\tString a = s.replaceAll(reg, \"$1\");\n\t\t\t\tString b = s.replaceAll(reg, \"$3\");\n\t\t\t\tint sisu = Integer.parseInt(s.replaceAll(reg, \"$2\"));\n//\t\t\t\tSystem.out.printf(\"%s\\n\", a);\n//\t\t\t\tSystem.out.printf(\"%s\\n\", b);\n//\t\t\t\tSystem.out.printf(\"%d\\n\", sisu);\n\n\t\t\t\tTani ta = null;\n\t\t\t\tTani tb = null;\n\t\t\t\tMap<String, Tani> mapa = null;\n\t\t\t\tMap<String, Tani> mapb = null;\n\t\t\t\tfor(int j = 0; j < group.size(); j++) { // SO[v©ç\n\t\t\t\t\tmapa = group.get(j);\n\t\t\t\t\tta = mapa.get(a);\n\t\t\t\t\tif (ta != null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < group.size(); j++) { // SO[v©ç\n\t\t\t\t\tmapb = group.get(j);\n\t\t\t\t\ttb = mapb.get(b);\n\t\t\t\t\tif (tb != null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ta == null && ta == null) {\n\t\t\t\t\t// VKo^\n\t\t\t\t\tMap<String, Tani> map = new HashMap<String, Tani>();\n\t\t\t\t\tmap.put(a, new Tani(a, 0));\n\t\t\t\t\tmap.put(b, new Tani(b, -sisu));\n\t\t\t\t\tgroup.add(map);\n\t\t\t\t}\n\t\t\t\telse if (tb == null) {\n\t\t\t\t\t// aªo^ÏÝ\n\t\t\t\t\tmapa.put(b, new Tani(b, -sisu + ta.sisu));\n\t\t\t\t}\n\t\t\t\telse if (ta == null) {\n\t\t\t\t\t// bªo^ÏÝ\n\t\t\t\t\tmapb.put(a, new Tani(a, sisu + tb.sisu));\n\t\t\t\t}\n\t\t\t\telse  { // ¼ûo^ÏÝ\n\t\t\t\t\tif (mapa == mapb) { // ¯êO[v\n\t\t\t\t\t\tif (ta.sisu - tb.sisu != sisu) { \n\t\t\t\t\t\t\tmujun = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse { // O[v¹\n\t\t\t\t\t\tfor(Map.Entry<String, Tani> entry: mapb.entrySet()) {\n\t\t\t\t\t\t\tTani t = entry.getValue();\n\t\t\t\t\t\t\tmapa.put(t.name, t);\n\t\t\t\t\t\t\tt.sisu += ta.sisu - tb.sisu - sisu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup.remove(mapb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%s\\n\", mujun?\"No\":\"Yes\");\t\t\t\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\n\npublic class Main {\n\t\n\tint n;\n\tString[] strs;\n\tHashMap<String, Integer> map;\n\tString[] ind2str;\n\tint NONVAL = (1<<28);\n\tint[][] d;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int c=0;;c++) {\n\t\t\tn = sc.nextInt();sc.nextLine();\n\t\t\tif(n ==0 ) break;\n\t\t\tstrs = new String[n];\n\t\t\tmap = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) strs[i] = sc.nextLine();\n\t\t\t\n\t\t\tdebug(c);\n\t\t\tint p = 0;\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\tif(!map.containsKey(sp[1])) map.put(sp[1], p++);\n\t\t\t\tif(!map.containsKey(sp[4])) map.put(sp[4], p++);\n\t\t\t}\n\t\t\tint size = map.size();\n\t\t\td = new int[size][size];\n\t\t\tfor(int[] a: d) fill(a, NONVAL);\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\td[map.get(sp[1])][map.get(sp[4])] = Integer.parseInt(sp[3].substring(3));\n\t\t\t\td[map.get(sp[4])][map.get(sp[1])] = -Integer.parseInt(sp[3].substring(3));\n\t\t\t}\n\t\t\t\n\t\t\tn = size;\n\t\t\tfor(int i=0;i<n;i++) d[i][i] = 0;\n//\t\t\tdebug(d);\n\t\t\tboolean flg = true;\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\td[i][j] = min(d[i][k] + d[k][j], d[i][j]);\n\t\t\t}\n//\t\t\tdebug(d);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tflg &= d[i][i] < 0 ;\n\t\t\t}\n\t\t\tdebug(flg);\n\t\t\tSystem.out.println((flg? \"No\": \"Yes\"));\n\t\t}\n\t\t\n\t}\n\n\tvoid debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\n\npublic class Main {\n\t\n\tint n;\n\tString[] strs;\n\tHashMap<String, Integer> map;\n\tString[] ind2str;\n\tint NONVAL = (1<<28);\n\tint[][] d;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int c=0;;c++) {\n\t\t\tdebug(c);\n\t\t\tn = sc.nextInt();sc.nextLine();\n\t\t\tif(n ==0 ) break;\n\t\t\tstrs = new String[n];\n\t\t\tmap = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) strs[i] = sc.nextLine();\n\t\t\t\n\t\t\tint p = 0;\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\tif(!map.containsKey(sp[1])) map.put(sp[1], p++);\n\t\t\t\tif(!map.containsKey(sp[4])) map.put(sp[4], p++);\n\t\t\t}\n\t\t\tint size = map.size();\n\t\t\td = new int[size][size];\n\t\t\tfor(int[] a: d) fill(a, NONVAL);\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\td[map.get(sp[1])][map.get(sp[4])] = Integer.parseInt(sp[3].substring(3));\n\t\t\t\td[map.get(sp[4])][map.get(sp[1])] = -Integer.parseInt(sp[3].substring(3));\n\t\t\t}\n\t\t\t\n\t\t\tn = size;\n\t\t\tfor(int i=0;i<n;i++) d[i][i] = 0;\n//\t\t\tdebug(d);\n\t\t\tboolean flg = true;\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\td[i][j] = min(d[i][k] + d[k][j], d[i][j]);\n\t\t\t}\n//\t\t\tdebug(d);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tflg &= d[i][i] < 0 ;\n\t\t\t}\n\t\t\tSystem.out.println((flg? \"No\": \"Yes\"));\n\t\t}\n\t\t\n\t}\n\n\tvoid debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.security.acl.Group;\nimport java.util.*;\n\n//@2207Problem D: ³µÈPÊn\npublic class Main {\n\n\t// 1 km = 10^3 m ÌÆ« kmÌsisuª0Å mª-3ÉÈé\n\tstatic class Tani {\n\t\tString name;\n\t\tint sisu;\n\t\tpublic Tani(String name, int sisu) {\n\t\t\tthis.name = name;\n\t\t\tthis.sisu = sisu;\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tfor(;;) {\n\t\t\tList<Map<String, Tani>> group = new ArrayList<Map<String, Tani>>();\n\t\t\n\t\t\tString s = reader.readLine();\n\t\t\tint n = Integer.parseInt(s);\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tboolean mujun = false;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\ts = reader.readLine();\n\t\t\t\tString reg = \"1 ([a-z]+) = 10\\\\^(-?[0-9]*) ([a-z]+)\";\n\t\t\t\tString a = s.replaceAll(reg, \"$1\");\n\t\t\t\tString b = s.replaceAll(reg, \"$3\");\n\t\t\t\tint sisu = Integer.parseInt(s.replaceAll(reg, \"$2\"));\n//\t\t\t\tSystem.out.printf(\"%s\\n\", a);\n//\t\t\t\tSystem.out.printf(\"%s\\n\", b);\n//\t\t\t\tSystem.out.printf(\"%d\\n\", sisu);\n\n\t\t\t\tTani ta = null;\n\t\t\t\tTani tb = null;\n\t\t\t\tMap<String, Tani> mapa = null;\n\t\t\t\tMap<String, Tani> mapb = null;\n\t\t\t\tfor(int j = 0; j < group.size(); j++) { // SO[v©ç\n\t\t\t\t\tmapa = group.get(j);\n\t\t\t\t\tta = mapa.get(a);\n\t\t\t\t\tif (ta != null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < group.size(); j++) { // SO[v©ç\n\t\t\t\t\tmapb = group.get(j);\n\t\t\t\t\ttb = mapb.get(b);\n\t\t\t\t\tif (tb != null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ta == null && tb == null) {\n\t\t\t\t\t// VKo^\n\t\t\t\t\tMap<String, Tani> map = new HashMap<String, Tani>();\n\t\t\t\t\tmap.put(a, new Tani(a, 0));\n\t\t\t\t\tmap.put(b, new Tani(b, -sisu));\n\t\t\t\t\tgroup.add(map);\n\t\t\t\t}\n\t\t\t\telse if (tb == null) {\n\t\t\t\t\t// aªo^ÏÝ\n\t\t\t\t\tmapa.put(b, new Tani(b, -sisu + ta.sisu));\n\t\t\t\t}\n\t\t\t\telse if (ta == null) {\n\t\t\t\t\t// bªo^ÏÝ\n\t\t\t\t\tmapb.put(a, new Tani(a, sisu + tb.sisu));\n\t\t\t\t}\n\t\t\t\telse  { // ¼ûo^ÏÝ\n\t\t\t\t\tif (mapa == mapb) { // ¯êO[v\n\t\t\t\t\t\tif (ta.sisu - tb.sisu != sisu) { \n\t\t\t\t\t\t\tmujun = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse { // O[v¹\n\t\t\t\t\t\tfor(Map.Entry<String, Tani> entry: mapb.entrySet()) {\n\t\t\t\t\t\t\tTani t = entry.getValue();\n\t\t\t\t\t\t\tmapa.put(t.name, t);\n\t\t\t\t\t\t\tt.sisu += ta.sisu - tb.sisu - sisu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup.remove(mapb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (group.size() > 1)\n\t\t\t\tmujun = true;\n\t\t\tSystem.out.printf(\"%s\\n\", mujun ? \"No\" : \"Yes\");\n\t\t\t\n\t\t\tif (false) {\n\t\t\t\tSystem.out.printf(\"group num=%d\\n\", group.size());\n\t\t\t\tfor(Map.Entry<String, Tani> entry: group.get(0).entrySet()) {\n\t\t\t\t\tTani t = entry.getValue();\n\t\t\t\t\tSystem.out.printf(\"%s %d\\n\", t.name, t.sisu);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    static int n;\n    static int[][] t;\n    static HashMap<String, Integer> map;\n    static final int MAX = 300;\n    static void init(){\n        map = new HashMap<String, Integer>();\n        t = new int[MAX][MAX];\n        for(int[] j : t) Arrays.fill(j, -1);\n    }\n    static int idxAt(String s){\n        if(!map.containsKey(s)){\n            map.put(s, map.size());\n        }\n        return map.get(s);\n    }\n\n    static void solve(){\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(t[i][k] == -1 || t[k][j] == -1 || !(i<k&&k<j)) continue;\n                    if(t[i][j] == -1) t[i][j] = t[i][k] + t[k][j];\n                    else if(t[i][j] != t[i][k] + t[k][j]){\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            }\n        }\n        out.println(\"Yes\");\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(in);\n        while(true){\n            n = sc.nextInt();\n            if(n == 0) break;\n\n            init();\n            for(int i=0;i<n;i++){\n                String a = sc.next();\n                String b = sc.next();\n                sc.next();\n                String c = sc.next();\n                String d = sc.next();\n\n                c = c.substring(c.indexOf(\"^\")+1);\n\n//                out.println(a +\" \" + b +\",\" + c + \" \" + d);\n\n                int ii = idxAt(b);\n                int jj = idxAt(d);\n\n                int cc = new Integer(c);\n                if(ii > jj){\n                    ii ^= jj; jj ^= ii; ii ^= jj;\n                    cc *= -1;\n                }\n//                if(cc < 0){\n//                    ii ^= jj; jj ^= ii; ii ^= jj;\n//                    cc *= -1;\n//                }\n\n                t[ii][jj] = cc;\n            }\n//            out.println(map);\n            n = map.size();\n            solve();\n        }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2207();\n\t}\n\tclass AOJ2207{\n\t\tint N;\n\t\tfinal int INF=1<<29;\n\t\tAOJ2207(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tArrayList<Edge> es=new ArrayList<Edge>();\n\t\t\tHashMap<String,Integer> map=new HashMap<String,Integer>();\n\t\t\tint kind=0;\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tsc.nextInt();\n\t\t\t\tString as=sc.next();\n\t\t\t\tint a=-1;\n\t\t\t\tif(map.containsKey(as))\ta=map.get(as);\n\t\t\t\telse{\n\t\t\t\t\ta=kind;\n\t\t\t\t\tmap.put(as, kind);\n\t\t\t\t\t++kind;\n\t\t\t\t}\n\t\t\t\tsc.next();\n\t\t\t\tint c=Integer.parseInt(sc.next().substring(3));\n\t\t\t\tString bs=sc.next();\n\t\t\t\tint b=-1;\n\t\t\t\tif(map.containsKey(bs))\tb=map.get(bs);\n\t\t\t\telse{\n\t\t\t\t\tb=kind;\n\t\t\t\t\tmap.put(bs, kind);\n\t\t\t\t\t++kind;\n\t\t\t\t}\n\t\t\t\tes.add(new Edge(a,b,c));\n\t\t\t\tes.add(new Edge(b,a,-c));\n\t\t\t}\n//\t\t\tSystem.out.println(es);\n\n\t\t\tbellmanFord bf=new bellmanFord(map.size(), es);\n\t\t\tfor(int i=0; i<map.size(); ++i)if(bf.shortestPath(i)==null){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}\n\t\tclass bellmanFord{\n\t\t\tfinal int INF=1<<29;\n\t\t\tint V,E;\n\t\t\tArrayList<Edge> es;\n\t\t\tint[] d;\n\t\t\tbellmanFord(int V,ArrayList<Edge> es){\n\t\t\t\tthis.V=V; this.es=es; this.E=es.size();\n\t\t\t}\n\t\t\t// startから到達可能な負の閉路があればnull．それ以外はstartからの最短経路．\n\t\t\tint[] shortestPath(int start){\n\t\t\t\td=new int[V];\n\t\t\t\tfor(int i=0; i<V; ++i)\td[i]=INF;\n\t\t\t\td[start]=0;\n\t\t\t\tfor(int i=1; i<=V; ++i){\n\t\t\t\t\tboolean update=false;\n\t\t\t\t\tfor(Edge e:es){\n\t\t\t\t\t\tif(d[e.from]<INF && d[e.to]>d[e.from]+e.cost){\n\t\t\t\t\t\t\td[e.to]=d[e.from]+e.cost;\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\tif(i==V)\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!update)\tbreak;\n\t\t\t\t}\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\tclass Edge implements Comparable<Edge>{\n\t\t\tint from,to,cost;\n\t\t\tEdge(int from,int to,int cost){\n\t\t\t\tthis.from=from;\tthis.to=to;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(Edge e){\n\t\t\t\treturn this.cost-e.cost;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn from+\"->\"+to+\":\"+cost;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    static int n;\n    static int[][] t;\n    static HashMap<String, Integer> map;\n\n    static void init(){\n        map = new HashMap<String, Integer>();\n        t = new int[n][n];\n        for(int[] i : t) Arrays.fill(i, -1);\n    }\n    static int idxAt(String s){\n        if(!map.containsKey(s)){\n            map.put(s, map.size());\n        }\n        return map.get(s);\n    }\n\n    static void solve(){\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(t[i][k] == -1 || t[k][j] == -1 || !(i<k &&k<j)) continue;\n                    if(t[i][j] == -1) t[i][j] = t[i][k] + t[k][j];\n                    else if(t[i][j] != t[i][k] + t[k][j]){\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            }\n        }\n        out.println(\"Yes\");\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(in);\n        while(true){\n            n = sc.nextInt();\n            if(n == 0) break;\n\n            init();\n            for(int i=0;i<n;i++){\n                String a = sc.next();\n                String b = sc.next();\n                sc.next();\n                String c = sc.next();\n                String d = sc.next();\n\n                c = c.substring(c.indexOf(\"^\")+1);\n\n                int ii = idxAt(b);\n                int jj = idxAt(d);\n\n                int cc = new Integer(c);\n                if(cc < 0){\n                    ii ^= jj; jj ^= ii; ii ^= jj;\n                    cc *= -1;\n                }\n                t[ii][jj] = cc;\n            }\n            solve();\n        }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "3\n1 km = 10^3 m\n1 m = 10^2 cm\n1 km = 10^5 cm\n7\n1 kilometre = 10^3 metre\n1 megametre = 10^3 kilometre\n1 metre = 10^-6 megametre\n1 terametre = 10^3 gigametre\n1 petametre = 10^3 terametre\n1 gigametre = 10^-6 petametre\n1 metre = 10^-15 petametre\n4\n1 a = 10^2 b\n1 a = 10^3 c\n1 b = 10^2 c\n1 c = 10^1 d\n4\n1 acm = 10^2 icpc\n1 icpc = 10^3 utpc\n1 utpc = 10^4 topcoder\n1 topcoder = 10^-1 acm\n0"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\n\npublic class Main {\n\t\n\tint n;\n\tString[] strs;\n\tHashMap<String, Integer> map;\n\tString[] ind2str;\n\tint NONVAL = (1<<28);\n\tint[][] d;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int c=0;;c++) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0 ) break;\n\t\t\tsc.nextLine();\n\t\t\tstrs = new String[n];\n\t\t\tmap = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) strs[i] = sc.nextLine();\n\t\t\t\n//\t\t\tif(c>29)debug(c);\n\t\t\tint p = 0;\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\tif(!map.containsKey(sp[1])) map.put(sp[1], p++);\n\t\t\t\tif(!map.containsKey(sp[4])) map.put(sp[4], p++);\n\t\t\t}\n\t\t\tint size = map.size();\n\t\t\td = new int[size][size];\n\t\t\tfor(int[] a: d) fill(a, NONVAL);\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\td[map.get(sp[1])][map.get(sp[4])] = Integer.parseInt(sp[3].substring(3));\n\t\t\t\td[map.get(sp[4])][map.get(sp[1])] = -Integer.parseInt(sp[3].substring(3));\n\t\t\t}\n\t\t\t\n\t\t\tn = size;\n\t\t\tfor(int i=0;i<n;i++) d[i][i] = 0;\n//\t\t\tdebug(d);\n\t\t\tboolean flg = true;\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\td[i][j] = min(d[i][k] + d[k][j], d[i][j]);\n\t\t\t}\n//\t\t\tdebug(d);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tflg &= d[i][i] < 0 ;\n\t\t\t}\n//\t\t\tif(c>40)debug(flg);\n\t\t\tSystem.out.println((flg? \"No\": \"Yes\"));\n\t\t}\n\t\t\n\t}\n\n\tvoid debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Consistet Unit System\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint id = 0;\n\t\t\tMap<String, Integer> ref = new HashMap<String, Integer>();\n\t\t\tint[][] cost = new int[2*n][2*n];\n\t\t\tfor(int[]c:cost)Arrays.fill(c, 1<<28);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tsc.next();\n\t\t\t\tString s = sc.next();\n\t\t\t\tif(!ref.containsKey(s)){\n\t\t\t\t\tref.put(s, id++);\n\t\t\t\t}\n\t\t\t\tint to = ref.get(s);\n\t\t\t\tsc.next();\n\t\t\t\tString[] num = sc.next().split(\"\\\\^\");\n\t\t\t\tint c = Integer.parseInt(num[1]);\n\t\t\t\ts = sc.next();\n\t\t\t\tif(!ref.containsKey(s))ref.put(s, id++);\n\t\t\t\tint from = ref.get(s);\n\t\t\t\tcost[from][to] = c;\n\t\t\t\tcost[to][from] = -c;\n\t\t\t}\n\t\t\tint[][] wf = new int[id][id];\n\t\t\tfor(int[] w:wf)Arrays.fill(w, 1<<28);\n\t\t\tfor(int i=0;i<id;i++)for(int j=0;j<id;j++)wf[i][j]=cost[i][j];\n\t\t\tfor(int k=0;k<id;k++){\n\t\t\t\tfor(int i=0;i<id;i++){\n\t\t\t\t\tfor(int j=0;j<id;j++){\n\t\t\t\t\t\twf[i][j] = Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<id;i++){\n\t\t\t\tfor(int j=0;j<id;j++){\n\t\t\t\t\tif(cost[i][j]!=1<<28 && wf[i][j] < cost[i][j]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(f?\"Yes\":\"No\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Queue;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Consistet Unit System\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint N = parseInt(line);\n\t\t\tif (N == 0) break;\n\n\t\t\tString std = \"\";\n\t\t\tMap<String, Integer> convs = new HashMap<>();\n\t\t\tQueue<Tuple> queue = new ArrayDeque<>();\n\t\t\tboolean ans = true;\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\twords = br.readLine().split(\"[ ^]\");\n\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tstd = words[1];\n\t\t\t\t\tconvs.put(words[5], parseInt(words[4]));\n\t\t\t\t} else {\n\t\t\t\t\tif (parseInt(words[4]) > 0) {\n\t\t\t\t\t\tqueue.add(new Tuple(words[1], words[5], parseInt(words[4])));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.add(new Tuple(words[5], words[1], -parseInt(words[4])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (!queue.isEmpty()) {\n\n\t\t\t\tTuple t = queue.poll();\n\n\t\t\t\tString u = \"\";\n\t\t\t\tint e = 0;\n\n\t\t\t\tif (t.u1.equals(std)) {\n\t\t\t\t\tu = t.u2;\n\t\t\t\t\te = t.e;\n\t\t\t\t} else if (t.u2.equals(std)) {\n\t\t\t\t\tu = t.u1;\n\t\t\t\t\te = -t.e;\n\t\t\t\t} else if (convs.containsKey(t.u1)) {\n\t\t\t\t\tu = t.u2;\n\t\t\t\t\te = convs.get(t.u1) + t.e;\n\t\t\t\t} else if (convs.containsKey(t.u2)) {\n\t\t\t\t\tu = t.u1;\n\t\t\t\t\te = convs.get(t.u2) - t.e;\n\t\t\t\t} else {\n\t\t\t\t\tqueue.offer(t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (u.equals(\"\")) {\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\n\t\t\t\tif (!convs.containsKey(u)) {\n\t\t\t\t\tconvs.put(u, e);\n\t\t\t\t} else {\n\t\t\t\t\tif (convs.get(u) != e) {\n\t\t\t\t\t\tans = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(ans ? \"Yes\" : \"No\");\n\t\t\t\n\t\t}\n\t}\n}\n\nclass Tuple {\n\tString u1, u2;\n\tint e;\n\n\tpublic Tuple(String u1, String u2, int e) {\n\t\tthis.u1 = u1;\n\t\tthis.u2 = u2;\n\t\tthis.e = e;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tPattern pt = Pattern.compile(\"10\\\\^(-?[0-9]+)\");\n\t\tMatcher mc = pt.matcher(\"\");\n\t\tList<String> unitList = new ArrayList<String>();\n\t\tint n;\n\t\twhile (in.hasNext()) {\n\t\t\tn = in.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tunitList.clear();\n\t\t\tInteger[][] data = new Integer[n * 2][n * 2];\n\t\t\tint size = 0;\n\t\t\tString unit1, unit2;\n\t\t\tInteger x;\n\t\t\tboolean yes = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin.next();\n\t\t\t\tunit1 = String.valueOf(in.next());\n\t\t\t\tin.next();\n\t\t\t\tmc.reset(in.next()).matches();\n\t\t\t\tx = Integer.valueOf(mc.group(1));\n\t\t\t\tunit2 = String.valueOf(in.next());\n\t\t\t\tif (yes) {\n\t\t\t\t\tif (!unitList.contains(unit1)) {\n\t\t\t\t\t\tunitList.add(unit1);\n\t\t\t\t\t\tint num = size++;\n\t\t\t\t\t\tdata[num][num] = Integer.valueOf(0);\n\t\t\t\t\t}\n\t\t\t\t\tif (!unitList.contains(unit2)) {\n\t\t\t\t\t\tunitList.add(unit2);\n\t\t\t\t\t\tint num = size++;\n\t\t\t\t\t\tdata[num][num] = Integer.valueOf(0);\n\t\t\t\t\t}\n\t\t\t\t\tfinal int from = unitList.indexOf(unit1);\n\t\t\t\t\tfinal int to = unitList.indexOf(unit2);\n\t\t\t\t\tint max = Math.max(from, to);\n\t\t\t\t\ta: for (int a = 0; a <= max; a++) {\n\t\t\t\t\t\tInteger pickVal = data[to][a];\n\t\t\t\t\t\tif (pickVal != null) {\n\t\t\t\t\t\t\tInteger newVal = Integer.valueOf(pickVal + x);\n\t\t\t\t\t\t\tif (data[from][a] != null\n\t\t\t\t\t\t\t\t\t&& !data[from][a].equals(newVal)) {\n\t\t\t\t\t\t\t\tyes = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int c = 0; c < a; c++) {\n\t\t\t\t\t\t\t\tif (newVal.equals(data[from][c])) {\n\t\t\t\t\t\t\t\t\tyes = false;\n\t\t\t\t\t\t\t\t\tbreak a;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdata[from][a] = newVal;\n\t\t\t\t\t\t\tdata[a][from] = Integer.valueOf(-newVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(yes ? \"Yes\" : \"No\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int MAX = 200;\n\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tMap<String, Integer> dict = new HashMap<String, Integer>();\n\t\t\n\t\tint[] from = new int[MAX];\n\t\tint[] to   = new int[MAX];\n\t\tint[] dist = new int[MAX];\n\t\tint[][] adj = new int[MAX][MAX];\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdict.clear();\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tsc.nextInt(); //1\n\t\t\t\t\n\t\t\t\t//A\n\t\t\t\tString from_str = sc.next();\n\t\t\t\tif(!dict.containsKey(from_str)){\n\t\t\t\t\tdict.put(from_str, count);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tfrom[i] = dict.get(from_str);\n\t\t\t\t\n\t\t\t\tsc.next(); //=\n\t\t\t\t\n\t\t\t\t//^~\n\t\t\t\tdist[i]= Integer.parseInt(sc.next().split(\"\\\\^\")[1]);\n\t\t\t\t\n\t\t\t\t//B\n\t\t\t\tString to_str = sc.next();\n\t\t\t\tif(!dict.containsKey(to_str)){\n\t\t\t\t\tdict.put(to_str, count);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tto[i] = dict.get(to_str);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\tfor(int j = 0; j < count; j++){\n\t\t\t\t\tadj[i][j] = i == j ? 0 : INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tadj[from[i]][to[i]] =  dist[i];\n\t\t\t\tadj[to[i]][from[i]] = -dist[i];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < count; k++){\n\t\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\t\tfor(int j = 0; j < count; j++){\n\t\t\t\t\t\tadj[i][j] = Math.min(adj[i][j], adj[i][k] + adj[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\tfor(int j = 0; j < count; j++){\n\t\t\t\t\tSystem.out.print(adj[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tboolean flag = false;\n\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\tfor(int j = i + 1; j < count; j++){\n\t\t\t\t\tif(adj[i][j] != -adj[j][i]){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(flag ? \"No\" : \"Yes\");\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.security.acl.Group;\nimport java.util.*;\n\n//@2207Problem D: ³µÈPÊn\npublic class Main {\n\n\t// 1 km = 10^3 m ÌÆ« kmÌsisuª0Å mª-3ÉÈé\n\tstatic class Tani {\n\t\tString name;\n\t\tint sisu;\n\t\tpublic Tani(String name, int sisu) {\n\t\t\tthis.name = name;\n\t\t\tthis.sisu = sisu;\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tfor(;;) {\n\t\t\tList<Map<String, Tani>> group = new ArrayList<Map<String, Tani>>();\n\t\t\n\t\t\tString s = reader.readLine();\n\t\t\tint n = Integer.parseInt(s);\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tboolean mujun = false;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\ts = reader.readLine();\n\t\t\t\tString reg = \"1 ([a-z]+) = 10\\\\^(-?[0-9]*) ([a-z]+)\";\n\t\t\t\tString a = s.replaceAll(reg, \"$1\");\n\t\t\t\tString b = s.replaceAll(reg, \"$3\");\n\t\t\t\tint sisu = Integer.parseInt(s.replaceAll(reg, \"$2\"));\n//\t\t\t\tSystem.out.printf(\"%s\\n\", a);\n//\t\t\t\tSystem.out.printf(\"%s\\n\", b);\n//\t\t\t\tSystem.out.printf(\"%d\\n\", sisu);\n\n\t\t\t\tTani ta = null;\n\t\t\t\tTani tb = null;\n\t\t\t\tMap<String, Tani> mapa = null;\n\t\t\t\tMap<String, Tani> mapb = null;\n\t\t\t\tfor(int j = 0; j < group.size(); j++) { // SO[v©ç\n\t\t\t\t\tmapa = group.get(j);\n\t\t\t\t\tta = mapa.get(a);\n\t\t\t\t\tif (ta != null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < group.size(); j++) { // SO[v©ç\n\t\t\t\t\tmapb = group.get(j);\n\t\t\t\t\ttb = mapb.get(b);\n\t\t\t\t\tif (tb != null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ta == null && tb == null) {\n\t\t\t\t\t// VKo^\n\t\t\t\t\tMap<String, Tani> map = new HashMap<String, Tani>();\n\t\t\t\t\tmap.put(a, new Tani(a, 0));\n\t\t\t\t\tmap.put(b, new Tani(b, -sisu));\n\t\t\t\t\tgroup.add(map);\n\t\t\t\t}\n\t\t\t\telse if (tb == null) {\n\t\t\t\t\t// aªo^ÏÝ\n\t\t\t\t\tmapa.put(b, new Tani(b, -sisu + ta.sisu));\n\t\t\t\t}\n\t\t\t\telse if (ta == null) {\n\t\t\t\t\t// bªo^ÏÝ\n\t\t\t\t\tmapb.put(a, new Tani(a, sisu + tb.sisu));\n\t\t\t\t}\n\t\t\t\telse  { // ¼ûo^ÏÝ\n\t\t\t\t\tif (mapa == mapb) { // ¯êO[v\n\t\t\t\t\t\tif (ta.sisu - tb.sisu != sisu) { \n\t\t\t\t\t\t\tmujun = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse { // O[v¹\n\t\t\t\t\t\tfor(Map.Entry<String, Tani> entry: mapb.entrySet()) {\n\t\t\t\t\t\t\tTani t = entry.getValue();\n\t\t\t\t\t\t\tmapa.put(t.name, t);\n\t\t\t\t\t\t\tt.sisu += ta.sisu - tb.sisu - sisu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup.remove(mapb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%s\\n\", mujun ? \"No\" : \"Yes\");\n\t\t\t\n//\t\t\tSystem.out.printf(\"group num=%d\\n\", group.size());\n//\t\t\tfor(Map.Entry<String, Tani> entry: group.get(0).entrySet()) {\n//\t\t\t\tTani t = entry.getValue();\n//\t\t\t\tSystem.out.printf(\"%s %d\\n\", t.name, t.sisu);\n//\t\t\t}\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    static int n;\n    static int[][] t;\n    static HashMap<String, Integer> map;\n    static final int MAX = 300;\n    static final int INF = -(1<<29);\n    static void init(){\n        map = new HashMap<String, Integer>();\n        t = new int[MAX][MAX];\n        for(int[] j : t) Arrays.fill(j, INF);\n    }\n    static int idxAt(String s){\n        if(!map.containsKey(s)){\n            map.put(s, map.size());\n        }\n        return map.get(s);\n    }\n\n    static void solve(){\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(t[i][k] == INF || t[k][j] == INF || !(i<k&&k<j)) continue;\n                    if(t[i][j] == INF) t[i][j] = t[i][k] + t[k][j];\n                    else if(t[i][j] != t[i][k] + t[k][j]){\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            }\n        }\n        out.println(\"Yes\");\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(in);\n        while(true){\n            n = sc.nextInt();\n            if(n == 0) break;\n\n            init();\n            for(int i=0;i<n;i++){\n                String a = sc.next();\n                String b = sc.next();\n                sc.next();\n                String c = sc.next();\n                String d = sc.next();\n\n                c = c.substring(c.indexOf(\"^\")+1);\n\n//                out.println(a +\" \" + b +\",\" + c + \" \" + d);\n\n                int ii = idxAt(b);\n                int jj = idxAt(d);\n\n                int cc = new Integer(c);\n                if(ii > jj){\n                    ii ^= jj; jj ^= ii; ii ^= jj;\n                    cc *= -1;\n                }\n//                if(cc < 0){\n//                    ii ^= jj; jj ^= ii; ii ^= jj;\n//                    cc *= -1;\n//                }\n\n                t[ii][jj] = cc;\n            }\n//            out.println(map);\n            n = map.size();\n            solve();\n        }\n    }\n\n}"
  },
  {
    "language": "Ruby",
    "code": "loop {\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tunit_system = []\n\tok = true\n\tn.times {\n\t\tgets.chomp =~ /^1 (\\w+) = 10\\^(-?\\d+) (\\w+)/\n\t\tnext unless ok\n\t\tu1, x, u2 = $1, $2.to_i, $3\n\t\tus1 = unit_system.find{|us| us[u1]}\n\t\tus2 = unit_system.find{|us| us[u2]}\n\t\tif !us1 && !us2\n\t\t\tunit_system << {u1 => 0, u2 => x}\n\t\telsif !us1\n\t\t\tus2[u1] = us2[u2] - x\t\n\t\telsif !us2\n\t\t\tus1[u2] = us1[u1] + x\t\n\t\telsif us1 == us2\n\t\t\tif us1[u1] + x != us2[u2]\n\t\t\t\tok = false\n\t\t\tend\n\t\telse\n\t\t\tunit_system.delete(us2)\n\t\t\tus2.each{|u3, pos|\n\t\t\t\ty = pos - us2[u2]\n\t\t\t\tus1[u3] = us1[u1] + x + y\n\t\t\t}\n\t\tend\n\t}\n\tputs ok ? 'Yes' : 'No'\n}"
  },
  {
    "language": "Ruby",
    "code": "loop {\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tunit_system = []\n\tok = true\n\tn.times {\n\t\tgets =~ /^1 (\\w+) = 10\\^(-?\\d+) (\\w+)/\n\t\tnext unless ok\n\t\tu1, x, u2 = $1, $2.to_i, $3\n\t\tus1 = unit_system.find{|us| us[u1]}\n\t\tus2 = unit_system.find{|us| us[u2]}\n\t\tif !us1 && !us2\n\t\t\tunit_system << {u1 => 0, u2 => x}\n\t\telsif !us1\n\t\t\tif us2[u1]\n\t\t\t\tok = false\n\t\t\t\tnext\n\t\t\tend\n\t\t\tus2[u1] = us2[u2] - x\t\n\t\telsif !us2\n\t\t\tif us1[u2]\n\t\t\t\tok = false\n\t\t\t\tnext\n\t\t\tend\n\t\t\tus1[u2] = us1[u1] + x\t\n\t\telsif us1 == us2\n\t\t\tif us1[u1] + x != us2[u2]\n\t\t\t\tok = false\n\t\t\t\tnext\n\t\t\tend\n\t\telse\n\t\t\tunit_system.delete(us2)\n\t\t\tus2.each{|u3, pos|\n\t\t\t\ty = pos - us2[u2]\n\t\t\t\tif us1.values.include?(x+y)\n\t\t\t\t\tok = false\n\t\t\t\t\tnext\n\t\t\t\tend\n\t\t\t\tus1[u3] = x + y\n\t\t\t}\n\t\tend\n\t}\n\tputs ok ? 'Yes' : 'No'\n}"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = int(input())\n    if n == 0:break\n    m = []\n    f = 1\n    for _ in range(n):\n        _, a, _, v, b = input().split()\n        v = int(v[3:])\n        x, y = -1, -1\n        for i in range(len(m)):\n            if a in m[i]:x = i\n            if b in m[i]:y = i\n        if x >= 0:\n            if y >= 0:\n                if x == y:\n                    if m[x][a] - v != m[x][b]:f = 0\n                else:\n                    for i in m[y]:\n                        m[x][i] = m[y][i] + m[x][a] - m[y][b] - v\n                    m.pop(y)\n            else:\n                m[x][b] = m[x][a] - v\n        elif y >= 0:\n            m[y][a] = m[y][b] + v\n        else:\n            m.append({a:v, b:0})\n    print(\"yes\" if f else \"no\")\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nclass WeightedUnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.weight = [0] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            px = self.find(self.parents[x])\n            self.weight[x] += self.weight[self.parents[x]]\n            self.parents[x] = px\n            return px\n\n    def union(self, x, y, w):\n        w += self.weight[x] - self.weight[y]\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y, w = y, x, -w\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        self.weight[y] = w\n        return\n\n    def weig(self, x):\n        self.find(x)\n        return self.weight[x]\n\n    def diff(self, x, y):\n        return self.weig(y) - self.weig(x)\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nwhile 1:\n    n = int(input())\n    if n == 0:\n        exit()\n    Q, d = [], set()\n    while n:\n        _, a, _, p, b = input().split()\n        Q += (a, b, int(p[3:])),\n        d |= {a, b}\n        n -= 1\n    D = {c : e for e, c in enumerate(d)}\n    UF = WeightedUnionFind(len(d))\n    for a, b, p in Q:\n        a, b = D[a], D[b]\n        if UF.same(a, b):\n            if p != UF.diff(a, b):\n                print(\"No\"); break\n        else:\n            UF.union(a, b, p)\n    else:\n        print(\"Yes\")\n"
  },
  {
    "language": "Python",
    "code": "defnum=999999999\n\ndef parse_input(line):\n    [one, lname, eq, scale, rname] = line.split()\n    exp=int( scale.split(\"^\")[-1] )\n    return lname, exp, rname\n\nwhile(1):\n    N=int(raw_input())\n    if N==0: break\n    L=[]\n    names=[]\n    for i in range(N):\n        [lname, exp, rname]=parse_input(raw_input())\n        names += [lname, rname]\n        L.append([lname, rname, exp])\n    names=sorted(set(names))\n    m=len(names)\n    A=[[defnum if i!=j else 0 for i in range(m)] for j in range(m)]\n    ans=\"Yes\"\n    for l in L:\n        li,ri = [names.index(name) for name in l[:2]]\n        exp=l[2]\n        #add\n        if A[li][ri] == defnum:\n            A[li][ri] = exp\n            A[ri][li] = -exp\n            for ab in[ [li,ri], [ri,li] ]:\n                a,b=ab\n                for x in range(m):\n                    if A[b][x]!=defnum:\n                        A[a][x] = A[a][b]+A[b][x]\n                        A[x][a] = -A[a][x]\n        else:\n            if A[li][ri]!=exp:\n                ans=\"No\"\n                break\n    print ans\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n  n = int(input())\n  if n == 0:break\n  dic = {}\n  for _ in range(n):\n    _, name1, _, val, name2 = input().split()\n    val = int(val.split(\"^\")[1])\n    if name1 not in dic:\n      dic[name1] = {}\n    if name2 not in dic:\n      dic[name2] = {}\n    dic[name1][name2] = val\n    dic[name2][name1] = -val\n  \n  keys = list(dic.keys())\n  score = {key:None for key in keys}\n  \n  def search(key):\n    now = score[key]\n    for to in dic[key]:\n      if score[to] == None:\n        score[to] = now + dic[key][to]\n        if not search(to):return False\n      if score[to] != now + dic[key][to]:return False\n    return True\n  \n  for key in keys:\n    if score[key] != None:continue\n    score[key] = 0\n    if not search(key):\n      print(\"No\")\n      break\n  else:\n    print(\"Yes\")\n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFind(object):\n    __slots__ = [\"nodes\", \"weight\"]\n\n    def __init__(self, n: int) -> None:\n        self.nodes = [-1]*n\n        self.weight = [0]*n\n\n    def get_root(self, x: int) -> int:\n        if x < 0:\n            raise ValueError(\"Negative Index\")\n\n        if self.nodes[x] < 0:\n            return x\n        else:\n            root = self.get_root(self.nodes[x])\n            self.weight[x] += self.weight[self.nodes[x]]\n            self.nodes[x] = root\n            return root\n\n    def relate(self, smaller: int, bigger: int, diff_weight: int) -> None:\n        if smaller < 0 or bigger < 0:\n            raise ValueError(\"Negative Index\")\n\n        root_a, root_b = self.get_root(smaller), self.get_root(bigger)\n        new_weight = diff_weight + self.weight[smaller] - self.weight[bigger]\n\n        if root_a == root_b:\n            # 問題によっては必要かも（情報に矛盾があるなら-1を出力など）\n            if self.weight[smaller] + diff_weight == self.weight[bigger]:\n                return\n            raise ValueError(\"relateに矛盾あり\")\n\n        if self.nodes[root_a] > self.nodes[root_b]:\n            root_a, root_b, new_weight = root_b, root_a, -new_weight\n\n        self.nodes[root_a] += self.nodes[root_b]\n        self.nodes[root_b] = root_a\n        self.weight[root_b] = new_weight\n\n    def diff(self, x: int, y: int) -> int:\n        root_x, root_y = self.get_root(x), self.get_root(y)\n        if root_x != root_y:\n            return None\n        return self.weight[y] - self.weight[x]\n\n\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    uf, d = WeightedUnionFind(N*2), dict()\n    queries = [input().split() for _ in [0]*N]\n    try:\n        for _, a, _, n, b in queries:\n            n = int(n[3:])\n            d[a] = d[a] if a in d else len(d)\n            d[b] = d[b] if b in d else len(d)\n            uf.relate(d[a], d[b], n)\n        print(\"Yes\")\n    except ValueError as e:\n        print(\"No\")\n\n"
  },
  {
    "language": "Python",
    "code": "defnum=999999999\n\ndef parse_input(line):\n    [one, lname, eq, scale, rname] = line.split()\n    exp=int( scale.split(\"^\")[-1] )\n    return lname, exp, rname\n\nwhile(1):\n    N=int(raw_input())\n    if N==0: break\n    L=[]\n    names=[]\n    for i in range(N):\n        [lname, exp, rname]=parse_input(raw_input())\n        names += [lname, rname]\n        L.append([lname, rname, exp])\n    names=sorted(set(names))\n    m=len(names)\n    A=[[defnum if i!=j else 0 for i in range(m)] for j in range(m)]\n    ans=\"Yes\"\n    for l in L:\n        li,ri = [names.index(name) for name in l[:2]]\n        exp=l[2]\n        #add\n        if A[li][ri] == defnum:\n            A[li][ri] = exp\n            A[ri][li] = -exp\n            for ab in[ [li,ri], [ri,li] ]:\n                a,b=ab\n                for y in range(m):\n                    for x in range(m):\n                        if A[y][a]!= defnum and A[b][x]!=defnum:\n                            A[y][x] = A[y][a]+A[a][b]+A[b][x]\n                            A[x][y] = -A[y][x]\n        else:\n            if A[li][ri]!=exp:\n                ans=\"No\"\n                break\n#    print names\n#    for al in A:\n#        print al\n    print ans\n\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = int(input())\n    if n == 0:break\n    m = []\n    f = 1\n    for _ in range(n):\n        _, a, _, v, b = input().split()\n        v = int(v[3:])\n        x, y = -1, -1\n        for i in range(len(m)):\n            if a in m[i]:x = i\n            if b in m[i]:y = i\n        if x >= 0:\n            if y >= 0:\n                if x == y:\n                    if m[x][a] - v != m[x][b]:f = 0\n                else:\n                    for i in m[y]:\n                        m[x][i] = m[y][i] + m[x][a] - m[y][b] - v\n                    m.pop(y)\n            else:\n                m[x][b] = m[x][a] - v\n        elif y >= 0:\n            m[y][a] = m[y][b] + v\n        else:\n            m.append({a:v, b:0})\n    print(\"Yes\" if f else \"No\")\n"
  }
]