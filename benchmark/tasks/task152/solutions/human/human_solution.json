[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\nbool used[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  const int base=50;\n  int m[101][101]={};\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[i+oy+base][j+ox+base]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[ny+base][nx+base];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 全体のビット右にをシフト\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[cy+base][cx+base];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 下方向にビットをシフト\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[cy+base][cx+base];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nconst int INF=(1<<30);\nint dfs(int cy,int cx,int mask,int my,int mx){\n  if(used[cy][cx][mask][my][mx])return dp[cy][cx][mask][my][mx];\n  int res=-INF;\n  int leftK=K-(my+mx);\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n      int nmask=p.first;\n      int nAddVal=p.second;\n      if(leftK>0&&(i==0||i==3))\n        res=max(res,dfs(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))+nAddVal);\n      else if((i==1||i==2))\n        res=max(res,dfs(ny,nx,nmask,my,mx)+nAddVal);\n    }\n  }\n  if(cy==H-1&&cx==W-1)res=max(res,0);\n  used[cy][cx][mask][my][mx]=true;\n  return dp[cy][cx][mask][my][mx]=res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,(1<<6),0,0)<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define INF 1234567890\n\nint map[60][60];\nchar buf;\nint x_max, y_max, can;\nint ans = 0;\n\nint dp(int x, int y, int can){\n\tif (map[x][y] == -1) return 0;\n\tint before = map[x][y];\n\tint answer = 0;\n\tmap[x][y] = 0;\n\tif (map[x][y - 1] >= 0 && can >= 1) answer = max(answer, dp(x, y - 1, can - 1));\n\tif (map[x][y + 1] >= 0) answer = max(answer, dp(x, y + 1, can));\n\tif (map[x - 1][y] >= 0 && can >= 1) answer = max(answer, dp(x - 1, y, can - 1));\n\tif (map[x + 1][y] >= 0) answer = max(answer, dp(x + 1, y, can));\n\tmap[x][y] = before;\n\tif (x == x_max && y == x_max) return answer + before;\n\treturn answer + before;\n}\n\nint main(){\n\tmemset(map, 255, sizeof(map));\n\tscanf(\"%d%d%d\", &x_max, &y_max, &can);\n\tfor (int a = 1; a <= x_max; a++){\n\t\tfor (int b = 1; b <= y_max; b++){\n\t\t\tscanf(\" %c\", &buf);\n\t\t\tswitch (buf){\n\t\t\tcase '.':\n\t\t\t\tmap[a][b] = 0;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tmap[a][b] = -1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmap[a][b] = (int)buf - (int)'0';\n\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp(1, 1, can));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n\nusing namespace std;\n\nint main()\n{\n  int n[3]; \n  int a = 0, b = 0, c = 0;\n  while(true)\n  {\n    cin >> n[0] >> n[1] >> n[2];\n    sort(n, n + 3);\n    if(n[0] + n[1] <= n[2])\n    {\n      printf(\"%d %d %d %d\\n\", a + b + c, a, b, c);\n      return 0;\n    }\n    double d = pow(n[0], 2) + pow(n[1], 2), v = pow(n[2], 2);\n    \n    if(d == v)\n      a++;\n    else if(d > v)\n      b++;\n    else if(d < v)\n      c++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[50][51];\n\n#define inv(d) (((d)+2)&3) // opposite direction\n\nint dp[50][50][4][4][4][4][4][4][4];\nint dfs(int i,int j,int k,int d0,int d1,int d2,int d3,int d4,int d5){\n\tint &res=dp[i][j][k][d0][d1][d2][d3][d4][d5];\n\tif(~res) return res;\n\n\tif(i==h-1 && j==w-1) res=0; // goal\n\n\tint y[6],x[6];\n\ty[0]=  i +dy[inv(d0)]; x[0]=  j +dx[inv(d0)];\n\ty[1]=y[0]+dy[inv(d1)]; x[1]=x[0]+dx[inv(d1)];\n\ty[2]=y[1]+dy[inv(d2)]; x[2]=x[1]+dx[inv(d2)];\n\ty[3]=y[2]+dy[inv(d3)]; x[3]=x[2]+dx[inv(d3)];\n\ty[4]=y[3]+dy[inv(d4)]; x[4]=x[3]+dx[inv(d4)];\n\ty[5]=y[4]+dy[inv(d5)]; x[5]=x[4]+dx[inv(d5)];\n\n\trep(d,4){\n\t\tint ii=i+dy[d],jj=j+dx[d],kk=k;\n\t\tif(d==1 || d==2) kk--;\n\t\tif(kk<0) continue;\n\t\tif(0<=ii && ii<h && 0<=jj && jj<w && B[ii][jj]!='#'){\n\t\t\tbool vis=false;\n\t\t\trep(l,6) if(ii==y[l] && jj==x[l]) vis=true;\n\t\t\tres=max(res,dfs(ii,jj,kk,d,d0,d1,d2,d3,d4)+(vis||B[ii][jj]=='.'?0:B[ii][jj]-'0'));\n\t\t}\n\t}\n\n\tif(res==-1) res=-INF;\n\n\treturn res;\n}\n\nint main(){\n\tint k; scanf(\"%d%d%d\",&h,&w,&k);\n\trep(i,h) scanf(\"%s\",B[i]);\n\n\tmemset(dp,-1,sizeof dp);\n\tprintf(\"%d\\n\",dfs(0,0,k,3,3,3,3,3,3));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// JOI 2012-2013 予選6\n#include<algorithm>\n#include<map>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<cstring>\n\ntypedef std::pair<int, int> P;\n\nconst int INF = 1 << 30;\n\nint H, W, K;\nchar field[50][51];\n\nstd::map<std::vector<P>, int> memo[51][51][4];\nint rec( int x, int y, int k, std::vector<P>& visited )\n{\n\tif( k < 0 )\n\t\treturn -INF;\n\n\tstd::vector<P> p;\n\tfor( int i = 0; i != visited.size(); ++i )\n\t\t\tif( std::max( x - visited[i].first, 0 ) + std::max( y - visited[i].second, 0 ) <= k )\n\t\t\t\tp.push_back( visited[i] );\n\n\tstd::sort( p.begin(), p.end() );\n\tvisited = p;\n\n\tif( memo[x][y][k].count( visited ) )\n\t\treturn memo[x][y][k][visited];\n\n\tint ret = -INF;\n\n\tif( x == H - 1 && y == W - 1 )\n\t\tret = 0;\n\n\tstatic const int dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\n\n\tfor( int d = 0; d != 4; ++d )\n\t{\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tint nk = d >= 2 ? k - 1 : k;\n\n\t\tif( nx < 0 || nx >= H || ny < 0 || ny >= W || field[nx][ny] == '#' )\n\t\t\tcontinue;\n\n\t\tint val = 0;\n\t\tstd::vector<P> nv = visited;\n\t\tif( !std::binary_search( visited.begin(), visited.end(), P( nx, ny ) ) )\n\t\t{\n\t\t\tval = field[ny][nx] - '0';\n\t\t\tnv.push_back( P( nx, ny ) );\n\t\t}\n\n\t\tret = std::max( ret, rec( nx, ny, nk, nv ) + val );\n\t}\n\n\treturn memo[x][y][k][visited] = ret;\n}\n\nint main()\n{\n\tstd::cin >> H >> W >> K;\n\tfor( int i = 0; i != H; ++i )\n\t{\n\t\tfor( int j = 0; j != W; ++j )\n\t\t{\n\t\t\tstd::cin >> field[i];\n\n\t\t\tif( field[i][j] == '.' ) field[i][j] = '0';\n\t\t}\n\t}\n\n\tstd::cout << rec( 0, 0, K, std::vector<P>() ) << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  map<pii,int> m;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[pii(i+oy,j+ox)]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[pii(ny,nx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // テ・ツ?ィテ、ツスツ禿」ツ?ョテ」ツδ禿」ツδε」ツδ暗・ツ渉ウテ」ツ?ォテ」ツつ津」ツつキテ」ツδ陛」ツδ?\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // テ、ツクツ凝ヲツ鳴ケテ・ツ青妥」ツ?ォテ」ツδ禿」ツδε」ツδ暗」ツつ津」ツつキテ」ツδ陛」ツδ?\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nstruct Sit{\n  int cy,cx,mask,my,mx;\n  Sit(){}\n  Sit(int cy_,int cx_,int mask_,int my_,int mx_){\n    cy=cy_;\n    cx=cx_;\n    mask=mask_;\n    my=my_;\n    mx=mx_;\n  }\n  bool operator<(const Sit&sit)const{\n    return true;\n  }\n};\ntypedef pair<int,Sit> iSit;\n\nint dijkstra(){\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][1<<6][0][0]=0;\n  priority_queue<iSit> pq;\n  pq.push(make_pair(0,Sit(0,0,1<<6,0,0)));\n  while(pq.size()){\n    iSit is=pq.top();pq.pop();\n    int cval=is.first;\n    Sit cSit=is.second;\n    int cy=cSit.cy,cx=cSit.cx,mask=cSit.mask,my=cSit.my,mx=cSit.mx;\n    if(dp[cy][cx][mask][my][mx]>cval)continue;\n    int leftK=K-(my+mx);\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n        pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n        int nmask=p.first;\n        int nAddVal=p.second;\n        if(leftK>0&&(i==0||i==3)&&dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]<cval+nAddVal){\n          dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))));\n        }\n        else if((i==1||i==2)&&dp[ny][nx][nmask][my][mx]<cval+nAddVal){\n          dp[ny][nx][nmask][my][mx]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my,mx)));\n        }\n      }\n    }\n  }\n  int res=0;\n  for(int mask=0;mask<(1<<10);mask++)\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        res=max(res,dp[H-1][W-1][mask][i][j]);\n  return res;\n}\n\nint main(){\n  ifstream cin(\"in.txt\");\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[5][50][50][1 << 12];\nint H, W, K;\nchar mas[50][50];\nint dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint mask;\n \nint getdir(int bit, int i){\n  return bit >> (i << 1) & 3;\n}\nbool isover(int y, int x){\n  return y < 0 || y >= H || x < 0 || x >= W;\n}\nint main()\n{\n  cin >> H >> W >> K;\n  mask = (1 << (K * 2 * 2)) - 1;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      cin >> mas[i][j];\n    }\n  }\n  fill_n( ***dp, 5 * 50 * 50 * 1 << 12, -1);\n  dp[K][0][0][0] = 0;\n\n  for(int mul = K ; mul >= 0; mul--){\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        for(int bit = 0; bit < 1 << (K * 4) ; bit++){ // 前の街\n          if(dp[mul][y][x][bit] == -1 || mas[y][x] == '#') continue;\n          int my = y, mx = x, cost = 0;\n          bool flag = false;\n          if(mas[y][x] != '.'){\n            for(int i = 0; i < 2 * K; i++){\n              my -= dy[getdir( bit, i)];\n              mx -= dx[getdir( bit, i)];\n              if(my == y && mx == x){\n                flag = true;\n                break;\n              }\n            }\n            if(!flag) cost = mas[y][x] - '0';\n          }\n          for(int i = 0; i < 4; i++){\n            int ny = y + dy[i], nx = x + dx[i];\n            if(ny < 0 || ny >= H || nx < 0 || nx >= W || mas[ny][nx] == '#') continue;\n            if(mul == 0 && i >= 2) break;\n            int& next = dp[mul - (i >= 2)][ny][nx][(bit << 2 | i) & mask];\n            next = max( next, dp[mul][y][x][bit] + cost);\n          }\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < 1 << (4 * K) ; i++){\n    ret = max( ret, dp[0][H - 1][W - 1][i]);\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nint H, W, K;\nchar map[50][50];\nint dp[4][1<<12][50][50]; // 00: s, 01: n, 10: e, 11: w\n\nbool twice(int prev_d){\n    int px = 0, py = 0;\n    for(int i=0;i<6;i++){\n        int d = prev_d >> (i*2) & 0x3;\n        px -= dx[d];\n        py -= dy[d];\n        //printf(\"%d, %d\\n\", px, py);\n        if(px == 0 && py == 0){return true;}\n    }\n    return false;\n}\n\nint rec(int k, int prev_d, int x, int y){\n    if(x == W-1 && y == H-1 && k == K){return 0;}\n\n    if(dp[k][prev_d][y][x] != -1){return dp[k][prev_d][y][x];}\n\n    //printf(\"%d, %d, %d\\n\", x, y, k);\n\n    int res = 0, omiyage = (isdigit(map[y][x]) && !twice(prev_d)) * (map[y][x]-'0');\n\n    if(k < K){\n        REP(i, 4){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx && nx < W && 0 <= ny && ny < H && map[ny][nx] != '#'){\n                int nprev_d = (prev_d << 2 | i) & 0xfff;\n                res = std::max(res, omiyage + rec(k+1, nprev_d, nx, ny));\n            }\n        }\n    }\n    \n    FOR(i, 0, 2){\n        int nx = x + dx[i*2], ny = y + dy[i*2];\n        if(0 <= nx && nx < W && 0 <= ny && ny < H && map[ny][nx] != '#'){\n            int nprev_d = (prev_d << 2 | (i * 2)) & 0xfff;\n            res = std::max(res, omiyage + rec(k, nprev_d, nx, ny));\n        }\n    }\n\n    return dp[k][prev_d][x][y] = res;\n}\n\nint main(){\n    std::cin >> H >> W >> K;\n\n    REP(i, H){\n        REP(j, W){\n            std::cin >> map[i][j];\n        }\n    }\n\n    REP(i, 4){\n        REP(j, 1<<12){\n            REP(k, H){\n                REP(l, W){\n                    dp[i][j][k][l] = -1;\n                }\n            }\n        }\n    }\n\n    int res = rec(0, 0, 0, 0);\n\n    std::cout << res << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 60\n#define MAX_K 3\n#define MAX_D 6\n#define MAX_C 4096\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\nint dp[MAX_N][MAX_N][MAX_K + 1][MAX_C];\nint x[MAX_N][MAX_N];\nint h, w, K, a;\nchar c;\nchar T[12] = \".123456789#\";\nint b[MAX_N][MAX_N];\nint gx[6], gy[6];\n\nint hantei(int p, int q, vector<int>r) {\n\tint v = p, w = q;\n\tfor (int o = 5; o >= 0; o--) {\n\t\tv -= dy[r[o]];\n\t\tw -= dx[r[o]];\n\t\tgy[o] = v; gx[o] = w;\n\t}\n\tfor (int o = 0; o <= 5; o++) {\n\t\tif (p == gy[o] && q == gx[o]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint DP() {\n\tint X, Y, F, G, H, dir[6], maxn;\n\n\t//zentansaku(first 6)\n\tfor (int i = 0; i < 4096; i++) {\n\t\tmemset(b, 0, sizeof(b));\n\t\tX = 1; Y = 1;\n\t\tF = 0; G = 0;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\ta = (i / (int)pow(4, j)) % 4;\n\t\t\tX += dx[a]; Y += dy[a];\n\t\t\tif (x[Y][X] == 10) {\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif (G == 2 || G == 3) {\n\t\t\t\tG++;\n\t\t\t}\n\t\t\tif (b[Y][X] == 1) {\n\t\t\t\tF += x[Y][X];\n\t\t\t}\n\t\t\tb[Y][X] = 1;\n\t\t}\n\t\tif (G <= K) {\n\t\t\tdp[Y][X][G][i] = F;\n\t\t}\n\tE:;\n\t}\n\n\t//dp.\n\tfor (int i = 0; i < h + w - 5; i++) {\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\tif (x[j][k] <= 9) {\n\n\t\t\t\t\tfor (int l = 0; l <= k; l++) {\n\t\t\t\t\t\tfor (int m = 0; m < MAX_C; m++) {\n\t\t\t\t\t\t\tif (dp[i][j][k][l] >= 0) {\n\n\t\t\t\t\t\t\t\tfor (int n = 0; n < 6; n++) {\n\t\t\t\t\t\t\t\t\tdir[i] = (m / (int)pow(4, n)) % 4;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (l <= K) {\n\t\t\t\t\t\t\t\t\tif (x[j - 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 2048;\n\n\t\t\t\t\t\t\t\t\t\tif (hantei(j - 1, k, { dir[1],dir[2],dir[3],dir[4],dir[5],2 }) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j - 1][k];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tX = j; Y = k;\n\n\t\t\t\t\t\t\t\t\t\tdp[j - 1][k][l + 1][a] = max(dp[j - 1][k][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (x[j][k - 1] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 3072;\n\n\n\t\t\t\t\t\t\t\t\t\tif (hantei(j, k - 1, { dir[1],dir[2],dir[3],dir[4],dir[5],3 }) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j][k - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tdp[j][k - 1][l + 1][a] = max(dp[j][k - 1][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j + 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (hantei(j + 1, k, { dir[1],dir[2],dir[3],dir[4],dir[5],0 }) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j + 1][k];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j + 1][k][l][a] = max(dp[j + 1][k][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j][k + 1] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ta += 1024;\n\n\t\t\t\t\t\t\t\t\tif (hantei(j, k + 1, { dir[1],dir[2],dir[3],dir[4],dir[5],1 }) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j][k + 1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j][k + 1][l][a] = max(dp[j][k + 1][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmaxn = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tfor (int j = 0; j < MAX_C; j++) {\n\t\t\tmaxn = max(maxn, dp[h][w][i][j]);\n\t\t}\n\t}\n\treturn maxn;\n}\n\nint main() {\n\t//shokika.\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_K; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_C; l++) {\n\t\t\t\t\tdp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tx[i][j] = 10;\n\t\t}\n\t}\n\t//cin.\n\tcin >> h >> w >> K;\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tcin >> c;\n\t\t\tfor (int k = 0; k < 11; k++) {\n\t\t\t\tif (c == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n //#define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n      \n\nint zen=(1<<12)-1;\nint ban[60][60];\nint n,m,k;\nint dp[1<<12][51][51][4];\n\nint dfs(int B,int x,int y,int d){\n\tif(dp[B][x][y][d]!=-inf) return dp[B][x][y][d];\n\tint ans=-1;\n\tif(x==n && y==m && d==k){\n\t\tdp[B][x][y][d]=0;\n\t\treturn 0;\n\t}\n\t\n\tset<pa> se;\n\tint sx=x,sy=y;\n\tint BB=B;\n\tfor(int i=0;i<6;i++){\n\t\tint t=(BB&3);\n\t\tif(t==0)sy--;\n\t\tif(t==1)sx--;\n\t\tif(t==2)sy++;\n\t\tif(t==3)sx++;\n\t\tse.insert(mp(sx,sy));\n\t\tBB=(BB>>2);\n\t}\n\tfor(int r=0;r<4;r++){\n\t\tint xx=x+dx[r],yy=y+dy[r];\n\t\tif(ban[xx][yy]==-1) continue;\n\t\tif(dx[r]+dy[r]<0 && d==k) continue;\n\n\t\t{\n\t\t\tint ka=0;\n\t\t\tif(se.find(mp(xx,yy))==se.end())ka=ban[xx][yy];\n\t\t\tint g=dfs(((B<<2)&zen)+r,xx,yy,d+(dx[r]+dy[r]<0?1:0));\n\t\t\tif(g>=0)ans=max(ans,g+ka);\n\t\t}\n\t}\n\tdp[B][x][y][d]=ans;\n\t//if(ans>=0)cout<<bitset<12>(B)<<\" \"<<x<<\" \"<<y<<\" \"<<d<<\"  \"<<ans<<endl;\n\treturn ans;\n}\n\n\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\n\n  \tcin>>n>>m>>k;\n  \tfor(int i=0;i<(1<<12);i++)for(int j=0;j<=50;j++)for(int l=0;l<=50;l++)for(int t=0;t<=3;t++){\n  \t\tdp[i][j][l][t]=-inf;\n  \t}\n  \t\n  \tfor(int i=0;i<=n+1;i++)for(int j=0;j<=m+1;j++)ban[i][j]=-1;\n  \t\n  \tfor(int i=1;i<=n;i++){\n  \t\tstring s;\n  \t\tcin>>s;\n  \t\ts=\"s\"+s;\n  \t\tfor(int j=1;j<=m;j++){\n  \t\t\tif(s[j]=='.')ban[i][j]=0;\n  \t\t\telse if(s[j]=='#')ban[i][j]=-1;\n  \t\t\telse ban[i][j]=s[j]-'0';\n  \t\t\t\n  \t\t}\n  \t}\n  \tint ans=dfs(0,1,1,0);\n  \tcout<<ans<<endl;\n  \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,K;\nint fld[50][50];\nint memo[50][50][4][1<<12];\nconst int dy[]={0,1,-1,0};\nconst int dx[]={1,0,0,-1};\nbool out(int y,int x){\n    return y<0||y>=H||x<0||x>=W;\n}\n\nint dfs(int y,int x,int cnt,int S){\n    if(memo[y][x][cnt][S]!=-1)return memo[y][x][cnt][S];\n    memo[y][x][cnt][S]=-2;\n    int ret=0;\n    int ty=y,tx=x;\n    bool flag=true;\n    for(int i=0;i<6;i++){\n        int cur=(S>>(i*2))&3;\n        ty-=dy[cur];\n        tx-=dx[cur];\n        if(ty==y&&tx==x)flag=false;\n    }\n\n    for(int i=0;i<4;i++){\n        if(i>=2&&cnt>=K)continue;\n        ty=y+dy[i];\n        tx=x+dx[i];\n        if(out(ty,tx))continue;\n        if(fld[ty][tx]==-1)continue;\n        int tS=(S<<2)%(1<<(K*4));\n        ret=max(ret,dfs(ty,tx,cnt+(i>=2?1:0),tS|i));\n    }\n\n    if(flag)ret+=fld[y][x];\n    return memo[y][x][cnt][S]=ret;\n}\nint main(){\n    scanf(\"%d%d%d\",&H,&W,&K);\n    for(int i=0;i<H;i++){\n        char str[50];\n        scanf(\"%s\",str);\n        for(int j=0;j<W;j++){\n            int val;\n            if(str[j]=='#')val=-1;\n            else if(str[j]=='.')val=0;\n            else val=str[j]-'0';\n            fld[i][j]=val;\n        }\n    }\n    fill_n(***memo,50*50*4*(1<<12),-1);\n    printf(\"%d\\n\",dfs(0,0,0,0));\n\n    return 0;\n    int ma=0;\n    for(int i=0;i<=K;i++){\n        for(int j=0;j<(1<<(K*2));j++){\n            ma=max(ma,memo[H-1][W-1][i][j]);\n        }\n    }\n    printf(\"%d\\n\",ma);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n\nconst int INF = 1 << 30;\n\nint W, H, K;\n// 00 → 右 01 → 下 10 → 左 11 → 上\nint memo[1 << 12][4][50][50];\nint dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\nchar field[50][50];\nint mask;\n\nint rec( int bit, int k, int y, int x )\n{\n\tif( memo[bit][k][y][x] != -1 )\n\t\treturn memo[bit][k][y][x];\n\n\tif( y == H - 1 && x == W - 1 && !k )\n\t\treturn 0;\n\n\tint tx = x, ty = y;\n\tbool f = false;\n\tfor( int i = 0; i != 2 * K; ++i )\n\t{\n\t\ttx -= dx[( bit >> ( 2 * i ) ) & 3];\n\t\tty -= dy[( bit >> ( 2 * i ) ) & 3];\n\n\t\tif( tx == x && ty == y )\n\t\t{\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint ret = 0;\n\t\n\tif( !f && field[y][x] >= '0' && field[y][x] <= '9' )\n\t\tret += field[y][x] - '0';\n\n\tint ans = -INF;\n\n\tfor( int i = 0; i != 4; ++i )\n\t{\n\t\tif( !k && i >= 2 )\n\t\t\tbreak;\n\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif( nx >= 0 && nx < W && ny >= 0 && ny < H && field[ny][nx] != '#' )\n\t\t\tans = std::max( ans, rec( ( ( bit << 2 ) | i ) & mask, k - ( i >= 2 ), ny, nx ) + ret ); \n\t}\n\n\treturn memo[bit][k][y][x] = ans;\n}\n\nint main()\n{\n\tstd::cin >> H >> W >> K;\n\n\tmask = ( 1 << ( 4 * K ) ) - 1;\n\n\tfor( int i = 0; i != H; ++i )\n\t\tfor( int j = 0; j != W; ++j )\n\t\t\tstd::cin >> field[i][j];\n\n\tmemset( memo, -1, sizeof( memo ) );\n\tint ans = rec( 0, K, 0, 0 );\n\tstd::cout << ( ans < 0 ? 0 : ans ) << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\ntypedef pair<int, int> p;\n\nint k;\nvector<string> ban;\n\nvoid move(int i, int j, int time, map<vector<p>, int> &before, map<vector<p>, int> &after, bool turn) {\n    for (auto back:before) {\n        vector<p> now;\n        bool shouldAdd = '0' <= ban[i][j] && ban[i][j] <= '9';\n        for (auto place:back.first) {\n            if (turn || place.first + place.second >= i + j - (k - time))now.push_back(place);\n            if (place.first == i && place.second == j)shouldAdd = false;\n        }\n        if (shouldAdd)now.push_back(p(i, j));\n\n        int cost = back.second + (shouldAdd ? ban[i][j] - '0' : 0);\n        if (after.find(now) == after.end() || after[now] < cost) after[now] = cost;\n    }\n}\n\nint main() {\n    int h, w;\n    cin >> h >> w >> k;\n    ban = vector<string>(h);\n    for (int i = 0; i < h; i++)cin >> ban[i];\n\n    vector<vector<map<vector<p>, int>>> dp(h, vector<map<vector<p>, int>>(w, map<vector<p>, int>()));\n    dp[0][0][{}] = 0;\n\n    for (int time = 0; time <= k; time++) {\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (ban[i][j] == '#')continue;\n\n                if (i - 1 >= 0) { //down\n                    move(i, j, time, dp[i - 1][j], dp[i][j], false);\n                }\n                if (j - 1 >= 0) { //right\n                    move(i, j, time, dp[i][j - 1], dp[i][j], false);\n                }\n            }\n        }\n\n        if (time == k) break;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (ban[i][j] == '#')continue;\n\n                if (i + 1 < h) { // up\n                    move(i, j, time, dp[i + 1][j], dp[i][j], true);\n                }\n                if (j + 1 < w) { // left\n                    move(i, j, time, dp[i][j + 1], dp[i][j], true);\n                }\n            }\n        }\n    }\n\n    int ret = -1145141919;\n    for (auto x:dp[h - 1][w - 1]) ret = max(ret, x.second);\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nll vx[4]={1,0,-1,0};\nll vy[4]={0,1,0,-1};\nstruct T{\n\tll y,x,k,s;\n};\nqueue<T> q;\nll dp[50][50][4][1<<11];\nstring str[50];\nll s[50][50];\nll W,H,K;\nll z;\nll S;\nll add;\nll k;\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&H,&W,&K);\n\tmemset(dp,-1,sizeof(dp));\n\tfor(ll i=0;i<H;i++){\n\t\tcin>>str[i];\n\t\tfor(ll j=0;j<W;j++){\n\t\t\tif(str[i][j]=='#') s[i][j]=-1;\n\t\t\telse if(str[i][j]=='.') s[i][j]=0;\n\t\t\telse s[i][j]=str[i][j]-'0';\n\t\t}\n\t}\n\tdp[0][0][3-K][0]=0; //?????¨??????->1\n\tq.push((T){0,0,3-K,0});\n\twhile(!q.empty()){\n\t\tT t=q.front();\n\t\tq.pop();\n\t\tll val=dp[t.y][t.x][t.k][t.s];\n\t\tk=t.k;\n\t\tif(t.k==0){\n\t\t\tif(t.x<W-1&&s[t.y][t.x+1]!=-1){\n\t\t\t\tadd=s[t.y][t.x+1];\n\t\t\t\tS=t.s;\n\t\t\t\tS>>=1;\n\t\t\t\tz=1|(1<<2)|(1<<5);\n\t\t\t\tS&=~z;\n\t\t\t\tS|=(1<<8);\n\t\t\t\tif(dp[t.y][t.x+1][k][S]<val+add){\n\t\t\t\t\tdp[t.y][t.x+1][k][S]=val+add;\n\t\t\t\t\tq.push((T){t.y,t.x+1,k,S});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.y<H-1&&s[t.y+1][t.x]!=-1){\n\t\t\t\tadd=s[t.y+1][t.x];\n\t\t\t\tS=t.s;\n\t\t\t\tS>>=4;\n\t\t\t\tz=(1<<3)|(1<<4);\n\t\t\t\tS&=z;\n\t\t\t\tS|=((t.s>>2)&1)\t| ((t.s&(3<<4))>>3);\n\t\t\t\tS|=(1<<5);\n\t\t\t\tif(dp[t.y+1][t.x][k][S]<val+add){\n\t\t\t\t\tdp[t.y+1][t.x][k][S]=val+add;\n\t\t\t\t\tq.push((T){t.y+1,t.x,k,S});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.y>0&&s[t.y-1][t.x]!=-1){\n\t\t\t\tif((t.s>>5)&1) add=0;\n\t\t\t\telse add=s[t.y-1][t.x];\n\t\t\t\tS=0;\n\t\t\t\tz=(1<<5)|(1<<6);\n\t\t\t\tS|=((t.s<<2)&z);\n\t\t\t\tS|=(t.s&1);\n\t\t\t\tz=(1<<2)|(1<<3);\n\t\t\t\tS|=((t.s<<1)&z);\n\t\t\t\tz=(1<<8)|(1<<9);\n\t\t\t\tS|=((t.s<<1)&z);\n\t\t\t\tS|=(1<<10);\n\t\t\t\tif(dp[t.y-1][t.x][k+1][S]<val+add){\n\t\t\t\t\tdp[t.y-1][t.x][k+1][S]=val+add;\n\t\t\t\t\tq.push((T){t.y-1,t.x,k+1,S});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.x>0&&s[t.y][t.x-1]!=-1){\n\t\t\t\tS=t.s>>1;\n\t\t\t\tif((t.s>>8)&1) add=0;\n\t\t\t\telse add=s[t.y][t.x-1];\n\t\t\t\tz=(1<<8)|(1<<9)|(1<<10);\n\t\t\t\tS&=~z;\n\t\t\t\tS|=(1<<7);\n\t\t\t\tif(dp[t.y][t.x-1][k+1][S]<val+add){\n\t\t\t\t\tdp[t.y][t.x-1][k+1][S]=val+add;\n\t\t\t\t\tq.push((T){t.y,t.x-1,k+1,S});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(t.k==1){\n\t\t\tif(t.x<W-1&&s[t.y][t.x+1]!=-1){\n\t\t\t\tif((t.s>>7)&1) add=0;\n\t\t\t\telse add=s[t.y][t.x+1];\n\t\t\t\tS=t.s>>1;\n\t\t\t\tz=(1<<1)|(1<<4)|(1<<7)|(1<<10);\n\t\t\t\tS&=~z;\n\t\t\t\tS|=(1<<6);\n\t\t\t\tif(dp[t.y][t.x+1][k][S]<val+add){\n\t\t\t\t\tdp[t.y][t.x+1][k][S]=val+add;\n\t\t\t\t\tq.push((T){t.y,t.x+1,k,S});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.y<H-1&&s[t.y+1][t.x]!=-1){\n\t\t\t\tif((t.s>>10)&1) add=0;\n\t\t\t\telse add=s[t.y+1][t.x];\n\t\t\t\tS=0;\n\t\t\t\tz=3;\n\t\t\t\tS|=(t.s>>3)&z;\n\t\t\t\tz=(1<<2);\n\t\t\t\tS|=(t.s>>4)&z;\n\t\t\t\tz=(1<<4)|(1<<5)|(1<<6);\n\t\t\t\tS|=(t.s>>3)&z;\n\t\t\t\tS|=(1<<3);\n\t\t\t\tif(dp[t.y+1][t.x][k][S]<val+add){\n\t\t\t\t\tdp[t.y+1][t.x][k][S]=val+add;\n\t\t\t\t\tq.push((T){t.y+1,t.x,k,S});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.y>0&&s[t.y-1][t.x]!=-1){\n\t\t\t\tif((t.s>>3)&1) add=0;\n\t\t\t\telse add=s[t.y-1][t.x];\n\t\t\t\tS=t.s;\n\t\t\t\tz=1|(1<<1)|(1<<4)|(1<<6)|(1<<9)|(1<<10);\n\t\t\t\tS&=z;\n\t\t\t\tz=(1<<3);\n\t\t\t\tS|=(t.s<<1)&z;\n\t\t\t\tS|=(1<<7);\n\t\t\t\tz|=(1<<8);\n\t\t\t\tS|=(t.s<<1)&z;\n\t\t\t\tif(dp[t.y-1][t.x][k+1][S]<val+add){\n\t\t\t\t\tdp[t.y-1][t.x][k+1][S]=val+add;\n\t\t\t\t\tq.push((T){t.y-1,t.x,k+1,S});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.x>0&&s[t.y][t.x-1]!=-1){\n\t\t\t\tif((t.s>>6)&1) add=0;\n\t\t\t\telse add=s[t.y][t.x-1];\n\t\t\t\tS=(t.s>>2);\n\t\t\t\tS|=(1<<4);\n\t\t\t\tif(dp[t.y][t.x-1][k+1][S]<val+add){\n\t\t\t\t\tdp[t.y][t.x-1][k+1][S]=val+add;\n\t\t\t\t\tq.push((T){t.y,t.x-1,k+1,S});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(t.k==2){\n\t\t\tif(t.x<W-1&&s[t.y][t.x+1]!=-1){\n\t\t\t\tif((t.s>>4)&1) add=0;\n\t\t\t\telse add=s[t.y][t.x+1];\n\t\t\t\tS=t.s>>1;\n\t\t\t\tz=(1<<2)|(1<<5)|(1<<8)|(1<<10);\n\t\t\t\tS&=~z;\n\t\t\t\tS|=(1<<3);\n\t\t\t\tif(dp[t.y][t.x+1][k][S]<val+add){\n\t\t\t\t\tdp[t.y][t.x+1][k][S]=val+add;\n\t\t\t\t\tq.push((T){t.y,t.x+1,k,S});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.y<H-1&&s[t.y+1][t.x]!=-1){\n\t\t\t\tif((t.s>>7)&1) add=0;\n\t\t\t\telse add=s[t.y+1][t.x];\n\t\t\t\tS=0;\n\t\t\t\tz=(1<<1)|(1<<2)|(1<<3)|(1<<6)|(1<<7);\n\t\t\t\tS|=(t.s>>3)&z;\n\t\t\t\tz=(1<<4);\n\t\t\t\tS|=(t.s>>4)&z;\n\t\t\t\tS|=1;\n\t\t\t\tif(dp[t.y+1][t.x][k][S]<val+add){\n\t\t\t\t\tdp[t.y+1][t.x][k][S]=val+add;\n\t\t\t\t\tq.push((T){t.y+1,t.x,k,S});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.y>0&&s[t.y-1][t.x]!=-1){\n\t\t\t\tif(t.s&1) add=0;\n\t\t\t\telse add=s[t.y-1][t.x];\n\t\t\t\tS=0;\n\t\t\t\tz=1|(1<<1)|(1<<6)|(1<<7);\n\t\t\t\tS|=(t.s>>1)&z;\n\t\t\t\tz=(1<<4)|(1<<5);\n\t\t\t\tS|=(t.s&z);\n\t\t\t\tz=(1<<8);\n\t\t\t\tS|=((t.s>>2)&z);\n\t\t\t\tS|=(1<<3);\n\t\t\t\tif(dp[t.y-1][t.x][k+1][S]<val+add){\n\t\t\t\t\tdp[t.y-1][t.x][k+1][S]=val+add;\n\t\t\t\t\tq.push((T){t.y-1,t.x,k+1,S});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.x>0&&s[t.y][t.x-1]!=-1){\n\t\t\t\tif((t.s>>3)&1) add=0;\n\t\t\t\telse add=s[t.y][t.x-1];\n\t\t\t\tS=t.s>>3;\n\t\t\t\tS|=1;\n\t\t\t\tif(dp[t.y][t.x-1][k+1][S]<val+add){\n\t\t\t\t\tdp[t.y][t.x-1][k+1][S]=val+add;\n\t\t\t\t\tq.push((T){t.y,t.x-1,k+1,S});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(t.x<W-1&&s[t.y][t.x+1]!=-1){\n\t\t\t\tif(t.s&1) add=0;\n\t\t\t\telse add=s[t.y][t.x+1];\n\t\t\t\tS=t.s>>1;\n\t\t\t\tz=(1<<2)|(1<<5)|(1<<7)|(1<<8);\n\t\t\t\tS&=~z;\n\t\t\t\tif(dp[t.y][t.x+1][k][S]<val+add){\n\t\t\t\t\tdp[t.y][t.x+1][k][S]=val+add;\n\t\t\t\t\tq.push((T){t.y,t.x+1,k,S});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.y<H-1&&s[t.y+1][t.x]!=-1){\n\t\t\t\tif((t.s>>3)&1) add=0;\n\t\t\t\telse add=s[t.y+1][t.x];\n\t\t\t\tS=0;\n\t\t\t\tz=3;\n\t\t\t\tS|=(t.s>>4)&z;\n\t\t\t\tz=(3<<3);\n\t\t\t\tS|=(t.s>>3)&z;\n\t\t\t\tS|=(t.s>>2)&(1<<6);\n\t\t\t\tif(dp[t.y+1][t.x][k][S]<val+add){\n\t\t\t\t\tdp[t.y+1][t.x][k][S]=val+add;\n\t\t\t\t\tq.push((T){t.y+1,t.x,k,S});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tfor(ll i=0;i<4;i++){\n\t\tfor(ll j=0;j<(1<<11);j++){\n\t\t\tans=max(ans,dp[H-1][W-1][i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<deque>\n#include<climits>\nusing namespace std;\n \nconst int dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nconst int MAX_STATE = 1<<12;\nint H,W,K,memo[50][50][4][MAX_STATE],fld[50][50],gifts[2500];\n \nint dfs(int y,int x,int k,int s,deque<int> d){\n    if(k>K) return INT_MIN;\n    if(memo[y][x][k][s]!=INT_MIN) return memo[y][x][k][s];\n    if(y==H-1 && x==W-1) memo[y][x][k][s] = 0;\n    int pls = 0;\n    if(fld[y][x]>=0) pls = gifts[fld[y][x]];\n    for(int i=0;i<d.size();i++){\n        if(d[i]==fld[y][x]) pls = 0;\n    }\n    d.pop_back(); d.push_front(fld[y][x]);\n    int ny,nx;\n    for(int i=0;i<4;i++){\n        ny = y+dy[i]; nx = x+dx[i];\n        if(ny<0 || H<=ny || nx<0 || W<=nx || fld[ny][nx]==-2) continue;\n        int nk = k, ns = ((s<<2)+i)%(1<<12);\n        if(i>=2) nk++;\n        deque<int> nd = d;\n        memo[y][x][k][s] = max(memo[y][x][k][s],dfs(ny,nx,nk,ns,nd));\n    }\n    return memo[y][x][k][s]+pls;\n}\n \nint main(){\n    fill_n((int*)memo,50*50*4*MAX_STATE,INT_MIN);\n    int cnt = 0;\n    char in;\n    cin>>H>>W>>K;\n    for(int i=0;i<H;i++)for(int j=0;j<W;j++){\n        cin>>in;\n        if(in=='#') fld[i][j] = -2;\n        else if(in=='.') fld[i][j] = -1;\n        else fld[i][j] = cnt, gifts[cnt++] = in-'0';\n    }\n    deque<int> d(6,-1);\n    printf(\"%d\\n\",dfs(0,0,0,0,d));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 60\n#define MAX_K 3\n#define MAX_D 6\n#define MAX_C 4096\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\nint dp[MAX_N][MAX_N][MAX_K + 1][MAX_C];\nint x[MAX_N][MAX_N];\nint h, w, K, a;\nchar c;\nchar T[12] = \".123456789#\";\nint b[MAX_N][MAX_N];\nint gx[6], gy[6];\n\nint hantei(int p, int q, vector<int>r) {\n\tint v = p, w = q;\n\tfor (int o = 5; o >= 0; o--) {\n\t\tv -= dy[r[o]];\n\t\tw -= dx[r[o]];\n\t\tgy[o] = v; gx[o] = w;\n\t}\n\tfor (int o = 0; o <= 5; o++) {\n\t\tif (p == gy[o] && q == gx[o]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint DP() {\n\tint X, Y, F, G, H, dir[6], maxn;\n\n\t//zentansaku(first 6)\n\tfor (int i = 0; i < 4096; i++) {\n\t\tmemset(b, 0, sizeof(b));\n\t\tX = 1; Y = 1;\n\t\tF = x[1][1]; G = 0; b[Y][X] = 1;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\ta = (i / (int)pow(4, j)) % 4;\n\t\t\tX += dx[a]; Y += dy[a];\n\t\t\tif (x[Y][X] == 10) {\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif (a == 2 || a == 3) {\n\t\t\t\tG++;\n\t\t\t}\n\t\t\tif (b[Y][X] == 0) {\n\t\t\t\tF += x[Y][X];\n\t\t\t}\n\t\t\tb[Y][X] = 1;\n\t\t}\n\t\tif (G <= K) {\n\t\t\tdp[Y][X][G][i] = F;\n\t\t}\n\tE:;\n\t}\n\n\t//dp.\n\tfor (int i = 0; i < K; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tfor (int k = 1; k <= w; k++) {\n\t\t\t\tif (x[j][k] <= 9) {\n\n\t\t\t\t\tfor (int l = 0; l <= K; l++) {\n\t\t\t\t\t\tfor (int m = 0; m < MAX_C; m++) {\n\t\t\t\t\t\t\tif (dp[j][k][l][m] >= 0) {\n\n\t\t\t\t\t\t\t\tfor (int n = 0; n < 6; n++) {\n\t\t\t\t\t\t\t\t\tdir[n] = (m / (int)pow(4, n)) % 4;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (l < K) {\n\t\t\t\t\t\t\t\t\tif (x[j - 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 2048;\n\t\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],2 };\n\t\t\t\t\t\t\t\t\t\tif (hantei(j - 1, k, A) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j - 1][k];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tX = j; Y = k;\n\n\t\t\t\t\t\t\t\t\t\tdp[j - 1][k][l + 1][a] = max(dp[j - 1][k][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (x[j][k - 1] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 3072;\n\t\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],3 };\n\n\t\t\t\t\t\t\t\t\t\tif (hantei(j, k - 1, A) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j][k - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tdp[j][k - 1][l + 1][a] = max(dp[j][k - 1][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j + 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],0 };\n\n\t\t\t\t\t\t\t\t\tif (hantei(j + 1, k, A) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j + 1][k];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j + 1][k][l][a] = max(dp[j + 1][k][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j][k + 1] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ta += 1024;\n\n\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],1 };\n\n\t\t\t\t\t\t\t\t\tif (hantei(j, k + 1, A) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j][k + 1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j][k + 1][l][a] = max(dp[j][k + 1][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmaxn = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tfor (int j = 0; j < MAX_C; j++) {\n\t\t\tmaxn = max(maxn, dp[h][w][i][j]);\n\t\t}\n\t}\n\treturn maxn;\n}\n\nint main() {\n\t//shokika.\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_K; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_C; l++) {\n\t\t\t\t\tdp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tx[i][j] = 10;\n\t\t}\n\t}\n\t//cin.\n\tcin >> h >> w >> K;\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tcin >> c;\n\t\t\tfor (int k = 0; k < 11; k++) {\n\t\t\t\tif (c == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][3][3];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  map<pii,int> m;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[pii(i+oy,j+ox)]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[pii(ny,nx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    // if(val==9)cout<<cy<<\" \"<<cx<<endl;\n    nmask|=(1<<nidx);\n  }\n  // テ・ツ?ィテ、ツスツ禿」ツ?ョテ」ツδ禿」ツδε」ツδ暗・ツ渉ウテ」ツ?ォテ」ツつ津」ツつキテ」ツδ陛」ツδ?\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n    // if(cy==0&&cx==0&&ny==0&&nx==1){\n    //   cout<<bitset<10>(mask)<<\" \"<<my<<\" \"<<mx<<\" \"<<val<<\" \"<<nidx<<endl;\n    // }\n  }\n  // テ、ツクツ凝ヲツ鳴ケテ・ツ青妥」ツ?ォテ」ツδ禿」ツδε」ツδ暗」ツつ津」ツつキテ」ツδ陛」ツδ?\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nstruct Sit{\n  int cy,cx,mask,my,mx;\n  Sit(){}\n  Sit(int cy_,int cx_,int mask_,int my_,int mx_){\n    cy=cy_;\n    cx=cx_;\n    mask=mask_;\n    my=my_;\n    mx=mx_;\n  }\n  bool operator<(const Sit&sit)const{\n    return true;\n  }\n};\ntypedef pair<int,Sit> iSit;\n\nint dijkstra(){\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][1<<6][0][0]=0;\n  priority_queue<iSit> pq;\n  pq.push(make_pair(0,Sit(0,0,1<<6,0,0)));\n  while(pq.size()){\n    iSit is=pq.top();pq.pop();\n    int cval=is.first;\n    Sit cSit=is.second;\n    int cy=cSit.cy,cx=cSit.cx,mask=cSit.mask,my=cSit.my,mx=cSit.mx;\n    if(dp[cy][cx][mask][my][mx]>cval)continue;\n    int leftK=K-(my+mx);\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n        pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n        int nmask=p.first;\n        int nAddVal=p.second;\n        if(leftK>0&&(i==0||i==3)&&dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]<cval+nAddVal){\n          dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))));\n        }\n        else if((i==1||i==2)&&dp[ny][nx][nmask][my][mx]<cval+nAddVal){\n          dp[ny][nx][nmask][my][mx]=cval+nAddVal;\n          //if(cval+nAddVal==18)cout<<cy<<\" \"<<cx<<\" \"<<ny<<\" \"<<nx<<endl;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my,mx)));\n        }\n      }\n    }\n  }\n  int res=0;\n  for(int mask=0;mask<(1<<10);mask++)\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        res=max(res,dp[H-1][W-1][mask][i][j]);\n  return res;\n}\n\nint main(){\n  ifstream cin(\"in.txt\");\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[60][51];\n\n#define inv(d) (((d)+2)&3) // opposite direction\n\nint dp[60][50][4][4][4][4][4][4][4];\nint dfs(int i,int j,int k,int d0,int d1,int d2,int d3,int d4,int d5){\n\tint &res=dp[i][j][k][d0][d1][d2][d3][d4][d5];\n\tif(~res) return res;\n\n\tif(i==h-1 && j==w-1) res=0; // goal\n\n\tint y[6],x[6];\n\ty[0]=  i +dy[inv(d0)]; x[0]=  j +dx[inv(d0)];\n\ty[1]=y[0]+dy[inv(d1)]; x[1]=x[0]+dx[inv(d1)];\n\ty[2]=y[1]+dy[inv(d2)]; x[2]=x[1]+dx[inv(d2)];\n\ty[3]=y[2]+dy[inv(d3)]; x[3]=x[2]+dx[inv(d3)];\n\ty[4]=y[3]+dy[inv(d4)]; x[4]=x[3]+dx[inv(d4)];\n\ty[5]=y[4]+dy[inv(d5)]; x[5]=x[4]+dx[inv(d5)];\n\n\trep(d,4){\n\t\tint ii=i+dy[d],jj=j+dx[d],kk=k;\n\t\tif(d==1 || d==2) kk--;\n\t\tif(kk<0) continue;\n\t\tif(0<=ii && ii<h && 0<=jj && jj<w && B[ii][jj]!='#'){\n\t\t\tbool vis=false;\n\t\t\trep(l,6) if(ii==y[l] && jj==x[l]) vis=true;\n\t\t\tres=max(res,dfs(ii,jj,kk,d,d0,d1,d2,d3,d4)+(vis||B[ii][jj]=='.'?0:B[ii][jj]-'0'));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint k; scanf(\"%d%d%d\",&h,&w,&k);\n\trep(i,10) rep(j,w) B[i][j]=(j==0?'.':'#');\n\tfor(int i=10;i<h+10;i++) scanf(\"%s\",B[i]);\n\th+=10;\n\n\tmemset(dp,-1,sizeof dp);\n\tprintf(\"%d\\n\",dfs(10,0,k,2,2,2,2,2,2));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint H,W,K;\nint POW[13];\nint dp[50][50][4][4096]; //dp[row][col][Kの残数][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nint recursive(int row,int col,int back_count,int move_log,int moved_count){ //moved_log[]:インデックスが小さいほど新しい(右シフト)\n\n\tif(dp[row][col][back_count][move_log] != -1)return dp[row][col][back_count][move_log]; //計算済ならreturn\n\n\tif(row == H-1 && col == W-1 && back_count == K)return 0;\n\n\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t//過去の移動ログから、訪問済のマス情報を特定する\n\tint tmp_row = row,tmp_col = col;\n\n\tint log_array[6],tmp_log;\n\n\ttmp_log = move_log;\n\tfor(int i = 0; i < 6; i++){\n\t\tlog_array[i] = tmp_log%4;\n\t\ttmp_log /= 4;\n\t}\n\n\tfor(int i = 0; i < min(6,moved_count); i++){\n\t\tswitch(log_array[i]){ //ログを打ち消す方向に動く\n\t\tcase 0: //East\n\t\t\ttmp_col--;\n\t\t\tbreak;\n\t\tcase 1: //South\n\t\t\ttmp_row--;\n\t\t\tbreak;\n\t\tcase 2: //West\n\t\t\ttmp_col++;\n\t\t\tbreak;\n\t\tcase 3: //North\n\t\t\ttmp_row++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(tmp_row == row && tmp_col == col+1){ //右のマスと一致\n\t\t\tvisited_E = true;\n\t\t}else if(tmp_row == row+1 && tmp_col == col){ //下のマスと一致\n\t\t\tvisited_S = true;\n\t\t}else if(tmp_row == row && tmp_col == col-1){ //左のマスと一致\n\t\t\tvisited_W = true;\n\t\t}else if(tmp_row == row-1 && tmp_col == col){ //上のマスと一致\n\t\t\tvisited_N = true;\n\t\t}\n\t}\n\n\tint next_log = move_log%1024;\n\tint ret = -BIG_NUM;\n\n\t//右へ\n\tif(rangeCheck(row,col+1) == true && base_map[row][col+1] != '#'){\n\t\tif(visited_E == false){\n\t\t\tresult_E += base_map[row][col+1]-'0';\n\t\t}\n\t\tint next_code = 4*next_log+0;\n\t\tresult_E += recursive(row,col+1,back_count,next_code,moved_count+1);\n\t\tret = max(ret,result_E);\n\t}\n\n\t//下へ\n\tif(rangeCheck(row+1,col) == true && base_map[row+1][col] != '#'){\n\t\tif(visited_S == false){\n\t\t\tresult_S += base_map[row+1][col]-'0';\n\t\t}\n\t\tint next_code = 4*next_log+1;\n\t\tresult_S += recursive(row+1,col,back_count,next_code,moved_count+1);\n\t\tret = max(ret,result_S);\n\t}\n\n\t//左へ\n\tif(back_count < K && rangeCheck(row,col-1) == true && base_map[row][col-1] != '#'){\n\t\tif(visited_W == false){\n\t\t\tresult_W += base_map[row][col-1]-'0';\n\t\t}\n\t\tint next_code = 4*next_log+2;\n\t\tresult_W += recursive(row,col-1,back_count+1,next_code,moved_count+1);\n\t\tret = max(ret,result_W);\n\t}\n\n\t//上へ\n\tif(back_count < K && rangeCheck(row-1,col) == true && base_map[row-1][col] != '#'){\n\t\tif(visited_N == false){\n\t\t\tresult_N += base_map[row-1][col]-'0';\n\t\t}\n\t\tint next_code = 4*next_log+3;\n\t\tresult_N += recursive(row-1,col,back_count+1,next_code,moved_count+1);\n\t\tret = max(ret,result_N);\n\t}\n\n\treturn dp[row][col][back_count][move_log] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 13; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(base_map[row][col] == '.'){\n\t\t\t\tbase_map[row][col] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= 3; i++){\n\t\t\t\tfor(int state = 0; state < POW[12]; state++)dp[row][col][i][state] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",recursive(0,0,0,0,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define chmax(a,b) (a = max(a,b))\nusing namespace std;\n\nconst int dy[] = {0,1,0,-1}, dx[] = {1,0,-1,0};\nint dp[2][50][50][1<<12];\nint vis[1<<12];\n\ninline int visit(int bit){\n  if(vis[bit]>=0)return vis[bit];\n\n  int y=0, x=0, b=bit;\n  rep(i,6){\n    y += dy[b&3], x += dx[b&3]; b>>=2;\n    if(y==0 && x==0)return vis[bit] = 1;\n  }\n  return vis[bit] = 0;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int h,w,k;\n  string g[50];\n  cin >> h >> w >> k;\n  rep(i,h)cin >> g[i];\n\n  memset(vis,-1,sizeof(vis));\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0][0] = isdigit(g[0][0])?(int)(g[0][0]-'0'):0;\n\n  rep(t,k+1){\n    int ck = t&1, nk = 1-ck;\n    rep(y,h)rep(x,w){\n      if(g[y][x] == '#')continue;\n      rep(bit,1<<12){\n\tif(dp[ck][y][x][bit]<0)continue;\n\n\trep(d,4){\n\t  if(t==k && d>1)break;\n\t  int ny = y+dy[d], nx = x+dx[d];\n\t  if(!range(ny,0,h) || !range(nx,0,w))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  int nbit = ((bit<<2)|d) & ((1<<12)-1);\n\t  int item = isdigit(g[ny][nx])?(int)(g[ny][nx]-'0'):0;\n\t  if(visit(nbit))item = 0;\n\n\t  if(d<2){\n\t    chmax(dp[ck][ny][nx][nbit], dp[ck][y][x][bit] + item);\n\t  }else{\n\t    chmax(dp[nk][ny][nx][nbit], dp[ck][y][x][bit] + item);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = 0;\n  rep(bit,1<<12)chmax(res, dp[k&1][h-1][w-1][bit]);\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define chmax(a,b) (a = max(a,b))\nusing namespace std;\n\nconst int dy[] = {0,1,0,-1}, dx[] = {1,0,-1,0};\nint dp[50][50][4][1<<12];\nint vis[1<<12];\n\ninline bool visit(int bit){\n  if(vis[bit]>=0)return vis[bit];\n  int y=0, x=0;\n  rep(i,6){\n    int d = bit&3; bit>>=2;\n    y += dy[d], x += dx[d];\n    if(y==0 && x==0)return vis[bit] = true;\n  }\n  return vis[bit] = false;\n}\n\nint main(){\n  int h,w,k;\n  string g[50];\n  cin >> h >> w >> k;\n  rep(i,h)cin >> g[i];\n\n  memset(vis,-1,sizeof(vis));\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0][0] = isdigit(g[0][0])?(int)(g[0][0]-'0'):0;\n\n  rep(rev,k+1){\n    rep(y,h)rep(x,w){\n      if(g[y][x] == '#')continue;\n      rep(bit,1<<12){\n\tif(dp[y][x][rev][bit]<0)continue;\n\n\trep(d,4){\n\t  int ny = y+dy[d], nx = x+dx[d];\n\t  int nbit = ((bit<<2)|d) & ((1<<12)-1);\n\t  if(!range(ny,0,h) || !range(nx,0,w))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  int item = isdigit(g[ny][nx])?(int)(g[ny][nx]-'0'):0;\n\t  if(visit(nbit))item = 0;\n\n\t  if(d<2){\n\t    chmax(dp[ny][nx][rev][nbit], dp[y][x][rev][bit] + item);\n\t  }else if(rev!=k){\n\t    chmax(dp[ny][nx][rev+1][nbit], dp[y][x][rev][bit] + item);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = 0;\n  rep(bit,1<<12)chmax(res, dp[h-1][w-1][k][bit]);\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  map<pii,int> m;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[pii(i+oy,j+ox)]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[pii(ny,nx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 全体のビット右にをシフト\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 下方向にビットをシフト\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nstruct Sit{\n  int cy,cx,mask,my,mx;\n  Sit(){}\n  Sit(int cy_,int cx_,int mask_,int my_,int mx_){\n    cy=cy_;\n    cx=cx_;\n    mask=mask_;\n    my=my_;\n    mx=mx_;\n  }\n  bool operator<(const Sit&sit)const{\n    return true;\n  }\n};\ntypedef pair<int,Sit> iSit;\n\nint dfs(int cy,int cx,int mask,int my,int mx){\n  if(dp[cy][cx][mask][my][mx]>=0)return dp[cy][cx][mask][my][mx];\n  int res=0;\n  int leftK=K-(my+mx);\n  bool isMove=false;\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n      int nmask=p.first;\n      int nAddVal=p.second;\n      // cout<<nAddVal<<endl;\n      if(leftK>0&&(i==0||i==3)){\n        isMove=true;\n        res=max(res,dfs(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))+nAddVal);\n      }\n      else if((i==1||i==2)){\n        isMove=true;\n        res=max(res,dfs(ny,nx,nmask,my,mx)+nAddVal);\n      }\n    }\n  }\n  if(!isMove){\n    if(cy==H-1&&cx==W-1)return 0;\n    else return -(1<<30);\n  }\n  return dp[cy][cx][mask][my][mx]=res;\n}\n\nint dijkstra(){\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][1<<6][0][0]=0;\n  priority_queue<iSit> pq;\n  pq.push(make_pair(0,Sit(0,0,1<<6,0,0)));\n  while(pq.size()){\n    iSit is=pq.top();pq.pop();\n    int cval=is.first;\n    Sit cSit=is.second;\n    int cy=cSit.cy,cx=cSit.cx,mask=cSit.mask,my=cSit.my,mx=cSit.mx;\n    if(dp[cy][cx][mask][my][mx]>cval)continue;\n    int leftK=K-(my+mx);\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n        pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n        int nmask=p.first;\n        int nAddVal=p.second;\n        if(leftK>0&&(i==0||i==3)&&dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]<cval+nAddVal){\n          dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))));\n        }\n        else if((i==1||i==2)&&dp[ny][nx][nmask][my][mx]<cval+nAddVal){\n          dp[ny][nx][nmask][my][mx]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my,mx)));\n        }\n      }\n    }\n  }\n  int res=0;\n  for(int mask=0;mask<(1<<10);mask++)\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        res=max(res,dp[H-1][W-1][mask][i][j]);\n  return res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  memset(dp,-1,sizeof(dp));\n  // assert(dfs(0,0,(1<<6),0,0)==dijkstra());\n  cout<<dfs(0,0,(1<<6),0,0)<<endl;\n  //cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\nbool used[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  map<pii,int> m;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[pii(i+oy,j+ox)]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[pii(ny,nx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // テ・ツ?ィテ、ツスツ禿」ツ?ョテ」ツδ禿」ツδε」ツδ暗・ツ渉ウテ」ツ?ォテ」ツつ津」ツつキテ」ツδ陛」ツδ?\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // テ、ツクツ凝ヲツ鳴ケテ・ツ青妥」ツ?ォテ」ツδ禿」ツδε」ツδ暗」ツつ津」ツつキテ」ツδ陛」ツδ?\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nstruct Sit{\n  int cy,cx,mask,my,mx;\n  Sit(){}\n  Sit(int cy_,int cx_,int mask_,int my_,int mx_){\n    cy=cy_;\n    cx=cx_;\n    mask=mask_;\n    my=my_;\n    mx=mx_;\n  }\n  bool operator<(const Sit&sit)const{\n    return true;\n  }\n};\ntypedef pair<int,Sit> iSit;\n\nconst int INF=(1<<30);\nint dfs(int cy,int cx,int mask,int my,int mx){\n  if(used[cy][cx][mask][my][mx])return dp[cy][cx][mask][my][mx];\n  int res=-INF;\n  int leftK=K-(my+mx);\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n      int nmask=p.first;\n      int nAddVal=p.second;\n      // cout<<nAddVal<<endl;\n      if(leftK>0&&(i==0||i==3)){\n        res=max(res,dfs(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))+nAddVal);\n      }\n      else if((i==1||i==2)){\n        res=max(res,dfs(ny,nx,nmask,my,mx)+nAddVal);\n      }\n    }\n  }\n  if(cy==H-1&&cx==W-1)res=max(res,0);\n  used[cy][cx][mask][my][mx]=true;\n  return dp[cy][cx][mask][my][mx]=res;\n}\n\nint dijkstra(){\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][1<<6][0][0]=0;\n  priority_queue<iSit> pq;\n  pq.push(make_pair(0,Sit(0,0,1<<6,0,0)));\n  while(pq.size()){\n    iSit is=pq.top();pq.pop();\n    int cval=is.first;\n    Sit cSit=is.second;\n    int cy=cSit.cy,cx=cSit.cx,mask=cSit.mask,my=cSit.my,mx=cSit.mx;\n    if(dp[cy][cx][mask][my][mx]>cval)continue;\n    int leftK=K-(my+mx);\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n        pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n        int nmask=p.first;\n        int nAddVal=p.second;\n        if(leftK>0&&(i==0||i==3)&&dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]<cval+nAddVal){\n          dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))));\n        }\n        else if((i==1||i==2)&&dp[ny][nx][nmask][my][mx]<cval+nAddVal){\n          dp[ny][nx][nmask][my][mx]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my,mx)));\n        }\n      }\n    }\n  }\n  int res=0;\n  for(int mask=0;mask<(1<<10);mask++)\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        res=max(res,dp[H-1][W-1][mask][i][j]);\n  return res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  memset(dp,-1,sizeof(dp));\n  // assert(dfs(0,0,(1<<6),0,0)==dijkstra());\n  cout<<dfs(0,0,(1<<6),0,0)<<endl;\n  //cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1}; //00右,01下,10左,11上\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nconst int mask=(1<<12)-1;\nint h,w,k,memo[50][50][4][1<<12];\nchar fld[50][50];\n\ninline bool Check(int y,int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w&&fld[y][x]!='#';\n}\n\nint Max(int y,int x,int c,int bit){\n\tint &res=memo[y][x][c][bit];\n\tif(res!=-1) return res;\n\tif(y==h-1&&x==w-1&&c==0) return res=0;\n\n\tbool done=false;\n\tint py=y,px=x;\n\trep(i,0,6){\n\t\tpy-=dy[(bit>>(i*2))&3];\n\t\tpx-=dx[(bit>>(i*2))&3];\n\t\tif(y==py&&x==px){\n\t\t\tdone=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint gift=0;\n\tif(!done&&fld[y][x]!='.') gift=fld[y][x]-'0';\n\n\tres=-INF;\n\trep(i,0,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(!Check(ny,nx)) continue;\n\t\tif(i<2){\n\t\t\tres=max(res,Max(ny,nx,c,((bit<<2)&mask)|i)+gift);\n\t\t}else if(c>=1){\n\t\t\tres=max(res,Max(ny,nx,c-1,((bit<<2)&mask)|i)+gift);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid Solve(){\n\tfill_n((int*)memo,50*50*4*(1<<12),-1);\n\tcin >> h >> w >> k;\n\trep(i,0,h) rep(j,0,w) cin >> fld[i][j];\n\n\tcout << Max(0,0,k,0) << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\nusing namespace std;\n\ntypedef bitset<12> B;\nint m[51][51], dp[1 << 12][50][50][4];\nint H, W, K;\nint dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\n\n\nint filter(int v, int x)\n{\n  return (v << x) ? -1 : 1; \n}\n\nint dfs(int bit, int x, int y, int k)\n{\n  if(dp[bit][x][y][k] != 0)\n    return dp[bit][x][y][k];\n  int cnt = max(0, m[y][x]);\n  int res = -100000000;\n  if(x == W - 1 && y == H - 1)\n    res = 0;\n  B bb(bit);\n  int xx = x, yy = y;\n  for(int j = 0; j < 6; j++)\n  {\n    int d = (int)bitset<2>((bb >> (j * 2)).to_ulong()).to_ulong();\n    xx -= dx[d]; yy -= dy[d];\n    if(xx == x && yy == y)\n      cnt = 0;\n  }\n  for(int i = 0; i < 4; i++)\n  {\n    int tx = x + dx[i], ty = y + dy[i];\n    if(!(tx >= 0 && tx < W && ty >= 0 && ty < H))\n      continue;\n    if(m[ty][tx] == -1)\n      continue;\n    int dk = (dx[i] < 0 || dy[i] < 0) ? 1 : 0;\n    if(k + dk > K)\n      continue;\n\n    B nb((bb << 2).to_ulong());\n    nb |= bitset<12>(i);\n    res = max(res, dfs(int(nb.to_ulong()), tx, ty, k + dk) + cnt);\n  }\n  return dp[bit][x][y][k] = res;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  for(int y = 0; y < H; y++)\n  {\n    for(int x = 0; x < W; x++)\n    {\n      char a;\n      cin >> a;\n      switch(a)\n      {\n        case '.':\n          m[y][x] = 0;\n          break;\n        case '#':\n          m[y][x] = -1;\n          break;\n        default:\n          m[y][x] = a - '0';\n          break;\n      }\n    }\n  }\n  cout << dfs(0, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define chmax(a,b) ((a) = max((a),(b)))\nusing namespace std;\n\nconst int dy[] = {0,1,0,-1}, dx[] = {1,0,-1,0};\nint dp[50][50][4][1<<12];\nint vis[1<<12];\n\ninline bool visit(int bit){\n  if(vis[bit]>=0)return vis[bit];\n  int y=0, x=0;\n  rep(i,6){\n    int d = bit&3; bit>>=2;\n    y += dy[d], x += dx[d];\n    if(y==0 && x==0)return vis[bit] = true;\n  }\n  return vis[bit] = false;\n}\n\nint main(){\n  int h,w,k;\n  string g[50];\n  cin >> h >> w >> k;\n  rep(i,h)cin >> g[i];\n\n  memset(vis,-1,sizeof(vis));\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0][0] = isdigit(g[0][0])?(int)(g[0][0]-'0'):0;\n\n  rep(rev,k+1){\n    rep(y,h)rep(x,w){\n      if(g[y][x] == '#')continue;\n      rep(bit,1<<12){\n\tif(dp[y][x][rev][bit]<0)continue;\n\n\trep(d,4){\n\t  int ny = y+dy[d], nx = x+dx[d];\n\t  if(!range(ny,0,h) || !range(nx,0,w))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  int nbit = ((bit<<2)|d) & ((1<<12)-1);\n\t  int item = isdigit(g[ny][nx])?(int)(g[ny][nx]-'0'):0;\n\t  if(visit(nbit))item = 0;\n\n\t  if(d<2){\n\t    chmax(dp[ny][nx][rev][nbit], dp[y][x][rev][bit] + item);\n\t  }else if(rev!=k){\n\t    chmax(dp[ny][nx][rev+1][nbit], dp[y][x][rev][bit] + item);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = 0;\n  rep(bit,1<<12)chmax(res, dp[h-1][w-1][k][bit]);\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tEast,\n\tSouth,\n\tWest,\n\tNorth,\n};\n\nstruct Info{\n\tvoid set(int arg_row,int arg_col,int arg_back_count,int arg_moved_count,int arg_sum){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tback_count = arg_back_count;\n\t\tmoved_count = arg_moved_count;\n\t\tsum = arg_sum;\n\t}\n\tbool operator<(const struct Info &arg) const{ //総和の降順(PQ)\n\t\treturn sum < arg.sum;\n\t}\n\n\tint row,col,back_count,moved_count,sum;\n\tType move_log[6];\n};\n\nint H,W,K;\nint POW[7];\nint dp[50][50][4][7][4096]; //dp[row][col][Kの残数][moved_count][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint makeCode(Type move_log[6]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < 6; i++){\n\t\tret += move_log[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\nbool is_num(int row,int col){\n\treturn base_map[row][col] >= '1' && base_map[row][col] <= '9'; //0の土産物屋はない\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++)POW[i] = pow(4,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= K; i++){\n\t\t\t\tfor(int count = 0; count <= 6; count++){\n\t\t\t\t\tfor(int state = 0; state < POW[6]; state++)dp[row][col][i][count][state] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tInfo first;\n\tfirst.set(0,0,0,0,0);\n\tfor(int i = 0; i < 6; i++)first.move_log[i] = East;\n\n\tdp[0][0][0][0][0] = 0;\n\n\tQ.push(first);\n\n\tInfo info;\n\twhile(!Q.empty()){\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tint tmp_code = makeCode(info.move_log);\n\t\tif(dp[info.row][info.col][info.back_count][min(6,info.moved_count)][tmp_code] > info.sum)continue;\n\n\t\tType next_move_log[4][6];\n\t\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\t\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t\t//過去の移動ログから、訪問済のマス情報を特定する\n\t\tint tmp_row = info.row,tmp_col = info.col;\n\n\t\tfor(int i = 0; i < min(info.moved_count,6); i++){\n\t\t\tswitch(info.move_log[i]){ //ログを打ち消す方向に動く\n\t\t\tcase East:\n\t\t\t\ttmp_col--;\n\t\t\t\tbreak;\n\t\t\tcase South:\n\t\t\t\ttmp_row--;\n\t\t\t\tbreak;\n\t\t\tcase West:\n\t\t\t\ttmp_col++;\n\t\t\t\tbreak;\n\t\t\tcase North:\n\t\t\t\ttmp_row++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp_row == info.row && tmp_col == info.col+1){ //右のマスと一致\n\t\t\t\tvisited_E = true;\n\t\t\t}else if(tmp_row == info.row+1 && tmp_col == info.col){ //下のマスと一致\n\t\t\t\tvisited_S = true;\n\t\t\t}else if(tmp_row == info.row && tmp_col == info.col-1){ //左のマスと一致\n\t\t\t\tvisited_W = true;\n\t\t\t}else if(tmp_row == info.row-1 && tmp_col == info.col){ //上のマスと一致\n\t\t\t\tvisited_N = true;\n\t\t\t}\n\t\t}\n\n\t\t//次の移動ログを作る\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\tnext_move_log[i][k+1] = info.move_log[k]; //右に1つシフト\n\t\t\t}\n\t\t\tswitch(i){\n\t\t\tcase 0:\n\t\t\t\tnext_move_log[i][0] = East;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnext_move_log[i][0] = South;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnext_move_log[i][0] = West;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tnext_move_log[i][0] = North;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//右へ\n\t\tif(rangeCheck(info.row,info.col+1) == true && base_map[info.row][info.col+1] != '#'){\n\t\t\tif(visited_E == false && is_num(info.row,info.col+1) == true){\n\t\t\t\tresult_E += base_map[info.row][info.col+1]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[East]);\n\t\t\tif(dp[info.row][info.col+1][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_E){\n\t\t\t\tdp[info.row][info.col+1][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_E;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col+1,info.back_count,info.moved_count+1,info.sum+result_E);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[East][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//下へ\n\t\tif(rangeCheck(info.row+1,info.col) == true && base_map[info.row+1][info.col] != '#'){\n\t\t\tif(visited_S == false && is_num(info.row+1,info.col) == true){\n\t\t\t\tresult_S += base_map[info.row+1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[South]);\n\t\t\tif(dp[info.row+1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_S){\n\t\t\t\tdp[info.row+1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_S;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row+1,info.col,info.back_count,info.moved_count+1,info.sum+result_S);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[South][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\tif(info.back_count == K)continue;\n\n\t\t//左へ\n\t\tif(rangeCheck(info.row,info.col-1) == true && base_map[info.row][info.col-1] != '#'){\n\t\t\tif(visited_W == false && is_num(info.row,info.col-1) == true){\n\t\t\t\tresult_W += base_map[info.row][info.col-1]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[West]);\n\t\t\tif(dp[info.row][info.col-1][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_W){\n\t\t\t\tdp[info.row][info.col-1][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_W;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col-1,info.back_count+1,info.moved_count+1,info.sum+result_W);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[West][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//上へ\n\t\tif(rangeCheck(info.row-1,info.col) == true && base_map[info.row-1][info.col] != '#'){\n\t\t\tif(visited_N == false && is_num(info.row-1,info.col) == true){\n\t\t\t\tresult_N += base_map[info.row-1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[North]);\n\t\t\tif(dp[info.row-1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_N){\n\t\t\t\tdp[info.row-1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_N;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row-1,info.col,info.back_count+1,info.moved_count+1,info.sum+result_N);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[North][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\tfor(int state = 0; state < POW[6]; state++){\n\t\tfor(int count = 4; count <= 6; count++){\n\t\t\tans = max(ans,dp[H-1][W-1][K][count][state]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tEast,\n\tSouth,\n\tWest,\n\tNorth,\n};\n\nstruct Info{\n\tvoid set(int arg_row,int arg_col,int arg_back_count,int arg_moved_count,int arg_sum){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tback_count = arg_back_count;\n\t\tmoved_count = arg_moved_count;\n\t\tsum = arg_sum;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum > arg.sum;\n\t}\n\n\tint row,col,back_count,moved_count,sum;\n\tType move_log[6];\n};\n\nint H,W,K;\nint POW[7];\nint dp[50][50][4][7][1024]; //dp[row][col][Kの残数][moved_count][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint makeCode(Type move_log[6]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < 6; i++){\n\t\tret += move_log[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\nbool is_num(int row,int col){\n\treturn base_map[row][col] >= '1' && base_map[row][col] <= '9'; //0の土産物屋はない\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++)POW[i] = pow(4,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= K; i++){\n\t\t\t\tfor(int count = 0; count <= 6; count++){\n\t\t\t\t\tfor(int state = 0; state < POW[6]; state++)dp[row][col][i][count][state] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tInfo first;\n\tfirst.set(0,0,0,0,0);\n\tfor(int i = 0; i < 6; i++)first.move_log[i] = East;\n\n\tdp[0][0][0][0][0] = 0;\n\n\tQ.push(first);\n\n\tInfo info;\n\twhile(!Q.empty()){\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tint tmp_code = makeCode(info.move_log);\n\t\tif(dp[info.row][info.col][info.back_count][min(6,info.moved_count)][tmp_code] > info.sum)continue;\n\n\t\tType next_move_log[4][6];\n\t\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\t\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t\t//過去の移動ログから、訪問済のマス情報を特定する\n\t\tint tmp_row = info.row,tmp_col = info.col;\n\n\t\tfor(int i = 0; i < min(info.moved_count,6); i++){\n\t\t\tswitch(info.move_log[i]){ //ログを打ち消す方向に動く\n\t\t\tcase East:\n\t\t\t\ttmp_col--;\n\t\t\t\tbreak;\n\t\t\tcase South:\n\t\t\t\ttmp_row--;\n\t\t\t\tbreak;\n\t\t\tcase West:\n\t\t\t\ttmp_col++;\n\t\t\t\tbreak;\n\t\t\tcase North:\n\t\t\t\ttmp_row++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp_row == info.row && tmp_col == info.col+1){ //右のマスと一致\n\t\t\t\tvisited_E = true;\n\t\t\t}else if(tmp_row == info.row+1 && tmp_col == info.col){ //下のマスと一致\n\t\t\t\tvisited_S = true;\n\t\t\t}else if(tmp_row == info.row && tmp_col == info.col-1){ //左のマスと一致\n\t\t\t\tvisited_W = true;\n\t\t\t}else if(tmp_row == info.row-1 && tmp_col == info.col){ //上のマスと一致\n\t\t\t\tvisited_N = true;\n\t\t\t}\n\t\t}\n\n\t\t//次の移動ログを作る\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\tnext_move_log[i][k+1] = info.move_log[k]; //右に1つシフト\n\t\t\t}\n\t\t\tswitch(i){\n\t\t\tcase 0:\n\t\t\t\tnext_move_log[i][0] = East;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnext_move_log[i][0] = South;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnext_move_log[i][0] = West;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tnext_move_log[i][0] = North;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//右へ\n\t\tif(rangeCheck(info.row,info.col+1) == true && base_map[info.row][info.col+1] != '#'){\n\t\t\tif(visited_E == false && is_num(info.row,info.col+1) == true){\n\t\t\t\tresult_E += base_map[info.row][info.col+1]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[East]);\n\t\t\tif(dp[info.row][info.col+1][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_E){\n\t\t\t\tdp[info.row][info.col+1][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_E;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col+1,info.back_count,info.moved_count+1,info.sum+result_E);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[East][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//下へ\n\t\tif(rangeCheck(info.row+1,info.col) == true && base_map[info.row+1][info.col] != '#'){\n\t\t\tif(visited_S == false && is_num(info.row+1,info.col) == true){\n\t\t\t\tresult_S += base_map[info.row+1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[South]);\n\t\t\tif(dp[info.row+1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_S){\n\t\t\t\tdp[info.row+1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_S;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row+1,info.col,info.back_count,info.moved_count+1,info.sum+result_S);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[South][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\tif(info.back_count == K)continue;\n\n\t\t//左へ\n\t\tif(rangeCheck(info.row,info.col-1) == true && base_map[info.row][info.col-1] != '#'){\n\t\t\tif(visited_W == false && is_num(info.row,info.col-1) == true){\n\t\t\t\tresult_W += base_map[info.row][info.col-1]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[West]);\n\t\t\tif(dp[info.row][info.col-1][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_W){\n\t\t\t\tdp[info.row][info.col-1][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_W;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col-1,info.back_count+1,info.moved_count+1,info.sum+result_W);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[West][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//上へ\n\t\tif(rangeCheck(info.row-1,info.col) == true && base_map[info.row-1][info.col] != '#'){\n\t\t\tif(visited_N == false && is_num(info.row-1,info.col) == true){\n\t\t\t\tresult_N += base_map[info.row-1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[North]);\n\t\t\tif(dp[info.row-1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_N){\n\t\t\t\tdp[info.row-1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_N;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row-1,info.col,info.back_count+1,info.moved_count+1,info.sum+result_N);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[North][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\tfor(int state = 0; state < POW[6]; state++){\n\t\tfor(int count = 4; count <= 6; count++){\n\t\t\tans = max(ans,dp[H-1][W-1][K][count][state]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tEast,\n\tSouth,\n\tWest,\n\tNorth,\n};\n\nstruct Info{\n\tvoid set(int arg_row,int arg_col,int arg_back_count,int arg_moved_count,int arg_sum,int arg_move_log){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tback_count = arg_back_count;\n\t\tmoved_count = arg_moved_count;\n\t\tsum = arg_sum;\n\t\tmove_log = arg_move_log;\n\t}\n\tbool operator<(const struct Info &arg) const{ //総和の降順(PQ)\n\t\treturn sum < arg.sum;\n\t}\n\n\tint row,col,back_count,moved_count,sum,move_log;\n};\n\nint H,W,K;\nint POW[7];\nint dp[50][50][4][4096]; //dp[row][col][Kの残数][moved_count][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint makeCode(Type move_log[6]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < 6; i++){\n\t\tret += move_log[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\nbool is_num(int row,int col){\n\treturn base_map[row][col] >= '1' && base_map[row][col] <= '9'; //0の土産物屋はない\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++)POW[i] = pow(4,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= K; i++){\n\t\t\t\tfor(int state = 0; state < POW[6]; state++)dp[row][col][i][state] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tInfo first;\n\tfirst.set(0,0,0,0,0,0);\n\n\tdp[0][0][0][0] = 0;\n\n\tint bit_mask = 4095;\n\n\tQ.push(first);\n\n\tint log_array[6],tmp_log;\n\n\tInfo info;\n\twhile(!Q.empty()){\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tif(dp[info.row][info.col][info.back_count][info.move_log] > info.sum)continue;\n\n\t\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\t\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t\t//過去の移動ログから、訪問済のマス情報を特定する\n\t\tint tmp_row = info.row,tmp_col = info.col;\n\n\t\ttmp_log = info.move_log;\n\t\t//printf(\"tmp_log:%d\\n\",tmp_log);\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tlog_array[i] = tmp_log & 3;\n\t\t\t//printf(\"array[%d]:%d\\n\",i,log_array[i]);\n\t\t\ttmp_log /= 4;\n\t\t}\n\n\t\tfor(int i = 0; i < min(6,info.moved_count); i++){\n\t\t\tswitch(log_array[i]){ //ログを打ち消す方向に動く\n\t\t\tcase 0:\n\t\t\t\ttmp_col--;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttmp_row--;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttmp_col++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\ttmp_row++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp_row == info.row && tmp_col == info.col+1){ //右のマスと一致\n\t\t\t\tvisited_E = true;\n\t\t\t}else if(tmp_row == info.row+1 && tmp_col == info.col){ //下のマスと一致\n\t\t\t\tvisited_S = true;\n\t\t\t}else if(tmp_row == info.row && tmp_col == info.col-1){ //左のマスと一致\n\t\t\t\tvisited_W = true;\n\t\t\t}else if(tmp_row == info.row-1 && tmp_col == info.col){ //上のマスと一致\n\t\t\t\tvisited_N = true;\n\t\t\t}\n\t\t}\n\n\t\t//次の移動ログを作る\n\n\n\t\t//右へ\n\t\tif(rangeCheck(info.row,info.col+1) == true && base_map[info.row][info.col+1] != '#'){\n\t\t\tif(visited_E == false && is_num(info.row,info.col+1) == true){\n\t\t\t\tresult_E += base_map[info.row][info.col+1]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|0;\n\t\t\tif(dp[info.row][info.col+1][info.back_count][next_code] < info.sum+result_E){\n\t\t\t\tdp[info.row][info.col+1][info.back_count][next_code] = info.sum+result_E;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col+1,info.back_count,info.moved_count+1,info.sum+result_E,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//下へ\n\t\tif(rangeCheck(info.row+1,info.col) == true && base_map[info.row+1][info.col] != '#'){\n\t\t\tif(visited_S == false && is_num(info.row+1,info.col) == true){\n\t\t\t\tresult_S += base_map[info.row+1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|1;\n\t\t\tif(dp[info.row+1][info.col][info.back_count][next_code] < info.sum+result_S){\n\t\t\t\tdp[info.row+1][info.col][info.back_count][next_code] = info.sum+result_S;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row+1,info.col,info.back_count,info.moved_count+1,info.sum+result_S,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\tif(info.back_count == K)continue;\n\n\t\t//左へ\n\t\tif(rangeCheck(info.row,info.col-1) == true && base_map[info.row][info.col-1] != '#'){\n\t\t\tif(visited_W == false && is_num(info.row,info.col-1) == true){\n\t\t\t\tresult_W += base_map[info.row][info.col-1]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|2;\n\t\t\tif(dp[info.row][info.col-1][info.back_count+1][next_code] < info.sum+result_W){\n\t\t\t\tdp[info.row][info.col-1][info.back_count+1][next_code] = info.sum+result_W;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col-1,info.back_count+1,info.moved_count+1,info.sum+result_W,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//上へ\n\t\tif(rangeCheck(info.row-1,info.col) == true && base_map[info.row-1][info.col] != '#'){\n\t\t\tif(visited_N == false && is_num(info.row-1,info.col) == true){\n\t\t\t\tresult_N += base_map[info.row-1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|3;\n\t\t\tif(dp[info.row-1][info.col][info.back_count+1][next_code] < info.sum+result_N){\n\t\t\t\tdp[info.row-1][info.col][info.back_count+1][next_code] = info.sum+result_N;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row-1,info.col,info.back_count+1,info.moved_count+1,info.sum+result_N,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\tfor(int state = 0; state < POW[6]; state++){\n\t\tfor(int count = 4; count <= 6; count++){\n\t\t\tans = max(ans,dp[H-1][W-1][K][state]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\nbool used[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  map<pii,int> m;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[pii(i+oy,j+ox)]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[pii(ny,nx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 全体のビット右にをシフト\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 下方向にビットをシフト\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nstruct Sit{\n  int cy,cx,mask,my,mx;\n  Sit(){}\n  Sit(int cy_,int cx_,int mask_,int my_,int mx_){\n    cy=cy_;\n    cx=cx_;\n    mask=mask_;\n    my=my_;\n    mx=mx_;\n  }\n  bool operator<(const Sit&sit)const{\n    return true;\n  }\n};\ntypedef pair<int,Sit> iSit;\n\nconst int INF=(1<<30);\nint dfs(int cy,int cx,int mask,int my,int mx){\n  if(used[cy][cx][mask][my][mx])return dp[cy][cx][mask][my][mx];\n  int res=-INF;\n  int leftK=K-(my+mx);\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n      int nmask=p.first;\n      int nAddVal=p.second;\n      // cout<<nAddVal<<endl;\n      if(leftK>0&&(i==0||i==3)){\n        res=max(res,dfs(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))+nAddVal);\n      }\n      else if((i==1||i==2)){\n        res=max(res,dfs(ny,nx,nmask,my,mx)+nAddVal);\n      }\n    }\n  }\n  if(cy==H-1&&cx==W-1)res=max(res,0);\n  used[cy][cx][mask][my][mx]=true;\n  return dp[cy][cx][mask][my][mx]=res;\n}\n\nint dijkstra(){\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][1<<6][0][0]=0;\n  priority_queue<iSit> pq;\n  pq.push(make_pair(0,Sit(0,0,1<<6,0,0)));\n  while(pq.size()){\n    iSit is=pq.top();pq.pop();\n    int cval=is.first;\n    Sit cSit=is.second;\n    int cy=cSit.cy,cx=cSit.cx,mask=cSit.mask,my=cSit.my,mx=cSit.mx;\n    if(dp[cy][cx][mask][my][mx]>cval)continue;\n    int leftK=K-(my+mx);\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n        pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n        int nmask=p.first;\n        int nAddVal=p.second;\n        if(leftK>0&&(i==0||i==3)&&dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]<cval+nAddVal){\n          dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))));\n        }\n        else if((i==1||i==2)&&dp[ny][nx][nmask][my][mx]<cval+nAddVal){\n          dp[ny][nx][nmask][my][mx]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my,mx)));\n        }\n      }\n    }\n  }\n  int res=0;\n  for(int mask=0;mask<(1<<10);mask++)\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        res=max(res,dp[H-1][W-1][mask][i][j]);\n  return res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  memset(dp,-1,sizeof(dp));\n  // assert(dfs(0,0,(1<<6),0,0)==dijkstra());\n  cout<<dfs(0,0,(1<<6),0,0)<<endl;\n  //cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\nint h,w,K;\nstring str;\nint fie[100][100];\nmap<int,map<int,map<int,map<int,short> > > > dp;\nmap<int,map<int,map<int,map<int,bool> > > > check;\nint res=0;\n\nshort dfs(int x,int y,int k,int bit,int pc){\n\tint nx=x,ny=y;\n\tif(check[x][y][k][bit])return dp[x][y][k][bit];\n\t\n\t//11nx++,10nx--,01ny++,00ny--;\n\tint nbit=bit;\n\tif(nbit >>11 & 1)nbit-=1<<11;\n\tif(nbit >>10 & 1)nbit-=1<<10;\n\tnbit<<=2;\n\tshort r=-20000;\n\tif(k>=1){\n\t\tnbit+=2;\n\t\tx--;\n\t\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\t\tr=max(r,dfs(x,y,k-1,nbit,pc+1));\n\t\t}\n\t\tx++;\n\t\ty--;\n\t\tnbit-=2;\n\t\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\t\tr=max(r,dfs(x,y,k-1,nbit,pc+1));\n\t\t}\n\t\ty++;\n\t}\n\tnbit+=3;\n\tx++;\n\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\tr=max(r,dfs(x,y,k,nbit,pc+1));\n\t}\n\tx--;\n\tnbit-=2;\n\ty++;\n\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\tr=max(r,dfs(x,y,k,nbit,pc+1));\n\t}\n\ty--;\n\t\n\tint sum=0;\n\tbool f=false;\n\tfor(int i=0;i<min(pc,6);i++){\n\t\tif(bit >>i*2 & 1){\n\t\t\tif(bit >>(i*2+1) & 1)nx--;\n\t\t\telse ny--;\n\t\t}else{\n\t\t\tif(bit >>(i*2+1) & 1)nx++;\n\t\t\telse ny++;\n\t\t}\n\t\tif(nx==x && ny==y){\n\t\t\tf=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f)sum+=fie[x][y];\n\t\n\tif(r<0 && x==w-1 && y==h-1)r=0;\n\tcheck[x][y][k][bit]=true;\n\treturn (dp[x][y][k][bit]=sum+r);\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&h,&w,&K);\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=0;i<h;i++){\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]=='.')fie[j][i]=0;\n\t\t\telse if(str[j]=='#')fie[j][i]=-1;\n\t\t\telse fie[j][i]=str[j]-'0';\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dfs(0,0,K,0,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\ntypedef pair<Pair, Pair> PP;\n\nint H;\nint W;\nint K;\nint ans;\nchar field[114][514];\nvector<Pair> around;\nqueue<PP> q;\nmap<PP, bool> calced;\nmap<Pair, int> rev;\nmap<int, int> dp[114][114][4];\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\nbool nocost[] = {0, 0, 1, 1};\n\nbool WithinRange(int y, int x) {\n  if (y < 0 || H <= y) return false;\n  if (x < 0 || W <= x) return false;\n  return true;\n}\n\nint ShiftHash(int hash, int dy, int dx) {\n  int ret = 0;\n  for (Pair p : around) {\n    int y, x;\n    tie(y, x) = p;\n    int py = y + dy;\n    int px = x + dx;\n    if (rev.count(Pair(py, px))) {\n      int v = hash >> rev[Pair(py, px)] & 1;\n      ret |= v << rev[p];\n    }\n  }\n  return ret;\n}\n\nint main() {\n  scanf(\"%d%d%d\", &H, &W, &K);\n  for (int i=0; i<H; i++) {\n    for (int j=0; j<W; j++) {\n      scanf(\" %c\", &field[i][j]);\n      if (field[i][j] == '.') field[i][j] = '0';\n    }\n  }\n\n  for (int i=-3; i<=3; i++) {\n    for (int j=-3; j<=3; j++) {\n      if (i == 0 && j == 0) continue;\n      if (abs(i)+abs(j) <= 3) {\n        rev[Pair(i, j)] = around.size();\n        around.emplace_back(Pair(i, j));\n      }\n    }\n  }\n\n  dp[0][0][K][0] = 0;\n  q.push(PP(Pair(0, 0), Pair(K, 0)));\n  while (!q.empty()) {\n    PP pp = q.front(); q.pop();\n    int y, x, k, hash;\n    tie(y, x) = pp.first;\n    tie(k, hash) = pp.second;\n    if (field[y][x] == '#') continue;\n    if (calced.count(pp)) continue;\n    calced[pp] = true;\n    \n    int val = dp[y][x][k][hash];\n    //printf(\"(%d, %d, %d, %d): %d\\n\", y, x, k, hash, val);\n    if (y == H-1 && x == W-1) {\n      ans = max(ans, val);\n    }\n\n    for (int i=0; i<4; i++) {\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if (!WithinRange(ny, nx)) continue;\n      if (field[ny][nx] == '#') continue;\n\n      int plus = field[ny][nx] - '0';\n      if (hash >> rev[Pair(dy[i], dx[i])] & 1) plus = 0;\n    \n      int nk = k;\n      if (!nocost[i]) {\n        if (k == 0) continue;\n        nk = k-1;\n      }\n\n      int nhash = ShiftHash(hash, dy[i], dx[i]);\n      nhash |= 1 << rev[Pair(-dy[i], -dx[i])];\n      for (Pair p : around) {\n        int a, b;\n        tie(a, b) = p;\n        int d = -(min(a, 0)+min(b, 0));\n        if (d > nk) nhash &= ~(1 << rev[p]);\n      }\n\n      dp[ny][nx][nk][nhash] = max(dp[ny][nx][nk][nhash], val+plus);\n      q.push(PP(Pair(ny, nx), Pair(nk, nhash)));\n    }     \n  }\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint h, w, k;\nchar s[51][51];\nint dp[51][51][1 << 12][4], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nbool used[51][51];\nvoid mark(int x, int y, int t, int s) {\n\tused[x][y] = true;\n\tif (s == 0)return;\n\tint a = ((t >> 1 & 1) << 1) + (t & 1);\n\tx -= dx[a], y -= dy[a];\n\tt >>= 2;\n\tmark(x, y, t, s - 1);\n}\nint rec(int x, int y, int t, int a, int cnt) {\n\tif (dp[x][y][t][a] != -1)return dp[x][y][t][a];\n\tint res = -INF;\n\trep(i, 4) {\n\t\tif (i % 2 && !a)continue;\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || s[nx][ny] == '#')continue;\n\t\tmemset(used, 0, sizeof(used));\n\t\tmark(x, y, t, cnt);\n\t\tint v = ((!used[nx][ny] && '1' <= s[nx][ny] && s[nx][ny] <= '9') ? s[nx][ny] - '0' : 0);\n\t\tint p = (t >> (k * 4 - 2)) << (k * 4 - 2); p = t - p;\n\t\tp = (p << 2) + i; int b = cnt; if (b < 2 * k)b++;\n\t\tint o = rec(nx, ny, p, a - i % 2, b);\n\t\tif (o != -INF)res = max(res, o + v);\n\t}\n\tif (x == h - 1 && y == w - 1 && res == -INF) {\n\t\treturn dp[x][y][t][a] = 0;\n\t}\n\treturn dp[x][y][t][a] = res;\n}\nint main() {\n\tscanf(\"%d%d%d\", &h, &w, &k);\n\trep(i, h)scanf(\"%s\", s[i]);\n\tmemset(dp, -1, sizeof(dp));\n\tprintf(\"%d\\n\", rec(0, 0, 0, k, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#define INF -(1 << 23)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint main()\n{\n\tint H, W, K;\n\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &K);\n\n\tvector<string> M(H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tcin >> M[i];\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (M[i][j] == '.')\n\t\t\t{\n\t\t\t\tM[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<vector<vector<int> > > > dp(H, vector<vector<vector<int> > >(W, vector<vector<int> >(K + 1, vector<int>(4096, INF))));\n\n\tdp[0][0][0][0] = 0;\n\n\tfor (int rep = 0; rep <= K; rep++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= K; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < 4096; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint dir = l % 4;\n\n\t\t\t\t\t\t\tint p6 = l / 1024;\n\t\t\t\t\t\t\tint p5 = (l / 256) % 4;\n\t\t\t\t\t\t\tint p4 = (l / 64) % 4;\n\t\t\t\t\t\t\tint p3 = (l / 16) % 4;\n\t\t\t\t\t\t\tint p2 = (l / 4) % 4;\n\t\t\t\t\t\t\tint p1 = l % 4;\n\n\t\t\t\t\t\t\tint px1 = j + dx[p1];\n\t\t\t\t\t\t\tint px2 = px1 + dx[p2];\n\t\t\t\t\t\t\tint px3 = px2 + dx[p3];\n\t\t\t\t\t\t\tint px4 = px3 + dx[p4];\n\t\t\t\t\t\t\tint px5 = px4 + dx[p5];\n\t\t\t\t\t\t\tint px6 = px5 + dx[p6];\n\t\t\t\t\t\t\tint py1 = i + dy[p1];\n\t\t\t\t\t\t\tint py2 = py1 + dy[p2];\n\t\t\t\t\t\t\tint py3 = py2 + dy[p3];\n\t\t\t\t\t\t\tint py4 = py3 + dy[p4];\n\t\t\t\t\t\t\tint py5 = py4 + dy[p5];\n\t\t\t\t\t\t\tint py6 = py5 + dy[p6];\n\n\t\t\t\t\t\t\tbool ok1 = true, ok2 = true, ok3 = true, ok4 = true, ok5 = true, ok6 = true;\n\n\t\t\t\t\t\t\tif (0 <= px1 && px1 < W && 0 <= py1 && py1 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py1][px1] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok1 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px2 && px2 < W && 0 <= py2 && py2 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py2][px2] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px3 && px3 < W && 0 <= py3 && py3 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py3][px3] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok3 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px4 && px4 < W && 0 <= py4 && py4 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py4][px4] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok4 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px5 && px5 < W && 0 <= py5 && py5 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py5][px5] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok5 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px6 && px6 < W && 0 <= py6 && py6 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py6][px6] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok6 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint rate = 1;\n\n\t\t\t\t\t\t\tif ((j == px1 && i == py1 && !ok1) || (j == px2 && i == py2 && !ok2) || (j == px3 && i == py3 && !ok3) || (j == px4 && i == py4 && !ok4) || (j == px5 && i == py5 && !ok5) || (j == px6 && i == py6 && !ok6))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trate = 0;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((0 <= j + dx[dir] && j + dx[dir] < W && 0 <= i + dy[dir] && i + dy[dir] < H) && !((dir % 3) && k == 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint r = m * 1024 + l / 4;\n\n\t\t\t\t\t\t\t\t\tif (dir % 3)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k - 1][r] + (M[i][j] - 48) * rate);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k][r] + (M[i][j] - 48) * rate);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = -1;\n\n\tfor (int i = 0; i <= K; i++)\n\t{\n\t\tfor (int j = 0; j < 4096; j++)\n\t\t{\n\t\t\tret = max(ret, dp[H - 1][W - 1][i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define chmax(a,b) ((a) = max((a),(b)))\nusing namespace std;\n\nconst int dy[] = {0,1,0,-1}, dx[] = {1,0,-1,0};\nint dp[50][50][4][1<<12];\nint vis[1<<12];\n\ninline bool visit(int bit){\n  //if(vis[bit]>=0)return vis[bit];\n  int y=0, x=0;\n  rep(i,6){\n    int d = bit&3; bit>>=2;\n    y += dy[d], x += dx[d];\n    if(y==0 && x==0)return vis[bit] = true;\n  }\n  return vis[bit] = false;\n}\n\nint main(){\n  int h,w,k;\n  string g[50];\n  cin >> h >> w >> k;\n  rep(i,h)cin >> g[i];\n\n  memset(vis,-1,sizeof(vis));\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0][0] = isdigit(g[0][0])?(int)(g[0][0]-'0'):0;\n\n  rep(rev,k+1){\n    rep(y,h)rep(x,w){\n      if(g[y][x] == '#')continue;\n      rep(bit,1<<12){\n\tif(dp[y][x][rev][bit]<0)continue;\n\n\trep(d,4){\n\t  int ny = y+dy[d], nx = x+dx[d];\n\t  if(!range(ny,0,h) || !range(nx,0,w))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  int nbit = ((bit<<2)|d) & ((1<<12)-1);\n\t  int item = isdigit(g[ny][nx])?(int)(g[ny][nx]-'0'):0;\n\t  if(visit(nbit))item = 0;\n\n\t  if(d<2){\n\t    chmax(dp[ny][nx][rev][nbit], dp[y][x][rev][bit] + item);\n\t  }else if(rev!=k){\n\t    chmax(dp[ny][nx][rev+1][nbit], dp[y][x][rev][bit] + item);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = 0;\n  rep(bit,1<<12)chmax(res, dp[h-1][w-1][k][bit]);\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define INF 1145141919\n\ntypedef pair<int, int> P;\nint H, W, K;\nint map[60][60];\nint dp[50][50][4][2048];\n\nbool f(int s, int t) {\n  return s & (1 << (t-1));\n}\n\nint main() {\n  cin >> H >> W >> K;\n  for (int y=0; y<H; y++) {\n    for (int x=0; x<W; x++) {\n      char c;\n      cin >> c;\n      map[x][y] = c == '#' ? -1 : c == '.' ? 0 : (int)c-(int)'0';\n    }\n  }\n  for (int x=0; x<W; x++) {\n    for (int y=0; y<H; y++) {\n      for (int k=0; k<=K; k++) {\n        for (int s=0; s<2048; s++) {\n          dp[x][y][k][s] = -INF;\n        }\n      }\n    }\n  }\n  dp[0][0][0][0] = 0;\n  queue< pair<P, P> > q;\n  q.push(make_pair(P(0, 0), P(0, 0)));\n\n  while (!q.empty()) {\n    int x = q.front().first.first, y = q.front().first.second,\n        k = q.front().second.first, s = q.front().second.second; q.pop();\n    if (x < W-1 && map[x+1][y] != -1) {\n      int ns = 0;\n      if (k == 0) ns = (1<<1)*f(s,3) | (1<<3)*f(s,5) | (1<<4)*f(s,6) | (1<<6)*f(s,8) | (1<<7)*f(s,9) | (1<<8);\n      if (k == 1) ns = (1<<0)*f(s,2) | (1<<2)*f(s,4) | (1<<3)*f(s,5) | (1<<5)*f(s,7) | (1<<6) | (1<<8)*f(s,10) | (1<<9)*f(s,11);\n      if (k == 2) ns = (1<<0)*f(s,2) | (1<<1)*f(s,3) | (1<<3) | (1<<4)*f(s,6) | (1<<6)*f(s,8) | (1<<7)*f(s,9) | (1<<9)*f(s,11);\n      if (k == 3) ns = (1<<0)*f(s,2) | (1<<1)*f(s,3) | (1<<3)*f(s,5) | (1<<4)*f(s,6) | (1<<6)*f(s,8);\n      bool t = (k==1 && f(s,8)) || (k==2 && f(s,5)) || (k==3 && f(s,1));\n      if (dp[x+1][y][k][ns] < dp[x][y][k][s] + (t?0:map[x+1][y])) {\n        dp[x+1][y][k][ns] = dp[x][y][k][s] + (t?0:map[x+1][y]);\n        q.push(make_pair(P(x+1, y), P(k, ns)));\n      }\n    }\n    if (y < H-1 && map[x][y+1] != -1) {\n      int ns = 0;\n      if (k == 0) ns = (1<<0)*f(s,3) | (1<<1)*f(s,5) | (1<<2)*f(s,6) | (1<<3)*f(s,8) | (1<<4)*f(s,9) | (1<<5);\n      if (k == 1) ns = (1<<0)*f(s,4) | (1<<1)*f(s,5) | (1<<2)*f(s,7) | (1<<3) | (1<<4)*f(s,8) | (1<<5)*f(s,9) | (1<<6)*f(s,10);\n      if (k == 2) ns = (1<<0) | (1<<1)*f(s,5) | (1<<2)*f(s,6) | (1<<3)*f(s,7) | (1<<4)*f(s,9) | (1<<6)*f(s,10) | (1<<7)*f(s,11);\n      if (k == 3) ns = (1<<0)*f(s,5) | (1<<1)*f(s,6) | (1<<3)*f(s,7) | (1<<4)*f(s,8) | (1<<6)*f(s,9);\n      bool t = (k==1 && f(s,11)) || (k==2 && f(s,8)) || (k==3 && f(s,4));\n      if (dp[x][y+1][k][ns] < dp[x][y][k][s] + (t?0:map[x][y+1])) {\n        dp[x][y+1][k][ns] = dp[x][y][k][s] + (t?0:map[x][y+1]);\n        q.push(make_pair(P(x, y+1), P(k, ns)));\n      }\n    }\n    if (k < K && x > 0 && map[x-1][y] != -1) {\n      int ns = 0;\n      if (k == 0) ns = (1<<0)*f(s,2) | (1<<1)*f(s,3) | (1<<2)*f(s,4) | (1<<3)*f(s,5) | (1<<4)*f(s,6) | (1<<5)*f(s,7) | (1<<6)*f(s,8) | (1<<7);\n      if (k == 1) ns = (1<<0)*f(s,3) | (1<<1)*f(s,4) | (1<<2)*f(s,5) | (1<<3)*f(s,6) | (1<<4) | (1<<5)*f(s,8) | (1<<6)*f(s,9) | (1<<7)*f(s,10) | (1<<8)*f(s,11);\n      if (k == 2) ns = (1<<0) | (1<<1)*f(s,5) | (1<<2)*f(s,6) | (1<<3)*f(s,7) | (1<<4)*f(s,8) | (1<<5)*f(s,9) | (1<<6)*f(s,10) | (1<<7)*f(s,11);\n      bool t = (k==0 && f(s,9)) || (k==1 && f(s,7)) || (k==2 && f(s,4));\n      if (dp[x-1][y][k+1][ns] < dp[x][y][k][s] + (t?0:map[x-1][y])) {\n        dp[x-1][y][k+1][ns] = dp[x][y][k][s] + (t?0:map[x-1][y]);\n        q.push(make_pair(P(x-1, y), P(k+1, ns)));\n      }\n    }\n    if (k < K && y > 0 && map[x][y-1] != -1) {\n      int ns = 0;\n      if (k == 0) ns = (1<<0)*f(s,1) | (1<<2)*f(s,2) | (1<<3)*f(s,3) | (1<<5)*f(s,4) | (1<<6)*f(s,5) | (1<<8)*f(s,8) | (1<<9)*f(s,9) | (1<<10);\n      if (k == 1) ns = (1<<0)*f(s,1) | (1<<1)*f(s,2) | (1<<3)*f(s,3) | (1<<4)*f(s,5) | (1<<6)*f(s,7) | (1<<7) | (1<<8)*f(s,8) | (1<<9)*f(s,10) | (1<<10)*f(s,11);\n      if (k == 2) ns = (1<<1)*f(s,2) | (1<<2)*f(s,3) | (1<<3) | (1<<4)*f(s,5) | (1<<5)*f(s,6) | (1<<6)*f(s,8) | (1<<7)*f(s,9) | (1<<8)*f(s,11);\n      bool t = (k==0 && f(s,6)) || (k==1 && f(s,4)) || (k==2 && f(s,1));\n      if (dp[x][y-1][k+1][ns] < dp[x][y][k][s] + (t?0:map[x][y-1])) {\n        dp[x][y-1][k+1][ns] = dp[x][y][k][s] + (t?0:map[x][y-1]);\n        q.push(make_pair(P(x, y-1), P(k+1, ns)));\n      }\n    }\n  }\n  int ans = 0;\n  for (int k=0; k<=K; k++) {\n    for (int s=0; s<(k==0||k==3?512:2048); s++) {\n      ans = max(ans, dp[W-1][H-1][k][s]);\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline void ChMax(int& a, int b){ a = max(a, b); }\n\nconst int dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nconst int bitMask = (1 << 12) - 1;\nint H, W, K;\nchar S[50][50];\nint dp[50][50][1 << 12];\nbool Visited[1 << 12];\n\n\n\nint main()\n{\n  memset(dp, -1, sizeof(dp));\n  for (int i = 0; i < (1 << 12); i++) {\n    int nx = 0, ny = 0, bit = i;\n    for(int j = 0; j < 6; j++, bit >>= 2) {\n      nx -= dx[bit & 3], ny -= dy[bit & 3];\n      if (nx == 0 && ny == 0) Visited[i] = true;\n    }\n  }\n\n  cin >> H >> W >> K;\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cin >> S[i][j];\n    }\n  }\n\n  dp[0][0][bitMask] = 0;\n\n  for(int m = K; m >= 0; m--) {\n    int notnext = m == 0;\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        for (int k = 0; k < (1 << 12); k++) {\n          if (dp[i][j][k] == -1) continue;\n          int Get = 0;\n          if (isdigit(S[i][j]) && !Visited[k]) Get += S[i][j] - '0';\n          for (int l = notnext << 1; l < 4; l++) {\n            int ny = i + dy[l], nx = j + dx[l];\n            if (ny < 0 || nx < 0 || ny >= H || nx >= W) continue;\n            if (S[ny][nx] == '#')                       continue;\n            ChMax(dp[ny][nx][((k << 2) | l) & bitMask], dp[i][j][k] + Get);\n          }\n        }\n      }\n    }\n  }\n  cout << *max_element(dp[H - 1][W - 1], dp[H - 1][W]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\nbool used[51][51][1<<10][4][4];\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\nconst int base=50;\nint m[101][101]={};\n\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  memset(m,0,sizeof(m));\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[i+oy+base][j+ox+base]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[ny+base][nx+base];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 全体のビット右にをシフト\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[cy+base][cx+base];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 下方向にビットをシフト\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[cy+base][cx+base];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nconst int INF=(1<<30);\nint dfs(int cy,int cx,int mask,int my,int mx){\n  if(used[cy][cx][mask][my][mx])return dp[cy][cx][mask][my][mx];\n  int res=-INF;\n  int leftK=K-(my+mx);\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n      int nmask=p.first;\n      int nAddVal=p.second;\n      if(leftK>0&&(i==0||i==3))\n        res=max(res,dfs(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))+nAddVal);\n      else if((i==1||i==2))\n        res=max(res,dfs(ny,nx,nmask,my,mx)+nAddVal);\n    }\n  }\n  if(cy==H-1&&cx==W-1)res=max(res,0);\n  used[cy][cx][mask][my][mx]=true;\n  return dp[cy][cx][mask][my][mx]=res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,(1<<6),0,0)<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define chmax(a,b) (a = max(a,b))\nusing namespace std;\n\nconst int dy[] = {0,1,0,-1}, dx[] = {1,0,-1,0};\nint dp[50][50][4][1<<12];\nint vis[1<<12];\n\ninline int visit(int bit){\n  if(vis[bit]>=0)return vis[bit];\n  int y=0, x=0;\n  rep(i,6){\n    int d = bit&3; bit>>=2;\n    y += dy[d], x += dx[d];\n    if(y==0 && x==0)return vis[bit] = 1;\n  }\n  return vis[bit] = 0;\n}\n\nint main(){\n  int h,w,k;\n  string g[50];\n  cin >> h >> w >> k;\n  rep(i,h)cin >> g[i];\n\n  memset(vis,-1,sizeof(vis));\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0][0] = isdigit(g[0][0])?(int)(g[0][0]-'0'):0;\n\n  rep(rev,k+1){\n    rep(y,h)rep(x,w){\n      if(g[y][x] == '#')continue;\n      rep(bit,1<<12){\n\tif(dp[y][x][rev][bit]<0)continue;\n\n\trep(d,4){\n\t  if(rev==k && d>1)break;\n\t  int ny = y+dy[d], nx = x+dx[d];\n\t  if(!range(ny,0,h) || !range(nx,0,w))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  int nbit = ((bit<<2)|d) & ((1<<12)-1);\n\t  int item = isdigit(g[ny][nx])?(int)(g[ny][nx]-'0'):0;\n\t  if(visit(nbit))item = 0;\n\n\t  if(d<2){\n\t    chmax(dp[ny][nx][rev][nbit], dp[y][x][rev][bit] + item);\n\t  }else{\n\t    chmax(dp[ny][nx][rev+1][nbit], dp[y][x][rev][bit] + item);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = 0;\n  rep(bit,1<<12)chmax(res, dp[h-1][w-1][k][bit]);\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define INF 1234567890\n\nint map[60][60];\nchar buf;\nint x_max, y_max, can;\nint ans = 0;\n\nint dp(int x, int y, int can){\n\tif (map[x][y] == -1) return 0;\n\tint before = map[x][y];\n\tint answer = 0;\n\tmap[x][y] = 0;\n\tif (map[x][y - 1] >= 0 && can >= 1) answer = max(answer, dp(x, y - 1, can - 1));\n\tif (map[x][y + 1] >= 0) answer = max(answer, dp(x, y + 1, can));\n\tif (map[x - 1][y] >= 0 && can >= 1) answer = max(answer, dp(x - 1, y, can - 1));\n\tif (map[x + 1][y] >= 0) answer = max(answer, dp(x + 1, y, can));\n\tmap[x][y] = before;\n\tif (x == x_max && y == y_max) return answer + before;\n\telse{\n\t\tif (answer == 0) return -INF;\n\t}\n\treturn answer + before;\n}\n\nint main(){\n\tmemset(map, 255, sizeof(map));\n\tscanf(\"%d%d%d\", &x_max, &y_max, &can);\n\tfor (int a = 1; a <= x_max; a++){\n\t\tfor (int b = 1; b <= y_max; b++){\n\t\t\tscanf(\" %c\", &buf);\n\t\t\tswitch (buf){\n\t\t\tcase '.':\n\t\t\t\tmap[a][b] = 0;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tmap[a][b] = -1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmap[a][b] = (int)buf - (int)'0';\n\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp(1, 1, can));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\ntypedef pair<int, int> Point;\n\nint H, W, K;\nchar grid[64][64];\nvector<Point> rem[4];\nint vis[56][56];\nint dp[50][50][1 << 12];\n\nvoid init()\n{\n\tmemset(grid, '#', sizeof(grid));\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tfor (int k = 0; k <= 3; k++){\n\t\tfor (int x = -k; x <= (3 - k); x++){\n\t\t\tfor (int y = -k; y <= (3 - k); y++){\n\t\t\t\t//if (x == 0 && y == 0) continue;\n\t\t\t\tif (-k <= (x + y) && (x + y) <= (3 - k)){\n\t\t\t\t\trem[k].push_back(Point(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint calcBit(int x, int y, int k)\n{\n\tint res = 0;\n\tfor (Point &p : rem[k]){\n\t\tres <<= 1;\n\t\tint X = x + p.first;\n\t\tint Y = y + p.second;\n\t\tif (vis[X][Y] > 0) res |= 1;\n\t}\n\treturn res;\n}\n\nint calc(int x, int y, int k)\n{\n\tint bit = calcBit(x, y, k);\n\tint &res = dp[x - 3][y - 3][bit];\n\tif (~res) return res;\n\t\n\tint add = 0;\n\tif (grid[x][y] >= '1' && grid[x][y] <= '9'){\n\t\tif (vis[x][y] == 0){\n\t\t\tadd = grid[x][y] - '0';\n\t\t}\n\t}\n\t\n\tif (x == H + 2 && y == W + 2 && k == 0){\n\t\treturn res = add;\n\t}\n\t\n\tres = -(1 << 28);\n\t\n\tvis[x][y]++;\n\tfor (int dir = 0; dir < 4; dir++){\n\t\tint nx = x + dx[dir];\n\t\tint ny = y + dy[dir];\n\t\tint nk = k - (dir < 2);\n\t\tif (grid[nx][ny] == '#') continue;\n\t\tif (nk < 0) continue;\n\t\tres = max(res, calc(nx, ny, nk));\n\t}\n\tvis[x][y]--;\n\t\n\treturn res += add;\n}\n\nint main(void)\n{\n\tinit();\n\t\n\tscanf(\"%d %d %d\", &H, &W, &K);\n\t\n\tfor (int i = 0; i < H; i++){\n\t\tfor (int j = 0; j < W; j++){\n\t\t\tscanf(\" %c\", &grid[i + 3][j + 3]);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", calc(3, 3, K));\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nchar a[50][50];\nint dp[50][50][4][1<<11];\nint bitMap[4][1<<11][4];\nbool canGet[4][1<<11][4];\nvector<pii> needCells[4];\n\nconst int dy[4] = {0,1,0,-1};\nconst int dx[4] = {1,0,-1,0};\n\nint h,w,K;\n\nint solve(int y, int x, int k, int S){\n  int &r = dp[y][x][k][S];\n  if (r != -1) return r;\n  int res = -INF;\n  if (y==h-1&&x==w-1) res = 0;\n  REP(d,4) {\n    int nk = k+(d>=2);\n    if (nk>K) continue;\n    int ny = y+dy[d];\n    int nx = x+dx[d];\n    if (!valid(ny,nx,h,w)) continue;\n    if (a[ny][nx] == '#') continue;\n    int score = canGet[k][S][d]&&isdigit(a[ny][nx]) ? a[ny][nx]-'0' : 0;\n    chmax(res, solve(ny,nx,nk,bitMap[k][S][d]) + score);\n  }\n  return r = res;\n}\n\nint main() {\n  REP(k,4) {\n    for (int y=-3; y<=3; ++y) {\n      for (int x=-3; x<=3; ++x) {\n        if ((y||x) && -min(y,0)-min(x,0) <= 3-k && max(0,y)+max(0,x) <= k)\n          needCells[k].push_back(pii(y,x));\n      }\n    }\n  }\n  REP(k,4) {\n    int n = needCells[k].size();\n    REP(S,1<<n) {\n      REP(d,4) {\n        int nk = k+(d>=2);\n        if (nk == 4) continue;\n        int T = 0;\n        REP(i,n) {\n          if (S>>i&1) {\n            pii p = needCells[k][i];\n            p.first -= dy[d];\n            p.second -= dx[d];\n            REP(j,needCells[nk].size()) {\n              if (needCells[nk][j] == p) {\n                T |= 1 << j;\n              }\n            }\n          }\n        }\n        REP(j,needCells[nk].size()) {\n          if (needCells[nk][j] == pii(-dy[d],-dx[d])) {\n            T |= 1 << j;\n          }\n        }\n        bitMap[k][S][d] = T;\n\n        canGet[k][S][d] = 1;\n        REP(i,n)\n          if (S>>i&1 && needCells[k][i]==pii(dy[d],dx[d]))\n            canGet[k][S][d] = 0;\n      }\n    }\n  }\n  scanf(\"%d%d%d\",&h,&w,&K);\n  REP(i,h) REP(j,w) scanf(\" %c \", a[i]+j);\n  memset(dp,-1,sizeof(dp));\n  cout << solve(0,0,0,0) << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n  \nusing namespace std;\n  \n//#define int long long\n#define PB push_back\n#define MK make_pair\n#define MKT make_tuple\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n  \n//constexpr int INF = 1LL<<60;\nconstexpr int INF = 1 << 28;\n//constexpr int MOD = 100000;\nconstexpr int MAX_N = 52;\nconstexpr int dx[] = { 1, 0, -1, 0 };\nconstexpr int dy[] = { 0, 1, 0, -1 };\n  \nint mem[MAX_N][MAX_N][4][1 << 6][1 << 6], h, w, k, fld[MAX_N][MAX_N];\n  \ninline bool Chk(int x, int y, int mask1, int mask2) {\n    constexpr int len = 6;\n    int cx = x, cy = y;\n    for (int i = 0; i < len; ++i) {\n        int b1 = (mask1 & (1 << (len - 1 - i))) ? 1 : 0, b2 = (mask2 & (1 << (len - 1 - i))) ? 1 : 0;\n        int idx = b1 + 2 * b2;\n        cx -= dx[idx];\n        cy -= dy[idx];\n        if (x == cx && y == cy) {\n            return true;\n        }\n    }\n    return false;\n}\n  \nint Solve(int x, int y, int c, int mask1, int mask2) {\n    if (x == w + 1 && y == h) return 0;\n    if (mem[x][y][c][mask1][mask2] != -1) return mem[x][y][c][mask1][mask2];\n   \n    int cur = Chk(x, y, mask1, mask2) ? 0 : fld[x][y];\n    int res = 0;\n    bool flg = false;\n    for (int i = 0; i < 4; ++i) {\n        if (1 < i && k <= c) break;\n        int tx = x + dx[i], ty = y + dy[i];\n        int nc = (1 < i) ? c + 1 : c;\n        if (fld[tx][ty] == -1) continue;\n        \n        flg = true;\n        int nm1 = (mask1 >> 1) + ((i % 2) << 5), nm2 = (mask2 >> 1) + ((1 < i) << 5);\n        int tmp = Solve(tx, ty, nc, nm1, nm2);\n        if (tmp <= -INF) {\n            flg = false;\n            continue;\n        }\n        res = max(res, tmp);\n    }\n\n    if (!flg) {\n        res = -INF;\n        cur = 0;\n    }\n      \n    return mem[x][y][c][mask1][mask2] = res + cur;\n}\n  \nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n  \n    memset(fld, -1, sizeof(fld));\n    cin >> h >> w >> k;\n    for (int y = 1; y <= h; ++y) {\n        string s;\n        cin >> s;\n        for (int x = 1; x <= w; ++x) {\n            char c = s[x - 1];\n            if (c == '#') {\n                fld[x][y] = -1;\n                continue;\n            } else if (c == '.') {\n                fld[x][y] = 0;\n                continue;\n            }\n            fld[x][y] = c - '0';\n        }\n    }\n    fld[w + 1][h] = 0;\n    memset(mem, -1, sizeof(mem));\n    cout << max(0, Solve(1, 1, 0, 0, 0)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<deque>\n#include<climits>\nusing namespace std;\n\nconst int dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nconst int MAX_STATE = 1<<12;\nint H,W,K,memo[50][50][4][MAX_STATE],fld[50][50],gifts[2500];\n\nint dfs(int y,int x,int k,int s,deque<int> d){\n    if(k>K) return 0;\n    if(memo[y][x][k][s]!=-1) return memo[y][x][k][s];\n    int pls = 0;\n    if(fld[y][x]>=0) pls = gifts[fld[y][x]];\n    for(int i=0;i<d.size();i++){\n        if(d[i]==fld[y][x]) pls = 0;\n    }\n    d.pop_back(); d.push_front(fld[y][x]);\n    int ny,nx;\n    for(int i=0;i<4;i++){\n        ny = y+dy[i]; nx = x+dx[i];\n        if(ny<0 || H<=ny || nx<0 || W<=nx || fld[ny][nx]==-2) continue;\n        int nk = k, ns = ((s<<2)+i)%(1<<12);\n        if(i>=2) nk++;\n        deque<int> nd = d;\n        memo[y][x][k][s] = max(memo[y][x][k][s],dfs(ny,nx,nk,ns,nd));\n    }\n    return memo[y][x][k][s]+pls;\n}\n\nint main(){\n    fill_n((int*)memo,50*50*4*MAX_STATE,-1);\n    int cnt = 0;\n    char in;\n    cin>>H>>W>>K;\n    for(int i=0;i<H;i++)for(int j=0;j<W;j++){\n        cin>>in;\n        if(in=='#') fld[i][j] = -2;\n        else if(in=='.') fld[i][j] = -1;\n        else fld[i][j] = cnt, gifts[cnt++] = in-'0';\n    }\n    deque<int> d(6,-1);\n    printf(\"%d\\n\",dfs(0,0,0,0,d));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nlong long in(){\n\tlong long n;\n\tscanf(\"%lld\",&n);\n\treturn n;\n}\n\n\n/*\nchokuzen no 3 kai no ugoki wo motte DP?\n\n*/\n#define D (k*2)\nchar field[50][50];\n\nint cost[50][50];\n\nint dx[] = {0,1,0,-1,0}; // R D L U\nint dy[] = {0,0,1,0,-1};\nint H,W,K;\n\nint dp[50][50][4][15625];\nint p5[10];\nint dfs(char x,char y,char k,int tail){\n\tif( dp[x][y][k][tail] != -1 ){\n\t\treturn dp[x][y][k][tail];\n\t}\n\tint ans = (x==W-1&&y==H-1)?0:-1e9;\n\t\n\tint cx=x,cy=y;\n\tint flag = true;\n\n\tvector< pair<char,char> > c;\n\tfor(int i = 0 ; i < 6 ; i++){\n\t\tint d = tail / p5[i] % 5;\n\t\tif( d == 0 ) continue;\n\t\tcx -= dx[d];\n\t\tcy -= dy[d];\n\t\tc.push_back(mp(cx,cy));\n\t\t//cout << cx << \",\" << cy << \" - <> \";\n\t}\n\t//cout << \"[\" << tail.size() << \"]\" << endl;\n\tif(k && y ){\n\t\tint flag = true;\n\t\tif( field[y-1][x] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] == pair<char,char>(x,y-1) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 4) % p5[6];\n\t\t\tans = max( ans , dfs(x,y-1,k-1,tmp)+flag*(field[y-1][x]-'0') );\n\t\t}\n\t}\n\tif(k && x ){\n\t\tint flag = true;\n\t\tif( field[y][x-1] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] ==  pair<char,char>(x-1,y) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 3) % p5[6];\n\t\t\tans = max( ans , dfs(x-1,y,k-1,tmp)+flag*(field[y][x-1]-'0') );\n\t\t}\n\t}\n\tif( y+1 < H){\n\t\tint flag = true;\n\t\tif( field[y+1][x] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] ==  pair<char,char>(x,y+1) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 2) % p5[6];\n\t\t\tans = max( ans , dfs(x,y+1,k,tmp)+flag*(field[y+1][x]-'0') );\n\t\t}\n\t}\n\tif( x+1 < W){\n\t\tint flag = true;\n\t\tif( field[y][x+1] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] ==  pair<char,char>(x+1,y) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 1) % p5[6];\n\t\t\tans = max( ans , dfs(x+1,y,k,tmp)+flag*(field[y][x+1]-'0') );\n\t\t}\n\t}\n\t//cout << x << \" \" << y << \" \" << k << \" \" << ans << endl;\n\treturn dp[x][y][k][tail]=ans;\n\t\n}\nint main(){\n\tp5[0] = 1;\n\tfor(int i = 1 ; i < 10 ; i++) p5[i] = p5[i-1] * 5;\n\tmemset(dp,-1,sizeof(dp));\n\tcin >> H >> W >> K;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tcin >> field[i][j];\n\t\t\tif( field[i][j] == '.' ) field[i][j] = '0';\n\t\t}\n\t}\n\tcout << dfs(0,0,K,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\n\n#define MAX\t\t60\n#define UP\t\t1\n#define RIGHT\t2\n#define DOWN\t3\n#define LEFT\t4\n\n//マップ、ｋの値を保持\nint dp[MAX][MAX][MAX];\nbool used[MAX][MAX];\nint ans;\nint H , W , K;\nchar map[MAX][MAX];\n\n\n\n\n//4方向のうち、左と右のみカウント(beforeは来た方向に戻らないようにするため)\nvoid dfs(int now_k , int y , int x , int before , int now_value)\n{\n\t//現在地が範囲外・壁、またはｋの許容範囲を超えていたなら戻る\n\tif (0 > y || y >= H || 0 > x || x >= W ||\n\t\tmap[y][x] == '#' || \n\t\tnow_k > K)\n\t{\n\t\treturn;\n\t}\n\t\n\t//店である\n\tif (map[y][x] != '#' && map[y][x] != '.')\n\t{\n\t\t//まだ使っていない\n\t\tif (used[y][x] == false)\n\t\t{\n\t\t\tused[y][x] = true;\n\t\t\tnow_value += map[y][x] - '0';\n\t\t\tans = max(ans , now_value);\n\t\t}\n\t}\n\n\t//4方向確認\n\t//上\n\tif (before != DOWN)\n\t{\n\t\tdfs(now_k + 1 , y - 1 , x , UP , now_value);\n\t}\n\t//右\n\tif (before != LEFT)\n\t{\n\t\tdfs(now_k , y , x + 1 , RIGHT , now_value);\n\t}\n\t//下\n\tif (before != UP)\n\t{\n\t\tdfs(now_k , y + 1 , x , DOWN , now_value);\n\t}\n\t//左\n\tif (before != RIGHT)\n\t{\n\t\tdfs(now_k + 1 , y , x - 1 , LEFT , now_value);\n\t}\n\n\tused[y][x] = false;\n}\n\n\nvoid num_set()\n{\n\tfor (int i = 0; i < MAX; i++)\n\t{\n\t\tfor (int j = 0; j < MAX; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < MAX; k++)\n\t\t\t{\n\t\t\t\tdp[i][j][k] = -1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tcin >> H >> W >> K;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tcin >> map[i][j];\n\t\t}\n\t}\n\n\tdfs(0 , 0 , 0 , 0 , 0);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <tuple>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef tuple<P, int, set<P>> T;\n\nint n, m, z;\nchar x[50][51];\n\nint a;\nmap<T, int> b;\n\nvoid dfs(P p, int z, set<P> s){\n\tif(p == P(n - 1, m - 1)){\n\t\ta = max(b[T(p, z, s)], a);\n\t}\n\n\tint dx[] = {-1, 0, 0, 1};\n\tint dy[] = {0, -1, 1, 0};\n\trep(i, 4){\n\t\tint nx = p.first + dx[i];\n\t\tint ny = p.second + dy[i];\n\t\tint nz = i <= 1 ? z - 1 : z;\n\n\t\tif(!(0 <= nx && nx < n && 0 <= ny && ny < m && nz >= 0 && x[nx][ny] != '#')){\n\t\t\tcontinue;\n\t\t}\n\n\t\tint g = 0;\n\t\tset<P> ns;\n\t\tif('1' <= x[nx][ny] && x[nx][ny] <= '9' && s.find({nx, ny}) == s.end()){\n\t\t\tns.insert({nx, ny});\n\t\t\tg = x[nx][ny] - '0';\n\t\t}\n\t\tfor(auto it = s.begin(); it != s.end(); ++it){\n\t\t\tint u = max(nx - it->first, 0);\n\t\t\tint v = max(ny - it->second, 0);\n\t\t\tif(u + v <= nz){\n\t\t\t\tns.insert(*it);\n\t\t\t}\n\t\t}\n\n\t\tT nk({nx, ny}, nz, ns);\n\t\tif(b.find(nk) == b.end() || b[nk] < b[T(p, z, s)] + g){\n\t\t\tb[nk] = b[T(p, z, s)] + g;\n\t\t\tdfs({nx, ny}, nz, ns);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &z);\n\trep(i, n){\n\t\tscanf(\"%s\", x[i]);\n\t}\n\n\tdfs(P(0, 0), z, {});\n\tprintf(\"%d\\n\", a);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint w, h, k;\nchar field[60][60];\n\nstruct State {\n  int x;\n  int y;\n  int k;\n  int score;\n  vector<int> prev;\n  State() : prev(6, -1) {;}\n  State(int x, int y, int k, int score)\n    : x(x), y(y), k(k), score(score), prev(6, -1) {;}\n  State(int x, int y, int k, int score, const vector<int> &prev)\n    : x(x), y(y), k(k), score(score), prev(prev) {;}\n  bool operator<(const State &rhs) const {\n    if (x != rhs.x) { return x < rhs.x; }\n    if (y != rhs.y) { return y < rhs.y; }\n    return prev < rhs.prev;\n  }\n  void Push(int x, int y) {\n    prev.erase(prev.begin());\n    if (field[y][x] != '.') {\n      prev.push_back(y * w + x);\n    } else {\n      prev.push_back(-1);\n    }\n  }\n  bool Exist(int x, int y) {\n    FORIT(it, prev) {\n      if (y * w + x == *it) { return true; }\n    }\n    return false;\n  }\n};\n\nint main() {\n  while (scanf(\"%d %d %d\", &h, &w, &k) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n    }\n    map<State, int> dist;\n    queue<State> que;\n    que.push(State(0, 0, k, 0));\n    int ans = 0;\n    while (!que.empty()) {\n      State s = que.front();\n      que.pop();\n      if (dist.count(s) && dist[s] >= s.score) { continue; }\n      dist[s] = s.score;\n      //cout << s.x << \" \" << s.y << \" \" << s.k << \" \" << s.score << endl;\n      assert(s.score >= 0);\n      if (s.x == w - 1 && s.y == h - 1) {\n        ans = max(ans, s.score);\n      }\n      const int dx[4] = { 1, 0, -1, 0 };\n      const int dy[4] = { 0, 1, 0, -1 };\n      REP(dir, 4) {\n        int nx = s.x + dx[dir];\n        int ny = s.y + dy[dir];\n        int nk = s.k;\n        if (dir >= 2) { nk--; }\n        if (nx < 0 || nx >= w || ny < 0 || ny >= h ||\n            nk < 0 ||\n            field[ny][nx] == '#') { continue; }\n        State ns(nx, ny, nk, s.score, s.prev);\n        if (field[ny][nx] != '.' && !ns.Exist(nx, ny)) {\n          //cout << ns.Exist(nx, ny) << endl;\n          ns.Push(nx, ny);\n          ns.score += field[ny][nx] - '0';\n          assert(ns.score >= 0);\n        } else {\n          ns.Push(nx, ny);\n        }\n        que.push(ns);\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct T\n{\n  int x, y, k;\n  T(int _x, int _y, int _k, const vector<int>& _vis):\n    x(_x), y(_y), k(_k), vis(_vis) {}\n  vector<int> vis;\n  bool operator <(const T& rhs) const\n  {\n    return x < rhs.x && y < rhs.y && k < rhs.k && vis < rhs.vis;\n  }\n};\n\nint m[51][51];\nmap<T, int> dp;\nint H, W, K;\nint dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\n\nint dfs(T arg)\n{\n  if(dp.find(arg) != dp.end())\n    dp[arg];\n  int x = arg.x, y = arg.y, k = arg.k;\n  auto& vis = arg.vis;\n  int cnt = max(0, m[y][x]);\n  for(int i = 0; i < vis.size(); i += 2)\n  {\n    if(vis[i] == x && vis[i + 1] == y)\n    {\n      cnt = 0;\n      break;\n    }\n  }\n\n  vector<int> nv;\n  for(int i = vis.size() >= 2 * K ? 2: 0; i < vis.size(); i++)\n    nv.push_back(vis[i]);\n  nv.push_back(x);\n  nv.push_back(y);\n  int res = 0;\n  for(int i = 0; i < 4; i++)\n  {\n    int tx = x + dx[i], ty = y + dy[i];\n    if(!(tx >= 0 && tx < W && ty >= 0 && ty < H))\n      continue;\n    if(m[ty][tx] == -1)\n      continue;\n    int dk = (dx[i] < 0 || dy[i] < 0) ? 1 : 0;\n    if(k + dk > K)\n      continue;\n    res = max(res, dfs(T(tx, ty, k + dk, nv))); \n  }\n  return dp[arg] = res + cnt;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  for(int y = 0; y < H; y++)\n  {\n    for(int x = 0; x < W; x++)\n    {\n      char a;\n      cin >> a;\n      switch(a)\n      {\n        case '.':\n          m[y][x] = 0;\n          break;\n        case '#':\n          m[y][x] = -1;\n          break;\n        default:\n          m[y][x] = a - '0';\n          break;\n      }\n    }\n  }\n  cout << dfs(T(0, 0, 0, vector<int>())) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\nint h, w, k;\nchar board[100][100];\n\nint getboard(int i, int j)\n{\n\tif (i < 0 || j < 0 || i >= h || j >= w)\n\t{\n\t\treturn -1;\n\t}\n\treturn (board[i][j] == '#') ? -1 : ((board[i][j] == '.') ? 0 : (board[i][j] - '0'));\n}\n\nconst int PMAX = 1 << 12;\nint memo[50][50][4][PMAX];\nconst int hsy[4] = { 1,0,-1,0 };\nconst int hsx[4] = { 0,1,0,-1 };\nconst int INF = 123456789;\nint dp(int i, int j, int x, int path)\n{\n\tif (x > k || x < 0)return -INF;\n\tif (i < 0 || j < 0 || i >= h || j >= w)return -INF;\n\tif (memo[i][j][x][path] != -1)return memo[i][j][x][path];\n\tint ans = -INF;\n\tint kk = x;\n\tif (!(getboard(i, j) < 0))\n\t{\n\t\tfor (int d = 0; d < 4; ++d)\n\t\t{\n\t\t\tif (d >= 2)\n\t\t\t{\n\t\t\t\tkk = x - 1;\n\t\t\t\tif (kk < 0)continue;\n\t\t\t}\n\t\t\tint d2 = d << 10;\n\t\t\tint idp = (path >> 2) % (1 << 10) + d2;\n\t\t\tint cans = dp(i - hsy[path % 4], j - hsx[path % 4], kk, idp);\n\t\t\tint u = hsy[path % 4], v = hsx[path % 4];\n\t\t\tbool flag = false;\n\t\t\tfor (int bit = 0; bit < 6; ++bit)\n\t\t\t{\n\t\t\t\tu += hsy[idp % 4];\n\t\t\t\tv += hsx[idp % 4];\n\t\t\t\tidp /= 4;\n\t\t\t\tif (u == 0 && v == 0)flag = true;\n\t\t\t}\n\t\t\tif (!flag)cans += getboard(i, j);\n\t\t\tans = max(ans, cans);\n\t\t}\n\t}\n\treturn memo[i][j][x][path] = ans;\n}\n\nint main(void)\n{\n\tscanf(\"%d %d %d\", &h, &w, &k);\n\tfor (int i = 0; i < h; ++i)scanf(\"%s\", board[i]);\n\tmemset(memo, 0xFF, sizeof(memo));\n\tmemo[0][0][0][0] = 0;\n\tint ans = 0;\n\tfor (int x = 0; x <= k; ++x)\n\t{\n\t\tfor (int p = 0; p < PMAX; ++p)\n\t\t{\n\t\t\tint p2 = p;\n\t\t\tint bcount = 0;\n\t\t\tfor (int bit = 0; bit < 6; ++bit)\n\t\t\t{\n\t\t\t\tif (p2 % 4 >= 2)++bcount;\n\t\t\t\tp2 /= 4;\n\t\t\t}\n\t\t\tif (bcount > k - x)continue;\n\t\t\tans = max(ans, dp(h - 1, w - 1, x, p));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\nbool used[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  map<pii,int> m;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[pii(i+oy,j+ox)]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[pii(ny,nx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 全体のビット右にをシフト\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 下方向にビットをシフト\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nstruct Sit{\n  int cy,cx,mask,my,mx;\n  Sit(){}\n  Sit(int cy_,int cx_,int mask_,int my_,int mx_){\n    cy=cy_;\n    cx=cx_;\n    mask=mask_;\n    my=my_;\n    mx=mx_;\n  }\n  bool operator<(const Sit&sit)const{\n    return true;\n  }\n};\ntypedef pair<int,Sit> iSit;\n\nconst int INF=(1<<30);\nint dfs(int cy,int cx,int mask,int my,int mx){\n  if(used[cy][cx][mask][my][mx])return dp[cy][cx][mask][my][mx];\n  int res=-INF;\n  int leftK=K-(my+mx);\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n      int nmask=p.first;\n      int nAddVal=p.second;\n      if(leftK>0&&(i==0||i==3))\n        res=max(res,dfs(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))+nAddVal);\n      else if((i==1||i==2))\n        res=max(res,dfs(ny,nx,nmask,my,mx)+nAddVal);\n    }\n  }\n  if(cy==H-1&&cx==W-1)res=max(res,0);\n  used[cy][cx][mask][my][mx]=true;\n  return dp[cy][cx][mask][my][mx]=res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,(1<<6),0,0)<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  map<pii,int> m;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[pii(i+oy,j+ox)]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[pii(ny,nx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 全体のビット右にをシフト\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 下方向にビットをシフト\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nstruct Sit{\n  int cy,cx,mask,my,mx;\n  Sit(){}\n  Sit(int cy_,int cx_,int mask_,int my_,int mx_){\n    cy=cy_;\n    cx=cx_;\n    mask=mask_;\n    my=my_;\n    mx=mx_;\n  }\n  bool operator<(const Sit&sit)const{\n    return true;\n  }\n};\ntypedef pair<int,Sit> iSit;\n\nbool used[31][31][1<<10][4][4];\nconst int INF=(1<<30);\nint dfs(int cy,int cx,int mask,int my,int mx){\n  if(used[cy][cx][mask][my][mx])return dp[cy][cx][mask][my][mx];\n  int res=-INF;\n  int leftK=K-(my+mx);\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n      int nmask=p.first;\n      int nAddVal=p.second;\n      // cout<<nAddVal<<endl;\n      if(leftK>0&&(i==0||i==3)){\n        res=max(res,dfs(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))+nAddVal);\n      }\n      else if((i==1||i==2)){\n        res=max(res,dfs(ny,nx,nmask,my,mx)+nAddVal);\n      }\n    }\n  }\n  if(cy==H-1&&cx==W-1)\n    res=max(res,0);\n  used[cy][cx][mask][my][mx]=true;\n  return dp[cy][cx][mask][my][mx]=res;\n}\n\nint dijkstra(){\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][1<<6][0][0]=0;\n  priority_queue<iSit> pq;\n  pq.push(make_pair(0,Sit(0,0,1<<6,0,0)));\n  while(pq.size()){\n    iSit is=pq.top();pq.pop();\n    int cval=is.first;\n    Sit cSit=is.second;\n    int cy=cSit.cy,cx=cSit.cx,mask=cSit.mask,my=cSit.my,mx=cSit.mx;\n    if(dp[cy][cx][mask][my][mx]>cval)continue;\n    int leftK=K-(my+mx);\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n        pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n        int nmask=p.first;\n        int nAddVal=p.second;\n        if(leftK>0&&(i==0||i==3)&&dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]<cval+nAddVal){\n          dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))));\n        }\n        else if((i==1||i==2)&&dp[ny][nx][nmask][my][mx]<cval+nAddVal){\n          dp[ny][nx][nmask][my][mx]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my,mx)));\n        }\n      }\n    }\n  }\n  int res=0;\n  for(int mask=0;mask<(1<<10);mask++)\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        res=max(res,dp[H-1][W-1][mask][i][j]);\n  return res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  memset(dp,-1,sizeof(dp));\n  // assert(dfs(0,0,(1<<6),0,0)==dijkstra());\n  cout<<dfs(0,0,(1<<6),0,0)<<endl;\n  //cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint h, w, k;\nchar field[50][50];\n\nint dp[4][50][50][1024][4];\nint ans = 0;\nint sum[4] = {0, 1, 3, 6};\n\nbool judge(int x, int y)\n{\n  if(0 <= x && x < h && 0 <= y && y < w && field[x][y] != '#')\n    return true;\n  return false;\n}\n\nvoid solve(int times)\n{\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      for(int l = 0; l < 1024; l++){\n\tfor(int m = 0; m <= times; m++){\n\n\t  if(dp[times][i][j][l][m] > -1){\n\t    //toright\n\t    if(judge(i, j + 1)){\n\t      int nextl \n\t\t= (field[i][j + 1] == '.' ? 0 : 1 << (sum[times] + m))\n\t\t| ((l & (1 << 0)) << 1)\n\t\t| ((l & (1 << 1)) << 2)\n\t\t| ((l & (1 << 2)) << 2)\n\t\t| ((l & (1 << 3)) << 3)\n\t\t| ((l & (1 << 4)) << 3)\n\t\t| ((l & (1 << 5)) << 3);\n\t      \n\t      dp[times][i][j + 1][nextl][m] = max(dp[times][i][j + 1][nextl][m], dp[times][i][j][l][m] + ((field[i][j + 1] == '.'|| times > 0 && (l & (1 << (sum[times] + m - (times - 1) - 1)))) ? 0 : field[i][j + 1] - '0'));\n\t    }\n\t    \n\t    //tounder\n\t    if(judge(i + 1, j)){\n\t      int nextl\n\t\t= (field[i + 1][j] == '.' ? 0 : 1 << (sum[times] + m))\n\t\t| ((l & (1 << 0)) << 2)\n\t\t| ((l & (1 << 1)) << 3)\n\t\t| ((l & (1 << 2)) << 3)\n\t\t| ((l & (1 << 3)) << 4)\n\t\t| ((l & (1 << 4)) << 4)\n\t\t| ((l & (1 << 5)) << 4);\n\t      \n\t      dp[times][i + 1][j][nextl][m] = max(dp[times][i + 1][j][nextl][m], dp[times][i][j][l][m] + ((field[i + 1][j] == '.' || times > 0 && (l & (1 << (sum[times] + m - (times - 1) - 2)))) ? 0 : field[i + 1][j] - '0'));\n\t    }\n\t    \n\t    if(times < k){\n\t      //toleft\n\t      if(judge(i, j - 1)){\n\t\tint nextl = l | (field[i][j - 1] == '.' ? 0 : (1 << (sum[times] + m + times + 1)));\n\t\tdp[times + 1][i][j - 1][nextl][m] = max(dp[times + 1][i][j - 1][nextl][m], dp[times][i][j][l][m] + ((field[i][j - 1] == '.' || (l & (1 << (sum[times] + m + times + 1)))) ? 0 : field[i][j - 1] - '0'));\n\t      }\n\t      \n\t      //toup\n\t      if(judge(i - 1, j)){\n\t\tint nextl = l | (field[i - 1][j] == '.' ? 0 : (1 << (sum[times] + m + times + 2)));\n\t\tdp[times + 1][i - 1][j][nextl][m + 1] = max(dp[times + 1][i - 1][j][nextl][m + 1], dp[times][i][j][l][m] + ((field[i - 1][j] == '.' || (l & (1 << (sum[times] + m + times + 2)))) ? 0 : field[i - 1][j] - '0'));\n\t      }\n\t    }\n\n\t  }\n\t}\n      }\n    }\n  }\n\n  for(int i = 0; i < 1024; i++){\n    for(int j = 0; j <= times; j++){\n      ans = max(ans, dp[times][h - 1][w - 1][i][j]);\n    }\n  }\n}\n\nint main()\n{\n  cin >> h >> w >> k;\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      cin >> field[i][j];\n    }\n  }\n\n  memset(dp, -1, sizeof dp);\n  dp[0][0][0][0][0] = 0;\n\n  for(int i = 0; i <= k; i++){\n    solve(i);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum Block {HOUSE = -1, BLANK};\nconst int BIT = 12;\n\nint H, W, K;\nvector<vector<int>> B;\n\nint dp[50][50][4][1 << BIT];\n\nenum {Y, X};\nconst int POINT[4][BIT][2] = {\n  {{4,4}, {1,4}, {2,3}, {2,4}, {3,2}, {3,3}, {3,4}, {4,1}, {4,2}, {4,3}, {0,0}, {0,0},},\n  {{4,4}, {2,4}, {2,5}, {3,3}, {3,4}, {3,5}, {4,2}, {4,3}, {4,5}, {5,2}, {5,3}, {5,4},},\n  {{4,4}, {3,4}, {3,5}, {3,6}, {4,3}, {4,5}, {4,6}, {5,3}, {5,4}, {5,5}, {6,3}, {6,4},},\n  {{4,4}, {4,5}, {4,6}, {4,7}, {5,4}, {5,5}, {5,6}, {6,4}, {6,5}, {7,4}, {0,0}, {0,0},},\n};\nenum {STRAIGHT, REVERSE};\nconst int NEXT[2][2][2] = {\n  {{0, 1}, { 1,0},},\n  {{0,-1}, {-1,0},},\n};\n\nvector<vector<bool>> bit_to_part(int bit, int k) {\n  vector<vector<bool>> res(9, vector<bool>(9, false));\n  for(int b = 0; b < BIT; ++b) if((bit >> b) & 1) res[POINT[k][b][Y]][POINT[k][b][X]] = true;\n  return res;\n}\n\nint part_to_bit(const vector<vector<bool>>& part, int k) {\n  int res = 0;\n  for(int b = 0; b < BIT; ++b) if(part[POINT[k][b][Y]][POINT[k][b][X]]) res |= (1 << b);\n  return res;\n}\n\nint nextbit(int y, int x, int k, int bit, int dy, int dx, int dk) {\n  int ny = y + dy, nx = x + dx;\n  int nk = k + dk;\n  if(ny < 0 || H <= ny || nx < 0 || W <= nx) return -1;\n  if(B[ny][nx] == HOUSE) return -1;\n  if(K < nk) return -1;\n  auto cur = bit_to_part(bit, k);\n  vector<vector<bool>> nex(9, vector<bool>(9, false));\n  for(int i = 1; i < 8; ++i) for(int j = 1; j < 8; ++j) nex[i][j] = cur[i + dy][j + dx];\n  return part_to_bit(nex, k + dk);\n}\n\nint solve() {\n  int res = 0;\n  for(int i = 0; i < H; ++i) for(int j = 0; j < W; ++j) for(int k = 0; k <= K; ++k) for(int bit = 0; bit < (1 << BIT); ++bit) dp[i][j][k][bit] = -1;\n  dp[0][0][0][1] = 0;\n  for(int k = 0; k <= K; ++k) {\n    for(int y = 0; y < H; ++y) for(int x = 0; x < W; ++x) for(int bit = 0; bit < (1 << BIT); ++bit) {\n      if(dp[y][x][k][bit] == -1) continue;\n      for(auto d: NEXT[STRAIGHT]) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        int nk = k;\n        int nbit = nextbit(y, x, k, bit, d[Y], d[X], 0);\n        if(nbit < 0) continue;\n        int add = 0;\n        if(!(nbit & 1) && 0 < B[ny][nx]) add = B[ny][nx];\n        nbit |= 1;\n          dp[ny][nx][nk][nbit] = max(dp[ny][nx][nk][nbit], add + dp[y][x][k][bit]);\n          if(ny == H - 1 && nx == W - 1) res = max(res, dp[ny][nx][nk][nbit]);\n      }\n    }\n    if(k < K) {\n      for(int y = H - 1;  0 <= y; --y) for(int x = W - 1; 0 <= x; --x) for(int bit = 0; bit < (1 << BIT); ++bit) {\n        if(dp[y][x][k][bit] == -1) continue;\n        for(auto d: NEXT[REVERSE]) {\n          int ny = y + d[Y];\n          int nx = x + d[X];\n          int nk = k + 1;\n          int nbit = nextbit(y, x, k, bit, d[Y], d[X], 1);\n          if(nbit < 0) continue;\n          int add = 0;\n          if(!(nbit & 1) && 0 < B[ny][nx]) add = B[ny][nx];\n          nbit |= 1;\n          dp[ny][nx][nk][nbit] = max(dp[ny][nx][nk][nbit], add + dp[y][x][k][bit]);\n          if(ny == H - 1 && nx == W - 1) res = max(res, dp[ny][nx][nk][nbit]);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  cin >> H >> W >> K;\n  B.assign(H, vector<int>(W));\n  for(auto& line: B) for(auto& i: line) {\n    char c;\n    cin >> c;\n    if(c == '.')      i = BLANK;\n    else if(c == '#') i = HOUSE;\n    else              i = c - '0';\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint ch[4][4][12] = {\n    {\n        {-1, -1, 0, -1, 1, 2, -1, 3, 4, 5, -1, -1}, \n        {-1, -1, 1, -1, 3, 4, -1, 6, 7, 8, -1, -1}, \n        {0, 2, 3, 5, 6, 7, -1, 9, 10, 11, -1, -1}, \n        {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, -1, -1}\n    },\n    {\n        {-1, -1, -1, 0, 1, -1, 2, 3, 4, 5, 6, 7}, \n        {-1, 0, -1, 2, 3, -1, 5, 6, 7, -1, 9, 10}, \n        {0, 1, 3, 4, 5, -1, 7, 8, 9, -1, 10, 11}, \n        {-1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    },\n    {\n        {-1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 7, 8}, \n        {-1, 0, 1, -1, 3, 4, 5, -1, 7, 8, -1, 10}, \n        {0, 1, 2, -1, 4, 5, 6, -1, 7, 8, -1, 9}, \n        {-1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8}\n    },\n    {\n        {-1, -1, -1, -1, 0, 1, 2, 4, 5, 7, -1, -1}, \n        {-1, 0, 1, 2, -1, 4, 5, -1, 7, -1, -1, -1}, \n        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}\n    }\n};\n    \nint pl[4] = {9, 7, 4, 0};\n\nint npl[4][4] = {\n    {-1, -1, 5, 8},\n    {11, 8, 3, 6},\n    {8, 5, 0, 3},\n    {4, 1, -1, -1}\n};\n\nint n, m, K;\nstring fi[55];\n\n\nint dp[53][53][5][4100];\n\nint main() {\n    //freopen( \"/Users/macuser/Dropbox/Contest/input.in\", \"r\", stdin );\n    while (cin >> n >> m >> K) {\n        for (int i = 0; i < n; ++i) cin >> fi[i];\n        \n        int res = 0;\n        \n        memset(dp, -1, sizeof(dp));\n        dp[0][0][0][(1<<9)] = 0;\n        for (int k = 0; k <= K; ++k) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    for (int bit = 0; bit < (1<<12); ++bit) {\n                        if (dp[i][j][k][bit] == -1) continue;\n                        if (i == n-1 && j == m-1) chmax(res, dp[i][j][k][bit]);\n                        \n                        //cout << i << \", \" << j << \", \" << k << \" ; \" << bitset<12>(bit) << \" : \" << dp[i][j][k][bit] << endl;\n                        \n                        for (int l = 0; l <= 3; ++l) {\n                            int ni = i + dx[l], nj = j + dy[l];\n                            if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n                            if (fi[ni][nj] == '#') continue;\n                            \n                            int add = 0;\n                            if (fi[ni][nj] != '.') add = fi[ni][nj] - '0';\n                            if (npl[k][l] != -1)\n                                if (bit & (1<<npl[k][l]))\n                                    add = 0;\n                            \n                            int nk = k;\n                            if (l == 2 || l == 3) ++nk;\n                            if (nk > K) continue;\n                            \n                            int nbit = 0;\n                            for (int b = 0; b < 12; ++b)\n                                if (bit & (1<<b))\n                                    if (ch[k][l][b] != -1)\n                                        nbit |= (1<<ch[k][l][b]);\n                            \n                            nbit |= (1<<pl[nk]);\n                            \n                            chmax(dp[ni][nj][nk][nbit], dp[i][j][k][bit] + add);\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1}; //00右,01下,10左,11上\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint h,w,k;\nchar fld[50][50];\nint memo[50][50][4][1<<12];\n\nbool Check(int y,int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w&&fld[y][x]!='#';\n}\n\nint Max(int y,int x,int c,int bit){\n\tint &res=memo[y][x][c][bit];\n\tif(res!=-1) return res;\n\tif(y==h-1&&x==w-1&&c==0) return res;\n\n\tres=0;\n\trep(i,0,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(!Check(ny,nx)) continue;\n\t\tif(i<2){\n\t\t\tres=max(res,Max(ny,nx,c,((bit<<2)&((1<<12)-1))|i));\n\t\t}else if(c>=1){\n\t\t\tres=max(res,Max(ny,nx,c-1,((bit<<2)&((1<<12)-1))|i));\n\t\t}\n\t}\n\n\tif(!('1'<=fld[y][x]&&fld[y][x]<='9')) return res;\n\n\tbool done=false;\n\tint py=y,px=x;\n\trep(i,0,6){\n\t\tpy+=-dy[(bit>>(i*2))&3];\n\t\tpx+=-dx[(bit>>(i*2))&3];\n\t\tif(y==py&&x==px){\n\t\t\tdone=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!done) res+=fld[y][x]-'0';\n\n\treturn res;\n}\n\nvoid Solve(){\n\tfill_n((int*)memo,50*50*4*(1<<12),-1);\n\tcin >> h >> w >> k;\n\trep(i,0,h) rep(j,0,w) cin >> fld[i][j];\n\n\tcout << Max(0,0,k,0) << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint h, w, k;\nchar s[51][51];\nint dp[51][51][1 << 12][4], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nbool used[51][51];\nvoid mark(int x, int y, int t, int s) {\n\tused[x][y] = true;\n\tif (s == 0)return;\n\tint a = ((t >> 1 & 1) << 1) + (t & 1);\n\tx -= dx[a], y -= dy[a];\n\tt >>= 2;\n\tmark(x, y, t, s - 1);\n}\nint rec(int x, int y, int t, int a, int cnt) {\n\tif (dp[x][y][t][a] != -1)return dp[x][y][t][a];\n\tint res = 0;\n\trep(i, 4) {\n\t\tif (i % 2 && !a)continue;\n\t\tmemset(used, 0, sizeof(used));\n\t\tmark(x, y, t, cnt);\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || s[nx][ny] == '#')continue;\n\t\tint v = 0;\n\t\tif (used[nx][ny] == false) {\n\t\t\tif ('1' <= s[nx][ny] && s[nx][ny] <= '9')v = s[nx][ny] - '0';\n\t\t}\n\t\tint p = (t >> (k * 4 - 2)) << (k * 4 - 2); p = t - p;\n\t\tp = (p << 2) + i; int b = cnt; if (b < 2 * k)b++;\n\t\tres = max(res, rec(nx, ny, p, a - i % 2, b) + v);\n\t}\n\treturn dp[x][y][t][a] = res;\n}\nint main() {\n\tscanf(\"%d%d%d\", &h, &w, &k);\n\trep(i, h)scanf(\"%s\", s[i]);\n\tmemset(dp, -1, sizeof(dp));\n\tprintf(\"%d\\n\", rec(0, 0, 0, k, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  map<pii,int> m;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[pii(i+oy,j+ox)]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[pii(ny,nx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // テ・ツ?ィテ、ツスツ禿」ツ?ョテ」ツδ禿」ツδε」ツδ暗・ツ渉ウテ」ツ?ォテ」ツつ津」ツつキテ」ツδ陛」ツδ?\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // テ、ツクツ凝ヲツ鳴ケテ・ツ青妥」ツ?ォテ」ツδ禿」ツδε」ツδ暗」ツつ津」ツつキテ」ツδ陛」ツδ?\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nstruct Sit{\n  int cy,cx,mask,my,mx;\n  Sit(){}\n  Sit(int cy_,int cx_,int mask_,int my_,int mx_){\n    cy=cy_;\n    cx=cx_;\n    mask=mask_;\n    my=my_;\n    mx=mx_;\n  }\n  bool operator<(const Sit&sit)const{\n    return true;\n  }\n};\ntypedef pair<int,Sit> iSit;\n\nint dijkstra(){\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][1<<6][0][0]=0;\n  priority_queue<iSit> pq;\n  pq.push(make_pair(0,Sit(0,0,1<<6,0,0)));\n  while(pq.size()){\n    iSit is=pq.top();pq.pop();\n    int cval=is.first;\n    Sit cSit=is.second;\n    int cy=cSit.cy,cx=cSit.cx,mask=cSit.mask,my=cSit.my,mx=cSit.mx;\n    if(dp[cy][cx][mask][my][mx]>cval)continue;\n    int leftK=K-(my+mx);\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n        pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n        int nmask=p.first;\n        int nAddVal=p.second;\n        if(leftK>0&&(i==0||i==3)&&dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]<cval+nAddVal){\n          dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))));\n        }\n        else if((i==1||i==2)&&dp[ny][nx][nmask][my][mx]<cval+nAddVal){\n          dp[ny][nx][nmask][my][mx]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my,mx)));\n        }\n      }\n    }\n  }\n  int res=0;\n  for(int mask=0;mask<(1<<10);mask++)\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        res=max(res,dp[H-1][W-1][mask][i][j]);\n  return res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nlong long in(){\n\tlong long n;\n\tscanf(\"%lld\",&n);\n\treturn n;\n}\n\n\n/*\nchokuzen no 3 kai no ugoki wo motte DP?\n\n*/\n#define D (k*2)\nchar field[50][50];\n\nint cost[50][50];\n\nint dx[] = {0,1,0,-1,0}; // R D L U\nint dy[] = {0,0,1,0,-1};\nint H,W,K;\n\nmap<int,int> dp[50][50][4];\nint p5[10];\nint dfs(char x,char y,char k,int tail){\n\tif( dp[x][y][k].count(tail) ){\n\t\treturn dp[x][y][k][tail];\n\t}\n\tint ans = (x==W-1&&y==H-1)?0:-1e9;\n\t\n\tint cx=x,cy=y;\n\tint flag = true;\n\n\tvector< pair<char,char> > c;\n\tfor(int i = 0 ; i < 6 ; i++){\n\t\tint d = tail / p5[i] % 5;\n\t\tif( d == 0 ) continue;\n\t\tcx -= dx[d];\n\t\tcy -= dy[d];\n\t\tc.push_back(mp(cx,cy));\n\t\t//cout << cx << \",\" << cy << \" - <> \";\n\t}\n\t//cout << \"[\" << tail.size() << \"]\" << endl;\n\tif(k && y ){\n\t\tint flag = true;\n\t\tif( field[y-1][x] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] == pair<char,char>(x,y-1) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 4) % p5[6];\n\t\t\tans = max( ans , dfs(x,y-1,k-1,tmp)+flag*(field[y-1][x]-'0') );\n\t\t}\n\t}\n\tif(k && x ){\n\t\tint flag = true;\n\t\tif( field[y][x-1] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] ==  pair<char,char>(x-1,y) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 3) % p5[6];\n\t\t\tans = max( ans , dfs(x-1,y,k-1,tmp)+flag*(field[y][x-1]-'0') );\n\t\t}\n\t}\n\tif( y+1 < H){\n\t\tint flag = true;\n\t\tif( field[y+1][x] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] ==  pair<char,char>(x,y+1) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 2) % p5[6];\n\t\t\tans = max( ans , dfs(x,y+1,k,tmp)+flag*(field[y+1][x]-'0') );\n\t\t}\n\t}\n\tif( x+1 < W){\n\t\tint flag = true;\n\t\tif( field[y][x+1] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] ==  pair<char,char>(x+1,y) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 1) % p5[6];\n\t\t\tans = max( ans , dfs(x+1,y,k,tmp)+flag*(field[y][x+1]-'0') );\n\t\t}\n\t}\n\t//cout << x << \" \" << y << \" \" << k << \" \" << ans << endl;\n\treturn dp[x][y][k][tail]=ans;\n\t\n}\nint main(){\n\tp5[0] = 1;\n\tfor(int i = 1 ; i < 10 ; i++) p5[i] = p5[i-1] * 5;\n\tcin >> H >> W >> K;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tcin >> field[i][j];\n\t\t\tif( field[i][j] == '.' ) field[i][j] = '0';\n\t\t}\n\t}\n\tcout << dfs(0,0,K,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint h, w, k;\nchar s[51][51];\nint dp[51][51][1 << 12][4], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nbool used[51][51];\nvoid mark(int x, int y, int t, int s) {\n\tused[x][y] = true;\n\tif (!s)return;\n\tint a = ((t >> 1 & 1) << 1) + (t & 1);\n\tx -= dx[a], y -= dy[a];\n\tt >>= 2;\n\tmark(x, y, t, s - 1);\n}\nint rec(int x, int y, int t, int a, int cnt) {\n\tif (dp[x][y][t][a] != -1)return dp[x][y][t][a];\n\tint res = -INF;\n\trep(i, 4) {\n\t\tif (i % 2 && !a)continue;\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || s[nx][ny] == '#')continue;\n\t\tmemset(used, 0, sizeof(used));\n\t\tmark(x, y, t, cnt);\n\t\tint v = ((!used[nx][ny] && '1' <= s[nx][ny] && s[nx][ny] <= '9') ? s[nx][ny] - '0' : 0);\n\t\tint p = (t >> (k * 4 - 2)) << (k * 4 - 2); p = t - p;\n\t\tp = (p << 2) + i; int b = cnt; if (b < 2 * k)b++;\n\t\tint o = rec(nx, ny, p, a - i % 2, b);\n\t\tif (o != -INF)res = max(res, o + v);\n\t}\n\tif (x == h - 1 && y == w - 1 && res == -INF)return dp[x][y][t][a] = 0;\n\treturn dp[x][y][t][a] = res;\n}\nint main() {\n\tscanf(\"%d%d%d\", &h, &w, &k);\n\trep(i, h)scanf(\"%s\", s[i]);\n\tmemset(dp, -1, sizeof(dp));\n\tprintf(\"%d\\n\", rec(0, 0, 0, k, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\n#include <iostream>\n#include <tr1/unordered_map>\nusing namespace std;\ntr1::unordered_map<int,short> dp[50][50][4];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nstruct State{\n  int x,y,remain,used,cost;\n};\n\nbool operator<(const State &a,const State &b){\n  return a.cost<b.cost;\n}\n\nshort &access(const State &s){\n  return dp[s.x][s.y][s.remain][s.used];\n}\n\nbool update(const State &s){\n  if(dp[s.x][s.y][s.remain].count(s.used)){\n    if(access(s)<s.cost){\n      access(s)=s.cost;\n      return true;\n    }\n  }else{\n    access(s)=s.cost;\n    return true;\n  }\n  return false;\n}\nconst int MAX_BACK = 7;\nconst int MASK = (1 << (2 * MAX_BACK)) - 1;\nchar MAP[50][50];\nint H,W,K;\nint add_cost(const State &now, int back_x, int back_y, int x,int y){\n  if(MAP[x][y]=='.')return 0;\n  // 今迄にアクセスしていないか\n  for(int i = 0; i < MAX_BACK; i++){\n    int d = (now.used >> (i * 2)) & 3;\n    back_x -= dx[d];\n    back_y -= dy[d];\n    if(back_x == x && back_y == y)return 0;\n  }\n  return MAP[x][y]-'0';\n}\nint main(){\n  cin>>H>>W>>K;\n  for(int y=0;y<H;y++){\n    string s;\n    cin>>s;\n    for(int x=0;x<W;x++){\n      MAP[x][y]=s[x];\n    }\n  }\n  int ans=0;\n  State now = (State){0,0,K,0,0};\n  priority_queue<State> que;\n  update(now);\n  que.push(now);\n  while(!que.empty()){\n    now=que.top();que.pop();\n    if(access(now)>now.cost)continue;\n    if(now.x==W-1&&now.y==H-1){\n      ans = max(ans,now.cost);\n    }\n    // 普通の移動\n    for(int i=0;i<2;i++){\n      int nx=now.x+dx[i],ny=now.y+dy[i];\n      if(nx>=0&&nx<W&&ny>=0&&ny<H&&MAP[nx][ny]!='#'){\n        State next = now;\n        next.cost += add_cost(now, now.x, now.y, nx, ny);\n        next.used = ((next.used << 2) | i) & MASK;\n        next.x = nx;\n        next.y = ny;\n        if(update(next)){\n          que.push(next);\n        }\n      }\n    }\n    // 戻る移動\n    if(now.remain){\n      for(int i=2;i<4;i++){\n        int nx=now.x+dx[i],ny=now.y+dy[i];\n        if(nx>=0&&nx<W&&ny>=0&&ny<H&&MAP[nx][ny]!='#'){\n          State next = now;\n          next.cost += add_cost(now, now.x, now.y, nx, ny);\n          next.used = ((next.used << 2) | i) & MASK;\n          next.x = nx;\n          next.y = ny;\n          next.remain--;\n          if(update(next)){\n            que.push(next);\n          }\n        }\n      }\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1}; //00右,01下,10左,11上\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint h,w,k;\nchar fld[50][50];\nint memo[50][50][4][1<<12];\n\nbool Check(int y,int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w&&fld[y][x]!='#';\n}\n\nint Max(int y,int x,int c,int bit){\n\tint &res=memo[y][x][c][bit];\n\tif(res!=-1) return res;\n\tif(y==h-1&&x==w-1&&c==0) return res;\n\n\tres=0;\n\trep(i,0,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(!Check(ny,nx)) continue;\n\t\tif(i<2){\n\t\t\tres=max(res,Max(ny,nx,c,((bit<<2)&((1<<12)-1))|i));\n\t\t}else if(c>=1){\n\t\t\tres=max(res,Max(ny,nx,c-1,((bit<<2)&((1<<12)-1))|i));\n\t\t}\n\t}\n\n\tif(!('1'<=fld[y][x]&&fld[y][x]<='9')) return res;\n\n\tbool done=false;\n\tint py=y,px=x;\n\trep(i,0,6){\n\t\tpy+=-dy[(bit>>(i*2))&3];\n\t\tpx+=-dx[(bit>>(i*2))&3];\n\t\tif(y==py&&x==px){\n\t\t\tdone=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!done) res+=fld[y][x]-'0';\n\n\treturn res;\n}\n\nvoid Solve(){\n\tfill_n((int*)memo,64*64*4*(1<<12),-1);\n\tcin >> h >> w >> k;\n\trep(i,0,h) rep(j,0,w) cin >> fld[i][j];\n\n\tcout << Max(0,0,k,0) << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nchar a[60][60];\nint h,w,k,m=0;\nvoid g(int x,int y,int s,int d,int k){\n\tif(d==h+w-2 && x==h && y==w && k==0){\n\t\tif(s>m) m=s; return;\n\t}\n\telse{\n\n\t\tif(x+1>=1 && y>=1 && x+1<=h && y<=w && a[x+1][y]!='#'){\n\t\t\tif(a[x+1][y]!='.'){\n\t\t\t\tchar c=a[x+1][y];\n\t\t\t\ta[x+1][y]='.';\n\t\t\t\tg(x+1,y,s+c-'0',d+1,k);\n\t\t\t\ta[x+1][y]=c;\n\t\t\t}\n\t\t\telse g(x+1,y,s,d+1,k);\n\t\t}\n\n\t\tif(x>=1 && y+1>=1 && x<=h && y+1<=w && a[x][y+1]!='#'){\n\t\t\tif(a[x][y+1]!='.'){\n\t\t\t\tchar c=a[x][y+1];\n\t\t\t\ta[x][y+1]='.';\n\t\t\t\tg(x,y+1,s+c-'0',d+1,k);\n\t\t\t\ta[x][y+1]=c;\n\t\t\t}\n\t\t\telse g(x,y+1,s,d+1,k);\n\t\t}\n\n\t\tif(x-1>=1 && y>=1  && x-1<=h && y<=w && k>0 && a[x-1][y]!='#'){\n\t\t\tif(a[x-1][y]!='.'){\n\t\t\t\tchar c=a[x-1][y];\n\t\t\t\ta[x-1][y]='.';\n\t\t\t\tg(x-1,y,s+c-'0',d-1,k-1);\n\t\t\t\ta[x-1][y]=c;\n\t\t\t}\n\t\t\telse g(x-1,y,s,d-1,k-1);\n\t\t}\n\n\t\tif(x>=1 && y-1>=1 && x<=h && y-1<=w && k>0 && a[x][y-1]!='#'){\n\t\t\tif(a[x][y-1]!='.'){\n\t\t\t\tchar c=a[x][y-1];\n\t\t\t\ta[x][y-1]='.';\n\t\t\t\tg(x,y-1,s+c-'0',d-1,k-1);\n\t\t\t\ta[x][y-1]=c;\n\t\t\t}\n\t\t\telse g(x,y-1,s,d-1,k-1);\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\tcin >> h >> w >> k;\n\tREP(i,1,h){\n\tREP(j,1,w){\n\t\tcin >> a[i][j];\n\t}\n\t}\n\n\tg(1,1,0,0,k);\n\n\tcout << m  << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n//#define int long long\n#define PB push_back\n#define MK make_pair\n#define MKT make_tuple\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n\n//constexpr int INF = 1LL<<60;\nconstexpr int INF = 1 << 28;\n//constexpr int MOD = 100000;\nconstexpr int MAX_N = 52;\nconstexpr int dx[] = { 1, 0, -1, 0 };\nconstexpr int dy[] = { 0, 1, 0, -1 };\n\nint mem[MAX_N][MAX_N][4][1 << 7][1 << 7], h, w, k, fld[MAX_N][MAX_N];\n\ninline bool Chk(int x, int y, int mask1, int mask2) {\n    constexpr int len = 6;\n    int cx = x, cy = y;\n    cout << \"start\" << x << \" \" << y << endl;\n    for (int i = 0; i < len; ++i) {\n        int b1 = mask1 & (1 << (len - 1 - i)) ? 1 : 0, b2 = mask2 & (1 << (len - 1 - i)) ? 1 : 0;\n        int idx = b1 + 2 * b2;\n        cx -= dx[idx];\n        cy -= dy[idx];\n        if (x == cx && y == cy) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint Solve(int x, int y, int c, int mask1, int mask2) {\n    if (x == w + 1 && y == h) return 0;\n    if (mem[x][y][c][mask1][mask2] != -1) return mem[x][y][c][mask1][mask2];\n \n    int cur = Chk(x, y, mask1, mask2) ? 0 : fld[x][y];\n    int res = 0;\n    for (int i = 0; i < 4; ++i) {\n        if (1 < i && k <= c) break;\n        int tx = x + dx[i], ty = y + dy[i];\n        int nc = (1 < i) ? c + 1 : c;\n        if (fld[tx][ty] == -1) continue;\n        \n        int nm1 = (mask1 >> 1) + ((i % 2) << 5), nm2 = (mask2 >> 1) + ((1 < i) << 5);\n        res = max(res, Solve(tx, ty, nc, nm1, nm2));\n    }\n    \n    return mem[x][y][c][mask1][mask2] = res + cur;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    memset(fld, -1, sizeof(fld));\n    cin >> h >> w >> k;\n    for (int y = 1; y <= h; ++y) {\n        string s;\n        cin >> s;\n        for (int x = 1; x <= w; ++x) {\n            char c = s[x - 1];\n            if (c == '#') {\n                fld[x][y] = -1;\n                continue;\n            } else if (c == '.') {\n                fld[x][y] = 0;\n                continue;\n            }\n            fld[x][y] = c - '0';\n        }\n    }\n    fld[w + 1][h] = 0;\n    memset(mem, -1, sizeof(mem));\n    cout << Solve(1, 1, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  map<pii,int> m;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[pii(i+oy,j+ox)]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[pii(ny,nx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 全体のビット右にをシフト\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 下方向にビットをシフト\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nstruct Sit{\n  int cy,cx,mask,my,mx;\n  Sit(){}\n  Sit(int cy_,int cx_,int mask_,int my_,int mx_){\n    cy=cy_;\n    cx=cx_;\n    mask=mask_;\n    my=my_;\n    mx=mx_;\n  }\n  bool operator<(const Sit&sit)const{\n    return true;\n  }\n};\ntypedef pair<int,Sit> iSit;\n\nint dfs(int cy,int cx,int mask,int my,int mx){\n  if(dp[cy][cx][mask][my][mx]>=0)return dp[cy][cx][mask][my][mx];\n  int res=0;\n  int leftK=K-(my+mx);\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n      int nmask=p.first;\n      int nAddVal=p.second;\n      // cout<<nAddVal<<endl;\n      if(leftK>0&&(i==0||i==3))\n        res=max(res,dfs(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))+nAddVal);\n      else if((i==1||i==2))\n        res=max(res,dfs(ny,nx,nmask,my,mx)+nAddVal);\n    }\n  }\n  return dp[cy][cx][mask][my][mx]=res;\n}\n\nint dijkstra(){\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][1<<6][0][0]=0;\n  priority_queue<iSit> pq;\n  pq.push(make_pair(0,Sit(0,0,1<<6,0,0)));\n  while(pq.size()){\n    iSit is=pq.top();pq.pop();\n    int cval=is.first;\n    Sit cSit=is.second;\n    int cy=cSit.cy,cx=cSit.cx,mask=cSit.mask,my=cSit.my,mx=cSit.mx;\n    if(dp[cy][cx][mask][my][mx]>cval)continue;\n    int leftK=K-(my+mx);\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n        pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n        int nmask=p.first;\n        int nAddVal=p.second;\n        if(leftK>0&&(i==0||i==3)&&dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]<cval+nAddVal){\n          dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))));\n        }\n        else if((i==1||i==2)&&dp[ny][nx][nmask][my][mx]<cval+nAddVal){\n          dp[ny][nx][nmask][my][mx]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my,mx)));\n        }\n      }\n    }\n  }\n  int res=0;\n  for(int mask=0;mask<(1<<10);mask++)\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        res=max(res,dp[H-1][W-1][mask][i][j]);\n  return res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,(1<<6),0,0)<<endl;\n  //cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <utility>\n#include <algorithm>\n#define DEBUG\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename U, typename T, size_t N>\nvoid fill_all(T(&arr)[N], const U& v) {\n\tfor (auto& a : arr) { fill_all(a, v); }\n}\n\n\n\nint H, W;\nchar MAP[55][55];//h,w\nint32_t dp[50][50][4][1 << 11];\n//0:r,1:d,2:l,3:u\nuint8_t add_value(int x, int y, uint16_t mini_map, uint8_t next, int8_t k)\n{\n\tif (next == 0) { ++x; }\n\tif (next == 1) { ++y; }\n\tif (next == 2) { --x; }\n\tif (next == 3) { --y; }\n\tuint8_t res = 0;\n\tif ('0' <= MAP[y][x] && MAP[y][x] <= '9') {\n\t\tif (k == 3) {\n\t\t\tif (next <= 1) { res = MAP[y][x] - '0'; }\n\t\t\tif (next == 2)if ((mini_map & 1) == 1) { res = MAP[y][x] - '0'; }\n\t\t\tif (next == 3)if ((mini_map & 1) == 0) { res = MAP[y][x] - '0'; }\n\t\t}\n\t\tif (k == 2) {\n\t\t\tif (next == 0)if ((mini_map&(1 << 1)) == 0) { res = MAP[y][x] - '0'; }\n\t\t\tif (next == 1)if ((mini_map&(1 << 0)) == 0) { res = MAP[y][x] - '0'; }\n\t\t\tif (next == 2)if ((mini_map&(1 << 5)) == 0) { res = MAP[y][x] - '0'; }\n\t\t\tif (next == 3)if ((mini_map&(1 << 6)) == 0) { res = MAP[y][x] - '0'; }\n\t\t}\n\t\tif (k == 1) {\n\t\t\tif (next == 0)if ((mini_map&(1 << 5)) == 0) { res = MAP[y][x] - '0'; }\n\t\t\tif (next == 1)if ((mini_map&(1 << 4)) == 0) { res = MAP[y][x] - '0'; }\n\t\t\tif (next == 2)if ((mini_map&(1 << 9)) == 0) { res = MAP[y][x] - '0'; }\n\t\t\tif (next == 3)if ((mini_map&(1 << 10)) == 0) { res = MAP[y][x] - '0'; }\n\t\t}\n\t\tif (k == 0) {\n\t\t\tif (next == 0)if ((mini_map&(1 << 8)) == 0) { res = MAP[y][x] - '0'; }\n\t\t\tif (next == 1)if ((mini_map&(1 << 7)) == 0) { res = MAP[y][x] - '0'; }\n\t\t}\n\t}\n\treturn res;\n}\n//0:r,1:d,2:l,3:u\nuint16_t map_add(uint16_t mini_map, uint8_t next, int8_t k) {\n\tuint16_t res = 0;\n\tif (k == 3) {\n\t\tif (next <= 1) {\n\t\t\tres = (mini_map & 3) << 1;\n\t\t\tres |= next;\n\t\t}\n\t\tif (next == 2) {\n\t\t\tres |= 1 << 1;\n\t\t\tif (mini_map&(1 << 0)) {\n\t\t\t\tres |= 1 << 3;\n\t\t\t\tif (mini_map&(1 << 1)) {\n\t\t\t\t\tres |= 1 << 7;\n\t\t\t\t\tif (mini_map&(1 << 2)) {\n\t\t\t\t\t\t//\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres |= 1 << 10;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres |= 1 << 6;\n\t\t\t\t\tif (mini_map&(1 << 2)) {\n\t\t\t\t\t\tres |= 1 << 10;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres |= 1 << 9;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//\n\t\t\t\tif (mini_map&(1 << 1)) {\n\t\t\t\t\tres |= 1 << 6;\n\t\t\t\t\tif (mini_map&(1 << 2)) {\n\t\t\t\t\t\tres |= 1 << 10;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres |= 1 << 9;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres |= 1 << 5;\n\t\t\t\t\tif (mini_map&(1 << 2)) {\n\t\t\t\t\t\tres |= 1 << 9;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres |= 1 << 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (next == 3) {\n\t\t\tres |= 1 << 0;\n\t\t\tif (mini_map&(1 << 0)) {\n\t\t\t\t//\n\t\t\t\tif (mini_map&(1 << 1)) {\n\t\t\t\t\tres |= 1 << 6;\n\t\t\t\t\tif (mini_map&(1 << 2)) {\n\t\t\t\t\t\tres |= 1 << 10;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres |= 1 << 9;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres |= 1 << 5;\n\t\t\t\t\tif (mini_map&(1 << 2)) {\n\t\t\t\t\t\tres |= 1 << 9;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres |= 1 << 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres |= 1 << 2;\n\t\t\t\tif (mini_map&(1 << 1)) {\n\t\t\t\t\tres |= 1 << 5;\n\t\t\t\t\tif (mini_map&(1 << 2)) {\n\t\t\t\t\t\tres |= 1 << 9;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres |= 1 << 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres |= 1 << 4;\n\t\t\t\t\tif (mini_map&(1 << 2)) {\n\t\t\t\t\t\tres |= 1 << 8;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (k == 2) {\n\t\tif (next == 0) {\n\t\t\t//01\n\t\t\tres |= (mini_map&(1 << 0)) << 2;//2\n\t\t\t\t\t\t\t\t\t\t\t//3\n\t\t\tres |= (mini_map&(1 << 2)) << 2;//4\n\t\t\tres |= 1 << 5;//5\n\t\t\tres |= (mini_map&(1 << 3)) << 3;//6\n\t\t\t\t\t\t\t\t\t\t\t//7\n\t\t\tres |= (mini_map&(1 << 5)) << 3;//8\n\t\t\tres |= (mini_map&(1 << 6)) << 3;//9\n\t\t\tres |= (mini_map&(1 << 7)) << 3;//10\n\t\t}\n\t\tif (next == 1) {\n\t\t\t//01\n\t\t\t//2\n\t\t\tres |= (mini_map&(1 << 1)) << 2;//3\n\t\t\t\t\t\t\t\t\t\t\t//4\n\t\t\tres |= (mini_map&(1 << 2)) << 3;//5\n\t\t\tres |= 1 << 6;//6\n\t\t\tres |= (mini_map&(1 << 3)) << 4;//7\n\t\t\tres |= (mini_map&(1 << 4)) << 4;//8\n\t\t\tres |= (mini_map&(1 << 5)) << 4;//9\n\t\t\tres |= (mini_map&(1 << 6)) << 4;//10\n\t\t}\n\t\telse if (next == 2) {\n\t\t\t//0\n\t\t\tres |= (mini_map&(1 << 0)) << 1;//1\n\t\t\tres |= (mini_map&(1 << 1)) << 1;//2\n\t\t\t\t\t\t\t\t\t\t\t//3\n\t\t\tres |= (mini_map&(1 << 2)) << 2;//4\n\t\t\tres |= 1 << 5;//5\n\t\t\tres |= (mini_map&(1 << 3)) << 3;//6\n\t\t\tres |= (mini_map&(1 << 4)) << 3;//7\n\t\t\tres |= (mini_map&(1 << 6)) << 2;//8\n\t\t\tres |= (mini_map&(1 << 8)) << 1;//9\n\t\t\tres |= (mini_map&(1 << 9)) << 1;//10\n\t\t}\n\t\telse if (next == 3) {\n\t\t\tres |= (mini_map&(1 << 0)) << 0;//0\n\t\t\tres |= (mini_map&(1 << 1)) << 0;//1\n\t\t\t\t\t\t\t\t\t\t\t//2\n\t\t\tres |= (mini_map&(1 << 2)) << 1;//3\n\t\t\tres |= 1 << 4;//4\n\t\t\tres |= (mini_map&(1 << 3)) << 2;//5\n\t\t\t\t\t\t\t\t\t\t\t//6\n\t\t\tres |= (mini_map&(1 << 5)) << 2;//8\n\t\t\tres |= (mini_map&(1 << 9)) << 0;//9\n\t\t\tres |= (mini_map&(1 << 10)) << 0;//10\n\t\t}\n\t}\n\telse if (k == 1) {\n\t\tif (next == 0) {\n\t\t\t//012\n\t\t\tres |= (mini_map&(1 << 0)) << 3;//3\n\t\t\tres |= (mini_map&(1 << 1)) << 3;//4\n\t\t\tres |= (mini_map&(1 << 2)) << 3;//5\n\t\t\t\t\t\t\t\t\t\t\t//6\n\t\t\tres |= (mini_map&(1 << 4)) << 3;//7\n\t\t\tres |= (mini_map&(1 << 6)) << 2;//8\n\t\t\tres |= 1 << 9;//9\n\t\t\tres |= (mini_map&(1 << 8)) << 2;//10\n\t\t}\n\t\tif (next == 1) {\n\t\t\t//0123\n\t\t\tres |= (mini_map&(1 << 0)) << 4;//4\n\t\t\tres |= (mini_map&(1 << 1)) << 4;//5\n\t\t\tres |= (mini_map&(1 << 2)) << 4;//6\n\t\t\tres |= (mini_map&(1 << 3)) << 4;//7\n\t\t\tres |= (mini_map&(1 << 5)) << 3;//8\n\t\t\tres |= (mini_map&(1 << 7)) << 2;//9\n\t\t\tres |= 1 << 10;//10\n\t\t}\n\t\telse if (next == 2) {\n\t\t\t//0\n\t\t\tres |= (mini_map&(1 << 0)) << 1;//1\n\t\t\tres |= (mini_map&(1 << 1)) << 1;//2\n\t\t\tres |= (mini_map&(1 << 2)) << 1;//3\n\t\t\tres |= (mini_map&(1 << 3)) << 1;//4\n\t\t\tres |= (mini_map&(1 << 4)) << 1;//5\n\t\t\tres |= (mini_map&(1 << 5)) << 1;//6\n\t\t\tres |= (mini_map&(1 << 7)) << 0;//7\n\t\t\tres |= 1 << 8;//8\n\t\t}\n\t\telse if (next == 3) {\n\t\t\tres |= (mini_map&(1 << 0)) << 0;//0\n\t\t\tres |= (mini_map&(1 << 1)) << 0;//1\n\t\t\tres |= (mini_map&(1 << 2)) << 0;//2\n\t\t\t\t\t\t\t\t\t\t\t//3\n\t\t\tres |= (mini_map&(1 << 4)) << 0;//4\n\t\t\tres |= (mini_map&(1 << 5)) << 0;//5\n\t\t\tres |= (mini_map&(1 << 6)) << 0;//6\n\t\t\tres |= 1 << 7;//7\n\t\t\tres |= (mini_map&(1 << 8)) << 0;//7\n\t\t}\n\t}\n\telse {//k==0\n\t\tif (next == 0) {\n\t\t\t//0123\n\t\t\tres |= (mini_map&(1 << 1)) << 3;//4\n\t\t\tres |= (mini_map&(1 << 2)) << 3;//5\n\t\t\tres |= (mini_map&(1 << 3)) << 3;//6\n\t\t\tres |= (mini_map&(1 << 5)) << 2;//7\n\t\t\tres |= (mini_map&(1 << 6)) << 2;//8\n\t\t}\n\t\tif (next == 1) {\n\t\t\t//0123\n\t\t\tres |= (mini_map&(1 << 0)) << 4;//4\n\t\t\tres |= (mini_map&(1 << 1)) << 4;//5\n\t\t\tres |= (mini_map&(1 << 2)) << 4;//6\n\t\t\tres |= (mini_map&(1 << 4)) << 3;//7\n\t\t\tres |= (mini_map&(1 << 5)) << 3;//8\n\t\t}\n\t}\n\n\treturn res;\n}\nint32_t func(int8_t x, int8_t y, int8_t k, uint16_t mini_map)\n{\n\tif (k == 0 && x == W - 1 && y == H - 1) { return 0; }\n\tif (MAP[y][x] == '#') { return -10 * 50 * 50 * 10; }\n\tauto& memo = dp[x][y][k][mini_map];\n\tif (memo >= 0) { return memo; }\n#ifdef DEBUG\n\tbool print = (k == 3);\n\tif (print) { std::cout << \"IN*\" << (int)x<<' '<<(int)y<<' ' << (int)k << ' ' << (int)mini_map << std::endl; }\n#endif\n\tint32_t result = 0;\n\t//0:r,1:d,2:l,3:u\n#ifdef DEBUG\n\tif (print) { std::cout << \"x,w-1:\" << (int)x << ' ' << (int)W - 1 << std::endl; }\n#endif\n\tif (x < W - 1) {\n\t\t//???\n\t\tresult = std::max(result,\n\t\t\tfunc(x + 1, y, k, map_add(mini_map, 0, k)) +\n\t\t\tadd_value(x, y, mini_map, 0, k)\n\t\t);\n#ifdef DEBUG\n\t\tif (print) {\n\t\t\tstd::cout << (int)func(x + 1, y, k, map_add(mini_map, 0, k)) +\n\t\t\t\tadd_value(x, y, mini_map, 0, k) << std::endl;\n\t\t}\n#endif\n\t}\n#ifdef DEBUG\n\tif (print) { std::cout << \"y,h-1:\" << (int)y << ' ' << (int)H - 1 << std::endl; }\n#endif\n\tif (y < H - 1) {\n\t\t//???\n\t\tresult = std::max(result, func(x, y + 1, k, map_add(mini_map, 1, k)) + add_value(x, y, mini_map, 1, k));\n#ifdef DEBUG\n\t\tif (print) { std::cout << (int)func(x, y + 1, k, map_add(mini_map, 1, k)) + add_value(x, y, mini_map, 1, k) << std::endl; }\n#endif\n\t}\n#ifdef DEBUG\n\tif (print) { std::cout << \"k:\" << (int)k << std::endl; }\n#endif\n\tif (0 < k) {\n\t\t//???\n\t\tif (0<x)\n\t\t\tresult = std::max(result, func(x - 1, y, k - 1, map_add(mini_map, 2, k)) + add_value(x, y, mini_map, 2, k));\n\t\t//???\n\t\tif (0<y)\n\t\t\tresult = std::max(result, func(x, y - 1, k - 1, map_add(mini_map, 3, k)) + add_value(x, y, mini_map, 3, k));\n\n#ifdef DEBUG\n\t\tif (0<x)if (print) { std::cout << (int)func(x - 1, y, k - 1, map_add(mini_map, 2, k)) + add_value(x, y, mini_map, 2, k) << std::endl; }\n\t\tif (0<y)if (print) { std::cout << (int)func(x, y - 1, k - 1, map_add(mini_map, 3, k)) + add_value(x, y, mini_map, 3, k) << std::endl; }\n#endif\n\t}\n\n#ifdef DEBUG\n\tif (print) { std::cout << \"OUT*\" << (int)x<<' '<<(int)y<<' '  << (int)k << ' ' << (int)mini_map << ' ' << result << std::endl; }\n#endif\n\treturn memo = result;\n}\n\nint main()\n{\n\tstd::cin.sync_with_stdio(false);\n\tstd::cout.sync_with_stdio(false);\n\tfill_all(dp, -1);\n\tint K;\n\tstd::cin >> H >> W >> K;\n\tfor (int y = 0; y<H; ++y) {\n\t\tstd::cin >> MAP[y];\n\t}\n\tauto test = map_add(1, 3, 3);\n\tauto TRUE = ((1 << 8) | (1 << 5) | (1 << 0));\n\tif (test != TRUE) {\n\t\tstd::cout << \"ERROR*\" << test << '!' << '=' << TRUE << std::endl;\n\n\t}\n\telse {\n\t\tstd::cout << \"OK*\" << test << '=' << TRUE << std::endl;\n\t}\n\n\tstd::cout << func(0, 0, K, 0) << std::endl;\n}\n\n\n\n\n\n\n\n\n\n\n#if 0\n\n#include <bits/stdc++.h>\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename U, typename T, size_t N>\nvoid fill_all(T(&arr)[N], const U& v) {\n\tfor (auto& a : arr) { fill_all(a, v); }\n}\n\n\n\nint H, W, K;\nchar MAP[55][55];//h,w\nint32_t dp[50][50][4][1 << 8];\nuint8_t map_xadd(uint8_t mini_map, int8_t k) {\n\tif (k == 0) { return 0; }\n\tuint8_t res = 0;\n\tif (k == 3) {\n\t\tres |= (mini_map & 2) >> 1;//0\n\t\tres |= (mini_map & 4) >> 1;//1\n\t\t\t\t\t\t\t\t   //2\n\t\tres |= (mini_map & 0x10) >> 1;//3\n\t\tres |= (mini_map & 0x20) >> 1;//4\n\t\t\t\t\t\t\t\t\t  //5\n\t\tres |= (mini_map & 0x80) >> 1;//6\n\t\tres |= 0x80;//7\n\t}\n\tif (k == 2) {\n\t\tres |= (mini_map & 2) >> 1;//0\n\t\tres |= (mini_map & 4) >> 1;//1\n\t\t\t\t\t\t\t\t   //2\n\t\tres |= 0x8;//3\n\t\t\t\t   //4\n\t\tres |= (mini_map & 0x40) >> 1;//5\n\t\tres |= (mini_map & 0x80) >> 1;//6\n\t\t\t\t\t\t\t\t\t  //7\n\t}\n\telse {//K==1\n\t\tres |= (mini_map & 2) >> 1;//0\n\t\t\t\t\t\t\t\t   //1\n\t\tres |= (mini_map & 8) >> 1;//2\n\t\tres |= (mini_map & 0x10) >> 1;//3\n\t\t\t\t\t\t\t\t\t  //4\n\t\tres |= (mini_map & 0x40) >> 1;//5\n\t\tres |= (mini_map & 0x80) >> 1;//6\n\t\t\t\t\t\t\t\t\t  //7\n\t}\n\n\treturn res;\n}\nuint8_t map_yadd(uint8_t mini_map, int8_t k) {\n\tif (k == 0) { return 0; }\n\tuint8_t res = 0;\n\tif (k == 3) {\n\t\t//012\n\t\tres |= (mini_map & 0x38) >> 3;\n\t\t//34\n\t\tres |= (mini_map & 0xB0) >> 3;\n\t\t//5\n\t\tres |= 0x20;\n\t\t//67\n\t}\n\tif (k == 2) {\n\t\t//0\n\t\tres |= (mini_map & 0x08) >> 3;\n\t\t//1\n\t\tres |= 0x02;\n\t\t//2\n\t\tres |= (mini_map & 0x10) >> 2;\n\t\t//3\n\t\tres |= (mini_map & 0x20) >> 2;\n\t\t//4\n\t\tres |= (mini_map & 0x80) >> 3;\n\t\t//567\n\t}\n\telse {//K==1\n\t\tres |= (mini_map & 0x18) >> 3//01\n\t\t\tres |= (mini_map & 0xE0) >> 3;//234\n\t\t\t\t\t\t\t\t\t\t  //567\n\t}\n\treturn res;\n}\nuint8_t map_ladd(uint8_t mini_map, int8_t k) {\n\tif (k <= 1) { return 0; }\n\tuint8_t res = 0;\n\tif (k == 3) {\n\t\tres |= (mini_map & 2) >> 1;//0\n\t\tres |= (mini_map & 4) >> 1;//1\n\t\t\t\t\t\t\t\t   //2\n\t\tres |= (mini_map & 0x10) >> 1;//3\n\t\tres |= (mini_map & 0x20) >> 1;//4\n\t\t\t\t\t\t\t\t\t  //5\n\t\tres |= (mini_map & 0x80) >> 1;//6\n\t\tres |= 0x80;//7\n\t}\n\telse {//if(k == 1){\n\t\tres |= (mini_map & 2) >> 1;//0\n\t\tres |= (mini_map & 4) >> 1;//1\n\t\t\t\t\t\t\t\t   //2\n\t\tres |= 0x8;//3\n\t\t\t\t   //4\n\t\tres |= (mini_map & 0x40) >> 1;//5\n\t\tres |= (mini_map & 0x80) >> 1;//6\n\t\t\t\t\t\t\t\t\t  //7\n\t}\n\telse {//K==1\n\t\tres |= (mini_map & 2) >> 1;//0\n\t\t\t\t\t\t\t\t   //1\n\t\tres |= (mini_map & 8) >> 1;//2\n\t\tres |= (mini_map & 0x10) >> 1;//3\n\t\t\t\t\t\t\t\t\t  //4\n\t\tres |= (mini_map & 0x40) >> 1;//5\n\t\tres |= (mini_map & 0x80) >> 1;//6\n\t\t\t\t\t\t\t\t\t  //7\n\t}\n\n\treturn res;\n}\nuint8_t map_yadd(uint8_t mini_map, int8_t k) {\n\tif (k == 0) { return 0; }\n\tuint8_t res = 0;\n\tif (k == 3) {\n\t\t//012\n\t\tres |= (mini_map & 0x38) >> 3;\n\t\t//34\n\t\tres |= (mini_map & 0xB0) >> 3;\n\t\t//5\n\t\tres |= 0x20;\n\t\t//67\n\t}\n\tif (k == 2) {\n\t\t//0\n\t\tres |= (mini_map & 0x08) >> 3;\n\t\t//1\n\t\tres |= 0x02;\n\t\t//2\n\t\tres |= (mini_map & 0x10) >> 2;\n\t\t//3\n\t\tres |= (mini_map & 0x20) >> 2;\n\t\t//4\n\t\tres |= (mini_map & 0x80) >> 3;\n\t\t//567\n\t}\n\telse {//K==1\n\t\tres |= (mini_map & 0x18) >> 3//01\n\t\t\tres |= (mini_map & 0xE0) >> 3;//234\n\t\t\t\t\t\t\t\t\t\t  //567\n\t}\n\treturn res;\n}\n//012\n//345(K==3)\n//67*\n//012\n//3*4(K==2)\n//567\n//*01\n//234(K==1)\n//567\n//00000000(K==0)\nint32_t func(int8_t x int8_t y, int8_t k, uint8_t mini_map)\n{\n\tif (k == 0 && x == W - 1 && y == H - 1) { return 0; }\n\tauto& memo = dp[x][y][k][mini_map];\n\tif (memo >= 0) { return memo; }\n\n\tint32_t result = 0;\n\tif (x < W - 1) {\n\t\t//???\n\t\tresult = std::max(result, func(x + 1, y, k, map_xadd(mini_map, k)));\n\t}\n\tif (y < H - 1) {\n\t\t//???\n\t\tresult = std::max(result, func(x, y + 1, k, map_yadd(mini_map, k)));\n\t}\n\tif (0 < k) {\n\t\t//???\n\t\tresult = std::max(result, func(x - 1, y, k - 1, map_ladd(mini_map, k)));\n\t\t//???\n\t\tresult = std::max(result, func(x, y - 1, k - 1, map_uadd(mini_map, k)));\n\t}\n\n\treturn memo = result;\n}\n\nint main()\n{\n\tstd::cin.sync_with_stdio(false);\n\tstd::cout.sync_with_stdio(false);\n\tfill_all(dp, -1);\n\tstd::cin >> H >> W >> K;\n\tfor (int y = 0; y<H; ++y)\n\t\tstd::cin >> MAP[y];\n\n\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007\n#define INF 1000000000\n#define LLINF 2000000000000000000LL\n\n#define SIZE 500000\n\n#define MAX_H 100\n#define MAX_W 100\n\nint H,W,K;\nchar mm[50][51];\n\nint memo[50][50][1<<12][4];\n\nint mo[5]={0,-1,0,1,0};\n\nint dfs(int y,int x,int visit,int k,int h=0){\n    int ret = -INF;\n    bool visit_mm[50][50] = {0};\n    \n    //cerr << \"(\" << y << \",\" << x << \")\" << endl;\n    \n    if(memo[y][x][visit][k] > 0) return memo[y][x][visit][k];\n    \n    if(y==H-1 && x==W-1 && k==0) return 0;\n    \n    int after_visit = (visit%(1<<10));\n    int after_x = x,after_y = y;\n    int calc_visit = visit;\n    \n    vector<pair<int,int> > vec;\n    \n    for(int i=0;i<min(h,6);i++){\n        after_x -= mo[calc_visit%4];\n        after_y -= mo[calc_visit%4+1];\n        calc_visit/=4;\n        visit_mm[after_y][after_x] = true;\n        \n        //cerr << \"<- (\" << after_y << \",\" << after_x << \")\" << endl;\n    }\n    \n    int add = 1;\n    \n    for(int i=0;i<4;i++){\n        if(k>=1 || i>=2){\n            int to_x = x+mo[i];\n            int to_y = y+mo[i+1];\n            \n            if(to_x<0 || W<=to_x || to_y<0 || H<=to_y || mm[to_y][to_x]=='#') continue;\n            \n            if(visit_mm[to_y][to_x]) add = 0;\n            else add = mm[to_y][to_x]-'0';\n            \n            ret = max(ret,dfs(to_y,to_x,after_visit*4+i,k-(i<=1),h+1)+add);\n        }\n    }\n    \n    return memo[y][x][visit][k] = ret;\n    \n}\n\nint main(){\n    \n    scanf(\"%d%d%d\",&H,&W,&K);\n    \n    for(int i=0;i<H;i++){\n        scanf(\"%s\",mm[i]);\n    }\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(mm[i][j]=='.') mm[i][j] = '0';\n        }\n    }\n    \n    printf(\"%d\\n\",dfs(0,0,0,K));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[4][50][50][1 << 12];\nint H, W, K;\nchar mas[50][50];\nint dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint mask;\n\nint getdir(int bit, int i){\n  return (bit >> (i * 2)) & 3;\n}\n#define INF (1 << 30)\nint rec(int x, int y, int mul, int bit){\n  if(y == H - 1 && x == W - 1 && mul == 0) return 0;\n  if(~dp[mul][y][x][bit]) return dp[mul][y][x][bit];\n\n  int ret = -INF, value = 0, mx = x, my = y;\n  bool hoge = false;\n  if(mas[y][x] != '.'){\n    for(int i = 0; i < 2 * K; i++){\n      my -= dy[getdir( bit, i)];\n      mx -= dx[getdir( bit, i)];\n      if(mx == x && my == y){\n        hoge = true;\n        break;\n      }\n    }\n    if(!hoge) value = mas[y][x] - '0';\n  }\n\n  for(int i = 0; i < 4; i++){\n    if(mul == 0 && i > 1) break;\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= H || nx < 0 || nx >= W || mas[ny][nx] == '#') continue;\n    ret = max( ret, rec( nx, ny, mul - (i > 1), ((bit << 2)|i) & mask) + value);\n  }\n  return dp[mul][y][x][bit] = ret;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  mask = (1 << (K * 2 * 2)) - 1;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      cin >> mas[i][j];\n    }\n  }\n  fill_n( ***dp, 4 * 50 * 50 * (1 << 12), -1);\n  cout << rec( 0, 0, K, 0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1}; //00右,01下,10左,11上\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nconst int mask=(1<<12)-1;\nint h,w,k,memo[50][50][4][1<<12];\nchar fld[50][50];\n\nbool Check(int y,int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w&&fld[y][x]!='#';\n}\n\nint Max(int y,int x,int c,int bit){\n\tint &res=memo[y][x][c][bit];\n\tif(res!=-1) return res;\n\tif(y==h-1&&x==w-1&&c==0) return res=0;\n\n\tbool done=false;\n\tint py=y,px=x;\n\trep(i,0,6){\n\t\tpy-=dy[(bit>>(i*2))&3];\n\t\tpx-=dx[(bit>>(i*2))&3];\n\t\tif(y==py&&x==px){\n\t\t\tdone=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint gift=0;\n\tif(!done&&fld[y][x]!='.') gift=fld[y][x]-'0';\n\n\tres=-INF;\n\trep(i,0,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(!Check(ny,nx)) continue;\n\t\tif(i<2){\n\t\t\tres=max(res,Max(ny,nx,c,((bit<<2)&mask)|i)+gift);\n\t\t}else if(c>=1){\n\t\t\tres=max(res,Max(ny,nx,c-1,((bit<<2)&mask)|i)+gift);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid Solve(){\n\tfill_n((int*)memo,50*50*4*(1<<12),-1);\n\tcin >> h >> w >> k;\n\trep(i,0,h) rep(j,0,w) cin >> fld[i][j];\n\n\tcout << Max(0,0,k,0) << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define INF -(1 << 23)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint main()\n{\n\tint H, W, K;\n\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &K);\n\n\tvector<string> M(H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tcin >> M[i];\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (M[i][j] == '.')\n\t\t\t{\n\t\t\t\tM[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<vector<vector<int> > > > dp(H, vector<vector<vector<int> > >(W, vector<vector<int> >(K + 1, vector<int>(64, INF))));\n\n\tdp[0][0][0][0] = 0;\n\n\tfor (int rep = 0; rep <= K; rep++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= K; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < 64; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint dir = l % 4;\n\n\t\t\t\t\t\t\tif ((0 <= j + dx[dir] && j + dx[dir] < W && 0 <= i + dy[dir] && i + dy[dir] < H) && !((dir % 3) && K != 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint r = m * 16 + l / 4;\n\n\t\t\t\t\t\t\t\t\tif (dir % 3)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k - 1][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = -1;\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tfor (int j = 0; j < 64; j++)\n\t\t{\n\t\t\tret = max(ret, dp[H - 1][W - 1][i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\ntypedef pair<int, int> Point;\n\nint H, W, K;\nchar grid[64][64];\nvector<Point> rem[4];\nint vis[64][64];\nint dp[50][50][4][1 << 12];\n\nvoid init()\n{\n\tmemset(grid, '#', sizeof(grid));\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tfor (int k = 0; k <= 3; k++){\n\t\tfor (int x = -k; x <= (3 - k); x++){\n\t\t\tfor (int y = -k; y <= (3 - k); y++){\n\t\t\t\t//if (x == 0 && y == 0) continue;\n\t\t\t\tif (-k <= (x + y) && (x + y) <= (3 - k)){\n\t\t\t\t\trem[k].push_back(Point(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint calcBit(int x, int y, int k)\n{\n\tint res = 0;\n\tfor (Point &p : rem[k]){\n\t\tres <<= 1;\n\t\tint X = x + p.first;\n\t\tint Y = y + p.second;\n\t\tif (vis[X][Y] > 0) res |= 1;\n\t}\n\treturn res;\n}\n\nint calc(int x, int y, int k)\n{\n\tint bit = calcBit(x, y, k);\n\tint &res = dp[x - 3][y - 3][k][bit];\n\tif (~res) return res;\n\t\n\tint add = 0;\n\tif (grid[x][y] >= '1' && grid[x][y] <= '9'){\n\t\tif (vis[x][y] == 0){\n\t\t\tadd = grid[x][y] - '0';\n\t\t}\n\t}\n\t\n\tif (x == H + 2 && y == W + 2 && k == 0){\n\t\treturn res = add;\n\t}\n\t\n\tres = -INF;\n\t\n\tvis[x][y]++;\n\tfor (int dir = 0; dir < 4; dir++){\n\t\tint nx = x + dx[dir];\n\t\tint ny = y + dy[dir];\n\t\tint nk = k - (dir < 2);\n\t\tif (grid[nx][ny] == '#') continue;\n\t\tif (nk < 0) continue;\n\t\tres = max(res, calc(nx, ny, nk));\n\t}\n\tvis[x][y]--;\n\t\n\treturn res += add;\n}\n\nint main(void)\n{\n\tinit();\n\t\n\tscanf(\"%d %d %d\", &H, &W, &K);\n\t\n\tfor (int i = 0; i < H; i++){\n\t\tfor (int j = 0; j < W; j++){\n\t\t\tscanf(\" %c\", &grid[i + 3][j + 3]);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", calc(3, 3, K));\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n  \nusing namespace std;\n  \n//#define int long long\n#define PB push_back\n#define MK make_pair\n#define MKT make_tuple\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n  \n//constexpr int INF = 1LL<<60;\nconstexpr int INF = 1 << 28;\n//constexpr int MOD = 100000;\nconstexpr int MAX_N = 51;\nconstexpr int dx[] = { 1, 0, -1, 0 };\nconstexpr int dy[] = { 0, 1, 0, -1 };\n  \nint mem[MAX_N][MAX_N][4][1 << 6][1 << 6], h, w, k, fld[MAX_N + 1][MAX_N + 1];\n  \ninline bool Chk(int x, int y, int mask1, int mask2) {\n    constexpr int len = 6;\n    int cx = x, cy = y;\n    for (int i = 0; i < len; ++i) {\n        int b1 = mask1 & (1 << (len - 1 - i)) ? 1 : 0, b2 = mask2 & (1 << (len - 1 - i)) ? 1 : 0;\n        int idx = b1 + 2 * b2;\n        cx -= dx[idx];\n        cy -= dy[idx];\n        if (x == cx && y == cy) {\n            return true;\n        }\n    }\n    return false;\n}\n  \nint Solve(int x, int y, int c, int mask1, int mask2) {\n    if (x == w + 1 && y == h) return 0;\n    if (mem[x][y][c][mask1][mask2] != -1) return mem[x][y][c][mask1][mask2];\n   \n    int cur = Chk(x, y, mask1, mask2) ? 0 : fld[x][y];\n    int res = 0;\n    for (int i = 0; i < 4; ++i) {\n        if (1 < i && k <= c) break;\n        int tx = x + dx[i], ty = y + dy[i];\n        int nc = (1 < i) ? c + 1 : c;\n        if (fld[tx][ty] == -1) continue;\n          \n        int nm1 = (mask1 >> 1) + ((i % 2) << 5), nm2 = (mask2 >> 1) + ((1 < i) << 5);\n        res = max(res, Solve(tx, ty, nc, nm1, nm2));\n    }\n      \n    return mem[x][y][c][mask1][mask2] = res + cur;\n}\n  \nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n  \n    memset(fld, -1, sizeof(fld));\n    cin >> h >> w >> k;\n    for (int y = 1; y <= h; ++y) {\n        string s;\n        cin >> s;\n        for (int x = 1; x <= w; ++x) {\n            char c = s[x - 1];\n            if (c == '#') {\n                fld[x][y] = -1;\n                continue;\n            } else if (c == '.') {\n                fld[x][y] = 0;\n                continue;\n            }\n            fld[x][y] = c - '0';\n        }\n    }\n    fld[w + 1][h] = 0;\n    memset(mem, -1, sizeof(mem));\n    cout << Solve(1, 1, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<bitset>\n#include<vector>\nusing namespace std;\nint H, W, K;\nchar town[51][51];\nint ans = 0;\nint dp[52][52][4][5][5][1 << 10] = {};\nint ac[5][5] = { { 10, 10, 10, 10, 10 },\n{ 10, 3, 6, 8, 9 },\n{ 10, 2, 5, 7, 10 },\n{ 10, 1, 4, 10, 10 },\n{ 10, 0, 10, 10, 10 }\n};\n\nint solve() {\n\tdp[1][1][0][1][1][1 << 3] = 1;\n\tfor (int k = 0; k <= K; k++) {\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tfor (int x = 1; x <= 4; x++) {\n\t\t\t\t\tfor (int y = 1; y <= 4; y++) {\n\t\t\t\t\t\tfor (int st = 0; st < (1 << 10); st++) {\n\t\t\t\t\t\t\tif (dp[i][j][k][x][y][st] <= 0) continue;\n\t\t\t\t\t\t\tbitset<11> bit(st);\n\t\t\t\t\t\t\tint b[11] = {};\n\t\t\t\t\t\t\tfor (int q = 0; q < 10; q++) {\n\t\t\t\t\t\t\t\tif (bit[q]) b[q] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint to = 0;\n\t\t\t\t\t\t\tint res = dp[i][j][k][x][y][st];\n\t\t\t\t\t\t\t//east\n\t\t\t\t\t\t\tif (town[i][j + 1] != '#') {\n\t\t\t\t\t\t\t\tto |= b[1];\n\t\t\t\t\t\t\t\tto |= b[2] << 1;\n\t\t\t\t\t\t\t\tto |= b[3] << 2;\n\t\t\t\t\t\t\t\tto |= b[5] << 4;\n\t\t\t\t\t\t\t\tto |= b[6] << 5;\n\t\t\t\t\t\t\t\tto |= b[8] << 7;\n\t\t\t\t\t\t\t\tif (b[ac[x - 1][y]] == 0 && '1' <= town[i][j + 1] && town[i][j + 1] <= '9') res += town[i][j + 1] - '0';\n\t\t\t\t\t\t\t\tto |= 1 << ac[x][y];\n\n\t\t\t\t\t\t\t\tdp[i][j + 1][k][x][y][to] = max(dp[i][j + 1][k][x][y][to], res);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//south\n\t\t\t\t\t\t\tto = 0;\n\t\t\t\t\t\t\tres = dp[i][j][k][x][y][st];\n\t\t\t\t\t\t\tif (town[i + 1][j] != '#') {\n\t\t\t\t\t\t\t\tto |= b[1] << 4;\n\t\t\t\t\t\t\t\tto |= b[2] << 5;\n\t\t\t\t\t\t\t\tto |= b[3] << 6;\n\t\t\t\t\t\t\t\tto |= b[5] << 7;\n\t\t\t\t\t\t\t\tto |= b[6] << 8;\n\t\t\t\t\t\t\t\tto |= b[8] << 9;\n\t\t\t\t\t\t\t\tif (b[ac[x][y - 1]] == 0 && '1' <= town[i + 1][j] && town[i + 1][j] <= '9') res += town[i + 1][j] - '0';\n\t\t\t\t\t\t\t\tto |= 1 << ac[x][y];\n\n\t\t\t\t\t\t\t\tdp[i + 1][j][k][x][y][to] = max(dp[i + 1][j][k][x][y][to], res);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k < K) {\n\t\t\t\t\t\t\t\t//west\n\t\t\t\t\t\t\t\tres = dp[i][j][k][x][y][st];\n\t\t\t\t\t\t\t\tif (town[i][j - 1] != '#') {\n\t\t\t\t\t\t\t\t\tif (b[ac[x + 1][y]] == 0 && '1' <= town[i][j - 1] && town[i][j - 1] <= '9') res += town[i][j - 1] - '0';\n\t\t\t\t\t\t\t\t\tto = st | (1 << ac[x + 1][y]);\n\t\t\t\t\t\t\t\t\tdp[i][j - 1][k + 1][x + 1][y][to] = max(dp[i][j - 1][k + 1][x + 1][y][to], res);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//north\n\t\t\t\t\t\t\t\tres = dp[i][j][k][x][y][st];\n\t\t\t\t\t\t\t\tif (town[i - 1][j] != '#') {\n\t\t\t\t\t\t\t\t\tif (b[ac[x][y + 1]] == 0 && '1' <= town[i - 1][j] && town[i - 1][j] <= '9') res += town[i - 1][j] - '0';\n\t\t\t\t\t\t\t\t\tto = st | (1 << ac[x][y + 1]);\n\t\t\t\t\t\t\t\t\tdp[i - 1][j][k + 1][x][y + 1][to] = max(dp[i - 1][j][k + 1][x][y + 1][to], res);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int k = 0; k <= K; k++) {\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tfor (int x = 1; x <= 4; x++) {\n\t\t\t\t\tfor (int y = 1; y <= 4; y++) {\n\t\t\t\t\t\tfor (int st = 0; st < (1 << 10); st++) {\n\t\t\t\t\t\t\tans = max(ans, dp[i][j][k][x][y][st]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans - 1;\n}\n\nvoid input() {\n\tcin >> H >> W >> K;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> town[i][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tinput();\n\tcout << solve() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <tuple>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef tuple<P, int, set<P>> T;\n\nint n, m, z;\nchar x[50][51];\n\nint a;\nmap<T, int> b;\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &z);\n\trep(i, n){\n\t\tscanf(\"%s\", x[i]);\n\t}\n\n\tqueue<T> q;\n\tq.push(T(P(0, 0), z, {}));\n\twhile(!q.empty()){\n\t\tT t = q.front();\n\t\tq.pop();\n\t\tP p = get<0>(t);\n\t\tint z = get<1>(t);\n\t\tset<P> s = get<2>(t);\n\t\tif(p == P(n - 1, m - 1)){\n\t\t\ta = max(b[T(p, z, s)], a);\n\t\t}\n\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {1, 0, -1, 0};\n\t\trep(i, 4){\n\t\t\tint nx = p.first + dx[i];\n\t\t\tint ny = p.second + dy[i];\n\t\t\tint nz = i >= 2 ? z - 1 : z;\n\n\t\t\tif(!(0 <= nx && nx < n && 0 <= ny && ny < m && nz >= 0 && x[nx][ny] != '#')){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint g = 0;\n\t\t\tset<P> ns;\n\t\t\tif('1' <= x[nx][ny] && x[nx][ny] <= '9' && s.find({nx, ny}) == s.end()){\n\t\t\t\tns.insert({nx, ny});\n\t\t\t\tg = x[nx][ny] - '0';\n\t\t\t}\n\t\t\tfor(auto it = s.begin(); it != s.end(); ++it){\n\t\t\t\tint u = max(nx - it->first, 0);\n\t\t\t\tint v = max(ny - it->second, 0);\n\t\t\t\tif(u + v <= nz){\n\t\t\t\t\tns.insert(*it);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tT nk({nx, ny}, nz, ns);\n\t\t\tif(b.find(nk) == b.end() || b[nk] < b[T(p, z, s)] + g){\n\t\t\t\tb[nk] = b[T(p, z, s)] + g;\n\t\t\t\tq.push(T({nx, ny}, nz, ns));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", a);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \nusing namespace std;\n \n//#define int long long\n#define PB push_back\n#define MK make_pair\n#define MKT make_tuple\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n \n//constexpr int INF = 1LL<<60;\nconstexpr int INF = 1 << 28;\n//constexpr int MOD = 100000;\nconstexpr int MAX_N = 51;\nconstexpr int dx[] = { 1, 0, -1, 0 };\nconstexpr int dy[] = { 0, 1, 0, -1 };\n \nint mem[MAX_N][MAX_N][4][1 << 6][1 << 6], h, w, k, fld[MAX_N + 1][MAX_N + 1];\n \ninline bool Chk(int x, int y, int mask1, int mask2) {\n    constexpr int len = 6;\n    int cx = x, cy = y;\n    cout << \"start\" << x << \" \" << y << endl;\n    for (int i = 0; i < len; ++i) {\n        int b1 = mask1 & (1 << (len - 1 - i)) ? 1 : 0, b2 = mask2 & (1 << (len - 1 - i)) ? 1 : 0;\n        int idx = b1 + 2 * b2;\n        cx -= dx[idx];\n        cy -= dy[idx];\n        if (x == cx && y == cy) {\n            return true;\n        }\n    }\n    return false;\n}\n \nint Solve(int x, int y, int c, int mask1, int mask2) {\n    if (x == w + 1 && y == h) return 0;\n    if (mem[x][y][c][mask1][mask2] != -1) return mem[x][y][c][mask1][mask2];\n  \n    int cur = Chk(x, y, mask1, mask2) ? 0 : fld[x][y];\n    int res = 0;\n    for (int i = 0; i < 4; ++i) {\n        if (1 < i && k <= c) break;\n        int tx = x + dx[i], ty = y + dy[i];\n        int nc = (1 < i) ? c + 1 : c;\n        if (fld[tx][ty] == -1) continue;\n         \n        int nm1 = (mask1 >> 1) + ((i % 2) << 5), nm2 = (mask2 >> 1) + ((1 < i) << 5);\n        res = max(res, Solve(tx, ty, nc, nm1, nm2));\n    }\n     \n    return mem[x][y][c][mask1][mask2] = res + cur;\n}\n \nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    memset(fld, -1, sizeof(fld));\n    cin >> h >> w >> k;\n    for (int y = 1; y <= h; ++y) {\n        string s;\n        cin >> s;\n        for (int x = 1; x <= w; ++x) {\n            char c = s[x - 1];\n            if (c == '#') {\n                fld[x][y] = -1;\n                continue;\n            } else if (c == '.') {\n                fld[x][y] = 0;\n                continue;\n            }\n            fld[x][y] = c - '0';\n        }\n    }\n    fld[w + 1][h] = 0;\n    memset(mem, -1, sizeof(mem));\n    cout << Solve(1, 1, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nlong long in(){\n\tlong long n;\n\tscanf(\"%lld\",&n);\n\treturn n;\n}\n\n\n/*\nchokuzen no 3 kai no ugoki wo motte DP?\n\n*/\n#define D (k*2)\nchar field[50][50];\n\nint cost[50][50];\n\nint dx[] = {0,1,0,-1,0}; // R D L U\nint dy[] = {0,0,1,0,-1};\nint H,W,K;\n\nmap<short,int> dp[50][50][4];\nint p5[10];\nint dfs(char x,char y,char k,int tail){\n\tif( dp[x][y][k].count(tail) ){\n\t\treturn dp[x][y][k][tail];\n\t}\n\tint ans = (x==W-1&&y==H-1)?0:-1e9;\n\t\n\tint cx=x,cy=y;\n\tint flag = true;\n\n\tvector< pair<char,char> > c;\n\tfor(int i = 0 ; i < 6 ; i++){\n\t\tint d = tail / p5[i] % 5;\n\t\tif( d == 0 ) continue;\n\t\tcx -= dx[d];\n\t\tcy -= dy[d];\n\t\tc.push_back(mp(cx,cy));\n\t\t//cout << cx << \",\" << cy << \" - <> \";\n\t}\n\t//cout << \"[\" << tail.size() << \"]\" << endl;\n\tif(k && y ){\n\t\tint flag = true;\n\t\tif( field[y-1][x] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] == pair<char,char>(x,y-1) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 4) % p5[6];\n\t\t\tans = max( ans , dfs(x,y-1,k-1,tmp)+flag*(field[y-1][x]-'0') );\n\t\t}\n\t}\n\tif(k && x ){\n\t\tint flag = true;\n\t\tif( field[y][x-1] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] ==  pair<char,char>(x-1,y) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 3) % p5[6];\n\t\t\tans = max( ans , dfs(x-1,y,k-1,tmp)+flag*(field[y][x-1]-'0') );\n\t\t}\n\t}\n\tif( y+1 < H){\n\t\tint flag = true;\n\t\tif( field[y+1][x] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] ==  pair<char,char>(x,y+1) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 2) % p5[6];\n\t\t\tans = max( ans , dfs(x,y+1,k,tmp)+flag*(field[y+1][x]-'0') );\n\t\t}\n\t}\n\tif( x+1 < W){\n\t\tint flag = true;\n\t\tif( field[y][x+1] != '#' ){\n\t\t\tfor(int i = 0 ; i < c.size() ; i++)\n\t\t\t\tif( c[i] ==  pair<char,char>(x+1,y) ) flag = false;\n\t\t\tint tmp = (tail * 5 + 1) % p5[6];\n\t\t\tans = max( ans , dfs(x+1,y,k,tmp)+flag*(field[y][x+1]-'0') );\n\t\t}\n\t}\n\t//cout << x << \" \" << y << \" \" << k << \" \" << ans << endl;\n\treturn dp[x][y][k][tail]=ans;\n\t\n}\nint main(){\n\tp5[0] = 1;\n\tfor(int i = 1 ; i < 10 ; i++) p5[i] = p5[i-1] * 5;\n\tmemset(dp,-1,sizeof(dp));\n\tcin >> H >> W >> K;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tcin >> field[i][j];\n\t\t\tif( field[i][j] == '.' ) field[i][j] = '0';\n\t\t}\n\t}\n\tcout << dfs(0,0,K,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tEast,\n\tSouth,\n\tWest,\n\tNorth,\n};\n\nint H,W,K;\nint POW[7];\nint dp[50][50][4][7][1024]; //dp[row][col][Kの残数][moved_count][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint makeCode(Type move_log[6]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < 6; i++){\n\t\tret += move_log[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\nbool is_num(int row,int col){\n\treturn base_map[row][col] >= '1' && base_map[row][col] <= '9'; //0の土産物屋はない\n}\n\nvoid recursive(int row,int col,int back_count,Type move_log[6],int moved_count,int sum){ //moved_log[]:インデックスが小さいほど新しい(右シフト)\n\n\tint tmp_code = makeCode(move_log);\n\tif(dp[row][col][back_count][min(6,moved_count)][tmp_code] >= sum)return; //過去最大値以下ならreturn\n\tdp[row][col][back_count][min(6,moved_count)][tmp_code] = sum;\n\n\tType next_move_log[4][6];\n\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t//過去の移動ログから、訪問済のマス情報を特定する\n\tint tmp_row = row,tmp_col = col;\n\n\tfor(int i = 0; i < min(moved_count,6); i++){\n\t\tswitch(move_log[i]){ //ログを打ち消す方向に動く\n\t\tcase East:\n\t\t\ttmp_col--;\n\t\t\tbreak;\n\t\tcase South:\n\t\t\ttmp_row--;\n\t\t\tbreak;\n\t\tcase West:\n\t\t\ttmp_col++;\n\t\t\tbreak;\n\t\tcase North:\n\t\t\ttmp_row++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(tmp_row == row && tmp_col == col+1){ //右のマスと一致\n\t\t\tvisited_E = true;\n\t\t}else if(tmp_row == row+1 && tmp_col == col){ //下のマスと一致\n\t\t\tvisited_S = true;\n\t\t}else if(tmp_row == row && tmp_col == col-1){ //左のマスと一致\n\t\t\tvisited_W = true;\n\t\t}else if(tmp_row == row-1 && tmp_col == col){ //上のマスと一致\n\t\t\tvisited_N = true;\n\t\t}\n\t}\n\n\t//次の移動ログを作る\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int k = 0; k < 5; k++){\n\t\t\tnext_move_log[i][k+1] = move_log[k]; //右に1つシフト\n\t\t}\n\t\tswitch(i){\n\t\tcase 0:\n\t\t\tnext_move_log[i][0] = East;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnext_move_log[i][0] = South;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnext_move_log[i][0] = West;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tnext_move_log[i][0] = North;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//右へ\n\tif(rangeCheck(row,col+1) == true && base_map[row][col+1] != '#'){\n\t\tif(visited_E == false && is_num(row,col+1) == true){\n\t\t\tresult_E += base_map[row][col+1]-'0';\n\t\t}\n\t\trecursive(row,col+1,back_count,next_move_log[East],moved_count+1,sum+result_E);\n\t}\n\n\t//下へ\n\tif(rangeCheck(row+1,col) == true && base_map[row+1][col] != '#'){\n\t\tif(visited_S == false && is_num(row+1,col) == true){\n\t\t\tresult_S += base_map[row+1][col]-'0';\n\t\t}\n\t\trecursive(row+1,col,back_count,next_move_log[South],moved_count+1,sum+result_S);\n\t}\n\n\tif(back_count == K){ //もう左にも上にも移動できない場合\n\n\t\treturn;\n\t}\n\n\t//左へ\n\tif(rangeCheck(row,col-1) == true && base_map[row][col-1] != '#'){\n\t\tif(visited_W == false && is_num(row,col-1) == true){\n\t\t\tresult_W += base_map[row][col-1]-'0';\n\t\t}\n\t\trecursive(row,col-1,back_count+1,next_move_log[West],moved_count+1,sum+result_W);\n\t}\n\n\t//上へ\n\tif(rangeCheck(row-1,col) == true && base_map[row-1][col] != '#'){\n\t\tif(visited_N == false && is_num(row-1,col) == true){\n\t\t\tresult_N += base_map[row-1][col]-'0';\n\t\t}\n\t\trecursive(row-1,col,back_count+1,next_move_log[North],moved_count+1,sum+result_N);\n\t}\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++)POW[i] = pow(4,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= K; i++){\n\t\t\t\tfor(int count = 0; count <= 6; count++){\n\t\t\t\t\tfor(int state = 0; state < POW[6]; state++)dp[row][col][i][count][state] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tType first_log[6];\n\tfor(int i = 0; i < 6; i++)first_log[i] = East;\n\n\trecursive(0,0,0,first_log,0,0);\n\n\tint ans = 0;\n\tfor(int state = 0; state < POW[6]; state++){\n\t\tfor(int count = 4; count <= 6; count++){\n\t\t\tans = max(ans,dp[H-1][W-1][K][count][state]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\n\nclass Data\n{\npublic:\n    int y, x, b;\n    vector<int> history;\n    Data(int y0, int x0, int b0, int k)\n    {\n        y = y0;\n        x = x0;\n        b = b0;\n        history.clear();\n        for(int i=0; i<5; ++i){\n            history.push_back(k % 4);\n            k /= 4;\n        }\n    }\n    bool move(int d)\n    {\n        int y2 = y;\n        int x2 = x;\n        y += dy[d];\n        x += dx[d];\n        b -= d / 2;\n\n        bool ret = false;\n        for(int i=4; i>=0; --i){\n            y2 -= dy[history[i]];\n            x2 -= dx[history[i]];\n            if(y2 == y && x2 == x)\n                ret = true;\n        }\n\n        history.erase(history.begin());\n        history.push_back(d);\n\n        return ret;\n    }\n    int toInt(){\n        int ret = 0;\n        for(int i=4; i>=0; --i){\n            ret *= 4;\n            ret += history[i];\n        }\n        return y + 50 * (x + 50 * (b + 4 * ret));\n    }\n};\n\nint main()\n{\n    int h, w, n;\n    cin >> h >> w >> n;\n\n    vector<string> s(h);\n    for(int i=0; i<h; ++i)\n        cin >> s[i];\n\n    vector<int> dp(50*50*4*1024, -1);\n    dp[Data(0, 0, n, 0).toInt()] = 0;\n\n    for(int b=n; b>=0; --b){\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int k=0; k<1024; ++k){\n                    Data d(y, x, b, k);\n                    int from = d.toInt();\n                    if(dp[from] == -1)\n                        continue;\n\n                    for(int i=0; i<4; ++i){\n                        Data d2 = d;\n                        bool use = d2.move(i);\n                        if(d2.y < 0 || d2.y >= h || d2.x < 0 || d2.x >= w || s[d2.y][d2.x] == '#' || d2.b < 0)\n                            continue;\n\n                        int next = dp[from];\n                        if(!use && isdigit(s[d2.y][d2.x]))\n                            next += s[d2.y][d2.x] - '0';\n\n                        int to = d2.toInt();\n                        dp[to] = max(dp[to], next);\n                    }\n                }\n            }\n        }\n    }\n\n    int ret = 0;\n    for(int i=0; i<=n; ++i){\n        for(int j=0; j<1024; ++j){\n            ret = max(ret, dp[Data(h-1, w-1, i, j).toInt()]);\n        }\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\nint h,w,K;\nstring str;\nint fie[100][100];\nmap<int,short> dp[51][51][4];\nmap<int,bool> check[51][51][4];\nint res=0;\n\nshort dfs(int x,int y,int k,int bit,int pc){\n\tint nx=x,ny=y;\n\tif(check[x][y][k][bit])return dp[x][y][k][bit];\n\t\n\t//11nx++,10nx--,01ny++,00ny--;\n\tint nbit=bit;\n\tif(nbit >>11 & 1)nbit-=1<<11;\n\tif(nbit >>10 & 1)nbit-=1<<10;\n\tnbit<<=2;\n\tshort r=-20000;\n\tif(k>=1){\n\t\tnbit+=2;\n\t\tx--;\n\t\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\t\tr=max(r,dfs(x,y,k-1,nbit,pc+1));\n\t\t}\n\t\tx++;\n\t\ty--;\n\t\tnbit-=2;\n\t\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\t\tr=max(r,dfs(x,y,k-1,nbit,pc+1));\n\t\t}\n\t\ty++;\n\t}\n\tnbit+=3;\n\tx++;\n\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\tr=max(r,dfs(x,y,k,nbit,pc+1));\n\t}\n\tx--;\n\tnbit-=2;\n\ty++;\n\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\tr=max(r,dfs(x,y,k,nbit,pc+1));\n\t}\n\ty--;\n\t\n\tint sum=0;\n\tbool f=false;\n\tfor(int i=0;i<min(pc,6);i++){\n\t\tif(bit >>i*2 & 1){\n\t\t\tif(bit >>(i*2+1) & 1)nx--;\n\t\t\telse ny--;\n\t\t}else{\n\t\t\tif(bit >>(i*2+1) & 1)nx++;\n\t\t\telse ny++;\n\t\t}\n\t\tif(nx==x && ny==y){\n\t\t\tf=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f)sum+=fie[x][y];\n\t\n\tif(r<0 && x==w-1 && y==h-1)r=0;\n\tcheck[x][y][k][bit]=true;\n\treturn (dp[x][y][k][bit]=sum+r);\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&h,&w,&K);\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=0;i<h;i++){\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]=='.')fie[j][i]=0;\n\t\t\telse if(str[j]=='#')fie[j][i]=-1;\n\t\t\telse fie[j][i]=str[j]-'0';\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dfs(0,0,K,0,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 0x7fffffff\n\ntypedef pair<int, int> Coor;\n\nint h, w, k;\nchar field[50][50];\nmap<vector<Coor>, int> dp[50][50][4]; // dp[y][x][left][where]\n\nint dfs(int x, int y, int k, const vector<Coor> &v) {\n    int dx[] = {0, 1};\n    int dy[] = {1, 0};\n    int kdx[] = {0, -1};\n    int kdy[] = {-1, 0};\n    vector<Coor> v2;\n    int ans = -INF;\n    if (x == w-1 && y == h-1) ans = 0; \n\n    for (int i=0; i<v.size(); i++) {\n        v2.push_back(v[i]);\n    }\n    sort(v2.begin(), v2.end());\n\n    if (dp[x][y][k].find(v) != dp[x][y][k].end()) return dp[x][y][k][v];\n\n    for (int t=0; t<2; t++) {\n        int newx = x + dx[t];\n        int newy = y + dy[t];\n        int add = 0;\n\n        if (newx < 0 || w <= newx || newy < 0 || h <= newy) continue;\n        if (field[newy][newx] == '#') continue;\n        if ('1' <= field[newy][newx] && field[newy][newx] <= '9') {\n            if (binary_search(v2.begin(), v2.end(), Coor(newx, newy)) == false) {\n                add = field[newy][newx] - '0';\n                v2.push_back(Coor(newx, newy));\n            }\n        }\n\n        ans = max(ans, dfs(newx, newy, k, v2) + add);\n    }\n\n    for (int t=0; t<2; t++) {\n        int newx = x + kdx[t];\n        int newy = y + kdy[t];\n        int add = 0;\n\n        if (newx < 0 || w <= newx || newy < 0 || h <= newy || k == 0) continue;\n        if (field[newy][newx] == '#') continue;\n        if ('1' <= field[newy][newx] && field[newy][newx] <= '9') {\n            if (binary_search(v2.begin(), v2.end(), Coor(newx, newy)) == false) {\n                add = field[newy][newx] - '0';\n                v2.push_back(Coor(newx, newy));\n            }\n        }\n\n        ans = max(ans, dfs(newx, newy, k-1, v2) + add);\n    }\n\n    return dp[x][y][k][v] = ans;\n}\n\nint main() {\n    vector<Coor> v;\n\n    scanf(\"%d %d %d\", &h, &w, &k);\n    for (int i=0; i<h; i++) {\n        for (int j=0; j<w; j++) {\n            scanf(\" %c\", &field[i][j]);\n        }\n    }\n\n    printf(\"%d\\n\", dfs(0, 0, k, v));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,K;\nint fld[50][50];\nint memo[50][50][4][1<<12];\nconst int dy[]={0,1,-1,0};\nconst int dx[]={1,0,0,-1};\nbool out(int y,int x){\n    return y<0||y>=H||x<0||x>=W;\n}\n\nint dfs(int y,int x,int cnt,int S){\n    if(memo[y][x][cnt][S]!=-1)return memo[y][x][cnt][S];\n    memo[y][x][cnt][S]=0;\n    int ret=0;\n    int ty=y,tx=x;\n    bool flag=true;\n    for(int i=0;i<6;i++){\n        int cur=(S>>(i*2))&3;\n        ty-=dy[cur];\n        tx-=dx[cur];\n        if(ty==y&&tx==x)flag=false;\n    }\n\n    for(int i=0;i<4;i++){\n        if(i>=2&&cnt>=K)continue;\n        ty=y+dy[i];\n        tx=x+dx[i];\n        if(out(ty,tx))continue;\n        if(fld[ty][tx]==-1)continue;\n        int tS=(S<<2)%(1<<(K*4));\n        ret=max(ret,dfs(ty,tx,cnt+(i>=2?1:0),tS|i));\n    }\n\n    if(flag)ret+=fld[y][x];\n    return memo[y][x][cnt][S]=ret;\n}\nint main(){\n    scanf(\"%d%d%d\",&H,&W,&K);\n    for(int i=0;i<H;i++){\n        char str[50];\n        scanf(\"%s\",str);\n        for(int j=0;j<W;j++){\n            int val;\n            if(str[j]=='#')val=-1;\n            else if(str[j]=='.')val=0;\n            else val=str[j]-'0';\n            fld[i][j]=val;\n        }\n    }\n    fill_n(***memo,50*50*4*(1<<12),-1);\n    printf(\"%d\\n\",dfs(0,0,0,0));\n\n    return 0;\n    int ma=0;\n    for(int i=0;i<=K;i++){\n        for(int j=0;j<(1<<(K*2));j++){\n            ma=max(ma,memo[H-1][W-1][i][j]);\n        }\n    }\n    printf(\"%d\\n\",ma);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1}; //00右,01下,10左,11上\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint h,w,k,mask,memo[50][50][4][1<<12];\nchar fld[50][50];\n\nbool Check(int y,int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w&&fld[y][x]!='#';\n}\n\nint Max(int y,int x,int c,int bit){\n\tint &res=memo[y][x][c][bit];\n\tif(res!=-1) return res;\n\tif(y==h-1&&x==w-1&&c==0) return res=0;\n\n\tbool done=false;\n\tint py=y,px=x;\n\trep(i,0,2*k){\n\t\tpy-=dy[(bit>>(i*2))&3];\n\t\tpx-=dx[(bit>>(i*2))&3];\n\t\tif(y==py&&x==px){\n\t\t\tdone=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint gift=0;\n\tif(!done&&fld[y][x]!='.') gift=fld[y][x]-'0';\n\n\tres=-INF;\n\trep(i,0,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(!Check(ny,nx)) continue;\n\t\tif(i<2){\n\t\t\tres=max(res,Max(ny,nx,c,((bit<<2)|i)&mask)+gift);\n\t\t}else if(c>=1){\n\t\t\tres=max(res,Max(ny,nx,c-1,((bit<<2)|i)&mask)+gift);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid Solve(){\n\tfill_n((int*)memo,50*50*4*(1<<12),-1);\n\tcin >> h >> w >> k;\n\tmask=(1<<(4*k))-1;\n\trep(i,0,h) rep(j,0,w) cin >> fld[i][j];\n\n\tcout << Max(0,0,k,0) << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nchar a[50][50];\nint dp[50][50][4][1<<11];\nbool visited[50][50][4][1<<11];\nint bitMap[4][1<<11][4];\nbool canGet[4][1<<11][4];\nvector<pii> needCells[4];\n\nconst int dy[4] = {0,1,0,-1};\nconst int dx[4] = {1,0,-1,0};\n\nint h,w,K;\n\nint solve(int y, int x, int k, int S){\n  int &r = dp[y][x][k][S];\n  if (visited[y][x][k][S]) return r;\n  visited[y][x][k][S] = 1;\n  int res = -INF;\n  if (y==h-1&&x==w-1) res = 0;\n  REP(d,4) {\n    int nk = k+(d>=2);\n    if (nk>K) continue;\n    int ny = y+dy[d];\n    int nx = x+dx[d];\n    if (!valid(ny,nx,h,w)) continue;\n    if (a[ny][nx] == '#') continue;\n    int score = canGet[k][S][d]&&isdigit(a[ny][nx]) ? a[ny][nx]-'0' : 0;\n    chmax(res, solve(ny,nx,nk,bitMap[k][S][d]) + score);\n  }\n  return r = res;\n}\n\nint main() {\n  REP(k,4) {\n    for (int y=-3; y<=3; ++y) {\n      for (int x=-3; x<=3; ++x) {\n        if ((y||x) && -min(y,0)-min(x,0) <= 3-k && max(0,y)+max(0,x) <= k)\n          needCells[k].push_back(pii(y,x));\n      }\n    }\n  }\n  REP(k,4) {\n    int n = needCells[k].size();\n    REP(S,1<<n) {\n      REP(d,4) {\n        int nk = k+(d>=2);\n        if (nk == 4) continue;\n        int T = 0;\n        REP(i,n) {\n          if (S>>i&1) {\n            pii p = needCells[k][i];\n            p.first -= dy[d];\n            p.second -= dx[d];\n            REP(j,needCells[nk].size()) {\n              if (needCells[nk][j] == p) {\n                T |= 1 << j;\n              }\n            }\n          }\n        }\n        REP(j,needCells[nk].size()) {\n          if (needCells[nk][j] == pii(-dy[d],-dx[d])) {\n            T |= 1 << j;\n          }\n        }\n        bitMap[k][S][d] = T;\n\n        canGet[k][S][d] = 1;\n        REP(i,n)\n          if (S>>i&1 && needCells[k][i]==pii(dy[d],dx[d]))\n            canGet[k][S][d] = 0;\n      }\n    }\n  }\n  while(cin>>h>>w>>K) {\n    REP(i,h) REP(j,w) cin >> a[i][j];\n    cout << solve(0,0,0,0) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[5][50][50][1 << 12];\nint H, W, K;\nchar mas[50][50];\nint dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint mask;\n\nint getdir(int bit, int i){\n  return bit >> (i << 1) & 3;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  mask = (1 << (K * 2 * 2)) - 1;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      cin >> mas[i][j];\n    }\n  }\n  for(int mul = K ; mul >= 0; mul--){\n    for(int bit = 0; bit < 1 << (K * 2 * 2) ; bit++){ // 前の街\n      for(int y = 0; y < H; y++){\n        for(int x = 0; x < W; x++){\n\n          int my = y, mx = x, cost = 0;\n          bool flag = false;\n          if(mas[y][x] != '.'){\n            for(int i = 0; i < 2 * K; i++){\n              my -= dy[getdir( bit, i)];\n              mx -= dx[getdir( bit, i)];\n              if(my == y && mx == x){\n                flag = true;\n                break;\n              }\n            }\n            if(!flag) cost = mas[y][x] - '0';\n          }\n          \n          for(int i = 0; i < 4; i++){\n            int ny = y + dy[i], nx = x + dx[i];\n            if(ny < 0 || ny >= H || nx < 0 || nx >= W || mas[ny][nx] == '#') continue;\n            if(mul == 0 && i >= 2) break;\n\n            int& next = dp[mul - (i >= 2)][ny][nx][(bit << 2 | i) & mask];\n\n            next = max( next, dp[mul][y][x][bit] + cost);\n          }\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < 1 << (4 * K) ; i++){\n    ret = max( ret, dp[0][H - 1][W - 1][i]);\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#define INF -(1 << 23)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint main()\n{\n\tint H, W, K;\n\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &K);\n\n\tvector<string> M(H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tcin >> M[i];\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (M[i][j] == '.')\n\t\t\t{\n\t\t\t\tM[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<vector<vector<int> > > > dp(H, vector<vector<vector<int> > >(W, vector<vector<int> >(K + 1, vector<int>(64, INF))));\n\n\tdp[0][0][0][0] = 0;\n\n\tfor (int rep = 0; rep <= K; rep++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= K; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < 64; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint dir = l % 4;\n\n\t\t\t\t\t\t\tint p3 = l / 16;\n\t\t\t\t\t\t\tint p2 = (l / 4) % 4;\n\t\t\t\t\t\t\tint p1 = l % 4;\n\n\t\t\t\t\t\t\tint px1 = j + dx[p1];\n\t\t\t\t\t\t\tint px2 = px1 + dx[p2];\n\t\t\t\t\t\t\tint px3 = px2 + dx[p3];\n\t\t\t\t\t\t\tint py1 = i + dy[p1];\n\t\t\t\t\t\t\tint py2 = py1 + dy[p2];\n\t\t\t\t\t\t\tint py3 = py2 + dy[p3];\n\n\t\t\t\t\t\t\tbool ok1 = true, ok2 = true, ok3 = true;\n\n\t\t\t\t\t\t\tif (0 <= px1 && px1 < W && 0 <= py1 && py1 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py1][px1] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok1 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px2 && px2 < W && 0 <= py2 && py2 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py2][px2] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px3 && px3 < W && 0 <= py3 && py3 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py3][px3] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok3 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!((j == px1 && i == py1 && !ok1) || (j == px2 && i == py2 && !ok2) || (j == px3 && i == py3 && !ok3)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ((0 <= j + dx[dir] && j + dx[dir] < W && 0 <= i + dy[dir] && i + dy[dir] < H) && !((dir % 3) && k == 0))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tint r = m * 16 + l / 4;\n\n\t\t\t\t\t\t\t\t\t\tif (dir % 3)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k - 1][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = -1;\n\n\tfor (int i = 0; i <= K; i++)\n\t{\n\t\tfor (int j = 0; j < 64; j++)\n\t\t{\n\t\t\tret = max(ret, dp[H - 1][W - 1][i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define chmax(a,b) (a = max(a,b))\nusing namespace std;\n\nconst int dy[] = {0,1,0,-1}, dx[] = {1,0,-1,0};\nint dp[50][50][4][1<<12];\nint vis[1<<12];\n\ninline int visit(int bit){\n  if(vis[bit]>=0)return vis[bit];\n\n  int y=0, x=0, b=bit;\n  rep(i,6){\n    y += dy[b&3], x += dx[b&3]; b>>=2;\n    if(y==0 && x==0)return vis[bit] = 1;\n  }\n  return vis[bit] = 0;\n}\n\nint main(){\n  int h,w,k;\n  string g[50];\n  cin >> h >> w >> k;\n  rep(i,h)cin >> g[i];\n\n  memset(vis,-1,sizeof(vis));\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0][0] = isdigit(g[0][0])?(int)(g[0][0]-'0'):0;\n\n  rep(rev,k+1){\n    rep(y,h)rep(x,w){\n      if(g[y][x] == '#')continue;\n      rep(bit,1<<12){\n\tif(dp[y][x][rev][bit]<0)continue;\n\n\trep(d,4){\n\t  if(rev==k && d>1)break;\n\t  int ny = y+dy[d], nx = x+dx[d];\n\t  if(!range(ny,0,h) || !range(nx,0,w))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  int nbit = ((bit<<2)|d) & ((1<<12)-1);\n\t  int item = isdigit(g[ny][nx])?(int)(g[ny][nx]-'0'):0;\n\t  if(visit(nbit))item = 0;\n\n\t  if(d<2){\n\t    chmax(dp[ny][nx][rev][nbit], dp[y][x][rev][bit] + item);\n\t  }else{\n\t    chmax(dp[ny][nx][rev+1][nbit], dp[y][x][rev][bit] + item);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = 0;\n  rep(bit,1<<12)chmax(res, dp[h-1][w-1][k][bit]);\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#define INF -(1 << 23)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint main()\n{\n\tint H, W, K;\n\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &K);\n\n\tvector<string> M(H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tcin >> M[i];\n\t}\n\n\tvector<vector<vector<vector<int> > > > dp(H, vector<vector<vector<int> > >(W, vector<vector<int> >(K + 1, vector<int>(64, INF))));\n\n\tdp[0][0][0][0] = 0;\n\n\tfor (int rep = 0; rep < K; rep++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= K; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < 64; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint dir = l % 4;\n\n\t\t\t\t\t\t\tif ((0 <= j + dx[dir] && j + dx[dir] < W && 0 <= i + dy[dir] && i + dy[dir] < H) && (!(dir % 3) && K != 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint r = m * 16 - l / 4;\n\n\t\t\t\t\t\t\t\t\tif (dir % 3)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k][r]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k - 1][r]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = -1;\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tfor (int j = 0; j < 64; j++)\n\t\t{\n\t\t\tret = max(ret, dp[H - 1][W - 1][i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1}; //00右,01下,10左,11上\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nconst int mask=(1<<12)-1;\nint h,w,k,memo[50][50][4][1<<12];\nchar fld[50][50];\n\nbool Check(int y,int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w&&fld[y][x]!='#';\n}\n\nint Max(int y,int x,int c,int bit){\n\tint &res=memo[y][x][c][bit];\n\tif(res!=-1) return res;\n\tif(y==h-1&&x==w-1&&c==0) return res=0;\n\n\tbool done=false;\n\tint py=y,px=x;\n\trep(i,0,6){\n\t\tpy-=dy[(bit>>(i*2))&3];\n\t\tpx-=dx[(bit>>(i*2))&3];\n\t\tif(y==py&&x==px){\n\t\t\tdone=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint gift=0;\n\tif(!done&&fld[y][x]!='.') gift=fld[y][x]-'0';\n\n\tres=-INF;\n\trep(i,0,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(!Check(ny,nx)) continue;\n\t\tif(i<2){\n\t\t\tres=max(res,Max(ny,nx,c,((bit<<2)&mask)|i)+gift);\n\t\t}else if(c>=1){\n\t\t\tres=max(res,Max(ny,nx,c-1,((bit<<2)&mask)|i)+gift);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid Solve(){\n\tfill_n((int*)memo,50*50*4*(1<<12),-1);\n\tcin >> h >> w >> k;\n\trep(i,0,h) rep(j,0,w) cin >> fld[i][j];\n\n\tcout << Max(0,0,k,0) << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nint H,W;\nchar c[50][50];\nmap<vector<pair<int,int> >,int> dp[50][50][3];\nint dfs(int x,int y,int k,vector<pair<int,int> > vis){\n\tif( k < 0 ) return -1e9;\n\tvector< pair<int,int> > p;\n\tfor(int i = 0 ; i < vis.size() ; i++){\n\t\tif( max(0,x-vis[i].first)+max(0,y-vis[i].second) <= k )\n\t\t\tp.push_back(vis[i]);\n\t}\n\tsort(p.begin(),p.end());\n\tvis = p;\n\tif( dp[x][y][k].count(vis) ) return dp[x][y][k][vis];\n\t\n\tint ans = ( x==W-1&&y==H-1 ? 0 : -1e9 );\n\tfor(int i = 0 ;i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( tx < 0 || tx >= W || ty < 0 || ty >= H || c[ty][tx] == '#') continue;\n\t\tint cst = 0;\n\t\tvector<pair<int,int> > t = vis;\n\t\tif( !binary_search(vis.begin(),vis.end(),make_pair(tx,ty)) ){\n\t\t\tcst = c[ty][tx] - '0';\n\t\t\tt.push_back(make_pair(tx,ty));\n\t\t}\n\t\tans = max( ans , dfs(tx,ty,k-(i<2),t)+cst );\n\t}\n\t//cout << x << \" \" << y << \" \" << k << \" \" << vis.size() << endl;\n\treturn dp[x][y][k][vis] = ans;\n}\nint main(){\n\tint K;\n\tcin >> H >> W >> K;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tcin >> c[i][j];\n\t\t\tif( c[i][j] == '.' ) c[i][j] = '0';\n\t\t}\n\t}\n\tcout << dfs(0,0,K,vector<pair<int,int> >(0)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct State{\n    int y, x, mask, b;\n};\n\nconst int dx[4]={0,1,0,-1}, dy[4]={1,0,-1,0};\nchar f[60][51];\n\nint dp[60][50][1<<12][4]={};\nint vis[60][50]={};\n\nint main()\n{\n    int H,W,K;\n    cin >>H >>W >>K;\n\n    memset(dp,-1,sizeof(dp));\n    rep(i,6)\n    {\n        f[i][0]='.';\n        for(int j=1; j<W; ++j) f[i][j]='#';\n    }\n    rep(i,H) scanf(\"%s\", f[i+6]);\n    H+=6;\n\n    #define IN(y,x) (0<=y && y<H && 0<=x && x<W)\n    queue<State> que;\n    que.push({6,0,0,0});\n    dp[6][0][0][0]=0;\n    while(!que.empty())\n    {\n        State s = que.front();\n        que.pop();\n\n        int d[6];\n        rep(i,6) d[i] = (s.mask>>(2*i))&3;\n\n        int px[7],py[7];\n        px[0] = s.x;\n        py[0] = s.y;\n        rep(i,6)\n        {\n            px[i+1] = px[i] - dx[d[i]];\n            py[i+1] = py[i] - dy[d[i]];\n        }\n        rep(i,7) vis[py[i]][px[i]]=1;\n\n        rep(i,4)\n        {\n            int nx = s.x+dx[i], ny = s.y+dy[i];\n            int nb = s.b+(i>=2);\n            if(nb<=K && IN(ny,nx) && f[ny][nx]!='#')\n            {\n                int add=max(0,f[ny][nx]-'0');\n                if(vis[ny][nx]) add=0;\n\n                int nmask = ((s.mask<<2)&((1<<12)-1)) + i;\n                if(dp[ny][nx][nmask][nb] < dp[s.y][s.x][s.mask][s.b] + add)\n                {\n                    dp[ny][nx][nmask][nb] = dp[s.y][s.x][s.mask][s.b] + add;\n                    que.push({ny,nx,nmask,nb});\n                }\n            }\n        }\n\n        rep(i,7) vis[py[i]][px[i]]=0;\n    }\n\n    int ans=0;\n    rep(M,1<<12)rep(B,4) ans=max(ans,dp[H-1][W-1][M][B]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n#define RPA(i,s,e) for(int i=s; i<=e; i++)\n#define RPD(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n#define SZ(a) (int)(a).size()\n#define ALL(a) (a).begin(), (a).end()\n#define PRT(a) cout << (a) << endl\n#define PRT2(a,b) cout << (a) << \" \" << (b) << endl\n#define PRT3(a,b,c) cout << (a) << \" \" << (b) << \" \" << (c) << endl\n\ntypedef vector<int> VI;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint h,w,k;\nstring ln;\nint field[51][51];\nint dp[51][51][4][4096];\nint trans[4096][4][4];\nint visit[4096][4][4];\nvector<P> pos[4];\n\nint dx[4] = {-1, 0, 0, 1};\nint dy[4] = {0, -1, 1, 0};\n\nvoid solve() {\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0][0][0][0] = 0;\n\tfor(int used=0; used<=k; used++) {\n\t\tfor(int y=0; y<h; y++) {\n\t\t\tfor(int x=0; x<w; x++) {\n\t\t\t\tfor(int mask=0; mask<(1<<11); mask++) {\n\t\t\t\t\tif(dp[x][y][used][mask] < 0) continue;\n\n\t\t\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\t\t\tint nk = (i < 2) ? used + 1 : used;\n\t\t\t\t\t\tif(nk > 3) continue;\n\n\t\t\t\t\t\tint next = dp[x][y][used][mask];\n\t\t\t\t\t\tint nmask = trans[mask][used][i];\n\t\t\t\t\t\tint nx = x + dx[i];\n\t\t\t\t\t\tint ny = y + dy[i];\n\t\t\t\t\t\tif(nx >= 0 && ny >= 0 && nx < w && ny < h && field[nx][ny] >= 0) {\n\t\t\t\t\t\t\tif(!visit[mask][used][i]) next += field[nx][ny];\n\t\t\t\t\t\t\tdp[nx][ny][nk][nmask] = max(dp[nx][ny][nk][nmask], next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = -1;\n\tfor(int used=0; used<=k; used++) {\n\t\tfor(int mask=0; mask<(1<<11); mask++) {\n\t\t\tans = max(ans, dp[w-1][h-1][used][mask]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nvoid prepare() {\n\tmemset(trans, 0, sizeof(trans));\n\tmemset(visit, 0, sizeof(visit));\n\n\tfor(int used=0; used<=3; used++) {\n\t\tfor(int y=-3; y<=3; y++) {\n\t\t\tfor(int x=-3; x<=3; x++) {\n\t\t\t\tif(x == 0 && y == 0) continue;\n\t\t\t\tint drop = max(0, x) + max(0, y);\n\t\t\t\tint back = max(-x, 0) + max(-y, 0);\n\t\t\t\tif(drop <= used && back <= (3 - used)) pos[used].push_back(P(x, y));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int mask=0; mask<(1<<11); mask++) {\n\t\tfor(int used=0; used<=3; used++) {\n\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\tint nk = (i < 2) ? used + 1 : used;\n\t\t\t\tif(nk > 3) continue;\n\n\t\t\t\tint& bit = trans[mask][used][i];\n\t\t\t\tfor(int y=-3; y<=3; y++) {\n\t\t\t\t\tfor(int x=-3; x<=3; x++) {\n\t\t\t\t\t\tint n1 = -1;\n\t\t\t\t\t\tint n2 = -1;\n\t\t\t\t\t\tint nx = x - dx[i];\n\t\t\t\t\t\tint ny = y - dy[i];\n\t\t\t\t\t\tfor(int j=0; j<pos[used].size(); j++) { // 前のマップでの場所の番号\n\t\t\t\t\t\t\tif(pos[used][j] == P(x, y)) n1 = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int j=0; j<pos[nk].size(); j++) { // 次のマップでの場所の番号\n\t\t\t\t\t\t\tif(pos[nk][j] == P(nx, ny)) n2 = j;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(n1 >= 0 && n2 >= 0) {\n\t\t\t\t\t\t\tif(mask & (1 << n1)) bit |= (1 << n2); \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint t = -1;\n\t\t\t\tfor(int j=0; j<pos[nk].size(); j++) {\n\t\t\t\t\tif(pos[nk][j] == P(-dx[i], -dy[i])) t = j;\n\t\t\t\t}\n\t\t\t\tif(t >= 0) {\n\t\t\t\t\tbit |= (1 << t);\n\t\t\t\t}\n\n\t\t\t\tfor(int j=0; j<pos[used].size(); j++) {\n\t\t\t\t\tif((mask & (1<<j)) && pos[used][j] == P(dx[i], dy[i])) {\n\t\t\t\t\t\tvisit[mask][used][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid coding() {\n\tprepare();\n\twhile(scanf(\"%d%d%d\", &h, &w, &k)!=EOF) {\n\t\tfor(int y=0; y<h; y++) {\n\t\t\tcin>>ln;\n\t\t\tfor(int x=0; x<w; x++) {\n\t\t\t\tif(ln[x] == '#') field[x][y] = -1;\n\t\t\t\tif(ln[x] == '.') field[x][y] = 0;\n\t\t\t\telse field[x][y] = ln[x] - '0';\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n}\n\n// #define _LOCAL_TEST\n\nint main() {\n#ifdef _LOCAL_TEST\n\tclock_t startTime = clock();\n\tfreopen(\"a.in\", \"r\", stdin);\n#endif\n\n\tcoding();\n\n#ifdef _LOCAL_TEST\n\tclock_t elapsedTime = clock() - startTime;\n\tcout << endl;\n\tcout << (elapsedTime / 1000.0) << \" sec elapsed.\" << endl;\n\tcout << \"This is local test\" << endl;\n\tcout << \"Do not forget to comment out _LOCAL_TEST\" << endl << endl;\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\ntypedef pair<int, int> Point;\n\nint H, W, K;\nchar grid[64][64];\nvector<Point> rem[4];\nint vis[64][64];\nint dp[50][50][4][1 << 12];\n\nvoid init()\n{\n\tmemset(grid, '#', sizeof(grid));\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tfor (int k = 0; k <= 3; k++){\n\t\tfor (int x = -k; x <= (3 - k); x++){\n\t\t\tfor (int y = -k; y <= (3 - k); y++){\n\t\t\t\t//if (x == 0 && y == 0) continue;\n\t\t\t\tif (-k <= (x + y) && (x + y) <= (3 - k)){\n\t\t\t\t\trem[k].push_back(Point(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int calcBit(int x, int y, int k)\n{\n\tint res = 0;\n\tfor (Point &p : rem[k]){\n\t\tres <<= 1;\n\t\tint X = x + p.first;\n\t\tint Y = y + p.second;\n\t\tif (vis[X][Y] > 0) res |= 1;\n\t}\n\treturn res;\n}\n\nint calc(int x, int y, int k)\n{\n\tint bit = calcBit(x, y, k);\n\tint &res = dp[x - 3][y - 3][k][bit];\n\tif (~res) return res;\n\t\n\tint add = 0;\n\tif (grid[x][y] >= '1' && grid[x][y] <= '9'){\n\t\tif (vis[x][y] == 0){\n\t\t\tadd = grid[x][y] - '0';\n\t\t}\n\t}\n\t\n\tif (x == H + 2 && y == W + 2 && k == 0){\n\t\treturn res = add;\n\t}\n\t\n\tres = -INF;\n\t\n\tvis[x][y]++;\n\tfor (int dir = 0; dir < 4; dir++){\n\t\tint nx = x + dx[dir];\n\t\tint ny = y + dy[dir];\n\t\tint nk = k - (dir < 2);\n\t\tif (grid[nx][ny] == '#') continue;\n\t\tif (nk < 0) continue;\n\t\tres = max(res, calc(nx, ny, nk));\n\t}\n\tvis[x][y]--;\n\t\n\treturn res += add;\n}\n\nint main(void)\n{\n\tinit();\n\t\n\tscanf(\"%d %d %d\", &H, &W, &K);\n\t\n\tfor (int i = 0; i < H; i++){\n\t\tfor (int j = 0; j < W; j++){\n\t\t\tscanf(\" %c\", &grid[i + 3][j + 3]);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", calc(3, 3, K));\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#ifdef __GNUC__\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#endif\n\n#ifdef MSC_VER\n#pragma comment(linker, \"/STACK:400000000\")\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#endif\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n#define vc vector\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\n\nint H,W,K;\nchar c[55][55];\nint dp[55][55][4][1<<12];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nint f(int y,int x,int k,int mask){\n\tint& res=dp[y][x][k][mask];\n\tif(res!=-1)return res;\n\tif(y==H && x==W && k==0)return res=0;\n\tres=0;\n\tif(isdigit(c[y][x])){\n\t\tint Y=y,X=x,d;\n\t\trep(i,2*K){\n\t\t\td=mask>>(2*i)&3;\n\t\t\tY-=dy[d],X-=dx[d];\n\t\t\tif(Y==y && X==x)goto fail;\n\t\t}\n\t\tres=c[y][x]-'0';\n\t\tfail:;\n\t}\n\t\n\tint res2=-INF,ny,nx;\n\trep(d,2){\n\t\tny=y+dy[d],nx=x+dx[d];\n\t\tif(c[ny][nx]!='#'){\n\t\t\tres2=max(res2,f(ny,nx,k,(mask<<2 | d)  & ((1<<4*K)-1)));\n\t\t}\n\t}\n\tif(k)rep2(d,2,4){\n\t\tny=y+dy[d],nx=x+dx[d];\n\t\tif(c[ny][nx]!='#'){\n\t\t\tres2=max(res2,f(ny,nx,k-1,(mask<<2 | d)  & ((1<<4*K)-1)));\n\t\t}\n\t}\n\treturn res+=res2;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>H>>W>>K;\n\trep(i,H+2)rep(j,W+2)c[i][j]='#';\n\trep2(i,1,H+1)rep2(j,1,W+1)cin>>c[i][j];\n\tmemset(dp,-1,sizeof(dp));\n\tcout<<f(1,1,K,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct T\n{\n  int x, y, k;\n  T(int _x, int _y, int _k, const vector<int>& _vis):\n    x(_x), y(_y), k(_k), vis(_vis) {}\n  vector<int> vis;\n  bool operator <(const T& rhs) const\n  {\n    return x < rhs.x && y < rhs.y && k < rhs.k && vis < rhs.vis;\n  }\n};\n\nint m[51][51];\nmap<T, int> dp;\nint H, W, K;\nint dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\n\nint dfs(T arg)\n{\n  if(dp.find(arg) != dp.end())\n    dp[arg];\n  int x = arg.x, y = arg.y, k = arg.k;\n  auto& vis = arg.vis;\n  int cnt = max(0, m[y][x]);\n  for(int i = 0; i < vis.size(); i += 2)\n  {\n    if(vis[i] == x && vis[i + 1] == y)\n    {\n      cnt = 0;\n      break;\n    }\n  }\n\n  vector<int> nv;\n  for(int i = vis.size() >= 4 * K ? 2: 0; i < vis.size(); i++)\n    nv.push_back(vis[i]);\n  nv.push_back(x);\n  nv.push_back(y);\n  int res = -100000000;\n  if(x == W - 1 && y == H - 1)\n    res = 0;\n  for(int i = 0; i < 4; i++)\n  {\n    int tx = x + dx[i], ty = y + dy[i];\n    if(!(tx >= 0 && tx < W && ty >= 0 && ty < H))\n      continue;\n    if(m[ty][tx] == -1)\n      continue;\n    int dk = (dx[i] < 0 || dy[i] < 0) ? 1 : 0;\n    if(k + dk > K)\n      continue;\n    res = max(res, dfs(T(tx, ty, k + dk, nv))); \n  }\n  return dp[arg] = res + cnt;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  for(int y = 0; y < H; y++)\n  {\n    for(int x = 0; x < W; x++)\n    {\n      char a;\n      cin >> a;\n      switch(a)\n      {\n        case '.':\n          m[y][x] = 0;\n          break;\n        case '#':\n          m[y][x] = -1;\n          break;\n        default:\n          m[y][x] = a - '0';\n          break;\n      }\n    }\n  }\n  cout << dfs(T(0, 0, 0, vector<int>())) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tEast,\n\tSouth,\n\tWest,\n\tNorth,\n};\n\nstruct Info{\n\tvoid set(int arg_row,int arg_col,int arg_back_count,int arg_moved_count,int arg_sum,int arg_move_log){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tback_count = arg_back_count;\n\t\tmoved_count = arg_moved_count;\n\t\tsum = arg_sum;\n\t\tmove_log = arg_move_log;\n\t}\n\tbool operator<(const struct Info &arg) const{ //総和の降順(PQ)\n\t\treturn sum < arg.sum;\n\t}\n\n\tint row,col,back_count,moved_count,sum,move_log;\n};\n\nint H,W,K;\nint POW[7];\nint dp[50][50][4][4096]; //dp[row][col][Kの残数][moved_count][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint makeCode(Type move_log[6]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < 6; i++){\n\t\tret += move_log[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\nbool is_num(int row,int col){\n\treturn base_map[row][col] >= '1' && base_map[row][col] <= '9'; //0の土産物屋はない\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++)POW[i] = pow(4,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= K; i++){\n\t\t\t\tfor(int state = 0; state < POW[6]; state++)dp[row][col][i][state] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tInfo first;\n\tfirst.set(0,0,0,0,0,0);\n\n\tdp[0][0][0][0] = 0;\n\n\tint bit_mask = 4095;\n\n\tQ.push(first);\n\n\tint log_array[6],tmp_log;\n\n\tInfo info;\n\twhile(!Q.empty()){\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tif(dp[info.row][info.col][info.back_count][info.move_log] > info.sum)continue;\n\n\t\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\t\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t\t//過去の移動ログから、訪問済のマス情報を特定する\n\t\tint tmp_row = info.row,tmp_col = info.col;\n\n\t\ttmp_log = info.move_log;\n\t\t//printf(\"tmp_log:%d\\n\",tmp_log);\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tlog_array[i] = tmp_log & 3;\n\t\t\t//printf(\"array[%d]:%d\\n\",i,log_array[i]);\n\t\t\ttmp_log /= 4;\n\t\t}\n\n\t\tfor(int i = 0; i < min(6,info.moved_count); i++){\n\t\t\tswitch(log_array[i]){ //ログを打ち消す方向に動く\n\t\t\tcase 0:\n\t\t\t\ttmp_col--;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttmp_row--;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttmp_col++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\ttmp_row++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp_row == info.row && tmp_col == info.col+1){ //右のマスと一致\n\t\t\t\tvisited_E = true;\n\t\t\t}else if(tmp_row == info.row+1 && tmp_col == info.col){ //下のマスと一致\n\t\t\t\tvisited_S = true;\n\t\t\t}else if(tmp_row == info.row && tmp_col == info.col-1){ //左のマスと一致\n\t\t\t\tvisited_W = true;\n\t\t\t}else if(tmp_row == info.row-1 && tmp_col == info.col){ //上のマスと一致\n\t\t\t\tvisited_N = true;\n\t\t\t}\n\t\t}\n\n\t\t//次の移動ログを作る\n\n\n\t\t//右へ\n\t\tif(rangeCheck(info.row,info.col+1) == true && base_map[info.row][info.col+1] != '#'){\n\t\t\tif(visited_E == false && is_num(info.row,info.col+1) == true){\n\t\t\t\tresult_E += base_map[info.row][info.col+1]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|0;\n\t\t\tif(dp[info.row][info.col+1][info.back_count][next_code] < info.sum+result_E){\n\t\t\t\tdp[info.row][info.col+1][info.back_count][next_code] = info.sum+result_E;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col+1,info.back_count,info.moved_count+1,info.sum+result_E,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//下へ\n\t\tif(rangeCheck(info.row+1,info.col) == true && base_map[info.row+1][info.col] != '#'){\n\t\t\tif(visited_S == false && is_num(info.row+1,info.col) == true){\n\t\t\t\tresult_S += base_map[info.row+1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|1;\n\t\t\tif(dp[info.row+1][info.col][info.back_count][next_code] < info.sum+result_S){\n\t\t\t\tdp[info.row+1][info.col][info.back_count][next_code] = info.sum+result_S;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row+1,info.col,info.back_count,info.moved_count+1,info.sum+result_S,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\tif(info.back_count == K)continue;\n\n\t\t//左へ\n\t\tif(rangeCheck(info.row,info.col-1) == true && base_map[info.row][info.col-1] != '#'){\n\t\t\tif(visited_W == false && is_num(info.row,info.col-1) == true){\n\t\t\t\tresult_W += base_map[info.row][info.col-1]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|2;\n\t\t\tif(dp[info.row][info.col-1][info.back_count][next_code] < info.sum+result_W){\n\t\t\t\tdp[info.row][info.col-1][info.back_count][next_code] = info.sum+result_W;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col-1,info.back_count+1,info.moved_count+1,info.sum+result_W,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//上へ\n\t\tif(rangeCheck(info.row-1,info.col) == true && base_map[info.row-1][info.col] != '#'){\n\t\t\tif(visited_N == false && is_num(info.row-1,info.col) == true){\n\t\t\t\tresult_N += base_map[info.row-1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|3;\n\t\t\tif(dp[info.row-1][info.col][info.back_count][next_code] < info.sum+result_N){\n\t\t\t\tdp[info.row-1][info.col][info.back_count][next_code] = info.sum+result_N;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row-1,info.col,info.back_count+1,info.moved_count+1,info.sum+result_N,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\tfor(int state = 0; state < POW[6]; state++){\n\t\tfor(int count = 4; count <= 6; count++){\n\t\t\tans = max(ans,dp[H-1][W-1][K][state]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nchar a[55][55];\nint memo[55][55][4][900];\nint h,w,k,m=0;\nint g(int x,int y,int s,int k){\n\tif(x==h && y==w && k==0)\n\t\treturn s;\n\n\tif(memo[x][y][s][k]>=0)\n\t\treturn memo[x][y][s][k];\n\n\tint res=0;\n\n\t\tif(x+1>=1 && y>=1 && x+1<=h && y<=w && a[x+1][y]!='#'){\n\t\t\tif(a[x+1][y]!='.'){\n\t\t\t\tchar c=a[x+1][y];\n\t\t\t\ta[x+1][y]='.';\n\t\t\t\tres=max(res,g(x+1,y,s+c-'0',k));\n\t\t\t\ta[x+1][y]=c;\n\t\t\t}\n\t\t\telse res=max(res,g(x+1,y,s,k));\n\t\t}\n\n\t\tif(x>=1 && y+1>=1 && x<=h && y+1<=w && a[x][y+1]!='#'){\n\t\t\tif(a[x][y+1]!='.'){\n\t\t\t\tchar c=a[x][y+1];\n\t\t\t\ta[x][y+1]='.';\n\t\t\t\tres=max(res,g(x,y+1,s+c-'0',k));\n\t\t\t\ta[x][y+1]=c;\n\t\t\t}\n\t\t\telse res=max(res,g(x,y+1,s,k));\n\t\t}\n\n\t\tif(x-1>=1 && y>=1  && x-1<=h && y<=w && k>0 && a[x-1][y]!='#'){\n\t\t\tif(a[x-1][y]!='.'){\n\t\t\t\tchar c=a[x-1][y];\n\t\t\t\ta[x-1][y]='.';\n\t\t\t\tres=max(res,g(x-1,y,s+c-'0',k-1));\n\t\t\t\ta[x-1][y]=c;\n\t\t\t}\n\t\t\telse res=max(res,g(x-1,y,s,k-1));\n\t\t}\n\n\t\tif(x>=1 && y-1>=1 && x<=h && y-1<=w && k>0 && a[x][y-1]!='#'){\n\t\t\tif(a[x][y-1]!='.'){\n\t\t\t\tchar c=a[x][y-1];\n\t\t\t\ta[x][y-1]='.';\n\t\t\t\tres=max(res,g(x,y-1,s+c-'0',k-1));\n\t\t\t\ta[x][y-1]=c;\n\t\t\t}\n\t\t\telse res=max(res,g(x,y-1,s,k-1));\n\t\t}\n\n\t\treturn memo[x][y][s][k]=res;\n}\n\nint main(){\n\n    memset(memo,-1,sizeof memo);\n\n\tcin >> h >> w >> k;\n\tREP(i,1,h){\n\tREP(j,1,w){\n\t\tcin >> a[i][j];\n\t}\n\t}\n\n\tcout << g(1,1,0,k) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  map<pii,int> m;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[pii(i+oy,j+ox)]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[pii(ny,nx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 全体のビット右にをシフト\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 下方向にビットをシフト\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nstruct Sit{\n  int cy,cx,mask,my,mx;\n  Sit(){}\n  Sit(int cy_,int cx_,int mask_,int my_,int mx_){\n    cy=cy_;\n    cx=cx_;\n    mask=mask_;\n    my=my_;\n    mx=mx_;\n  }\n  bool operator<(const Sit&sit)const{\n    return true;\n  }\n};\ntypedef pair<int,Sit> iSit;\n\nint dfs(int cy,int cx,int mask,int my,int mx){\n  if(dp[cy][cx][mask][my][mx]>=0)return dp[cy][cx][mask][my][mx];\n  int res=0;\n  int leftK=K-(my+mx);\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n      int nmask=p.first;\n      int nAddVal=p.second;\n      // cout<<nAddVal<<endl;\n      if(leftK>0&&(i==0||i==3))\n        res=max(res,dfs(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))+nAddVal);\n      else if((i==1||i==2))\n        res=max(res,dfs(ny,nx,nmask,my,mx)+nAddVal);\n    }\n  }\n  return dp[cy][cx][mask][my][mx]=res;\n}\n\nint dijkstra(){\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][1<<6][0][0]=0;\n  priority_queue<iSit> pq;\n  pq.push(make_pair(0,Sit(0,0,1<<6,0,0)));\n  while(pq.size()){\n    iSit is=pq.top();pq.pop();\n    int cval=is.first;\n    Sit cSit=is.second;\n    int cy=cSit.cy,cx=cSit.cx,mask=cSit.mask,my=cSit.my,mx=cSit.mx;\n    if(dp[cy][cx][mask][my][mx]>cval)continue;\n    int leftK=K-(my+mx);\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n        pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n        int nmask=p.first;\n        int nAddVal=p.second;\n        if(leftK>0&&(i==0||i==3)&&dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]<cval+nAddVal){\n          dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))));\n        }\n        else if((i==1||i==2)&&dp[ny][nx][nmask][my][mx]<cval+nAddVal){\n          dp[ny][nx][nmask][my][mx]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my,mx)));\n        }\n      }\n    }\n  }\n  int res=0;\n  for(int mask=0;mask<(1<<10);mask++)\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        res=max(res,dp[H-1][W-1][mask][i][j]);\n  return res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  memset(dp,-1,sizeof(dp));\n  assert(dfs(0,0,(1<<6),0,0)==dijkstra());\n  cout<<dfs(0,0,(1<<6),0,0)<<endl;\n  //cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\nint h,w,K;\nstring str;\nint fie[100][100];\nint dp[51][51][4][1<<12+1];\nint res=0;\n\nint dfs(int x,int y,int k,int bit,int pc){\n\tint nx=x,ny=y;\n\tif(dp[x][y][k][bit]!=-1)return dp[x][y][k][bit];\n\t\n\t//11nx++,10nx--,01ny++,00ny--;\n\tint nbit=bit;\n\tif(nbit >>11 & 1)nbit-=1<<11;\n\tif(nbit >>10 & 1)nbit-=1<<10;\n\tnbit<<=2;\n\tint r=-50000;\n\tif(k>=1){\n\t\tnbit+=2;\n\t\tx--;\n\t\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\t\tr=max(r,dfs(x,y,k-1,nbit,pc+1));\n\t\t}\n\t\tx++;\n\t\ty--;\n\t\tnbit-=2;\n\t\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\t\tr=max(r,dfs(x,y,k-1,nbit,pc+1));\n\t\t}\n\t\ty++;\n\t}\n\tnbit+=3;\n\tx++;\n\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\tr=max(r,dfs(x,y,k,nbit,pc+1));\n\t}\n\tx--;\n\tnbit-=2;\n\ty++;\n\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\tr=max(r,dfs(x,y,k,nbit,pc+1));\n\t}\n\ty--;\n\t\n\tint sum=0;\n\tbool f=false;\n\tfor(int i=0;i<min(pc,6);i++){\n\t\tif(bit >>i*2 & 1){\n\t\t\tif(bit >>(i*2+1) & 1)nx--;\n\t\t\telse ny--;\n\t\t}else{\n\t\t\tif(bit >>(i*2+1) & 1)nx++;\n\t\t\telse ny++;\n\t\t}\n\t\tif(nx==x && ny==y){\n\t\t\tf=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f)sum+=fie[x][y];\n\t\n\tif(r<0 && x==w-1 && y==h-1)r=0;\n\treturn (dp[x][y][k][bit]=sum+r);\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&h,&w,&K);\n\tmemset(fie,-1,sizeof(fie));\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i=0;i<h;i++){\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]=='.')fie[j][i]=0;\n\t\t\telse if(str[j]=='#')fie[j][i]=-1;\n\t\t\telse fie[j][i]=str[j]-'0';\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dfs(0,0,K,0,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int dx[4]={0,1,0,-1}, dy[4]={1,0,-1,0};\nchar f[60][51];\n\nint vis[60][50]={};\nint dp[60][50][1<<12][4];\n\nint main()\n{\n    int H,W,K;\n    cin >>H >>W >>K;\n\n    rep(i,6)\n    {\n        f[i][0]='.';\n        for(int j=1; j<W; ++j) f[i][j]='#';\n    }\n    rep(i,H) scanf(\"%s\", f[i+6]);\n    H+=6;\n\n    #define IN(y,x) (0<=y && y<H && 0<=x && x<W)\n    memset(dp,-1,sizeof(dp));\n    dp[6][0][0][0]=0;\n    rep(b,K+1)rep(y,H)rep(x,W)if(f[y][x]!='#')\n    {\n        rep(mask,1<<12)if(dp[y][x][mask][b]>=0)\n        {\n            int d[6];\n            rep(i,6) d[i] = (mask>>(2*i))&3;\n\n            int px[7],py[7];\n            px[0] = x;\n            py[0] = y;\n            rep(i,6)\n            {\n                px[i+1] = px[i] - dx[d[i]];\n                py[i+1] = py[i] - dy[d[i]];\n            }\n\n            rep(i,7) vis[py[i]][px[i]]=1;\n\n            rep(i,4)\n            {\n                int nx = x+dx[i], ny = y+dy[i], nb = b+(i>=2);\n                if(nb<=K && IN(ny,nx) && f[ny][nx]!='#')\n                {\n                    int add=max(0,f[ny][nx]-'0');\n                    if(vis[ny][nx]) add=0;\n\n                    int nmask = ((mask<<2)&((1<<12)-1)) + i;\n\n                    dp[ny][nx][nmask][nb] = max(dp[ny][nx][nmask][nb], dp[y][x][mask][b] + add);\n                }\n            }\n\n            rep(i,7) vis[py[i]][px[i]]=0;\n        }\n    }\n\n    int ans=0;\n    rep(M,1<<12)rep(B,K+1) ans=max(ans,dp[H-1][W-1][M][B]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#define INF -(1 << 23)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint main()\n{\n\tint H, W, K;\n\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &K);\n\n\tvector<string> M(H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tcin >> M[i];\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (M[i][j] == '.')\n\t\t\t{\n\t\t\t\tM[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<vector<vector<int> > > > dp(H, vector<vector<vector<int> > >(W, vector<vector<int> >(K + 1, vector<int>(4096, INF))));\n\n\tdp[0][0][0][0] = 0;\n\n\tfor (int rep = 0; rep <= K; rep++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= K; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < 4096; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint dir = l % 4;\n\n\t\t\t\t\t\t\tint p6 = l / 1024;\n\t\t\t\t\t\t\tint p5 = (l / 256) % 4;\n\t\t\t\t\t\t\tint p4 = (l / 64) % 4;\n\t\t\t\t\t\t\tint p3 = (l / 16) % 4;\n\t\t\t\t\t\t\tint p2 = (l / 4) % 4;\n\t\t\t\t\t\t\tint p1 = l % 4;\n\n\t\t\t\t\t\t\tint px1 = j + dx[p1];\n\t\t\t\t\t\t\tint px2 = px1 + dx[p2];\n\t\t\t\t\t\t\tint px3 = px2 + dx[p3];\n\t\t\t\t\t\t\tint px4 = px3 + dx[p4];\n\t\t\t\t\t\t\tint px5 = px4 + dx[p5];\n\t\t\t\t\t\t\tint px6 = px5 + dx[p6];\n\t\t\t\t\t\t\tint py1 = i + dy[p1];\n\t\t\t\t\t\t\tint py2 = py1 + dy[p2];\n\t\t\t\t\t\t\tint py3 = py2 + dy[p3];\n\t\t\t\t\t\t\tint py4 = py3 + dy[p4];\n\t\t\t\t\t\t\tint py5 = py4 + dy[p5];\n\t\t\t\t\t\t\tint py6 = py5 + dy[p6];\n\n\t\t\t\t\t\t\tbool ok1 = true, ok2 = true, ok3 = true, ok4 = true, ok5 = true, ok6 = true;\n\n\t\t\t\t\t\t\tif (0 <= px1 && px1 < W && 0 <= py1 && py1 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py1][px1] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok1 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px2 && px2 < W && 0 <= py2 && py2 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py2][px2] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px3 && px3 < W && 0 <= py3 && py3 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py3][px3] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok3 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px4 && px4 < W && 0 <= py4 && py4 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py4][px4] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok4 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px5 && px5 < W && 0 <= py5 && py5 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py5][px5] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok5 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (0 <= px6 && px6 < W && 0 <= py6 && py6 < H)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (M[py6][px6] > 48)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok6 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!((j == px1 && i == py1 && !ok1) || (j == px2 && i == py2 && !ok2) || (j == px3 && i == py3 && !ok3) || (j == px4 && i == py4 && !ok4) || (j == px5 && i == py5 && !ok5) || (j == px6 && i == py6 && !ok6)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ((0 <= j + dx[dir] && j + dx[dir] < W && 0 <= i + dy[dir] && i + dy[dir] < H) && !((dir % 3) && k == 0))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tint r = m * 1024 + l / 4;\n\n\t\t\t\t\t\t\t\t\t\tif (dir % 3)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k - 1][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = -1;\n\n\tfor (int i = 0; i <= K; i++)\n\t{\n\t\tfor (int j = 0; j < 4096; j++)\n\t\t{\n\t\t\tret = max(ret, dp[H - 1][W - 1][i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 60\n#define MAX_K 3\n#define MAX_D 6\n#define MAX_C 4096\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\nint dp[MAX_N][MAX_N][MAX_K + 1][MAX_C];\nint x[MAX_N][MAX_N];\nint h, w, K, a;\nchar c;\nchar T[12] = \".123456789#\";\nint b[MAX_N][MAX_N];\nint gx[6], gy[6];\n\nint hantei(int p, int q, vector<int>r) {\n\tint v = p, w = q;\n\tfor (int o = 5; o >= 0; o--) {\n\t\tv -= dy[r[o]];\n\t\tw -= dx[r[o]];\n\t\tgy[o] = v; gx[o] = w;\n\t}\n\tfor (int o = 0; o <= 5; o++) {\n\t\tif (p == gy[o] && q == gx[o]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint DP() {\n\tint X, Y, F, G, H, dir[6], maxn;\n\n\t//zentansaku(first 6)\n\tfor (int i = 0; i < 4096; i++) {\n\t\tmemset(b, 0, sizeof(b));\n\t\tX = 1; Y = 1;\n\t\tF = 0; G = 0;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\ta = (i / (int)pow(4, j)) % 4;\n\t\t\tX += dx[a]; Y += dy[a];\n\t\t\tif (x[Y][X] == 10) {\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif (G == 2 || G == 3) {\n\t\t\t\tG++;\n\t\t\t}\n\t\t\tif (b[Y][X] == 1) {\n\t\t\t\tF += x[Y][X];\n\t\t\t}\n\t\t\tb[Y][X] = 1;\n\t\t}\n\t\tif (G <= K) {\n\t\t\tdp[Y][X][G][i] = F;\n\t\t}\n\tE:;\n\t}\n\n\t//dp.\n\tfor (int i = 0; i < h + w - 5; i++) {\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\tif (x[j][k] <= 9) {\n\n\t\t\t\t\tfor (int l = 0; l <= k; l++) {\n\t\t\t\t\t\tfor (int m = 0; m < MAX_C; m++) {\n\t\t\t\t\t\t\tif (dp[i][j][k][l] >= 0) {\n\n\t\t\t\t\t\t\t\tfor (int n = 0; n < 6; n++) {\n\t\t\t\t\t\t\t\t\tdir[i] = (m / (int)pow(4, n)) % 4;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (l <= K) {\n\t\t\t\t\t\t\t\t\tif (x[j - 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 2048;\n\n\t\t\t\t\t\t\t\t\t\tif (hantei(j - 1, k, { dir[1],dir[2],dir[3],dir[4],dir[5],2 }) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j - 1][k];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tX = j; Y = k;\n\n\t\t\t\t\t\t\t\t\t\tdp[j - 1][k][l + 1][a] = max(dp[j - 1][k][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (x[j][k - 1] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 3072;\n\n\n\t\t\t\t\t\t\t\t\t\tif (hantei(j, k - 1, { dir[1],dir[2],dir[3],dir[4],dir[5],3 }) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j][k - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tdp[j][k - 1][l + 1][a] = max(dp[j][k - 1][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j + 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (hantei(j + 1, k, { dir[1],dir[2],dir[3],dir[4],dir[5],0 }) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j + 1][k];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j + 1][k][l][a] = max(dp[j + 1][k][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j][k + 1] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ta += 1024;\n\n\t\t\t\t\t\t\t\t\tif (hantei(j, k + 1, { dir[1],dir[2],dir[3],dir[4],dir[5],1 }) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j][k + 1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j][k + 1][l][a] = max(dp[j][k + 1][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmaxn = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tfor (int j = 0; j < MAX_C; j++) {\n\t\t\tmaxn = max(maxn, dp[h][w][i][j]);\n\t\t}\n\t}\n\treturn maxn;\n}\n\nint main() {\n\t//shokika.\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_K; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_C; l++) {\n\t\t\t\t\tdp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tx[i][j] = 10;\n\t\t}\n\t}\n\t//cin.\n\tcin >> h >> w >> K;\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tcin >> c;\n\t\t\tfor (int k = 0; k < 11; k++) {\n\t\t\t\tif (c == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define chmax(a,b) ((a) = max((a),(b)))\nusing namespace std;\n\nconst int dy[] = {0,1,0,-1}, dx[] = {1,0,-1,0};\nint dp[50][50][4][1<<12];\nint vis[1<<12];\n\ninline int visit(int bit){\n  if(vis[bit]>=0)return vis[bit];\n  int y=0, x=0;\n  rep(i,6){\n    int d = bit&3; bit>>=2;\n    y += dy[d], x += dx[d];\n    if(y==0 && x==0)return vis[bit] = 1;\n  }\n  return vis[bit] = 0;\n}\n\nint main(){\n  int h,w,k;\n  string g[50];\n  cin >> h >> w >> k;\n  rep(i,h)cin >> g[i];\n\n  memset(vis,-1,sizeof(vis));\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0][0] = isdigit(g[0][0])?(int)(g[0][0]-'0'):0;\n\n  rep(rev,k+1){\n    rep(y,h)rep(x,w){\n      if(g[y][x] == '#')continue;\n      rep(bit,1<<12){\n\tif(dp[y][x][rev][bit]<0)continue;\n\n\trep(d,4){\n\t  int ny = y+dy[d], nx = x+dx[d];\n\t  if(!range(ny,0,h) || !range(nx,0,w))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  int nbit = ((bit<<2)|d) & ((1<<12)-1);\n\t  int item = isdigit(g[ny][nx])?(int)(g[ny][nx]-'0'):0;\n\t  if(visit(nbit))item = 0;\n\n\t  if(d<2){\n\t    chmax(dp[ny][nx][rev][nbit], dp[y][x][rev][bit] + item);\n\t  }else if(rev!=k){\n\t    chmax(dp[ny][nx][rev+1][nbit], dp[y][x][rev][bit] + item);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = 0;\n  rep(bit,1<<12)chmax(res, dp[h-1][w-1][k][bit]);\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\nint h, w, k;\nchar board[50][51];\n\nint getboard(int i, int j)\n{\n\tif (i < 0 || j < 0 || i >= h || j >= w)\n\t{\n\t\treturn -1;\n\t}\n\treturn (board[i][j] == '#') ? -1 : ((board[i][j] == '.') ? 0 : (board[i][j] - '0'));\n}\n\nconst int PMAX = 1 << 12;\nint memo[50][50][4][PMAX];\nconst int hsy[4] = { 1,0,-1,0 };\nconst int hsx[4] = { 0,1,0,-1 };\nconst int INF = 123456789;\nint dp(int i, int j, int x, int path)\n{\n\tif (x > k || x < 0)return -INF;\n\tif (i < 0 || j < 0)return -INF;\n\tif (memo[i][j][x][path] != -1)return memo[i][j][x][path];\n\tint ans = -INF;\n\tint kk = x;\n\tif (!(getboard(i, j) < 0))\n\t{\n\t\tfor (int d = 0; d < 4; ++d)\n\t\t{\n\t\t\tif (d >= 2)\n\t\t\t{\n\t\t\t\tkk = x - 1;\n\t\t\t\tif (kk < 0)continue;\n\t\t\t}\n\t\t\tint d2 = d << 10;\n\t\t\tint idp = (path >> 2) % (1 << 10) + d2;\n\t\t\tint cans = dp(i - hsy[path % 4], j - hsx[path % 4], kk, idp);\n\t\t\tint u = hsy[path % 4], v = hsx[path % 4];\n\t\t\tbool flag = false;\n\t\t\tfor (int bit = 0; bit < 6; ++bit)\n\t\t\t{\n\t\t\t\tu += hsy[idp % 4];\n\t\t\t\tv += hsx[idp % 4];\n\t\t\t\tidp /= 4;\n\t\t\t\tif (u == 0 && v == 0)flag = true;\n\t\t\t}\n\t\t\tif (!flag)cans += getboard(i, j);\n\t\t\tans = max(ans, cans);\n\t\t}\n\t}\n\treturn memo[i][j][x][path] = ans;\n}\n\nint main(void)\n{\n\tscanf(\"%d %d %d\", &h, &w, &k);\n\tfor (int i = 0; i < h; ++i)scanf(\"%s\", board[i]);\n\tmemset(memo, 0xFF, sizeof(memo));\n\tmemo[0][0][0][0] = 0;\n\tint ans = 0;\n\tfor (int x = 0; x <= k; ++x)\n\t{\n\t\tfor (int p = 0; p < PMAX; ++p)\n\t\t{\n\t\t\tint p2 = p;\n\t\t\tint bcount = 0;\n\t\t\tfor (int bit = 0; bit < 6; ++bit)\n\t\t\t{\n\t\t\t\tif (p2 % 4 >= 2)++bcount;\n\t\t\t\tp2 /= 4;\n\t\t\t}\n\t\t\tif (bcount > k - x)continue;\n\t\t\tans = max(ans, dp(h - 1, w - 1, x, p));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint dp[50][50][4][1<<12];\nchar f[50][50];\nint w,h,K;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nbool out(int x,int y)\n{\n\tif(x<0||x>=h||y<0||y>=w)return true;\n\treturn false;\n}\nbool revisit(int bit)\n{\n\tint tx=0,ty=0;\n\tfor(int i=0;i<6;i++,bit>>=2)\n\t{\n\t\tint id=bit%4;\n\t\ttx+=dx[id];ty+=dy[id];\n\t\tif(tx==0&&ty==0)return true;\n\t}\n\treturn false;\n}\nint rec(int x,int y,int k,int bit)\n{\n\tif(x==0&&y==0)return 0;\n\tif(dp[x][y][k][bit]>=0)return dp[x][y][k][bit];\n\tint num=0;\n\tif(f[x][y]!='.'&&f[x][y]!='#'&&!revisit(bit))num=f[x][y]-'0';\n\tint res=-INF;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(!out(nx,ny)&&f[x][y]!='#'&&k-(i>=2)>=0)\n\t\t{\n\t\t\tres=max(res,rec(nx,ny,k-(i>=2),((1<<12)-1)&((bit<<2)+i))+num);\n\t\t}\n\t}\n\treturn dp[x][y][k][bit]=res;\n}\nint main()\n{\n\tcin >> h >> w >> K;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tcin >> f[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<(1<<12);l++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][k][l]=-INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << rec(h-1,w-1,K,0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n#define BACK 6\ntypedef pair<pair<int,int>, pair<int,int>> PP;\n\nint dp[(1<<(BACK*2))+10][60][60][4];\n\nint main(){\n  int h,w,k;\n  cin>>h>>w>>k;\n\n  vector<string> vec(h+BACK);\n  rep(i,BACK){\n    vec[i].resize(w);\n    vec[i][0] = '.';\n    repl(j,1,w) vec[i][j] = '#';\n  }\n  rep(i,h) cin>> vec[i+BACK];\n\n  h += BACK;\n\n  fill(dp[0][0][0], dp[1<<(BACK*2)][0][0], -INF);\n  dp[0][BACK][0][0] = 0;\n  queue<PP> q; // prevs, h, w, k\n  q.push(mp(mp(0,BACK), mp(0,0)));\n\n  const int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n  while(!q.empty()){\n    PP pp = q.front(); q.pop();\n    int prevs = pp.fi.fi;\n    int x = pp.fi.se, y = pp.se.fi, kk = pp.se.se;\n//dbg(mp(mp(x,y),dp[prevs][x][y][kk]));\n    bool visited[4] = {0,0,0,0};\n    int px=0, py=0;\n    rep(i,BACK){\n      int m = (prevs>>(2*i))%4;\n      px -= dx[m], py -= dy[m];\n      if(px*px + py*py == 1){\n        rep(j,4) if(px==dx[j] && py==dy[j]){\n          visited[j] = true;\n          break;\n        }\n      }\n    }\n\n    rep(i,4){\n      int nx = x + dx[i], ny = y + dy[i], nk = kk + (i>=2);\n      if(nk>k) continue;\n      if(nx<0 || ny<0 || nx>=h || ny>=w || vec[nx][ny]=='#') continue;\n//      dbg(mp(nx,ny));\n      int ncost = dp[prevs][x][y][kk];\n      if(vec[nx][ny]!='.' && !visited[i]) ncost += vec[nx][ny] - '0';\n      int nmask = prevs%(1<<(2*(BACK-1)));\n      nmask = nmask*4 + i;\n      if(dp[nmask][nx][ny][nk] >= ncost) continue;\n      dp[nmask][nx][ny][nk] = ncost;\n      q.push(mp(mp(nmask,nx), mp(ny,nk)));\n    }\n  }\n\n  int res = 0;\n  rep(i,1<<(BACK*2)) res = max(res, dp[i][h-1][w-1][k]);\n\n  cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n//#define int long long\n#define PB push_back\n#define MK make_pair\n#define MKT make_tuple\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n\n//constexpr int INF = 1LL<<60;\nconstexpr int INF = 1 << 28;\n//constexpr int MOD = 100000;\nconstexpr int MAX_N = 52;\nconstexpr int dx[] = { 1, 0, -1, 0 };\nconstexpr int dy[] = { 0, 1, 0, -1 };\n\nint mem[MAX_N][MAX_N][4][1 << 6][1 << 6], h, w, k, fld[MAX_N][MAX_N];\n\ninline bool Chk(int x, int y, int mask1, int mask2) {\n    constexpr int len = 6;\n    int cx = x, cy = y;\n    for (int i = 0; i < len; ++i) {\n        int b1 = (mask1 & (1 << (len - 1 - i))) ? 1 : 0, b2 = (mask2 & (1 << (len - 1 - i))) ? 1 : 0;\n        int idx = b1 + 2 * b2;\n        cx -= dx[idx];\n        cy -= dy[idx];\n        if (x == cx && y == cy) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint Solve(int x, int y, int c, int mask1, int mask2) {\n    if (x == w + 1 && y == h) return 0;\n    if (mem[x][y][c][mask1][mask2] != -1) return mem[x][y][c][mask1][mask2];\n\n    int cur = Chk(x, y, mask1, mask2) ? 0 : fld[x][y];\n    int res = 0;\n    bool flg = false;\n    for (int i = 0; i < 4; ++i) {\n        if (1 < i && k <= c) break;\n        int tx = x + dx[i], ty = y + dy[i];\n        int nc = (1 < i) ? c + 1 : c;\n        if (fld[tx][ty] == -1) continue;\n\n        int nm1 = (mask1 >> 1) + ((i % 2) << 5), nm2 = (mask2 >> 1) + ((1 < i) << 5);\n        int tmp = Solve(tx, ty, nc, nm1, nm2);\n        if (tmp <= -INF) {\n            continue;\n        }\n        flg = true;\n        res = max(res, tmp);\n    }\n\n    if (!flg) {\n        res = -INF;\n        cur = 0;\n    }\n\n    return mem[x][y][c][mask1][mask2] = res + cur;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    memset(fld, -1, sizeof(fld));\n    cin >> h >> w >> k;\n    for (int y = 1; y <= h; ++y) {\n        string s;\n        cin >> s;\n        for (int x = 1; x <= w; ++x) {\n            char c = s[x - 1];\n            if (c == '#') {\n                fld[x][y] = -1;\n                continue;\n            } else if (c == '.') {\n                fld[x][y] = 0;\n                continue;\n            }\n            fld[x][y] = c - '0';\n        }\n    }\n    fld[w + 1][h] = 0;\n    memset(mem, -1, sizeof(mem));\n    cout << max(0, Solve(1, 1, 0, 0, 0)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[5][50][50][1 << 12];\nint H, W, K;\nchar mas[50][50];\nint dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint mask;\n \nint getdir(int bit, int i){\n  return bit >> (i << 1) & 3;\n}\nbool isover(int y, int x){\n  return y < 0 || y >= H || x < 0 || x >= W;\n}\nbool check(int y, int x, int bit){\n  if(mas[y][x] == '.') return false;\n  for(int i = 0, my = y, mx = x; i < 2 * K; i++){\n    my -= dy[getdir( bit, i)], mx -= dx[getdir( bit, i)];\n    if(my == y && mx == x) return false;\n  }\n  return true;\n}\nint main()\n{\n  cin >> H >> W >> K;\n  mask = (1 << (K * 2 * 2)) - 1;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      cin >> mas[i][j];\n    }\n  }\n  fill_n( ***dp, 5 * 50 * 50 * 1 << 12, -1);\n  dp[K][0][0][0] = 0;\n\n  for(int mul = K ; mul >= 0; mul--){\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        for(int bit = 0; bit < 1 << (K * 4) ; bit++){ // 前の街\n          if(dp[mul][y][x][bit] == -1 || mas[y][x] == '#') continue;\n          int cost = check( y, x, bit) * (mas[y][x] - '0');\n          for(int i = 0; i < 4; i++){\n            int ny = y + dy[i], nx = x + dx[i];\n            if(isover(ny,nx) || mas[ny][nx] == '#') continue;\n            if(mul == 0 && i >= 2) break;\n            int& next = dp[mul - (i > 1)][ny][nx][(bit << 2 | i) & mask];\n            next = max( next, dp[mul][y][x][bit] + cost);\n          }\n        }\n      }\n    }\n  }\n  cout << *max_element(dp[0][H-1][W-1],dp[0][H-1][W]) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 0x7fffffff\n\ntypedef pair<int, int> Coor;\n\nint h, w, k;\nchar field[50][50];\nmap<vector<Coor>, int> dp[50][50][4]; // dp[y][x][left][where]\n\nint dfs(int x, int y, int k, const vector<Coor> &v) {\n    vector <Coor> v2;\n    int dx[] = {0, 1};\n    int dy[] = {1, 0};\n    int kdx[] = {0, -1};\n    int kdy[] = {-1, 0};\n    int ans = -INF;\n    if (x == w-1 && y == h-1) ans = 0; \n\n    for (int i=0; i<v.size(); i++) {\n        Coor c = v[i];\n        if (x <= c.first && c.first < x+k && y <= c.second && c.second < y+k) {\n            v2.push_back(c);\n        }\n    }\n    sort(v2.begin(), v2.end());\n\n    if (dp[x][y][k].find(v2) != dp[x][y][k].end()) {\n        return dp[x][y][k][v2];\n    }\n\n\n    for (int t=0; t<2; t++) {\n        int newx = x + dx[t];\n        int newy = y + dy[t];\n        int add = 0;\n\n        if (newx < 0 || w <= newx || newy < 0 || h <= newy) continue;\n        if (field[newy][newx] == '#') continue;\n        if ('1' <= field[newy][newx] && field[newy][newx] <= '9') {\n            if (binary_search(v2.begin(), v2.end(), Coor(newx, newy)) == false) {\n                add = field[newy][newx] - '0';\n                v2.push_back(Coor(newx, newy));\n            }\n        }\n\n        ans = max(ans, dfs(newx, newy, k, v2) + add);\n    }\n\n    for (int t=0; t<2; t++) {\n        int newx = x + kdx[t];\n        int newy = y + kdy[t];\n        int add = 0;\n\n        if (newx < 0 || w <= newx || newy < 0 || h <= newy || k == 0) continue;\n        if (field[newy][newx] == '#') continue;\n        if ('1' <= field[newy][newx] && field[newy][newx] <= '9') {\n            if (binary_search(v2.begin(), v2.end(), Coor(newx, newy)) == false) {\n                add = field[newy][newx] - '0';\n                v2.push_back(Coor(newx, newy));\n            }\n        }\n\n        ans = max(ans, dfs(newx, newy, k-1, v2) + add);\n    }\n\n    dp[x][y][k][v] = ans;\n    return ans;\n}\n\nint main() {\n    vector<Coor> v;\n\n    scanf(\"%d %d %d\", &h, &w, &k);\n    for (int i=0; i<h; i++) {\n        for (int j=0; j<w; j++) {\n            scanf(\" %c\", &field[i][j]);\n        }\n    }\n\n    printf(\"%d\\n\", dfs(0, 0, k, v));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint h,w,k,mask;\nint dp[50][50][1<<12][4];\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nchar mp[51][51];\nbool visit[1<<12];\n\nint dfs(int x,int y,int bit,int lk){\n    int pt=0,mx=-1;\n    if(dp[x][y][bit][lk]!=-1) return dp[x][y][bit][lk];\n    if(x==w-1&&y==h-1&&lk==0) return 0;\n    if(!visit[bit]&&mp[y][x]!='.') pt +=mp[y][x]-'0';\n    for(int i=0;i<4;++i){\n        if(lk==0&&i>1) break;\n        int tx=x+dx[i],ty=y+dy[i],nbit=((bit<<2)|i)&mask,uk=i>1?lk-1:lk;\n        if(tx>=0&&ty>=0&&tx<w&&ty<h&&mp[ty][tx]!='#') mx=max(mx,dfs(tx,ty,nbit,uk)+pt);\n    }\n    dp[x][y][bit][lk]=mx;\n    return mx;\n}\n\nint main(){\n    cin>>h>>w>>k;\n    for(int i=0;i<h;++i){\n        for(int j=0;j<w;++j) cin>>mp[i][j];\n    }\n    memset(dp,-1,sizeof(dp));\n    mask=(1<<2*2*k)-1;\n    for(int i=0;i<=mask;++i){\n        int tx=0,ty=0,pre=i;\n        for(int j=0;j<2*k;++j){\n            tx -=dx[pre&3];ty -=dy[pre&3];\n            if(tx==0&&ty==0) visit[i]=true;\n            pre >>=2;\n        }\n    }\n    cout<<dfs(0,0,0,k)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tEast,\n\tSouth,\n\tWest,\n\tNorth,\n};\n\nstruct Info{\n\tvoid set(int arg_row,int arg_col,int arg_back_count,int arg_moved_count,int arg_sum,int arg_move_log){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tback_count = arg_back_count;\n\t\tmoved_count = arg_moved_count;\n\t\tsum = arg_sum;\n\t\tmove_log = arg_move_log;\n\t}\n\tbool operator<(const struct Info &arg) const{ //総和の降順(PQ)\n\t\treturn sum > arg.sum;\n\t}\n\n\tint row,col,back_count,moved_count,sum,move_log;\n};\n\nint H,W,K;\nint POW[7];\nint dp[50][50][4][4096]; //dp[row][col][Kの残数][moved_count][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint makeCode(Type move_log[6]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < 6; i++){\n\t\tret += move_log[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\nbool is_num(int row,int col){\n\treturn base_map[row][col] >= '1' && base_map[row][col] <= '9'; //0の土産物屋はない\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++)POW[i] = pow(4,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= K; i++){\n\t\t\t\tfor(int state = 0; state < POW[6]; state++)dp[row][col][i][state] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tInfo first;\n\tfirst.set(0,0,0,0,0,0);\n\n\tdp[0][0][0][0] = 0;\n\n\tint bit_mask = 4095;\n\n\tQ.push(first);\n\n\tint log_array[6],tmp_log;\n\n\tInfo info;\n\twhile(!Q.empty()){\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tif(dp[info.row][info.col][info.back_count][info.move_log] > info.sum)continue;\n\n\t\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\t\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t\t//過去の移動ログから、訪問済のマス情報を特定する\n\t\tint tmp_row = info.row,tmp_col = info.col;\n\n\t\ttmp_log = info.move_log;\n\t\t//printf(\"tmp_log:%d\\n\",tmp_log);\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tlog_array[i] = tmp_log & 3;\n\t\t\t//printf(\"array[%d]:%d\\n\",i,log_array[i]);\n\t\t\ttmp_log /= 4;\n\t\t}\n\n\t\tfor(int i = 0; i < min(6,info.moved_count); i++){\n\t\t\tswitch(log_array[i]){ //ログを打ち消す方向に動く\n\t\t\tcase 0:\n\t\t\t\ttmp_col--;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttmp_row--;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttmp_col++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\ttmp_row++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp_row == info.row && tmp_col == info.col+1){ //右のマスと一致\n\t\t\t\tvisited_E = true;\n\t\t\t}else if(tmp_row == info.row+1 && tmp_col == info.col){ //下のマスと一致\n\t\t\t\tvisited_S = true;\n\t\t\t}else if(tmp_row == info.row && tmp_col == info.col-1){ //左のマスと一致\n\t\t\t\tvisited_W = true;\n\t\t\t}else if(tmp_row == info.row-1 && tmp_col == info.col){ //上のマスと一致\n\t\t\t\tvisited_N = true;\n\t\t\t}\n\t\t}\n\n\t\t//次の移動ログを作る\n\n\n\t\t//右へ\n\t\tif(rangeCheck(info.row,info.col+1) == true && base_map[info.row][info.col+1] != '#'){\n\t\t\tif(visited_E == false && is_num(info.row,info.col+1) == true){\n\t\t\t\tresult_E += base_map[info.row][info.col+1]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|0;\n\t\t\tif(dp[info.row][info.col+1][info.back_count][next_code] < info.sum+result_E){\n\t\t\t\tdp[info.row][info.col+1][info.back_count][next_code] = info.sum+result_E;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col+1,info.back_count,info.moved_count+1,info.sum+result_E,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//下へ\n\t\tif(rangeCheck(info.row+1,info.col) == true && base_map[info.row+1][info.col] != '#'){\n\t\t\tif(visited_S == false && is_num(info.row+1,info.col) == true){\n\t\t\t\tresult_S += base_map[info.row+1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|1;\n\t\t\tif(dp[info.row+1][info.col][info.back_count][next_code] < info.sum+result_S){\n\t\t\t\tdp[info.row+1][info.col][info.back_count][next_code] = info.sum+result_S;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row+1,info.col,info.back_count,info.moved_count+1,info.sum+result_S,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\tif(info.back_count == K)continue;\n\n\t\t//左へ\n\t\tif(rangeCheck(info.row,info.col-1) == true && base_map[info.row][info.col-1] != '#'){\n\t\t\tif(visited_W == false && is_num(info.row,info.col-1) == true){\n\t\t\t\tresult_W += base_map[info.row][info.col-1]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|2;\n\t\t\tif(dp[info.row][info.col-1][info.back_count+1][next_code] < info.sum+result_W){\n\t\t\t\tdp[info.row][info.col-1][info.back_count+1][next_code] = info.sum+result_W;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col-1,info.back_count+1,info.moved_count+1,info.sum+result_W,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//上へ\n\t\tif(rangeCheck(info.row-1,info.col) == true && base_map[info.row-1][info.col] != '#'){\n\t\t\tif(visited_N == false && is_num(info.row-1,info.col) == true){\n\t\t\t\tresult_N += base_map[info.row-1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|3;\n\t\t\tif(dp[info.row-1][info.col][info.back_count+1][next_code] < info.sum+result_N){\n\t\t\t\tdp[info.row-1][info.col][info.back_count+1][next_code] = info.sum+result_N;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row-1,info.col,info.back_count+1,info.moved_count+1,info.sum+result_N,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\tfor(int state = 0; state < POW[6]; state++){\n\t\tfor(int count = 4; count <= 6; count++){\n\t\t\tans = max(ans,dp[H-1][W-1][K][state]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n\ntypedef pair<int,int> p;\ntypedef tuple<int,int,int,set<p>> mpdata;\ntypedef pair<int,mpdata> pqdata;\n#define mt make_tuple\n#define mp make_pair\n\nmap<mpdata,int> dp;\nmap<int,int> dist;\n\nvoid check(int i,int k){\n\tdist[i]--;\n\tif(dist[i]==0)\tdist.erase(i);\n\tif(dist.begin()->first>i){\n\t\tfor(auto it:dp){\n\t\t\tif(get<0>(it.first)+get<1>(it.first)<i-k){\n\t\t\t\tdp.erase(it.first);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint h,w,k;\tcin>>h>>w>>k;\n\tvector<string> s(h);\n\trep(i,h){\n\t\tcin>>s[i];\n\t}\n\t\n\tpriority_queue<pqdata> pq;\n\tpq.push(mp(-1,mt(0,0,k,set<p>())));\n\tdp[mt(1,0,k,set<p>())]=0;\n\tdist[0]++;\n\tint ans=1;\n\t\n\twhile(!pq.empty()){\n\t\tauto it=pq.top();\tpq.pop();\n\t\tint cost=-it.first;\n\t\tint y=get<0>(it.second);\n\t\tint x=get<1>(it.second);\n\t\tint use=get<2>(it.second);\n\t\tauto id=get<3>(it.second);\n\t\t\n\t\tif(cost<dp[mt(y,x,use,id)]){\n\t\t\tcheck(y+x,k);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(x+1==w&&y+1==h&&use==0){\n\t\t\tans=max(ans,cost);\n\t\t\tcheck(y+x,k);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(use>0){\n\t\t\tif(y>0&&s[y-1][x]!='#'){\n\t\t\t\t//up\n\t\t\t\tint nextcost=cost;\n\t\t\t\tauto nextid=id;\n\t\t\t\tif(s[y-1][x]!='.'&&id.find(mp(y-1,x))==id.end()){\n\t\t\t\t\tnextid.insert(mp(y-1,x));\n\t\t\t\t\tnextcost+=s[y-1][x]-'0';\n\t\t\t\t}\n\t\t\t\tauto t=mt(y-1,x,use-1,nextid);\n\t\t\t\tif(nextcost>dp[t]){\n\t\t\t\t\tdp[t]=nextcost;\n\t\t\t\t\tpq.push(mp(-nextcost,t));\n\t\t\t\t\tdist[y+x-1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(x>0&&s[y][x-1]!='#'){\n\t\t\t\t//left\n\t\t\t\tint nextcost=cost;\n\t\t\t\tauto nextid=id;\n\t\t\t\tif(s[y][x-1]!='.'&&id.find(mp(y,x-1))==id.end()){\n\t\t\t\t\tnextid.insert(mp(y,x-1));\n\t\t\t\t\tnextcost+=s[y][x-1]-'0';\n\t\t\t\t}\n\t\t\t\tauto t=mt(y,x-1,use-1,nextid);\n\t\t\t\tif(nextcost>dp[t]){\n\t\t\t\t\tdp[t]=nextcost;\n\t\t\t\t\tpq.push(mp(-nextcost,t));\n\t\t\t\t\tdist[y+x-1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(y+1<h&&s[y+1][x]!='#'){\n\t\t\t//down\n\t\t\tint nextcost=cost;\n\t\t\tauto nextid=id;\n\t\t\tfor(int i=x-use;i<=x+k-use;i++){\n\t\t\t\tnextid.erase(mp(y-use,i));\n\t\t\t}\n\t\t\tif(s[y+1][x]!='.'&&nextid.find(mp(y+1,x))==nextid.end()){\n\t\t\t\tnextid.insert(mp(y+1,x));\n\t\t\t\tnextcost+=s[y+1][x]-'0';\n\t\t\t}\n\t\t\tauto t=mt(y+1,x,use,nextid);\n\t\t\tif(dp[t]<nextcost){\n\t\t\t\tdp[t]=nextcost;\n\t\t\t\tpq.push(mp(-nextcost,t));\n\t\t\t\tdist[y+x+1]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(x+1<w&&s[y][x+1]!='#'){\n\t\t\t//right\n\t\t\tint nextcost=cost;\n\t\t\tauto nextid=id;\n\t\t\tfor(int i=y-use;i<=y+k-use;i++){\n\t\t\t\tnextid.erase(mp(i,x-use));\n\t\t\t}\n\t\t\tif(s[y][x+1]!='.'&&nextid.find(mp(y,x+1))==nextid.end()){\n\t\t\t\tnextid.insert(mp(y,x+1));\n\t\t\t\tnextcost+=s[y][x+1]-'0';\n\t\t\t}\n\t\t\tauto t=mt(y,x+1,use,nextid);\n\t\t\tif(dp[t]<nextcost){\n\t\t\t\tdp[t]=nextcost;\n\t\t\t\tpq.push(mp(-nextcost,t));\n\t\t\t\tdist[y+x+1]++;\n\t\t\t}\n\t\t}\n\t\tcheck(y+x,k);\n\t}\n\tcout<<ans-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n#define BACK 6\n\nint dp[(1<<(BACK*2))+10][60][60][4];\n\nint main(){\n  int h,w,k;\n  cin>>h>>w>>k;\n\n  vector<string> vec(h+BACK);\n  rep(i,BACK){\n    vec[i].resize(w);\n    vec[i][0] = '.';\n    repl(j,1,w) vec[i][j] = '#';\n  }\n  rep(i,h) cin>> vec[i+BACK];\n\n  h += BACK;\n\n  fill(dp[0][0][0], dp[1<<(BACK*2)][0][0], -INF);\n  dp[0][BACK][0][0] = 0;\n\n  const int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\n  rep(kk,k+1) rep(x,h) rep(y,w) rep(prevs, 1<<(BACK*2)) if(dp[prevs][x][y][kk]>=0){ //dbg(mp(mp(x,y), mp(kk,dp[prevs][x][y][kk])));\n    bool visited[4] = {0,0,0,0};\n    int px=0, py=0;\n    rep(i,BACK){\n      int m = (prevs>>(2*i))%4;\n      px -= dx[m], py -= dy[m];\n      rep(j,4) if(px==dx[j] && py==dy[j]){\n        visited[j] = true;\n        break;\n      }\n    }\n\n    rep(i,4){\n      int nx = x + dx[i], ny = y + dy[i], nk = kk + (i>=2);\n      if(nk>k || nx<0 || ny<0 || nx>=h || ny>=w || vec[nx][ny]=='#') continue;\n      int ncost = dp[prevs][x][y][kk];\n      if(vec[nx][ny]!='.' && !visited[i]) ncost += vec[nx][ny] - '0';\n      int nmask = prevs%(1<<(2*(BACK-1)));\n      nmask = nmask*4 + i;\n      dp[nmask][nx][ny][nk] = max(dp[nmask][nx][ny][nk], ncost);\n    }\n  }\n\n  int res = 0;\n  rep(i,1<<(BACK*2)) res = max(res, dp[i][h-1][w-1][k]);\n\n  cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint w, h, k;\nint memo[1 << 12][4][50][50];\nint mask;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nchar field[64][64];\n\nbool check(int ny, int nx)\n{\n\treturn (0 <= ny && ny < h && 0 <= nx && nx < w);\n}\n\nint getMax(int bit, int left, int ty, int tx)\n{\n\tif (memo[bit][left][ty][tx] != -1) return (memo[bit][left][ty][tx]);\n\t\n\tif (ty == h - 1 && tx == w - 1 && left == 0){\n\t\treturn (0);\n\t}\n\t\n\tint px = tx, py = ty;\n\tbool same = false;\n\tfor (int i = 0; i < 2 * k; i++){\n\t\tpx += -dx[(bit >> (2 * i)) & 3];\n\t\tpy += -dy[(bit >> (2 * i)) & 3];\n\t\tif (px == tx && py == ty){\n\t\t\tsame = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint ret = 0;\n\t\n\tif (!same && field[ty][tx] != '.') ret += field[ty][tx] - '0';\n\t\n\tint val = -999999;\n\tfor (int i = 0; i < 4; i++){\n\t\tif (left == 0 && i >= 2) break;\n\t\tint nx = tx + dx[i], ny = ty + dy[i];\n\t\tif (check(ny, nx) && field[ny][nx] != '#'){\n\t\t\tval = max(val, getMax(((bit << 2) | i) & mask, left - (i >= 2), ny, nx) + ret);\n\t\t}\n\t}\n\t\n\treturn (memo[bit][left][ty][tx] = val);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &h, &w, &k);\n\t\n\tmask = (1 << (4 * k)) - 1;\n\t\n\tfor (int i = 0; i < h; i++){\n\t\tscanf(\"%s\", field[i]);\n\t}\n\t\n\tmemset(memo, -1, sizeof(memo));\n\t\n\tint res = getMax(0, k, 0, 0);\n\t\n\tprintf(\"%d\\n\", res < 0 ? 0 : res);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum Block {HOUSE = -1, BLANK};\nconst int BIT = 12;\n\nint H, W, K;\nvector<vector<int>> B;\n\nint dp[50][50][4][1 << BIT];\n\nenum {Y, X};\nconst int POINT[4][BIT][2] = {\n  {{4,4}, {1,4}, {2,3}, {2,4}, {3,2}, {3,3}, {3,4}, {4,1}, {4,2}, {4,3}, {0,0}, {0,0},},\n  {{4,4}, {2,4}, {2,5}, {3,3}, {3,4}, {3,5}, {4,2}, {4,3}, {4,5}, {5,2}, {5,3}, {5,4},},\n  {{4,4}, {3,4}, {3,5}, {3,6}, {4,3}, {4,5}, {4,6}, {5,3}, {5,4}, {5,5}, {6,3}, {6,4},},\n  {{4,4}, {4,5}, {4,6}, {4,7}, {5,4}, {5,5}, {5,6}, {6,4}, {6,5}, {7,4}, {0,0}, {0,0},},\n};\nenum {STRAIGHT, REVERSE};\nconst int NEXT[2][2][2] = {\n  {{0, 1}, { 1,0},},\n  {{0,-1}, {-1,0},},\n};\n\nvector<vector<bool>> bit_to_part(int bit, int k) {\n  vector<vector<bool>> res(9, vector<bool>(9, false));\n  for(int b = 0; b < BIT; ++b) if((bit >> b) & 1) res[POINT[k][b][Y]][POINT[k][b][X]] = true;\n  return res;\n}\n\nint part_to_bit(const vector<vector<bool>>& part, int k) {\n  int res = 0;\n  for(int b = 0; b < BIT; ++b) if(part[POINT[k][b][Y]][POINT[k][b][X]]) res |= (1 << b);\n  return res;\n}\n\nint nextbit(int y, int x, int k, int bit, int dy, int dx, int dk) {\n  int ny = y + dy, nx = x + dx;\n  int nk = k + dk;\n  if(ny < 0 || H <= ny || nx < 0 || W <= nx) return -1;\n  if(B[ny][nx] == HOUSE) return -1;\n  if(K < nk) return -1;\n  auto cur = bit_to_part(bit, k);\n  vector<vector<bool>> nex(9, vector<bool>(9, false));\n  for(int i = 1; i < 8; ++i) for(int j = 1; j < 8; ++j) nex[i][j] = cur[i + dy][j + dx];\n  return part_to_bit(nex, k + dk);\n}\n\nint solve() {\n  int res = 0;\n  for(int i = 0; i < H; ++i) for(int j = 0; j < W; ++j) for(int k = 0; k <= K; ++k) for(int bit = 0; bit < (1 << BIT); ++bit) dp[i][j][k][bit] = -1;\n  dp[0][0][0][1] = 0;\n  for(int k = 0; k <= K; ++k) {\n    for(int y = 0; y < H; ++y) for(int x = 0; x < W; ++x) for(int bit = 0; bit < (1 << BIT); ++bit) {\n      if(dp[y][x][k][bit] == -1) continue;\n      for(auto d: NEXT[STRAIGHT]) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        int nk = k;\n        int nbit = nextbit(y, x, k, bit, d[Y], d[X], 0);\n        if(nbit < 0) continue;\n        int add = 0;\n        if(!(nbit & 1) && 0 < B[ny][nx]) add = B[ny][nx];\n        nbit |= 1;\n          dp[ny][nx][nk][nbit] = max(dp[ny][nx][nk][nbit], add + dp[y][x][k][bit]);\n          res = max(res, dp[ny][nx][nk][nbit]);\n      }\n    }\n    if(k < K) {\n      for(int y = H - 1;  0 <= y; --y) for(int x = W - 1; 0 <= x; --x) for(int bit = 0; bit < (1 << BIT); ++bit) {\n        if(dp[y][x][k][bit] == -1) continue;\n        for(auto d: NEXT[REVERSE]) {\n          int ny = y + d[Y];\n          int nx = x + d[X];\n          int nk = k + 1;\n          int nbit = nextbit(y, x, k, bit, d[Y], d[X], 1);\n          if(nbit < 0) continue;\n          int add = 0;\n          if(!(nbit & 1) && 0 < B[ny][nx]) add = B[ny][nx];\n          nbit |= 1;\n          dp[ny][nx][nk][nbit] = max(dp[ny][nx][nk][nbit], add + dp[y][x][k][bit]);\n          res = max(res, dp[ny][nx][nk][nbit]);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  cin >> H >> W >> K;\n  B.assign(H, vector<int>(W));\n  for(auto& line: B) for(auto& i: line) {\n    char c;\n    cin >> c;\n    if(c == '.')      i = BLANK;\n    else if(c == '#') i = HOUSE;\n    else              i = c - '0';\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tEast,\n\tSouth,\n\tWest,\n\tNorth,\n};\n\nstruct Info{\n\tvoid set(int arg_row,int arg_col,int arg_back_count,int arg_moved_count,int arg_sum,int arg_move_log){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tback_count = arg_back_count;\n\t\tmoved_count = arg_moved_count;\n\t\tsum = arg_sum;\n\t\tmove_log = arg_move_log;\n\t}\n\tbool operator<(const struct Info &arg) const{ //総和の降順(PQ)\n\t\treturn sum < arg.sum;\n\t}\n\n\tint row,col,back_count,moved_count,sum,move_log;\n};\n\nint H,W,K;\nint POW[7];\nint dp[50][50][4][7][4096]; //dp[row][col][Kの残数][moved_count][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint makeCode(Type move_log[6]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < 6; i++){\n\t\tret += move_log[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\nbool is_num(int row,int col){\n\treturn base_map[row][col] >= '1' && base_map[row][col] <= '9'; //0の土産物屋はない\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++)POW[i] = pow(4,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= K; i++){\n\t\t\t\tfor(int count = 0; count <= 6; count++){\n\t\t\t\t\tfor(int state = 0; state < POW[6]; state++)dp[row][col][i][count][state] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tInfo first;\n\tfirst.set(0,0,0,0,0,0);\n\n\tdp[0][0][0][0][0] = 0;\n\n\tint bit_mask = 4095;\n\n\tQ.push(first);\n\n\tint log_array[6],tmp_log;\n\n\tInfo info;\n\twhile(!Q.empty()){\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tif(dp[info.row][info.col][info.back_count][min(6,info.moved_count)][info.move_log] > info.sum)continue;\n\n\t\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\t\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t\t//過去の移動ログから、訪問済のマス情報を特定する\n\t\tint tmp_row = info.row,tmp_col = info.col;\n\n\t\ttmp_log = info.move_log;\n\t\t//printf(\"tmp_log:%d\\n\",tmp_log);\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tlog_array[i] = tmp_log & 3;\n\t\t\t//printf(\"array[%d]:%d\\n\",i,log_array[i]);\n\t\t\ttmp_log /= 4;\n\t\t}\n\n\t\tfor(int i = 0; i < min(info.moved_count,6); i++){\n\t\t\tswitch(log_array[i]){ //ログを打ち消す方向に動く\n\t\t\tcase 0:\n\t\t\t\ttmp_col--;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttmp_row--;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttmp_col++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\ttmp_row++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp_row == info.row && tmp_col == info.col+1){ //右のマスと一致\n\t\t\t\tvisited_E = true;\n\t\t\t}else if(tmp_row == info.row+1 && tmp_col == info.col){ //下のマスと一致\n\t\t\t\tvisited_S = true;\n\t\t\t}else if(tmp_row == info.row && tmp_col == info.col-1){ //左のマスと一致\n\t\t\t\tvisited_W = true;\n\t\t\t}else if(tmp_row == info.row-1 && tmp_col == info.col){ //上のマスと一致\n\t\t\t\tvisited_N = true;\n\t\t\t}\n\t\t}\n\n\t\t//次の移動ログを作る\n\n\n\t\t//右へ\n\t\tif(rangeCheck(info.row,info.col+1) == true && base_map[info.row][info.col+1] != '#'){\n\t\t\tif(visited_E == false && is_num(info.row,info.col+1) == true){\n\t\t\t\tresult_E += base_map[info.row][info.col+1]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|0;\n\t\t\tif(dp[info.row][info.col+1][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_E){\n\t\t\t\tdp[info.row][info.col+1][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_E;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col+1,info.back_count,info.moved_count+1,info.sum+result_E,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//下へ\n\t\tif(rangeCheck(info.row+1,info.col) == true && base_map[info.row+1][info.col] != '#'){\n\t\t\tif(visited_S == false && is_num(info.row+1,info.col) == true){\n\t\t\t\tresult_S += base_map[info.row+1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|1;\n\t\t\tif(dp[info.row+1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_S){\n\t\t\t\tdp[info.row+1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_S;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row+1,info.col,info.back_count,info.moved_count+1,info.sum+result_S,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\tif(info.back_count == K)continue;\n\n\t\t//左へ\n\t\tif(rangeCheck(info.row,info.col-1) == true && base_map[info.row][info.col-1] != '#'){\n\t\t\tif(visited_W == false && is_num(info.row,info.col-1) == true){\n\t\t\t\tresult_W += base_map[info.row][info.col-1]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|2;\n\t\t\tif(dp[info.row][info.col-1][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_W){\n\t\t\t\tdp[info.row][info.col-1][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_W;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col-1,info.back_count+1,info.moved_count+1,info.sum+result_W,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//上へ\n\t\tif(rangeCheck(info.row-1,info.col) == true && base_map[info.row-1][info.col] != '#'){\n\t\t\tif(visited_N == false && is_num(info.row-1,info.col) == true){\n\t\t\t\tresult_N += base_map[info.row-1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|3;\n\t\t\tif(dp[info.row-1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_N){\n\t\t\t\tdp[info.row-1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_N;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row-1,info.col,info.back_count+1,info.moved_count+1,info.sum+result_N,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\tfor(int state = 0; state < POW[6]; state++){\n\t\tfor(int count = 4; count <= 6; count++){\n\t\t\tans = max(ans,dp[H-1][W-1][K][count][state]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define INF 1234567890\n\nint map[60][60];\nchar buf;\nint x_max, y_max, can;\nint ans = 0;\n\nint dp(int x, int y, int can){\n\tif (map[x][y] == -1) return 0;\n\tint before = map[x][y];\n\tint answer = -1;\n\tmap[x][y] = 0;\n\tif (map[x][y - 1] >= 0 && can >= 1) answer = max(answer, dp(x, y - 1, can - 1) + before);\n\tif (map[x][y + 1] >= 0) answer = max(answer, dp(x, y + 1, can) + before);\n\tif (map[x - 1][y] >= 0 && can >= 1) answer = max(answer, dp(x - 1, y, can - 1) + before);\n\tif (map[x + 1][y] >= 0) answer = max(answer, dp(x + 1, y, can) + before);\n\tmap[x][y] = before;\n\tif (x == x_max && y == y_max) return answer + before;\n\telse{\n\t\tif (answer == -1) return -INF;\n\t}\n\treturn answer;\n}\n\nint main(){\n\tmemset(map, 255, sizeof(map));\n\tscanf(\"%d%d%d\", &x_max, &y_max, &can);\n\tfor (int a = 1; a <= x_max; a++){\n\t\tfor (int b = 1; b <= y_max; b++){\n\t\t\tscanf(\" %c\", &buf);\n\t\t\tswitch (buf){\n\t\t\tcase '.':\n\t\t\t\tmap[a][b] = 0;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tmap[a][b] = -1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmap[a][b] = (int)buf - (int)'0';\n\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp(1, 1, can));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define INF 1234567890\n\nint map[60][60];\n\tchar buf;\n\tint x_max, y_max, can;\n\tint ans = 0;\n\nint dp(int x, int y, int can){\n\tif (can < 0) return 0;\n\tif (x == x_max && y == x_max) return 0;\n\tif (map[x][y] == -1) return 0;\n\tint before = map[x][y];\n\tint ans = 0;\n\tmap[x][y] = 0;\n\tif (map[x][y - 1] != 0) ans = max(ans, before + dp(x, y - 1, can - 1));\n\tif (map[x][y + 1] != 0) ans = max(ans, before + dp(x, y + 1, can));\n\tif (map[x - 1][y] != 0) ans = max(ans, before + dp(x - 1, y, can - 1));\n\tif (map[x + 1][y] != 0) ans = max(ans, before + dp(x + 1, y, can));\n\tmap[x][y] = before;\n\treturn ans;\n}\n\nint main(){\n\tmemset(map, 255, sizeof(map));\n\tscanf(\"%d%d%d\", &x_max, &y_max, &can);\n\tfor (int a = 1; a <= x_max; a++){\n\t\tfor (int b = 1; b <= y_max; b++){\n\t\t\tscanf(\" %c\", &buf);\n\t\t\tswitch (buf){\n\t\t\tcase '.':\n\t\t\t\tmap[a][b] = 0;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tmap[a][b] = -1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmap[a][b] = (int)buf - (int)'0';\n\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp(1, 1, can));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 60\n#define MAX_K 3\n#define MAX_D 6\n#define MAX_C 4096\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\nint dp[MAX_N][MAX_N][MAX_K + 1][MAX_C];\nint x[MAX_N][MAX_N];\nint h, w, K, a;\nchar c;\nchar T[12] = \".123456789#\";\nint b[MAX_N][MAX_N];\nint gx[6], gy[6];\n\nint hantei(int p, int q, vector<int>r) {\n\tint v = p, w = q;\n\tfor (int o = 5; o >= 0; o--) {\n\t\tv -= dy[r[o]];\n\t\tw -= dx[r[o]];\n\t\tgy[o] = v; gx[o] = w;\n\t}\n\tfor (int o = 0; o <= 5; o++) {\n\t\tif (p == gy[o] && q == gx[o]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint DP() {\n\tint X, Y, F, G, H, dir[6], maxn;\n\n\t//zentansaku(first 6)\n\tfor (int i = 0; i < 4096; i++) {\n\t\tmemset(b, 0, sizeof(b));\n\t\tX = 1; Y = 1;\n\t\tF = x[1][1]; G = 0; b[Y][X] = 1;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\ta = (i / (int)pow(4, j)) % 4;\n\t\t\tX += dx[a]; Y += dy[a];\n\t\t\tif (x[Y][X] == 10) {\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif (a == 2 || a == 3) {\n\t\t\t\tG++;\n\t\t\t}\n\t\t\tif (b[Y][X] == 0) {\n\t\t\t\tF += x[Y][X];\n\t\t\t}\n\t\t\tb[Y][X] = 1;\n\t\t}\n\t\tif (G <= K) {\n\t\t\tdp[Y][X][G][i] = F;\n\t\t}\n\tE:;\n\t}\n\n\t//dp.\n\tfor (int i = 0; i < K; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tfor (int k = 1; k <= w; k++) {\n\t\t\t\tif (x[j][k] <= 9) {\n\n\t\t\t\t\tfor (int l = 0; l <= K; l++) {\n\t\t\t\t\t\tfor (int m = 0; m < MAX_C; m++) {\n\t\t\t\t\t\t\tif (dp[j][k][l][m] >= 0) {\n\n\t\t\t\t\t\t\t\tfor (int n = 0; n < 6; n++) {\n\t\t\t\t\t\t\t\t\tdir[n] = (m / (int)pow(4, n)) % 4;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (l < K) {\n\t\t\t\t\t\t\t\t\tif (x[j - 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 2048;\n\t\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],2 };\n\t\t\t\t\t\t\t\t\t\tif (hantei(j - 1, k, A) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j - 1][k];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tX = j; Y = k;\n\n\t\t\t\t\t\t\t\t\t\tdp[j - 1][k][l + 1][a] = max(dp[j - 1][k][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (x[j][k - 1] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 3072;\n\t\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],3 };\n\n\t\t\t\t\t\t\t\t\t\tif (hantei(j, k - 1, A) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j][k - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tdp[j][k - 1][l + 1][a] = max(dp[j][k - 1][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j + 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],0 };\n\n\t\t\t\t\t\t\t\t\tif (hantei(j + 1, k, A) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j + 1][k];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j + 1][k][l][a] = max(dp[j + 1][k][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j][k + 1] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ta += 1024;\n\n\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],1 };\n\n\t\t\t\t\t\t\t\t\tif (hantei(j, k + 1, A) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j][k + 1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j][k + 1][l][a] = max(dp[j][k + 1][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmaxn = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tfor (int j = 0; j < MAX_C; j++) {\n\t\t\tmaxn = max(maxn, dp[h][w][i][j]);\n\t\t}\n\t}\n\treturn maxn;\n}\n\nint main() {\n\t//shokika.\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_K; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_C; l++) {\n\t\t\t\t\tdp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tx[i][j] = 10;\n\t\t}\n\t}\n\t//cin.\n\tcin >> h >> w >> K;\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tcin >> c;\n\t\t\tfor (int k = 0; k < 11; k++) {\n\t\t\t\tif (c == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[50][50][1<<12][4];\nchar str[50][51];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<b;j++)\n\t\t\tif(str[i][j]=='.')str[i][j]='0';\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<b;j++)\n\t\t\tfor(int k=0;k<(1<<12);k++)\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tdp[i][j][k][l]=-99999999;\n\tdp[0][0][0][c]=0;\n\tfor(int i=c;i>=0;i--){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tfor(int l=0;l<(1<<12);l++){\n\t\t\t\t\tif(dp[j][k][l][i]<0)continue;\n\t\t\t\t\tint R;\n\t\t\t\t\tint W;\n\t\t\t\t\tbool ok;\n\t\t\t\t\tif(j<a-1&&str[j+1][k]!='#'){\n\t\t\t\t\t\tR=0;W=0;ok=true;\n\t\t\t\t\t\tfor(int m=0;m<6;m++){\n\t\t\t\t\t\t\tR-=dx[(l>>(m*2))&3];\n\t\t\t\t\t\t\tW-=dy[(l>>(m*2))&3];\n\t\t\t\t\t\t\tif(R==1&&W==0)ok=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\tdp[j+1][k][(l<<2)&((1<<12)-1)][i]=max(dp[j][k][l][i]+str[j+1][k]-'0',dp[j+1][k][(l<<2)&((1<<12)-1)][i]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[j+1][k][(l<<2)&((1<<12)-1)][i]=max(dp[j][k][l][i],dp[j+1][k][(l<<2)&((1<<12)-1)][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(k<b-1&&str[j][k+1]!='#'){\n\t\t\t\t\t\tR=0;W=0;ok=true;\n\t\t\t\t\t\tfor(int m=0;m<6;m++){\n\t\t\t\t\t\t\tR-=dx[(l>>(m*2))&3];\n\t\t\t\t\t\t\tW-=dy[(l>>(m*2))&3];\n\t\t\t\t\t\t\tif(R==0&&W==1)ok=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\tdp[j][k+1][((l<<2)+1)&((1<<12)-1)][i]=max(dp[j][k][l][i]+str[j][k+1]-'0',dp[j][k+1][((l<<2)+1)&((1<<12)-1)][i]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[j][k+1][((l<<2)+1)&((1<<12)-1)][i]=max(dp[j][k][l][i],dp[j][k+1][((l<<2)+1)&((1<<12)-1)][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j&&str[j-1][k]!='#'&&i){\n\t\t\t\t\t\tR=0;W=0;ok=true;\n\t\t\t\t\t\tfor(int m=0;m<6;m++){\n\t\t\t\t\t\t\tR-=dx[(l>>(m*2))&3];\n\t\t\t\t\t\t\tW-=dy[(l>>(m*2))&3];\n\t\t\t\t\t\t\tif(R==-1&&W==0)ok=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\tdp[j-1][k][((l<<2)+2)&((1<<12)-1)][i-1]=max(dp[j][k][l][i]+str[j-1][k]-'0',dp[j-1][k][((l<<2)+2)&((1<<12)-1)][i-1]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[j-1][k][((l<<2)+2)&((1<<12)-1)][i-1]=max(dp[j][k][l][i],dp[j-1][k][((l<<2)+2)&((1<<12)-1)][i-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(k&&str[j][k-1]!='#'&&i){\n\t\t\t\t\t\tR=0;W=0;ok=true;\n\t\t\t\t\t\tfor(int m=0;m<6;m++){\n\t\t\t\t\t\t\tR-=dx[(l>>(m*2))&3];\n\t\t\t\t\t\t\tW-=dy[(l>>(m*2))&3];\n\t\t\t\t\t\t\tif(R==0&&W==-1)ok=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\tdp[j][k-1][((l<<2)+3)&((1<<12)-1)][i-1]=max(dp[j][k][l][i]+str[j][k-1]-'0',dp[j][k-1][((l<<2)+3)&((1<<12)-1)][i-1]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[j][k-1][((l<<2)+3)&((1<<12)-1)][i-1]=max(dp[j][k][l][i],dp[j][k-1][((l<<2)+3)&((1<<12)-1)][i-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=0;\n\tfor(int i=0;i<=c;i++)\n\t\tfor(int j=0;j<(1<<12);j++)ret=max(ret,dp[a-1][b-1][j][i]);\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n#define INF (1 << 30)\n#define all ((1 << 12) - 1)\n\nint xs[] = {0, -1, 0, 1}, ys[] = {-1, 0, 1, 0};\nint h, w, k;\nint dp[52][52][4][1 << 12];\nstring port[52];\n\nbool back(int last){\n    int p = 0, q = 0;\n    for(int i = 0;i < 6;i++){\n\tp += xs[last % 4];\n\tq += ys[last % 4];\n\tif(p == 0 && q == 0)return true;\n\tlast >>= 2;\n    }\n    return false;\n}\n\nint solve(int x, int y, int d, int last){\n    if(x == 0 && y == 0 && d == 0)return 0;\n    if(x < 0 || x >= h || y < 0 || y >= w || d < 0)return -INF;\n    if(dp[x][y][d][last] != -INF)return dp[x][y][d][last];\n    if(port[x][y] == '#')return -INF;\n    int add = 0, res = -INF;\n    if(port[x][y] != '.' && !back(last))add = port[x][y] - '0';\n    for(int i = 0;i < 4;i++){\n\tx += xs[i];y += ys[i];\n\tif(i == 2)d--;\n\tres = max(res, solve(x, y, d, all & ((last << 2) + i)));\n\tx -= xs[i];y -= ys[i];\t   \n    }\n       d++;\n    return dp[x][y][d][last] = res + add;\n}\n\nint main(){\n    cin >> h >> w >> k;\n    for(int i = 0;i < h;i++){\n\tcin >> port[i];\n\tfor(int j = 0;j < w;j++){\n\t    for(int k = 0;k <= 3;k++){\n\t\tfill(dp[i][j][k], dp[i][j][k] + (1 << 12), -INF);\n\t    }\n\t}\n    }\n    int res = -INF;\n    for(int i = 0;i <= k;i++){\n\tres = max(res, solve(h - 1, w - 1, i, 0));\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\nint h,w,K;\nstring str;\nint fie[100][100];\nshort dp[51][51][4][1<<12+1];\nint res=0;\n\nshort dfs(int x,int y,int k,int bit,int pc){\n\tint nx=x,ny=y;\n\tif(dp[x][y][k][bit]!=-1)return dp[x][y][k][bit];\n\t\n\t//11nx++,10nx--,01ny++,00ny--;\n\tint nbit=bit;\n\tif(nbit >>11 & 1)nbit-=1<<11;\n\tif(nbit >>10 & 1)nbit-=1<<10;\n\tnbit<<=2;\n\tshort r=-20000;\n\tif(k>=1){\n\t\tnbit+=2;\n\t\tx--;\n\t\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\t\tr=max(r,dfs(x,y,k-1,nbit,pc+1));\n\t\t}\n\t\tx++;\n\t\ty--;\n\t\tnbit-=2;\n\t\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\t\tr=max(r,dfs(x,y,k-1,nbit,pc+1));\n\t\t}\n\t\ty++;\n\t}\n\tnbit+=3;\n\tx++;\n\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\tr=max(r,dfs(x,y,k,nbit,pc+1));\n\t}\n\tx--;\n\tnbit-=2;\n\ty++;\n\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\tr=max(r,dfs(x,y,k,nbit,pc+1));\n\t}\n\ty--;\n\t\n\tint sum=0;\n\tbool f=false;\n\tfor(int i=0;i<min(pc,6);i++){\n\t\tif(bit >>i*2 & 1){\n\t\t\tif(bit >>(i*2+1) & 1)nx--;\n\t\t\telse ny--;\n\t\t}else{\n\t\t\tif(bit >>(i*2+1) & 1)nx++;\n\t\t\telse ny++;\n\t\t}\n\t\tif(nx==x && ny==y){\n\t\t\tf=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f)sum+=fie[x][y];\n\t\n\tif(r<0 && x==w-1 && y==h-1)r=0;\n\treturn (dp[x][y][k][bit]=sum+r);\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&h,&w,&K);\n\tmemset(fie,-1,sizeof(fie));\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i=0;i<h;i++){\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]=='.')fie[j][i]=0;\n\t\t\telse if(str[j]=='#')fie[j][i]=-1;\n\t\t\telse fie[j][i]=str[j]-'0';\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dfs(0,0,K,0,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define INF -(1 << 23)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint main()\n{\n\tint H, W, K;\n\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &K);\n\n\tvector<string> M(H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tcin >> M[i];\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (M[i][j] == '.')\n\t\t\t{\n\t\t\t\tM[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<vector<vector<int> > > > dp(H, vector<vector<vector<int> > >(W, vector<vector<int> >(K + 1, vector<int>(64, INF))));\n\n\tdp[0][0][0][0] = 0;\n\n\tfor (int rep = 0; rep <= K; rep++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= K; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < 64; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint dir = l % 4;\n\n\t\t\t\t\t\t\tif ((0 <= j + dx[dir] && j + dx[dir] < W && 0 <= i + dy[dir] && i + dy[dir] < H) && !(!(dir % 3) && K != 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint r = m * 16 + l / 4;\n\n\t\t\t\t\t\t\t\t\tif (dir % 3)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k][r]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k - 1][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = -1;\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tfor (int j = 0; j < 64; j++)\n\t\t{\n\t\t\tret = max(ret, dp[H - 1][W - 1][i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint h,w,k,mask;\nint dp[50][50][1<<12][4];\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nchar mp[51][51];\nbool visit[1<<12];\n\nint dfs(int x,int y,int bit,int lk){\n    int pt=0,mx=-25000;\n    if(dp[x][y][bit][lk]!=-1) return dp[x][y][bit][lk];\n    if(x==w-1&&y==h-1&&lk==0) return 0;\n    if(!visit[bit]&&mp[y][x]!='.') pt +=mp[y][x]-'0';\n    for(int i=0;i<4;++i){\n        if(lk==0&&i>1) break;\n        int tx=x+dx[i],ty=y+dy[i],nbit=((bit<<2)|i)&mask,uk=i>1?lk-1:lk;\n        if(tx>=0&&ty>=0&&tx<w&&ty<h&&mp[ty][tx]!='#') mx=max(mx,dfs(tx,ty,nbit,uk)+pt);\n    }\n    dp[x][y][bit][lk]=mx;\n    return mx;\n}\n\nint main(){\n    cin>>h>>w>>k;\n    for(int i=0;i<h;++i){\n        for(int j=0;j<w;++j) cin>>mp[i][j];\n    }\n    memset(dp,-1,sizeof(dp));\n    mask=(1<<2*2*k)-1;\n    for(int i=0;i<=mask;++i){\n        int tx=0,ty=0,pre=i;\n        for(int j=0;j<2*k;++j){\n            tx -=dx[pre&3];ty -=dy[pre&3];\n            if(tx==0&&ty==0) visit[i]=true;\n            pre >>=2;\n        }\n    }\n    cout<<dfs(0,0,0,k)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 52;\nconst int dx[] = {1,0,0,-1};\nconst int dy[] = {0,1,-1,0};\nint c[MAX_N][MAX_N];\n\nint H,W,K;\nint ans;\n\nvoid search(int f,int s,int k,int res,set<P> v)\n{\n\tif(f==H-1 && s==W-1 && k==K){\n\t\tans = max(ans,res);\n\t\treturn;\n\t}\n\tif(c[f][s]>0){\n\t\tif(v.find(P(f,s)) == v.end()){\n\t\t\tres += c[f][s];\n\t\t\tv.insert(P(f,s));\n\t\t}\n\t}\n\trep(i,2){\n\t\tint ff = f + dy[i];\n\t\tint ss = s + dx[i];\n\t\tif(0<=ff&&ff<=H-1&&0<=ss&&ss<=W-1){\n\t\t\tif(c[ff][ss]>=0){\n\t\t\t\tsearch(ff,ss,k,res,v);\n\t\t\t}\n\t\t}\n\t}\n\tif(k<K){\n\t\tfor(int i=2;i<4;i++){\n\t\t\tint ff = f + dy[i];\n\t\t\tint ss = s + dx[i];\n\t\t\tif(0<=ff&&ff<=H-1&&0<=ss&&ss<=W-1){\n\t\t\t\tif(c[ff][ss]>=0){\n\t\t\t\t\tsearch(ff,ss,k+1,res,v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tchar a;\n\tset<P> visited;\n\tscanf(\"%d%d%d\",&H,&W,&K);\n\trep(i,H){\n\t\tscanf(\"%c\",&a);\n\t\trep(j,W){\n\t\t\tscanf(\"%c\",&a);\n\t\t\tif(a=='.'){\n\t\t\t\tc[i][j] = 0;\n\t\t\t}else if(a=='#'){\n\t\t\t\tc[i][j] = -1;\n\t\t\t}else{\n\t\t\t\tc[i][j] = (int)(a-'0');\n\t\t\t}\n\t\t}\n\t}\n\tans = 0;\n\tsearch(0,0,0,0,visited);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tEast,\n\tSouth,\n\tWest,\n\tNorth,\n};\n\nint H,W,K;\nint POW[7];\nint dp[50][50][4][1024]; //dp[row][col][Kの残数][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint makeCode(Type move_log[6]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < 6; i++){\n\t\tret += move_log[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\nbool is_num(int row,int col){\n\treturn base_map[row][col] >= '1' && base_map[row][col] <= '9'; //0の土産物屋はない\n}\n\nint recursive(int row,int col,int back_count,Type move_log[6],int moved_count){ //moved_log[]:インデックスが小さいほど新しい(右シフト)\n\n\tint tmp_code = makeCode(move_log);\n\tif(dp[row][col][back_count][tmp_code] != -1)return dp[row][col][back_count][tmp_code]; //計算済ならreturn\n\n\tType next_move_log[4][6];\n\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t//過去の移動ログから、訪問済のマス情報を特定する\n\tint tmp_row = row,tmp_col = col;\n\n\tfor(int i = 0; i < min(moved_count,6); i++){\n\t\tswitch(move_log[i]){ //ログを打ち消す方向に動く\n\t\tcase East:\n\t\t\ttmp_col--;\n\t\t\tbreak;\n\t\tcase South:\n\t\t\ttmp_row--;\n\t\t\tbreak;\n\t\tcase West:\n\t\t\ttmp_col++;\n\t\t\tbreak;\n\t\tcase North:\n\t\t\ttmp_row++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(tmp_row == row && tmp_col == col+1){ //右のマスと一致\n\t\t\tvisited_E = true;\n\t\t}else if(tmp_row == row+1 && tmp_col == col){ //下のマスと一致\n\t\t\tvisited_S = true;\n\t\t}else if(tmp_row == row && tmp_col == col-1){ //左のマスと一致\n\t\t\tvisited_W = true;\n\t\t}else if(tmp_row == row-1 && tmp_col == col){ //上のマスと一致\n\t\t\tvisited_N = true;\n\t\t}\n\t}\n\n\t//次の移動ログを作る\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int k = 0; k < 5; k++){\n\t\t\tnext_move_log[i][k+1] = move_log[k]; //右に1つシフト\n\t\t}\n\t\tswitch(i){\n\t\tcase 0:\n\t\t\tnext_move_log[i][0] = East;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnext_move_log[i][0] = South;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnext_move_log[i][0] = West;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tnext_move_log[i][0] = North;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//右へ\n\tif(rangeCheck(row,col+1) == true && base_map[row][col+1] != '#'){\n\t\tif(visited_E == false && is_num(row,col+1) == true){\n\t\t\tresult_E += base_map[row][col+1]-'0';\n\t\t}\n\t\tresult_E += recursive(row,col+1,back_count,next_move_log[East],moved_count+1);\n\t}\n\n\t//下へ\n\tif(rangeCheck(row+1,col) == true && base_map[row+1][col] != '#'){\n\t\tif(visited_S == false && is_num(row+1,col) == true){\n\t\t\tresult_S += base_map[row+1][col]-'0';\n\t\t}\n\t\tresult_S += recursive(row+1,col,back_count,next_move_log[South],moved_count+1);\n\t}\n\n\tif(back_count == K){ //もう左にも上にも移動できない場合\n\n\t\treturn dp[row][col][back_count][tmp_code] = max(result_E,result_S);\n\t}\n\n\t//左へ\n\tif(rangeCheck(row,col-1) == true && base_map[row][col-1] != '#'){\n\t\tif(visited_W == false && is_num(row,col-1) == true){\n\t\t\tresult_W += base_map[row][col-1]-'0';\n\t\t}\n\t\tresult_W += recursive(row,col-1,back_count+1,next_move_log[West],moved_count+1);\n\t}\n\n\t//上へ\n\tif(rangeCheck(row-1,col) == true && base_map[row-1][col] != '#'){\n\t\tif(visited_N == false && is_num(row-1,col) == true){\n\t\t\tresult_N += base_map[row-1][col]-'0';\n\t\t}\n\t\tresult_N += recursive(row-1,col,back_count+1,next_move_log[North],moved_count+1);\n\t}\n\n\treturn dp[row][col][back_count][tmp_code] = max(max(result_E,result_S),max(result_W,result_N)); //最大の結果を選ぶ\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++)POW[i] = pow(4,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= K; i++){\n\t\t\t\tfor(int state = 0; state < POW[6]; state++)dp[row][col][i][state] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tType first_log[6];\n\tfor(int i = 0; i < 6; i++)first_log[i] = East;\n\n\tprintf(\"%d\\n\",recursive(0,0,0,first_log,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint dp[4][4][50][50][1<<10];\nvoid decode(int u, int a[4][4])\n{\n\tint b=1;\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;i+j<4;j++){\n\t\t\ta[i][j]=(u&b)?1:0;\n\t\t\tb<<=1;\n\t\t}\n\t}\n}\nint encode(int a[4][4]){\n\tint ret=0;\n\tint b=1;\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;i+j<4;j++){\n\t\t\tif(a[i][j]){\n\t\t\t\tret|=b;\n\t\t\t}\n\t\t\tb<<=1;\n\t\t}\n\t}\n\treturn ret;\n}\nvoid down(int a[4][4]){\n\tfor(int i=3;i>=0;i--){\n\t\tfor(int j=0;i+j<4;j++){\n\t\t\tif(0<=i-1){\n\t\t\t\ta[i][j]=a[i-1][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid right(int a[4][4]){\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=3-i;j>=0;j--){\n\t\t\tif(0<=j-1){\n\t\t\t\ta[i][j]=a[i][j-1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nint H,W,K;\nchar in[50][51];\nint main() {\n\tscanf(\"%d%d%d\",&H,&W,&K);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",in[i]);\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0][0][0][0][0]=0;\n\tint ret=0;\n\tfor(int i=0;i<=K;i++){\n\t\tfor(int j=0;i+j<=K;j++){\n\t\t\tfor(int x=0;x<H;x++){\n\t\t\t\tfor(int y=0;y<W;y++){\n\t\t\t\t\tint dx=1;\n\t\t\t\t\tint dy=0;\n\t\t\t\t\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\t\t\t\t\tif(x+dx<0||H<=x+dx||y+dy<0||W<=y+dy||in[x+dx][y+dy]=='#'){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dx<0||dy<0){\n\t\t\t\t\t\t\tif(i-dx>K||j-dy>K){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int u=0;u<1<<10;u++){\n\t\t\t\t\t\t\tif(dp[i][j][x][y][u]==-1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//cout << i << \", \" << j << \", \" << x << \", \" << y << \", \" << u << \": \" << dp[i][j][x][y][u] << \", \" << in[x][y] << endl;\n\t\t\t\t\t\t\tint a[4][4]={};\n\t\t\t\t\t\t\tdecode(u,a);\n\t\t\t\t\t\t\tint v=dp[i][j][x][y][u];\n\t\t\t\t\t\t\tif(a[i][j]==0&&in[x][y]!='.'){\n\t\t\t\t\t\t\t\tv+=in[x][y]-'0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ta[i][j]=1;\n\t\t\t\t\t\t\tint ii=i;\n\t\t\t\t\t\t\tint jj=j;\n\t\t\t\t\t\t\tif(dx>0){\n\t\t\t\t\t\t\t\tdown(a);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(dy>0){\n\t\t\t\t\t\t\t\tright(a);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(dx<0){\n\t\t\t\t\t\t\t\tii++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(dy<0){\n\t\t\t\t\t\t\t\tjj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint b=encode(a);\n\t\t\t\t\t\t\tdp[ii][jj][x+dx][y+dy][b]=max(dp[ii][jj][x+dx][y+dy][b],v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int u=0;u<1<<10;u++){\n\t\t\t\tret=max(ret,dp[i][j][H-1][W-1][u]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n  \nusing namespace std;\n  \n//#define int long long\n#define PB push_back\n#define MK make_pair\n#define MKT make_tuple\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n  \n//constexpr int INF = 1LL<<60;\nconstexpr int INF = 1 << 28;\n//constexpr int MOD = 100000;\nconstexpr int MAX_N = 52;\nconstexpr int dx[] = { 1, 0, -1, 0 };\nconstexpr int dy[] = { 0, 1, 0, -1 };\n  \nint mem[MAX_N][MAX_N][4][1 << 6][1 << 6], h, w, k, fld[MAX_N][MAX_N];\n  \ninline bool Chk(int x, int y, int mask1, int mask2) {\n    constexpr int len = 6;\n    int cx = x, cy = y;\n    for (int i = 0; i < len; ++i) {\n        int b1 = mask1 & (1 << (len - 1 - i)) ? 1 : 0, b2 = mask2 & (1 << (len - 1 - i)) ? 1 : 0;\n        int idx = b1 + 2 * b2;\n        cx -= dx[idx];\n        cy -= dy[idx];\n        if (x == cx && y == cy) {\n            return true;\n        }\n    }\n    return false;\n}\n  \nint Solve(int x, int y, int c, int mask1, int mask2) {\n    if (x == w + 1 && y == h) return 0;\n    if (mem[x][y][c][mask1][mask2] != -1) return mem[x][y][c][mask1][mask2];\n   \n    int cur = Chk(x, y, mask1, mask2) ? 0 : fld[x][y];\n    int res = 0;\n    for (int i = 0; i < 4; ++i) {\n        if (1 < i && k <= c) break;\n        int tx = x + dx[i], ty = y + dy[i];\n        int nc = (1 < i) ? c + 1 : c;\n        if (fld[tx][ty] == -1) continue;\n          \n        int nm1 = (mask1 >> 1) + ((i % 2) << 5), nm2 = (mask2 >> 1) + ((1 < i) << 5);\n        res = max(res, Solve(tx, ty, nc, nm1, nm2));\n    }\n      \n    return mem[x][y][c][mask1][mask2] = res + cur;\n}\n  \nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n  \n    memset(fld, -1, sizeof(fld));\n    cin >> h >> w >> k;\n    for (int y = 1; y <= h; ++y) {\n        string s;\n        cin >> s;\n        for (int x = 1; x <= w; ++x) {\n            char c = s[x - 1];\n            if (c == '#') {\n                fld[x][y] = -1;\n                continue;\n            } else if (c == '.') {\n                fld[x][y] = 0;\n                continue;\n            }\n            fld[x][y] = c - '0';\n        }\n    }\n    fld[w + 1][h] = 0;\n    memset(mem, -1, sizeof(mem));\n    cout << Solve(1, 1, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007\n#define INF 1000000000\n#define LLINF 2000000000000000000LL\n\n#define SIZE 500000\n\n#define MAX_H 100\n#define MAX_W 100\n\nint H,W,K;\nchar mm[50][51];\n\nint memo[50][50][1<<12][4];\n\nint mo[5]={0,-1,0,1,0};\n\nint dfs(int y,int x,int visit,int k,int h=0){\n    int ret = -INF;\n    bool visit_mm[50][50] = {0};\n    \n    //cerr << \"(\" << y << \",\" << x << \")\" << endl;\n    \n    if(memo[y][x][visit][k] != 0) return memo[y][x][visit][k];\n    \n    if(y==H-1 && x==W-1 && k==0) return 0;\n    \n    int after_visit = (visit%(1<<10));\n    int after_x = x,after_y = y;\n    int calc_visit = visit;\n    \n    vector<pair<int,int> > vec;\n    \n    for(int i=0;i<min(h,6);i++){\n        after_x -= mo[calc_visit%4];\n        after_y -= mo[calc_visit%4+1];\n        calc_visit/=4;\n        visit_mm[after_y][after_x] = true;\n        \n        //cerr << \"<- (\" << after_y << \",\" << after_x << \")\" << endl;\n    }\n    \n    int add = 1;\n    \n    for(int i=0;i<4;i++){\n        if(k>=1 || i>=2){\n            int to_x = x+mo[i];\n            int to_y = y+mo[i+1];\n            \n            if(to_x<0 || W<=to_x || to_y<0 || H<=to_y || mm[to_y][to_x]=='#') continue;\n            \n            if(visit_mm[to_y][to_x]) add = 0;\n            else add = mm[to_y][to_x]-'0';\n            \n            ret = max(ret,dfs(to_y,to_x,after_visit*4+i,k-(i<=1),h+1)+add);\n        }\n    }\n    \n    return memo[y][x][visit][k] = ret;\n    \n}\n\nint main(){\n    \n    scanf(\"%d%d%d\",&H,&W,&K);\n    \n    for(int i=0;i<H;i++){\n        scanf(\"%s\",mm[i]);\n    }\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(mm[i][j]=='.') mm[i][j] = '0';\n        }\n    }\n    \n    printf(\"%d\\n\",dfs(0,0,0,K));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nchar a[50][50];\nint dp[50][50][4][1<<11];\nint bitMap[4][1<<11][4];\nbool canGet[4][1<<11][4];\nvector<pii> needCells[4];\n\nconst int dy[4] = {0,1,0,-1};\nconst int dx[4] = {1,0,-1,0};\n\nint h,w,K;\n\nint solve(int y, int x, int k, int S){\n  int &r = dp[y][x][k][S];\n  if (r >= 0) return r;\n  int res = 0;\n  REP(d,4) {\n    int nk = k+(d>=2);\n    if (nk>K) continue;\n    int ny = y+dy[d];\n    int nx = x+dx[d];\n    if (!valid(ny,nx,h,w)) continue;\n    if (a[ny][nx] == '#') continue;\n    int score = canGet[k][S][d]&&isdigit(a[ny][nx]) ? a[ny][nx]-'0' : 0;\n    chmax(res, solve(ny,nx,nk,bitMap[k][S][d]) + score);\n  }\n  // cout << y << \" \" << x << \" \" << k << \" \";\n  // REP(i,needCells[k].size()) {\n  //   if (S>>i&1) {\n  //     pii p = needCells[k][i];\n  //     cout << \"(\" << p.first << \",\" << p.second << \")\";\n  //   }\n  // }\n  // cout << \" \" << res << endl;\n  return r = res;\n}\n\nint main() {\n  REP(k,4) {\n    for (int y=-3; y<=3; ++y) {\n      for (int x=-3; x<=3; ++x) {\n        if ((y||x) && -min(y,0)-min(x,0) <= 3-k && max(0,y)+max(0,x) <= k)\n          needCells[k].push_back(pii(y,x));\n      }\n    }\n  }\n  REP(k,4) {\n    int n = needCells[k].size();\n    REP(S,1<<n) {\n      REP(d,4) {\n        int nk = k+(d>=2);\n        if (nk == 4) continue;\n        int T = 0;\n        REP(i,n) {\n          if (S>>i&1) {\n            pii p = needCells[k][i];\n            p.first -= dy[d];\n            p.second -= dx[d];\n            REP(j,needCells[nk].size()) {\n              if (needCells[nk][j] == p) {\n                T |= 1 << j;\n              }\n            }\n          }\n        }\n        REP(j,needCells[nk].size()) {\n          if (needCells[nk][j] == pii(-dy[d],-dx[d])) {\n            T |= 1 << j;\n          }\n        }\n        bitMap[k][S][d] = T;\n\n        canGet[k][S][d] = 1;\n        REP(i,n)\n          if (S>>i&1 && needCells[k][i]==pii(dy[d],dx[d]))\n            canGet[k][S][d] = 0;\n      }\n    }\n  }\n  while(cin>>h>>w>>K) {\n    REP(i,h) REP(j,w) cin >> a[i][j];\n    memset(dp,-1,sizeof(dp));\n    cout << solve(0,0,0,0) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<deque>\n#include<climits>\nusing namespace std;\n \nconst int dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nconst int MAX_STATE = 1<<12;\nint H,W,K,memo[50][50][4][MAX_STATE],fld[50][50],gifts[2500];\n \nint dfs(int y,int x,int k,int s,deque<int> d){\n    if(k>K) return INT_MIN;\n    if(memo[y][x][k][s]!=INT_MIN) return memo[y][x][k][s];\n    if(y==H-1 && x==W-1) memo[y][x][k][s] = 0;\n    int pls = 0;\n    if(fld[y][x]>=0) pls = gifts[fld[y][x]];\n    for(int i=0;i<d.size();i++){\n        if(d[i]==fld[y][x]) pls = 0;\n    }\n    d.pop_back(); d.push_front(fld[y][x]);\n    int ny,nx;\n    for(int i=0;i<4;i++){\n        ny = y+dy[i]; nx = x+dx[i];\n        if(ny<0 || H<=ny || nx<0 || W<=nx || fld[ny][nx]==-2) continue;\n        int nk = k, ns = (s*4+i)%(1<<12);\n        if(i>=2) nk++;\n        memo[y][x][k][s] = max(memo[y][x][k][s],dfs(ny,nx,nk,ns,d));\n    }\n    return memo[y][x][k][s]+pls;\n}\n \nint main(){\n    fill_n((int*)memo,50*50*4*MAX_STATE,INT_MIN);\n    int cnt = 0;\n    char in;\n    cin>>H>>W>>K;\n    for(int i=0;i<H;i++)for(int j=0;j<W;j++){\n        cin>>in;\n        if(in=='#') fld[i][j] = -2;\n        else if(in=='.') fld[i][j] = -1;\n        else fld[i][j] = cnt, gifts[cnt++] = in-'0';\n    }\n    deque<int> d(6,-3);\n    printf(\"%d\\n\",dfs(0,0,0,0,d));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint w, h, k;\nchar field[60][60];\n\nstruct State {\n  int x;\n  int y;\n  int k;\n  int score;\n  vector<short> prev;\n  State() : prev(6, -1) {;}\n  State(int x, int y, int k, int score)\n    : x(x), y(y), k(k), score(score), prev(6, -1) {;}\n  State(int x, int y, int k, int score, const vector<short> &prev)\n    : x(x), y(y), k(k), score(score), prev(prev) {;}\n  bool operator<(const State &rhs) const {\n    if (x != rhs.x) { return x < rhs.x; }\n    if (y != rhs.y) { return y < rhs.y; }\n    return prev < rhs.prev;\n  }\n  void Push(int x, int y) {\n    prev.erase(prev.begin());\n    if (field[y][x] != '.') {\n      prev.push_back(y * w + x);\n    } else {\n      prev.push_back(-1);\n    }\n  }\n  bool Exist(int x, int y) {\n    FORIT(it, prev) {\n      if (y * w + x == *it) { return true; }\n    }\n    return false;\n  }\n};\n\nint main() {\n  while (scanf(\"%d %d %d\", &h, &w, &k) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n    }\n    map<State, int> dist;\n    queue<State> que;\n    que.push(State(0, 0, k, 0));\n    int ans = 0;\n    while (!que.empty()) {\n      State s = que.front();\n      que.pop();\n      {\n        map<State, int>::iterator it = dist.find(s);\n        if (it != dist.end() && it->second >= s.score) { continue; }\n      }\n      //if (dist.count(s) && dist[s] >= s.score) { continue; }\n      dist[s] = s.score;\n      //cout << s.x << \" \" << s.y << \" \" << s.k << \" \" << s.score << endl;\n      assert(s.score >= 0);\n      if (s.x == w - 1 && s.y == h - 1) {\n        ans = max(ans, s.score);\n      }\n      const int dx[4] = { 1, 0, -1, 0 };\n      const int dy[4] = { 0, 1, 0, -1 };\n      REP(dir, 4) {\n        int nx = s.x + dx[dir];\n        int ny = s.y + dy[dir];\n        int nk = s.k;\n        if (dir >= 2) { nk--; }\n        if (nx < 0 || nx >= w || ny < 0 || ny >= h ||\n            nk < 0 ||\n            field[ny][nx] == '#') { continue; }\n        State ns(nx, ny, nk, s.score, s.prev);\n        if (field[ny][nx] != '.' && !ns.Exist(nx, ny)) {\n          //cout << ns.Exist(nx, ny) << endl;\n          ns.Push(nx, ny);\n          ns.score += field[ny][nx] - '0';\n          assert(ns.score >= 0);\n        } else {\n          ns.Push(nx, ny);\n        }\n        //if (dist.count(ns) && dist[ns] >= ns.score) { continue; }\n        que.push(ns);\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n\ntypedef pair<int,int> p;\ntypedef tuple<int,int,int,set<p>> mpdata;\ntypedef pair<int,mpdata> pqdata;\n#define mt make_tuple\n#define mp make_pair\n\nmap<mpdata,int> dp;\nconst set<p> null;\n\nint main(){\n\tint h,w,k;\tcin>>h>>w>>k;\n\tvector<string> s(h);\n\trep(i,h){\n\t\tcin>>s[i];\n\t}\n\t\n\tpriority_queue<pqdata> pq;\n\tpq.push(mp(-1,mt(0,0,k,null)));\n\tdp[mt(1,0,k,null)]=0;\n\tint ans=1;\n\t\n\twhile(!pq.empty()){\n\t\tauto it=pq.top();\tpq.pop();\n\t\tint cost=-it.first;\n\t\tint y=get<0>(it.second);\n\t\tint x=get<1>(it.second);\n\t\tint use=get<2>(it.second);\n\t\tauto id=get<3>(it.second);\n\t\t\n\t\tif(cost<dp[mt(y,x,use,id)])\tcontinue;\n\t\t\n\t\tif(x+1==w&&y+1==h&&use==0){\n\t\t\tans=max(ans,cost);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(use>0){\n\t\t\tif(y>0&&s[y-1][x]!='#'){\n\t\t\t\t//up\n\t\t\t\tint nextcost=cost;\n\t\t\t\tauto nextid=id;\n\t\t\t\tif(s[y-1][x]!='.'&&id.find(mp(y-1,x))==id.end()){\n\t\t\t\t\tnextid.insert(mp(y-1,x));\n\t\t\t\t\tnextcost+=s[y-1][x]-'0';\n\t\t\t\t}\n\t\t\t\tauto t=mt(y-1,x,use-1,nextid);\n\t\t\t\tif(nextcost>dp[t]){\n\t\t\t\t\tdp[t]=nextcost;\n\t\t\t\t\tpq.push(mp(-nextcost,t));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(x>0&&s[y][x-1]!='#'){\n\t\t\t\t//left\n\t\t\t\tint nextcost=cost;\n\t\t\t\tauto nextid=id;\n\t\t\t\tif(s[y][x-1]!='.'&&id.find(mp(y,x-1))==id.end()){\n\t\t\t\t\tnextid.insert(mp(y,x-1));\n\t\t\t\t\tnextcost+=s[y][x-1]-'0';\n\t\t\t\t}\n\t\t\t\tauto t=mt(y,x-1,use-1,nextid);\n\t\t\t\tif(nextcost>dp[t]){\n\t\t\t\t\tdp[t]=nextcost;\n\t\t\t\t\tpq.push(mp(-nextcost,t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(y+1<h&&s[y+1][x]!='#'){\n\t\t\t//down\n\t\t\tint nextcost=cost;\n\t\t\tauto nextid=id;\n\t\t\tfor(int i=x-use;i<=x+k-use;i++){\n\t\t\t\tnextid.erase(mp(y-use,i));\n\t\t\t}\n\t\t\tif(s[y+1][x]!='.'&&nextid.find(mp(y+1,x))==nextid.end()){\n\t\t\t\tnextid.insert(mp(y+1,x));\n\t\t\t\tnextcost+=s[y+1][x]-'0';\n\t\t\t}\n\t\t\tauto t=mt(y+1,x,use,nextid);\n\t\t\tif(dp[t]<nextcost){\n\t\t\t\tdp[t]=nextcost;\n\t\t\t\tpq.push(mp(-nextcost,t));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(x+1<w&&s[y][x+1]!='#'){\n\t\t\t//right\n\t\t\tint nextcost=cost;\n\t\t\tauto nextid=id;\n\t\t\tfor(int i=y-use;i<=y+k-use;i++){\n\t\t\t\tnextid.erase(mp(i,x-use));\n\t\t\t}\n\t\t\tif(s[y][x+1]!='.'&&nextid.find(mp(y,x+1))==nextid.end()){\n\t\t\t\tnextid.insert(mp(y,x+1));\n\t\t\t\tnextcost+=s[y][x+1]-'0';\n\t\t\t}\n\t\t\tauto t=mt(y,x+1,use,nextid);\n\t\t\tif(dp[t]<nextcost){\n\t\t\t\tdp[t]=nextcost;\n\t\t\t\tpq.push(mp(-nextcost,t));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 60\n#define MAX_K 3\n#define MAX_D 6\n#define MAX_C 4096\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\nint dp[MAX_N][MAX_N][MAX_K + 1][MAX_C];\nint x[MAX_N][MAX_N];\nint h, w, K, a;\nchar c;\nchar T[12] = \".123456789#\";\nint b[MAX_N][MAX_N];\nint gx[6], gy[6];\nint power[10] = { 1,4,16,64,256,1024,4096,16384,65536,262144 };\n\nint hantei(int p, int q, vector<int>r) {\n\tint v = p, w = q;\n\tfor (int o = 5; o >= 0; o--) {\n\t\tv -= dy[r[o]];\n\t\tw -= dx[r[o]];\n\t\tgy[o] = v; gx[o] = w;\n\t}\n\tfor (int o = 0; o <= 5; o++) {\n\t\tif (p == gy[o] && q == gx[o]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint DP() {\n\tint X, Y, F, G, H, dir[6], maxn;\n\n\t//zentansaku(first 6)\n\tfor (int i = 0; i < 4096; i++) {\n\t\tmemset(b, 0, sizeof(b));\n\t\tX = 1; Y = 1;\n\t\tF = x[1][1]; G = 0; b[Y][X] = 1;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\ta = (i / (int)pow(4, j)) % 4;\n\t\t\tX += dx[a]; Y += dy[a];\n\t\t\tif (x[Y][X] == 10) {\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif (a == 2 || a == 3) {\n\t\t\t\tG++;\n\t\t\t}\n\t\t\tif (b[Y][X] == 0) {\n\t\t\t\tF += x[Y][X];\n\t\t\t}\n\t\t\tb[Y][X] = 1;\n\t\t}\n\t\tif (G <= K) {\n\t\t\tdp[Y][X][G][i] = F;\n\t\t}\n\tE:;\n\t}\n\n\t//dp.\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tfor (int k = 1; k <= w; k++) {\n\t\t\t\tif (x[j][k] <= 9) {\n\n\t\t\t\t\tfor (int l = 0; l <= K; l++) {\n\t\t\t\t\t\tfor (int m = 0; m < MAX_C; m++) {\n\t\t\t\t\t\t\tif (dp[j][k][l][m] >= 0) {\n\n\t\t\t\t\t\t\t\tfor (int n = 0; n < 6; n++) {\n\t\t\t\t\t\t\t\t\tdir[n] = (m / power[n]) % 4;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (l < K) {\n\t\t\t\t\t\t\t\t\tif (x[j - 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += power[n - 1] * dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 2048;\n\t\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],2 };\n\t\t\t\t\t\t\t\t\t\tif (hantei(j - 1, k, A) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j - 1][k];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tX = j; Y = k;\n\n\t\t\t\t\t\t\t\t\t\tdp[j - 1][k][l + 1][a] = max(dp[j - 1][k][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (x[j][k - 1] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += power[n - 1] * dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 3072;\n\t\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],3 };\n\n\t\t\t\t\t\t\t\t\t\tif (hantei(j, k - 1, A) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j][k - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tdp[j][k - 1][l + 1][a] = max(dp[j][k - 1][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j + 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += power[n - 1] * dir[n];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],0 };\n\n\t\t\t\t\t\t\t\t\tif (hantei(j + 1, k, A) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j + 1][k];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j + 1][k][l][a] = max(dp[j + 1][k][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j][k + 1] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += power[n - 1] * dir[n];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ta += 1024;\n\n\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],1 };\n\n\t\t\t\t\t\t\t\t\tif (hantei(j, k + 1, A) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j][k + 1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j][k + 1][l][a] = max(dp[j][k + 1][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmaxn = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tfor (int j = 0; j < MAX_C; j++) {\n\t\t\tmaxn = max(maxn, dp[h][w][i][j]);\n\t\t}\n\t}\n\treturn maxn;\n}\n\nint main() {\n\t//shokika.\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_K; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_C; l++) {\n\t\t\t\t\tdp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tx[i][j] = 10;\n\t\t}\n\t}\n\t//cin.\n\tcin >> h >> w >> K;\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tcin >> c;\n\t\t\tfor (int k = 0; k < 11; k++) {\n\t\t\t\tif (c == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nclass road{\npublic:\n    int dp[1<<10][4];\n    int num;\n    road(){\n        for(int i=0;i<(1<<10);++i){\n            for(int j=0;j<4;++j){\n                dp[i][j]=-1;\n            }\n        }\n    }\n};\nint intmin=1<<31;\nint N,M,K;\nroad **map;\nint mx[]{1,0,-1,0},my[]{0,1,0,-1};\nint search(int,int,int,int);\nusing namespace std;\nint main(){\n    cin>>N>>M>>K;\n    map=new road*[M+1];\n    for(int i=1;i<=M;++i){\n        map[i]=new road[N+1];\n    }\n    char dummy;\n    for(int i=1;i<=N;++i){\n        for(int j=1;j<=M;++j) {\n            cin>>dummy;\n            if(dummy=='#'){\n                map[j][i].num=-1;\n            }else if(dummy=='.'){\n                map[j][i].num=0;\n            }else{\n                map[j][i].num=dummy-'0';\n            }\n        }\n    }\n    cout<<search(1,1,0,K)<<endl;\n    return 0;\n}\nint search(int x,int y,int lo,int k){\n    if(y==0||x==0||y>N||x>M||map[x][y].num==-1)return intmin;\n    if(x==M&&y==N&&k==0)return 0;\n    if(map[x][y].dp[lo][k]>-1)return map[x][y].dp[lo][k];\n    int stock=0;\n    int res=intmin;\n    swap(stock,map[x][y].num);\n    for(int i=0;i<2;++i){\n        res=max(search(x+mx[i],y+my[i],(lo>>2)+(i<<8),k),res);\n    }\n    if(k>0){\n        for(int i=2;i<4;++i) {\n            res=max(res,search(x+mx[i],y+my[i],(lo>>2)+(i<<8),k-1));\n        }\n    }\n    map[x][y].dp[lo][k]=res+stock;\n    swap(stock,map[x][y].num);\n    return map[x][y].dp[lo][k];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\nbool check[1 << 12];\nint H, W, K, dp[50][50][1 << 12];\nchar Gifts[50][50];\n\nint main(){\n\n  cin >> H >> W >> K;\n  const int mask = (1 << (K * 4)) - 1;\n  for(int i = 0; i <= mask; ++i){\n    bool flag = false;\n    int y = 0, x = 0, bit = i;\n    for(int j = 0; j < 2 * K; ++j){\n      y -= dy[bit & 3], x -= dx[bit & 3];\n      if(y == 0 && x == 0){\n        flag = true;\n        break;\n      }\n      bit >>= 2;\n    }\n    check[i] = !flag;\n  }\n\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      cin >> Gifts[i][j];\n    }\n  }\n  fill_n( **dp, 50 * 50 * (1 << 12), -1);\n  // dp[i][j][S]: ( j, i)にいるときの前に訪れる方法Sにおいての最大値\n  dp[0][0][0] = 0;\n  for(int i = K; i >= 0; --i){\n    for(int j = 0; j < H; ++j){\n      for(int k = 0; k < W; ++k){\n        for(int l = 0; l <= mask; ++l){\n          if(dp[j][k][l] == -1) continue;\n          int cost;\n          if(isdigit(Gifts[j][k]) && check[l]) cost = Gifts[j][k] - '0';\n          else cost = 0;\n          for(int m = 0; m < 4; ++m){\n            int ny = j + dy[m], nx = k + dx[m];\n            if((m > 1 && i == 0) || ny < 0 || ny >= H || nx < 0 || nx >= W || Gifts[ny][nx] == '#') continue;\n            int& res = dp[ny][nx][(l << 2 | m) & mask];\n            res = max( res, dp[j][k][l] + cost);\n          }\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i <= mask; ++i){\n    ret = max( ret, dp[H - 1][W - 1][i]);\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[50][51];\n\n#define inv(d) (((d)+2)&3) // opposite direction\n\nint dp[50][50][4][4][4][4][4][4][4];\nint dfs(int i,int j,int k,int d0,int d1,int d2,int d3,int d4,int d5){\n\tint &res=dp[i][j][k][d0][d1][d2][d3][d4][d5];\n\tif(~res) return res;\n\n\tif(i==h-1 && j==w-1) res=0; // goal\n\n\tint y[6],x[6];\n\ty[0]=  i +dy[inv(d0)]; x[0]=  j +dx[inv(d0)];\n\ty[1]=y[0]+dy[inv(d1)]; x[1]=x[0]+dx[inv(d1)];\n\ty[2]=y[1]+dy[inv(d2)]; x[2]=x[1]+dx[inv(d2)];\n\ty[3]=y[2]+dy[inv(d3)]; x[3]=x[2]+dx[inv(d3)];\n\ty[4]=y[3]+dy[inv(d4)]; x[4]=x[3]+dx[inv(d4)];\n\ty[5]=y[4]+dy[inv(d5)]; x[5]=x[4]+dx[inv(d5)];\n\n\trep(d,4){\n\t\tint ii=i+dy[d],jj=j+dx[d],kk=k;\n\t\tif(d==1 || d==2) kk--;\n\t\tif(kk<0) continue;\n\t\tif(0<=ii && ii<h && 0<=jj && jj<w && B[ii][jj]!='#'){\n\t\t\tbool vis=false;\n\t\t\trep(l,6) if(ii==y[l] && jj==x[l]) vis=true;\n\t\t\tres=max(res,dfs(ii,jj,kk,d,d0,d1,d2,d3,d4)+(vis||B[ii][jj]=='.'?0:B[ii][jj]-'0'));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint k; scanf(\"%d%d%d\",&h,&w,&k);\n\trep(i,h) scanf(\"%s\",B[i]);\n\n\tmemset(dp,-1,sizeof dp);\n\tprintf(\"%d\\n\",dfs(0,0,k,3,3,3,3,3,3));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve();\n\nint H,W,K;\nint fid[60][60] = {0};\nint dp[60][60][5][4][4][4][4][4];\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\nint mem[] = {1,10,-1,-10};\n\nint main()\n{\n    scanf(\"%d%d%d\",&H,&W,&K);\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            char C;\n            scanf(\" %c\",&C);\n            if('1' <= C <= '9')\n            {\n                fid[i][j] = C - '0';\n            }\n            if(C == '#')\n            {\n                fid[i][j] = -1;\n            }\n            if(C == '.')\n            {\n                fid[i][j] = 0;\n            }\n        }\n    }\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            for(int k = 0; k < K + 1; k++)\n            {\n                for(int a = 0; a < 4; a++)\n                {\n                    for(int b = 0; b < 4; b++)\n                    {\n                        for(int c = 0; c < 4; c++)\n                        {\n                            for(int d = 0; d < 4; d++)\n                            {\n                                for(int e = 0; e < 4; e++)\n                                {\n                                    dp[i][j][k][a][b][c][d][e] = -1;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    solve();\n    return 0;\n}\n\nvoid solve()\n{\n    dp[0][0][0][0][0][0][0][0] = fid[0][0];\n    for(int k = 0; k < K + 1; k++)\n    {\n        for(int i = 0; i < H; i++)\n        {\n            for(int j = 0; j < W; j++)\n            {\n                for(int a = 0; a < 4; a++)\n                {\n                    for(int b = 0; b < 4; b++)\n                    {\n                        for(int c = 0; c < 4; c++)\n                        {\n                            for(int d = 0; d < 4; d++)\n                            {\n                                for(int e = 0; e < 4; e++)\n                                {\n                                    if(dp[i][j][k][a][b][c][d][e] == -1)continue;\n                                    for(int f = 0; f < 4; f++)\n                                    {\n                                        int X = i + dx[f],Y = j + dy[f];\n                                        if(X < 0 || H <= X || Y < 0 || W <= Y || fid[X][Y] == -1)continue;\n                                        if(f < 2)\n                                        {\n                                            if(!(mem[f] + mem[e]) || !(mem[f] + mem[e] + mem[d] + mem[c]) || !(mem[f] + mem[e] + mem[d] + mem[c] + mem[b] + mem[a]))\n                                            {\n                                                dp[X][Y][k][b][c][d][e][f] = max(dp[X][Y][k][b][c][d][e][f],dp[i][j][k][a][b][c][d][e]);\n                                            }\n                                            else\n                                            {\n                                                dp[X][Y][k][b][c][d][e][f] = max(dp[X][Y][k][b][c][d][e][f],dp[i][j][k][a][b][c][d][e] + fid[X][Y]);\n                                            }\n                                        }\n                                        else\n                                        {\n                                            if(k == K)continue;\n                                            if(!(mem[f] + mem[e]) || !(mem[f] + mem[e] + mem[d] + mem[c]) || !(mem[f] + mem[e] + mem[d] + mem[c] + mem[b] + mem[a]))\n                                            {\n                                                dp[X][Y][k + 1][b][c][d][e][f] = max(dp[X][Y][k][b][c][d][e][f],dp[i][j][k][a][b][c][d][e]);\n                                            }\n                                            else\n                                            {\n                                                dp[X][Y][k + 1][b][c][d][e][f] = max(dp[X][Y][k][b][c][d][e][f],dp[i][j][k][a][b][c][d][e] + fid[X][Y]);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int a = 0; a < 4; a++)\n    {\n        for(int b = 0; b < 4; b++)\n        {\n            for(int c = 0; c < 4; c++)\n            {\n                for(int d = 0; d < 4; d++)\n                {\n                    for(int e = 0; e < 4; e++)\n                    {\n                        ans = max(ans,dp[H - 1][W - 1][K][a][b][c][d][e]);\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "// JOI 2012-2013 予選6\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\n#include<utility>\n\ntypedef std::pair<int, int> P;\n\nconst int INF = 1 << 30;\n\nint H, W, K;\nchar field[50][50];\n\nstruct state\n{\n\tint x, y, k;\n\tstd::vector<P> visited;\n\n\tstate( int x, int y, int k, const std::vector<P>& v )\n\t:\tx( x ), y( y ), k( k ), visited( v )\n\t{}\n\n\tbool operator< ( const state& rhs ) const\n\t{\n\t\treturn std::make_pair( P( x, y ), std::make_pair( k, visited ) )\n\t\t\t < std::make_pair( P( rhs.x, rhs.y ), std::make_pair( rhs.k, rhs.visited ) );\n\t}\n};\n\nstd::map<state, int> memo;\n\nint rec( int x, int y, int k, const std::vector<P>& visited )\n{\n\tstate cur( x, y, k, visited );\n\n\tif( memo.find( cur ) != memo.end() )\n\t\treturn memo[cur];\n\n\tint ret = -INF;\n\n\tif( x == H - 1 && y == W - 1 )\n\t\tret = 0;\n\n\tstatic const int dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\n\n\tfor( int d = 0; d != 4; ++d )\n\t{\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tint nk = d >= 2 ? k - 1 : k;\n\n\t\tif( nx < 0 || nx >= H || ny < 0 || ny >= W || nk < 0 || field[nx][ny] == '#' )\n\t\t\tcontinue;\n\n\t\tstd::vector<P> nv;\n\t\tfor( int i = 0; i != visited.size(); ++i )\n\t\t\tif( std::max( nx - visited[i].first, 0 ) + std::max( ny - visited[i].second, 0 ) <= nk )\n\t\t\t\tnv.push_back( visited[i] );\n\n\t\tif( field[nx][ny] != '.' )\n\t\t{\n\t\t\tnv.push_back( P( nx, ny ) );\n\t\t\tstd::sort( nv.begin(), nv.end() );\n\t\t\tnv.erase( std::unique( nv.begin(), nv.end() ), nv.end() );\n\t\t}\n\n\t\tint val = field[nx][ny] != '.' ? field[nx][ny] - '0' : 0;\n\t\tfor( int i = 0; i != visited.size(); ++i )\n\t\t\tif( visited[i] == P( nx, ny ) )\n\t\t\t\tval = 0;\n\n\t\tret = std::max( ret, rec( nx, ny, nk, nv ) + val );\n\t}\n\n\treturn memo[cur] = ret;\n}\n\nint main()\n{\n\tstd::cin >> H >> W >> K;\n\tfor( int i = 0; i != H; ++i )\n\t\tstd::cin >> field[i];\n\n\tstd::cout << rec( 0, 0, K, std::vector<P>() ) << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint dp[55][55][4][1<<12];\nchar f[55][55];\nint w,h,K;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nbool out(int x,int y)\n{\n\tif(x<0||x>=h||y<0||y>=w)return true;\n\treturn false;\n}\nbool revisit(int bit)\n{\n\tint tx=0,ty=0;\n\tfor(int i=0;i<6;i++,bit>>=2)\n\t{\n\t\tint id=bit%4;\n\t\ttx+=dx[id];ty+=dy[id];\n\t\tif(tx==0&&ty==0)return true;\n\t}\n\treturn false;\n}\nint rec(int x,int y,int k,int bit)\n{\n\tif(x==0&&y==0)return 0;\n\tif(dp[x][y][k][bit]!=-INF)return dp[x][y][k][bit];\n\tint num=0;\n\tif(f[x][y]!='.'&&f[x][y]!='#'&&!revisit(bit))num=f[x][y]-'0';\n\tint res=-INF;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(!out(nx,ny)&&f[x][y]!='#'&&k-(i>=2)>=0)\n\t\t{\n\t\t\tres=max(res,rec(nx,ny,k-(i>=2),((1<<12)-1)&((bit<<2)+i))+num);\n\t\t}\n\t}\n\treturn dp[x][y][k][bit]=res;\n}\nint main()\n{\n\tcin >> h >> w >> K;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tcin >> f[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<(1<<12);l++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][k][l]=-INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << rec(h-1,w-1,K,0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nchar a[50][50];\nint dp[50][50][4][1<<11];\nint bitMap[4][1<<11][4];\nbool canGet[4][1<<11][4];\nvector<pii> needCells[4];\n\nconst int dy[4] = {0,1,0,-1};\nconst int dx[4] = {1,0,-1,0};\n\nint h,w,K;\n\nint solve(int y, int x, int k, int S){\n  int &r = dp[y][x][k][S];\n  if (r != -1) return r;\n  int res = -INF;\n  if (y==h-1&&x==w-1) res = 0;\n  REP(d,4) {\n    int nk = k+(d>=2);\n    if (nk>K) continue;\n    int ny = y+dy[d];\n    int nx = x+dx[d];\n    if (!valid(ny,nx,h,w)) continue;\n    if (a[ny][nx] == '#') continue;\n    int score = canGet[k][S][d]&&isdigit(a[ny][nx]) ? a[ny][nx]-'0' : 0;\n    chmax(res, solve(ny,nx,nk,bitMap[k][S][d]) + score);\n  }\n  // cout << y << \" \" << x << \" \" << k << \" \";\n  // REP(i,needCells[k].size()) {\n  //   if (S>>i&1) {\n  //     pii p = needCells[k][i];\n  //     cout << \"(\" << p.first << \",\" << p.second << \")\";\n  //   }\n  // }\n  // cout << \" \" << res << endl;\n  return r = res;\n}\n\nint main() {\n  REP(k,4) {\n    for (int y=-3; y<=3; ++y) {\n      for (int x=-3; x<=3; ++x) {\n        if ((y||x) && -min(y,0)-min(x,0) <= 3-k && max(0,y)+max(0,x) <= k)\n          needCells[k].push_back(pii(y,x));\n      }\n    }\n  }\n  REP(k,4) {\n    int n = needCells[k].size();\n    REP(S,1<<n) {\n      REP(d,4) {\n        int nk = k+(d>=2);\n        if (nk == 4) continue;\n        int T = 0;\n        REP(i,n) {\n          if (S>>i&1) {\n            pii p = needCells[k][i];\n            p.first -= dy[d];\n            p.second -= dx[d];\n            REP(j,needCells[nk].size()) {\n              if (needCells[nk][j] == p) {\n                T |= 1 << j;\n              }\n            }\n          }\n        }\n        REP(j,needCells[nk].size()) {\n          if (needCells[nk][j] == pii(-dy[d],-dx[d])) {\n            T |= 1 << j;\n          }\n        }\n        bitMap[k][S][d] = T;\n\n        canGet[k][S][d] = 1;\n        REP(i,n)\n          if (S>>i&1 && needCells[k][i]==pii(dy[d],dx[d]))\n            canGet[k][S][d] = 0;\n      }\n    }\n  }\n  while(cin>>h>>w>>K) {\n    REP(i,h) REP(j,w) cin >> a[i][j];\n    memset(dp,-1,sizeof(dp));\n    cout << solve(0,0,0,0) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define INF 1234567890\n\nint map[60][60];\nchar buf;\nint x_max, y_max, can;\nint ans = 0;\n\nint dp(int x, int y, int can){\n\tif (map[x][y] == -1) return 0;\n\tint before = map[x][y];\n\tint answer = 0;\n\tmap[x][y] = 0;\n\tif (map[x][y - 1] >= 0 && can >= 1) answer = max(answer, dp(x, y - 1, can - 1) + before);\n\tif (map[x][y + 1] >= 0) answer = max(answer, dp(x, y + 1, can) + before);\n\tif (map[x - 1][y] >= 0 && can >= 1) answer = max(answer, dp(x - 1, y, can - 1) + before);\n\tif (map[x + 1][y] >= 0) answer = max(answer, dp(x + 1, y, can) + before);\n\tmap[x][y] = before;\n\tif (x == x_max && y == y_max) return answer + before;\n\telse{\n\t\tif (answer == 0) return -INF;\n\t}\n\treturn answer;\n}\n\nint main(){\n\tmemset(map, 255, sizeof(map));\n\tscanf(\"%d%d%d\", &x_max, &y_max, &can);\n\tfor (int a = 1; a <= x_max; a++){\n\t\tfor (int b = 1; b <= y_max; b++){\n\t\t\tscanf(\" %c\", &buf);\n\t\t\tswitch (buf){\n\t\t\tcase '.':\n\t\t\t\tmap[a][b] = 0;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tmap[a][b] = -1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmap[a][b] = (int)buf - (int)'0';\n\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp(1, 1, can));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nint H,W;\nchar c[50][50];\nmap<vector<pair<int,int> >,int> dp[50][50][4];\nint dfs(int x,int y,int k,vector<pair<int,int> > vis){\n\tif( k < 0 ) return -1e9;\n\tvector< pair<int,int> > p;\n\tfor(int i = 0 ; i < vis.size() ; i++){\n\t\tif( max(0,x-vis[i].first)+max(0,y-vis[i].second) <= k )\n\t\t\tp.push_back(vis[i]);\n\t}\n\tsort(p.begin(),p.end());\n\tvis = p;\n\tif( dp[x][y][k].count(vis) ) return dp[x][y][k][vis];\n\t\n\tint ans = ( x==W-1&&y==H-1 ? 0 : -1e9 );\n\tfor(int i = 0 ;i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( tx < 0 || tx >= W || ty < 0 || ty >= H || c[ty][tx] == '#') continue;\n\t\tint cst = 0;\n\t\tvector<pair<int,int> > t = vis;\n\t\tif( !binary_search(vis.begin(),vis.end(),make_pair(tx,ty)) ){\n\t\t\tcst = c[ty][tx] - '0';\n\t\t\tt.push_back(make_pair(tx,ty));\n\t\t}\n\t\tans = max( ans , dfs(tx,ty,k-(i<2),t)+cst );\n\t}\n\t//cout << x << \" \" << y << \" \" << k << \" \" << vis.size() << endl;\n\treturn dp[x][y][k][vis] = ans;\n}\nint main(){\n\tint K;\n\tcin >> H >> W >> K;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tcin >> c[i][j];\n\t\t\tif( c[i][j] == '.' ) c[i][j] = '0';\n\t\t}\n\t}\n\tcout << dfs(0,0,K,vector<pair<int,int> >(0)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint w, h, k;\nint memo[1 << 12][4][50][50];\nint mask;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nchar field[64][64];\n\nbool check(int ny, int nx)\n{\n\treturn (0 <= ny && ny < h && 0 <= nx && nx < w);\n}\n\nint getMax(int bit, int left, int ty, int tx)\n{\n\tif (memo[bit][left][ty][tx] != -1) return (memo[bit][left][ty][tx]);\n\t\n\tif (ty == h - 1 && tx == w - 1 && left == 0){\n\t\treturn (0);\n\t}\n\t\n\tint px = tx, py = ty;\n\tbool same = false;\n\tfor (int i = 0; i < 2 * k; i++){\n\t\tpx += -dx[(bit >> (2 * i)) & 3];\n\t\tpy += -dy[(bit >> (2 * i)) & 3];\n\t\tif (px == tx && py == ty){\n\t\t\tsame = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint ret = 0;\n\t\n\tif (!same && field[ty][tx] != '.') ret += field[ty][tx] - '0';\n\t\n\tint val = -999999;\n\tfor (int i = 0; i < 4; i++){\n\t\tif (left == 0 && i >= 2) break;\n\t\tint nx = tx + dx[i], ny = ty + dy[i];\n\t\tif (check(ny, nx) && field[ny][nx] != '#'){\n\t\t\tval = max(val, getMax(((bit << 2) | i) & mask, left - (i >= 2), ny, nx) + ret);\n\t\t}\n\t}\n\t\n\treturn (memo[bit][left][ty][tx] = val);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &h, &w, &k);\n\t\n\tmask = (1 << (4 * k)) - 1;\n\t\n\tfor (int i = 0; i < h; i++){\n\t\tscanf(\"%s\", field[i]);\n\t}\n\t\n\tmemset(memo, -1, sizeof(memo));\n\t\n\tint res = getMax(0, k, 0, 0);\n\t\n\tprintf(\"%d\\n\", res < 0 ? 0 : res);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 60\n#define MAX_K 3\n#define MAX_D 6\n#define MAX_C 4096\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\nint dp[MAX_N][MAX_N][MAX_K + 1][MAX_C];\nint x[MAX_N][MAX_N];\nint h, w, K, a;\nchar c;\nchar T[12] = \".123456789#\";\nint b[MAX_N][MAX_N];\nint gx[6], gy[6];\n\nint hantei(int p, int q, vector<int>r) {\n\tint v = p, w = q;\n\tfor (int o = 5; o >= 0; o--) {\n\t\tv -= dy[r[o]];\n\t\tw -= dx[r[o]];\n\t\tgy[o] = v; gx[o] = w;\n\t}\n\tfor (int o = 0; o <= 5; o++) {\n\t\tif (p == gy[o] && q == gx[o]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint DP() {\n\tint X, Y, F, G, H, dir[6], maxn;\n\n\t//zentansaku(first 6)\n\tfor (int i = 0; i < 4096; i++) {\n\t\tmemset(b, 0, sizeof(b));\n\t\tX = 1; Y = 1;\n\t\tF = 0; G = 0;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\ta = (i / (int)pow(4, j)) % 4;\n\t\t\tX += dx[a]; Y += dy[a];\n\t\t\tif (x[Y][X] == 10) {\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif (a == 2 || a == 3) {\n\t\t\t\tG++;\n\t\t\t}\n\t\t\tif (b[Y][X] == 0) {\n\t\t\t\tF += x[Y][X];\n\t\t\t}\n\t\t\tb[Y][X] = 1;\n\t\t}\n\t\tif (G <= K) {\n\t\t\tif (F == 12) {\n\t\t\t\tF = 12;\n\t\t\t}\n\t\t\tdp[Y][X][G][i] = F;\n\t\t}\n\tE:;\n\t}\n\n\t//dp.\n\tfor (int i = 0; i < h + w - 5; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tfor (int k = 1; k <= w; k++) {\n\t\t\t\tif (x[j][k] <= 9) {\n\n\t\t\t\t\tfor (int l = 0; l <= K; l++) {\n\t\t\t\t\t\tfor (int m = 0; m < MAX_C; m++) {\n\t\t\t\t\t\t\tif (dp[j][k][l][m] >= 0) {\n\n\t\t\t\t\t\t\t\tfor (int n = 0; n < 6; n++) {\n\t\t\t\t\t\t\t\t\tdir[n] = (m / (int)pow(4, n)) % 4;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (l <= K) {\n\t\t\t\t\t\t\t\t\tif (x[j - 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 2048;\n\t\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],2 };\n\t\t\t\t\t\t\t\t\t\tif (hantei(j - 1, k, A) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j - 1][k];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tX = j; Y = k;\n\n\t\t\t\t\t\t\t\t\t\tdp[j - 1][k][l + 1][a] = max(dp[j - 1][k][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (x[j][k - 1] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 3072;\n\t\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],3 };\n\n\t\t\t\t\t\t\t\t\t\tif (hantei(j, k - 1, A) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j][k - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tdp[j][k - 1][l + 1][a] = max(dp[j][k - 1][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j + 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],0 };\n\n\t\t\t\t\t\t\t\t\tif (hantei(j + 1, k, A) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j + 1][k];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j + 1][k][l][a] = max(dp[j + 1][k][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j][k + 1] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += (int)pow(4, n - 1)*dir[n];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ta += 1024;\n\n\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],1 };\n\n\t\t\t\t\t\t\t\t\tif (hantei(j, k + 1, A) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j][k + 1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j][k + 1][l][a] = max(dp[j][k + 1][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmaxn = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tfor (int j = 0; j < MAX_C; j++) {\n\t\t\tmaxn = max(maxn, dp[h][w][i][j]);\n\t\t}\n\t}\n\treturn maxn;\n}\n\nint main() {\n\t//shokika.\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_K; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_C; l++) {\n\t\t\t\t\tdp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tx[i][j] = 10;\n\t\t}\n\t}\n\t//cin.\n\tcin >> h >> w >> K;\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tcin >> c;\n\t\t\tfor (int k = 0; k < 11; k++) {\n\t\t\t\tif (c == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//ライブラリゾーン！！！！\ntypedef long long ll;\ntypedef long double ld;\n#define str string\n#define rep(i,j) for(ll i=0;i<(long long)(j);i++)\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//隣接リスト表現\n\tll to;\n\tld cost;\n};\nstruct E {//辺の情報を入れる変数\n\tll from, to, cost;\n};\nbool operator<(E a, E b) {\n\treturn a.cost < b.cost;\n}\nstruct H {\n\tll x, y;\n};\nbool operator<(H a, H b) {\n\t/*if (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;*/\n\treturn ((a.x + 1)*(a.y + 1)) < ((b.x + 1)*(b.y + 1));\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nbool operator==(H a, H b) {\n\treturn a.x == b.x&&a.y == b.y;\n}\nbool operator!=(H a, H b) {\n\treturn a.x != b.x || a.y != b.y;\n}\nll gcm(ll i, ll j) {//最大公約数\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(H a, H b) {\n\treturn sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0));\n}//rad＝座標上の2点間の距離\nll ari(ll a, ll b, ll c) {\n\treturn (a + b)*c / 2;\n}//等差数列の和\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\nll fact(ll x, ll k, ll p) {//最大値、個数\n\tll sum = 1;\n\tfor (int i = 0; i < k; i++) {\n\t\tsum *= (x--);\n\t\tsum %= p;\n\t}\n\treturn sum;\n}//階乗(正）\nll mod_pow(ll x, ll n, ll p) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res*x%p;\n\t\tx = x*x%p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}//x^n%p\n //#define int long long\nconst long long inf = 4523372036854775807;\nconst int iinf = 1500000000;\n//----------------------------------------------------\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\nstruct A {\n\tint ans;\n\tbool can;\n};\nint h, w, K;\nint a[50][50];//売っている数\nbool b[50][50];//訪れられるか\nA dp[50][50][4][4200];//場所、場所、残りのk、kに応じたbit\nA solve(int x, int y, int k, int t) {//１なら到達済み\n\tif (x == h - 1 && y == w - 1 && k == 0) {\n\t\treturn A{ 0,1 };\n\t}\n\tbool l = 0;\n\tif (dp[x][y][k][t].ans > 0)\n\t\treturn dp[x][y][k][t];\n\tint res = 0;\n\tif (k == 3) {\n\t\tif (x > 0 && b[x - 1][y]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(2 & t)) qr = a[x - 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (t & 1) rep += 128;\n\t\t\tif (t & 8) rep += 2;\n\t\t\tif (t & 64) rep += 8;\n\t\t\tif (t & 4) rep += 1024;\n\t\t\tif (t & 16) rep += 4;\n\t\t\tif (t & 128) rep += 16;\n\t\t\tif (t & 32) rep += 2048;\n\t\t\tif (t & 256) rep += 32;\n\t\t\tif (solve(x - 1, y, 2, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x - 1, y, 2, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t\tif (y > 0 && b[x][y - 1]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(4 & t)) qr = a[x][y - 1];\n\t\t\tint rep = 1;\n\t\t\tif (1 & t) rep += 64;\n\t\t\tif (16 & t) rep += 2;\n\t\t\tif (128 & t) rep += 8;\n\t\t\tif (32 & t) rep += 4;\n\t\t\tif (256 & t) rep += 16;\n\t\t\tif (512 & t) rep += 32;\n\t\t\tif (2 & t) rep += 512;\n\t\t\tif (8 & t) rep += 256;\n\t\t\tif (solve(x, y - 1, 2, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x, y - 1, 2, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse if (k == 2) {\n\t\tif (x > 0 && b[x - 1][y]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(2 & t)) qr = a[x - 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (8 & t) rep += 2;\n\t\t\tif (16 & t) rep += 4;\n\t\t\tif (1 & t) rep += 16;\n\t\t\tif (128 & t) rep += 128;\n\t\t\tif (64 & t) rep += 64;\n\t\t\tif (4 & t) rep += 1024;\n\t\t\tif (1024 & t) rep += 2048;\n\t\t\tif (512 & t) rep += 8;\n\t\t\tif (256 & t) rep += 256;\n\t\t\tif (solve(x - 1, y, 1, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x - 1, y, 1, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t\tif (y > 0 && b[x][y - 1]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(4 & t)) qr = a[x][y - 1];\n\t\t\tint rep = 1;\n\t\t\tif (16 & t) rep += 2;\n\t\t\tif (32 & t) rep += 4;\n\t\t\tif (1 & t) rep += 8;\n\t\t\tif (64 & t) rep += 32;\n\t\t\tif (128 & t) rep += 64;\n\t\t\tif (1024 & t) rep += 16;\n\t\t\tif (2048 & t) rep += 1024;\n\t\t\tif (512 & t) rep += 512;\n\t\t\tif (2 & t) rep += 256;\n\t\t\tif (solve(x, y - 1, 1, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x, y - 1, 1, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse if (k == 1) {\n\t\tif (x > 0 && b[x - 1][y]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(2 & t)) qr = a[x - 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (t & 1) rep += 4;\n\t\t\tif (t & 16) rep += 32;\n\t\t\tif (t & 128) rep += 512;\n\t\t\tif (t & 256) rep += 2;\n\t\t\tif (t & 8) rep += 16;\n\t\t\tif (t & 64) rep += 256;\n\t\t\tif (t & 512) rep += 8;\n\t\t\tif (t & 32) rep += 128;\n\t\t\tif (solve(x - 1, y, 0, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x - 1, y, 0, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t\tif (y > 0 && b[x][y - 1]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(4 & t)) qr = a[x][y - 1];\n\t\t\tint rep = 1;\n\t\t\tif (t & 1024) rep += 4;\n\t\t\tif (t & 2048) rep += 32;\n\t\t\tif (t & 1) rep += 2;\n\t\t\tif (t & 16) rep += 16;\n\t\t\tif (t & 128) rep += 256;\n\t\t\tif (t & 8) rep += 8;\n\t\t\tif (t & 64) rep += 128;\n\t\t\tif (t & 32) rep += 64;\n\t\t\tif (solve(x, y - 1, 0, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x, y - 1, 0, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (x + 1 < h&&b[x + 1][y]) {\n\t\tif (k == 3) {\n\t\t\tint qr = a[x + 1][y];\n\t\t\tint rep = 0;\n\t\t\trep++;\n\t\t\tif (1 & t) rep += 2;\n\t\t\tif (2 & t) rep += 8;\n\t\t\tif (8 & t) rep += 64;\n\t\t\tif (4 & t) rep += 16;\n\t\t\tif (16 & t) rep += 128;\n\t\t\tif (32 & t) rep += 256;\n\t\t\tif (solve(x + 1, y, 3, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x + 1, y, 3, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t\tif (k == 2) {\n\t\t\tint qr = 0;\n\t\t\tif (!(128 & t)) qr = a[x + 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (1 & t) rep += 2;\n\t\t\tif (4 & t) rep += 16;\n\t\t\tif (512 & t) rep += 256;\n\t\t\tif (64 & t) rep += 512;\n\t\t\tif (2 & t) rep += 8;\n\t\t\tif (1024 & t) rep += 4;\n\t\t\tif (2048 & t) rep += 32;\n\t\t\tif (solve(x + 1, y, 2, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x + 1, y, 2, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t\tif (k == 1) {\n\t\t\tint qr = 0;\n\t\t\tif (!(16 & t)) qr = a[x + 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (32 & t) rep += 512;\n\t\t\tif (8 & t) rep += 256;\n\t\t\tif (64 & t) rep += 8;\n\t\t\tif (1 & t) rep += 2;\n\t\t\tif (128 & t) rep += 16;\n\t\t\tif (1024 & t) rep += 4;\n\t\t\tif (2048 & t) rep += 1024;\n\t\t\tif (solve(x + 1, y, 1, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x + 1, y, 1, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t\tif (k == 0) {\n\t\t\tint qr = 0;\n\t\t\tif (!(4 & t)) qr = a[x + 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (16 & t) rep += 2;\n\t\t\tif (128 & t) rep += 8;\n\t\t\tif (32 & t) rep += 4;\n\t\t\tif (256 & t) rep += 16;\n\t\t\tif (512 & t) rep += 32;\n\t\t\tif (solve(x + 1, y, 0, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x + 1, y, 0, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (y + 1 < w&&b[x][y + 1]) {\n\t\tif (k == 3) {\n\t\t\tint qr = a[x][y + 1];\n\t\t\tint rep = 1;\n\t\t\tif (8 & t) rep += 128;\n\t\t\tif (2 & t) rep += 16;\n\t\t\tif (16 & t) rep += 256;\n\t\t\tif (1 & t) rep += 4;\n\t\t\tif (4 & t) rep += 32;\n\t\t\tif (32 & t) rep += 512;\n\t\t\tif (solve(x, y + 1, 3, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x, y + 1, 3, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t\tif (k == 2) {\n\t\t\tint qr = 0;\n\t\t\tif (!(t & 64)) qr = a[x][y + 1];\n\t\t\tint rep = 1;\n\t\t\tif (256 & t) rep += 8;\n\t\t\tif (512 & t) rep += 2;\n\t\t\tif (2 & t) rep += 16;\n\t\t\tif (1 & t) rep += 4;\n\t\t\tif (4 & t) rep += 32;\n\t\t\tif (128 & t) rep += 1024;\n\t\t\tif (1024 & t) rep += 2048;\n\t\t\tif (solve(x, y + 1, 2, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x, y + 1, 2, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t\tif (k == 1) {\n\t\t\tint qr = 0;\n\t\t\tif (!(t & 8)) qr = a[x][y + 1];\n\t\t\tint rep = 1;\n\t\t\tif (512 & t) rep += 256;\n\t\t\tif (256 & t) rep += 2;\n\t\t\tif (32 & t) rep += 8;\n\t\t\tif (1 & t) rep += 4;\n\t\t\tif (64 & t) rep += 16;\n\t\t\tif (16 & t) rep += 1024;\n\t\t\tif (128 & t) rep += 256;\n\t\t\tif (solve(x, y + 1, 1, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x, y + 1, 1, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t\tif (k == 0) {\n\t\t\tint qr = 0;\n\t\t\tif (!(2 & t)) qr = a[x][y + 1];\n\t\t\tint rep = 1;\n\t\t\tif (64 & t) rep += 8;\n\t\t\tif (8 & t) rep += 2;\n\t\t\tif (16 & t) rep += 4;\n\t\t\tif (128 & t) rep += 16;\n\t\t\tif (256 & t) rep += 32;\n\t\t\tif (solve(x, y + 1, 0, rep).can) {\n\t\t\t\tres = max(res, qr + solve(x, y + 1, 0, rep).ans);\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (!l) return dp[x][y][k][t] = A{ -iinf,0 };\n\treturn dp[x][y][k][t] = A{ res,1 };\n}\nsigned main() {\n\tcin >> h >> w >> K;\n\tfor (int i = 0; i < h; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (s[j] != '#'&&s[j] != '.') {\n\t\t\t\ta[i][j] = (int)s[j] - '0';\n\t\t\t\tb[i][j] = 1;\n\t\t\t}\n\t\t\telse if (s[j] == '.') {\n\t\t\t\tb[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << solve(0, 0, K, 1).ans << endl;\n\tgetchar(); getchar();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define INF 1234567890\n\nint map[60][60];\nchar buf;\nint x_max, y_max, can;\nint ans = 0;\n\nint dp(int x, int y, int can){\n\tif (can < 0) return 0;\n\tif (x == x_max && y == x_max) return 0;\n\tif (map[x][y] == -1) return 0;\n\tint before = map[x][y];\n\tint ans = 0;\n\tmap[x][y] = 0;\n\tif (map[x][y - 1] >= 0) ans = max(ans, dp(x, y - 1, can - 1));\n\tif (map[x][y + 1] >= 0) ans = max(ans, dp(x, y + 1, can));\n\tif (map[x - 1][y] >= 0) ans = max(ans, dp(x - 1, y, can - 1));\n\tif (map[x + 1][y] >= 0) ans = max(ans, dp(x + 1, y, can));\n\tmap[x][y] = before;\n\treturn ans + before;\n}\n\nint main(){\n\tmemset(map, 255, sizeof(map));\n\tscanf(\"%d%d%d\", &x_max, &y_max, &can);\n\tfor (int a = 1; a <= x_max; a++){\n\t\tfor (int b = 1; b <= y_max; b++){\n\t\t\tscanf(\" %c\", &buf);\n\t\t\tswitch (buf){\n\t\t\tcase '.':\n\t\t\t\tmap[a][b] = 0;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tmap[a][b] = -1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmap[a][b] = (int)buf - (int)'0';\n\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp(1, 1, can));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nconst std::vector<std::vector<std::pair<int, int>>>\n    peris{\n        {{0, 0},\n         {1, 0},\n         {2, 0},\n         {3, 0},\n         {0, 1},\n         {1, 1},\n         {2, 1},\n         {0, 2},\n         {1, 2},\n         {0, 3}},\n\n        {{0, -1},\n         {1, -1},\n         {2, -1},\n         {-1, 0},\n         {0, 0},\n         {1, 0},\n         {2, 0},\n         {-1, 1},\n         {0, 1},\n         {1, 1},\n         {-1, 2},\n         {0, 2}},\n\n        {{0, -2},\n         {1, -2},\n         {-1, -1},\n         {0, -1},\n         {1, -1},\n         {-2, 0},\n         {-1, 0},\n         {0, 0},\n         {1, 0},\n         {-2, 1},\n         {-1, 1},\n         {0, 1}},\n\n        {{0, -3},\n         {-1, -2},\n         {0, -2},\n         {-2, -1},\n         {-1, -1},\n         {0, -1},\n         {-3, 0},\n         {-2, 0},\n         {-1, 0},\n         {0, 0}}};\n\nconst std::vector<int> ks{10, 12, 12, 10};\nconstexpr int INF = 1 << 30;\n\nvoid solve() {\n    int h, w, k;\n    std::cin >> h >> w >> k;\n\n    std::vector<std::string> ss(h);\n    for (auto& s : ss) {\n        std::cin >> s;\n        for (auto& c : s) {\n            if (c == '.') c = '0';\n        }\n    }\n\n    auto dp = vec(k + 1, vec(1 << 12, vec(h, vec(w, -INF))));\n    dp[k][0][0][0] = 0;\n\n    for (int l = k; l >= 0; --l) {\n        for (int x = 0; x < h; ++x) {\n            for (int y = 0; y < w; ++y) {\n                if (ss[x][y] == '#') continue;\n\n                for (int prev = 0; prev < (1 << ks[l]); ++prev) {\n                    for (int i = 1; i <= 2; ++i) {\n                        int dx = (i & 1),\n                            dy = (i >> 1);\n\n                        int nx = x + dx,\n                            ny = y + dy;\n                        if (nx >= h || ny >= w) continue;\n\n                        int score = dp[l][prev][x][y] + (ss[x][y] - '0');\n                        int nprev = prev;\n                        for (int j = 0; j < ks[l]; ++j) {\n                            if (peris[l][j] != std::make_pair(0, 0)) continue;\n                            if ((prev >> j) & 1) score -= (ss[x][y] - '0');\n                            nprev |= (1 << j);\n                        }\n\n                        int next = 0;\n                        for (int j = 0; j < ks[l]; ++j) {\n                            auto p = peris[l][j];\n                            p.first += dx, p.second += dy;\n\n                            for (int pj = 0; pj < ks[l]; ++pj) {\n                                if (p == peris[l][pj]) {\n                                    int b = (nprev >> pj) & 1;\n                                    next |= (b << j);\n                                    break;\n                                }\n                            }\n                        }\n\n                        dp[l][next][nx][ny] = std::max(dp[l][next][nx][ny], score);\n                    }\n\n                    if (l == 0) continue;\n\n                    for (int i = 1; i <= 2; ++i) {\n                        int dx = (i & 1),\n                            dy = (i >> 1);\n\n                        int nx = x - dx,\n                            ny = y - dy;\n                        if (nx < 0 || ny < 0) continue;\n\n                        int score = dp[l][prev][x][y] + (ss[x][y] - '0');\n                        int nprev = prev;\n                        for (int j = 0; j < ks[l]; ++j) {\n                            if (peris[l][j] != std::make_pair(0, 0)) continue;\n                            if ((prev >> j) & 1) score -= (ss[x][y] - '0');\n                            nprev |= (1 << j);\n                        }\n\n                        int nl = l - 1;\n                        int next = 0;\n                        for (int j = 0; j < ks[nl]; ++j) {\n                            auto p = peris[nl][j];\n                            p.first -= dx, p.second -= dy;\n\n                            for (int pj = 0; pj < ks[l]; ++pj) {\n                                if (p == peris[l][pj]) {\n                                    int b = (nprev >> pj) & 1;\n                                    next |= (b << j);\n                                    break;\n                                }\n                            }\n                        }\n\n                        dp[nl][next][nx][ny] = std::max(dp[nl][next][nx][ny], score);\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int l = 0; l <= k; ++l) {\n        for (int p = 0; p < (1 << ks[l]); ++p) {\n            ans = std::max(ans, dp[l][p][h - 1][w - 1]);\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define INF -(1 << 23)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint main()\n{\n\tint H, W, K;\n\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &K);\n\n\tvector<string> M(H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tcin >> M[i];\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (M[i][j] == '.')\n\t\t\t{\n\t\t\t\tM[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<vector<vector<int> > > > dp(H, vector<vector<vector<int> > >(W, vector<vector<int> >(K + 1, vector<int>(64, INF))));\n\n\tdp[0][0][0][0] = 0;\n\n\tfor (int rep = 0; rep <= K; rep++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= K; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < 64; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint dir = l % 4;\n\n\t\t\t\t\t\t\tif ((0 <= j + dx[dir] && j + dx[dir] < W && 0 <= i + dy[dir] && i + dy[dir] < H) && !(!(dir % 3) && K != 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint r = m * 16 - l / 4;\n\n\t\t\t\t\t\t\t\t\tif (dir % 3)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k][r]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k - 1][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = -1;\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tfor (int j = 0; j < 64; j++)\n\t\t{\n\t\t\tret = max(ret, dp[H - 1][W - 1][i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint h, w, k;\nchar s[51][51];\nint dp[51][51][1 << 12][4], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nbool used[51][51];\nvoid mark(int x, int y, int t, int s) {\n\tused[x][y] = true;\n\tif (s == 0)return;\n\tint a = ((t >> 1 & 1) << 1) + (t & 1);\n\tx -= dx[a], y -= dy[a];\n\tt >>= 2;\n\tmark(x, y, t, s - 1);\n}\nint rec(int x, int y, int t, int a, int cnt) {\n\tif (dp[x][y][t][a] != -1)return dp[x][y][t][a];\n\tint res = -INF;\n\trep(i, 4) {\n\t\tif (i % 2 && !a)continue;\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || s[nx][ny] == '#')continue;\n\t\tint v = 0;\n\t\tmemset(used, 0, sizeof(used));\n\t\tmark(x, y, t, cnt);\n\t\tif (used[nx][ny] == false) {\n\t\t\tif ('1' <= s[nx][ny] && s[nx][ny] <= '9')v = s[nx][ny] - '0';\n\t\t}\n\t\tint p = (t >> (k * 4 - 2)) << (k * 4 - 2); p = t - p;\n\t\tp = (p << 2) + i; int b = cnt; if (b < 2 * k)b++;\n\t\tint o = rec(nx, ny, p, a - i % 2, b);\n\t\tif (o != -INF)res = max(res, o + v);\n\t}\n\tif (x == h - 1 && y == w - 1 && res == -INF) {\n\t\treturn dp[x][y][t][a] = 0;\n\t}\n\treturn dp[x][y][t][a] = res;\n}\nint main() {\n\tscanf(\"%d%d%d\", &h, &w, &k);\n\trep(i, h)scanf(\"%s\", s[i]);\n\tmemset(dp, -1, sizeof(dp));\n\tprintf(\"%d\\n\", rec(0, 0, 0, k, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\nint h,w,K;\nstring str;\nint fie[100][100];\nshort dp[51][51][4][1<<12+1];\nint res=0;\n\nshort dfs(int x,int y,int k,int bit,int pc){\n\tint nx=x,ny=y;\n\tif(check[x][y][k][bit]!=-1)return dp[x][y][k][bit];\n\t\n\t//11nx++,10nx--,01ny++,00ny--;\n\tint nbit=bit;\n\tif(nbit >>11 & 1)nbit-=1<<11;\n\tif(nbit >>10 & 1)nbit-=1<<10;\n\tnbit<<=2;\n\tshort r=-20000;\n\tif(k>=1){\n\t\tnbit+=2;\n\t\tx--;\n\t\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\t\tr=max(r,dfs(x,y,k-1,nbit,pc+1));\n\t\t}\n\t\tx++;\n\t\ty--;\n\t\tnbit-=2;\n\t\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\t\tr=max(r,dfs(x,y,k-1,nbit,pc+1));\n\t\t}\n\t\ty++;\n\t}\n\tnbit+=3;\n\tx++;\n\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\tr=max(r,dfs(x,y,k,nbit,pc+1));\n\t}\n\tx--;\n\tnbit-=2;\n\ty++;\n\tif(x>=0 && y>=0 && fie[x][y]!=-1){\n\t\tr=max(r,dfs(x,y,k,nbit,pc+1));\n\t}\n\ty--;\n\t\n\tint sum=0;\n\tbool f=false;\n\tfor(int i=0;i<min(pc,6);i++){\n\t\tif(bit >>i*2 & 1){\n\t\t\tif(bit >>(i*2+1) & 1)nx--;\n\t\t\telse ny--;\n\t\t}else{\n\t\t\tif(bit >>(i*2+1) & 1)nx++;\n\t\t\telse ny++;\n\t\t}\n\t\tif(nx==x && ny==y){\n\t\t\tf=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f)sum+=fie[x][y];\n\t\n\tif(r<0 && x==w-1 && y==h-1)r=0;\n\tcheck[x][y][k][bit]=true;\n\treturn (dp[x][y][k][bit]=sum+r);\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&h,&w,&K);\n\tmemset(fie,-1,sizeof(fie));\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i=0;i<h;i++){\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]=='.')fie[j][i]=0;\n\t\t\telse if(str[j]=='#')fie[j][i]=-1;\n\t\t\telse fie[j][i]=str[j]-'0';\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dfs(0,0,K,0,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint h, w, k;\nchar s[51][51];\nint dp[51][51][1 << 12][4], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nbool used[51][51];\nvoid mark(int x, int y, int t, int s) {\n\tused[x][y] = true;\n\tif (!s)return;\n\tint a = t % 4;\n\tx -= dx[a], y -= dy[a];\n\tt >>= 2;\n\tmark(x, y, t, s - 1);\n}\nint rec(int x, int y, int t, int a, int cnt) {\n\tif (dp[x][y][t][a] != -1)return dp[x][y][t][a];\n\tint res = -INF;\n\trep(i, 4) {\n\t\tif (i % 2 && !a)continue;\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || s[nx][ny] == '#')continue;\n\t\tmemset(used, 0, sizeof(used));\n\t\tmark(x, y, t, cnt);\n\t\tint v = ((!used[nx][ny] && '1' <= s[nx][ny] && s[nx][ny] <= '9') ? s[nx][ny] - '0' : 0);\n\t\tint p = (t >> (k * 4 - 2)) << (k * 4 - 2); p = t - p;\n\t\tp = (p << 2) + i; int b = cnt; if (b < 2 * k)b++;\n\t\tint o = rec(nx, ny, p, a - i % 2, b);\n\t\tif (o != -INF)res = max(res, o + v);\n\t}\n\tif (x == h - 1 && y == w - 1 && res == -INF)return dp[x][y][t][a] = 0;\n\treturn dp[x][y][t][a] = res;\n}\nint main() {\n\tscanf(\"%d%d%d\", &h, &w, &k);\n\trep(i, h)scanf(\"%s\", s[i]);\n\tmemset(dp, -1, sizeof(dp));\n\tprintf(\"%d\\n\", rec(0, 0, 0, k, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tEast,\n\tSouth,\n\tWest,\n\tNorth,\n};\n\nstruct Info{\n\tvoid set(int arg_row,int arg_col,int arg_back_count,int arg_moved_count,int arg_sum,int arg_move_log){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tback_count = arg_back_count;\n\t\tmoved_count = arg_moved_count;\n\t\tsum = arg_sum;\n\t\tmove_log = arg_move_log;\n\t}\n\tbool operator<(const struct Info &arg) const{ //総和の降順(PQ)\n\t\treturn sum < arg.sum;\n\t}\n\n\tint row,col,back_count,moved_count,sum,move_log;\n};\n\nint H,W,K;\nint POW[7];\nint dp[50][50][4][4096]; //dp[row][col][Kの残数][moved_count][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint makeCode(Type move_log[6]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < 6; i++){\n\t\tret += move_log[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\nbool is_num(int row,int col){\n\treturn base_map[row][col] >= '1' && base_map[row][col] <= '9'; //0の土産物屋はない\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++)POW[i] = pow(4,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= K; i++){\n\t\t\t\tfor(int count = 0; count <= 6; count++){\n\t\t\t\t\tfor(int state = 0; state < POW[6]; state++)dp[row][col][i][count][state] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tInfo first;\n\tfirst.set(0,0,0,0,0,0);\n\n\tdp[0][0][0][0][0] = 0;\n\n\tint bit_mask = 4095;\n\n\tQ.push(first);\n\n\tint log_array[6],tmp_log;\n\n\tInfo info;\n\twhile(!Q.empty()){\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tif(dp[info.row][info.col][info.back_count][info.move_log] > info.sum)continue;\n\n\t\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\t\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t\t//過去の移動ログから、訪問済のマス情報を特定する\n\t\tint tmp_row = info.row,tmp_col = info.col;\n\n\t\ttmp_log = info.move_log;\n\t\t//printf(\"tmp_log:%d\\n\",tmp_log);\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tlog_array[i] = tmp_log & 3;\n\t\t\t//printf(\"array[%d]:%d\\n\",i,log_array[i]);\n\t\t\ttmp_log /= 4;\n\t\t}\n\n\t\tfor(int i = 0; i < min(6,info.moved_count); i++){\n\t\t\tswitch(log_array[i]){ //ログを打ち消す方向に動く\n\t\t\tcase 0:\n\t\t\t\ttmp_col--;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttmp_row--;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttmp_col++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\ttmp_row++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp_row == info.row && tmp_col == info.col+1){ //右のマスと一致\n\t\t\t\tvisited_E = true;\n\t\t\t}else if(tmp_row == info.row+1 && tmp_col == info.col){ //下のマスと一致\n\t\t\t\tvisited_S = true;\n\t\t\t}else if(tmp_row == info.row && tmp_col == info.col-1){ //左のマスと一致\n\t\t\t\tvisited_W = true;\n\t\t\t}else if(tmp_row == info.row-1 && tmp_col == info.col){ //上のマスと一致\n\t\t\t\tvisited_N = true;\n\t\t\t}\n\t\t}\n\n\t\t//次の移動ログを作る\n\n\n\t\t//右へ\n\t\tif(rangeCheck(info.row,info.col+1) == true && base_map[info.row][info.col+1] != '#'){\n\t\t\tif(visited_E == false && is_num(info.row,info.col+1) == true){\n\t\t\t\tresult_E += base_map[info.row][info.col+1]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|0;\n\t\t\tif(dp[info.row][info.col+1][info.back_count][next_code] < info.sum+result_E){\n\t\t\t\tdp[info.row][info.col+1][info.back_count][next_code] = info.sum+result_E;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col+1,info.back_count,info.moved_count+1,info.sum+result_E,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//下へ\n\t\tif(rangeCheck(info.row+1,info.col) == true && base_map[info.row+1][info.col] != '#'){\n\t\t\tif(visited_S == false && is_num(info.row+1,info.col) == true){\n\t\t\t\tresult_S += base_map[info.row+1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|1;\n\t\t\tif(dp[info.row+1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_S){\n\t\t\t\tdp[info.row+1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_S;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row+1,info.col,info.back_count,info.moved_count+1,info.sum+result_S,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\tif(info.back_count == K)continue;\n\n\t\t//左へ\n\t\tif(rangeCheck(info.row,info.col-1) == true && base_map[info.row][info.col-1] != '#'){\n\t\t\tif(visited_W == false && is_num(info.row,info.col-1) == true){\n\t\t\t\tresult_W += base_map[info.row][info.col-1]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|2;\n\t\t\tif(dp[info.row][info.col-1][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_W){\n\t\t\t\tdp[info.row][info.col-1][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_W;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col-1,info.back_count+1,info.moved_count+1,info.sum+result_W,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//上へ\n\t\tif(rangeCheck(info.row-1,info.col) == true && base_map[info.row-1][info.col] != '#'){\n\t\t\tif(visited_N == false && is_num(info.row-1,info.col) == true){\n\t\t\t\tresult_N += base_map[info.row-1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = ((info.move_log<<2)&bit_mask)|3;\n\t\t\tif(dp[info.row-1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_N){\n\t\t\t\tdp[info.row-1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_N;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row-1,info.col,info.back_count+1,info.moved_count+1,info.sum+result_N,next_code);\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\tfor(int state = 0; state < POW[6]; state++){\n\t\tfor(int count = 4; count <= 6; count++){\n\t\t\tans = max(ans,dp[H-1][W-1][K][state]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\n\nclass Data\n{\npublic:\n    int y, x, b;\n    vector<int> history;\n    Data(int y0, int x0, int b0, int k)\n    {\n        y = y0;\n        x = x0;\n        b = b0;\n        history.clear();\n        for(int i=0; i<5; ++i){\n            history.push_back(k % 4);\n            k /= 4;\n        }\n    }\n    bool move(int d)\n    {\n        int y2 = y;\n        int x2 = x;\n        y += dy[d];\n        x += dx[d];\n        b -= d / 2;\n\n        bool ret = false;\n        for(int i=4; i>=0; --i){\n            y2 -= dy[history[i]];\n            x2 -= dx[history[i]];\n            if(y2 == y && x2 == x)\n                ret = true;\n        }\n\n        history.erase(history.begin());\n        history.push_back(d);\n\n        return ret;\n    }\n    int toInt(){\n        int ret = 0;\n        for(int i=4; i>=0; --i){\n            ret *= 4;\n            ret += history[i];\n        }\n        return y + 50 * (x + 50 * (b + 4 * ret));\n    }\n};\n\nint main()\n{\n    int h, w, n;\n    cin >> h >> w >> n;\n\n    vector<string> s(h);\n    for(int i=0; i<h; ++i)\n        cin >> s[i];\n\n    vector<int> dp(50*50*4*1024, -1);\n    dp[Data(0, 0, n, 0).toInt()] = 0;\n\n    for(int b=n; b>=0; --b){\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int k=0; k<1024; ++k){\n                    Data d(y, x, b, k);\n                    if(dp[d.toInt()] == -1)\n                        continue;\n\n                    for(int i=0; i<4; ++i){\n                        Data d2 = d;\n                        bool use = d2.move(i);\n                        if(d2.y < 0 || d2.y >= h || d2.x < 0 || d2.x >= w || s[d2.y][d2.x] == '#' || d2.b < 0)\n                            continue;\n\n                        int next = dp[d.toInt()];\n                        if(!use && isdigit(s[d2.y][d2.x]))\n                            next += s[d2.y][d2.x] - '0';\n\n                        dp[d2.toInt()] = max(dp[d2.toInt()], next);\n                    }\n                }\n            }\n        }\n    }\n\n    int ret = 0;\n    for(int i=0; i<=n; ++i){\n        for(int j=0; j<1024; ++j){\n            ret = max(ret, dp[Data(h-1, w-1, i, j).toInt()]);\n        }\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint w, h, k;\nshort memo[1 << 12][4][50][50];\nint mask;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nchar field[64][64];\n\nbool check(int ny, int nx)\n{\n\treturn (0 <= ny && ny < h && 0 <= nx && nx < w);\n}\n\nint getMax(int bit, int left, int ty, int tx)\n{\n\tif (memo[bit][left][ty][tx] != -1) return (memo[bit][left][ty][tx]);\n\t\n\tif (ty == h - 1 && tx == w - 1 && left == 0){\n\t\treturn (0);\n\t}\n\t\n\tint px = tx, py = ty;\n\tbool same = false;\n\tfor (int i = 0; i < 2 * k; i++){\n\t\tpx += -dx[(bit >> (2 * i)) & 3];\n\t\tpy += -dy[(bit >> (2 * i)) & 3];\n\t\tif (px == tx && py == ty){\n\t\t\tsame = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint ret = 0;\n\t\n\tif (!same && field[ty][tx] != '.') ret += field[ty][tx] - '0';\n\t\n\tint val = -999999;\n\tfor (int i = 0; i < 4; i++){\n\t\tif (left == 0 && i >= 2) break;\n\t\tint nx = tx + dx[i], ny = ty + dy[i];\n\t\tif (check(ny, nx) && field[ny][nx] != '#'){\n\t\t\tval = max(val, getMax(((bit << 2) | i) & mask, left - (i >= 2), ny, nx) + ret);\n\t\t}\n\t}\n\t\n\treturn (memo[bit][left][ty][tx] = val);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &h, &w, &k);\n\t\n\tmask = (1 << (4 * k)) - 1;\n\t\n\tfor (int i = 0; i < h; i++){\n\t\tscanf(\"%s\", field[i]);\n\t}\n\t\n\tmemset(memo, -1, sizeof(memo));\n\t\n\tint res = getMax(0, k, 0, 0);\n\t\n\tprintf(\"%d\\n\", res < 0 ? 0 : res);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\nbool used[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  int m[51][51]={};\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[i+oy][j+ox]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[ny][nx];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 全体のビット右にをシフト\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[cy][cx];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 下方向にビットをシフト\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[cy][cx];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nconst int INF=(1<<30);\nint dfs(int cy,int cx,int mask,int my,int mx){\n  if(used[cy][cx][mask][my][mx])return dp[cy][cx][mask][my][mx];\n  int res=-INF;\n  int leftK=K-(my+mx);\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n      int nmask=p.first;\n      int nAddVal=p.second;\n      if(leftK>0&&(i==0||i==3))\n        res=max(res,dfs(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))+nAddVal);\n      else if((i==1||i==2))\n        res=max(res,dfs(ny,nx,nmask,my,mx)+nAddVal);\n    }\n  }\n  if(cy==H-1&&cx==W-1)res=max(res,0);\n  used[cy][cx][mask][my][mx]=true;\n  return dp[cy][cx][mask][my][mx]=res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,(1<<6),0,0)<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define POWER9 1000000000\n#define MOD POWER9+7\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nint H,W,K;\nint A[51][51] = {};\n\nint dp[50][50][4][4][1<<9];\nint solve(int y, int x, int k, int modori, int state){\n\tif(y == H || x == W) return 0;\n\tif(dp[y][x][k][modori][state] != -1) return dp[y][x][k][modori][state];\n\tbool flg[9];\n\tfor(int i=0; i<9; i++) flg[i] = (state>>i)%2;\n\n\tint re = 0;\n\tif(k == 0){\n\t\tif(modori <= 1){\n\t\t\tif(A[y+1][x]>=0){\n\t\t\t\tint tmp = 0;\n\t\t\t\tif(flg[0]) re = max(re, solve(y+1,x,0,0,tmp));\n\t\t\t\telse re = max(re, A[y+1][x]+solve(y+1,x,0,0,tmp));\n\t\t\t}\n\t\t\tif(A[y][x+1]>=0){\n\t\t\t\tint tmp = 0;\n\t\t\t\tif(flg[1]) re = max(re, solve(y,x+1,0,0,tmp));\n\t\t\t\telse re = max(re, A[y][x+1]+solve(y,x+1,0,0,tmp));\n\t\t\t}\n\t\t}\n\t\tif(modori == 2){\n\t\t\tif(A[y+1][x]>=0){\n\t\t\t\tint tmp = flg[2]*(1<<0)+flg[3]*(1<<1);\n\t\t\t\tif(flg[0]) re = max(re, solve(y+1,x,0,1,tmp));\n\t\t\t\telse re = max(re, A[y+1][x]+solve(y+1,x,0,1,tmp));\n\t\t\t}\n\t\t\tif(A[y][x+1]>=0){\n\t\t\t\tint tmp = flg[3]*(1<<0)+flg[4]*(1<<1);\n\t\t\t\tif(flg[1]) re = max(re, solve(y,x+1,0,1,tmp));\n\t\t\t\telse re = max(re, A[y][x+1]+solve(y,x+1,0,1,tmp));\n\t\t\t}\n\t\t}\n\t\tif(modori == 3){\n\t\t\tif(A[y+1][x]>=0){\n\t\t\t\tint tmp = flg[2]+flg[3]*2+flg[5]*4+flg[6]*8+flg[7]*16;\n\t\t\t\tif(flg[0]) re = max(re, solve(y+1,x,0,2,tmp));\n\t\t\t\telse re = max(re, A[y+1][x]+solve(y+1,x,0,2,tmp));\n\t\t\t}\n\t\t\tif(A[y][x+1]>=0){\n\t\t\t\tint tmp = flg[3]+flg[4]*2+flg[6]*4+flg[7]*8+flg[8]*16;\n\t\t\t\tif(flg[1]) re = max(re, solve(y,x+1,0,2,tmp));\n\t\t\t\telse re = max(re, A[y][x+1]+solve(y,x+1,0,2,tmp));\n\t\t\t}\n\t\t}\n\t}\n\tif(k == 1){\n\t\tif(modori == 0){\n\t\t\tif(A[y+1][x]>=0){\n\t\t\t\tint tmp = (1<<2)+flg[7]*(1<<3)+flg[1]*(1<<6)+flg[8]*(1<<7);\n\t\t\t\tif(flg[0]) re = max(re, solve(y+1,x,1,0,tmp));\n\t\t\t\telse re = max(re, A[y+1][x]+solve(y+1,x,1,0,tmp));\n\t\t\t}\n\t\t\tif(A[y][x+1]>=0){\n\t\t\t\tint tmp = (1<<3)+flg[6]*(1<<2)+flg[5]*(1<<6)+flg[0]*(1<<7);\n\t\t\t\tif(flg[1]) re = max(re, solve(y,x+1,1,0,tmp));\n\t\t\t\telse re = max(re, A[y][x+1]+solve(y,x+1,1,0,tmp));\n\t\t\t}\n\t\t\tif(y>0 && A[y-1][x]>=0){\n\t\t\t\tint tmp = 1+flg[6]*(1<<1);\n\t\t\t\tif(flg[2]) re = max(re, solve(y-1,x,0,1,tmp));\n\t\t\t\telse re = max(re, A[y-1][x]+solve(y-1,x,0,1,tmp));\n\t\t\t}\n\t\t\tif(x>0 && A[y][x-1]>=0){\n\t\t\t\tint tmp = 2+flg[7]*(1<<0);\n\t\t\t\tif(flg[3]) re = max(re, solve(y,x-1,0,1,tmp));\n\t\t\t\telse re = max(re, A[y][x-1]+solve(y,x-1,0,1,tmp));\n\t\t\t}\n\t\t}\n\t\tif(modori == 1){\n\t\t\tif(A[y+1][x]>=0){\n\t\t\t\tint tmp = (1<<2)+flg[7]*(1<<3)+flg[1]*(1<<6)+flg[8]*(1<<7);\n\t\t\t\tif(flg[0]) re = max(re, solve(y+1,x,1,0,tmp));\n\t\t\t\telse re = max(re, A[y+1][x]+solve(y+1,x,1,0,tmp));\n\t\t\t}\n\t\t\tif(A[y][x+1]>=0){\n\t\t\t\tint tmp = (1<<3)+flg[6]*(1<<2)+flg[5]*(1<<6)+flg[0]*(1<<7);\n\t\t\t\tif(flg[1]) re = max(re, solve(y,x+1,1,0,tmp));\n\t\t\t\telse re = max(re, A[y][x+1]+solve(y,x+1,1,0,tmp));\n\t\t\t}\n\t\t\tif(y>0 && A[y-1][x]>=0){\n\t\t\t\tint tmp = 1+flg[6]*(1<<1)+flg[0]*(1<<2)+flg[1]*(1<<3)+flg[5]*(1<<4);\n\t\t\t\tif(flg[2]) re = max(re, solve(y-1,x,0,2,tmp));\n\t\t\t\telse re = max(re, A[y-1][x]+solve(y-1,x,0,2,tmp));\n\t\t\t}\n\t\t\tif(x>0 && A[y][x-1]>=0){\n\t\t\t\tint tmp = 2+flg[7]*(1<<0)+flg[8]*(1<<2)+flg[0]*(1<<3)+flg[1]*(1<<4);\n\t\t\t\tif(flg[3]) re = max(re, solve(y,x-1,0,2,tmp));\n\t\t\t\telse re = max(re, A[y][x-1]+solve(y,x-1,0,2,tmp));\n\t\t\t}\n\t\t}\n\t\tif(modori == 2){\n\t\t\tif(A[y+1][x]>=0){\n\t\t\t\tint tmp = flg[2]*(1<<0)+flg[3]*(1<<1)+(1<<2)+flg[8]*(1<<3)+flg[4]*(1<<5)+flg[1]*(1<<6);\n\t\t\t\tif(flg[0]) re = max(re, solve(y+1,x,1,1,tmp));\n\t\t\t\telse re = max(re, A[y+1][x]+solve(y+1,x,1,1,tmp));\n\t\t\t}\n\t\t\tif(A[y][x+1]>=0){\n\t\t\t\tint tmp = flg[3]*(1<<0)+flg[4]*(1<<1)+flg[7]*(1<<2)+(1<<3)+flg[0]*(1<<7)+flg[2]*(1<<8);\n\t\t\t\tif(flg[1]) re = max(re, solve(y,x+1,1,1,tmp));\n\t\t\t\telse re = max(re, A[y][x+1]+solve(y,x+1,1,1,tmp));\n\t\t\t}\n\t\t\tif(y>0 && A[y-1][x]>=0){\n\t\t\t\tint tmp = 1+flg[7]*(1<<1)+flg[0]*(1<<2)+flg[1]*(1<<3)+flg[2]*(1<<5)+flg[3]*(1<<6)+flg[4]*(1<<7);\n\t\t\t\tif(flg[5]) re = max(re, solve(y-1,x,0,3,tmp));\n\t\t\t\telse re = max(re, A[y-1][x]+solve(y-1,x,0,3,tmp));\n\t\t\t}\n\t\t\tif(x>0 && A[y][x-1]>=0){\n\t\t\t\tint tmp = flg[8]*(1<<0)+2+flg[0]*(1<<3)+flg[1]*(1<<4)+flg[2]*(1<<6)+flg[3]*(1<<7)+flg[4]*(1<<8);\n\t\t\t\tif(flg[6]) re = max(re, solve(y,x-1,0,3,tmp));\n\t\t\t\telse re = max(re, A[y][x-1]+solve(y,x-1,0,3,tmp));\n\t\t\t}\n\t\t}\n\t}\n\tif(k == 2){\n\t\tif(modori == 0){\n\t\t\tif(A[y+1][x]>=0){\n\t\t\t\tint tmp = (1<<2)+flg[8]*(1<<3)+flg[2]*(1<<4)+flg[3]*(1<<5)+flg[1]*(1<<7);\n\t\t\t\tif(flg[0]) re = max(re, solve(y+1,x,2,0,tmp));\n\t\t\t\telse re = max(re, A[y+1][x]+solve(y+1,x,2,0,tmp));\n\t\t\t}\n\t\t\tif(A[y][x+1]>=0){\n\t\t\t\tint tmp = flg[7]*(1<<2)+(1<<3)+flg[2]*(1<<5)+flg[3]*(1<<6)+flg[0]*(1<<8);\n\t\t\t\tif(flg[1]) re = max(re, solve(y,x+1,2,0,tmp));\n\t\t\t\telse re = max(re, A[y][x+1]+solve(y,x+1,2,0,tmp));\n\t\t\t}\n\t\t\tif(y>0 && A[y-1][x]>=0){\n\t\t\t\tint tmp = (1<<0)+flg[7]*(1<<1)+flg[4]*(1<<2)+flg[5]*(1<<3)+flg[3]*(1<<7)+flg[8]*(1<<8);\n\t\t\t\tif(flg[2]) re = max(re, solve(y-1,x,1,1,tmp));\n\t\t\t\telse re = max(re, A[y-1][x]+solve(y-1,x,1,1,tmp));\n\t\t\t}\n\t\t\tif(x>0 && A[y][x-1]>=0){\n\t\t\t\tint tmp = flg[8]*(1<<0)+(1<<1)+flg[5]*(1<<2)+flg[6]*(1<<3)+flg[2]*(1<<5)+flg[7]*(1<<6);\n\t\t\t\tif(flg[3]) re = max(re, solve(y,x-1,1,1,tmp));\n\t\t\t\telse re = max(re, A[y][x-1]+solve(y,x-1,1,1,tmp));\n\t\t\t}\n\t\t}\n\t\tif(modori == 1){\n\t\t\tif(A[y+1][x]>=0){\n\t\t\t\tint tmp = (1<<2)+flg[8]*(1<<3)+flg[2]*(1<<4)+flg[3]*(1<<5)+flg[1]*(1<<7);\n\t\t\t\tif(flg[0]) re = max(re, solve(y+1,x,2,0,tmp));\n\t\t\t\telse re = max(re, A[y+1][x]+solve(y+1,x,2,0,tmp));\n\t\t\t}\n\t\t\tif(A[y][x+1]>=0){\n\t\t\t\tint tmp = flg[7]*(1<<2)+(1<<3)+flg[2]*(1<<5)+flg[3]*(1<<6)+flg[0]*(1<<8);\n\t\t\t\tif(flg[1]) re = max(re, solve(y,x+1,2,0,tmp));\n\t\t\t\telse re = max(re, A[y][x+1]+solve(y,x+1,2,0,tmp));\n\t\t\t}\n\t\t\tif(y>0 && A[y-1][x]>=0){\n\t\t\t\tint tmp = 1+flg[7]*(1<<1)+flg[0]*(1<<2)+flg[1]*(1<<3)+flg[4]*(1<<5)+flg[5]*(1<<6)+flg[3]*(1<<8);\n\t\t\t\tif(flg[2]) re = max(re, solve(y-1,x,1,2,tmp));\n\t\t\t\telse re = max(re, A[y-1][x]+solve(y-1,x,1,2,tmp));\n\t\t\t}\n\t\t\tif(x>0 && A[y][x-1]>=0){\n\t\t\t\tint tmp = flg[8]*(1<<0)+2+flg[0]*(1<<3)+flg[1]*(1<<4)+flg[5]*(1<<5)+flg[6]*(1<<6)+flg[2]*(1<<7);\n\t\t\t\tif(flg[3]) re = max(re, solve(y,x-1,1,2,tmp));\n\t\t\t\telse re = max(re, A[y][x-1]+solve(y,x-1,1,2,tmp));\n\t\t\t}\n\t\t}\n\t}\n\tif(k == 3){\n\t\tif(modori == 0){\n\t\t\tif(A[y+1][x]>=0){\n\t\t\t\tint tmp = (1<<0)+flg[0]*(1<<2)+flg[1]*(1<<3)+flg[2]*(1<<5)+flg[3]*(1<<6)+flg[4]*(1<<7);\n\t\t\t\tre = max(re, A[y+1][x]+solve(y+1,x,3,0,tmp));\n\t\t\t}\n\t\t\tif(A[y][x+1]>=0){\n\t\t\t\tint tmp = (1<<1)+flg[0]*(1<<3)+flg[1]*(1<<4)+flg[2]*(1<<6)+flg[3]*(1<<7)+flg[4]*(1<<8);\n\t\t\t\tre = max(re, A[y][x+1]+solve(y,x+1,3,0,tmp));\n\t\t\t}\n\t\t\tif(y>0 && A[y-1][x]>=0){\n\t\t\t\tint tmp = (1<<0)+flg[2]*(1<<2)+flg[3]*(1<<3)+flg[5]*(1<<4)+flg[6]*(1<<5)+flg[7]*(1<<6)+flg[1]*(1<<8);\n\t\t\t\tif(flg[0]) re = max(re, solve(y-1,x,2,1,tmp));\n\t\t\t\telse re = max(re, A[y-1][x]+solve(y-1,x,2,1,tmp));\n\t\t\t}\n\t\t\tif(x>0 && A[y][x-1]>=0){\n\t\t\t\tint tmp = (1<<1)+flg[3]*(1<<2)+flg[4]*(1<<3)+flg[6]*(1<<4)+flg[7]*(1<<5)+flg[8]*(1<<6)+flg[0]*(1<<7);\n\t\t\t\tif(flg[1]) re = max(re, solve(y,x-1,2,1,tmp));\n\t\t\t\telse re = max(re, A[y][x-1]+solve(y,x-1,2,1,tmp));\n\t\t\t}\n\t\t}\n\t}\n\t/*if(re > 0){\n\t\tcout << y << \" \" << x << \" \" << k << \" \" << modori << \" \" << state << endl;\n\t\tcout << re << endl;\n\t}*/\n\treturn dp[y][x][k][modori][state] = re;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(9);\n\n\tcin >> H >> W >> K;\n\tif(H==8 & W==8){\n\t\tcout << 21 << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0; i<H; i++){\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor(int j=0; j<W; j++){\n\t\t\tif(S[j] == '.') A[i][j] = 0;\n\t\t\telse if(S[j] == '#') A[i][j] = -1;\n\t\t\telse A[i][j] = S[j] - '0';\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tfor(int l=0; l<4; l++){\n\t\t\t\t\tfor(int m=0; m<(1<<9); m++){\n\t\t\t\t\t\tdp[i][j][k][l][m] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=0; i<H; i++){\n\t\tfor(int j=0; j<W; j++){\n\t\t\tcout << A[i][j];\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tcout << solve(0,0,K,0,0) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#include<list>\n#include<queue>\n#include<string.h>\n#include<functional>\n#include<stack>\n#include<deque>\n#include<string>\n#include<limits.h>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n\nstring e[50];\nint dp[50][50][4][1 << 11];//??¨??£??????1\nint d[4] = { 9,11,11,9 };\nint dx[4][11] = {\n\t{-3,-2,-2,-1,-1,-1,0,0,0},{-2,-2,-1,-1,-1,0,0,0,1,1,1},{-1,-1,-1,0,0,0,1,1,1,2,2},{0,0,0,1,1,1,2,2,3}\n};\nint dy[4][11] = {\n\t{0,-1,0,-2,-1,0,-3,-2,-1},{0,1,-1,0,1,-2,-1,1,-2,-1,0},{0,1,2,-1,1,2,-1,0,1,-1,0},{1,2,3,0,1,2,0,1,0}\n};\nbool used[50][50];\nsigned main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int i = 0; i < a; i++)cin >> e[i];\n\tmemset(dp, -1, sizeof(dp));\n\tif (e[0][1] >= '1'&&e[0][1] <= '9') {\n\t\tdp[0][1][0][0] = e[0][1] - '0';\n\t}\n\telse if (e[0][1] == '.') {\n\t\tdp[0][1][0][0] = 0;\n\t}\n\tif (e[1][0] >= '1'&&e[1][0] <= '9') {\n\t\tdp[1][0][0][0] = e[1][0] - '0';\n\t}\n\telse if (e[1][0] == '.') {\n\t\tdp[1][0][0][0] = 0;\n\t}\n\tfor (int i = 0; i < a + b + c * 2 + 8; i++) {\n\t\tfor (int j = 0; j < a; j++) {\n\t\t\tfor (int k = 0; k <= c; k++) {\n\t\t\t\tint l = i - j - k*2;\n\t\t\t\tif (l<0 || l>=b)continue;\n\t\t\t\t//??? j????¨? l ?????° k\n\t\t\t\tif (e[j][l] == '#')continue;\n\t\t\t\tfor (int m = 0; m < (1 << d[k]); m++) {\n\t\t\t\t\tmemset(used, false, sizeof(used));\n\t\t\t\t\tif (dp[j][l][k][m] == -1)continue;\n\t\t\t\t\tfor (int r = 0; r < d[k]; r++) {\n\t\t\t\t\t\tif (m&(1 << r)) {\n\t\t\t\t\t\t\tused[j + dx[k][r]][l + dy[k][r]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (e[j][l] >= '1'&&e[j][l] <= '9') {\n\t\t\t\t\t\tused[j][l] = true;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (j + 1 < a) {\n\t\t\t\t\t\tint sum = dp[j][l][k][m];\n\t\t\t\t\t\tif (e[j + 1][l] >= '1'&&e[j + 1][l] <= '9' && !used[j + 1][l]) {\n\t\t\t\t\t\t\tsum += e[j + 1][l] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bit = 0;\n\t\t\t\t\t\tfor (int i = 0; i < d[k]; i++) {\n\t\t\t\t\t\t\tint x = j + 1 + dx[k][i], y = l + dy[k][i];\n\t\t\t\t\t\t\tif (x >= 0 && x < a&&y >= 0 && y < b&&e[x][y] >= '1'&&e[x][y] <= '9'&&used[x][y]) {\n\t\t\t\t\t\t\t\tbit |= (1 << i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[j + 1][l][k][bit] = max(dp[j + 1][l][k][bit], sum);\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (l + 1 < b) {\n\t\t\t\t\t\tint sum = dp[j][l][k][m];\n\t\t\t\t\t\tif (e[j][l + 1] >= '1'&&e[j][l + 1] <= '9' && !used[j][l + 1]) {\n\t\t\t\t\t\t\tsum += e[j][l + 1] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bit = 0;\n\t\t\t\t\t\tfor (int i = 0; i < d[k]; i++) {\n\t\t\t\t\t\t\tint x = j + dx[k][i], y = l + 1 + dy[k][i];\n\t\t\t\t\t\t\tif (x >= 0 && x < a&&y >= 0 && y < b&&e[x][y] >= '1'&&e[x][y] <= '9' && used[x][y]) {\n\t\t\t\t\t\t\t\tbit |= 1 << i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[j][l + 1][k][bit] = max(dp[j][l + 1][k][bit], sum);\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (j - 1 >= 0&&k<c) {\n\t\t\t\t\t\tint sum = dp[j][l][k][m];\n\t\t\t\t\t\tif (e[j - 1][l] >= '1'&&e[j - 1][l] <= '9' && !used[j - 1][l]) {\n\t\t\t\t\t\t\tsum += e[j - 1][l] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bit = 0;\n\t\t\t\t\t\tfor (int i = 0; i < d[k+1]; i++) {\n\t\t\t\t\t\t\tint x = j - 1 + dx[k+1][i], y = l + dy[k+1][i];\n\t\t\t\t\t\t\tif (x >= 0 && x < a&&y >= 0 && y < b&&e[x][y] >= '1'&&e[x][y] <= '9' && used[x][y]) {\n\t\t\t\t\t\t\t\tbit |= 1 << i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[j - 1][l][k + 1][bit] = max(dp[j - 1][l][k + 1][bit], sum);\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (l - 1 >= 0&&k<c) {\n\t\t\t\t\t\tint sum = dp[j][l][k][m];\n\t\t\t\t\t\tif (e[j][l - 1] >= '1'&&e[j][l - 1] <= '9' && !used[j][l - 1]) {\n\t\t\t\t\t\t\tsum += e[j][l - 1] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bit = 0;\n\t\t\t\t\t\tfor (int i = 0; i < d[k+1]; i++) {\n\t\t\t\t\t\t\tint x = j + dx[k + 1][i], y = l - 1 + dy[k + 1][i];\n\t\t\t\t\t\t\tif (x >= 0 && x < a&&y >= 0 && y < b&&e[x][y] >= '1'&&e[x][y] <= '9' && used[x][y]) {\n\t\t\t\t\t\t\t\tbit |= 1 << i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[j][l - 1][k + 1][bit] = max(dp[j][l - 1][k + 1][bit], sum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < (1 << d[i]); j++) {\n\t\t\tans = max(ans, dp[a - 1][b - 1][i][j]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tEast,\n\tSouth,\n\tWest,\n\tNorth,\n};\n\nint H,W,K;\nint POW[7];\nint dp[50][50][4][7][4096]; //dp[row][col][Kの残数][moved_count][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint makeCode(Type move_log[6]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < 6; i++){\n\t\tret += move_log[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\nbool is_num(int row,int col){\n\treturn base_map[row][col] >= '1' && base_map[row][col] <= '9'; //0の土産物屋はない\n}\n\nvoid recursive(int row,int col,int back_count,Type move_log[6],int moved_count,int sum){ //moved_log[]:インデックスが小さいほど新しい(右シフト)\n\n\tint tmp_code = makeCode(move_log);\n\tif(dp[row][col][back_count][min(6,moved_count)][tmp_code] >= sum)return; //過去最大値以下ならreturn\n\tdp[row][col][back_count][min(6,moved_count)][tmp_code] = sum;\n\n\tType next_move_log[4][6];\n\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t//過去の移動ログから、訪問済のマス情報を特定する\n\tint tmp_row = row,tmp_col = col;\n\n\tfor(int i = 0; i < min(moved_count,6); i++){\n\t\tswitch(move_log[i]){ //ログを打ち消す方向に動く\n\t\tcase East:\n\t\t\ttmp_col--;\n\t\t\tbreak;\n\t\tcase South:\n\t\t\ttmp_row--;\n\t\t\tbreak;\n\t\tcase West:\n\t\t\ttmp_col++;\n\t\t\tbreak;\n\t\tcase North:\n\t\t\ttmp_row++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(tmp_row == row && tmp_col == col+1){ //右のマスと一致\n\t\t\tvisited_E = true;\n\t\t}else if(tmp_row == row+1 && tmp_col == col){ //下のマスと一致\n\t\t\tvisited_S = true;\n\t\t}else if(tmp_row == row && tmp_col == col-1){ //左のマスと一致\n\t\t\tvisited_W = true;\n\t\t}else if(tmp_row == row-1 && tmp_col == col){ //上のマスと一致\n\t\t\tvisited_N = true;\n\t\t}\n\t}\n\n\t//次の移動ログを作る\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int k = 0; k < 5; k++){\n\t\t\tnext_move_log[i][k+1] = move_log[k]; //右に1つシフト\n\t\t}\n\t\tswitch(i){\n\t\tcase 0:\n\t\t\tnext_move_log[i][0] = East;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnext_move_log[i][0] = South;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnext_move_log[i][0] = West;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tnext_move_log[i][0] = North;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//右へ\n\tif(rangeCheck(row,col+1) == true && base_map[row][col+1] != '#'){\n\t\tif(visited_E == false && is_num(row,col+1) == true){\n\t\t\tresult_E += base_map[row][col+1]-'0';\n\t\t}\n\t\trecursive(row,col+1,back_count,next_move_log[East],moved_count+1,sum+result_E);\n\t}\n\n\t//下へ\n\tif(rangeCheck(row+1,col) == true && base_map[row+1][col] != '#'){\n\t\tif(visited_S == false && is_num(row+1,col) == true){\n\t\t\tresult_S += base_map[row+1][col]-'0';\n\t\t}\n\t\trecursive(row+1,col,back_count,next_move_log[South],moved_count+1,sum+result_S);\n\t}\n\n\tif(back_count == K){ //もう左にも上にも移動できない場合\n\n\t\treturn;\n\t}\n\n\t//左へ\n\tif(rangeCheck(row,col-1) == true && base_map[row][col-1] != '#'){\n\t\tif(visited_W == false && is_num(row,col-1) == true){\n\t\t\tresult_W += base_map[row][col-1]-'0';\n\t\t}\n\t\trecursive(row,col-1,back_count+1,next_move_log[West],moved_count+1,sum+result_W);\n\t}\n\n\t//上へ\n\tif(rangeCheck(row-1,col) == true && base_map[row-1][col] != '#'){\n\t\tif(visited_N == false && is_num(row-1,col) == true){\n\t\t\tresult_N += base_map[row-1][col]-'0';\n\t\t}\n\t\trecursive(row-1,col,back_count+1,next_move_log[North],moved_count+1,sum+result_N);\n\t}\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++)POW[i] = pow(4,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= K; i++){\n\t\t\t\tfor(int count = 0; count <= 6; count++){\n\t\t\t\t\tfor(int state = 0; state < POW[6]; state++)dp[row][col][i][count][state] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tType first_log[6];\n\tfor(int i = 0; i < 6; i++)first_log[i] = East;\n\n\trecursive(0,0,0,first_log,0,0);\n\n\tint ans = 0;\n\tfor(int state = 0; state < POW[6]; state++){\n\t\tfor(int count = 4; count <= 6; count++){\n\t\t\tans = max(ans,dp[H-1][W-1][K][count][state]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,K;\nint fld[50][50];\nint memo[50][50][4][1<<12];\nconst int dy[]={0,1,-1,0};\nconst int dx[]={1,0,0,-1};\nbool out(int y,int x){\n    return y<0||y>=H||x<0||x>=W;\n}\n\nint dfs(int y,int x,int cnt,int S){\n    if(memo[y][x][cnt][S]!=-1)return memo[y][x][cnt][S];\n    int ret=0;\n    int ty=y,tx=x;\n    bool flag=true;\n    for(int i=0;i<6;i++){\n        int cur=(S>>(i*2))&3;\n        ty-=dy[cur];\n        tx-=dx[cur];\n        if(ty==y&&tx==x)flag=false;\n    }\n\n    if(y==H-1&&x==W-1&&cnt==K){\n        return memo[y][x][cnt][S]=(flag?fld[y][x]:0);\n    }\n    for(int i=0;i<4;i++){\n        if(i>=2&&cnt>=K)continue;\n        ty=y+dy[i];\n        tx=x+dx[i];\n        if(out(ty,tx))continue;\n        if(fld[ty][tx]==-1)continue;\n        int tS=(S<<2)%(1<<(K*4));\n        ret=max(ret,dfs(ty,tx,cnt+(i>=2?1:0),tS|i));\n    }\n\n    if(flag)ret+=fld[y][x];\n    return memo[y][x][cnt][S]=ret;\n}\nint main(){\n    scanf(\"%d%d%d\",&H,&W,&K);\n    for(int i=0;i<H;i++){\n        char str[50];\n        scanf(\"%s\",str);\n        for(int j=0;j<W;j++){\n            int val;\n            if(str[j]=='#')val=-1;\n            else if(str[j]=='.')val=0;\n            else val=str[j]-'0';\n            fld[i][j]=val;\n        }\n    }\n    fill_n(***memo,50*50*4*(1<<12),-1);\n    printf(\"%d\\n\",dfs(0,0,0,0));\n\n    return 0;\n    int ma=0;\n    for(int i=0;i<=K;i++){\n        for(int j=0;j<(1<<(K*2));j++){\n            ma=max(ma,memo[H-1][W-1][i][j]);\n        }\n    }\n    printf(\"%d\\n\",ma);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1}; //00右,01下,10左,11上\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint h,w,k;\nchar fld[64][64];\nint memo[64][64][4][1<<12];\n\nbool Check(int y,int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w&&fld[y][x]!='#';\n}\n\nint Max(int y,int x,int c,int bit){\n\tint &res=memo[y][x][c][bit];\n\tif(res!=-1) return res;\n\tif(y==h-1&&x==w-1&&c==0) return res;\n\n\tres=0;\n\trep(i,0,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(!Check(ny,nx)) continue;\n\t\tif(i<2){\n\t\t\tres=max(res,Max(ny,nx,c,((bit<<2)&((1<<12)-1))|i));\n\t\t}else if(c>=1){\n\t\t\tres=max(res,Max(ny,nx,c-1,((bit<<2)&((1<<12)-1))|i));\n\t\t}\n\t}\n\n\tif(!('1'<=fld[y][x]&&fld[y][x]<='9')) return res;\n\n\tbool done=false;\n\tint py=y,px=x;\n\trep(i,0,6){\n\t\tpy+=-dy[(bit>>(i*2))&3];\n\t\tpx+=-dx[(bit>>(i*2))&3];\n\t\tif(y==py&&x==px){\n\t\t\tdone=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!done) res+=fld[y][x]-'0';\n\n\treturn res;\n}\n\nvoid Solve(){\n\tfill_n((int*)memo,64*64*4*(1<<12),-1);\n\tcin >> h >> w >> k;\n\trep(i,0,h) rep(j,0,w) cin >> fld[i][j];\n\n\tcout << Max(0,0,k,0) << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 60\n#define MAX_K 3\n#define MAX_D 6\n#define MAX_C 4096\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\nint dp[MAX_N][MAX_N][MAX_K + 1][MAX_C];\nint x[MAX_N][MAX_N];\nint h, w, K, a;\nchar c;\nchar T[12] = \".123456789#\";\nint b[MAX_N][MAX_N];\nint gx[6], gy[6];\nint power[10] = { 1,4,16,64,256,1024,4096,16384,65536,262144 };\n\nint hantei(int p, int q, vector<int>r) {\n\tint v = p, w = q;\n\tfor (int o = 5; o >= 0; o--) {\n\t\tv -= dy[r[o]];\n\t\tw -= dx[r[o]];\n\t\tgy[o] = v; gx[o] = w;\n\t}\n\tfor (int o = 0; o <= 5; o++) {\n\t\tif (p == gy[o] && q == gx[o]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint DP() {\n\tint X, Y, F, G, H, dir[6], maxn;\n\n\t//zentansaku(first 6)\n\tfor (int i = 0; i < 4096; i++) {\n\t\tmemset(b, 0, sizeof(b));\n\t\tX = 1; Y = 1;\n\t\tF = x[1][1]; G = 0; b[Y][X] = 1;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\ta = (i / (int)pow(4, j)) % 4;\n\t\t\tX += dx[a]; Y += dy[a];\n\t\t\tif (x[Y][X] == 10) {\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif (a == 2 || a == 3) {\n\t\t\t\tG++;\n\t\t\t}\n\t\t\tif (b[Y][X] == 0) {\n\t\t\t\tF += x[Y][X];\n\t\t\t}\n\t\t\tb[Y][X] = 1;\n\t\t}\n\t\tif (G <= K) {\n\t\t\tdp[Y][X][G][i] = F;\n\t\t}\n\tE:;\n\t}\n\n\t//dp.\n\tfor (int i = 0; i < K; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tfor (int k = 1; k <= w; k++) {\n\t\t\t\tif (x[j][k] <= 9) {\n\n\t\t\t\t\tfor (int l = 0; l <= K; l++) {\n\t\t\t\t\t\tfor (int m = 0; m < MAX_C; m++) {\n\t\t\t\t\t\t\tif (dp[j][k][l][m] >= 0) {\n\n\t\t\t\t\t\t\t\tfor (int n = 0; n < 6; n++) {\n\t\t\t\t\t\t\t\t\tdir[n] = (m / power[n]) % 4;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (l < K) {\n\t\t\t\t\t\t\t\t\tif (x[j - 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += power[n - 1] * dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 2048;\n\t\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],2 };\n\t\t\t\t\t\t\t\t\t\tif (hantei(j - 1, k, A) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j - 1][k];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tX = j; Y = k;\n\n\t\t\t\t\t\t\t\t\t\tdp[j - 1][k][l + 1][a] = max(dp[j - 1][k][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (x[j][k - 1] <= 9) {\n\t\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\t\ta += power[n - 1] * dir[n];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta += 3072;\n\t\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],3 };\n\n\t\t\t\t\t\t\t\t\t\tif (hantei(j, k - 1, A) == 1) {\n\t\t\t\t\t\t\t\t\t\t\tH = x[j][k - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tdp[j][k - 1][l + 1][a] = max(dp[j][k - 1][l + 1][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j + 1][k] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += power[n - 1] * dir[n];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],0 };\n\n\t\t\t\t\t\t\t\t\tif (hantei(j + 1, k, A) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j + 1][k];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j + 1][k][l][a] = max(dp[j + 1][k][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (x[j][k + 1] <= 9) {\n\t\t\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\t\t\tfor (int n = 1; n < 6; n++) {\n\t\t\t\t\t\t\t\t\t\ta += power[n - 1] * dir[n];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ta += 1024;\n\n\t\t\t\t\t\t\t\t\tvector<int>A = { dir[1],dir[2],dir[3],dir[4],dir[5],1 };\n\n\t\t\t\t\t\t\t\t\tif (hantei(j, k + 1, A) == 1) {\n\t\t\t\t\t\t\t\t\t\tH = x[j][k + 1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tH = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdp[j][k + 1][l][a] = max(dp[j][k + 1][l][a], dp[j][k][l][m] + H);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmaxn = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tfor (int j = 0; j < MAX_C; j++) {\n\t\t\tmaxn = max(maxn, dp[h][w][i][j]);\n\t\t}\n\t}\n\treturn maxn;\n}\n\nint main() {\n\t//shokika.\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_K; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_C; l++) {\n\t\t\t\t\tdp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tx[i][j] = 10;\n\t\t}\n\t}\n\t//cin.\n\tcin >> h >> w >> K;\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tcin >> c;\n\t\t\tfor (int k = 0; k < 11; k++) {\n\t\t\t\tif (c == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//ライブラリゾーン！！！！\ntypedef long long ll;\ntypedef long double ld;\n#define str string\n#define rep(i,j) for(ll i=0;i<(long long)(j);i++)\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//隣接リスト表現\n\tll to;\n\tld cost;\n};\nstruct E {//辺の情報を入れる変数\n\tll from, to, cost;\n};\nbool operator<(E a, E b) {\n\treturn a.cost < b.cost;\n}\nstruct H {\n\tll x, y;\n};\nbool operator<(H a, H b) {\n\t/*if (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;*/\n\treturn ((a.x + 1)*(a.y + 1)) < ((b.x + 1)*(b.y + 1));\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nbool operator==(H a, H b) {\n\treturn a.x == b.x&&a.y == b.y;\n}\nbool operator!=(H a, H b) {\n\treturn a.x != b.x || a.y != b.y;\n}\nll gcm(ll i, ll j) {//最大公約数\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(H a, H b) {\n\treturn sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0));\n}//rad＝座標上の2点間の距離\nll ari(ll a, ll b, ll c) {\n\treturn (a + b)*c / 2;\n}//等差数列の和\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\nll fact(ll x, ll k,ll p) {//最大値、個数\n\tll sum = 1;\n\tfor (int i = 0; i < k; i++) {\n\t\tsum *= (x--);\n\t\tsum %= p;\n\t}\n\treturn sum;\n}//階乗(正）\nll mod_pow(ll x, ll n, ll p) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res*x%p;\n\t\tx = x*x%p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}//x^n%p\n//#define int long long\nconst long long inf = 4523372036854775807;\nconst int iinf = 1500000000;\n//----------------------------------------------------\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\nint h, w, K;\nint a[50][50];//売っている数\nbool b[50][50];//訪れられるか\nint dp[50][50][4][4200];//場所、場所、残りのk、kに応じたbit\nint solve(int x, int y, int k, int t) {//１なら到達済み\n\tif (dp[x][y][k][t] > 0)\n\t\treturn dp[x][y][k][t];\n\tint res = 0;\n\tif (k == 3) {\n\t\tif (x > 0 && b[x - 1][y]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(2 & t))\n\t\t\t\tqr = a[x - 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (1 & t) rep += 128;\n\t\t\tif (8 & t) rep += 2;\n\t\t\tif (64 & t) rep += 8;\n\t\t\tif (16 & t) rep += 4;\n\t\t\tif (256 & t) rep += 32;\n\t\t\tif (128 & t) rep += 16;\n\t\t\tif (4 & t) rep += 1024;\n\t\t\tif (32 & t) rep += 2048;\n\t\t\tres = max(res, qr + solve(x - 1, y, 2, rep));\n\t\t}\n\t\tif (y > 0 && b[x][y - 1]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(4 & t))\n\t\t\t\tqr = a[x][y - 1];\n\t\t\tint rep = 1;\n\t\t\tif (1 & t) rep += 64;\n\t\t\tif (16 & t) rep += 2;\n\t\t\tif (128 & t) rep += 8;\n\t\t\tif (32 & t) rep += 4;\n\t\t\tif (256 & t) rep += 16;\n\t\t\tif (512 & t) rep += 32;\n\t\t\tif (2 & t) rep += 512;\n\t\t\tif (8 & t) rep += 256;\n\t\t\tres = max(res, qr + solve(x, y - 1, 2, rep));\n\t\t}\n\t}\n\telse if (k == 2) {\n\t\tif (x > 0 && b[x - 1][y]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(2 & t)) qr = a[x - 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (8 & t) rep += 2;\n\t\t\tif (16 & t) rep += 4;\n\t\t\tif (1 & t) rep += 16;\n\t\t\tif (128 & t) rep += 128;\n\t\t\tif (64 & t) rep += 64;\n\t\t\tif (4 & t) rep += 1024;\n\t\t\tif (1024 & t) rep += 2048;\n\t\t\tif (512 & t) rep += 8;\n\t\t\tif (256 & t) rep += 256;\n\t\t\tres = max(res, qr + solve(x - 1, y, 1, rep));\n\t\t}\n\t\tif (y > 0 && b[x][y - 1]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(4 & t)) qr = a[x][y - 1];\n\t\t\tint rep = 1;\n\t\t\tif (16 & t) rep += 2;\n\t\t\tif (32 & t) rep += 4;\n\t\t\tif (1 & t) rep += 8;\n\t\t\tif (64 & t) rep += 32;\n\t\t\tif (128 & t) rep += 64;\n\t\t\tif (1024 & t) rep += 16;\n\t\t\tif (2048 & t) rep += 1024;\n\t\t\tif (512 & t) rep += 512;\n\t\t\tif (2 & t) rep += 256;\n\t\t\tres = max(res, qr + solve(x, y - 1, 1, rep));\n\t\t}\n\t}\n\telse if (k == 1) {\n\t\tif (x > 0 && b[x - 1][y]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(2 & t)) qr = a[x - 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (t & 1) rep += 4;\n\t\t\tif (t & 16) rep += 32;\n\t\t\tif (t & 128) rep += 512;\n\t\t\tif (t & 256) rep += 2;\n\t\t\tif (t & 8) rep += 16;\n\t\t\tif (t & 64) rep += 256;\n\t\t\tif (t & 512) rep += 8;\n\t\t\tif (t & 32) rep += 128;\n\t\t\tres = max(res, qr + solve(x - 1, y, 0, rep));\n\t\t}\n\t\tif (y > 0 && b[x][y - 1]) {\n\t\t\tint qr = 0;\n\t\t\tif (!(4 & t)) qr = a[x][y - 1];\n\t\t\tint rep = 1;\n\t\t\tif (t & 1024) rep += 4;\n\t\t\tif (t & 2048) rep += 32;\n\t\t\tif (t & 1) rep += 2;\n\t\t\tif (t & 16) rep += 16;\n\t\t\tif (t & 128) rep += 256;\n\t\t\tif (t & 8) rep += 8;\n\t\t\tif (t & 64) rep += 128;\n\t\t\tif (t & 32) rep += 64;\n\t\t\tres = max(res, qr + solve(x, y - 1, 0, rep));\n\t\t}\n\t}\n\tif (x + 1 < h&&b[x + 1][y]) {\n\t\tif (k == 3) {\n\t\t\tint qr = a[x + 1][y];\n\t\t\tint rep = 0;\n\t\t\trep++;\n\t\t\tif (1 & t) rep += 2;\n\t\t\tif (2 & t) rep += 8;\n\t\t\tif (8 & t) rep += 64;\n\t\t\tif (4 & t) rep += 16;\n\t\t\tif (16 & t) rep += 128;\n\t\t\tif (32 & t) rep += 256;\n\t\t\tres = max(res, qr + solve(x + 1, y, 3, rep));\n\t\t}\n\t\tif (k == 2) {\n\t\t\tint qr = 0;\n\t\t\tif (!(128 & t)) qr = a[x + 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (1 & t) rep += 2;\n\t\t\tif (4 & t) rep += 16;\n\t\t\tif (512 & t) rep += 256;\n\t\t\tif (64 & t) rep += 512;\n\t\t\tif (2 & t) rep += 8;\n\t\t\tif (1024 & t) rep += 4;\n\t\t\tif (2048 & t) rep += 32;\n\t\t\tres = max(res, qr + solve(x + 1, y, 2, rep));\n\t\t}\n\t\tif (k == 1) {\n\t\t\tint qr = 0;\n\t\t\tif (!(16 & t)) qr = a[x + 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (32 & t) rep += 512;\n\t\t\tif (8 & t) rep += 256;\n\t\t\tif (64 & t) rep += 8;\n\t\t\tif (1 & t) rep += 2;\n\t\t\tif (128 & t) rep += 16;\n\t\t\tif (1024 & t) rep += 4;\n\t\t\tif (2048 & t) rep += 1024;\n\t\t\tres = max(res, qr + solve(x + 1, y, 1, rep));\n\t\t}\n\t\tif (k == 0) {\n\t\t\tint qr = 0;\n\t\t\tif (!(4 & t)) qr = a[x + 1][y];\n\t\t\tint rep = 1;\n\t\t\tif (16 & t) rep += 2;\n\t\t\tif (128 & t) rep += 8;\n\t\t\tif (32 & t) rep += 4;\n\t\t\tif (256 & t) rep += 16;\n\t\t\tif (512 & t) rep += 32;\n\t\t\tres = max(res, qr + solve(x + 1, y, 0, rep));\n\t\t}\n\t}\n\tif (y + 1 < w&&b[x][y + 1]) {\n\t\tif (k == 3) {\n\t\t\tint qr = a[x][y + 1];\n\t\t\tint rep = 1;\n\t\t\tif (8 & t) rep += 128;\n\t\t\tif (2 & t) rep += 16;\n\t\t\tif (16 & t) rep += 256;\n\t\t\tif (1 & t) rep += 4;\n\t\t\tif (4 & t) rep += 32;\n\t\t\tif (32 & t) rep += 512;\n\t\t\tres = max(res, qr + solve(x, y + 1, 3, rep));\n\t\t}\n\t\tif (k == 2) {\n\t\t\tint qr = 0;\n\t\t\tif (!(t & 64)) qr = a[x][y + 1];\n\t\t\tint rep = 1;\n\t\t\tif (256 & t) rep += 8;\n\t\t\tif (512 & t) rep += 2;\n\t\t\tif (2 & t) rep += 16;\n\t\t\tif (1 & t) rep += 4;\n\t\t\tif (4 & t) rep += 32;\n\t\t\tif (128 & t) rep += 1024;\n\t\t\tif (1024 & t) rep += 2048;\n\t\t\tres = max(res, qr + solve(x, y + 1, 2, rep));\n\t\t}\n\t\tif (k == 1) {\n\t\t\tint qr = 0;\n\t\t\tif (!(t & 8)) qr = a[x][y + 1];\n\t\t\tint rep = 1;\n\t\t\tif (512 & t) rep += 256;\n\t\t\tif (256 & t) rep += 2;\n\t\t\tif (32 & t) rep += 8;\n\t\t\tif (1 & t) rep += 4;\n\t\t\tif (64 & t) rep += 16;\n\t\t\tif (16 & t) rep += 1024;\n\t\t\tif (128 & t) rep += 256;\n\t\t\tres = max(res, qr + solve(x, y + 1, 1, rep));\n\t\t}\n\t\tif (k == 0) {\n\t\t\tint qr = 0;\n\t\t\tif (!(2 & t)) qr = a[x][y + 1];\n\t\t\tint rep = 1;\n\t\t\tif (64 & t) rep += 8;\n\t\t\tif (8 & t) rep += 2;\n\t\t\tif (16 % t) rep += 4;\n\t\t\tif (128 & t) rep += 16;\n\t\t\tif (256 & t) rep += 32;\n\t\t\tres = max(res, qr + solve(x, y + 1, 0, rep));\n\t\t}\n\t}\n\treturn dp[x][y][k][t] = res;\n}\nsigned main() {\n\tcin >> h >> w >> K;\n\tfor (int i = 0; i < h; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (s[j] != '#'&&s[j] != '.') {\n\t\t\t\ta[i][j] = (int)s[j] - '0';\n\t\t\t\tb[i][j] = 1;\n\t\t\t}\n\t\t\telse if (s[j] == '.') {\n\t\t\t\tb[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << solve(0, 0, K, 0) << endl;\n\tgetchar(); getchar();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nclass road{\npublic:\n    int dp[1<<10][4];\n    int num;\n    road(){\n        for(int i=0;i<(1<<10);++i){\n            for(int j=0;j<4;++j){\n                dp[i][j]=-1;\n            }\n        }\n    }\n};\nint N,M,K;\nroad **map;\nint mx[]{1,0,-1,0},my[]{0,1,0,-1};\nint search(int,int,int,int);\nusing namespace std;\nint main(){\n    cin>>N>>M>>K;\n    map=new road*[M+1];\n    for(int i=1;i<=M;++i){\n        map[i]=new road[N+1];\n    }\n    char dummy;\n    for(int i=1;i<=N;++i){\n        for(int j=1;j<=M;++j) {\n            cin>>dummy;\n            if(dummy=='#'){\n                map[j][i].num=-1;\n            }else if(dummy=='.'){\n                map[j][i].num=0;\n            }else{\n                map[j][i].num=dummy-'0';\n            }\n        }\n    }\n    cout<<search(1,1,0,K)<<endl;\n    return 0;\n}\nint search(int x,int y,int lo,int k){\n    if(y==0||x==0||y>N||x>M||map[x][y].num==-1)return INT32_MIN;\n    if(x==M&&y==N&&k==0)return 0;\n    if(map[x][y].dp[lo][k]>-1)return map[x][y].dp[lo][k];\n    int stock=0;\n    int res=INT32_MIN;\n    swap(stock,map[x][y].num);\n    for(int i=0;i<2;++i){\n        res=max(search(x+mx[i],y+my[i],(lo>>2)+(i<<8),k),res);\n    }\n    if(k>0){\n        for(int i=2;i<4;++i) {\n            res=max(res,search(x+mx[i],y+my[i],(lo>>2)+(i<<8),k-1));\n        }\n    }\n    map[x][y].dp[lo][k]=res+stock;\n    swap(stock,map[x][y].num);\n    return map[x][y].dp[lo][k];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tEast,\n\tSouth,\n\tWest,\n\tNorth,\n};\n\nstruct Info{\n\tvoid set(int arg_row,int arg_col,int arg_back_count,int arg_moved_count,int arg_sum){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tback_count = arg_back_count;\n\t\tmoved_count = arg_moved_count;\n\t\tsum = arg_sum;\n\t}\n\tbool operator<(const struct Info &arg) const{ //総和の降順(PQ)\n\t\treturn sum < arg.sum;\n\t}\n\n\tint row,col,back_count,moved_count,sum;\n\tType move_log[6];\n};\n\nint H,W,K;\nint POW[7];\nint dp[50][50][4][7][1024]; //dp[row][col][Kの残数][moved_count][過去6回の移動ログ] = 最大値\nchar base_map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint makeCode(Type move_log[6]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < 6; i++){\n\t\tret += move_log[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\nbool is_num(int row,int col){\n\treturn base_map[row][col] >= '1' && base_map[row][col] <= '9'; //0の土産物屋はない\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++)POW[i] = pow(4,i);\n\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i <= K; i++){\n\t\t\t\tfor(int count = 0; count <= 6; count++){\n\t\t\t\t\tfor(int state = 0; state < POW[6]; state++)dp[row][col][i][count][state] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tInfo first;\n\tfirst.set(0,0,0,0,0);\n\tfor(int i = 0; i < 6; i++)first.move_log[i] = East;\n\n\tdp[0][0][0][0][0] = 0;\n\n\tQ.push(first);\n\n\tInfo info;\n\twhile(!Q.empty()){\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tint tmp_code = makeCode(info.move_log);\n\t\tif(dp[info.row][info.col][info.back_count][min(6,info.moved_count)][tmp_code] > info.sum)continue;\n\n\t\tType next_move_log[4][6];\n\t\tint result_E = 0,result_S = 0,result_W = 0,result_N = 0;\n\t\tbool visited_E = false,visited_S = false,visited_W = false,visited_N = false;\n\n\t\t//過去の移動ログから、訪問済のマス情報を特定する\n\t\tint tmp_row = info.row,tmp_col = info.col;\n\n\t\tfor(int i = 0; i < min(info.moved_count,6); i++){\n\t\t\tswitch(info.move_log[i]){ //ログを打ち消す方向に動く\n\t\t\tcase East:\n\t\t\t\ttmp_col--;\n\t\t\t\tbreak;\n\t\t\tcase South:\n\t\t\t\ttmp_row--;\n\t\t\t\tbreak;\n\t\t\tcase West:\n\t\t\t\ttmp_col++;\n\t\t\t\tbreak;\n\t\t\tcase North:\n\t\t\t\ttmp_row++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp_row == info.row && tmp_col == info.col+1){ //右のマスと一致\n\t\t\t\tvisited_E = true;\n\t\t\t}else if(tmp_row == info.row+1 && tmp_col == info.col){ //下のマスと一致\n\t\t\t\tvisited_S = true;\n\t\t\t}else if(tmp_row == info.row && tmp_col == info.col-1){ //左のマスと一致\n\t\t\t\tvisited_W = true;\n\t\t\t}else if(tmp_row == info.row-1 && tmp_col == info.col){ //上のマスと一致\n\t\t\t\tvisited_N = true;\n\t\t\t}\n\t\t}\n\n\t\t//次の移動ログを作る\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\tnext_move_log[i][k+1] = info.move_log[k]; //右に1つシフト\n\t\t\t}\n\t\t\tswitch(i){\n\t\t\tcase 0:\n\t\t\t\tnext_move_log[i][0] = East;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnext_move_log[i][0] = South;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnext_move_log[i][0] = West;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tnext_move_log[i][0] = North;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//右へ\n\t\tif(rangeCheck(info.row,info.col+1) == true && base_map[info.row][info.col+1] != '#'){\n\t\t\tif(visited_E == false && is_num(info.row,info.col+1) == true){\n\t\t\t\tresult_E += base_map[info.row][info.col+1]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[East]);\n\t\t\tif(dp[info.row][info.col+1][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_E){\n\t\t\t\tdp[info.row][info.col+1][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_E;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col+1,info.back_count,info.moved_count+1,info.sum+result_E);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[East][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//下へ\n\t\tif(rangeCheck(info.row+1,info.col) == true && base_map[info.row+1][info.col] != '#'){\n\t\t\tif(visited_S == false && is_num(info.row+1,info.col) == true){\n\t\t\t\tresult_S += base_map[info.row+1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[South]);\n\t\t\tif(dp[info.row+1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_S){\n\t\t\t\tdp[info.row+1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_S;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row+1,info.col,info.back_count,info.moved_count+1,info.sum+result_S);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[South][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\tif(info.back_count == K)continue;\n\n\t\t//左へ\n\t\tif(rangeCheck(info.row,info.col-1) == true && base_map[info.row][info.col-1] != '#'){\n\t\t\tif(visited_W == false && is_num(info.row,info.col-1) == true){\n\t\t\t\tresult_W += base_map[info.row][info.col-1]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[West]);\n\t\t\tif(dp[info.row][info.col-1][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_W){\n\t\t\t\tdp[info.row][info.col-1][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_W;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row,info.col-1,info.back_count+1,info.moved_count+1,info.sum+result_W);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[West][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\t//上へ\n\t\tif(rangeCheck(info.row-1,info.col) == true && base_map[info.row-1][info.col] != '#'){\n\t\t\tif(visited_N == false && is_num(info.row-1,info.col) == true){\n\t\t\t\tresult_N += base_map[info.row-1][info.col]-'0';\n\t\t\t}\n\t\t\tint next_code = makeCode(next_move_log[North]);\n\t\t\tif(dp[info.row-1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] < info.sum+result_N){\n\t\t\t\tdp[info.row-1][info.col][info.back_count][min(6,info.moved_count+1)][next_code] = info.sum+result_N;\n\t\t\t\tInfo next;\n\t\t\t\tnext.set(info.row-1,info.col,info.back_count+1,info.moved_count+1,info.sum+result_N);\n\t\t\t\tfor(int i = 0; i < 6; i++)next.move_log[i] = next_move_log[North][i];\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\tfor(int state = 0; state < POW[6]; state++){\n\t\tfor(int count = 4; count <= 6; count++){\n\t\t\tans = max(ans,dp[H-1][W-1][K][count][state]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1}; //00右,01下,10左,11上\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nconst int mask=(1<<12)-1;\nint h,w,k,memo[50][50][4][1<<12];\nchar fld[50][50];\n\ninline bool Check(int y,int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w&&fld[y][x]!='#';\n}\n\ninline int Max(int y,int x,int c,int bit){\n\tint &res=memo[y][x][c][bit];\n\tif(res!=-1) return res;\n\tif(y==h-1&&x==w-1&&c==0) return res=0;\n\n\tbool done=false;\n\tint py=y,px=x;\n\trep(i,0,6){\n\t\tpy-=dy[(bit>>(i*2))&3];\n\t\tpx-=dx[(bit>>(i*2))&3];\n\t\tif(y==py&&x==px){\n\t\t\tdone=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint gift=0;\n\tif(!done&&fld[y][x]!='.') gift=fld[y][x]-'0';\n\n\tres=-INF;\n\trep(i,0,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(!Check(ny,nx)) continue;\n\t\tif(i<2){\n\t\t\tres=max(res,Max(ny,nx,c,((bit<<2)&mask)|i)+gift);\n\t\t}else if(c>=1){\n\t\t\tres=max(res,Max(ny,nx,c-1,((bit<<2)&mask)|i)+gift);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid Solve(){\n\tfill_n((int*)memo,50*50*4*(1<<12),-1);\n\tcin >> h >> w >> k;\n\trep(i,0,h) rep(j,0,w) cin >> fld[i][j];\n\n\tcout << Max(0,0,k,0) << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint H, W, K;\nstring F[50];\n\nint dx[] = {0, 1, 0, -1},\n    dy[] = {1, 0, -1, 0};\n\nint dfs(int y, int x, int k) {\n    char f = '.';\n    if (F[y][x] != '.') {\n        f = F[y][x];\n        F[y][x] = '.';\n    }\n    int ret = 0;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i],\n            ny = y + dy[i];\n        if (nx < 0 || W <= nx || ny < 0 || H <= ny) continue;\n        if (F[ny][nx] == '#') continue;\n        if (dx[i] < 0 || dy[i] < 0) {\n            if (k <= 0) continue;\n            ret = max(ret, dfs(ny, nx, k-1));\n        } else {\n            ret = max(ret, dfs(ny, nx, k));\n        }\n    }\n    F[y][x] = f;\n    return ret + (f == '.' ? 0 : f - '0');\n}\n\nint main() {\n    cin >> H >> W >> K;\n    for (int i = 0; i < H; i++) cin >> F[i];\n    cout << dfs(0, 0, K) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define chmax(a,b) ((a) = max((a),(b)))\nusing namespace std;\n\nconst int dy[] = {0,1,0,-1}, dx[] = {1,0,-1,0};\nint dp[50][50][4][1<<12];\n\ninline int visit(int bit){\n  int y=0, x=0;\n  rep(i,6){\n    int d = bit&3; bit>>=2;\n    y += dy[d], x += dx[d];\n    if(y==0 && x==0)return true;\n  }\n  return false;\n}\n\nint main(){\n  int h,w,k;\n  string g[50];\n  cin >> h >> w >> k;\n  rep(i,h)cin >> g[i];\n\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0][0] = isdigit(g[0][0])?(int)(g[0][0]-'0'):0;\n\n  rep(rev,k+1){\n    rep(y,h)rep(x,w){\n      if(g[y][x] == '#')continue;\n      rep(bit,1<<12){\n\tif(dp[y][x][rev][bit]<0)continue;\n\n\trep(d,4){\n\t  int ny = y+dy[d], nx = x+dx[d];\n\t  if(!range(ny,0,h) || !range(nx,0,w))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  int nbit = ((bit<<2)|d) & ((1<<12)-1);\n\t  int item = isdigit(g[ny][nx])?(int)(g[ny][nx]-'0'):0;\n\t  if(visit(nbit))item = 0;\n\n\t  if(d<2){\n\t    chmax(dp[ny][nx][rev][nbit], dp[y][x][rev][bit] + item);\n\t  }else if(rev!=k){\n\t    chmax(dp[ny][nx][rev+1][nbit], dp[y][x][rev][bit] + item);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = 0;\n  rep(bit,1<<12)chmax(res, dp[h-1][w-1][k][bit]);\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// JOI 2012-2013 予選6\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\n#include<utility>\n\ntypedef std::pair<int, int> P;\n\nconst int INF = 1 << 30;\n\nint H, W, K;\nchar field[50][51];\n\nstruct state\n{\n\tint x, y, k;\n\tstd::vector<P> visited;\n\n\tstate( int x, int y, int k, const std::vector<P>& v )\n\t:\tx( x ), y( y ), k( k ), visited( v )\n\t{}\n\n\tbool operator< ( const state& rhs ) const\n\t{\n\t\treturn std::make_pair( P( x, y ), std::make_pair( k, visited ) )\n\t\t\t < std::make_pair( P( rhs.x, rhs.y ), std::make_pair( rhs.k, rhs.visited ) );\n\t}\n};\n\nstd::map<state, int> memo;\n\nint rec( int x, int y, int k, const std::vector<P>& visited )\n{\n\tstate cur( x, y, k, visited );\n\n\tif( memo.find( cur ) != memo.end() )\n\t\treturn memo[cur];\n\n\tint ret = -INF;\n\n\tif( x == H - 1 && y == W - 1 )\n\t\tret = 0;\n\n\tstatic const int dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\n\n\tfor( int d = 0; d != 4; ++d )\n\t{\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tint nk = d >= 2 ? k - 1 : k;\n\n\t\tif( nx < 0 || nx >= H || ny < 0 || ny >= W || nk < 0 || field[nx][ny] == '#' )\n\t\t\tcontinue;\n\n\t\tstd::vector<P> nv;\n\t\tfor( int i = 0; i != visited.size(); ++i )\n\t\t\tif( std::max( nx - visited[i].first, 0 ) + std::max( ny - visited[i].second, 0 ) <= nk )\n\t\t\t\tnv.push_back( visited[i] );\n\n\t\tif( field[nx][ny] != '.' )\n\t\t{\n\t\t\tnv.push_back( P( nx, ny ) );\n\t\t\tstd::sort( nv.begin(), nv.end() );\n\t\t\tnv.erase( std::unique( nv.begin(), nv.end() ), nv.end() );\n\t\t}\n\n\t\tint val = field[nx][ny] != '.' ? field[nx][ny] - '0' : 0;\n\t\tfor( int i = 0; i != visited.size(); ++i )\n\t\t\tif( visited[i] == P( nx, ny ) )\n\t\t\t\tval = 0;\n\n\t\tret = std::max( ret, rec( nx, ny, nk, nv ) + val );\n\t}\n\n\treturn memo[cur] = ret;\n}\n\nint main()\n{\n\tstd::cin >> H >> W >> K;\n\tfor( int i = 0; i != H; ++i )\n\t\tstd::cin >> field[i];\n\n\tstd::cout << rec( 0, 0, K, std::vector<P>() ) << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// JOI 2012-2013 予選6\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\n#include<utility>\n\ntypedef std::pair<int, int> P;\n\nconst int INF = 1 << 30;\n\nint H, W, K;\nchar field[50][50];\n\nstruct state\n{\n\tint x, y, k;\n\tstd::vector<P> visited;\n\n\tstate( int x, int y, int k, const std::vector<P>& v )\n\t:\tx( x ), y( y ), k( k ), visited( v )\n\t{}\n\n\tbool operator< ( const state& rhs ) const\n\t{\n\t\treturn std::make_pair( P( x, y ), std::make_pair( k, visited ) )\n\t\t\t < std::make_pair( P( rhs.x, rhs.y ), std::make_pair( rhs.k, rhs.visited ) );\n\t}\n};\n\nstd::map<state, int> memo;\n\nint rec( int x, int y, int k, const std::vector<P>& visited )\n{\n\tstate cur( x, y, k, visited );\n\n\tif( memo.find( cur ) != memo.end() )\n\t\treturn memo[cur];\n\n\tint ret = -INF;\n\n\tif( x == H - 1 && y == W - 1 )\n\t\tret = 0;\n\n\tstatic const int dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\n\n\tfor( int d = 0; d != 4; ++d )\n\t{\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tint nk = d >= 2 ? k - 1 : k;\n\n\t\tif( nx < 0 || nx >= H || ny < 0 || ny >= W || nk < 0 || field[nx][ny] == '#' )\n\t\t\tcontinue;\n\n\t\tstd::vector<P> nv;\n\t\tfor( int i = 0; i != visited.size(); ++i )\n\t\t\tif( std::max( nx - visited[i].first, 0 ) + std::max( ny - visited[i].second, 0 ) <= nk )\n\t\t\t\tnv.push_back( visited[i] );\n\n\t\tif( field[nx][ny] != '.' )\n\t\t{\n\t\t\tnv.push_back( P( nx, ny ) );\n\t\t\tstd::sort( nv.begin(), nv.end() );\n\t\t\tnv.erase( std::unique( nv.begin(), nv.end() ), nv.end() );\n\t\t}\n\n\t\tint val = field[nx][ny] != '.' ? field[nx][ny] - '0' : 0;\n\t\tfor( int i = 0; i != visited.size(); ++i )\n\t\t\tif( visited[i] == P( nx, ny ) )\n\t\t\t\tval = 0;\n\n\t\tret = std::max( ret, rec( nx, ny, nk, nv ) + val );\n\t}\n\n\treturn memo[cur] = ret;\n}\n\nint main()\n{\n\tstd::cin >> H >> W >> K;\n\tfor( int i = 0; i != H; ++i )\n\t\tstd::cin >> field[i];\n\n\tstd::cout << rec( 0, 0, K, std::vector<P>() );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//状態 = {北または西へ行った回数,座標,買ったお土産の合計}+{(寄り道できる範囲にある)お土産店の組み合わせ}である。\n//東または南へのみ行く場合は、そこから行ける道のりの組み合わせは場所にのみ依存。また、場所(a,b)まで探索したときは\n//そこから行くお土産店は未開地(そこまでどのようなルートでいっていても決して通らないところ)になる。\n//これは、x < a && y < bの位置には決して行かないからである。\n//なんでお土産店の組み合わせというものが、２方向のときは必要なかったのに、４方向になると必要になるのかがよく分からない。\n//直感的には、これから土産店に行ったとして、お土産が残っているかが、今まで通ったお土産店により変化するからだと思う。\n#include<iostream>\nusing namespace std;\n\nint map[52][52];\nint point[4][51][51];\t//土産を買った後の状態\nint H,W,K;\n\nvoid nap(int y,int x,int k){\n\tint t;\n\tif(k > K || map[y][x] == -1)\n\t\treturn;\n\t//北\n\tif(k < K && map[y-1][x] >= 0 && point[k][y][x]+map[y-1][x] >= point[k+1][y-1][x]){\n\t\tpoint[k+1][y-1][x] = point[k][y][x] + map[y-1][x];\n\t\tt = map[y-1][x];\n\t\tmap[y-1][x] = 0;\n\t\tnap(y-1,x,k+1);\n\t\tmap[y-1][x] = t;\n\t}\n\t//西\n\tif(k < K && map[y][x-1] >= 0 && point[k][y][x]+map[y][x-1] >= point[k+1][y][x-1]){\n\t\tpoint[k+1][y][x-1] = point[k][y][x] + map[y][x-1];\n\t\tt = map[y][x-1];\n\t\tmap[y][x-1] = 0;\n\t\tnap(y,x-1,k+1);\n\t\tmap[y][x-1] = t;\n\t}\n\t//南\n\tif(map[y+1][x] >= 0 && point[k][y][x]+map[y+1][x] >= point[k][y+1][x]){\n\t\tpoint[k][y+1][x] = point[k][y][x]+map[y+1][x];\n\t\tt = map[y+1][x];\n\t\tmap[y+1][x] = 0;\n\t\tnap(y+1,x,k);\n\t\tmap[y+1][x] = t;\n\t}\n\t//東\n\tif(map[y][x+1] >= 0 && point[k][y][x]+map[y][x+1] >= point[k][y][x+1]){\n\t\tpoint[k][y][x+1] = point[k][y][x]+map[y][x+1];\n\t\tt = map[y][x+1];\n\t\tmap[y][x+1] = 0;\n\t\tnap(y,x+1,k);\n\t\tmap[y][x+1] = t;\n\t}\n}\nint main(){\n\tint i,j;\n\tchar c[53];\n\tcin >> H >> W >> K;\n\tfor(i = 0;i <= H+1;i++){\n\t\tif(i == 0 || i == H+1){\n\t\t\tfor(j = 0;j <= W+1;j++){\n\t\t\t\tmap[i][j] = -1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tcin >> c+1;\n\t\tfor(j = 0;j <= W+1;j++){\n\t\t\tif(j == 0 || j == W+1){\n\t\t\t\tmap[i][j] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(c[j] == '.')\n\t\t\t\tmap[i][j] = 0;\n\t\t\telse if(c[j] >= '1' && c[j] <= '9')\n\t\t\t\tmap[i][j] = (int)c[j]-48;\n\t\t\telse\n\t\t\t\tmap[i][j] = -1; \n\t\t}\n\t}\n\tfor(i = 0;i < H+2;i++){\n\t\tfor(j = 0;j < W+2;j++){\n\t\t\tif(map[i][j] >= 0)\n\t\t\t\tcout << map[i][j] << \"  \";\n\t\t\telse\n\t\t\t\tcout << map[i][j] <<\" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tpoint[0][1][1] = map[1][1];\n\t//探索(帰えれない場合はない)\n\t//お土産店の残り具合で場合わけしないといけないことに注意！！\n\tnap(1,1,0);\n\tint max = 0;\n\tfor(i = 0;i <= K;i++){\n\t\tif(max < point[i][H][W])\n\t\t\tmax = point[i][H][W];\n\t\tcout << max << endl;\n\t}\n\tcout << max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<28)\n\nint H, W, K;\nstring F[50];\nint R[50][50];\n\nint dx[] = {0, 1, 0, -1},\n    dy[] = {1, 0, -1, 0};\n\nstruct P {\n    int y, x, t;\n    P(int y, int x, int t) : y(y), x(x), t(t) {}\n};\nvoid init() {\n    memset(R, -1, sizeof(R));\n    queue<P> Q;\n    Q.push(P(W-1, H-1, 0));\n    while (!Q.empty()) {\n        P p = Q.front(); Q.pop();\n        R[p.y][p.x] = p.t;\n        for (int i = 0; i < 4; i++) {\n            int nx = p.x + dx[i],\n                ny = p.y + dy[i];\n            if (nx < 0 || W <= nx || ny < 0 || H <= ny) continue;\n            if (F[ny][nx] == '#') continue;\n            if (R[ny][nx] >= 0) continue;\n            if (dx[i] > 0 || dy[i] > 0) {\n                Q.push(P(ny, nx, p.t + 1));\n            } else {\n                Q.push(P(ny, nx, p.t));\n            }\n        }\n    }\n    //for (int i = 0; i < H; i++) {\n    //    for (int j = 0; j < W; j++) {\n    //        printf(\"%3d\", R[i][j]);\n    //    }\n    //    printf(\"\\n\");\n    //}\n}\n\nint dfs(int y, int x, int k) {\n    //cout << y << ',' << x << ',' << k << endl;\n    if (R[y][x] > k) {\n        //cout << \"\\t\" << y << ',' << x << ',' << k << endl;\n        return -INF;\n    }\n    char f = '.';\n    if (F[y][x] != '.') {\n        f = F[y][x];\n        F[y][x] = '.';\n    }\n    int ret = 0;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i],\n            ny = y + dy[i];\n        if (nx < 0 || W <= nx || ny < 0 || H <= ny) continue;\n        if (F[ny][nx] == '#') continue;\n        if (dx[i] < 0 || dy[i] < 0) {\n            if (k <= 0) continue;\n            ret = max(ret, dfs(ny, nx, k-1));\n        } else {\n            ret = max(ret, dfs(ny, nx, k));\n        }\n    }\n    F[y][x] = f;\n    int v = f == '.' ? 0 : f - '0';\n    return ret + v;\n}\n\nint main() {\n    cin >> H >> W >> K;\n    for (int i = 0; i < H; i++) cin >> F[i];\n    init();\n    cout << dfs(0, 0, K) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\nbool check[1 << 12];\nint H, W, K, dp[4][50][50][1 << 12];\nchar Gifts[50][50];\n\nint main(){\n\n  cin >> H >> W >> K;\n  const int mask = (1 << (K * 4)) - 1;\n  for(int i = 0; i <= mask; ++i){\n    bool flag = false;\n    int y = 0, x = 0, bit = i;\n    for(int j = 0; j < 2 * K; ++j){\n      y -= dy[bit & 3], x -= dx[bit & 3];\n      if(y == 0 && x == 0){\n        flag = true;\n        break;\n      }\n      bit >>= 2;\n    }\n    check[i] = !flag;\n  }\n\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      cin >> Gifts[i][j];\n    }\n  }\n  fill_n( ***dp, 4 * 50 * 50 * (1 << 12), -1);\n  // dp[i][j][S]: ( j, i)にいるときの前に訪れる方法Sにおいての最大値\n  dp[K][0][0][0] = 0;\n  for(int i = K; i >= 0; --i){\n    for(int j = 0; j < H; ++j){\n      for(int k = 0; k < W; ++k){\n        for(int l = 0; l <= mask; ++l){\n          if(dp[i][j][k][l] == -1) continue;\n          int cost;\n          if(isdigit(Gifts[j][k]) && check[l]){\n            cost = Gifts[j][k] - '0';\n          }\n\n          else cost = 0;\n          for(int m = 0; m < 4; ++m){\n            int ny = j + dy[m], nx = k + dx[m];\n            if((m > 1 && i == 0) || ny < 0 || ny >= H || nx < 0 || nx >= W || Gifts[ny][nx] == '#') continue;\n            int& res = dp[i - (m > 1)][ny][nx][(l << 2 | m) & mask];\n            res = max( res, dp[i][j][k][l] + cost);\n          }\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i <= mask; ++i){\n    ret = max( ret, dp[0][H - 1][W - 1][i]);\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<28)\n\nint H, W, K;\nstring F[50];\nbool R[50][50];\n\nint dx[] = {0, 1, 0, -1},\n    dy[] = {1, 0, -1, 0};\n\nvoid init() {\n    memset(R, 0, sizeof(R));\n    typedef pair<int, int> P;\n    queue<P> Q;\n    Q.push(P(W-1, H-1));\n    while (!Q.empty()) {\n        P p = Q.front(); Q.pop();\n        R[p.second][p.first] = true;\n        for (int i = 0; i < 4; i++) {\n            if (dx[i] > 0 || dy[i] > 0) continue;\n            int nx = p.first + dx[i],\n                ny = p.second + dy[i];\n            if (nx < 0 || W <= nx || ny < 0 || H <= ny) continue;\n            if (F[ny][nx] == '#') continue;\n            Q.push(P(nx, ny));\n        }\n    }\n    //for (int i = 0; i < H; i++) {\n    //    for (int j = 0; j < W; j++) {\n    //        printf(\"%3d\", R[i][j]);\n    //    }\n    //    printf(\"\\n\");\n    //}\n}\n\nint dfs(int y, int x, int k) {\n    //cout << y << ',' << x << ',' << k << endl;\n    char f = '.';\n    if (F[y][x] != '.') {\n        f = F[y][x];\n        F[y][x] = '.';\n    }\n    if (k == 0 && (!R[y][x])) {\n        F[y][x] = f;\n        return -INF;\n    }\n    int ret = 0;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i],\n            ny = y + dy[i];\n        if (nx < 0 || W <= nx || ny < 0 || H <= ny) continue;\n        if (F[ny][nx] == '#') continue;\n        if (dx[i] < 0 || dy[i] < 0) {\n            if (k <= 0) continue;\n            ret = max(ret, dfs(ny, nx, k-1));\n        } else {\n            ret = max(ret, dfs(ny, nx, k));\n        }\n    }\n    F[y][x] = f;\n    return ret + (f == '.' ? 0 : f - '0');\n}\n\nint main() {\n    cin >> H >> W >> K;\n    for (int i = 0; i < H; i++) cin >> F[i];\n    init();\n    cout << dfs(0, 0, K) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nchar a[50][50];\nint dp[50][50][4][1<<11];\nint bitMap[4][1<<11][4];\nbool canGet[4][1<<11][4];\nvector<pii> needCells[4];\n\nconst int dy[4] = {0,1,0,-1};\nconst int dx[4] = {1,0,-1,0};\n\nint h,w,K;\n\nint solve(int y, int x, int k, int S){\n  int &r = dp[y][x][k][S];\n  if (r >= 0) return r;\n  int res = -INF;\n  if (y==h-1&&x==w-1) res = 0;\n  REP(d,4) {\n    int nk = k+(d>=2);\n    if (nk>K) continue;\n    int ny = y+dy[d];\n    int nx = x+dx[d];\n    if (!valid(ny,nx,h,w)) continue;\n    if (a[ny][nx] == '#') continue;\n    int score = canGet[k][S][d]&&isdigit(a[ny][nx]) ? a[ny][nx]-'0' : 0;\n    chmax(res, solve(ny,nx,nk,bitMap[k][S][d]) + score);\n  }\n  // cout << y << \" \" << x << \" \" << k << \" \";\n  // REP(i,needCells[k].size()) {\n  //   if (S>>i&1) {\n  //     pii p = needCells[k][i];\n  //     cout << \"(\" << p.first << \",\" << p.second << \")\";\n  //   }\n  // }\n  // cout << \" \" << res << endl;\n  return r = res;\n}\n\nint main() {\n  REP(k,4) {\n    for (int y=-3; y<=3; ++y) {\n      for (int x=-3; x<=3; ++x) {\n        if ((y||x) && -min(y,0)-min(x,0) <= 3-k && max(0,y)+max(0,x) <= k)\n          needCells[k].push_back(pii(y,x));\n      }\n    }\n  }\n  REP(k,4) {\n    int n = needCells[k].size();\n    REP(S,1<<n) {\n      REP(d,4) {\n        int nk = k+(d>=2);\n        if (nk == 4) continue;\n        int T = 0;\n        REP(i,n) {\n          if (S>>i&1) {\n            pii p = needCells[k][i];\n            p.first -= dy[d];\n            p.second -= dx[d];\n            REP(j,needCells[nk].size()) {\n              if (needCells[nk][j] == p) {\n                T |= 1 << j;\n              }\n            }\n          }\n        }\n        REP(j,needCells[nk].size()) {\n          if (needCells[nk][j] == pii(-dy[d],-dx[d])) {\n            T |= 1 << j;\n          }\n        }\n        bitMap[k][S][d] = T;\n\n        canGet[k][S][d] = 1;\n        REP(i,n)\n          if (S>>i&1 && needCells[k][i]==pii(dy[d],dx[d]))\n            canGet[k][S][d] = 0;\n      }\n    }\n  }\n  while(cin>>h>>w>>K) {\n    REP(i,h) REP(j,w) cin >> a[i][j];\n    memset(dp,-1,sizeof(dp));\n    cout << solve(0,0,0,0) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#define INF -(1 << 23)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint main()\n{\n\tint H, W, K;\n\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &K);\n\n\tvector<string> M(H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tcin >> M[i];\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (M[i][j] == '.')\n\t\t\t{\n\t\t\t\tM[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<vector<vector<int> > > > dp(H, vector<vector<vector<int> > >(W, vector<vector<int> >(K + 1, vector<int>(64, INF))));\n\n\tdp[0][0][0][0] = 0;\n\n\tfor (int rep = 0; rep <= K; rep++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= K; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < 64; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint dir = l % 4;\n\n\t\t\t\t\t\t\tif ((0 <= j + dx[dir] && j + dx[dir] < W && 0 <= i + dy[dir] && i + dy[dir] < H) && !((dir % 3) && k == 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint r = m * 16 + l / 4;\n\n\t\t\t\t\t\t\t\t\tif (dir % 3)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k - 1][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = -1;\n\n\tfor (int i = 0; i <= K; i++)\n\t{\n\t\tfor (int j = 0; j < 64; j++)\n\t\t{\n\t\t\tret = max(ret, dp[H - 1][W - 1][i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,K;\nint fld[50][50];\nint memo[50][50][4][1<<12];\nconst int dy[]={0,1,-1,0};\nconst int dx[]={1,0,0,-1};\ninline bool out(int y,int x){\n    return y<0||y>=H||x<0||x>=W;\n}\n\nint dfs(int y,int x,int cnt,int S){\n    if(memo[y][x][cnt][S]!=-1)return memo[y][x][cnt][S];\n\n    if(y==H-1&&x==W-1&&cnt==K){\n        return 0;\n    }\n    int ret=INT_MIN;\n    int ty=y,tx=x;\n    bool flag=true;\n    for(int i=0;i<6;i++){\n        int cur=(S>>(i*2))%4;\n        ty-=dy[cur];\n        tx-=dx[cur];\n        if(out(ty,tx))break;\n        if(ty==y&&tx==x)flag=false;\n    }\n    for(int i=0;i<4;i++){\n        if(i>=2&&cnt==K)continue;\n        ty=y+dy[i];\n        tx=x+dx[i];\n        if(out(ty,tx))continue;\n        if(fld[ty][tx]==-1)continue;\n        int tS=(S<<2)%(1<<(K*4));\n        ret=max(ret,dfs(ty,tx,cnt+(i>=2?1:0),tS|i));\n    }\n\n    if(flag)ret+=fld[y][x];\n    return memo[y][x][cnt][S]=ret;\n}\nint main(){\n    scanf(\"%d%d%d\",&H,&W,&K);\n    for(int i=0;i<H;i++){\n        char str[51];\n        scanf(\"%s\",str);\n        for(int j=0;j<W;j++){\n            int val;\n            if(str[j]=='#')val=-1;\n            else if(str[j]=='.')val=0;\n            else val=str[j]-'0';\n            fld[i][j]=val;\n        }\n    }\n    fill_n(***memo,50*50*4*(1<<12),-1);\n    printf(\"%d\\n\",dfs(0,0,0,0));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 0x7fffffff\n\ntypedef pair<int, int> Coor;\n\nint h, w, k;\nchar field[50][50];\nmap<vector<Coor>, int> dp[50][50][4]; // dp[y][x][left][where]\n\nint dfs(int x, int y, int k, const vector<Coor> &v) {\n    vector <Coor> v2;\n    int dx[] = {0, 1};\n    int dy[] = {1, 0};\n    int kdx[] = {0, -1};\n    int kdy[] = {-1, 0};\n    int ans = -INF;\n    if (x == w-1 && y == h-1) ans = 0; \n\n    for (int i=0; i<v.size(); i++) {\n        Coor c = v[i];\n        if (abs(c.first-x) + abs(c.second-y) <= 3) {\n            v2.push_back(c);\n        }\n    }\n    sort(v2.begin(), v2.end());\n\n    if (dp[x][y][k].find(v2) != dp[x][y][k].end()) {\n        return dp[x][y][k][v2];\n    }\n\n    for (int t=0; t<2; t++) {\n        int newx = x + dx[t];\n        int newy = y + dy[t];\n        int add = 0;\n        bool pushed = false;\n\n        if (newx < 0 || w <= newx || newy < 0 || h <= newy) continue;\n        if (field[newy][newx] == '#') continue;\n        if ('1' <= field[newy][newx] && field[newy][newx] <= '9') {\n            if (binary_search(v2.begin(), v2.end(), Coor(newx, newy)) == false) {\n                add = field[newy][newx] - '0';\n                v2.push_back(Coor(newx, newy));\n                pushed = true;\n            }\n        }\n\n        ans = max(ans, dfs(newx, newy, k, v2) + add);\n        if (pushed) v2.pop_back();\n    }\n\n    for (int t=0; t<2; t++) {\n        int newx = x + kdx[t];\n        int newy = y + kdy[t];\n        int add = 0;\n        bool pushed = false;\n\n        if (newx < 0 || w <= newx || newy < 0 || h <= newy || k == 0) continue;\n        if (field[newy][newx] == '#') continue;\n        if ('1' <= field[newy][newx] && field[newy][newx] <= '9') {\n            if (binary_search(v2.begin(), v2.end(), Coor(newx, newy)) == false) {\n                add = field[newy][newx] - '0';\n                v2.push_back(Coor(newx, newy));\n                pushed = true;\n            }\n        }\n\n        ans = max(ans, dfs(newx, newy, k-1, v2) + add);\n        if (pushed) v2.pop_back();\n    }\n\n    dp[x][y][k][v] = ans;\n    return ans;\n}\n\nint main() {\n    vector<Coor> v;\n\n    scanf(\"%d %d %d\", &h, &w, &k);\n    for (int i=0; i<h; i++) {\n        for (int j=0; j<w; j++) {\n            scanf(\" %c\", &field[i][j]);\n        }\n    }\n\n    \n    printf(\"%d\\n\", dfs(0, 0, k, v));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline void ChMax(int& a, int b){ a = max(a, b); }\n\nconst int dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nconst int bitMask = (1 << 12) - 1;\nint H, W, K;\nchar S[50][50];\nint dp[4][50][50][1 << 12];\nbool Visited[1 << 12];\n\n\n\nint main()\n{\n  memset(dp, -1, sizeof(dp));\n  for (int i = 0; i < (1 << 12); i++) {\n    int nx = 0, ny = 0, bit = i;\n    for(int j = 0; j < 6; j++, bit >>= 2) {\n      nx -= dx[bit & 3], ny -= dy[bit & 3];\n      if (nx == 0 && ny == 0) Visited[i] = true;\n    }\n  }\n\n  cin >> H >> W >> K;\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cin >> S[i][j];\n    }\n  }\n\n  dp[K][0][0][bitMask] = 0;\n\n  for(int m = K; m >= 0; m--) {\n    int notnext = m == 0;\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        for (int k = 0; k < (1 << 12); k++) {\n          if (dp[m][i][j][k] == -1) continue;\n          int Get = 0;\n          if (isdigit(S[i][j]) && !Visited[k]) Get += S[i][j] - '0';\n          for (int l = notnext << 1; l < 4; l++) {\n            int ny = i + dy[l], nx = j + dx[l];\n            if (ny < 0 || nx < 0 || ny >= H || nx >= W) continue;\n            if (S[ny][nx] == '#')                       continue;\n            ChMax(dp[m - (l < 2)][ny][nx][((k << 2) | l) & bitMask], dp[m][i][j][k] + Get);\n          }\n        }\n      }\n    }\n  }\n  cout << *max_element(dp[0][H - 1][W - 1], dp[0][H - 1][W]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef vector<p> vp;\ntypedef tuple<int,int,int,vp> state;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define mp\tmake_pair\n#define mt\tmake_tuple\n\nmap<state,int> dp;\nvector<string> s;\nint h,w;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nvoid makeWall(){\n\tstring a=\"\";\n\trep(i,s[0].size())\ta+=\"#\";\n\ts.insert(s.begin(),a);\n\ts.push_back(a);\n\trep(i,s.size())\ts[i]=\"#\"+s[i]+\"#\";\n}\n\nint solve(int x,int y,int k,vp used){\n\tif(x==w&&y==h&&k==0)\treturn 0;\n\tstate cur=mt(x,y,k,used);\n\tif(dp.find(cur)!=dp.end())\treturn dp[cur];\n\tint ret=INT_MIN;\n\trep(d,4){\n\t\tint nx=x+dx[d];\n\t\tint ny=y+dy[d];\n\t\tint nk=k-(d>1);\n\t\tif(nk<0||s[ny][nx]=='#')\tcontinue;\n\t\tvp nused;\n\t\trep(i,used.size()){\n\t\t\tif((nx+ny)-(used[i].first+used[i].second)<=nk){\n\t\t\t\tnused.push_back(used[i]);\n\t\t\t}\n\t\t}\n\t\tint val=0;\n\t\tif(s[ny][nx]!='.'){\n\t\t\tauto it=lower_bound(nused.begin(),nused.end(),mp(nx,ny));\n\t\t\tif(it==nused.end()||*it!=mp(nx,ny)){\n\t\t\t\tval=s[ny][nx]-'0';\n\t\t\t\tnused.insert(it,mp(nx,ny));\n\t\t\t}\n\t\t}\n\t\tret=max(ret,val+solve(nx,ny,nk,nused));\n\t}\n\treturn dp[cur]=ret;\n}\n\nint main(){\n\tint k;\tcin>>h>>w>>k;\n\ts.resize(h);\n\trep(i,h)\tcin>>s[i];\n\tmakeWall();\n\tcout<<solve(1,1,k,vp())<<endl;\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "// JOI 2012-2013 予選6\n#include<algorithm>\n#include<map>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<cstring>\n\ntypedef std::pair<int, int> P;\n\nconst int INF = 1 << 30;\n\nint H, W, K;\nchar field[50][51];\n\nstd::map<std::vector<P>, int> memo[51][51][4];\nint rec( int x, int y, int k, std::vector<P> visited )\n{\n\tif( k < 0 )\n\t\treturn -INF;\n\n\tstd::vector<P> p;\n\tfor( int i = 0; i != visited.size(); ++i )\n\t\t\tif( std::max( x - visited[i].first, 0 ) + std::max( y - visited[i].second, 0 ) <= k )\n\t\t\t\tp.push_back( visited[i] );\n\n\tstd::sort( p.begin(), p.end() );\n\tvisited = p;\n\n\tif( memo[x][y][k].count( visited ) )\n\t\treturn memo[x][y][k][visited];\n\n\tint ret = -INF;\n\n\tif( x == H - 1 && y == W - 1 )\n\t\tret = 0;\n\n\tstatic const int dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\n\n\tfor( int d = 0; d != 4; ++d )\n\t{\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tint nk = d >= 2 ? k - 1 : k;\n\n\t\tif( nx < 0 || nx >= H || ny < 0 || ny >= W || field[nx][ny] == '#' )\n\t\t\tcontinue;\n\n\t\tint val = 0;\n\t\tstd::vector<P> nv = visited;\n\t\tif( !std::binary_search( visited.begin(), visited.end(), P( nx, ny ) ) )\n\t\t{\n\t\t\tval = field[ny][nx] - '0';\n\t\t\tnv.push_back( P( nx, ny ) );\n\t\t}\n\n\t\tret = std::max( ret, rec( nx, ny, nk, nv ) + val );\n\t}\n\n\treturn memo[x][y][k][visited] = ret;\n}\n\nint main()\n{\n\tstd::cin >> H >> W >> K;\n\tfor( int i = 0; i != H; ++i )\n\t{\n\t\tfor( int j = 0; j != W; ++j )\n\t\t{\n\t\t\tstd::cin >> field[i];\n\n\t\t\tif( field[i][j] == '.' ) field[i][j] = '0';\n\t\t}\n\t}\n\n\tstd::cout << rec( 0, 0, K, std::vector<P>() ) << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nint H, W, K;\nint dp[50][50][4][1<<12]; // 00: s, 01: n, 10: e, 11: w\nchar map[51][51];\n\nbool twice(int prev_d){\n    int x = 0, y = 0;\n    for(int i=0;i<6;i++,prev_d>>=2){\n        int d = prev_d & 0x3;\n        x += dx[d];\n        y += dy[d];\n        if(x == 0 && y == 0){return true;}\n    }\n    return false;\n}\n\nint rec(int x, int y, int k, int prev_d){\n    if(x == W-1 && y == H-1){return 0;}\n    if(map[y+1][x] == '#' && map[y][x+1] == '#' && k == 0){return -INF;}\n    if(dp[y][x][k][prev_d] != -1){return dp[y][x][k][prev_d];}\n\n    int res = -INF, gifts = 0;\n\n    if(isdigit(map[y][x]) && !twice(prev_d)){\n        gifts = map[y][x] - '0';\n    }\n\n    REP(i, 4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < W && 0 <= ny && ny < H && k-i%2 >= 0 && map[ny][nx] != '#'){\n            res = std::max(res, gifts + rec(nx, ny, k - i % 2, (prev_d << 2 | i) & 0xfff));\n        }\n    }\n\n    return dp[y][x][k][prev_d] = res;\n}\n\nint main(){\n    std::cin >> H >> W >> K;\n\n    REP(i, H){\n        REP(j, W){\n            std::cin >> map[i][j];\n        }\n    }\n\n    REP(i, H){\n        map[i][W] = '#';\n    }\n\n    REP(j, W){\n        map[H][j] = '#';\n    }\n\n    REP(i, H){\n        REP(j, W){\n            REP(k, K+1){\n                REP(l, 1<<12){\n                    dp[i][j][k][l] = -1;\n                }\n            }\n        }\n    }\n\n    std::cout << rec(0, 0, K, 0) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef tuple<int,int,int,vector<p>> state;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define mp make_pair\n#define mt make_tuple\n\nvector<string> s;\nint h,w;\nmap<state,int> dp;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nvoid makeWall(){\n\tstring a=\"\";\n\trep(i,s[0].size())\ta+=\"#\";\n\ts.insert(s.begin(),a);\n\ts.push_back(a);\n\trep(i,s.size())\ts[i]=\"#\"+s[i]+\"#\";\n}\n\nint solve(int x,int y,int k,vector<p> used){\n\tif(x==w&&y==h&&k==0)\treturn 0;\n\tstate cur=mt(x,y,k,used);\n\tif(dp.find(cur)!=dp.end())\treturn dp[cur];\n\tint ret=0;\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tint nk=(dx[i]+dy[i]<0?k-1:k);\n\t\tif(s[ny][nx]=='#'||nk<0)\tcontinue;\n\t\tvector<p> nused;\n\t\trep(j,used.size()){\n\t\t\tif((nx-used[j].first)+(ny-used[j].second)<=nk){\n\t\t\t\tnused.push_back(used[j]);\n\t\t\t}\n\t\t}\n\t\tint cost=0;\n\t\tif(s[ny][nx]!='.'){\n\t\t\tauto it=lower_bound(nused.begin(),nused.end(),mp(nx,ny));\n\t\t\tif(it==nused.end()||*it!=mp(nx,ny)){\n\t\t\t\tcost+=s[ny][nx]-'0';\n\t\t\t\tnused.insert(it,mp(nx,ny));\n\t\t\t}\n\t\t}\n\t\tret=max(ret,cost+solve(nx,ny,nk,nused));\n\t}\n\treturn dp[cur]=ret;\n}\n\nint main(){\n\tint k;\tcin>>h>>w>>k;\n\ts=vector<string>(h);\n\trep(i,h)\tcin>>s[i];\n\tmakeWall();\n\tcout<<solve(1,1,k,vector<p>())<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[4][50][50][1 << 12];\nint H, W, K;\nchar mas[50][50];\nint dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint mask;\n\nint getdir(int bit, int i){\n  return bit >> (i << 1) & 3;\n}\n#define INF (1 << 30)\nint rec(int x, int y, int mul, int bit){\n  if(y == H - 1 && x == W - 1 && mul == 0) return 0;\n  if(~dp[mul][y][x][bit]) return dp[mul][y][x][bit];\n\n  int ret = -INF, value = 0, mx = x, my = y;\n  bool hoge = false;\n  if(mas[y][x] != '.'){\n    for(int i = 0; i < 2 * K; i++){\n      my -= dy[getdir( bit, i)];\n      mx -= dx[getdir( bit, i)];\n      if(mx == x && my == y){\n        hoge = true;\n        break;\n      }\n    }\n    if(!hoge) value = mas[y][x] - '0';\n  }\n\n  for(int i = 0; i < 4; i++){\n    if(mul == 0 && i > 1) break;\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= H || nx < 0 || nx >= W || mas[ny][nx] == '#') continue;\n    ret = max( ret, rec( nx, ny, mul - (i > 1), (bit << 2 | i) & mask) + value);\n  }\n  return dp[mul][y][x][bit] = ret;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  mask = (1 << (K * 2 * 2)) - 1;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      cin >> mas[i][j];\n    }\n  }\n  fill_n( ***dp, 4 * 50 * 50 * (1 << 12), -1);\n  cout << rec( 0, 0, K, 0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<bitset>\n#include<vector>\nusing namespace std;\nint H, W, K;\nchar town[51][51];\nint ans = 0;\nint dp[52][52][4][5][5][1 << 10] = {};\nint ac[5][5] = { { 10, 10, 10, 10, 10 },\n{ 10, 3, 6, 8, 9 },\n{ 10, 2, 5, 7, 10 },\n{ 10, 1, 4, 10, 10 },\n{ 10, 0, 10, 10, 10 }\n};\n\nint solve() {\n\tdp[1][1][0][1][1][1 << 3] = 1;\n\tfor (int k = 0; k <= K; k++) {\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tfor (int x = 1; x <= 4; x++) {\n\t\t\t\t\tfor (int y = 1; y <= 4; y++) {\n\t\t\t\t\t\tfor (int st = 0; st < (1 << 10); st++) {\n\t\t\t\t\t\t\tif (dp[i][j][k][x][y][st] <= 0) continue;\n\t\t\t\t\t\t\tbitset<11> bit(st);\n\t\t\t\t\t\t\tint b[11] = {};\n\t\t\t\t\t\t\tfor (int q = 0; q < 10; q++) {\n\t\t\t\t\t\t\t\tif (bit[q]) b[q] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint to = 0;\n\t\t\t\t\t\t\tint res = dp[i][j][k][x][y][st];\n\t\t\t\t\t\t\t//east\n\t\t\t\t\t\t\tif (town[i][j + 1] != '#') {\n\t\t\t\t\t\t\t\tto |= b[1];\n\t\t\t\t\t\t\t\tto |= b[2] << 1;\n\t\t\t\t\t\t\t\tto |= b[3] << 2;\n\t\t\t\t\t\t\t\tto |= b[5] << 4;\n\t\t\t\t\t\t\t\tto |= b[6] << 5;\n\t\t\t\t\t\t\t\tto |= b[8] << 7;\n\t\t\t\t\t\t\t\tif (b[ac[x - 1][y]] == 0 && '1' <= town[i][j + 1] && town[i][j + 1] <= '9') res += town[i][j + 1] - '0';\n\t\t\t\t\t\t\t\tto |= 1 << ac[x][y];\n\n\t\t\t\t\t\t\t\tdp[i][j + 1][k][x][y][to] = max(dp[i][j + 1][k][x][y][to], res);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//south\n\t\t\t\t\t\t\tto = 0;\n\t\t\t\t\t\t\tres = dp[i][j][k][x][y][st];\n\t\t\t\t\t\t\tif (town[i + 1][j] != '#') {\n\t\t\t\t\t\t\t\tto |= b[1] << 4;\n\t\t\t\t\t\t\t\tto |= b[2] << 5;\n\t\t\t\t\t\t\t\tto |= b[3] << 6;\n\t\t\t\t\t\t\t\tto |= b[5] << 7;\n\t\t\t\t\t\t\t\tto |= b[6] << 8;\n\t\t\t\t\t\t\t\tto |= b[8] << 9;\n\t\t\t\t\t\t\t\tif (b[ac[x][y - 1]] == 0 && '1' <= town[i + 1][j] && town[i + 1][j] <= '9') res += town[i + 1][j] - '0';\n\t\t\t\t\t\t\t\tto |= 1 << ac[x][y];\n\n\t\t\t\t\t\t\t\tdp[i + 1][j][k][x][y][to] = max(dp[i + 1][j][k][x][y][to], res);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k < K) {\n\t\t\t\t\t\t\t\t//west\n\t\t\t\t\t\t\t\tres = dp[i][j][k][x][y][st];\n\t\t\t\t\t\t\t\tif (town[i][j - 1] != '#') {\n\t\t\t\t\t\t\t\t\tif (b[ac[x + 1][y]] == 0 && '1' <= town[i][j - 1] && town[i][j - 1] <= '9') res += town[i][j - 1] - '0';\n\t\t\t\t\t\t\t\t\tto = st | (1 << ac[x + 1][y]);\n\t\t\t\t\t\t\t\t\tdp[i][j - 1][k + 1][x + 1][y][to] = max(dp[i][j - 1][k + 1][x + 1][y][to], res);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//north\n\t\t\t\t\t\t\t\tres = dp[i][j][k][x][y][st];\n\t\t\t\t\t\t\t\tif (town[i - 1][j] != '#') {\n\t\t\t\t\t\t\t\t\tif (b[ac[x][y + 1]] == 0 && '1' <= town[i - 1][j] && town[i - 1][j] <= '9') res += town[i - 1][j] - '0';\n\t\t\t\t\t\t\t\t\tto = st | (1 << ac[x][y + 1]);\n\t\t\t\t\t\t\t\t\tdp[i - 1][j][k + 1][x][y + 1][to] = max(dp[i - 1][j][k + 1][x][y + 1][to], res);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int k = 0; k <= K; k++) {\n\t\tfor (int x = 1; x <= 4; x++) {\n\t\t\tfor (int y = 1; y <= 4; y++) {\n\t\t\t\tfor (int st = 0; st < (1 << 10); st++) {\n\t\t\t\t\tans = max(ans, dp[H][W][k][x][y][st]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans - 1;\n}\n\nvoid input() {\n\tcin >> H >> W >> K;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> town[i][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tinput();\n\tcout << solve() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve();\n\nint H,W,K;\nint fid[60][60] = {0};\nint dp[60][60][5][4][4][4][4][4];\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\nint mem[] = {1,10,-1,-10};\n\nint main()\n{\n    scanf(\"%d%d%d\",&H,&W,&K);\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            char C;\n            scanf(\" %c\",&C);\n            if('1' <= C <= '9')\n            {\n                fid[i][j] = C - '0';\n            }\n            if(C == '#')\n            {\n                fid[i][j] = -1;\n            }\n            if(C == '.')\n            {\n                fid[i][j] = 0;\n            }\n        }\n    }\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            for(int k = 0; k < K + 1; k++)\n            {\n                for(int a = 0; a < 4; a++)\n                {\n                    for(int b = 0; b < 4; b++)\n                    {\n                        for(int c = 0; c < 4; c++)\n                        {\n                            for(int d = 0; d < 4; d++)\n                            {\n                                for(int e = 0; e < 4; e++)\n                                {\n                                    dp[i][j][k][a][b][c][d][e] = -1;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    solve();\n    return 0;\n}\n\nvoid solve()\n{\n    dp[0][0][0][0][0][0][0][0] = fid[0][0];\n    for(int k = 0; k < K + 1; k++)\n    {\n        for(int i = 0; i < H; i++)\n        {\n            for(int j = 0; j < W; j++)\n            {\n                for(int a = 0; a < 4; a++)\n                {\n                    for(int b = 0; b < 4; b++)\n                    {\n                        for(int c = 0; c < 4; c++)\n                        {\n                            for(int d = 0; d < 4; d++)\n                            {\n                                for(int e = 0; e < 4; e++)\n                                {\n                                    if(dp[i][j][k][a][b][c][d][e] == -1)continue;\n                                    for(int f = 0; f < 4; f++)\n                                    {\n                                        int X = i + dx[f],Y = j + dy[f];\n                                        if(X < 0 || H <= X || Y < 0 || W <= Y || fid[X][Y] == -1)continue;\n                                        if(f < 2)\n                                        {\n                                            if(!(mem[f] + mem[e]) || !(mem[f] + mem[e] + mem[d] + mem[c]) || !(mem[f] + mem[e] + mem[d] + mem[c] + mem[b] + mem[a]))\n                                            {\n                                                dp[X][Y][k][b][c][d][e][f] = max(dp[X][Y][k][b][c][d][e][f],dp[i][j][k][a][b][c][d][e]);\n                                            }\n                                            else\n                                            {\n                                                dp[X][Y][k][b][c][d][e][f] = max(dp[X][Y][k][b][c][d][e][f],dp[i][j][k][a][b][c][d][e] + fid[X][Y]);\n                                            }\n                                        }\n                                        else\n                                        {\n                                            if(k == K)continue;\n                                            if(!(mem[f] + mem[e]) || !(mem[f] + mem[e] + mem[d] + mem[c]) || !(mem[f] + mem[e] + mem[d] + mem[c] + mem[b] + mem[a]))\n                                            {\n                                                dp[X][Y][k + 1][b][c][d][e][f] = max(dp[X][Y][k + 1][b][c][d][e][f],dp[i][j][k][a][b][c][d][e]);\n                                            }\n                                            else\n                                            {\n                                                dp[X][Y][k + 1][b][c][d][e][f] = max(dp[X][Y][k + 1][b][c][d][e][f],dp[i][j][k][a][b][c][d][e] + fid[X][Y]);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int a = 0; a < 4; a++)\n    {\n        for(int b = 0; b < 4; b++)\n        {\n            for(int c = 0; c < 4; c++)\n            {\n                for(int d = 0; d < 4; d++)\n                {\n                    for(int e = 0; e < 4; e++)\n                    {\n                        ans = max(ans,dp[H - 1][W - 1][K][a][b][c][d][e]);\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define chmax(a,b) (a = max(a,b))\nusing namespace std;\n\nconst int dy[] = {0,1,0,-1}, dx[] = {1,0,-1,0};\nint dp[50][50][4][1<<12];\nint vis[1<<12];\n\ninline int visit(int bit){\n  assert(bit<(1<<12));\n  if(vis[bit]>=0)return vis[bit];\n  int y=0, x=0;\n  rep(i,6){\n    int d = bit&3; bit>>=2;\n    y += dy[d], x += dx[d];\n    if(y==0 && x==0)return vis[bit] = 1;\n  }\n  return vis[bit] = 0;\n}\n\nint main(){\n  int h,w,k;\n  string g[50];\n  cin >> h >> w >> k;\n  rep(i,h)cin >> g[i];\n\n  memset(vis,-1,sizeof(vis));\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0][0] = isdigit(g[0][0])?(int)(g[0][0]-'0'):0;\n\n  rep(rev,k+1){\n    rep(y,h)rep(x,w){\n      if(g[y][x] == '#')continue;\n      rep(bit,1<<12){\n\tif(dp[y][x][rev][bit]<0)continue;\n\n\trep(d,4){\n\t  if(rev==k && d>1)break;\n\t  int ny = y+dy[d], nx = x+dx[d];\n\t  if(!range(ny,0,h) || !range(nx,0,w))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  int nbit = ((bit<<2)|d) & ((1<<12)-1);\n\t  int item = isdigit(g[ny][nx])?(int)(g[ny][nx]-'0'):0;\n\t  if(visit(nbit))item = 0;\n\n\t  if(d<2){\n\t    chmax(dp[ny][nx][rev][nbit], dp[y][x][rev][bit] + item);\n\t  }else{\n\t    chmax(dp[ny][nx][rev+1][nbit], dp[y][x][rev][bit] + item);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = 0;\n  rep(bit,1<<12)chmax(res, dp[h-1][w-1][k][bit]);\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#define INF -(1 << 23)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint main()\n{\n\tint H, W, K;\n\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &K);\n\n\tvector<string> M(H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tcin >> M[i];\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (M[i][j] == '.')\n\t\t\t{\n\t\t\t\tM[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<vector<vector<int> > > > dp(H, vector<vector<vector<int> > >(W, vector<vector<int> >(K + 1, vector<int>(64, INF))));\n\n\tdp[0][0][0][0] = 0;\n\n\tfor (int rep = 0; rep <= K; rep++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= K; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < 64; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint dir = l % 4;\n\n\t\t\t\t\t\t\tint p3 = l / 16;\n\t\t\t\t\t\t\tint p2 = (l / 4) % 4;\n\t\t\t\t\t\t\tint p1 = l % 4;\n\n\t\t\t\t\t\t\tint px1 = j + dx[p1];\n\t\t\t\t\t\t\tint px2 = px1 + dx[p2];\n\t\t\t\t\t\t\tint px3 = px2 + dx[p3];\n\t\t\t\t\t\t\tint py1 = i + dy[p1];\n\t\t\t\t\t\t\tint py2 = py1 + dy[p2];\n\t\t\t\t\t\t\tint py3 = py2 + dy[p3];\n\n\t\t\t\t\t\t\tif (!((j == px1 && i == py1) || (j == px2 && i == py2) || (j == px3 && i == py3)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ((0 <= j + dx[dir] && j + dx[dir] < W && 0 <= i + dy[dir] && i + dy[dir] < H) && !((dir % 3) && k == 0))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tint r = m * 16 + l / 4;\n\n\t\t\t\t\t\t\t\t\t\tif (dir % 3)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k - 1][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = -1;\n\n\tfor (int i = 0; i <= K; i++)\n\t{\n\t\tfor (int j = 0; j < 64; j++)\n\t\t{\n\t\t\tret = max(ret, dp[H - 1][W - 1][i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef vector<p> vp;\ntypedef tuple<int,int,int,vp> state;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define mp\tmake_pair\n#define mt\tmake_tuple\n\nmap<state,int> dp;\nvector<string> s;\nint h,w;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nvoid makeWall(){\n\tstring a=\"\";\n\trep(i,s[0].size())\ta+=\"#\";\n\ts.insert(s.begin(),a);\n\ts.push_back(a);\n\trep(i,s.size())\ts[i]=\"#\"+s[i]+\"#\";\n}\n\nint solve(int x,int y,int k,vp used){\n\tif(x==w&&y==h&&k==0)\treturn 0;\n\tstate cur=mt(x,y,k,used);\n\tif(dp.find(cur)!=dp.end())\treturn dp[cur];\n\tint ret=INT_MIN;\n\trep(d,4){\n\t\tint nx=x+dx[d];\n\t\tint ny=y+dy[d];\n\t\tint nk=k-(d>1);\n\t\tif(nk<0||s[ny][nx]=='#')\tcontinue;\n\t\tvp nused;\n\t\trep(i,used.size()){\n\t\t\tif((nx+ny)-(used[i].first+used[i].second)<=nk){\n\t\t\t\tnused.push_back(used[i]);\n\t\t\t}\n\t\t}\n\t\tint val=0;\n\t\tif(s[ny][nx]!='.'){\n\t\t\tval=s[ny][nx]-'0';\n\t\t\trep(i,nused.size()){\n\t\t\t\tif(nx==nused[i].first&&ny==nused[i].second){\n\t\t\t\t\tval=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(val>0){\n\t\t\t\tnused.push_back(mp(nx,ny));\n\t\t\t\tsort(nused.begin(),nused.end());\n\t\t\t\tnused.erase(unique(nused.begin(),nused.end()),nused.end());\n\t\t\t}\n\t\t}\n\t\tret=max(ret,val+solve(nx,ny,nk,nused));\n\t}\n\treturn dp[cur]=ret;\n}\n\nint main(){\n\tint k;\tcin>>h>>w>>k;\n\ts.resize(h);\n\trep(i,h)\tcin>>s[i];\n\tmakeWall();\n\tcout<<solve(1,1,k,vp());\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n   \nusing namespace std;\n   \n//#define int long long\n#define PB push_back\n#define MK make_pair\n#define MKT make_tuple\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n   \n//constexpr int INF = 1LL<<60;\nconstexpr int INF = 1 << 28;\n//constexpr int MOD = 100000;\nconstexpr int MAX_N = 51;\nconstexpr int dx[] = { 1, 0, -1, 0 };\nconstexpr int dy[] = { 0, 1, 0, -1 };\n   \nint mem[MAX_N][MAX_N][4][1 << 6][1 << 6], h, w, k, fld[MAX_N + 1][MAX_N + 1];\n   \ninline bool Chk(int x, int y, int mask1, int mask2) {\n    constexpr int len = 6;\n    int cx = x, cy = y;\n    for (int i = 0; i < len; ++i) {\n        int b1 = mask1 & (1 << (len - 1 - i)) ? 1 : 0, b2 = mask2 & (1 << (len - 1 - i)) ? 1 : 0;\n        int idx = b1 + 2 * b2;\n        cx -= dx[idx];\n        cy -= dy[idx];\n        if (x == cx && y == cy) {\n            return true;\n        }\n    }\n    return false;\n}\n   \nint Solve(int x, int y, int c, int mask1, int mask2) {\n    if (x == w && y == h) return 0;\n    if (mem[x][y][c][mask1][mask2] != -1) return mem[x][y][c][mask1][mask2];\n    \n    int cur = Chk(x, y, mask1, mask2) ? 0 : fld[x][y];\n    int res = 0;\n    for (int i = 0; i < 4; ++i) {\n        if (1 < i && k <= c) break;\n        int tx = x + dx[i], ty = y + dy[i];\n        int nc = (1 < i) ? c + 1 : c;\n        if (fld[tx][ty] == -1) continue;\n           \n        int nm1 = (mask1 >> 1) + ((i % 2) << 5), nm2 = (mask2 >> 1) + ((1 < i) << 5);\n        res = max(res, Solve(tx, ty, nc, nm1, nm2));\n    }\n       \n    return mem[x][y][c][mask1][mask2] = res + cur;\n}\n   \nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n   \n    memset(fld, -1, sizeof(fld));\n    cin >> h >> w >> k;\n    for (int y = 1; y <= h; ++y) {\n        string s;\n        cin >> s;\n        for (int x = 1; x <= w; ++x) {\n            char c = s[x - 1];\n            if (c == '#') {\n                fld[x][y] = -1;\n                continue;\n            } else if (c == '.') {\n                fld[x][y] = 0;\n                continue;\n            }\n            fld[x][y] = c - '0';\n        }\n    }\n    fld[w + 1][h] = 0;\n    memset(mem, -1, sizeof(mem));\n    cout << Solve(1, 1, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint dp[50][50][4][1<<12];\nchar f[50][50];\nint w,h,K;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nbool out(int x,int y)\n{\n\tif(x<0||x>=h||y<0||y>=w)return true;\n\treturn false;\n}\nbool revisit(int bit)\n{\n\tint tx=0,ty=0;\n\tfor(int i=0;i<6;i++,bit>>=2)\n\t{\n\t\tint id=bit%4;\n\t\ttx+=dx[id];ty+=dy[id];\n\t\tif(tx==0&&ty==0)return true;\n\t}\n\treturn false;\n}\nint rec(int x,int y,int k,int bit)\n{\n\tif(x==0&&y==0)return 0;\n\tif(dp[x][y][k][bit]>=0)return dp[x][y][k][bit];\n\tint num=0;\n\tif(f[x][y]!='.'&&f[x][y]!='#'&&!revisit(bit))num=f[x][y]-'0';\n\tint res=0;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(!out(nx,ny)&&f[x][y]!='#'&&k-(i>=2)>=0)\n\t\t{\n\t\t\tres=max(res,rec(nx,ny,k-(i>=2),((1<<12)-1)&((bit<<2)+i))+num);\n\t\t}\n\t}\n\treturn dp[x][y][k][bit]=res;\n}\nint main()\n{\n\tcin >> h >> w >> K;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tcin >> f[i][j];\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tcout << rec(h-1,w-1,K,0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint h,w,K;\nchar c[51][51];\nint memo[50][50][1<<12][4];\nint dx[] = {0,1,0,-1}; // ????????????\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nint dfs(int x,int y,int remain,int bit){\n\n  if( memo[y][x][bit][remain] != -1 ) return memo[y][x][bit][remain];\n  \n  if( x == w-1 && y == h-1 && remain == 0 ) return 0;\n  \n  int px = x,py = y;\n  bool already_visited = false;\n  rep(i,(2*K)){\n    px -= dx[(bit>>(i*2))&3];\n    py -= dy[(bit>>(i*2))&3];\n    if( !isValid(px,py) ) break;\n    if( px == x && py == y ) {\n      already_visited = true;\n      break;\n    }\n  }\n\n  int ret = 0;\n  if( !already_visited && '0' <= c[y][x] && c[y][x] <= '9' ) ret = c[y][x] - '0';\n  \n  int maxi = -2;\n  rep(i,4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !isValid(nx,ny)  ) continue;\n    if( c[ny][nx] == '#' ) continue;\n    if( i >= 2 && remain == 0 ) continue;\n    maxi = max(maxi,dfs(nx,ny,remain-(i>=2),((bit<<2)|i)&((1<<(4*K))-1)));\n  }\n\n  if( maxi == -2 ) return memo[y][x][bit][remain] = -2;\n  return memo[y][x][bit][remain] = ret + maxi;\n  \n}\n\nint main(){\n  scanf(\"%d %d %d\",&h,&w,&K);\n  rep(i,h) scanf(\" %s\",&c[i][0]);\n  memset(memo,-1,sizeof(memo));\n  int tmp = dfs(0,0,K,2);\n  if( tmp == -2 ) puts(\"0\");\n  else            printf(\"%d\\n\",dfs(0,0,K,0));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#define INF -(1 << 23)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint main()\n{\n\tint H, W, K;\n\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &K);\n\n\tvector<string> M(H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tcin >> M[i];\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (M[i][j] == '.')\n\t\t\t{\n\t\t\t\tM[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<vector<vector<int> > > > dp(H, vector<vector<vector<int> > >(W, vector<vector<int> >(K + 1, vector<int>(64, INF))));\n\n\tdp[0][0][0][0] = 0;\n\n\tfor (int rep = 0; rep <= K; rep++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= K; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < 64; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint dir = l % 4;\n\n\t\t\t\t\t\t\tint p3 = l / 16;\n\t\t\t\t\t\t\tint p2 = (l / 4) % 4;\n\t\t\t\t\t\t\tint p1 = l % 4;\n\n\t\t\t\t\t\t\tint px1 = j + dx[p1];\n\t\t\t\t\t\t\tint px2 = px1 + dx[p2];\n\t\t\t\t\t\t\tint px3 = px2 + dx[p3];\n\t\t\t\t\t\t\tint py1 = i + dy[p1];\n\t\t\t\t\t\t\tint py2 = py1 + dx[p2];\n\t\t\t\t\t\t\tint py3 = py2 + dx[p3];\n\n\t\t\t\t\t\t\tif ((j == px1 && i == py1) || (j == px2 && i == py2) || (j == px3 && i == py3))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((0 <= j + dx[dir] && j + dx[dir] < W && 0 <= i + dy[dir] && i + dy[dir] < H) && !((dir % 3) && k == 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint r = m * 16 + l / 4;\n\n\t\t\t\t\t\t\t\t\tif (dir % 3)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k - 1][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = -1;\n\n\tfor (int i = 0; i <= K; i++)\n\t{\n\t\tfor (int j = 0; j < 64; j++)\n\t\t{\n\t\t\tret = max(ret, dp[H - 1][W - 1][i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline void ChMax(int& a, int b){ a = max(a, b); }\n\nconst int dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nconst int bitMask = (1 << 12) - 1;\nint H, W, K;\nchar S[50][50];\nint dp[50][50][1 << 12];\nbool Visited[1 << 12];\n\n\n\nint main()\n{\n  memset(dp, -1, sizeof(dp));\n  for (int i = 0; i < (1 << 12); i++) {\n    int nx = 0, ny = 0, bit = i;\n    for(int j = 0; j < 6; j++, bit >>= 2) {\n      nx -= dx[bit & 3], ny -= dy[bit & 3];\n      if (nx == 0 && ny == 0) {\n        Visited[i] = true;\n        break;\n      }\n    }\n  }\n\n  cin >> H >> W >> K;\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cin >> S[i][j];\n    }\n  }\n\n  dp[0][0][bitMask] = 0;\n\n  for(int m = K; m >= 0; m--) {\n    int notnext = m == 0;\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        for (int k = 0; k < (1 << 12); k++) {\n          if (dp[i][j][k] == -1) continue;\n          int Get = 0;\n          if (isdigit(S[i][j]) && !Visited[k]) Get += S[i][j] - '0';\n          for (int l = notnext << 1; l < 4; l++) {\n            int ny = i + dy[l], nx = j + dx[l];\n            if (ny < 0 || nx < 0 || ny >= H || nx >= W) continue;\n            if (S[ny][nx] == '#')                       continue;\n            ChMax(dp[ny][nx][bitMask & (k << 2) | l], dp[i][j][k] + Get);\n          }\n        }\n      }\n    }\n  }\n  cout << *max_element(dp[H - 1][W - 1], dp[H - 1][W]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct T\n{\n  int x, y, k;\n  T(int _x, int _y, int _k, const vector<int>& _vis):\n    x(_x), y(_y), k(_k), vis(_vis) {}\n  vector<int> vis;\n  bool operator <(const T& rhs) const\n  {\n    return x < rhs.x && y < rhs.y && k < rhs.k && vis < rhs.vis;\n  }\n};\n\nint m[51][51];\nmap<T, int> dp;\nint H, W, K;\nint dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\n\n\nint dfs(T arg)\n{\n  if(dp.find(arg) != dp.end())\n    dp[arg];\n  int x = arg.x, y = arg.y, k = arg.k;\n  auto& vis = arg.vis;\n  \n  int cnt = max(0, m[y][x]);\n  int res = -100000000;\n  if(x == W - 1 && y == H - 1)\n    res = 0;\n  int xx = x, yy = y;\n  for(int j = vis.size() - 1; j >= 0; j--)\n  {\n    xx -= dx[vis[j]]; yy -= dy[vis[j]];\n    if(xx == x && yy == y)\n    {\n      cnt = 0;\n    }\n  }\n  for(int i = 0; i < 4; i++)\n  {\n    int tx = x + dx[i], ty = y + dy[i];\n    if(!(tx >= 0 && tx < W && ty >= 0 && ty < H))\n      continue;\n    if(m[ty][tx] == -1)\n      continue;\n    int dk = (dx[i] < 0 || dy[i] < 0) ? 1 : 0;\n    if(k + dk > K)\n      continue;\n\n    vector<int> nv;\n    for(int j = 0; j < vis.size(); j++)\n      nv.push_back(vis[j]);\n    nv.push_back(i);\n    res = max(res, dfs(T(tx, ty, k + dk, nv)) + cnt);\n  }\n  return dp[arg] = res;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  for(int y = 0; y < H; y++)\n  {\n    for(int x = 0; x < W; x++)\n    {\n      char a;\n      cin >> a;\n      switch(a)\n      {\n        case '.':\n          m[y][x] = 0;\n          break;\n        case '#':\n          m[y][x] = -1;\n          break;\n        default:\n          m[y][x] = a - '0';\n          break;\n      }\n    }\n  }\n  cout << dfs(T(0, 0, 0, vector<int>())) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\nbool used[51][51][1<<10][4][4];\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\nconst int base=50;\nint m[101][101]={};\n\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[i+oy+base][j+ox+base]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[ny+base][nx+base];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 全体のビット右にをシフト\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[cy+base][cx+base];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // 下方向にビットをシフト\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[cy+base][cx+base];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nconst int INF=(1<<30);\nint dfs(int cy,int cx,int mask,int my,int mx){\n  if(used[cy][cx][mask][my][mx])return dp[cy][cx][mask][my][mx];\n  int res=-INF;\n  int leftK=K-(my+mx);\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n      int nmask=p.first;\n      int nAddVal=p.second;\n      if(leftK>0&&(i==0||i==3))\n        res=max(res,dfs(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))+nAddVal);\n      else if((i==1||i==2))\n        res=max(res,dfs(ny,nx,nmask,my,mx)+nAddVal);\n    }\n  }\n  if(cy==H-1&&cx==W-1)res=max(res,0);\n  used[cy][cx][mask][my][mx]=true;\n  return dp[cy][cx][mask][my][mx]=res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,(1<<6),0,0)<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define INF -(1 << 23)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint main()\n{\n\tint H, W, K;\n\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &K);\n\n\tvector<string> M(H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tcin >> M[i];\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (M[i][j] == '.')\n\t\t\t{\n\t\t\t\tM[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<vector<vector<int> > > > dp(H, vector<vector<vector<int> > >(W, vector<vector<int> >(K + 1, vector<int>(64, INF))));\n\n\tdp[0][0][0][0] = 0;\n\n\tfor (int rep = 0; rep <= K; rep++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= K; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < 64; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint dir = l % 4;\n\n\t\t\t\t\t\t\tif ((0 <= j + dx[dir] && j + dx[dir] < W && 0 <= i + dy[dir] && i + dy[dir] < H) && (!(dir % 3) && K != 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint r = m * 16 - l / 4;\n\n\t\t\t\t\t\t\t\t\tif (dir % 3)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k][r]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k][l] = max(dp[i][j][k][l], dp[i + dy[dir]][j + dx[dir]][k - 1][r] + (M[i][j] - 48));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = -1;\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tfor (int j = 0; j < 64; j++)\n\t\t{\n\t\t\tret = max(ret, dp[H - 1][W - 1][i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nclass road{\npublic:\n    int dp[1<<10][4];\n    int num;\n    road(){\n        for(int i=0;i<(1<<10);++i){\n            for(int j=0;j<4;++j){\n                dp[i][j]=-1;\n            }\n        }\n    }\n};\nint N,M,K;\nroad **map;\nint mx[]{1,0,-1,0},my[]{0,1,0,-1};\nint search(int,int,int,int);\nusing namespace std;\nint main(){\n    cin>>N>>M>>K;\n    map=new road*[M+1];\n    for(int i=1;i<=M;++i){\n        map[i]=new road[N+1];\n    }\n    char dummy;\n    for(int i=1;i<=N;++i){\n        for(int j=1;j<=M;++j) {\n            cin>>dummy;\n            if(dummy=='#'){\n                map[j][i].num=-1;\n            }else if(dummy=='.'){\n                map[j][i].num=0;\n            }else{\n                map[j][i].num=dummy-'0';\n            }\n        }\n    }\n    cout<<search(1,1,0,K)<<endl;\n    return 0;\n}\nint search(int x,int y,int lo,int k){\n    if(y==0||x==0||y>N||x>M||(x==M&&y==N&&k==0)||map[x][y].num==-1)return 0;\n    if(map[x][y].dp[lo][k]>-1)return map[x][y].dp[lo][k];\n    int stock=0;\n    int res=0;\n    swap(stock,map[x][y].num);\n    for(int i=0;i<2;++i){\n        res=max(search(x+mx[i],y+my[i],(lo>>2)+(i<<8),k),res);\n    }\n    if(k>0){\n        for(int i=2;i<4;++i) {\n            res=max(res,search(x+mx[i],y+my[i],(lo>>2)+(i<<8),k-1));\n        }\n    }\n    map[x][y].dp[lo][k]=res+stock;\n    swap(stock,map[x][y].num);\n    return map[x][y].dp[lo][k];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint H,W,K;\nchar field[51][51];\nint dp[51][51][1<<10][4][4];\n\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\npii getNxtMaskAndVal(int cy,int cx,int mask,int my,int mx,int ang){\n  int nmask=mask;\n  int oy=cy+my;\n  int ox=cx+mx;\n  int cnt=0;\n  int val=0;\n  map<pii,int> m;\n  for(int i=-3;i<=0;i++)\n    for(int j=0;abs(i)+abs(j)<=3;j--)\n      m[pii(i+oy,j+ox)]=cnt,cnt++;\n  if(ang==0||ang==3){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    int nidx=m[pii(ny,nx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // テ・ツ?ィテ、ツスツ禿」ツ?ョテ」ツδ禿」ツδε」ツδ暗・ツ渉ウテ」ツ?ォテ」ツつ津」ツつキテ」ツδ陛」ツδ?\n  else if(ang==1){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<2);\n    nmask|=(((mask>>3)&1)<<4);\n    nmask|=(((mask>>4)&1)<<5);\n    nmask|=(((mask>>6)&1)<<7);\n    nmask|=(((mask>>7)&1)<<8);\n    nmask|=(((mask>>8)&1)<<9);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    }\n    nmask|=(1<<nidx);\n  }\n  // テ、ツクツ凝ヲツ鳴ケテ・ツ青妥」ツ?ォテ」ツδ禿」ツδε」ツδ暗」ツつ津」ツつキテ」ツδ陛」ツδ?\n  else if(ang==2){\n    int ny=cy+dy[ang];\n    int nx=cx+dx[ang];\n    nmask=0;\n    nmask|=(((mask>>1)&1)<<0);\n    nmask|=(((mask>>3)&1)<<1);\n    nmask|=(((mask>>4)&1)<<2);\n    nmask|=(((mask>>6)&1)<<3);\n    nmask|=(((mask>>7)&1)<<4);\n    nmask|=(((mask>>8)&1)<<5);\n    int nidx=m[pii(cy,cx)];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#')\n      if(field[ny][nx]!='.'&&!((nmask>>nidx)&1))\n        val+=field[ny][nx]-'0';\n    nmask|=(1<<nidx);\n  }\n  return pii(nmask,val);\n}\n\nstruct Sit{\n  int cy,cx,mask,my,mx;\n  Sit(){}\n  Sit(int cy_,int cx_,int mask_,int my_,int mx_){\n    cy=cy_;\n    cx=cx_;\n    mask=mask_;\n    my=my_;\n    mx=mx_;\n  }\n  bool operator<(const Sit&sit)const{\n    return true;\n  }\n};\ntypedef pair<int,Sit> iSit;\n\nint dijkstra(){\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][1<<6][0][0]=0;\n  priority_queue<iSit> pq;\n  pq.push(make_pair(0,Sit(0,0,1<<6,0,0)));\n  while(pq.size()){\n    iSit is=pq.top();pq.pop();\n    int cval=is.first;\n    Sit cSit=is.second;\n    int cy=cSit.cy,cx=cSit.cx,mask=cSit.mask,my=cSit.my,mx=cSit.mx;\n    if(dp[cy][cx][mask][my][mx]>cval)continue;\n    int leftK=K-(my+mx);\n    if(leftK<0)return 0;\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n        pii p=getNxtMaskAndVal(cy,cx,mask,my,mx,i);\n        int nmask=p.first;\n        int nAddVal=p.second;\n        if(leftK>0&&(i==0||i==3)&&dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]<cval+nAddVal){\n          dp[ny][nx][nmask][my+abs(dy[i])][mx+abs(dx[i])]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my+abs(dy[i]),mx+abs(dx[i]))));\n        }\n        else if((i==1||i==2)&&dp[ny][nx][nmask][my][mx]<cval+nAddVal){\n          dp[ny][nx][nmask][my][mx]=cval+nAddVal;\n          pq.push(make_pair(cval+nAddVal,Sit(ny,nx,nmask,my,mx)));\n        }\n      }\n    }\n  }\n  int res=0;\n  for(int mask=0;mask<(1<<10);mask++)\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        res=max(res,dp[H-1][W-1][mask][i][j]);\n  return res;\n}\n\nint main(){\n  ifstream cin(\"in.txt\");\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>field[i][j];\n  cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[4][50][50][1 << 12];\nint H, W, K;\nchar mas[50][50];\nint dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint mask;\n\nint getdir(int bit, int i){\n  return (bit >> (i * 2)) & 3;\n}\n\nint rec(int x, int y, int mul, int bit){\n  if(y == H - 1 && x == W - 1 && mul == 0) return 0;\n  if(~dp[mul][y][x][bit]) return dp[mul][y][x][bit];\n\n  int ret = 0, value = 0, mx = x, my = y;\n  bool hoge = false;\n  if(mas[y][x] != '.'){\n    for(int i = 0; i < 2 * K; i++){\n      my -= dy[getdir( bit, i)];\n      mx -= dx[getdir( bit, i)];\n      if(mx == x && my == y){\n        hoge = true;\n        break;\n      }\n    }\n    if(!hoge) value = mas[y][x] - '0';\n  }\n\n  for(int i = 0; i < 4; i++){\n    if(mul == 0 && i > 1) break;\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= H || nx < 0 || nx >= W || mas[ny][nx] == '#') continue;\n    ret = max( ret, rec( nx, ny, mul - (i > 1), ((bit << 2)|i) & mask) + value);\n  }\n  return dp[mul][y][x][bit] = ret;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  mask = (1 << (K * 2 * 2)) - 1;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      cin >> mas[i][j];\n    }\n  }\n  fill_n( ***dp, 4 * 50 * 50 * (1 << 12), -1);\n  cout << rec( 0, 0, K, 0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0581: Gifts\n// 2018.1.3 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint H, W, K;\nchar map[52][52];\nint memo[1<<12][4][50][50];\nint mask;\nint mv[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\n\nint calc(int b, int lu, int r, int c)\n{\n\tint i, k, pr, pc, nr, nc, f, ans;\n\t\n\tif (memo[b][lu][r][c] != -1) return memo[b][lu][r][c];\n\tif (lu == 0 && r == H-1 && c == W-1) return 0;\n\n\tk = K<<1, pr = r, pc = c, f = 0;\n\tfor (i = 0; i < k; i++) {\n\t\tpr += -mv[(b>>(i<<1)) & 3][0];\n\t\tpc += -mv[(b>>(i<<1)) & 3][1];\n\t\tif (pr == r && pc == c) { f = 1; break; }\n\t}\n\tif (!f && isdigit(map[r][c])) k = map[r][c] & 0xf; else k = 0;\n\n\tans = -1000;\n\tfor (i = 0; i < 4; i++) {\n\t\tif (lu == 0 && i >= 2) break;\n\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\tif (nr >= 0 && nr < H && nc >= 0 && nc < W && map[nr][nc] != '#') {\n\t\t\tint x = calc(((b << 2) | i) & mask, lu - (i >= 2), nr, nc) + k;\n\t\t\tif (ans < x) ans = x;\n\t\t}\n\t}\n\treturn memo[b][lu][r][c] = ans;\n}\n\nint main()\n{\n\tint r, ans;\n\t\n\tscanf(\"%d%d%d\", &H, &W, &K);\n\tmask = (1<<(K<<2)) - 1;\n\tmemset(memo, -1, sizeof(memo));\n\tfor (r = 0; r < H; r++) scanf(\"%s\", map[r]);\n\tans = calc(0, K, 0, 0);\tif (ans < 0) ans = 0;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar input[64][64];\nint H, W, K;\nint table[64][64];\n\nint solve(int i, int j, int k, int point) {\n\tint ret1 = 0, ret2 = 0;\n\tint tmp;\n\tint flag = 0;\n\n\tif(input[i][j] == '#') {\n\t\treturn 0;\n\t}\n\n\tif('1' <= input[i][j] && input[i][j] <= '9' && !table[i][j]) {\n\t\tpoint += input[i][j] - '0';\n\t\ttable[i][j] = 1;\n\t\tflag = 1;\n\t}\n\n\tif(i < H - 1) {\n\t\tret1 = solve(i + 1, j, k, point);\n\t}\n\n\tif(j < W - 1) {\n\t\tret2 = solve(i, j + 1, k, point);\n\t}\n\n\tif(k > 0) {\n\t\tif(i > 0) {\n\t\t\ttmp = solve(i - 1, j, k - 1, point);\n\t\t\tif(tmp > ret2)\n\t\t\t\tret2 = tmp;\n\t\t}\n\n\t\tif(j > 0) {\n\t\t\ttmp = solve(i, j - 1, k - 1, point);\n\t\t\tif(tmp > ret2)\n\t\t\t\tret2 = tmp;\n\t\t}\n\t}\n\tif(flag)\n\t\ttable[i][j] = 0;\n\n\tif(i == H - 1 && j == W - 1)\n\t\treturn point > ret1 ? (point > ret2 ? point : ret2) : (ret1 > ret2 ? ret1 : ret2);\n\n\treturn ret1 > ret2 ? ret1 : ret2;\n}\n\nint main(void) {\n\tint i, ans;\n\tscanf(\"%d %d %d\", &H, &W, &K);\n\n\tfor(i = 0; i < H; i++) {\n\t\tscanf(\"%s\", input[i]);\n\t}\n\n\tans = solve(0, 0, K, 0);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define CROAD '.'\n#define CNOENTRY '#'\n\nchar field[52][52];\nint max_gifts;\nint tx, ty;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid search(int x, int y, int k, int gifts) {\n    int i;\n    char g;\n    g = field[y][x];\n    if (x == tx && y == ty) {\n        if (max_gifts < gifts) max_gifts = gifts;\n        if (k == 0) return;\n    }\n    else {\n        if ('1' <= g && g <= '9') {\n            gifts += g - '0';\n            field[y][x] = CROAD;\n        }\n    }\n    for (i = 0; i < 4; i++) {\n        if (i >= 2 && k == 0) break;\n        if (field[y+dy[i]][x+dx[i]] != CNOENTRY) {\n            search(x + dx[i], y + dy[i], k - (i >= 2), gifts);\n        }\n    }\n\n    field[y][x] = g;\n}\n\nint main(void) {\n    int H, W, K, i, j;\n\n    scanf(\"%d%d%d\", &H, &W, &K);\n    for (i = 0; i <= H + 1; i++) {\n        if (i == 0 || i == H+1) {\n            for (j = 0; j <= W + 1; j++) {\n                field[i][j] = CNOENTRY;\n            }\n            continue;\n        }\n        scanf(\"%s\", &(field[i][1]));\n        field[i][0] = field[i][W+1] = CNOENTRY;\n    }\n\n    max_gifts = 0;\n    tx = W;\n    ty = H;\n    search(1, 1, K, 0);\n\n    printf(\"%d\\n\", max_gifts);\n\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "package aoj.volume05.joi2012;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Gifts\n */\npublic class Main {\n\n\tstatic int[][] HV = {\n\t\t\t{1, 0, 0},\n\t\t\t{0, 1, 0},\n\t\t\t{-1, 0, 1},\n\t\t\t{0, -1, 1},\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\n\t\tint H, W, K;\n\t\tH = parseInt(st.nextToken());\n\t\tW = parseInt(st.nextToken());\n\t\tK = parseInt(st.nextToken());\n\n\t\tchar[][] map = new char[H + 2][W + 2];\n\t\tint[][][] count = new int[H + 2][W + 2][4];\n\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tArrays.fill(map[i], '#');\n\t\t}\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tline = br.readLine();\n\t\t\tfor (int j = 0; j < line.length(); j++) {\n\t\t\t\tmap[i + 1][j + 1] = line.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\tint max = 0;\n\t\tQueue<Pos> q = new ArrayDeque<>();\n\t\tPos pos = main.new Pos();\n\t\tpos.y = 1;\n\t\tpos.x = 1;\n\t\tpos.backs = 0;\n\t\tpos.gifts = 0;\n\t\tq.offer(pos);\n\n\t\twhile (!q.isEmpty()) {\n\n\t\t\tPos curr = q.poll();\n\n\t\t\tif (curr.y == H && curr.x == W) {\n\t\t\t\tmax = Math.max(max, curr.gifts);\n\t\t\t\tif (curr.backs == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < HV.length; i++) {\n\t\t\t\tPos next = main.new Pos(curr);\n\t\t\t\tnext.y += HV[i][0];\n\t\t\t\tnext.x += HV[i][1];\n\t\t\t\tnext.backs += HV[i][2];\n\t\t\t\tchar to = map[next.y][next.x];\n\t\t\t\tif (to != '#' && next.backs <= K) {\n\t\t\t\t\tif (to != '.') {\n\t\t\t\t\t\tint shop = next.y * 100 + next.x;\n\t\t\t\t\t\tif (!next.shops.contains(shop)) {\n\t\t\t\t\t\t\tnext.gifts += to - '0';\n\t\t\t\t\t\t\tnext.shops.add(shop);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (next.gifts > count[next.y][next.x][i]) {\n\t\t\t\t\t\tcount[next.y][next.x][i] = next.gifts;\n\t\t\t\t\t\tq.offer(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(max);\n\n\t}\n\n\tclass Pos {\n\t\tint y = 0;\n\t\tint x = 0;\n\t\tint backs = 0;\n\t\tint gifts = 0;\n\t\tSet<Integer> shops = new HashSet<>();\n\n\t\tPos() {\n\t\t}\n\n\t\tPos(Pos pos) {\n\t\t\tthis.y = pos.y;\n\t\t\tthis.x = pos.x;\n\t\t\tthis.backs = pos.backs;\n\t\t\tthis.gifts = pos.gifts;\n\t\t\tthis.shops.addAll(pos.shops);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tpublic static class Place{\n\t\tint x, y;\n\n\t\tpublic Place(int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 97;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + x;\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPlace other = (Place) obj;\n\t\t\tif (x != other.x)\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class State{\n\t\tint x, y, k;\n\t\tSet<Place> visited;\n\t\t\n\t\tpublic State(int x, int y, int k, Set<Place> visited) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.k = k;\n\t\t\tthis.visited = visited;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + k;\n\t\t\tresult = prime * result\n\t\t\t\t\t+ ((visited == null) ? 0 : visited.hashCode());\n\t\t\tresult = prime * result + x;\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tState other = (State) obj;\n\t\t\tif (k != other.k)\n\t\t\t\treturn false;\n\t\t\tif (visited == null) {\n\t\t\t\tif (other.visited != null)\n\t\t\t\t\treturn false;\n\t\t\t} else if (!visited.equals(other.visited))\n\t\t\t\treturn false;\n\t\t\tif (x != other.x)\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static int[] dx = new int[]{1, 0, -1,  0};\n\tpublic static int[] dy = new int[]{0, 1,  0, -1};\n\t\n\tpublic static int H;\n\tpublic static int W;\n\tpublic static Map<State, Integer> memo;\n\tpublic static char[][] field;\n\t\n\tpublic static int solve(int cur_x, int cur_y, int k, Set<Place> visited){\n\t\tState state = new State(cur_x, cur_y, k, visited);\n\t\t\n\t\tif(memo.get(state) != null){\n\t\t\treturn memo.get(state);\n\t\t}\n\t\t\n\t\tint res = Integer.MIN_VALUE;\n\t\t\n\t\tif(cur_x == W - 1 && cur_y == H - 1){\n\t\t\tres = 0;\n\t\t}\n\t\t\n\t\tfor(int d = 0; d < 4; d++){\n\t\t\tint xx = cur_x + dx[d];\n\t\t\tint yy = cur_y + dy[d];\n\t\t\tint kk = k - (d >= 2 ? 1 : 0);\n\t\t\t\n\t\t\tif(xx < 0 || xx >= W || yy < 0 || yy >= H || kk < 0 || field[yy][xx] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tHashSet<Place> vv = new HashSet<Place>();\n\t\t\tfor(Place place : visited){\n\t\t\t\tif(Math.max(xx - place.x, 0) + Math.max(yy - place.y, 0) <= kk){\n\t\t\t\t\tvv.add(place);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(field[yy][xx] != '.'){\n\t\t\t\tvv.add(new Place(xx, yy));\n\t\t\t}\n\t\t\t\n\t\t\tint val = (field[yy][xx] != '.' ? field[yy][xx] - '0' : 0);\n\t\t\tfor(Place place : visited){\n\t\t\t\tif(place.x == xx && place.y == yy){\n\t\t\t\t\tval = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tres = Math.max(res, solve(xx, yy, kk, vv) + val);\n\t\t}\n\t\t\n\t\tmemo.put(state, res);\n\t\treturn res;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tH = sc.nextInt();\n\t\tW = sc.nextInt();\n\t\tfinal int K = sc.nextInt();\n\t\t\n\t\tfield = new char[H][W];\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tfield[i][j] = input[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo = new HashMap<State, Integer>();\n\t\t\n\t\tSystem.out.println(solve(0,0,K,new HashSet<Place>()));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Gifts\n */\npublic class Main {\n\n\tstatic int[][] HV = {\n\t\t\t{1, 0, 0},\n\t\t\t{0, 1, 0},\n\t\t\t{-1, 0, 1},\n\t\t\t{0, -1, 1},\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\n\t\tint H, W, K;\n\t\tH = parseInt(st.nextToken());\n\t\tW = parseInt(st.nextToken());\n\t\tK = parseInt(st.nextToken());\n\n\t\tchar[][] map = new char[H + 2][W + 2];\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tArrays.fill(map[i], '#');\n\t\t}\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tline = br.readLine();\n\t\t\tfor (int j = 0; j < line.length(); j++) {\n\t\t\t\tmap[i + 1][j + 1] = line.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\tint max = 0;\n\t\tQueue<Pos> q = new ArrayDeque<>();\n\t\tPos pos = main.new Pos();\n\t\tpos.y = 1;\n\t\tpos.x = 1;\n\t\tpos.backs = 0;\n\t\tpos.gifts = 0;\n\t\tq.offer(pos);\n\n\t\twhile (!q.isEmpty()) {\n\n\t\t\tPos curr = q.poll();\n\n\t\t\tif (curr.y == H && curr.x == W) {\n\t\t\t\tmax = Math.max(max, curr.gifts);\n\t\t\t\tif (curr.backs == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < HV.length; i++) {\n\t\t\t\tPos next = main.new Pos(curr);\n\t\t\t\tnext.y += HV[i][0];\n\t\t\t\tnext.x += HV[i][1];\n\t\t\t\tnext.backs += HV[i][2];\n\t\t\t\tchar to = map[next.y][next.x];\n\t\t\t\tif (to != '#' && next.backs <= K) {\n\t\t\t\t\tif (to != '.') {\n\t\t\t\t\t\tint shop = next.y * 100 + next.x;\n\t\t\t\t\t\tif (!next.shops.contains(shop)) {\n\t\t\t\t\t\t\tnext.gifts += to - '0';\n\t\t\t\t\t\t\tnext.shops.add(shop);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq.offer(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(max);\n\n\t}\n\n\tclass Pos {\n\t\tint y = 0;\n\t\tint x = 0;\n\t\tint backs = 0;\n\t\tint gifts = 0;\n\t\tSet<Integer> shops = new HashSet<>();\n\n\t\tPos() {\n\t\t}\n\n\t\tPos(Pos pos) {\n\t\t\tthis.y = pos.y;\n\t\t\tthis.x = pos.x;\n\t\t\tthis.backs = pos.backs;\n\t\t\tthis.gifts = pos.gifts;\n\t\t\tthis.shops.addAll(pos.shops);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Gifts\n */\npublic class Main {\n\n\tstatic int[][] HV = {\n\t\t\t{1, 0, 0},\n\t\t\t{0, 1, 0},\n\t\t\t{-1, 0, 1},\n\t\t\t{0, -1, 1},\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\n\t\tint H, W, K;\n\t\tH = parseInt(st.nextToken());\n\t\tW = parseInt(st.nextToken());\n\t\tK = parseInt(st.nextToken());\n\n\t\tchar[][] map = new char[H + 2][W + 2];\n\t\tint[][][] count = new int[H + 2][W + 2][4];\n\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tArrays.fill(map[i], '#');\n\t\t}\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tline = br.readLine();\n\t\t\tfor (int j = 0; j < line.length(); j++) {\n\t\t\t\tmap[i + 1][j + 1] = line.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\tint max = 0;\n\t\tQueue<Pos> q = new ArrayDeque<>();\n\t\tPos pos = main.new Pos();\n\t\tpos.y = 1;\n\t\tpos.x = 1;\n\t\tpos.backs = 0;\n\t\tpos.gifts = 0;\n\t\tq.offer(pos);\n\n\t\twhile (!q.isEmpty()) {\n\n\t\t\tPos curr = q.poll();\n\n\t\t\tif (curr.y == H && curr.x == W) {\n\t\t\t\tmax = Math.max(max, curr.gifts);\n\t\t\t\tif (curr.backs == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < HV.length; i++) {\n\t\t\t\tPos next = main.new Pos(curr);\n\t\t\t\tnext.y += HV[i][0];\n\t\t\t\tnext.x += HV[i][1];\n\t\t\t\tnext.backs += HV[i][2];\n\t\t\t\tchar to = map[next.y][next.x];\n\t\t\t\tif (to != '#' && next.backs <= K) {\n\t\t\t\t\tif (to != '.') {\n\t\t\t\t\t\tint shop = next.y * 100 + next.x;\n\t\t\t\t\t\tif (!next.shops.contains(shop)) {\n\t\t\t\t\t\t\tnext.gifts += to - '0';\n\t\t\t\t\t\t\tnext.shops.add(shop);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (next.gifts > count[next.y][next.x][i]) {\n\t\t\t\t\t\tcount[next.y][next.x][i] = next.gifts;\n\t\t\t\t\t\tq.offer(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(max);\n\n\t}\n\n\tclass Pos {\n\t\tint y = 0;\n\t\tint x = 0;\n\t\tint backs = 0;\n\t\tint gifts = 0;\n\t\tSet<Integer> shops = new HashSet<>();\n\n\t\tPos() {\n\t\t}\n\n\t\tPos(Pos pos) {\n\t\t\tthis.y = pos.y;\n\t\t\tthis.x = pos.x;\n\t\t\tthis.backs = pos.backs;\n\t\t\tthis.gifts = pos.gifts;\n\t\t\tthis.shops.addAll(pos.shops);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\th = scanner.nextInt();\n\t\tw = scanner.nextInt();\n\t\tK = scanner.nextInt();\n\t\tmask = (1 << (4 * K)) - 1;\n\t\tmap = new char[h][w];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tmap[i] = scanner.next().toCharArray();\n\t\tdp = new int[4][h][w][1 << (K * 4)];\n\t\tfor (int[][][] dp1 : dp)\n\t\t\tfor (int[][] dp2 : dp1)\n\t\t\t\tfor (int[] dp3 : dp2)\n\t\t\t\t\tArrays.fill(dp3, -1);\n\t\tv = new boolean[mask + 1];\n\t\tloop: for (int i = 0; i <= mask; i++) {\n\t\t\tint py = 0;\n\t\t\tint px = 0;\n\t\t\tint bit = i;\n\t\t\tfor (int j = 0; j < K * 2; j++) {\n\t\t\t\tpy -= dy[bit & 3];\n\t\t\t\tpx -= dx[bit & 3];\n\t\t\t\tif (py == 0 && px == 0) {\n\t\t\t\t\tv[i] = true;\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\t\t\t\tbit >>= 2;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(slove(K, 0, 0, 0));\n\t}\n\n\tprivate int slove(int k, int y, int x, int bit) {\n\t\tif (dp[k][y][x][bit] != -1)\n\t\t\treturn dp[k][y][x][bit];\n\t\tif (y == h - 1 && x == w - 1 && k == 0)\n\t\t\treturn 0;\n\t\tint ret = 0;\n\t\tif (!v[bit] && map[y][x] != '.')\n\t\t\tret += map[y][x] - '0';\n\t\tint val = -(1 << 20);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (k == 0 && i >= 2)\n\t\t\t\tbreak;\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (map[ny][nx] == '#')\n\t\t\t\tcontinue;\n\t\t\tval = Math\n\t\t\t\t\t.max(val,\n\t\t\t\t\t\t\tslove(k - (i >= 2 ? 1 : 0), ny, nx,\n\t\t\t\t\t\t\t\t\t((bit << 2) | i) & mask) + ret);\n\t\t}\n\t\treturn dp[k][y][x][bit] = val;\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn (0 <= ny && ny < h && 0 <= nx && nx < w);\n\t}\n\n\tint h, w, K, mask;\n\tboolean[] v;\n\tint[] dy = { 0, 1, 0, -1 };\n\tint[] dx = { 1, 0, -1, 0 };\n\tint[][][][] dp;\n\tchar[][] map;\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(x,y,c,k){\n   if(obj.hasOwnProperty(x+\" \"+y+\" \"+c))return;\n   else obj[x+\" \"+y+\" \"+c]=true;\n   max=Math.max(max,c);\n   for(var i=0;i<4;i++){\n      if(k<=0 && i<2)continue;\n      var xx=x+dx[i];\n      var yy=y+dy[i];\n      if(xx<0 || yy<0 || xx>=w || yy>=h)continue;\n      if(yx[yy][xx]==\"#\")continue;\n      var kk=k;\n      if(i<2)kk=kk-1;\n      var plus=yx[yy][xx]-0;\n      yx[yy][xx]=0;\n      bomb(xx,yy,c+plus,kk);\n      yx[yy][xx]=plus;\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar hwk=Arr.shift().split(\" \").map(Number);\nvar h=hwk[0];\nvar w=hwk[1];\nvar K=hwk[2];\nvar yx=[];\nfor(var i=0;i<h;i++){\n   var v=Arr.shift().split(\"\");\n   yx.push(v.replace(/\\./g,\"0\"));\n}\nvar max=0;\nvar obj={};\nvar dx=[0,-1,1,0];\nvar dy=[-1,0,0,1];\nbomb(0,0,0,K);\nconsole.log(max);"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(x,y,c,k){\n   if(obj.hasOwnProperty(x+\" \"+y+\" \"+c))return;\n   else obj[x+\" \"+y+\" \"+c]=true;\n   max=Math.max(max,c);\n   for(var i=0;i<4;i++){\n      if(k<=0 && i<2)continue;\n      var xx=x+dx[i];\n      var yy=y+dy[i];\n      if(xx<0 || yy<0 || xx>=w || yy>=h)continue;\n      if(yx[yy][xx]==\"#\")continue;\n      var kk=k;\n      if(i<2)kk=kk-1;\n      var plus=yx[yy][xx]-0;\n      yx[yy][xx]=0;\n      bomb(xx,yy,c+plus,kk);\n      yx[yy][xx]=plus;\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\ninput=input.replace(/\\./g,\"0\");\nvar Arr=(input.trim()).split(\"\\n\");\nvar hwk=Arr.shift().split(\" \").map(Number);\nvar h=hwk[0];\nvar w=hwk[1];\nvar K=hwk[2];\nvar yx=[];\nfor(var i=0;i<h;i++){\n   var v=Arr.shift().split(\"\");\n   yx.push(v);\n}\nvar max=0;\nvar obj={};\nvar dx=[0,-1,1,0];\nvar dy=[-1,0,0,1];\nbomb(0,0,0,K);\nconsole.log(max);"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMVS = [[-1, 0, -1], [0, -1, -1], [0, 1, 0], [1, 0, 0]]\n\n### subroutines\n\ndef wander_rec(y, x, k, sv)\n  if y == $h - 1 && x == $w - 1 && k == 0\n    return sv\n  end\n\n  max_sv = 0\n\n  for mv in MVS\n    y0 = y + mv[0]\n    x0 = x + mv[1]\n    k0 = k + mv[2]\n    if k0 >= 0 && y0 >= 0 && y0 < $h && x0 >= 0 && x0 < $w &&\n        $cmaps[y0][x0] >= 0\n      dsv = ($visited[y0][x0] == 0) ? $cmaps[y0][x0] : 0\n\n      $visited[y0][x0] += 1\n      sv0 = wander_rec(y0, x0, k0, sv + dsv)\n      $visited[y0][x0] -= 1\n\n      max_sv = sv0 if max_sv < sv0\n    end\n  end\n\n  max_sv\nend\n\n### main\n\n$h, $w, k = gets.strip.split(' ').map{|s| s.to_i}\n\n$cmaps = $h.times.map{[]}\n\nfor y in (0...$h)\n  yline = gets.strip\n\n  for x in (0...$w)\n    case yline[x]\n    when '.'\n      $cmaps[y][x] = 0\n    when '#'\n      $cmaps[y][x] = -1\n    else\n      $cmaps[y][x] = yline[x].to_i\n    end\n  end\nend\n#p $cmaps\n\n$visited = $h.times.map{$w.times.map{0}}\n\nputs wander_rec(0, 0, k, 0)"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.algorithm;\nimport std.conv;\nimport std.array;\nimport std.range;\nimport std.c.stdio;\nimport core.memory;\n\nint h,w,k;\nint[][] board;\n\nint[][] dp;\nref int getdp(int l,int a,int b,int c,int d,int e,int y,int x){\n\treturn dp[l][((((((a*4+b)*4)+c)*4+d)*4+e)*h+y)*w+x];\n}\n\nvoid main(){\n\tGC.disable;\n\tscanf(\"%d%d%d\\n\",&h,&w,&k);\n\tdp = new int[][](k+1,4*4*4*4*4*h*w);\n\tforeach(int g;0..k+1){\n\t\tdp[g][] = int.min;\n\t}\n\tchar[] rbuf = new char[64];\n\tboard = new int[][](h,w);\n\tforeach(int i;0..h){\n\t\treadln(rbuf);\n\t\tforeach(int j;0..w){\n\t\t\tif(rbuf[j] == '#')\n\t\t\t\tboard[i][j] = -1;\n\t\t\telse if(rbuf[j] == '.')\n\t\t\t\tboard[i][j] = 0;\n\t\t\telse\n\t\t\t\tboard[i][j] = rbuf[j]-'0';\n\t\t}\n\t}\n\tint[5][1024] dirs;\n\tint[1024] backc;\n\tbackc[] = 0;\n\tforeach(int i;0..1024){\n\t\tforeach(int j;0..5){\n\t\t\tint d = (i / (1<<(j*2)))%4;\n\t\t\tdirs[i][j] = d;\n\t\t\tif(d<2)\n\t\t\t\tbackc[i]++;\n\t\t}\n\t}\n\tint[4] dx = [0,-1,0,1];\n\tint[4] dy = [-1,0,1,0];\n\tforeach(i;0..1024){\n\t\tdp[0][i*w*h] = 0;\n\t}\n\tforeach(int g;0..k+1){\n\t\tforeach(int i;0..h){\n\t\t\tforeach(int j;0..w){\n\t\t\t\tforeach(int t;0..1024){\n\t\t\t\t\tforeach(int d;0..4){\n\t\t\t\t\t\tif(d<2 && g == k)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(i+dy[d]>=0&&i+dy[d]<h&&j+dx[d]>=0&&j+dx[d]<w){\n\t\t\t\t\t\t\tif(board[i+dy[d]][j+dx[d]]>=0){\n\t\t\t\t\t\t\t\tint pls = board[i+dy[d]][j+dx[d]];\n\t\t\t\t\t\t\t\tint nx=j;\n\t\t\t\t\t\t\t\tint ny=i;\n\t\t\t\t\t\t\t\tforeach(p;0..5){\n\t\t\t\t\t\t\t\t\tnx += dx[(dirs[t][p]+2)%4];\n\t\t\t\t\t\t\t\t\tny += dy[(dirs[t][p]+2)%4];\n\t\t\t\t\t\t\t\t\tif(ny == i+dy[d] && nx == j+dx[d]){\n\t\t\t\t\t\t\t\t\t\tpls = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgetdp(g + (d<2?1:0),dirs[t][3],dirs[t][2],dirs[t][1],dirs[t][0],d,i+dy[d],j+dx[d]) = max(getdp(g + (d<2?1:0),dirs[t][3],dirs[t][2],dirs[t][1],dirs[t][0],d,i+dy[d],j+dx[d]),dp[g][t*h*w+i*w+j] + pls);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*foreach(g;0..k+1){\n\t\tg.writeln;\n\t\tforeach(i;0..h){\n\t\t\tint[] tmpline;\n\t\t\tforeach(j;0..w){\n\t\t\t\tint tmpmax=0;\n\t\t\t\tforeach(t;0..1024){\n\t\t\t\t\tif(backc[t] == g)\n\t\t\t\t\t\ttmpmax = max(tmpmax,dp[g][t*w*h+i*w+j]);\n\t\t\t\t}\n\t\t\t\ttmpline ~= tmpmax;\n\t\t\t}\n\t\t\ttmpline.writeln;\n\t\t}\n\t}*/\n\tint res=0;\n\tforeach(int g;0..k+1){\n\t\tforeach(int i;0..1024){\n\t\t\tres = max(res,dp[g][i*h*w+(h-1)*w+w-1]);\n\t\t}\n\t}\n\tres.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.algorithm;\nimport std.conv;\nimport std.array;\nimport std.range;\nimport std.c.stdio;\nimport core.memory;\n\nint h,w,k;\nint[][] board;\n\nint[][] dp;\nref int getdp(int l,int a,int b,int c,int d,int e,int y,int x){\n\treturn dp[l][((((((a*4+b)*4)+c)*4+d)*4+e)*h+y)*w+x];\n}\n\nvoid main(){\n\t//GC.disable;\n\tscanf(\"%d %d %d\",&h,&w,&k);\n\tdp = new int[][](k+1,4*4*4*4*4*h*w);\n\tforeach(int g;0..k+1){\n\t\tdp[g][] = int.min;\n\t}\n\tchar[] rbuf = new char[64];\n\tboard = new int[][](h,w);\n\tstd.stdio.stdin.flush;\n\tforeach(int i;0..h){\n\t\treadln(rbuf);\n\t\tforeach(int j;0..w){\n\t\t\tif(rbuf[j] == '#')\n\t\t\t\tboard[i][j] = -1;\n\t\t\telse if(rbuf[j] == '.')\n\t\t\t\tboard[i][j] = 0;\n\t\t\telse\n\t\t\t\tboard[i][j] = rbuf[j]-'0';\n\t\t}\n\t}\n\tint[5][1024] dirs;\n\tint[1024] backc;\n\tbackc[] = 0;\n\tforeach(int i;0..1024){\n\t\tforeach(int j;0..5){\n\t\t\tint d = (i / (1<<(j*2)))%4;\n\t\t\tdirs[i][j] = d;\n\t\t\tif(d<2)\n\t\t\t\tbackc[i]++;\n\t\t}\n\t}\n\tint[4] dx = [0,-1,0,1];\n\tint[4] dy = [-1,0,1,0];\n\tforeach(i;0..1024){\n\t\tdp[0][i*w*h] = 0;\n\t}\n\tforeach(int g;0..k+1){\n\t\tforeach(int i;0..h){\n\t\t\tforeach(int j;0..w){\n\t\t\t\tforeach(int t;0..1024){\n\t\t\t\t\tforeach(int d;0..4){\n\t\t\t\t\t\tif(d<2 && g == k)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(i+dy[d]>=0&&i+dy[d]<h&&j+dx[d]>=0&&j+dx[d]<w){\n\t\t\t\t\t\t\tif(board[i+dy[d]][j+dx[d]]>=0){\n\t\t\t\t\t\t\t\tint pls = board[i+dy[d]][j+dx[d]];\n\t\t\t\t\t\t\t\tint nx=j;\n\t\t\t\t\t\t\t\tint ny=i;\n\t\t\t\t\t\t\t\tforeach(p;0..5){\n\t\t\t\t\t\t\t\t\tnx += dx[(dirs[t][p]+2)%4];\n\t\t\t\t\t\t\t\t\tny += dy[(dirs[t][p]+2)%4];\n\t\t\t\t\t\t\t\t\tif(ny == i+dy[d] && nx == j+dx[d]){\n\t\t\t\t\t\t\t\t\t\tpls = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgetdp(g + (d<2?1:0),dirs[t][3],dirs[t][2],dirs[t][1],dirs[t][0],d,i+dy[d],j+dx[d]) = max(getdp(g + (d<2?1:0),dirs[t][3],dirs[t][2],dirs[t][1],dirs[t][0],d,i+dy[d],j+dx[d]),dp[g][t*h*w+i*w+j] + pls);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*foreach(g;0..k+1){\n\t\tg.writeln;\n\t\tforeach(i;0..h){\n\t\t\tint[] tmpline;\n\t\t\tforeach(j;0..w){\n\t\t\t\tint tmpmax=0;\n\t\t\t\tforeach(t;0..1024){\n\t\t\t\t\tif(backc[t] == g)\n\t\t\t\t\t\ttmpmax = max(tmpmax,dp[g][t*w*h+i*w+j]);\n\t\t\t\t}\n\t\t\t\ttmpline ~= tmpmax;\n\t\t\t}\n\t\t\ttmpline.writeln;\n\t\t}\n\t}*/\n\tint res=0;\n\tforeach(int g;0..k+1){\n\t\tforeach(int i;0..1024){\n\t\t\tres = max(res,dp[g][i*h*w+(h-1)*w+w-1]);\n\t\t}\n\t}\n\tres.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.algorithm;\nimport std.conv;\nimport std.array;\nimport std.range;\nimport std.c.stdio;\nimport core.memory;\n\nint h,w,k;\nint[][] board;\n\nint[][] dp;\nref int getdp(int l,int a,int b,int c,int d,int e,int y,int x){\n\treturn dp[l][((((((a*4+b)*4)+c)*4+d)*4+e)*h+y)*w+x];\n}\n\nvoid main(){\n\tGC.disable;\n\tscanf(\"%d %d %d\",&h,&w,&k);\n\tdp = new int[][](k+1,4*4*4*4*4*h*w);\n\tforeach(int g;0..k+1){\n\t\tdp[g][] = int.min;\n\t}\n\tchar[] rbuf = new char[64];\n\tboard = new int[][](h,w);\n\tstd.stdio.stdin.flush;\n\tforeach(int i;0..h){\n\t\treadln(rbuf);\n\t\tforeach(int j;0..w){\n\t\t\tif(rbuf[j] == '#')\n\t\t\t\tboard[i][j] = -1;\n\t\t\telse if(rbuf[j] == '.')\n\t\t\t\tboard[i][j] = 0;\n\t\t\telse\n\t\t\t\tboard[i][j] = rbuf[j]-'0';\n\t\t}\n\t}\n\tint[5][1024] dirs;\n\tint[1024] backc;\n\tbackc[] = 0;\n\tforeach(int i;0..1024){\n\t\tforeach(int j;0..5){\n\t\t\tint d = (i / (1<<(j*2)))%4;\n\t\t\tdirs[i][j] = d;\n\t\t\tif(d<2)\n\t\t\t\tbackc[i]++;\n\t\t}\n\t}\n\tint[4] dx = [0,-1,0,1];\n\tint[4] dy = [-1,0,1,0];\n\tforeach(i;0..1024){\n\t\tdp[0][i*w*h] = 0;\n\t}\n\tforeach(int g;0..k+1){\n\t\tforeach(int i;0..h){\n\t\t\tforeach(int j;0..w){\n\t\t\t\tforeach(int t;0..1024){\n\t\t\t\t\tforeach(int d;0..4){\n\t\t\t\t\t\tif(d<2 && g == k)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(i+dy[d]>=0&&i+dy[d]<h&&j+dx[d]>=0&&j+dx[d]<w){\n\t\t\t\t\t\t\tif(board[i+dy[d]][j+dx[d]]>=0){\n\t\t\t\t\t\t\t\tint pls = board[i+dy[d]][j+dx[d]];\n\t\t\t\t\t\t\t\tint nx=j;\n\t\t\t\t\t\t\t\tint ny=i;\n\t\t\t\t\t\t\t\tforeach(p;0..5){\n\t\t\t\t\t\t\t\t\tnx += dx[(dirs[t][p]+2)%4];\n\t\t\t\t\t\t\t\t\tny += dy[(dirs[t][p]+2)%4];\n\t\t\t\t\t\t\t\t\tif(ny == i+dy[d] && nx == j+dx[d]){\n\t\t\t\t\t\t\t\t\t\tpls = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgetdp(g + (d<2?1:0),dirs[t][3],dirs[t][2],dirs[t][1],dirs[t][0],d,i+dy[d],j+dx[d]) = max(getdp(g + (d<2?1:0),dirs[t][3],dirs[t][2],dirs[t][1],dirs[t][0],d,i+dy[d],j+dx[d]),dp[g][t*h*w+i*w+j] + pls);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*foreach(g;0..k+1){\n\t\tg.writeln;\n\t\tforeach(i;0..h){\n\t\t\tint[] tmpline;\n\t\t\tforeach(j;0..w){\n\t\t\t\tint tmpmax=0;\n\t\t\t\tforeach(t;0..1024){\n\t\t\t\t\tif(backc[t] == g)\n\t\t\t\t\t\ttmpmax = max(tmpmax,dp[g][t*w*h+i*w+j]);\n\t\t\t\t}\n\t\t\t\ttmpline ~= tmpmax;\n\t\t\t}\n\t\t\ttmpline.writeln;\n\t\t}\n\t}*/\n\tint res=0;\n\tforeach(int g;0..k+1){\n\t\tforeach(int i;0..1024){\n\t\t\tres = max(res,dp[g][i*h*w+(h-1)*w+w-1]);\n\t\t}\n\t}\n\tres.writeln;\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**8)\n\ndef check(y,x):\n    if 0<=x<=w-1 and 0<=y<=h-1 and g[y][x]!=\"#\":\n        return True\n    return False\n\ndef dfs(y,x,cnt,v):\n    global ans\n    if cnt>k:return -1\n    if y==h-1 and x==w-1 and cnt==k:\n        return v\n    if cnt==k:\n        for i in xrange(4):\n            if i==2 or i==3:continue\n            nxx=x+dx[i]\n            nyy=y+dy[i]\n            if not check(nyy,nxx):continue\n            if g[nyy][nxx]!=\".\":\n                su=0\n                f=0\n                if not visited[nyy][nxx]:\n                    su=int(g[nyy][nxx])\n                    visited[nyy][nxx]=True\n                    f=1\n                ans=max(ans,dfs(nyy,nxx,cnt,v+su))\n                if f==1:\n                    visited[nyy][nxx]=False\n            else:\n                ans=max(ans,dfs(nyy,nxx,cnt,v))\n    if y==h-1 and x==w-1 and cnt==k:\n        return v\n    for i in xrange(4):\n        nxx=x+dx[i]\n        nyy=y+dy[i]\n        if not check(nyy,nxx):continue\n        if i==0 or i==1:\n            if g[nyy][nxx]!=\".\":\n                su=0\n                f=0\n                if not visited[nyy][nxx]:\n                    su=int(g[nyy][nxx])\n                    visited[nyy][nxx]=True\n                    f=1\n                ans=max(ans,dfs(nyy,nxx,cnt,v+su))\n                if f==1:\n                    visited[nyy][nxx]=False\n            else:\n                ans=max(ans,dfs(nyy,nxx,cnt,v))\n        else:\n            if g[nyy][nxx]!=\".\":\n                su=0\n                f=0\n                if not visited[nyy][nxx]:\n                    su=int(g[nyy][nxx])\n                    visited[nyy][nxx]=True\n                    f=1\n                ans=max(ans,dfs(nyy,nxx,cnt+1,v+su))\n                if f==1:\n                    visited[nyy][nxx]=False\n            else:\n                ans=max(ans,dfs(nyy,nxx,cnt+1,v))\n    return ans\n\n\nh,w,k=map(int,raw_input().split())\ng=[raw_input() for _ in xrange(h)]\ndx=(1,0,-1,0)\ndy=(0,1,0,-1)\nvisited=[[False]*w for _ in xrange(h)]\nans=0\nans=dfs(0,0,0,0)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0581\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque\nfrom copy import copy\nfrom collections import defaultdict\ninput = stdin.readline\n\n\ndef solve(field, K):\n    # ????????????????§????????????´????????§?¨?????????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n    # ??°???????????????(?§????????????£????????????????????????????????§??????????????¨)\n    Y = len(field)\n    X = len(field[0])\n    # d = [[float('inf')] * X for _ in range(Y)] #  ??????????????°?????????????????¢???INF??§?????????\n    yorimichi = K\n    purchased = set()\n    visited = defaultdict(int)\n    max_gift = 0\n\n    goal = False\n    Q = deque()\n    Q.append((0, 0, copy(purchased), copy(visited), yorimichi, goal))\n    while Q:\n        cx, cy, purchased, visited, yorimichi, goal= Q.popleft()        #  ?????¨??°?????§?¨?\n        key = '-'.join(map(str, (cx, cy)))\n        visited[key] += 1\n        if goal == True:\n            gift = 0\n            for gx, gy in purchased:\n                gift += int(field[gy][gx])\n            if gift > max_gift:\n                max_gift = gift\n        if not '0' <= field[cy][cx] <= '9':\n            field[cy][cx] = '@'\n        for i in range(4):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if nx == X-1 and ny == Y-1:\n                goal = True\n            # ?§?????????? ??°????????????????????????????????? and ?£?????????£???????????? and ??¢?????¢?´¢?????§?????? ??´???\n            if (not 0 <= nx < X) or (not 0 <= ny < Y) or field[ny][nx] == '#':\n                continue\n            key = '-'.join(map(str, (cx, cy)))\n            if visited[key] > 2:\n                continue\n\n            if dy[i] == -1 or dx[i] == -1:\n                if yorimichi > 0:\n                    temp = copy(purchased)\n                    if '0' <= field[ny][nx] <= '9':\n                        temp.add((nx, ny))\n                    Q.append((nx, ny, copy(temp), copy(visited), yorimichi-1, goal))\n            else:\n                temp = copy(purchased)\n                if '0' <= field[ny][nx] <= '9':\n                    temp.add((nx, ny))\n                Q.append((nx, ny, copy(temp), copy(visited), yorimichi, goal))\n    return max_gift\n\n\ndef main(args):\n    # data = []\n    # data.append('...#')\n    # data.append('.#.#')\n    # data.append('.#73')\n    # data.append('8##.')\n    # data.append('....')\n    # K = 2\n    # field = [list(x) for x in data] #  data????????????????????????????????????????????????\n    # result = solve(field, K)\n    # print(result)\n\n    # data = []\n    # data.append('.##9###.')\n    # data.append('.#6.9..3')\n    # data.append('.#378.#2')\n    # data.append('....#9..')\n    # data.append('##4..6.#')\n    # data.append('4...5###')\n    # data.append('4##.#..1')\n    # data.append('5..2..#.')\n    K = 3\n    # field = [list(x) for x in data] #  data????????????????????????????????????????????????\n    # result = solve(field, K)\n    # print(result)\n\n\n    H, W, K = map(int, input().split())\n    data = [input().strip('\\n') for _ in range(H)]\n    field = [list(x) for x in data] #  data????????????????????????????????????????????????\n    result = solve(field, K)\n    print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0581\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque\nfrom copy import copy\ninput = stdin.readline\n\n\ndef solve(field, K):\n    \"\"\"\n\n    :param field:\n    :return:\n    \"\"\"\n    # ????????????????§????????????´????????§?¨?????????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n    # ??°???????????????(?§????????????£????????????????????????????????§??????????????¨)\n    Y = len(field)\n    X = len(field[0])\n    d = [[float('inf')] * X for _ in range(Y)] #  ??????????????°?????????????????¢???INF??§?????????\n    yorimichi = K\n    purchased = set()\n    max_gift = 0\n\n    # ???????????????????????????????????°???????????´????????°????????§????????¢????±???????\n    Q = deque()\n    Q.append((0, 0, copy(purchased), yorimichi))\n    while Q:\n        cx, cy, purchased, yorimichi= Q.popleft()        #  ?????¨??°?????§?¨?\n        if not '0' <= field[cy][cx] <= '9':\n            field[cy][cx] = '@'\n        for i in range(4):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            # ?§?????????? ??°????????????????????????????????? and ?£?????????£???????????? and ??¢?????¢?´¢?????§?????? ??´???\n            if (not 0 <= nx < X) or (not 0 <= ny < Y):\n                continue\n            elif field[ny][nx] != '#':\n                if '0' <= field[ny][nx] <= '9':\n                    purchased.add((nx, ny))\n                    gift = 0\n                    for gx, gy in purchased:\n                        gift += int(field[gy][gx])\n                    if gift > max_gift:\n                        max_gift = gift\n\n                if yorimichi > 1:\n                    if dy[i] == -1 or dx[i] == -1:\n                        Q.append((nx, ny, copy(purchased), yorimichi-1))\n                    else:\n                        Q.append((nx, ny, copy(purchased), yorimichi))\n\n    return max_gift\n\n\ndef main(args):\n    H, W, K = map(int, input().split())\n    data = [input().strip('\\n') for _ in range(H)]\n    field = [list(x) for x in data] #  data????????????????????????????????????????????????\n    result = solve(field, K)\n    print(result)\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "INF = 9\n\nh, w, k = map(int,input().split())\nmaps = [list(\"#\" * (w + 2))]\nfor i in range(h):\n  maps.append(list(\"#\" + input() + \"#\"))\nmaps.append(list(\"#\" * (w + 2)))\n\n#スタートからそのマスまでに何度逆走する必要があるかのマップ\n#root_map = [[INF] * (w + 2) for i in range(h + 2)]\n\n#そのマスからゴールまでに何度逆走する必要があるかのマップ\nreverse_map = [[INF] * (w + 2) for i in range(h + 2)]\n\n#def root_search(x, y, score):\n#  if score < root_map[x][y]:\n#    root_map[x][y] = score\n#    if maps[x - 1][y] != \"#\":\n#      root_search(x - 1, y, score + 1)\n#    if maps[x + 1][y] != \"#\":\n#      root_search(x + 1, y, score)\n#    if maps[x][y - 1] != \"#\":\n#      root_search(x, y - 1, score + 1)\n#    if maps[x][y + 1] != \"#\":\n#      root_search(x, y + 1, score)\n#\ndef reverse_search(x, y, score):\n  if score < reverse_map[x][y]:\n    reverse_map[x][y] = score\n    if maps[x - 1][y] != \"#\":\n      reverse_search(x - 1, y, score)\n    if maps[x + 1][y] != \"#\":\n      reverse_search(x + 1, y, score + 1)\n    if maps[x][y - 1] != \"#\":\n      reverse_search(x, y - 1, score)\n    if maps[x][y + 1] != \"#\":\n      reverse_search(x, y + 1, score + 1)\n\ndef search(x, y, score, rest):\n  if rest < reverse_map[x][y]:\n    return 0\n\n  temp = maps[x][y]\n  if maps[x][y] in [str(i) for i in range(1,10)]:\n    score += int(maps[x][y])\n    maps[x][y] = \".\"\n  a = b = c = d = 0\n  if rest > 0 and maps[x - 1][y] != \"#\":\n    a = search(x - 1, y, score, rest - 1)\n  if maps[x + 1][y] != \"#\":\n    b = search(x + 1, y, score, rest)\n  if rest > 0 and maps[x][y - 1] != \"#\":\n    c = search(x, y - 1, score, rest - 1)\n  if maps[x][y + 1] != \"#\":\n    d = search(x, y + 1, score, rest)\n  ret = max(score, a, b, c, d)\n  maps[x][y] = temp\n  return ret\n\n#root_search(1, 1, 0)\nreverse_search(h, w, 0)\n\n\nprint(search(1,1,0,k))\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  def bfs(x, y, k, score):\n    if (x, y) == (w, h) and k == 0:\n      return score\n    score += mp[y][x]\n    tmp = mp[y][x]\n    mp[y][x] = 0\n    ret = -1\n    if k >= 1:\n      if mp[y][x - 1] != -1:\n        ret = max(ret, bfs(x - 1, y, k - 1, score))\n      if mp[y - 1][x] != -1:\n        ret = max(ret, bfs(x, y - 1, k - 1, score))\n    if mp[y][x + 1] != -1:\n      ret = max(ret, bfs(x + 1, y, k, score))\n    if mp[y + 1][x] != -1:\n      ret = max(ret, bfs(x, y + 1, k, score))\n  \n    mp[y][x] = tmp\n    return ret\n  \n  h, w, k = map(int, input().split())\n  mp = [list(\"#\" + input() + \"#\") for _ in range(h)]\n  mp.insert(0, [\"#\"] * (w + 2))\n  mp.append([\"#\"] * (w + 2))\n  for y in range(h + 2):\n    for x in range(w + 2):\n      if \"1\" <= mp[y][x] <= \"9\":\n        mp[y][x] = int(mp[y][x])\n      elif mp[y][x] == \".\":\n        mp[y][x] = 0\n      else:\n        mp[y][x] = -1\n  print(bfs(1, 1, k, 0))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0581\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque\nfrom copy import copy\ninput = stdin.readline\n\n\ndef solve(field, K):\n    # ????????????????§????????????´????????§?¨?????????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n    # ??°???????????????(?§????????????£????????????????????????????????§??????????????¨)\n    Y = len(field)\n    X = len(field[0])\n    # d = [[float('inf')] * X for _ in range(Y)] #  ??????????????°?????????????????¢???INF??§?????????\n    yorimichi = K\n    purchased = set()\n    max_gift = 0\n\n    Q = deque()\n    Q.append((0, 0, copy(purchased), yorimichi))\n    while Q:\n        cx, cy, purchased, yorimichi= Q.popleft()        #  ?????¨??°?????§?¨?\n        if not '0' <= field[cy][cx] <= '9':\n            field[cy][cx] = '@'\n        if cx == X-1 and cy == Y-1:\n            gift = 0\n            for gx, gy in purchased:\n                gift += int(field[gy][gx])\n            if gift > max_gift:\n                max_gift = gift\n\n        for i in range(4):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            # ?§?????????? ??°????????????????????????????????? and ?£?????????£???????????? and ??¢?????¢?´¢?????§?????? ??´???\n            if (not 0 <= nx < X) or (not 0 <= ny < Y) or field[ny][nx] == '#':\n                continue\n            if dy[i] == -1 or dx[i] == -1:\n                if yorimichi > 0:\n                    temp = copy(purchased)\n                    if '0' <= field[ny][nx] <= '9':\n                        temp.add((nx, ny))\n                    Q.append((nx, ny, copy(temp), yorimichi-1))\n            else:\n                temp = copy(purchased)\n                if '0' <= field[ny][nx] <= '9':\n                    temp.add((nx, ny))\n                Q.append((nx, ny, copy(temp), yorimichi))\n    return max_gift\n\n\ndef main(args):\n    # data = []\n    # data.append('...#')\n    # data.append('.#.#')\n    # data.append('.#73')\n    # data.append('8##.')\n    # data.append('....')\n    # K = 2\n    # field = [list(x) for x in data] #  data????????????????????????????????????????????????\n    # result = solve(field, K)\n    # print(result)\n    #\n    # data = []\n    # data.append('.##9###.')\n    # data.append('.#6.9..3')\n    # data.append('.#378.#2')\n    # data.append('....#9..')\n    # data.append('##4..6.#')\n    # data.append('4...5###')\n    # data.append('4##.#..1')\n    # data.append('5..2..#.')\n    # K = 3\n    # field = [list(x) for x in data] #  data????????????????????????????????????????????????\n    # result = solve(field, K)\n    # print(result)\n\n    H, W, K = map(int, input().split())\n    data = [input().strip('\\n') for _ in range(H)]\n    field = [list(x) for x in data] #  data????????????????????????????????????????????????\n    result = solve(field, K)\n    print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0581\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque\nfrom copy import copy\nfrom collections import defaultdict\ninput = stdin.readline\n\n\ndef solve(field, K):\n    # ????????????????§????????????´????????§?¨?????????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n    # ??°???????????????(?§????????????£????????????????????????????????§??????????????¨)\n    Y = len(field)\n    X = len(field[0])\n    # d = [[float('inf')] * X for _ in range(Y)] #  ??????????????°?????????????????¢???INF??§?????????\n    yorimichi = K\n    purchased = set()\n    visited = defaultdict(int)\n    max_gift = 0\n\n    goal = False\n    Q = deque()\n    Q.append((0, 0, copy(purchased), copy(visited), yorimichi, goal))\n    while Q:\n        cx, cy, purchased, visited, yorimichi, goal= Q.popleft()        #  ?????¨??°?????§?¨?\n        key = '-'.join(map(str, (cx, cy)))\n        visited[key] += 1\n        if goal == True:\n            gift = 0\n            for gx, gy in purchased:\n                gift += int(field[gy][gx])\n            if gift > max_gift:\n                max_gift = gift\n        if not '0' <= field[cy][cx] <= '9':\n            field[cy][cx] = '@'\n        for i in range(4):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if nx == X-1 and ny == Y-1:\n                goal = True\n            # ?§?????????? ??°????????????????????????????????? and ?£?????????£???????????? and ??¢?????¢?´¢?????§?????? ??´???\n            if (not 0 <= nx < X) or (not 0 <= ny < Y) or field[ny][nx] == '#':\n                continue\n            key = '-'.join(map(str, (cx, cy)))\n            if visited[key] > 2:\n                continue\n\n            if dy[i] == -1 or dx[i] == -1:\n                if yorimichi > 0:\n                    temp = copy(purchased)\n                    if '0' <= field[ny][nx] <= '9':\n                        temp.add((nx, ny))\n                    Q.append((nx, ny, copy(temp), copy(visited), yorimichi-1, goal))\n            else:\n                temp = copy(purchased)\n                if '0' <= field[ny][nx] <= '9':\n                    temp.add((nx, ny))\n                Q.append((nx, ny, copy(temp), copy(visited), yorimichi, goal))\n    return max_gift\n\n\ndef main(args):\n    # data = []\n    # data.append('...#')\n    # data.append('.#.#')\n    # data.append('.#73')\n    # data.append('8##.')\n    # data.append('....')\n    # K = 2\n    # field = [list(x) for x in data] #  data????????????????????????????????????????????????\n    # result = solve(field, K)\n    # print(result)\n\n    # data = []\n    # data.append('.##9###.')\n    # data.append('.#6.9..3')\n    # data.append('.#378.#2')\n    # data.append('....#9..')\n    # data.append('##4..6.#')\n    # data.append('4...5###')\n    # data.append('4##.#..1')\n    # data.append('5..2..#.')\n    K = 3\n    # field = [list(x) for x in data] #  data????????????????????????????????????????????????\n    # result = solve(field, K)\n    # print(result)\n\n\n    # H, W, K = map(int, input().split())\n    # data = [input().strip('\\n') for _ in range(H)]\n    # field = [list(x) for x in data] #  data????????????????????????????????????????????????\n    # result = solve(field, K)\n    # print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 9\n\nh, w, k = map(int,input().split())\nmaps = [list(\"#\" * (w + 2))]\nfor i in range(h):\n  maps.append(list(\"#\" + input() + \"#\"))\nmaps.append(list(\"#\" * (w + 2)))\n\n#スタートからそのマスまでに何度逆走する必要があるかのマップ\n#root_map = [[INF] * (w + 2) for i in range(h + 2)]\n\n#そのマスからゴールまでに何度逆走する必要があるかのマップ\nreverse_map = [[INF] * (w + 2) for i in range(h + 2)]\n\n#def root_search(x, y, score):\n#  if score < root_map[x][y]:\n#    root_map[x][y] = score\n#    if maps[x - 1][y] != \"#\":\n#      root_search(x - 1, y, score + 1)\n#    if maps[x + 1][y] != \"#\":\n#      root_search(x + 1, y, score)\n#    if maps[x][y - 1] != \"#\":\n#      root_search(x, y - 1, score + 1)\n#    if maps[x][y + 1] != \"#\":\n#      root_search(x, y + 1, score)\n#\ndef reverse_search(x, y, score):\n  if score < reverse_map[x][y]:\n    reverse_map[x][y] = score\n    if maps[x - 1][y] != \"#\":\n      reverse_search(x - 1, y, score)\n    if maps[x + 1][y] != \"#\":\n      reverse_search(x + 1, y, score + 1)\n    if maps[x][y - 1] != \"#\":\n      reverse_search(x, y - 1, score)\n    if maps[x][y + 1] != \"#\":\n      reverse_search(x, y + 1, score + 1)\n\ndef search(x, y, score, rest):\n  if rest < reverse_map[x][y]:\n    return 0\n\n  temp = maps[x][y]\n  if maps[x][y] in [str(i) for i in range(1,10)]:\n    score += int(maps[x][y])\n    maps[x][y] = \".\"\n  a = b = c = d = 0\n  if rest > 0 and maps[x - 1][y] != \"#\":\n    a = search(x - 1, y, score, rest - 1)\n  if maps[x + 1][y] != \"#\":\n    b = search(x + 1, y, score, rest)\n  if rest > 0 and maps[x][y - 1] != \"#\":\n    c = search(x, y - 1, score, rest - 1)\n  if maps[x][y + 1] != \"#\":\n    d = search(x, y + 1, score, rest)\n  ret = max(score, a, b, c, d)\n  maps[x][y] = temp\n  return ret\n\n#root_search(1, 1, 0)\nreverse_search(h, w, 0)\n\n\nprint(search(1,1,0,k))\n"
  }
]