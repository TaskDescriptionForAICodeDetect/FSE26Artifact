[
  {
    "language": "Scala",
    "code": "import Main.{calPattern, choiceAFromN}\n\nobject Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n  implicit val choiceMemo = Array.tabulate(10){i ⇒ Array.tabulate(i + 1){_ ⇒ None: Option[List[List[Boolean]]]}}\n  def choiceAFromN(a: Int, n: Int)(implicit memo: Array[Array[Option[List[List[Boolean]]]]]): List[List[Boolean]] = {\n    memo(n)(a) match {\n      case None if a == 0 ⇒ List(List.tabulate(n){_ ⇒ false}).also{it ⇒ memo(n)(a) = Some(it)}\n      case None if a == n ⇒ List(List.tabulate(n){_ ⇒ true}).also{it ⇒ memo(n)(a) = Some(it)}\n      case None ⇒ List(choiceAFromN(a - 1, n - 1)(memo).map{it ⇒ true::it}, choiceAFromN(a, n - 1)(memo).map{it ⇒ false::it}).flatten.also{it ⇒ memo(n)(a) = Some(it)}\n      case Some(r) ⇒ r\n    }\n  }\n  implicit val memo = Array.tabulate(390625){_ ⇒ None:Option[Long]}\n  def solve: Unit ={\n    val n = readLine.trim.toInt\n    if (n == 0) return\n    val m = readLine.trim.toInt\n    implicit val scoreGraph = Array.tabulate(n){_ ⇒ Array.tabulate(n){_ ⇒ 0}}\n    for (_ ← 0 until m){\n      val Array(x, y) = readLine.trim.split(' ').map(_.toInt)\n      scoreGraph(x - 1)(y - 1) = 1\n      scoreGraph(y - 1)(x - 1) = -1\n    }\n    implicit val winCount = scoreGraph.map{it ⇒ it.count(_ == 1)}\n    implicit val unknownIndices = scoreGraph.indices.map{i ⇒ (i + 1 until scoreGraph.length).filter{idx ⇒ scoreGraph(i)(idx) == 0}.toList}.toArray\n    memo.indices.foreach(it ⇒ memo(it) = None)\n    println(\n      calPattern(scoreGraph.length)\n    )\n    solve\n  }\n  solve\n  implicit class ExpandList(val value: Array[Int]){\n    def toIndex(digit: Int): Int = value.tail.foldLeft(0){case (a, b) ⇒ a * digit + b}\n  }\n  def calPattern(length:Int , team: Int = 0)(implicit winCount: Array[Int], unknownIndices: Array[List[Int]], memo: Array[Option[Long]]): Long = {\n    if (team == length) {\n      1L\n    }\n    else if (winCount.forall(it ⇒ it <= length / 2)){\n      memo(winCount.toIndex(length / 2 + 1)) match {\n        case None ⇒ {\n          val unknown = unknownIndices(team)\n          val win = winCount(team)\n          if (unknown.length + win < length / 2 || winCount.exists(it ⇒ it > length / 2)) {\n            0L\n          }\n          else {\n            var sum = 0L\n            for (pattern ← choiceAFromN(length / 2 - win, unknown.length)) {\n              unknown.zip(pattern).foreach{\n                case (i, false) ⇒ winCount(i) += 1\n                case (i, true) ⇒\n              }\n              sum += calPattern(length, team + 1)\n              unknown.zip(pattern).foreach{\n                case (i, false) ⇒ winCount(i) -= 1\n                case _ ⇒\n              }\n            }\n            memo(winCount.toIndex(length / 2 + 1)) = Some(sum)\n            sum\n          }\n        }\n        case Some(r) ⇒ r\n      }\n    }else 0L\n  }\n\n  implicit class Extenion[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n/*\nhttps://onlinejudge.u-aizu.ac.jp/challenges/sources/JAG/Prelim/2884\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, ans, table[9][9];\n\nint chack(){\n\tint res=1;\n\tfor(int i=0; i<n; i++){\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\ttmp += table[i][j];\n\t\t}\n\t\tif(tmp){\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nvoid solve(int x, int y){\n\tif(y < n-1) y++;\n\telse if(x < n-1){\n\t\ty=0;\n\t\tx++;\n\t} else {\n\t\tans += chack();\n\t\treturn;\n\t}\n\t\n\tif(y==0 && x>0){\n\t\tint tmp =0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\t//cout << table[x-1][i] << \" \";\n\t\t\ttmp +=table[x-1][i];\n\t\t}\n\t\t//cout << endl;\n\t\tif(tmp) return;\n\t}\n\t\n\n\tif(table[x][y] == 0 && x != y){\n\t\ttable[x][y] = 1;\n\t\ttable[y][x] = -1;\n\n\t\tsolve(x, y);\n\n\t\ttable[x][y] = -1;\n\t\ttable[y][x] = 1;\n\t\tsolve(x, y);\n\n\t\ttable[x][y] = table[y][x] = 0;\n\t} else solve(x, y);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfill(table[0], table[8], 0);\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\ttable[x][y] = 1;\n\t\t\ttable[y][x] = -1;\n\t\t}\n\t\tint x, y;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(table[i][j]==0 && i != j){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j-1;\n\t\t\t\t\tgoto AA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tAA:\n\n\t\tans = 0;\n\t\tsolve(x, y);\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint ans = 0;\nint n;\nint win[10];\nchar mp[10][10];\n\nvoid dfs(int a,int b){\n\n\t//SHOW2d(mp,n,n);\n\t\n\tif(a == n-1 && b == n-1){\n\t\tans++;\n\t\treturn;\n\t}\n\tif(b == n){\n\t\ta++;\n\t\tb = 0;\n\t}\n\t\n\tif(a == b || mp[a][b] != '-'){\n\t\tdfs(a,b+1);\n\t}\n\telse{\n\t\tif(win[a] < (n-1) / 2){\n\t\t\tmp[a][b] = 'o';\n\t\t\tmp[b][a] = 'x';\n\t\t\twin[a]++;\n\t\t\tdfs(a,b+1);\n\t\t\twin[a]--;\n\t\t\tmp[a][b] = '-';\n\t\t\tmp[b][a] = '-';\t\t\t\n\t\t}\n\t\tif(win[b] < (n-1) / 2){\n\t\t\tmp[a][b] = 'x';\n\t\t\tmp[b][a] = 'o';\n\t\t\twin[b]++;\n\t\t\tdfs(a,b+1);\n\t\t\twin[b]--;\n\t\t\tmp[a][b] = '-';\n\t\t\tmp[b][a] = '-';\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tans = 0;\n\tREP(i,10){\n\t\twin[i] = 0;\n\t\tREP(j,10){\n\t\t\tmp[i][j] = '-';\n\t\t}\n\t}\n\tint m;cin >> m;\n\tREP(i,m){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tmp[a][b] = 'o';\n\t\tmp[b][a] = 'x';\n\t\twin[a]++;\n\t}\n\t\n\tdfs(0,0);\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\t\n\twhile(cin >> n,n){\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\nint N, M, A[9][9];\n//---------------------------------------------------------------------------------------------------\nint check(int y) {\n    int win = 0;\n    rep(x, 0, N) if (A[y][x] == 1) win++;\n    return win == (N - 1) / 2;\n}\n//---------------------------------------------------------------------------------------------------\nint ans = 0;\nvoid dfs(int cu) {\n    int x = cu % N;\n    int y = cu / N;\n\n    if (x == 0 and 0 < y) {\n        if (y == N) {\n            if (check(y - 1)) ans++;\n            return;\n        } else {\n            if (!check(y - 1)) return;\n        }\n    }\n\n    if (x == y or 0 <= A[y][x]) dfs(cu + 1);\n    \n    A[y][x] = 1; A[x][y] = 0;\n    dfs(cu + 1);\n\n    A[y][x] = 0; A[x][y] = 1;\n    dfs(cu + 1);\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> N) {\n        if (N == 0) return;\n        cin >> M;\n        rep(i, 0, N) rep(j, 0, N) A[i][j] = -1;\n        rep(i, 0, M) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            A[a][b] = 1;\n            A[b][a] = 0;\n        }\n\n        ans = 0;\n        dfs(0);\n        printf(\"%d\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define rep(i,n) for(int i=0;i<((int)(n)); i++)\nint n;\nint dat[15][15];\n\nint win[2][15];\n\nint dfs(int i,int j){\n\t//printf(\"%d %d\\n\",i,j);\n\tif(j>=n){\n\t\t/*\n\t\trep(i,n){\n\t\t\tprintf(\"%d : %d %d\\n\",i,win[0][i],win[1][i]);\n\t\t}\n\t\t*/\n\t\trep(i,n){\n\t\t\tif(win[0][i]!=win[1][i])return 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tint ti,tj;\n\tti=i+1; tj=j;\n\tif(ti>=tj){\n\t\tti=0; tj=j+1;\n\t}\n\t//printf(\"%d %d\\n\",ti,tj);\n\tif(dat[i][j])return dfs(ti,tj);\n\tint res=0;\n\trep(t,2){\n\t\twin[t][i]++;\n\t\twin[1-t][j]++;\n\t\tif(win[t][i]*2<=n && win[1-t][j]*2<=n){\n\t\t\tres += dfs(ti,tj);\n\t\t}\n\t\twin[t][i]--;\n\t\twin[1-t][j]--;\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(;;){\n\t\tint m;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tmemset(dat,0,sizeof(dat));\n\t\tmemset(win,0,sizeof(win));\n\t\tif(n==0)break;\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b); a--; b--;\n\t\t\tdat[a][b]=dat[b][a]=1;\n\t\t\twin[0][a]++;\n\t\t\twin[1][b]++;\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(0,1));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll =long long;\n\nint n;\n\nbool valid(vector<vector<int>> &table){\n    for(int i=0;i<n;i++){\n        int psum=0;\n        int nsum=0;\n        for(int j=0;j<n;j++){\n            if(i==j) continue;\n            if(table[i][j]>0) psum++;\n            if(table[i][j]<0) nsum++;\n        }\n        if(psum>(n-1)/2 || nsum>(n-1)/2) return false;\n    }\n    return true;\n}\nint dfs(int i,int j,vector<vector<int>>& table){\n    if(!valid(table)) return 0;\n    if(i==n) return 1;\n    if(j==n) return dfs(i+1,0,table);\n    if(i==j || table[i][j]!=0) return dfs(i,j+1,table);\n    table[i][j]=1;\n    table[j][i]=-1;\n    int resw=dfs(i,j+1,table);\n    table[i][j]=-1;\n    table[j][i]=1;\n    int resl=dfs(i,j+1,table);\n    table[i][j]=table[j][i]=0;\n    return resw+resl;\n}\nint solve(){\n    vector<vector<int>> table(n,vector<int>(n,0));\n    int m;\n    cin>>m;\n    for(int i=0;i<m;i++){\n        int x,y; cin>>x>>y;\n        x--,y--;\n        table[x][y]=1;\n        table[y][x]=-1;\n    }\n    return dfs(0,0,table);\n}\nint main(){\n    while(cin>>n,n){\n        cout<<solve()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, m, ans, table[9][9];\n\nint chack(){\n\tfor(int i=0; i<n; i++){\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; j++) tmp += table[i][j];\n\t\tif(tmp) return 0;\n\t}\n\treturn 1;\n}\n\n\nvoid dfs(int x, int y){\n\tif(x < n-1) x++;\n\telse if(y < n-1){\n\t\tx=0;\n\t\ty++;\n\t} else{\n\t\tans += chack();\n\t\treturn;\n\t}\n\n\tif(x==0 && 0<y){\n\t\tint tmp =0;\n\t\tfor(int i=0; i<n; i++) tmp += table[y-1][i];\n\t\tif(tmp) return;\n\t}\n\n\tif(table[y][x] == 0 && y != x){\n\t\ttable[y][x] = 1;\n\t\ttable[x][y] = -1;\n\t\tdfs(y, x);\n\n\t\ttable[y][x] = -1;\n\t\ttable[x][y] = 1;\n\t\tdfs(y, x);\n\n\t\ttable[y][x] = table[x][y] = 0;\n\t} else dfs(x, y);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfill(table[0], table[8], 0);\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\ttable[x][y] = 1;\n\t\t\ttable[y][x] = -1;\n\t\t}\n\n\t\tans = 0;\n\t\tdfs(0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll n,m,h;\nll res=0;\nll g[10][10];\n\nbool check(ll i){\n  ll win=0,lose=0,rest=0;\n  rep(j,n)if(i!=j){\n    if(g[i][j]==1)win++;\n    if(g[i][j]==0)lose++;\n    if(g[i][j]==-1)rest++;\n  }\n  if(win<=h&&lose<=h)return true;\n  else return false;\n}\n\nvoid dfs(ll i,ll j){ // i<j\n  if(i==n-1&&j==n){\n    res++;\n    return ;\n  }\n  ll ni,nj;\n  if(j==n-1){\n    ni=i+1; nj=ni+1;\n  }else{\n    ni=i; nj=j+1;\n  }\n  if(g[i][j]!=-1){\n    if(check(i)&&check(j))dfs(ni,nj);\n  }else{\n    g[i][j]=0; g[j][i]=1;\n    if(check(i)&&check(j))dfs(ni,nj);\n    g[i][j]=1; g[j][i]=0;\n    if(check(i)&&check(j))dfs(ni,nj);\n    g[i][j]=-1; g[j][i]=-1;\n  }\n  return ;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    h=n/2;\n    cin>>m;\n    memset(g,-1,sizeof(g));\n\n    rep(i,m){\n      ll a,b;\n      cin>>a>>b;\n      a--;b--;\n      g[a][b]=1;\n      g[b][a]=0;\n    }\n\n    res=0;\n    dfs(0,1);\n    cout<<res<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include <map>\n#include <fstream>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <assert.h>\n#include <complex>\nusing namespace std;\n#define LONG_INF 10000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353LL\n#define seg_size 65536*4\n#define REP(i,n) for(long long i = 0;i < n;++i)\nint done[10][10] = {};\nint cnt[10] = {};\nint n;\nint solve(int now) {\n\tif (now == n + 1) return 1;\n\tvector<int> sizing;\n\tfor (int i = now + 1; i <= n; ++i) {\n\t\tif (done[now][i] == 0) {\n\t\t\tsizing.push_back(i);\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < (1 << sizing.size()); ++i) {\n\t\tint now_doing = i;\n\t\tfor (int q = 0;q < sizing.size(); ++q) {\n\t\t\tif (now_doing % 2 == 1) {\n\t\t\t\t//kati\n\t\t\t\tcnt[now]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//make\n\t\t\t\tcnt[sizing[q]]++;\n\t\t\t}\n\t\t\tnow_doing /= 2;\n\t\t}\n\t\tif (cnt[now] == n / 2) {\n\t\t\tans += solve(now + 1);\n\t\t}\n\t\tnow_doing = i;\n\t\tfor (int q = 0; q < sizing.size(); ++q) {\n\t\t\tif (now_doing % 2 == 1) {\n\t\t\t\t//kati\n\t\t\t\tcnt[now]--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//make\n\t\t\t\tcnt[sizing[q]]--;\n\t\t\t}\n\t\t\tnow_doing /= 2;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) return 0;\n\t\tint m;\n\t\tcin >> m;\n\t\tREP(i, 10) {\n\t\t\tREP(q, 10) {\n\t\t\t\tdone[i][q] = 0;\n\t\t\t}\n\t\t\tcnt[i] = 0;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tdone[a][b] = 1;\n\t\t\tdone[b][a] = 1;\n\t\t\tcnt[a]++;\n\t\t}\n\t\tcout << solve(1) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n\n#define int long long\n\nint n, m;\nbool f[10][10];\nint dfs(int x, int y, vector<int> v) {\n\tint ret = 0;\n\tint s = (n - 1) / 2;\n\tint nx = x, ny = y + 1;\n\tif (ny == n) {\n\t\tnx++;\n\t\tny = nx;\n\t}\n\tif (nx == n) {\n\t\tret = 1;\n\t\tfor (auto u : v)if (u != 0)ret = 0;\n\t}\n\telse if (x == y && x > 0 && v[x - 1] != 0) {\n\t\tret = 0;\n\t}\n\telse if (f[x][y]) {\n\t\tret = dfs(nx, ny, v);\n\t}\n\telse {\n\t\tif (v[x] < s && v[y] > -s) {\n\t\t\tvector<int> w = v;\n\t\t\tw[x]++, w[y]--;\n\t\t\tret += dfs(nx, ny, w);\n\t\t}\n\t\tif (v[x] > -s && v[y] < s) {\n\t\t\tvector<int> w = v;\n\t\t\tw[x]--, w[y]++;\n\t\t\tret += dfs(nx, ny, w);\n\t\t}\n\t}\n\t//cerr << x << \" \" << y << \" \";\n\t//for (auto u : v)cerr << \" \" << u;\n\t//cerr << \"  \" << ret << endl;\n\treturn ret;\n}\n\nsigned main() {\n\tfor (; cin >> n && n;) {\n\t\tcin >> m;\n\t\tmemset(f, 0, sizeof(f));\n\t\tvector<int> x(m), y(m);\n\t\trep(i, 0, m) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tx[i]--, y[i]--;\n\t\t}\n\n\t\tvector<int> v(n);\n\t\trep(i, 0, m) {\n\t\t\tv[x[i]]++;\n\t\t\tv[y[i]]--;\n\t\t\tf[x[i]][y[i]] = true;\n\t\t\tf[y[i]][x[i]] = true;\n\t\t}\n\t\trep(i, 0, n)f[i][i] = true;\n\n\t\tint ans = dfs(0, 0, v);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nint n,ans;\n//確定リスト\nint g[9][9];\n//現状\nint a[9][9];\n\n//上からy行目がまだ可能性あるか\nbool check(){\n    bool f=true;\n    rep(i,n){\n        int w=0,l=0;\n        rep(j,n){\n            if(i==j) continue;\n            if(a[i][j]==1) w++;\n            if(a[i][j]==-1)l++;\n        }\n        if(!(w<=(n-1)/2 and l<=(n-1)/2)) f=false;\n    }\n    return f;\n}\n\n//I,Jを試すよ\nvoid dfs(int I,int J){\n    if(I==n-1 and J==n-1) {\n        ans++;\n        // cout<<ans<<endl;\n        // rep(i,n){\n        //     rep(j,n){\n        //         if(i==j) cout<<\"x \";\n        //         else cout<<a[i][j]<<\" \";\n        //     }cout<<endl;\n        // }\n        return ;\n    }\n    int ni,nj;\n    if(I==J)ni=I+1,nj=0;\n    else    ni=I,nj=J+1;\n    if(I==J or a[I][J]!=0){\n        if(check()) dfs(ni,nj);\n        return ;\n    }\n    a[I][J]=1;a[J][I]=-1;\n    if(check())dfs(ni,nj);\n    a[I][J]=-1;a[J][I]=1;\n    if(check())dfs(ni,nj);\n    a[I][J]=0;a[J][I]=0;\n}\n\nvoid solve(){\n    rep(i,n)rep(j,n)g[i][j]=0;\n    rep(i,n)rep(j,n)a[i][j]=0;\n    ans=0;\n    int m;cin>>m;\n    rep(i,m){\n        int x,y;cin>>x>>y;\n        x--,y--;\n        g[x][y]=1;\n        g[y][x]=-1;\n        a[x][y]=1;\n        a[y][x]=-1;\n    }\n    // rep(i,n){\n    //     rep(j,n){\n    //         if(i==j) cout<<\"x \";\n    //         else cout<<g[i][j]<<\" \";\n    //     }cout<<endl;\n    // }\n    \n    dfs(1,0);\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    \n    while(true){\n        cin>>n;\n        if(n==0) return 0;\n        solve();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid print(vector<vector<int>>& t) {\n    for (auto x: t) {\n        for (auto y: x) {\n            cout << y << ' ';\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint n, m;\nint count (vector<vector<int>>& table, int i) {\n    int zero = 0;\n    int won = 0;\n    for (int j = 0; j < n; j++) {\n        if (table[i][j] == 0) zero++;\n        else if (table[i][j] == 1) won++;\n    }\n    int more = n / 2 - won;\n    // check\n    if (more < 0 || zero < more) return 0;\n    if (i == n - 1) return 1;\n    \n    if (more == 0) {\n        vector<vector<int>> new_table(table);\n        for (int j = 0; j < n; j++) {\n            if (new_table[i][j] != 0) continue;\n            new_table[i][j] = -1;\n            new_table[j][i] = 1;\n        }\n        return count(new_table, i + 1);\n    }\n    \n    int comb = (1 << more) - 1;\n    int ans = 0;\n    while (comb < 1 << zero) {\n        vector<vector<int>> new_table(table);\n        int xx = 0;\n        for (int j = 0; j < n; j++) {\n            if (new_table[i][j] != 0) continue;\n            if ((1 << xx) & comb) {\n                new_table[i][j] = 1;\n                new_table[j][i] = -1;\n            } else {\n                new_table[i][j] = -1;\n                new_table[j][i] = 1;\n            }\n            xx++;\n        }\n        ans += count(new_table, i + 1);\n\n        int x = comb & -comb, y = comb + x;\n        comb = ((comb & ~y) / x >> 1) | y;\n    }\n    return ans;\n}\n\nint main() {\n    while (1) {\n        cin >> n >> m;\n        if (n == 0) return 0;\n        vector<vector<int>> table(n, vector<int>(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    table[i][j] = -100;\n                } else {\n                    table[i][j] = 0;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            int a, b;\n            cin >> a >> b;\n            table[a - 1][b - 1] = 1;\n            table[b - 1][a - 1] = -1;\n        }\n        cout << count(table, 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,m,mp[9][9],win[9],border,cnt;\n\nint dfs(int x,int y) {\n  if( y >= n ) return ++cnt; \n  \n  int nx = x + 1, ny = y;\n  if( nx >= ny ) nx = 0, ++ny;\n\n  if( mp[x][y] != -1 ) return dfs(nx,ny);\n\n  int c[2] = {x,y};\n  rep(i,2) {\n    mp[c[i]][c[(i+1)%2]] = 0, mp[c[(i+1)%2]][c[i]] = 1, ++win[c[i]];\n    if( win[c[i]] <= border ) dfs(nx,ny);\n    --win[c[i]];\n  }\n\n  mp[x][y] = mp[y][x] = -1;\n  \n}\n\nint main() {\n  while( cin >> n, n ) {\n    memset(mp,-1,sizeof mp);\n    memset(win,0,sizeof win);\n    border = ( n * n - n ) / ( n * 2 );\n    cnt = 0;\n    cin >> m;\n    int x,y;\n    rep(i,m) {\n      cin >> x >> y;\n      --x, --y;\n      mp[x][y] = 1, mp[y][x] = 0, ++win[x];\n    }\n    rep(i,n) mp[i][i] = 0;\n    bool fail = false;\n    rep(i,n) if( win[i] > border ) { fail = true; break; }\n    if( !fail ) dfs(0,0);\n    cout << cnt << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 時間計算量の見積もりが出来ません\n#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint v[9][9], win[9], lose[9];\nint ans, n;\n\nvoid dfs(int i, int j){\n    while(i == j || v[i][j] != 0){\n        j++;\n        if(j == n)  i++, j = 0;\n        if(i == n){\n            ans++;\n            return;\n        }\n    }\n    if(win[i]+1 <= n/2 && lose[j]+1 <= n/2){\n        v[i][j] = 1; v[j][i] = -1;\n        win[i]++;   lose[j]++;\n        dfs(i, j);\n        win[i]--;   lose[j]--;\n        v[i][j] = v[j][i] = 0;\n    }\n    swap(i, j);\n    if(win[i]+1 <= n/2 && lose[j]+1 <= n/2){\n        v[i][j] = 1; v[j][i] = -1;\n        win[i]++;   lose[j]++;\n        dfs(j, i);\n        win[i]--;   lose[j]--;\n        v[i][j] = v[j][i] = 0;\n    }\n}\n\nint main(){\n    while(cin >> n, n){\n        memset(v, 0, sizeof(v));\n        memset(win, 0, sizeof(win));\n        memset(lose, 0, sizeof(lose));\n        int m;\n        cin >> m;\n        bool ini = true;\n        while(m-- > 0){\n            int x, y;\n            cin >> x >> y;\n            x--, y--;\n            v[x][y] = 1; v[y][x] = -1;\n            win[x]++, lose[y]++;\n            ini &= win[x] <= n/2 && lose[y] <= n/2;\n        }\n        if(!ini){\n            cout << 0 << endl;\n            continue;\n        }\n        ans = 0;\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n,m;\nint rem[10];\nvector<int> yet[10];\nint dp[10][400100];\nint x[100],y[100];\nint f[10][10];\nint fpow[20];\nint tmp[20];\nint k;\nint encode(int s){\n\tint res = 0;\n\tfor(int i=s;i<n;i++){\n\t\tres = res*5+tmp[i];\n\t}\n\treturn res;\n}\nvoid decode(int S){\n\tfor(int i=n-1;i>=0;i--){\n\t\ttmp[i]=S%5;\n\t\tS/=5;\n\t}\n}\nvoid print(){\n\tfor(int i=0;i<n;i++){\n\t\tcout << tmp[i] << ' ';\n\t}\n\tcout << endl;\n}\nbool solve(){\n\tscanf(\"%d\",&n);\n\tif(n==0)return false;\n\tscanf(\"%d\",&m);\n\tmemset(f,-1,sizeof(f));\n\tmemset(rem,0,sizeof(rem));\n\tmemset(dp,0,sizeof(dp));\n\tfor(int i=0;i<n;i++)yet[i].clear();\n\tk = (n-1)/2;\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\tx[i]--;y[i]--;\n\t\tf[x[i]][y[i]]=1;\n\t\tf[y[i]][x[i]]=0;\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcout << f[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tfor(int i=0;i<n;i++){\n\t\ttmp[i]=k;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(f[i][j]==1)tmp[i]--;\n\t\t}\n\t\tif(tmp[i]<0){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tcout << tmp[i] << endl;\n\t}*/\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(f[i][j]==-1)yet[i].pb(j);\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<yet[i].size();j++){\n\t\t\tcout << yet[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tdp[0][encode(0)]=1;\n\tfor(int i=0;i<n-1;i++){\n\t\tint yy = yet[i].size();\n\t\tfor(int j=0;j<fpow[n-i];j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\t//print();\n\t\t\tdecode(j);\n\t\t\tfor(int k=0;k<(1<<yy);k++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int l=0;l<yy;l++){\n\t\t\t\t\tif((k>>l)&1){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(tmp[yet[i][l]]==0){\n\t\t\t\t\t\t\tcnt=-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if(j==31)cout << j << ' ' << k << ' ' << cnt  << ' ' << tmp[i] << endl;\n\t\t\t\tif(cnt!=tmp[i])continue;\n\t\t\t\t//if(j==31)cout << j << ' ' << k << ' ' << cnt << endl;\n\t\t\t\t//cout << j << \" -> (\"  << k << ')'; \n\t\t\t\tfor(int l=0;l<yy;l++){\n\t\t\t\t\tif(!((k>>l)&1)){\n\t\t\t\t\t\ttmp[yet[i][l]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i+1][encode(i+1)]+=dp[i][j];\n\t\t\t\t//print();\n\t\t\t\tdecode(j);\n\t\t\t}\n\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n-1][0]);\n\treturn true;\n}\nint main(){\n\tfpow[0]=1;\n\tfor(int i=0;i<10;i++)fpow[i+1]=fpow[i]*5;\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<numeric>\n//#include<map>\nusing namespace std;\n\n#define R(i,s,n) for(int i=s;i<n;i++)\n#define D(i,n,s) for(int i=n-1;i>=s;i--)\ntypedef pair<int,int> P;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nconst int MAX_N = 9;\nconst int MAX_M = 36;\n\nint N,M;\nint match[MAX_N+1][MAX_N+1];  //-1...lose , 1...win\nint res;\nP xy;\n\nvoid solve(int [][MAX_N+1]);\nvoid printmap();\nbool check(int [][MAX_N+1],int);\n\nint main() {\n\n  while(cin>>N && N) {\n    memset(match,0,sizeof(match));\n    cin>>M;\n    R(i,0,M) { cin>>xy.first>>xy.second; match[xy.first][xy.second] = 1; match[xy.second][xy.first] = -1; }\n    bool flag;\n    int sum;\n    R(i,1,N+1) {\n      if(!check(match,i)) { cout<<\"0\"<<endl; goto exit; }\n    }\n    res = 0;\n    solve(match);\n    cout<<res<<endl;\n    exit: ;\n  }\n  return 0;\n}\n\nvoid solve(int map[][MAX_N+1]) {\n  //printmap();\n\n  R(i,1,N+1) {\n    R(j,i+1,N+1) {\n      if(map[i][j]==0) {\n        int tmp[MAX_N+1][MAX_N+1];\n        memset(tmp,0,sizeof(tmp));\n        R(i,0,N+1) R(j,0,N+1) tmp[i][j] = map[i][j];\n        tmp[i][j] = 1; tmp[j][i] = -1;  //勝利パターン\n        if(check(tmp,i) && check(tmp,j)) solve(tmp);\n        tmp[i][j] = -1; tmp[j][i] = 1;  //負けパターン\n        if(check(tmp,i) && check(tmp,j))  solve(tmp);\n        return ;\n      }\n    }\n  }\n  res++;\n  return ;\n}\n\nbool check(int map[][MAX_N+1],int i) {\n  int sum = 0;\n  int zero = 0;\n  R(j,1,N+1) {\n    sum+=map[i][j];\n    if(i!=j && map[i][j]==0) zero++;\n  }\n  if(abs(sum)-zero>0) return false;\n  return true;\n}\n\nvoid printmap() {\n  R(i,0,N+1) {\n    cout<<setw(2)<<match[i][0];\n    R(j,1,N+1) cout<<\" , \"<<setw(2)<<match[i][j];\n    cout<<endl;\n  }\n  cout<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e18\n#define int long long\n#define Rep(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) Rep(i, 0, n)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\n\nint n, match[10][10];\n\nint solve(int x, int y)\n{\n    if (x == n - 1 && y == n - 1)\n        return 1;\n    int nx = x, ny = y + 1;\n    if (ny == n)\n        nx++, ny = 0;\n    if (match[x][y] != 0)\n        return solve(nx, ny);\n    int xwin = 0, xlose = 0, ywin = 0, ylose = 0;\n    rep(i, n)\n    {\n        if (match[x][i] == 1)\n            xwin++;\n        if (match[x][i] == -1)\n            xlose++;\n    }\n    rep(i, n)\n    {\n        if (match[y][i] == 1)\n            ywin++;\n        if (match[y][i] == -1)\n            ylose++;\n    }\n    int res = 0;\n    if (xwin < n / 2 && ylose < n / 2)\n    {\n        match[x][y] = 1, match[y][x] = -1;\n        res += solve(nx, ny);\n        match[x][y] = match[y][x] = 0;\n    }\n    if (xlose < n / 2 && ywin < n / 2)\n    {\n        match[x][y] = -1, match[y][x] = 1;\n        res += solve(nx, ny);\n        match[x][y] = match[y][x] = 0;\n    }\n    return res;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (cin >> n, n)\n    {\n        rep(i, n) rep(j, n) match[i][j] = 0;\n        rep(i, n) match[i][i] = 2;\n        int m;\n        cin >> m;\n        rep(i, m)\n        {\n            int x, y;\n            cin >> x >> y;\n            x--, y--;\n            match[x][y] = 1;\n            match[y][x] = -1;\n        }\n        bool ok = true;\n        rep(i, n)\n        {\n            int win = 0, lose = 0;\n            rep(j, n)\n            {\n                if (match[i][j] == 1)\n                    win++;\n                if (match[i][j] == -1)\n                    lose++;\n            }\n            if (win > n / 2 || lose > n / 2)\n                ok = false;\n        }\n        cout << (ok ? solve(0, 0) : 0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass ScoreBoard{\npublic:\n    //  1: win\n    // -1: lose\n    // enum\n    vector<vector<int>> board;\n    vector<int> wincounts;\n    \n    ScoreBoard(int N){\n        board = vector<vector<int>>(N, vector<int>(N));\n        wincounts.resize(N);\n    }\n    void update(int x, int y){\n        board[x][y] = 1;\n        board[y][x] = -1;\n        wincounts[x]++;\n    }\n    void remove(int x, int y){\n        board[x][y] = board[y][x] = 0;\n        wincounts[x]--;\n    }\n    bool allok(){\n        for(int i=0; i<board.size(); i++)\n            if(wincounts[i] > (board.size()-1)/2)\n                return false;\n        return true;\n    }\n    bool ok(int x, int y){\n        return wincounts[x] < (board.size()-1)/2;\n    }\n    void view(){\n        cout << \"============\" << endl;\n        for(int x=0; x<board.size(); x++){\n            for(int y=0; y<board.size(); y++){\n                if(x == y)\n                    cout << \". \";\n                else\n                    cout << (board[x][y]==1) << \" \";\n            }\n            cout << endl;\n        }\n    }\n    int dfs(vector<int> &X, vector<int> &Y, int idx){\n        if(X.size() == idx){\n//            view();\n            return 1;\n        }\n        \n        int res = 0;\n        if(ok(X[idx], Y[idx])){\n            update(X[idx], Y[idx]);\n            res += dfs(X, Y, idx+1);\n            remove(X[idx], Y[idx]);\n        }\n        if(ok(Y[idx], X[idx])){\n            update(Y[idx], X[idx]);\n            res += dfs(X, Y, idx+1);\n            remove(Y[idx], X[idx]);\n        }\n        return res;\n    }\n};\n\n\nint main(){\n    int N, M;\n    while(cin >> N >> M, N|M){\n        auto sb = ScoreBoard(N);\n        \n        for(int i=0; i<M; i++){\n            int x, y; cin >> x >> y;\n            x--; y--;\n            sb.update(x, y);\n        }\n        \n        vector<int> X, Y;\n        for(int x=0; x<N; x++){\n            for(int y=x+1; y<N; y++){\n                if(sb.board[x][y] != 0)\n                    continue;\n                X.push_back(x);\n                Y.push_back(y);\n            }\n        }\n        if(sb.allok())\n            cout << sb.dfs(X, Y, 0) << endl;\n        else\n            cout << 0 << endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nconst int INF = 100000000;\n\n\n\nint GCD(int a, int b){\n    if(a < b) swap(a, b);\n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\nint ans;\nint n;\nint arr[10][10];\nint win[10];\nvoid rec(int a, int b){\n\n    if(a == n-1 && b == n-1){\n        ans++;\n        return;\n    }\n\n    if(b==n){\n        a++;\n        b = 0;\n    }\n\n    if(a == b || arr[a][b] != -1){\n        rec(a, b+1);\n    }\n    else{\n        if(win[a] < (n-1)/2){\n            arr[a][b] = 1;\n            arr[b][a] = 0;\n            win[a]++;\n            rec(a, b+1);\n            win[a]--;\n            arr[a][b]=-1;\n            arr[b][a]=-1;\n        }\n\n        if(win[b] < (n-1)/2){\n            arr[a][b] = 0;\n            arr[b][a] = 1;\n            win[b]++;\n            rec(a, b+1);\n            win[b]--;\n            arr[a][b]=-1;\n            arr[b][a] = -1;\n        }\n    }\n}\nvoid solve(){\n    int m; cin >> m;\n    ans = 0;\n\n    REP(i, 10) win[i]=0;\n    REP(i, 10) REP(j, 10) arr[i][j] = -1;\n    for(int i=0; i<m; ++i){\n        int x, y; cin >> x >>y;\n        x--; y--;\n        arr[x][y] = 1;\n        arr[y][x] = 0;\n        win[x]++;\n    }\n    for(int i=0; i<n; ++i){\n        if(win[i] > (n-1)/2){\n            cout << 0 << endl;\n            return;\n        }\n    }\n    rec(0,0);\n    cout << ans << endl;\n}\nint main() {\n    //cout << fixed << setprecision(15);\n\n\n    while(cin >> n){\n        if(n == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, m, ans, table[9][9];\n\nint chack(){\n\tfor(int i=0; i<n; i++){\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; j++) tmp += table[i][j];\n\t\tif(tmp)\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nvoid solve(int x, int y){\n\tif(y < n-1) y++;\n\telse if(x < n-1){\n\t\ty=0;\n\t\tx++;\n\t}else {\n\t\tans += chack();\n\t\treturn;\n\t}\n\t\n\tif(y==0 && 0<x){\n\t\tint tmp =0;\n\t\tfor(int i=0; i<n; i++) tmp +=table[x-1][i];\n\t\tif(tmp) return;\n\t}\t\n\n\tif(table[x][y] == 0 && x != y){\n\t\ttable[x][y] = 1;\n\t\ttable[y][x] = -1;\n\n\t\tsolve(x, y);\n\n\t\ttable[x][y] = -1;\n\t\ttable[y][x] = 1;\n\t\tsolve(x, y);\n\n\t\ttable[x][y] = table[y][x] = 0;\n\t} else solve(x, y);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfill(table[0], table[8], 0);\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\ttable[x][y] = 1;\n\t\t\ttable[y][x] = -1;\n\t\t}\n\n\t\tans = 0;\n\t\tsolve(0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\nll n,m;\nll mk[11][11],kt[11];\nll i, j, k,ans;\n\nvoid dnyk(ll a,ll b){\n    if(a==n){\n        ans++;\n        return;\n    }\n    if(b==n){\n        if(kt[a]==(n-1)/2){\n            dnyk(a + 1, a + 2);\n        }\n        return;\n    }\n    if(mk[a][b]!=2){\n        kt[a]++;\n        dnyk(a, b + 1);\n        kt[a]--;\n    }\n    if(mk[a][b]!=1){\n        kt[b]++;\n        dnyk(a, b + 1);\n        kt[b]--;\n    }\n}\n\nint main(){\n    \n    scanf(\"%lld\", &n);\n    while(n){\n        ans = 0;\n        fornum(i,0,11){\n            fornum(j,0,11){\n                mk[i][j] = 0;\n            }\n        }\n        scanf(\"%lld\", &m);\n        fornum(i,0,m){\n            ll a, b;\n            scanf(\"%lld%lld\", &a, &b);\n            mk[a-1][b-1] = 1;\n            mk[b-1][a-1] = 2;\n        }\n        dnyk(0, 1);\n        printf(\"%lld\\n\", ans);\n        scanf(\"%lld\", &n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\n\nint win[10][10];\n\nint dfs(int s,int t){ // s:チーム目のt:試合目を見ている\n\tif(s==t)return dfs(s,t+1);\n\tif(s==n-1&&t==n)return 1;\n\tif(t==n)return dfs(s+1,0);\n\tif(win[s][t]!=0)return dfs(s,t+1);\n\tint res=0;\n\tint num=0,cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(s==i)continue;\n\t\tif(win[s][i]==0)cnt++;\n\t\telse num+=win[s][i];\n\t}\n\tif(abs(num)>cnt)return 0;\n\tif(abs(num)==cnt){\n\t\tqueue<int> q;\n\t\tif(num==cnt){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s==i)continue;\n\t\t\t\tif(win[s][i]==0){\n\t\t\t\t\twin[s][i]=-1;\n\t\t\t\t\twin[i][s]=1;\n\t\t\t\t\tq.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s==i)continue;\n\t\t\t\tif(win[s][i]==0){\n\t\t\t\t\twin[s][i]=1;\n\t\t\t\t\twin[i][s]=-1;\n\t\t\t\t\tq.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=1;\n\t\tfor(int i=s+1;i<n;i++){\n\t\t\tint p=0,pp=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(win[i][j]==0)p++;\n\t\t\t\telse pp+=win[i][j];\n\t\t\t}\n\t\t\tif(abs(pp)>p)ok=0;\n\t\t\tif(!ok)break;\n\t\t}\n\t\tif(ok)res=dfs(s+1,0);\n\t\telse{\n\t\t\twhile(q.size()){\n\t\t\t\tint qq=q.front(); q.pop();\n\t\t\t\twin[s][qq]=win[qq][s]=0;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\twhile(q.size()){\n\t\t\tint qq=q.front(); q.pop();\n\t\t\twin[s][qq]=win[qq][s]=0;\n\t\t}\n\t}\n\telse{\n\t\twin[s][t]=1;\n\t\twin[t][s]=-1;\n\t\tres+=dfs(s,t+1);\n\t\twin[s][t]=win[t][s]=0;\n\t\twin[s][t]=-1;\n\t\twin[t][s]=1;\n\t\tres+=dfs(s,t+1);\n\t\twin[s][t]=win[t][s]=0;\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tint m; cin >> m;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\twin[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\twin[x][y]=1;\n\t\t\twin[y][x]=-1;\n\t\t}\n\t\tcout << dfs(0,0) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\n\n\n\n\nint maxg,ans,n,t[10][10];\n\nint getxy(int g){\n\tint x=1,y;\n\tint plus = n-1;\n\tfor(int i = n-1;plus >= 1;x++){\n\t\tplus--;\n\t\tif(g <= i){\n\t\t\ty = n - (i - g);\n\t\t\tbreak;\n\t\t}\n\t\ti += plus;\n\t}\n\n\treturn (10*x+y);\n}\n\nvoid solve(int g,int l[10],int w[10]){\n\tint xy = getxy(g);\n\tint x = xy / 10,y = xy % 10;\n\n\tint eq = (n-1)/2;\n\tif(g == maxg){ //finish solve\n\t\tif(t[x][y] == 1){  //win\n\t\t\tif(w[x] == eq && l[y] == eq){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}else if(t[x][y] == -1){\n\t\t\tif(w[y] == eq && l[x] == eq){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}else{\n\t\t\tif(w[x]+1 == eq && l[y]+1 == eq){\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tif(w[y]+1 == eq && l[x]+1 == eq){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}else if(t[x][y] == 0){\n\t\tif(w[x]+1 <= eq && l[y]+1 <= eq){\n\t\t\tw[x]++; l[y]++;\n\t\t\tsolve(g+1,l,w);\n\t\t\tw[x]--; l[y]--;\n\t\t}\n\t\tif(w[y]+1 <= eq && l[x]+1 <= eq){\n\t\t\tw[y]++; l[x]++;\n\t\t\tsolve(g+1,l,w);\n\t\t\tw[y]--; l[x]--;\n\t\t}\n\t}else if(t[x][y] == -1){\n\t\tif(w[y] <= eq && l[x] <= eq){\n\t\t\tsolve(g+1,l,w);\n\t\t}\n\t}else{\n\t\tif(w[x] <= eq && l[y] <= eq){\n\t\t\tsolve(g+1,l,w);\n\t\t}\n\t}\n\treturn;\n}\n\n\nint d[40][2];\nint l[10],w[10],g;\n\nint main(){\n\tint m;\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tcin >> m;\n\t\tmaxg = 0;\n\t\tans = 0;\n\t\tfor(int i = n-1;i >= 1;i--){\n\t\t\tmaxg += i;\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tl[i] = 0;\n\t\t\tw[i] = 0;\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tt[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tw[x]++;\n\t\t\tl[y]++;\n\t\t\tt[x][y] = 1;\n\t\t\tt[y][x] = -1;\n\t\t}\n\t\tsolve(1,l,w);\n\t\tcout << ans << endl;\n\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define _for(i,j,N) for(int i = (j);i < (N);i++)\n#define _rep(i,j,N) for(int i = (j);i <= (N);i++)\n#define _dec(i,N,j) for(int i = (N-1);i >= (j);i--)\n#define _rec(i,N,j) for(int i = (N);i >=(j);i--)\n#define ALL(x) x.begin(),x.end()\n#define MEM(a,n) memset(a,n,sizeof(a))\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\nint get_int(){int x;scanf(\"%d\",&x);return x;}\nLL get_ll(){LL x;scanf(\"%lld\",&x);return x;}\ndouble get_db(){double x;scanf(\"%lf\",&x);return x;}\n\ntemplate<typename T> int chmin(T &a,T b){if(a > b){a = b;return 1;}else return 0;}\ntemplate<typename T> int chmax(T &a,T b){if(a < b){a = b;return 1;}else return 0;}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {_for(i,0,v.size()) os << v[i] << \" \";return os;}\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& v){for(auto a:v) os << a <<\" \";return os;}\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& v){os << v.fst <<\" \"<<v.scd << \" \";return os;}\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const map<T1,T2>& v){for(auto a:v) cout << a << endl;return os;}\n\nstatic const int dx[8] = { -1,  0, 1, 0,  1, -1,  1, -1};\nstatic const int dy[8] = {0,  1, 0,  -1,  1, -1, -1,  1};\nconst double pi  = acos(-1.0);\nconst double eps = 1e-8;\n//const LL  INF  = 0x3f3f3f3f3f3f3f3f;\nconst int inf  = 0x3f3f3f3f;\n\nint N,M;\nint maxd;\nint ans;\nint G[10][10];\nvector<int> st;\nvector<int> rest;\nvector<pii> match;\n\n\nbool get_input(){\n    scanf(\"%d\",&N);\n    if(N == 0) return false;\n    MEM(G,0);\n    scanf(\"%d\",&M);\n    st.clear();\n    rest.clear();\n    match.clear();\n    _for(i,0,N){\n        rest.PB(N-1);\n        st.PB(0);\n    }\n\n    _for(i,0,M){\n        int x,y;\n        scanf(\"%d %d\",&x,&y);\n        x--;y--;\n        G[x][y] = (G[y][x] = 1);\n        rest[x]--;rest[y]--;\n        st[x]++;st[y]--;\n    }\n    _for(i,0,N){\n        _for(j,i+1,N){\n            if(!G[i][j]){\n                match.PB(MP(i,j));\n            }\n        }\n    }\n    maxd = match.size();\n    ans = 0;\n\n    return true;\n}\n\nbool ok(int a){\n    int k = abs(st[a]);\n    if(rest[a] < k) return false;\n    return true;\n}\n\nbool can(){\n    _for(i,0,N){ if(st[i]) return false;}\n    return true;\n\n}\n\nvoid searching(int d){\n    //cout << rest <<endl;\n    //cout << st << endl;\n    if(d == maxd){\n        if(can())++ans;\n        return;\n    }\n\n    pii m = match[d];\n    int a = m.fst;\n    int b = m.scd;\n    rest[a]--;rest[b]--;\n    st[a]++;st[b]--;\n    if(ok(a) && ok(b)){\n        searching(d+1);\n    }\n\n    st[a]-=2;st[b]+=2;\n    if(ok(a) && ok(b)){\n        searching(d+1);\n    }\n    rest[a]++; rest[b]++;\n    st[a]++;st[b]--;\n}\n\n\nint main()\n{\n    //freopen(\"out.txt\",\"w\",stdout);\n    while(get_input()){\n        searching(0);\n        cout << ans << endl;\n\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nvoid func(vector<vector<int>>&win, vector<int>&sum, int a, int b) {\n\t//cout << \"a b \" << a << \" \" << b << endl;\n\t//cout << sum[a] << endl;\n\tif (a == N - 1) {\n\t\t//for (auto i : sum)cout << i << endl;\n\t\t//cout << endl;\n\t\tif (!sum[a])K++;\n\t\treturn;\n\t}\n\tif (win[a][b] >= 0) {\n\t\tint bef = win[a][b];\n\t\twin[a][b] = 1, win[b][a] = -1;\n\t\tsum[a]++;\n\t\tsum[b]--;\n\t\tif (b == N - 1) {\n\t\t\tif (!sum[a]) {\n\t\t\t\tfunc(win, sum, a + 1, a + 2);\n\t\t\t}\n\t\t\twin[a][b] = bef, win[b][a] = -bef;\n\t\t\tsum[a]--;\n\t\t\tsum[b]++;\n\t\t}\n\t\telse {\n\t\t\tfunc(win, sum, a, b + 1);\n\t\t\twin[a][b] = bef, win[b][a] = -bef;\n\t\t\tsum[a]--;\n\t\t\tsum[b]++;\n\t\t}\n\t}\n\tif (win[a][b] <= 0) {\n\t\tint bef = win[a][b];\n\t\twin[a][b] = -1, win[b][a] = 1;\n\t\tsum[a]--;\n\t\tsum[b]++;\n\t\tif (b == N - 1) {\n\t\t\tif (!sum[a]) {\n\t\t\t\tfunc(win, sum, a + 1, a + 2);\n\t\t\t}\n\t\t\twin[a][b] = bef, win[b][a] = -bef;\n\t\t\tsum[a]++;\n\t\t\tsum[b]--;\n\t\t}\n\t\telse {\n\t\t\tfunc(win, sum, a, b + 1);\n\t\t\twin[a][b] = bef, win[b][a] = -bef;\n\t\t\tsum[a]++;\n\t\t\tsum[b]--;\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> N, N) {\n\t\tK = 0;\n\t\tcin >> M;\n\t\tvector<vector<int>>win(N, vector<int>(N));\n\t\tvector<int>sum(N);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> L >> R;\n\t\t\tL--, R--;\n\t\t\twin[L][R] = 1;\n\t\t\twin[R][L] = -1;\n\t\t}\n\t\tfunc(win, sum, 0, 1);\n\t\tcout << K << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define itn int\nusing uint = unsigned int;\nusing lint = long long int;\nusing llint = long long int;\nusing ulint = unsigned long long int;\nusing ullint = ulint;\n\n#define DEBUG\n#ifdef DEBUG\n#define dump(x) cout << \"[*]\" #x \":\" << x << endl\n#define debug(x) x\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\nint n, m;\nint res[10][10];\nint dp[50][2000000];\nint beki[10];\n\nint add(int s, int i)\n{\n  return s + beki[i];\n}\n\nint get(int s, int i)\n{\n  s /= beki[i];\n  return s % 5;\n}\n\n\n\nint main() {\n\n  int q = 1;\n  for(int i = 0; i < 10; i++) beki[i] = q, q *= 5;\n\n  while (true) {\n    cin >> n;\n    if(n == 0) break;\n    cin >> m;\n\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\t       res[i][j] = 0;\n      }\n    }\n    int u, v;\n    int is = 0;\n    for(int i = 0; i < m; i++){\n      cin >> u >> v;\n      u--, v--;\n      res[u][v] = 1;\n      res[v][u] = -1;\n      is = add(is, u);\n    }\n    int S = beki[n];\n    int N = n*(n-1)/2;\n    int X = (n-1)/2;\n\n    for(int x = 0; x <= N; x++){\n      for(int k = 0; k < S; k++){\n\t       dp[x][k] = 0;\n      }\n    }\n    dp[0][is] = 1;\n\n\n    bool flag = false;\n    for(int i = 0; i < n; i++){\n      if(get(is, i) > X){\n      \tcout << 0 << endl;\n      \tflag = true;\n      }\n    }\n    if(flag) continue;\n\n    int x = -1;\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n    \tif(i >= j) continue;\n    \tx++;\n    \tif(res[i][j]){\n        for(int s = 0; s < S; s++) dp[x+1][s] = dp[x][s];\n        continue;\n      }\n        \tfor(int s = 0; s < S; s++){\n        \t  if(get(s, i) < X){\n        \t    dp[x+1][add(s, i)] += dp[x][s];\n        \t  }\n        \t  if(get(s, j) < X){\n        \t    dp[x+1][add(s, j)] += dp[x][s];\n        \t  }\n        \t}\n      }\n    }\n\n    int as = 0;\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < X; j++){\n\tas = add(as, i);\n      }\n    }\n    cout << dp[N][as] << endl;\n\n    break;\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, m, ans, table[9][9];\n\nint chack(){\n\tfor(int i=0; i<n; i++){\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; j++) tmp += table[i][j];\n\t\tif(tmp) return 0;\n\t}\n\treturn 1;\n}\n\n\nvoid dfs(int y, int x){\n\tif(x < n-1) x++;\n\telse if(y < n-1){\n\t\tx=0;\n\t\ty++;\n\t} else{\n\t\tans += chack();\n\t\treturn;\n\t}\n\n\tif(x==0 && 0<y){\n\t\tint tmp =0;\n\t\tfor(int i=0; i<n; i++) tmp += table[y-1][i];\n\t\tif(tmp) return;\n\t}\n\n\tif(table[y][x] == 0 && y != x){\n\t\ttable[y][x] = 1;\n\t\ttable[x][y] = -1;\n\t\tdfs(y, x);\n\n\t\ttable[y][x] = -1;\n\t\ttable[x][y] = 1;\n\t\tdfs(y, x);\n\n\t\ttable[y][x] = table[x][y] = 0;\n\t} else dfs(y, x);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfill(table[0], table[8], 0);\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\ttable[x][y] = 1;\n\t\t\ttable[y][x] = -1;\n\t\t}\n\n\t\tans = 0;\n\t\tdfs(0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<31)-1;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\n//int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint n;\nint m;\nint xy[11][11];\nint hwl[11];\nint re[11];\nll ans=0;\nvector< pair<int,int> >PP;\n\n\nvoid check(int k){\n\tif(k==PP.size()){\n\t\tans++;\n\t\treturn;\n\t}\n\tpair<int,int> pp=PP[k];\n\t//cout<<k<<\" \"<<pp.first<<\"   \"<<pp.second<<endl;\n\txy[pp.first][pp.second]=1;\n\txy[pp.second][pp.first]=-1;\n\tre[pp.first]--;\n\tre[pp.second]--;\n\thwl[pp.first]++;\n\thwl[pp.second]--;\n\tif(abs(hwl[pp.first])<=re[pp.first]&&abs(hwl[pp.second])<=re[pp.second]){/*cout<<k<<\" \"<<1<<endl;*/check(k+1);}\n\t//else cout<<\"out1\"<<endl;\n\tpp=PP[k];\n\txy[pp.first][pp.second]=-1;\n\txy[pp.second][pp.first]=1;\n\t\n\thwl[pp.first]-=2;\n\thwl[pp.second]+=2;\n\tif(abs(hwl[pp.first])<=re[pp.first]&&abs(hwl[pp.second])<=re[pp.second]){/*cout<<k<<\" \"<<2<<endl;*/check(k+1);}\n\t//else cout<<\"out2\"<<endl;\n\tpp=PP[k];\n\txy[pp.first][pp.second]=0;\n\txy[pp.second][pp.first]=0;\n\tre[pp.first]++;\n\tre[pp.second]++;\n\thwl[pp.first]++;\n\thwl[pp.second]--;\n\treturn;\n}\n\t\nint main(){\n\twhile(1){\n\t\tans=0;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tcin>>m;\n\t\tPP.clear();\n\t\tfor(int i=0;i<11;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\txy[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<11;i++){\n\t\t\thwl[i]=0;\n\t\t}\n\t\tfor(int i=0;i<11;i++){\n\t\t\tre[i]=0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint t,s;\n\t\t\tcin>>t>>s;\n\t\t\txy[t][s]=1,xy[s][t]=-1;\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(i!=j){\n\t\t\t\t\thwl[i]+=xy[i][j];\n\t\t\t\t\tif(xy[i][j]==0){\n\t\t\t\t\t\tif(i>j){\n\t\t\t\t\t\tPP.push_back(pair<int,int>(i,j));\n\t\t\t\t\t\tre[i]++;\n\t\t\t\t\t\tre[j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t/*for(int i=0;i<PP.size();i++){\n\t\t\tcout<<PP[i].first<<\" \"<<PP[i].second<<endl;\n\t\t}*/\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(abs(hwl[i])>re[i]){\n\t\t\t\tgoto A;\n\t\t\t}\n\t\t}\n\t\tcheck(0);\n\t\tA:\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t\n\n\t\t\t\t\t\n\t\t\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nint n;\nint m;\nint x, y;\nint t[9][9];\n\nbool check(int y) {\n\tint x, cnt = 0;\n\trep(x, n) {\n\t\tcnt += t[y][x];\n\t}\n\treturn cnt == 0;\n}\n\nvoid printT() {\n\tint i, j;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tcout << t[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint dfs(int y, int x) {\n\t//cout << y << \", \" << x << endl;\n\t//printT();\n\t\n\tif (y == n) {\n\t\treturn 1;\n\t}\n\tif (x == n) {\n\t\tif (!check(y)) return 0;\n\t\treturn dfs(y + 1, 0);\n\t}\n\tif (y == x) {\n\t\treturn dfs(y, x + 1);\n\t}\n\t\n\tif (t[y][x] != 0) {\n\t\treturn dfs(y, x + 1);\n\t}\n\t\n\tt[y][x] = 1;\n\tt[x][y] = -1;\n\tint res1 = dfs(y, x + 1);\n\t\n\tt[y][x] = -1;\n\tt[x][y] = 1;\n\tint res2 = dfs(y, x + 1);\n\t\n\tt[y][x] = 0;\n\tt[x][y] = 0;\n\treturn res1 + res2;\n}\n\nint main() {\n\tint i, j;\n\t\n\twhile (cin >> n) {\n\t\tif (!n) break;\n\t\t\n\t\trep(i, n) rep(j, n) t[i][j] = 0;\n\t\t\n\t\tcin >> m;\n\t\trep(i, m) {\n\t\t\tcin >> x >> y;\n\t\t\tx--; y--;\n\t\t\tt[x][y] = 1;\n\t\t\tt[y][x] = -1;\n\t\t}\n\t\tint res = dfs(0, 0);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, m, ans, table[9][9];\n\nint chack(){\n\tint res=1;\n\tfor(int i=0; i<n; i++){\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\ttmp += table[i][j];\n\t\t}\n\t\tif(tmp){\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nvoid solve(int x, int y){\n\tif(y < n-1) y++;\n\telse if(x < n-1){\n\t\ty=0;\n\t\tx++;\n\t} else {\n\t\tans += chack();\n\t\treturn;\n\t}\n\t\n\tif(y==0 && 0<x){\n\t\tint tmp =0;\n\t\tfor(int i=0; i<n; i++) tmp +=table[x-1][i];\n\t\tif(tmp) return;\n\t}\n\t\n\n\tif(table[x][y] == 0 && x != y){\n\t\ttable[x][y] = 1;\n\t\ttable[y][x] = -1;\n\n\t\tsolve(x, y);\n\n\t\ttable[x][y] = -1;\n\t\ttable[y][x] = 1;\n\t\tsolve(x, y);\n\n\t\ttable[x][y] = table[y][x] = 0;\n\t} else solve(x, y);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfill(table[0], table[8], 0);\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\ttable[x][y] = 1;\n\t\t\ttable[y][x] = -1;\n\t\t}\n\n\t\tint x, y;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(table[i][j]==0 && i != j){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j-1;\n\t\t\t\t\tgoto AA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tAA:\n\n\t\tans = 0;\n\t\tsolve(x, y);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nbool mark; \nint n,m,mp[15][15],win[15],lose[15],k,x,y;\n\nll dfs(int x,int y)\n{\n\t//printf(\"%d %d !!\\n\",x,y);\n\tbool markk=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(win[i]<(n/2))\t{markk=0;break;}\n\tif(markk)\treturn 1;\n\tll temp=0;\n\tfor(int i=x;i<=n;i++) \n\t{\n\t\tfor(int j=(i==x?y:1);j<=n;j++) \n\t\t{\n\t\t\tif(mp[i][j]!=0||i==j)\tcontinue;\n\t\t\tif((win[i]<(n/2)&&win[i]>=0)&&(lose[j]<(n/2)&&lose[j]>=0)) \n\t\t\t{\n\t\t\t\tmp[i][j]=1;\n\t\t\t\tmp[j][i]=-1;\n\t\t\t\twin[i]++;\n\t\t\t\tlose[j]++;\n\t\t\t\ttemp=temp+dfs(i,j);\n\t\t\t\tmp[i][j]=0;\n\t\t\t\tmp[j][i]=0;\n\t\t\t\tlose[j]--;\n\t\t\t\twin[i]--;\n\t\t\t\tmarkk=1;\n\t\t\t}\n\t\t\tif((win[j]<(n/2)&&lose[i]>=0)&&(lose[i]<(n/2)&&win[j]>=0)) \n\t\t\t{\n\t\t\t\tmp[i][j]=-1;\n\t\t\t\tmp[j][i]=1;\n\t\t\t\tlose[i]++;\n\t\t\t\twin[j]++;\n\t\t\t\ttemp=temp+dfs(i,j);\n\t\t\t\tmp[i][j]=0; \n\t\t\t\tmp[j][i]=0;\n\t\t\t\twin[j]--;\n\t\t\t\tlose[i]--;\n\t\t\t\tmarkk=1;\n\t\t\t}\n\t\t\tif(markk)\tbreak;\n\t\t}\n\t\tif(markk)\tbreak;\n\t}\n\treturn temp;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tmark=0; \n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<=15;i++)\n\t\t\tfor(int j=0;j<=15;j++)\n\t\t\t\tmp[i][j]=0;\n\t\tmemset(lose,0,sizeof(lose));\n\t\tmemset(win,0,sizeof(win));\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tmp[x][y]=1;\n\t\t\tmp[y][x]=-1;\n\t\t\twin[x]+=1;\n\t\t\tlose[y]+=1;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(win[i]>(n/2)||lose[i]>(n/2))\n\t\t\t{\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tmark=1;\n\t\t\t}\n\t\t} \n\t\t\tif(mark) continue;//特判剪枝 \n\t\telse printf(\"%d\\n\",dfs(1,1));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nenum class Result\n{\n    UNKNOWN,\n    LOSE,\n    WIN,\n};\n\nbool setResult(vector<vector<Result> >& result, vector<pair<int, int> >& cnt, int x, int y)\n{\n    result[x][y] = Result::WIN;\n    result[y][x] = Result::LOSE;\n    ++ cnt[x].first;\n    ++ cnt[y].second;\n    int n = result.size();\n    return cnt[x].first <= n / 2 && cnt[y].second <= n / 2;\n}\n\nvoid resetResult(vector<vector<Result> >& result, vector<pair<int, int> >& cnt, int x, int y)\n{\n    result[x][y] = Result::UNKNOWN;\n    result[y][x] = Result::UNKNOWN;\n    -- cnt[x].first;\n    -- cnt[y].second;\n}\n\nint solve(vector<vector<Result> >& result, vector<pair<int, int> >& cnt, int k)\n{\n    int n = result.size();\n    if(k == n * n)\n        return 1;\n\n    int x = k / n;\n    int y = k % n;\n    if(x == y || result[x][y] != Result::UNKNOWN)\n        return solve(result, cnt, k+1);\n\n    int ans = 0;\n    for(int i=0; i<2; ++i){\n        if(setResult(result, cnt, x, y))\n            ans += solve(result, cnt, k+1);\n        resetResult(result, cnt, x, y);\n        swap(x, y);\n    }\n    return ans;\n}\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Result> > result(n, vector<Result>(n, Result::UNKNOWN));\n        vector<pair<int, int> > cnt(n);\n        bool ng = false;\n        for(int i=0; i<m; ++i){\n            int x, y;\n            cin >> x >> y;\n            -- x;\n            -- y;\n            result[x][y] = Result::WIN;\n            result[y][x] = Result::LOSE;\n            ++ cnt[x].first;\n            ++ cnt[y].second;\n            if(cnt[x].first > n / 2 || cnt[y].second > n / 2)\n                ng = true;\n        }\n\n        if(ng)\n            cout << 0 << endl;\n        else\n            cout << solve(result, cnt, 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint f[9][9];\nint v[9][9];\n\nbool ok() {\n\tfor (int i = 0; i < n; i++) {\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcnt += v[i][j];\n\t\t}\n\t\tif (cnt > (n >> 1)) return false;\n\t}\n\tfor (int j = 0; j < n; j++) {\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt += v[i][j];\n\t\t}\n\t\tif (cnt > (n >> 1)) return false;\n\t}\n\treturn true;\n}\n\nint dfs(int x, int y) {\n\tif (x == n) return 1;\n\tif (y == n) return dfs(x + 1, x + 2);\n\tif (f[x][y]) {\n\t\treturn ok() ? dfs(x, y + 1) : 0;\n\t}\n\tint res = 0;\n\tv[y][x] = 1;\n\tif (ok()) res += dfs(x, y + 1);\n\tv[x][y] = 1; v[y][x] = 0;\n\tif (ok()) res += dfs(x, y + 1);\n\tv[x][y] = v[y][x] = 0;\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tf[i][j] = v[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y; --x, --y;\n\t\t\tf[x][y] = f[y][x] = 1;\n\t\t\tv[x][y] = 1;\n\t\t}\n\t\tcout << dfs(0, 1) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<vector<bool>> v(n, vector<bool>(n));\n        int m; cin >> m;\n        vector<int> win(n), lose(n);\n        for(int i = 0; i < m; ++i) {\n            int x, y; cin >> x >> y;\n            v[x - 1][y - 1] = v[y - 1][x - 1] = true;\n            win[x - 1] += 1;\n            lose[y - 1] += 1;\n        }\n\n        function<int(int, int)> dfs = [&] (int y, int x) {\n            for(int i = 0; i < n; ++i) {\n                if(win[i] > (n - 1) / 2 || lose[i] > (n - 1) / 2) {\n                    return 0;\n                }\n            }\n            if(y == n) {\n                return 1;\n            }\n            if(y == x || v[y][x]) {\n                if(x == n - 1) return dfs(y + 1, 0);\n                else           return dfs(y, x + 1);\n            } else {\n                int res = 0;\n\n                win[y] += 1, lose[x] += 1;\n                v[y][x] = v[x][y] = true;\n                if(x == n - 1) res = dfs(y + 1, 0);\n                else           res = dfs(y, x + 1);\n                v[y][x] = v[x][y] = false;\n                win[y] -= 1, lose[x] -= 1;\n\n                lose[y] += 1, win[x] += 1;\n                v[y][x] = v[x][y] = true;\n                if(x == n - 1) res += dfs(y + 1, 0);\n                else           res += dfs(y, x + 1);\n                v[y][x] = v[x][y] = false;\n                lose[y] -= 1, win[x] -= 1;\n\n                return res;\n            }\n        };\n\n        cout << dfs(0, 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define inf (int)1e9+7\n#define eb emplace_back\n\nint N, M;\nint next_combination(int sub) {\n    int x = sub & -sub, y = sub + x;\n    return (((sub & ~y) / x) >> 1) | y;\n}\nint dfs(int dep, int table[9][9]) {\n    //cout << endl;\n    if (dep == N) {\n        //cout << endl; rep(i, N) {rep(j, N) cout << table[i][j] << \" \"; cout << endl;}\n        return 1;\n    }\n    int w = 0;\n    rep(i, N) w += (table[dep][i] == 1);\n    int rw = N / 2 - w;\n    //cout << dep << \" \" << rw << endl;\n    if (rw < 0) return 0;\n    if (rw == 0) {\n        rep(i, N) {\n            if (table[dep][i]) continue;\n            if (dep == i) continue;\n            table[dep][i] = -1;\n            table[i][dep] = 1;\n        }\n        return dfs(dep + 1, table);\n    }\n    int res = 0;\n    int table2[9][9];\n    rep(i, 9) rep(j, 9) table2[i][j] = table[i][j];\n    for (int bit = (1 << rw) - 1; bit < (1 << N); bit = next_combination(bit)) {\n        //新しく追加するbit\n        //すでに入ってたら切る\n        if (bit & (1 << dep)) continue; //自分のとこは入らない\n        rep(i, 9) rep(j, 9) table[i][j] = table2[i][j];\n        int flg = 0;\n        rep(i, N) if (bit & (1 << i) && table[dep][i]) {flg = 1; break;}\n        if (flg) continue;\n        rep(i, N) {\n            if (table[dep][i]) continue;\n            if (bit & (1 << i)) {\n                table[dep][i] = 1;\n                table[i][dep] = -1;\n            } else if (dep != i) {\n                table[dep][i] = -1;\n                table[i][dep] = 1;\n            } //if dep == i, 0\n        }\n        //cout << bitset<10>(bit) << endl; rep(i, N) {rep(j, N) cout << table[i][j] << \" \"; cout << endl;}\n        res += dfs(dep + 1, table);\n    }\n    return res;\n}\nint main() {\n    while (cin >> N && N) {\n        cin >> M;\n        int table[9][9] = {0};\n        rep(i, M) {int x, y; cin >> x >> y; x--; y--; table[x][y] = 1; table[y][x] = -1;}\n        //rep(i, N) {rep(j, N) cout << table[i][j] << \" \"; cout << endl;}\n        cout << dfs(0, table) << endl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tint M;\n\t\tcin >> M;\n\t\tvector<vector<int> > results(N, vector<int>(N, -1));\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y; --x, --y;\n\t\t\tresults[x][y] = 1;\n\t\t\tresults[y][x] = 0;\n\t\t}\n\t\tvector<pair<int, int> > allpair;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tallpair.push_back(make_pair(i, j));\n\t\t\t}\n\t\t}\n\t\tint S = allpair.size(), LS = S / 2, RS = S - LS;\n\t\tvector<vector<int> > winL(1 << LS, vector<int>(N));\n\t\tvector<vector<int> > winR(1 << RS, vector<int>(N));\n\t\tfor (int i = 0; i < 1 << LS; ++i) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < LS; ++j) {\n\t\t\t\tif ((i >> j) & 1) {\n\t\t\t\t\tif (results[allpair[j].first][allpair[j].second] != 0) ++winL[i][allpair[j].first];\n\t\t\t\t\telse ok = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (results[allpair[j].first][allpair[j].second] != 1) ++winL[i][allpair[j].second];\n\t\t\t\t\telse ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) winL[i] = vector<int>(N, -1);\n\t\t}\n\t\tfor (int i = 0; i < 1 << RS; ++i) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < RS; ++j) {\n\t\t\t\tif ((i >> j) & 1) {\n\t\t\t\t\tif (results[allpair[j + LS].first][allpair[j + LS].second] != 0) ++winR[i][allpair[j + LS].first];\n\t\t\t\t\telse ok = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (results[allpair[j + LS].first][allpair[j + LS].second] != 1) ++winR[i][allpair[j + LS].second];\n\t\t\t\t\telse ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) winR[i] = vector<int>(N, -1);\n\t\t}\n\t\tsort(winR.begin(), winR.end());\n\t\tint ans = 0;\n\t\tfor (vector<int> v : winL) {\n\t\t\tvector<int> tar(N);\n\t\t\tfor (int i = 0; i < N; ++i) tar[i] = (N - 1) / 2 - v[i];\n\t\t\tans += upper_bound(winR.begin(), winR.end(), tar) - lower_bound(winR.begin(), winR.end(), tar);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m,a[10][10],c1,c2,ans,c;\n\nvoid dfs(){\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(~a[i][j])continue;\n\t\t\tr(o,2){\n\t\t\t\tint f=0;\n\t\t\t\ta[i][j]=o;\n\t\t\t\ta[j][i]=o^1;\n\t\t\t\tr(k,i+1){\n\t\t\t\t\tc1=c2=0;\n\t\t\t\t\tif(k==i&&j!=n-1)continue;\n\t\t\t\t\tr(l,n)if(k!=l){\n\t\t\t\t\t\tif(a[k][l])c1++;\n\t\t\t\t\t\telse c2++;\n\t\t\t\t\t}\n\t\t\t\t\tif(c1!=c2)f++;\n\t\t\t\t}\n\t\t\t\tif(f)continue;\n\t\t\t\tif(i==n-2&&j==n-1)ans++;\n\t\t\t\telse dfs();\n\t\t\t}\n\t\t\ta[i][j]=-1;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tans=0;\n\t\tcin>>m;\n\t\tmemset(a,-1,sizeof(a));\n\t\tr(i,m){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tx--;y--;\n\t\t\ta[x][y]=1;\n\t\t\ta[y][x]=0;\n\t\t}\n\t\tdfs();\n\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nint wl[10][10];\nint n, m;\n\nmap<string, int> update(int i, int j, string state,\n        map<string, int> nmap, int num) {\n    if (state[i]-'0'>=1 && state[n+j]-'0'>=1) {\n        string nstate = state;\n        nstate[i] = to_string(state[i]-'0'-1)[0];\n        nstate[n+j] = to_string(state[n+j]-'0'-1)[0];\n\n        auto iter = nmap.find(nstate);\n        if (iter != nmap.end()) {\n            nmap[nstate] += num;\n        } else {\n            nmap[nstate] = num;\n        }\n    }\n    return nmap;\n}\n\nint main() {\n    while (true) {\n        cin >> n >> m;\n\n        if (n==0) break;\n\n        REP(i, n) {\n            REP(j, n) {\n                wl[i][j] = 0;\n            }\n        }\n\n        string initn = to_string((n-1)/2);\n        string inits = string(n * 2, initn[0]);\n        // 1 - (n-1)/2 : win\n        // n - (n-1) : lose\n\n        REP(i, m) {\n            int x, y;\n            cin >> x >> y;\n            wl[x-1][y-1] = 1;\n            wl[y-1][x-1] = -1;\n\n            int xwin = inits[x-1] - '0';\n            inits[x-1] = to_string(xwin - 1)[0];\n\n            int ylose = inits[n + (y-1)] - '0';\n            inits[n + (y-1)] = to_string(ylose - 1)[0];\n        }\n\n        map<string, int> prevm;\n        prevm[inits] = 1;\n        REP(i, n-1) {\n            for (int j=i+1; j<n; j++) {\n                if (wl[i][j] == 0) {\n                    map<string, int> nextm;\n                    for(auto& kv: prevm) {\n                        string state = kv.first;\n                        int num = kv.second;\n\n                        nextm = update(i, j, state, nextm, num);\n                        nextm = update(j, i, state, nextm, num);\n                    }\n                    prevm = nextm;\n                }\n            }\n        }\n\n        string ends = string(n*2, '0');\n        cout << prevm[ends] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\n\nvector<vector<int> > wl;\nvector<int> wn;\nint n;\nint cnt;\nvoid dfs(int x,int y){\n //   cout<<x<<' '<<y<<endl;\n    if( x== n-1 && y == n ){\n\tif( wn[x] == 0 ) cnt++;\n\t return;\n    }\n    if( x== y ){\n\tdfs(x,y+1);\n\treturn;\n    }\n    \n    if( wl[x][y] == 0 ){\n\tfor(int w=1;w>=-1;w-=2){\n\t    wl[x][y] == w;\n\t    wl[y][x] == -w;\n\t    wn[x] += w;\n\t    wn[y] -= w;\n\t    if( -n+y < wn[x]&&wn[x] < n-y)\n\t    if( y == n-1 ){\n\t\tif(wn[x]==0)dfs(x+1,x+2);\n\t    }else{\n\t\tdfs(x,y+1);\n\t    }\n\t    wl[x][y] = 0;\n\t    wl[y][x] = 0;\n\t    wn[x] -=w;\n\t    wn[y] +=w;\n\t}\n    }else{\n\tif(-n+y  <wn[x]&& wn[x]<n-y) \n\tif( y == n-1 ){\n\t    if(wn[x]==0)dfs(x+1,x+2);\n\t}else{\n\t    dfs(x,y+1);\n\t}\n    }\n}\n\n\nint main(){\n    while(1){\n\tcin>>n;\n\tif(n==0)break;\n\tcnt = 0;\n\twl = vector<vector<int> >(n,vector<int>(n,0) );\n\twn = vector<int>(n,0);\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t    int x,y;\n\t    cin>>x>>y;\n\t    x--,y--;\n\t    wl[x][y] =  1;\n\t    wl[y][x] = -1;\n\t    wn[x]++;\n\t    wn[y]--;\n\t}\n\tdfs(0,1);\n\t//dfs(0,0,-1);\n\tcout<<cnt<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, m, ans, table[9][9];\n\nint chack(){\n\tfor(int i=0; i<n; i++){\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; j++) tmp += table[i][j];\n\t\tif(tmp) return 0;\n\t}\n\treturn 1;\n}\n\n\nvoid dfs(int x, int y){\n\tif(x < n-1) x++;\n\telse if(y < n-1){\n\t\tx=0;\n\t\ty++;\n\t} else{\n\t\tans += chack();\n\t\treturn;\n\t}\n\n\tif(x==0 && 0<y){\n\t\tint tmp =0;\n\t\tfor(int i=0; i<n; i++) tmp += table[y-1][i];\n\t\tif(tmp) return;\n\t}\n\n\tif(table[y][x] == 0 && y != x){\n\t\ttable[y][x] = 1;\n\t\ttable[x][y] = -1;\n\t\tdfs(x, y);\n\n\t\ttable[y][x] = -1;\n\t\ttable[x][y] = 1;\n\t\tdfs(x, y);\n\n\t\ttable[y][x] = table[x][y] = 0;\n\t} else dfs(x, y);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfill(table[0], table[8], 0);\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\ttable[x][y] = 1;\n\t\t\ttable[y][x] = -1;\n\t\t}\n\n\t\tans = 0;\n\t\tdfs(0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint memo[10][10] = {0};\nint wl[10][3] = {0};\nint n, m, x, y, ans = 0, hal;\n\nvoid solve(int now, int riv);\nvoid check();\nint main() {\n  int i, j;\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    for(i = 1; i <= n; i++)\n      for(j = 0; j < 2; j++) wl[i][j] = 0;\n    for(i = 1; i <= n; i++)\n      for(j = 1; j <= n; j++) memo[i][j] = 0;\n    cin >> m;\n    for(i = 0; i < m; i++) {\n      cin >> x >> y;\n      memo[x][y] = 1;\n      memo[y][x] = 2;\n      wl[x][0]++;\n      wl[y][1]++;\n    }\n    hal = (n - 1) / 2;\n    ans = 0;\n    // check();\n    solve(1, 2);\n    cout << ans << endl;\n    ;\n  }\n  return 0;\n}\n\nvoid solve(int now, int riv) {\n  int nnow, nriv;\n  if(now == n && riv == n + 1) {\n    check();\n    return;\n  }\n  if(riv < n) {\n    nnow = now;\n    nriv = riv + 1;\n  }\n  else {\n    nnow = now + 1;\n    nriv = nnow + 1;\n  }\n  if(now == riv || memo[now][riv] != 0)\n    solve(nnow, nriv);\n  else {\n    if(hal > wl[now][0]) {\n      ++wl[now][0];\n      ++wl[riv][1];\n      memo[now][riv] = 1;\n      memo[riv][now] = 2;\n      solve(nnow, nriv);\n      --wl[now][0];\n      --wl[riv][1];\n    }\n    if(hal > wl[now][1]) {\n      ++wl[now][1];\n      ++wl[riv][0];\n      memo[now][riv] = 2;\n      memo[riv][now] = 1;\n      solve(nnow, nriv);\n      --wl[now][1];\n      --wl[riv][0];\n    }\n    memo[now][riv] = 0;\n    memo[riv][now] = 0;\n  }\n}\n\nvoid check() {\n  int i, j;\n  /*for(i = 1; i <= n; ++i) {\n    for(j = 1; j <= n; ++j) cout << memo[i][j] << \" \";\n    cout << endl;\n  }\n  cout << \"wl\";\n  for(i = 1; i <= n; ++i) cout << \" \" << wl[i][0];\n  cout << endl << endl;*/\n  for(i = 1; i <= n; ++i)\n    if(wl[i][0] != hal || wl[i][1] != hal) return;\n\n  ++ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\n\nvector<vector<int> > wl;\nvector<int> wn;\nint n;\nint cnt;\nvoid dfs(int x,int y){\n //   cout<<x<<' '<<y<<endl;\n    if( x== n-1 && y == n ){\n\tif( wn[x] == 0 ) cnt++;\n\t return;\n    }\n    if( x== y ){\n\tdfs(x,y+1);\n\treturn;\n    }\n    \n    if( wl[x][y] == 0 ){\n\tfor(int w=1;w>=-1;w-=2){\n\t    wl[x][y] == w;\n\t    wl[y][x] == -w;\n\t    wn[x] += w;\n\t    wn[y] -= w;\n\t  //  if( -n+y < wn[x] < n-y)\n\t    if( y == n-1 ){\n\t\tif(wn[x]==0)dfs(x+1,x+2);\n\t    }else{\n\t\tdfs(x,y+1);\n\t    }\n\t    wl[x][y] = 0;\n\t    wl[y][x] = 0;\n\t    wn[x] -=w;\n\t    wn[y] +=w;\n\t}\n    }else{\n\t//if(-n+y  <wn[x]<n-y) \n\tif( y == n-1 ){\n\t    if(wn[x]==0)dfs(x+1,x+2);\n\t}else{\n\t    dfs(x,y+1);\n\t}\n    }\n}\n\n\nint main(){\n    while(1){\n\tcin>>n;\n\tif(n==0)break;\n\tcnt = 0;\n\twl = vector<vector<int> >(n,vector<int>(n,0) );\n\twn = vector<int>(n,0);\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t    int x,y;\n\t    cin>>x>>y;\n\t    x--,y--;\n\t    wl[x][y] =  1;\n\t    wl[y][x] = -1;\n\t    wn[x]++;\n\t    wn[y]--;\n\t}\n\tdfs(0,1);\n\t//dfs(0,0,-1);\n\tcout<<cnt<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nInt n,m;\nInt re[11][11];\nInt wi[11],ls[11];\nInt ans;\nvoid dfs(Int y,Int x){\n  //cout<<y<<\" \"<<x<<endl;\n  if(y+1==n){\n    Int flg=1;\n    for(Int i=0;i<n;i++)\n      flg&=wi[i]==ls[i];\n    \n    if(0){\n      for(Int i=0;i<n;i++)\n\tcout<<i<<\":\"<<wi[i]<<\" \"<<ls[i]<<endl;\n      cout<<flg<<endl;\n    }\n    \n    ans+=flg;\n    return;\n  }\n  Int ny=y+(x+1)/n,nx=(x+1)%n;\n  while(nx<=ny) nx++;\n  \n  if(~re[y][x]){\n    dfs(ny,nx);\n    return;\n  }\n  {  \n    wi[x]++;\n    ls[y]++;\n    if(wi[x]<=n/2&&ls[y]<=n/2) dfs(ny,nx);\n    wi[x]--;\n    ls[y]--;    \n  }\n  {  \n    wi[y]++;\n    ls[x]++;\n    if(wi[y]<=n/2&&ls[x]<=n/2) dfs(ny,nx);\n    wi[y]--;\n    ls[x]--;    \n  }\n}\n\nsigned main(){\n  while(cin>>n,n){    \n    memset(re,-1,sizeof(re));\n    memset(wi,0,sizeof(wi));\n    memset(ls,0,sizeof(ls));\n    cin>>m;\n    for(Int i=0;i<m;i++){\n      Int x,y;\n      cin>>x>>y;\n      x--;y--;\n      re[x][y]=1;\n      re[y][x]=0;\n      wi[x]++;\n      ls[y]++;\n    }\n    for(Int i=0;i<n;i++) re[i][i]=2;\n    ans=0;\n    dfs(0,1);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint a[9][9],n,m;\nlong ans;\nvoid dfs(int I)\n{\n\tif(I==n)\n\t{\n\t\tans++;\n\t\treturn;\n\t}\n\tint id[9]={},sz=0,win=0;\n\tfor(int j=0;j<n;j++)\n\t{\n\t\tif(I!=j)\n\t\t{\n\t\t\tif(a[I][j])\n\t\t\t{\n\t\t\t\twin+=a[I][j]>0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tid[sz++]=j;\n\t\t\t}\n\t\t}\n\t}\n\tif(sz==0&&(n-1)/2==win)\n\t{\n\t\tdfs(I+1);\n\t\treturn;\n\t}\n\tif((n-1)/2<win||(n-1)/2-win>sz)return;\n\tint get=(n-1)/2-win;\n\tint comb=(1<<get)-1;\n\twhile(comb<1<<sz)\n\t{\n\t\tfor(int j=0;j<sz;j++)\n\t\t{\n\t\t\ta[I][id[j]]=comb>>j&1?1:-1;\n\t\t\ta[id[j]][I]=-a[I][id[j]];\n\t\t}\n\t\tdfs(I+1);\n\t\tif(get==0)break;\n\t\tint x=comb&-comb;\n\t\tint y=comb+x;\n\t\tcomb=(comb&~y)/x/2|y;\n\t}\n\tfor(int j=0;j<sz;j++)\n\t{\n\t\ta[I][id[j]]=a[id[j]][I]=0;\n\t}\n}\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tcin>>m;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)a[i][j]=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint x,y;cin>>x>>y;\n\t\t\tx--,y--;\n\t\t\ta[x][y]=1;\n\t\t\ta[y][x]=-1;\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint N,M,x,y,a[12][12],sum[2][12],vis[12][12];\nint qx[110],qy[110],DEP;\n\nint dfs (int dep) {\n    if(dep > DEP)\n\t\treturn 1;\n\n\tint re = 0;\n\n\tsum[0][qx[dep]]++;\n\tsum[1][qy[dep]]++;\n\tif(sum[0][qx[dep]] <= N / 2 && sum[1][qy[dep]] <= N / 2)\n        re += dfs(dep + 1);\n\tsum[0][qx[dep]]--;\n\tsum[1][qy[dep]]--;\n\n\tsum[1][qx[dep]]++;\n\tsum[0][qy[dep]]++;\n\tif(sum[1][qx[dep]] <= N / 2 && sum[0][qy[dep]] <= N / 2)\n        re += dfs(dep + 1);\n\tsum[1][qx[dep]]--;\n\tsum[0][qy[dep]]--;\n\n\treturn re;\n}\n\nint main () {\n\twhile(1) {\n\t\t\tDEP = 0;\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0) break;\n\t\tscanf(\"%d\",&M);\n\n\t\tfor(int i = 1;i <= N;++i) {\n\t\t\tsum[0][i] = sum[1][i] = 0;\n\t\t\tfor(int j = i;j <= N;++j)\n\t\t\t\tvis[i][j] = vis[j][i] = 0;\n\t\t}\n\n\t\tfor(int i = 1;i <= M;++i) {\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tvis[x][y] = vis[y][x] = 1;\n\t\t\ta[x][y] = 1;\n\t\t\ta[y][x] = 0;\n\t\t\tsum[1][x]++;\n\t\t\tsum[0][y]++;\n\t\t}\n\t\tbool f = 0;\n\t\tfor(int i = 1;i <= N;++i) {\n\t\t\tif(sum[0][i] > N / 2 || sum[1][i] > N / 2) {\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tf = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f) continue;\n\n\t\tfor(int i = 1;i <= N;++i) {\n\t\t\tfor(int j = i + 1;j <= N;++j) {\n\t\t\t\tif(!vis[i][j]) {\n\t\t\t\t\tqx[++DEP] = i;\n\t\t\t\t\tqy[DEP] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(1));\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nmap<vector<int>, int> dp;\nvector<vector<int>> data;\n\n// 各プレイヤーの残り勝数と先頭の番号\nint rec(vector<int> win, int id) {\n    if (win.size() == 1 && win[0] == 0) return 1;\n    if (dp.count(win)) return dp[win];\n\n    int n = win.size(), h = win.front();\n    dp[win] = 0;\n\n    for (int pat = 0; pat < (1 << (n - 1)); ++pat) {\n        // 勝数条件\n        if (__builtin_popcount(pat) != h) continue;\n\n        bool judge = true;\n\n        // 与えられた条件と合致するか\n        for (int i = 0; i < n - 1; ++i) {\n            int opp = id + i + 1;\n            if (data[id][opp] >= 0 && ((pat >> i) & 1) != data[id][opp]) {\n                judge = false;\n            }\n        }\n\n        auto nwin = win;\n\n        // 自分が「負けた」相手の残り勝数を1減らす\n        for (int i = 0; i < n - 1; ++i) {\n            int opp = i + 1;\n            nwin[opp] -= 1 - ((pat >> i) & 1);\n            if (nwin[opp] < 0) judge = false;\n        }\n        nwin.erase(nwin.begin());\n        if (judge) dp[win] += rec(nwin, id + 1);\n    }\n\n    return dp[win];\n}\n\nbool solve() {\n    dp.clear();\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n    data.assign(N, vector<int>(N, -1));\n\n    int M;\n    cin >> M;\n    for (int i = 0; i < M; ++i) {\n        int x, y;\n        cin >> x >> y;\n        --x, --y;\n        data[x][y] = 1;\n        data[y][x] = 0;\n    }\n\n\n    vector<int> win(N, N / 2);\n    cout << rec(win, 0) << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N,M;\nvector<vector<int>> v(9,vector<int>(9,-1));\n\nbool check(int y){\n    int win = 0,nul = 0;\n    for(int x=0;x<N;x++){\n        if(v[y][x]==1) win++;\n        else if(v[y][x]==-1 && y!=x) nul++;\n    }\n    return win<=(N-1)/2 && (N-1)/2<=win+nul;\n}        \n\nint dfs(int now){\n    int res = 0;\n    int x = now%N,y = now/N;\n    if(now==N*N) return 1;\n    if(x==y || v[y][x]!=-1){\n        if(check(y)) res += dfs(now+1);\n        return res;\n    }\n    v[y][x] = 1; v[x][y] = 0;\n    if(check(y)) res += dfs(now+1);\n    v[y][x] = 0; v[x][y] = 1;\n    if(check(y)) res += dfs(now+1);\n    v[y][x] = -1; v[x][y] = -1;\n    return res;\n}\n\nint main(){\n    while(cin >> N >> M && N>0){\n        int x,y;\n        for(int i=0;i<N;i++) for(int j=0;j<N;j++) v[i][j] = -1;\n        for(int i=0;i<M;i++){\n            cin >> x >> y;\n            x--; y--;\n            v[x][y] = 1;\n            v[y][x] = 0;\n        }\n        cout << dfs(0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<bool>> tfmap(11, vector<bool>(11, false));\nvector<vector<string>> wlmap(11, vector<string>(11, \"\"));\n\n\nint s(int n,int i,int j){\n\tif(i==j){\n\t\tif(j == n){\n\t\t\tint temp = 0;\n\t\t\tfor(int k = 1;k<n;k++){\n\t\t\t\tif(wlmap[i][k] == \"w\") temp++;\n\t\t\t}\n\t\t\tif(temp == (n-1)/2) return 1;\n\t\t\telse return 0;\n\t\t}\n\t\telse{\n\t\t\treturn s(n,i,j+1);\n\t\t}\n\t}\n\telse if(j == n+1){\n\t\tint temp = 0;\n\t\tfor(int k = 0;k<=n;k++){\n\t\t\tif(k==i) continue;\n\t\t\tif(wlmap[i][k] == \"w\") temp++;\n\t\t}\n\t\tif(temp == (n-1)/2) return s(n,i+1,1);\n\t\telse return 0;\n\t}\n\telse{\n\t\tif(tfmap[i][j]) return s(n,i,j+1);\n\t\telse{\n\t\t\tint temp = 0;\n\t\t\ttfmap[i][j] = true;\n\t\t\ttfmap[j][i] = true;\n\t\t\twlmap[i][j] = \"w\";\n\t\t\twlmap[j][i] = \"l\";\n\t\t\ttemp += s(n,i,j+1);\n\t\t\twlmap[i][j] = \"l\";\n\t\t\twlmap[j][i] = \"w\";\n\t\t\ttemp += s(n,i,j+1);\n\t\t\ttfmap[i][j] = false;\n\t\t\ttfmap[j][i] = false;\n\t\t\treturn temp;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m;\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcin >> m;\n\t\tfor(int i = 0;i<10;i++){\n\t\t\tfor(int j = 0;j<10;j++){\n\t\t\t\ttfmap[i][j] = false;\n\t\t\t\twlmap[i][j] = \"\";\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i<m;i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttfmap[x][y] = true;\n\t\t\ttfmap[y][x] = true;\n\t\t\twlmap[x][y] = \"w\";\n\t\t\twlmap[y][x] = \"l\";\n\t\t}\n\t\tcout << s(n,1,2) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nint n;\nint ans;\n\nvector<int> w,r;\nvector<pi> b;\nint B;\n\nconst int N = 9;\nint res[N][N];\n\nvoid dfs(int d){\n    if(d==B){\n        rep(i,n)if(w[i]!=n/2) return;\n        ++ans;\n        return;\n    }\n\n    int x = b[d].fi, y = b[d].se;\n    if(res[x][y]==0){\n        rep(i,2){\n            ++w[x];\n            --r[x];\n            --r[y];\n\n            bool valid = true;\n            for(int j:{x,y}){\n                if(w[j]+r[j]<n/2 || w[j]>n/2) valid = false;\n            }\n            if(valid) dfs(d+1);\n\n            --w[x];\n            ++r[x];\n            ++r[y];\n            swap(x,y);\n        }\n    }\n    else dfs(d+1);\n}\n\nint main(){\n    while(cin >>n,n){\n        memset(res,0,sizeof(res));\n        w = vector<int>(n);\n        r = vector<int>(n,n-1);\n\n        int m;\n        cin >>m;\n        rep(i,m){\n            int x,y;\n            cin >>x >>y;\n            --x;\n            --y;\n\n            res[x][y] = 1;\n            res[y][x] = -1;\n\n            ++w[x];\n            --r[x];\n            --r[y];\n        }\n\n        ans = 0;\n        b.clear();\n        rep(i,n)for(int j=i+1; j<n; ++j) b.pb({i,j});\n        B = b.size();\n        dfs(0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 10\n\nenum Type{\n\tWIN,\n\tLOSE,\n\tUNDEFINED,\n};\n\nint N,M;\nint win_table[NUM],lose_table[NUM];\nType table[NUM][NUM];\nbool inputed[NUM][NUM];\n\nvoid init(int row,int col){\n\n\tif(!inputed[row][col]){\n\n\t\tif(table[row][col] == WIN){\n\n\t\t\twin_table[row]--;\n\t\t\tlose_table[col]--;\n\n\t\t}else{\n\n\t\t\tlose_table[row]--;\n\t\t\twin_table[col]--;\n\t\t}\n\n\t\ttable[row][col] = UNDEFINED;\n\t\ttable[col][row] = UNDEFINED;\n\t}\n}\n\nint recursive(int row,int col){\n\n\tif(row == col){\n\t\treturn recursive(row,col+1);\n\t}\n\n\tint ret = 0;\n\n\tif(col == N-1){\n\n\t\tif(inputed[row][col] == false && win_table[row] != (N-1)/2-1 && lose_table[row] != (N-1)/2-1){\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(win_table[row] == (N-1)/2-1){\n\n\t\t\tif(lose_table[col] == (N-1)/2){\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\ttable[row][col] = WIN;\n\t\t\ttable[col][row] = LOSE;\n\n\t\t\twin_table[row]++;\n\t\t\tlose_table[col]++;\n\n\t\t}else if(lose_table[row] == (N-1)/2-1){\n\n\t\t\tif(win_table[col] == (N-1)/2){\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\ttable[row][col] = LOSE;\n\t\t\ttable[col][row] = WIN;\n\n\t\t\tlose_table[row]++;\n\t\t\twin_table[col]++;\n\t\t}\n\n\t\tif(row == N-2){\n\n\t\t\tinit(row,col);\n\t\t\treturn 1;\n\n\t\t}else{\n\n\t\t\tret = recursive(row+1,0);\n\n\t\t\tinit(row,col);\n\n\t\t\treturn ret;\n\t\t}\n\n\t}else{\n\n\t\tif(table[row][col] == UNDEFINED){\n\n\t\t\tif(win_table[row] < (N-1)/2 && lose_table[col] < (N-1)/2){\n\n\t\t\t\ttable[row][col] = WIN;\n\t\t\t\ttable[col][row] = LOSE;\n\n\t\t\t\twin_table[row]++;\n\t\t\t\tlose_table[col]++;\n\n\t\t\t\tret += recursive(row,col+1);\n\n\t\t\t\ttable[row][col] = UNDEFINED;\n\t\t\t\ttable[col][row] = UNDEFINED;\n\n\t\t\t\twin_table[row]--;\n\t\t\t\tlose_table[col]--;\n\t\t\t}\n\t\t\tif(lose_table[row] < (N-1)/2 && win_table[col] < (N-1)/2){\n\n\t\t\t\ttable[row][col] = LOSE;\n\t\t\t\ttable[col][row] = WIN;\n\n\t\t\t\tlose_table[row]++;\n\t\t\t\twin_table[col]++;\n\n\t\t\t\tret += recursive(row,col+1);\n\n\t\t\t\ttable[row][col] = UNDEFINED;\n\t\t\t\ttable[col][row] = UNDEFINED;\n\n\t\t\t\tlose_table[row]--;\n\t\t\t\twin_table[col]--;\n\t\t\t}\n\n\t\t\treturn ret;\n\n\t\t}else{\n\n\t\t\treturn recursive(row,col+1);\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tfor(int row = 0; row < N; row++){\n\t\tfor(int col = 0; col < N; col++){\n\t\t\ttable[row][col] = UNDEFINED;\n\t\t\tinputed[row][col] = false;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&M);\n\n\tint x,y;\n\n\tfor(int loop = 0; loop < M; loop++){\n\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tx--;\n\t\ty--;\n\n\t\ttable[x][y] = WIN;\n\t\ttable[y][x] = LOSE;\n\n\t\tinputed[x][y] = true;\n\t\tinputed[y][x] = true;\n\t}\n\n\tint num_win,num_lose;\n\n\tfor(int row = 0; row < N; row++){\n\n\t\tnum_win = 0;\n\t\tnum_lose = 0;\n\n\t\tfor(int col = 0; col < N; col++){\n\t\t\tif(table[row][col] == WIN){\n\n\t\t\t\tnum_win++;\n\n\t\t\t}else if(table[row][col] == LOSE){\n\n\t\t\t\tnum_lose++;\n\t\t\t}\n\t\t}\n\n\t\tif(num_win > (N-1)/2 || num_lose > (N-1)/2){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn;\n\t\t}\n\t\twin_table[row] = num_win;\n\t\tlose_table[row] = num_lose;\n\t}\n\n\tprintf(\"%d\\n\",recursive(0,0));\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n\nll n, m, x, y, d[9][9], win[9], WIN;\n\nll dfs(ll x, ll y) {\n  if (x == n) {\n    //for (ll i = 0; i < n; i++) if (win[i] != WIN) return 0;\n    //for (ll i = 0; i < n; i++) printf(\"%lld \", win[i]); printf(\"\\n\");\n    return 1;\n  }\n  if (y == n) return dfs(x+1, x+2);\n  if (d[x][y] != 0) return dfs(x, y+1);\n  //printf(\"%lld,%lld\\n\", x, y);\n  ll ans = 0;\n  if (win[x] != WIN) win[x]++, ans += dfs(x, y+1), win[x]--;\n  if (win[y] != WIN) win[y]++, ans += dfs(x, y+1), win[y]--;\n  return ans;\n}\n\nint main() {\n  while (scanf(\"%lld\", &n), n) {\n    scanf(\"%lld\", &m);\n    WIN = n/2;\n    for (ll i = 0; i < n; i++) win[i] = 0;\n    for (ll i = 0; i < n; i++) for (ll j = 0; j < n; j++) d[i][j] = 0;\n    for (ll i = 0; i < m; i++) scanf(\"%lld%lld\", &x, &y), x--, y--, d[x][y] = 1, d[y][x] = -1, win[x]++;\n    bool flag = false;\n    for (ll i = 0; i < n; i++) if (win[i] > WIN) flag = true;\n    if (flag) {\n      printf(\"0\\n\");\n      continue;\n    }\n    printf(\"%lld\\n\", dfs(0, 1));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nbool check(vector<vector<int>> &g) {\n    int n = g.size();\n    for(int i = 0; i < n; i++) {\n        int win = 0, lose = 0;\n        for(int j = 0; j < n; j++) {\n            if(i == j) {\n                continue;\n            }\n            win += (g[i][j] == 1);\n            lose += (g[i][j] == 0);\n        }\n        if(win > (n / 2) || lose > (n / 2)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint dfs(int now, vector<vector<int>> &g, vector<P> &v) {\n    int n = g.size();\n    int sz = v.size();\n    if(now >= sz) {\n        // for(int i = 0; i < n; i++) {\n        //     for(int j = 0; j < n; j++) {\n        //         cerr << g[i][j] << \" \";\n        //     }\n        //     cerr << endl;\n        // }\n        return (check(g));\n    }\n    int res = 0;\n    int i = v[now].first;\n    int j = v[now].second;\n    // cerr << i << \" \" << j << endl;\n    if(g[i][j] == -1) {\n        g[i][j] = 0;\n        g[j][i] = 1;\n        if(check(g)) {\n            res += dfs(now + 1, g, v);\n        }\n        g[i][j] = 1;\n        g[j][i] = 0;\n        if(check(g)) {\n            res += dfs(now + 1, g, v);\n        }\n        g[i][j] = g[j][i] = -1;\n    } else {\n        res += dfs(now + 1, g, v);\n    }\n    return res;\n}\n\nint main() {\n    while(true) {\n        int n, m;\n        cin >> n;\n        if(n == 0) {\n            break;\n        }\n        cin >> m;\n        vector<vector<int>> g(n, vector<int>(n, -1));\n        for(int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            g[--x][--y] = 1;\n            g[y][x] = 0;\n        }\n        vector<P> v;\n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                // cerr << i << \" \" << j << endl;\n                v.emplace_back(P(i, j));\n            }\n        }\n        cout << dfs(0, g, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPA(i,n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define PII pair<int,int>\n#define PLI pair<long long, int>\n#define PLL pair<long long, long long>\n#define PDD pair<double, double>\n#define MOD ((int)1e9 + 7)\n#define INF ((int)1e9)\n#define INFLL ((LL)1e18)\n#define ALL(x) (x).begin(),(x).end()\n#define ctoi(x) (x - 'a') \n#define CTOI(x) (x - 'A')\n#define BIT(x) (1 << (x))\nusing namespace std;\n\nLL modinv(LL a){\n    LL b = MOD, u = 1, v = 0;\n    while(b){\n        LL t = a / b;\n        a -= t * b;swap(a, b);\n        u -= t * v;swap(u, v);\n    }\n    u%=MOD;\n    if(u < 0) u += MOD;\n    return u;\n\n}\n\nLL exp(LL a, LL b){\n    LL sum = a;\n    LL res = 1;\n    while(b){\n        if(b&1){\n            res = (res * sum)%MOD;\n        }\n        sum = (sum * sum) % MOD;\n        b>>=1;\n    }\n    return res;\n}\n\nint N, M;\nvector<vector<int> > game;\n\nint func(int place){\n    if(place==N+1){\n        return 1;\n    }\n    int won=0;\n    int lose=0;\n    vector<int> non;\n    REPA(i, N+1){\n        if(i==place)continue;\n        if(game[place][i]==-1){\n            ++lose;\n        }else if(game[place][i]==1){\n            ++won;\n        }else{\n            non.push_back(i);\n        }\n    }\n    if(won>N/2||lose>N/2)return 0;\n    vector<int> lw;\n    REP(i, N/2-lose)lw.push_back(-1);\n    REP(i, N/2-won)lw.push_back(1);\n    int res = 0;\n    do{\n        REP(i, non.size()){\n            game[place][non[i]]=lw[i];\n            game[non[i]][place]=-lw[i];\n        }\n        res += func(place+1);\n        REP(i, non.size()){\n            game[place][non[i]]=0;\n            game[non[i]][place]=0;\n        }\n    }while(next_permutation(ALL(lw)));\n    return res;\n}\n\nint main(){\n    while(cin>>N&&N){\n        cin>>M;\n        game.assign(N+1, vector<int>(N+1, 0));\n        REP(i, M){\n            int a, b;\n            cin >> a >> b;\n            game[a][b]=1;\n            game[b][a]=-1;\n        }\n        cout << func(1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nint result[100][100];\nint win[100];\nint sum[100];\nint ans=0;\nint n;\nvoid dfs(int);\nvoid comb(int w,int s,int d,int num,int bbit,int wnum,int lnum){\n  //cout<<num<<endl;\n  if(num==n-s-1){\n    int cnt=0;\n    vector<pair<int,int> >po;\n    for(int i=d+1;i<n;i++){\n      if(result[d][i]==0){\n\tif(bbit&(1<<cnt)){\n\t  result[d][i]=1;\n\t  result[i][d]=2;\n\t  sum[i]++;\n\t  win[d]++;\n\t  po.pb(mp(i,0));\n\t}else{\n\t  result[d][i]=2;\n\t  result[i][d]=1;\n\t  sum[i]++;\n\t  win[i]++;\n\t  po.pb(mp(i,1));\n\t}\n\tcnt++;\n      }\n    }\n    dfs(d+1);\n    for(int i=0;i<po.size();i++){\n      if(po[i].S){\n\twin[po[i].F]--;\n      }else\n\twin[d]--;\n      sum[po[i].F]--;\n      result[d][po[i].F]=0;\n      result[po[i].F][d]=0;\n    }\n    return;\n  }\n  if(wnum+w<(n-1)/2)\n    comb(w,s,d,num+1,bbit+(1<<num),wnum+1,lnum);\n  if(lnum+(s-w)<(n-1)/2)\n    comb(w,s,d,num+1,bbit,wnum,lnum+1);\n}\nvoid dfs(int depth){\n  if(depth==n-1){\n     for(int i=0;i<n;i++){\n    // for(int j=0;j<n;j++){\n    //\tcout<<result[i][j]<<\" \";\n    // }\n    // cout<<endl;\n      if(win[i]!=n/2)return;\n      }\n    ans++;\n    return;\n  }\n  comb(win[depth],sum[depth],depth,0,0,0,0);\n}\nint main(){\n  while(cin>>n,n){\n    ans=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)\n\tresult[i][j]=0;\n      win[i]=0;\n      sum[i]=0;\n    }\n    int m;cin>>m;\n    for(int i=0;i<m;i++){\n      int x,y;cin>>x>>y;\n      result[--x][--y]=1;\n      result[y][x]=2;\n      win[x]++;\n      sum[x]++;\n      sum[y]++;\n    }\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int UNDEFINED = -1;\nconst int WIN = 0;\nconst int LOSE = 1;\nint n;\nint win[10], lose[10];\nint result[10][10];\nint ans;\n\nint encode(int x, int y) {\n    return x * n + y;\n}\npair<int, int> decode(int z) {\n    return  {z / n, z % n};\n}\n\nvoid dfs(int z) {\n    int x, y;\n    tie(x, y) = decode(z);\n    if(x >= n or y >= n) {\n        ans++;\n        return;\n    }\n    if(win[x] > n / 2) return;\n    if(lose[x] > n / 2) return;\n    if(x == y) {\n        dfs(encode(x, y) + 1);\n        return;\n    }\n    if(result[x][y] != UNDEFINED) {\n        dfs(encode(x, y) + 1);\n        return;\n    }\n    // WIN\n    if(win[x] < n / 2) {\n        result[x][y] = WIN;\n        result[y][x] = LOSE;\n        win[x]++; lose[y]++;\n        dfs(encode(x, y) + 1);\n        result[x][y] = UNDEFINED;\n        result[y][x] = UNDEFINED;\n        win[x]--; lose[y]--;\n    }\n    // LOSE\n    if(lose[x] < n / 2) {\n        result[x][y] = LOSE;\n        result[y][x] = WIN;\n        lose[x]++; win[y]++;\n        dfs(encode(x, y) + 1);\n        result[x][y] = UNDEFINED;\n        result[y][x] = UNDEFINED;\n        lose[x]--; win[y]--;\n    }\n}\n\nint main() {\n    while(cin >> n and n > 0) {\n        // init\n        ans = 0;\n        for(int i = 0; i < n; ++i) {\n            win[i] = lose[i] = 0;\n            for(int j = 0; j < n; ++j) {\n                result[i][j] = UNDEFINED;\n            }\n        }\n        // input\n        int m; cin >> m;\n        while(m--) {\n            int x, y; cin >> x >> y;\n            x--; y--;\n            result[x][y] = WIN;\n            result[y][x] = LOSE;\n            win[x]++; lose[y]++;\n        }\n        dfs(0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\nint d[10] ;\nbool vis[10][10] ;\nint n ;\nmap< int , int > mp1 , mp2 ;\nint a[50] , b[50] , x[10] ;\nlong long ans ;\nvoid dfs( int k , int up ){\n    if ( k == up + 1 ){\n        int res = 0 ;\n        int j = 1 ;\n        for( int i = n ; i >= 1 ; i-- ){\n            res += d[i] * j ; j *= 10 ;\n        }\n        mp1[res]++ ;\n        return ;\n    }\n    d[a[k]]++ ;\n    if ( d[a[k]] <= n / 2 ) dfs( k + 1 , up ) ;\n    d[a[k]]-- ;\n    d[b[k]]++ ;\n    if ( d[b[k]] <= n / 2 ) dfs( k + 1 , up ) ;\n    d[b[k]]-- ;\n}\nvoid dfs2( int k , int up ){\n    if ( k == up + 1 ){\n        int res = 0 ;\n        int j = 1 ;\n        for( int i = n ; i >= 1 ; i-- ){\n            res += d[i] * j ; j *= 10 ;\n        }\n        mp2[res]++ ;\n        return ;\n    }\n    d[a[k]]++ ;\n    if ( d[a[k]] <= n / 2 ) dfs2( k + 1 , up ) ;\n    d[a[k]]-- ;\n    d[b[k]]++ ;\n    if ( d[b[k]] <= n / 2 ) dfs2( k + 1 , up ) ;\n    d[b[k]]-- ;\n}\nvoid dfs3( int k ){\n    if ( k == n + 1 ){\n        int res = 0 ;\n        int gg = 0 ;\n        int j = 1 ;\n        for( int i = n ; i >= 1 ; i-- ){\n            res += x[i] * j ;\n            gg += ( n / 2 - x[i] + d[i] ) * j ;\n            j *= 10 ;\n        }\n        ans += ( long long )mp1[res] * mp2[gg] ;\n        return ;\n    }\n    for( int i = 0 ; i <= n / 2 ; i++ ){\n        x[k] = i ;\n        dfs3( k + 1 ) ;\n    }\n}\nint main(){\n    while( 1 ){\n          scanf( \"%d\" , &n ) ;\n          if ( n == 0 ) break ;\n          memset( d , 0 , sizeof( d ) ) ;\n          memset( vis , false , sizeof( vis ) ) ;\n          mp1.clear() ; mp2.clear() ; ans = 0 ;\n          int m ;\n          scanf( \"%d\" , &m ) ;\n          for( int i = 1 ; i <= m ; i++ ){\n              int x , y ;\n              scanf( \"%d%d\" , &x , &y ) ;\n              d[x]++ ; vis[x][y] = vis[y][x] = true ;\n          }\n          int sz = 0 ;\n          for( int i = 1 ; i <= n - 1 ; i++ )\n              for( int j = i + 1 ; j <= n ; j++ ){\n                  if ( !vis[i][j] ){\n                      sz++ ; a[sz] = i ; b[sz] = j ;\n                  }\n              }\n          dfs( 1 , sz / 2 ) ;\n          dfs2( sz / 2 + 1 , sz ) ;\n          dfs3( 1 ) ;\n          printf( \"%lld\\n\" , ans ) ;\n    }\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n,m;\nint rem[10];\nvector<int> yet[10];\nint dp[10][400100];\nint x[100],y[100];\nint f[10][10];\nint fpow[20];\nint tmp[20];\nint k;\nint encode(int s){\n\tint res = 0;\n\tfor(int i=s;i<n;i++){\n\t\tres = res*5+tmp[i];\n\t}\n\treturn res;\n}\nvoid decode(int S){\n\tfor(int i=n-1;i>=0;i--){\n\t\ttmp[i]=S%5;\n\t\tS/=5;\n\t}\n}\nvoid print(){\n\tfor(int i=0;i<n;i++){\n\t\tcout << tmp[i] << ' ';\n\t}\n\tcout << endl;\n}\nbool solve(){\n\tscanf(\"%d\",&n);\n\tif(n==0)return false;\n\tscanf(\"%d\",&m);\n\tmemset(f,-1,sizeof(f));\n\tmemset(rem,0,sizeof(rem));\n\tmemset(dp,0,sizeof(dp));\n\tfor(int i=0;i<n;i++)yet[i].clear();\n\tk = (n-1)/2;\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\tx[i]--;y[i]--;\n\t\tf[x[i]][y[i]]=1;\n\t\tf[y[i]][x[i]]=0;\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcout << f[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tfor(int i=0;i<n;i++){\n\t\ttmp[i]=k;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(f[i][j]==1)tmp[i]--;\n\t\t}\n\t\tif(tmp[i]<0){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tcout << tmp[i] << endl;\n\t}*/\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(f[i][j]==-1)yet[i].pb(j);\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<yet[i].size();j++){\n\t\t\tcout << yet[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tdp[0][encode(0)]=1;\n\tfor(int i=0;i<n-1;i++){\n\t\tint yy = yet[i].size();\n\t\tfor(int j=0;j<fpow[n-i];j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\t//print();\n\t\t\tdecode(j);\n\t\t\tfor(int k=0;k<(1<<yy);k++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int l=0;l<yy;l++){\n\t\t\t\t\tif((k>>l)&1){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(tmp[yet[i][l]]==0){\n\t\t\t\t\t\t\tcnt=-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if(j==31)cout << j << ' ' << k << ' ' << cnt  << ' ' << tmp[i] << endl;\n\t\t\t\tif(cnt!=tmp[i])continue;\n\t\t\t\t//if(j==31)cout << j << ' ' << k << ' ' << cnt << endl;\n\t\t\t\t//cout << j << \" -> (\"  << k << ')'; \n\t\t\t\tfor(int l=0;l<yy;l++){\n\t\t\t\t\tif(!((k>>l)&1)){\n\t\t\t\t\t\ttmp[yet[i][l]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i+1][encode(i+1)]+=dp[i][j];\n\t\t\t\t//print();\n\t\t\t\tdecode(j);\n\t\t\t}\n\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n-1][0]);\n\treturn true;\n}\nint main(){\n\tfpow[0]=1;\n\tfor(int i=0;i<10;i++)fpow[i+1]=fpow[i]*5;\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n  for(auto &youso_ : (x)) cin >> youso_\n#define mp make_pair\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n  T x;\n  cin >> x;\n  return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n  cin >> head;\n  CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n  int __VA_ARGS__;                                                           \\\n  CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n  ll __VA_ARGS__;                                                            \\\n  CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n  string __VA_ARGS__;                                                        \\\n  CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n  {                                                                          \\\n  FOREACH(x, v) { cout << x << \" \"; }                                    \\\n    cout << \"\\n\";                                                          \\\n    }\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\ntypedef priority_queue<ll> PQ;\ntypedef priority_queue<ll, VL, greater<ll>> PQG;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\nconst ll dx[] = {1, -1, 0, 0};\nconst ll dy[] = {0, 0, 1, -1};\n\nll N, M, H;\nll res;\nvector<VL> g;\n\nbool check(ll i){\n  ll win=0,lose=0;\n  REP(j,N){\n    if(i!=j){\n      if(g[i][j]==1) win++;\n      if(g[i][j]==0) lose++;\n    }\n  }\n  return (win<=H && lose<=H)?true:false;\n}\n\n\nvoid dfs(ll i, ll j){\n  if(i==N-1 && j==N){\n    res++;\n    return;\n  }\n  ll ni,nj;\n  if(j==N-1){\n    ni=i+1,nj=ni+1;\n  }else{\n    ni=i,nj=j+1;\n  }\n  if(g[i][j]!=-1){\n    if(check(i) && check(j)) dfs(ni,nj);\n  }else{\n    g[i][j]=0, g[j][i]=1;\n    if(check(i) && check(j)) dfs(ni,nj);\n    g[i][j]=1, g[j][i]=0;\n    if(check(i) && check(j)) dfs(ni,nj);\n    g[i][j]=-1, g[j][i]=-1;\n  }\n  return;\n}\nsigned main(){\n  while(1){\n    cin>>N;\n    if(N==0) break;\n    H=N/2;\n    cin>>M;\n    g.assign(N,VL(N,-1));\n    REP(i,M){\n      LCIN(a,b);\n      a--,b--;\n      g[a][b]=1;\n      g[b][a]=0;\n    }\n    res=0;\n    dfs(0,1);\n    cout << res << \"\\n\";\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n,m,ans,sum[10],a[10][10];\nvoid dfs(int xx,int yy)\n{\n    int v=0;\n    int x,y;\n    for (int i=1;i<=n;i++)\n    if (sum[i]>(n-1)/2) return;\n    for (int i=xx;i<=n;i++)\n    {\n      for (int j=1;j<=i-1;j++)\n      if (a[i][j]==-1)\n      {\n         x=i; y=j;\n         v=1;\n         break;\n      }\n      if (v==1) break;\n    }\n    if (v==0)\n    {\n        int vv=0;\n        for (int i=1;i<=n;i++)\n        {\n            if (i>=2&&sum[i]!=sum[i-1])\n            {\n                vv=1; break;\n            }\n        }\n        if (vv==0) ans++;\n        return;\n    }\n    a[x][y]=1;\n    a[y][x]=0;\n    sum[x]+=1;\n    dfs(x,y);\n    a[x][y]=-1;\n    a[y][x]=-1;\n    sum[x]-=1;\n    a[x][y]=0;\n    a[y][x]=1;\n    sum[y]+=1;\n    dfs(x,y);\n    a[x][y]=-1;\n    a[y][x]=-1;\n    sum[y]-=1;\n}\n\nint main()\n{\nwhile (1)\n{\n    scanf(\"%d\",&n);\n    if (n==0) break;\n    scanf(\"%d\",&m);\n    memset(a,-1,sizeof(a));\n    int x,y;\n    memset(sum,0,sizeof(sum));\n    for (int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        a[x][y]=1;\n        a[y][x]=0;\n        sum[x]+=1;\n    }\n    ans=0;\n    dfs(1,1);\n    printf(\"%d\\n\",ans);\n}\n\n    return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, m, ans, table[9][9];\n\nint chack(){\n\tfor(int i=0; i<n; i++){\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; j++) tmp += table[i][j];\n\t\tif(tmp)\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nvoid solve(int x, int y){\n\tif(y < n-1) y++;\n\telse if(x < n-1){\n\t\ty=0;\n\t\tx++;\n\t}else {\n\t\tans += chack();\n\t\treturn;\n\t}\n\t\n\tif(y==0 && 0<x){\n\t\tint tmp =0;\n\t\tfor(int i=0; i<n; i++) tmp +=table[x-1][i];\n\t\tif(tmp) return;\n\t}\t\n\n\tif(table[x][y] == 0 && x != y){\n\t\ttable[x][y] = 1;\n\t\ttable[y][x] = -1;\n\n\t\tsolve(x, y);\n\n\t\ttable[x][y] = -1;\n\t\ttable[y][x] = 1;\n\t\tsolve(x, y);\n\n\t\ttable[x][y] = table[y][x] = 0;\n\t} else solve(x, y);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfill(table[0], table[8], 0);\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\ttable[x][y] = 1;\n\t\t\ttable[y][x] = -1;\n\t\t}\n\n\t\tint x, y;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(table[i][j]==0 && i != j){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j-1;\n\t\t\t\t\tgoto AA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tAA:\n\n\t\tans = 0;\n\t\tsolve(x, y);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// ll ans;\n// int n;\n\n// vector<vector<int>> combs[10];\n\n// void dfs(int pos, int init, int l, vector<int> perm) { \n//     if(pos == l / 2)    {\n//         //\n//         combs[l].push_back(perm);\n//         //\n//     }\n//     for(int i = init; i <= l - l / 2 + pos; ++ i) {\n//         perm.push_back(i);\n//         dfs(pos + 1, i + 1, l, perm);\n//         perm.pop_back();\n//     }\n// }\n\n// void rec(vector<vector<int>> f, int i) {\n//     if(i == n) {\n//         ++ ans;\n//         return;\n//     }\n//     int cnt0 = 0, cnt1 = 0;\n//     rep(j, n) {\n//         if(i == j) continue;\n//         if(f[i][j] == 1) ++ cnt1;\n//         if(f[i][j] == 0) ++ cnt0;\n//     }\n//     if(cnt0 > n / 2 || cnt1 > n / 2) return;\n//     int cnt = n - cnt0 - cnt1;\n//     if(cnt == 1) {\n//         rec(f, i + 1);\n//     }\n//     for(auto com: combs[cnt - 1]) {\n//         int k = 0, l = 0;\n//         vector<int> q;\n//         rep(j, n) {\n//             if(f[i][j] == 1 || f[i][j] == 0 || i == j) continue;\n//             q.push_back(j);\n//             if(com[l] == k) {\n//                 ++ l;\n//                 f[i][j] = 1;\n//             } else {\n//                 f[i][j] = 0;\n//             }\n//             ++ k;\n//         }\n//         rec(f, i + 1);\n//         for(auto j: q) {\n//             f[i][j] = -1;\n//         }\n//     }\n// }\n\n// void solve() {\n//     vector<int> perm;\n//     for(int i = 0; i <= 9; ++ i) {\n//         combs[i].resize(0);\n//         dfs(0, 0, i, perm);\n//     }\n//     while(cin >> n) {\n//         int m; cin >> m;\n//         vector<int> x(m), y(m);\n//         vector<vector<int>> f(n, vector<int>(n, -1));\n//         rep(i, m) {\n//             cin >> x[i] >> y[i];\n//             -- x[i], -- y[i];\n//             f[x[i]][y[i]] = 1;\n//             f[x[i]][y[i]] = 0;\n//         }\n//         ans = 0;\n//         rec(f, 0);\n//         cout << ans << endl;\n//     }\n// }\n\nint n, m, f[9][9];\nint ans;\n\nbool check(int i) {\n    int win = 0, lose = 0;\n    rep(j, n) {\n        if(i == j) continue;\n        if(f[i][j] == 1) ++ win;\n        else if(f[i][j] == 0) ++ lose;\n    }\n    return win <= n / 2 && lose <= n / 2;\n}\n\nvoid rec(int cnt) {\n    if(cnt == n * n) {\n        ++ ans;\n        return;\n    }\n    int i = cnt / n, j = cnt % n;\n    if(i == j || f[i][j] != -1) {\n        if(check(i)) rec(cnt + 1);\n        return;\n    }\n    f[i][j] = 1, f[j][i] = 0;\n    if(check(i)) rec(cnt + 1);\n    f[i][j] = 0, f[j][i] = 1;\n    if(check(i)) rec(cnt + 1);\n    f[i][j] = -1, f[j][i] = -1;\n}\n\nvoid solve() {\n    while(cin >> n) {\n        if(n == 0) break;\n        cin >> m;\n        rep(i, n) {\n            rep(j, n) {\n                f[i][j] = -1;\n            }\n        }\n        rep(i, m) {\n            int a, b; cin >> a >> b;\n            -- a, -- b;\n            f[a][b] = 1;\n            f[b][a] = 0;\n        }\n        ans = 0;\n        rec(0);\n        cout << ans << endl;\n    }\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m,a[10][10],c1,c2,ans,c;\n\nvoid dfs(){\n  for(int i=0;i<n-1;i++){\n    for(int j=i+1;j<n;j++){\n      if(i==n-2&&j==n-1&&(a[i][j]!=-1)){\n        ans++;\n        continue;\n      }\n      else if(~a[i][j])continue;\n      r(o,2){\n        int f=0;\n        a[i][j]=o;\n        a[j][i]=o^1;\n        r(k,i+1){\n          c1=c2=0;\n          if(k==i&&j!=n-1)continue;\n          r(l,n)if(k!=l){\n            if(a[k][l])c1++;\n            else c2++;\n          }\n          if(c1!=c2)f++;\n        }\n        if(f)continue;\n        if(i==n-2&&j==n-1)ans++;\n        else dfs();\n      }\n      a[i][j]=-1;\n      return;\n    }\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    ans=0;\n    cin>>m;\n    memset(a,-1,sizeof(a));\n    r(i,m){\n      int x,y;\n      cin>>x>>y;\n      x--;y--;\n      a[x][y]=1;\n      a[y][x]=0;\n    }\n    dfs();\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n\nusing namespace std;\n\nint a[20][20],ans,n,m,judge;\n\nvoid dfs(int x,int y)\n{\n    if (x>n)\n    {\n        int sum=0;\n        for (int i=1;i<=n;i++) sum+=a[i][y];\n        if (sum!=judge) return;\n        y++;x=y+1;\n    }\n    if (y==n)\n    {\n        int sum=0;\n        for (int i=1;i<=n;i++) sum+=a[i][y];\n        if (sum==judge) ans++;\n        return;\n    }\n\n    if (a[x][y]==0)\n    {\n        a[x][y]=2;a[y][x]=-1;\n        dfs(x+1,y);\n        a[x][y]=-1;a[y][x]=2;\n        dfs(x+1,y);\n        a[x][y]=a[y][x]=0;\n    }\n    else dfs(x+1,y);\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    while (cin>>n)\n    {\n        if (n==0) break;\n        cin>>m;\n        memset(a,0,sizeof(a));\n        for (int i=1;i<=n;i++) a[i][i]=3;\n        while (m--)\n        {\n            int x,y;\n            cin>>x>>y;\n            a[x][y]=2;a[y][x]=-1;\n        }\n\n        ans=0;judge=n/2+3;\n        dfs(2,1);\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n#include<functional>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nint win[10], lose[10], table[10][10], save[50], n, m, k, ans;\n\nvoid dfs(int x,int f)\n{\n\tif (x == k + 1)\n\t{\n\t\tint ok = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (win[i] != n / 2 || lose[i] != n / 2) ok = 0;\n\t\tif (ok) ans++;\n\t\treturn;\n\t}\n\tint i = save[x] / n + 1; int j = save[x]%n + 1;\n\tif (f == 1)\n\t{\n\t\twin[i]++; lose[j]++;\n\t}\n\telse\n\t{\n\t\twin[j]++; lose[i]++;\n\t}\n\tif (win[i] > n / 2 || lose[i] > n / 2 || win[j] > n / 2 || lose[j] > n / 2)\n\t{\n\t\tif (f == 1)\n\t\t{\n\t\t\twin[i]--; lose[j]--;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twin[j]--; lose[i]--;\n\t\t\treturn;\n\t\t}\n\t}\n\tdfs(x + 1, 1);\n\tdfs(x + 1, 0);\n\tif (f == 1)\n\t{\n\t\twin[i]--; lose[j]--;\n\t}\n\telse\n\t{\n\t\twin[j]--; lose[i]--;\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\twhile (1)\n\t{\n\t\tcin >> n >> m;\n\t\tif (!n) break;\n\t\tmemset(win, 0, sizeof(win));\n\t\tmemset(lose, 0, sizeof(lose));\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\ttable[i][j] = -1;\n\t\tfor (int i = 1; i <= m; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttable[x][y] = 1; table[y][x] = 0;\n\t\t\twin[x]++; lose[y]++;\n\t\t}\n\t\tk = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\t\tif (table[i][j] == -1) save[++k] = (i - 1)*n + j - 1;\n\t\tans = 0;\n\t\tdfs(1, 1);\n\t\tdfs(1, 0);\n\t\tcout << ans/2 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint grid[50][50];\nint n, m;\n\nbool check(int y) {\n    int win = 0, draw = 0;\n    for (int x = 0; x < n; x++) {\n        if (y == x) continue;\n        if (grid[y][x] == 1) win++;\n        if (grid[y][x] == 0) draw++;\n    }\n    return win <= (n - 1) / 2 && win + draw >= (n - 1) / 2;\n}\n\nll ans;\nvoid dfs(int cur) {\n    int x = cur % n;\n    int y = cur / n;\n    if (cur == n * n) {\n        ans++;\n        return;\n    }\n    // 自分自身 or 既に埋まってる\n    if (y == x || grid[y][x] != 0) {\n        if (check(y)) dfs(cur + 1);\n        return;\n    }\n    grid[y][x] = 1;\n    grid[x][y] = -1;\n    if (check(y)) dfs(cur + 1);\n    grid[y][x] = -1;\n    grid[x][y] = 1;\n    if (check(y)) dfs(cur + 1);\n    grid[y][x] = grid[x][y] = 0;\n}\n\nint main() {\n    while (cin >> n, n) {\n        cin >> m;\n        memset(grid, 0, sizeof(grid));\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            grid[x][y] = 1;\n            grid[y][x] = -1;\n        }\n        ans = 0;\n        dfs(0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 1627.cc: Playoff by all the teams\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 9;\nconst int MAX_M = MAX_N * (MAX_N - 1) / 2;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\n\n/* global variables */\n\nint wns[MAX_N], lns[MAX_N], h, cnt;\nbool mts[MAX_N][MAX_N];\npii ps[MAX_M];\n\n/* subroutines */\n\nvoid rec(int u) {\n  if (u < 0) {\n    cnt++;\n    return;\n  }\n\n  int &x = ps[u].first, &y = ps[u].second;\n\n  if (wns[x] < h && lns[y] < h) {\n    wns[x]++, lns[y]++;\n    rec(u - 1);\n    wns[x]--, lns[y]--;\n  }\n  if (wns[y] < h && lns[x] < h) {\n    wns[y]++, lns[x]++;\n    rec(u - 1);\n    wns[y]--, lns[x]--;\n  }\n}\n\n/* main */\n\nint main() {\n  for (int n; scanf(\"%d\", &n) == 1 && n > 0;) {\n    memset(wns, 0, sizeof(wns));\n    memset(lns, 0, sizeof(lns));\n    memset(mts, false, sizeof(mts));\n\n    int m;\n    scanf(\"%d\", &m);\n\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      x--, y--;\n      wns[x]++, lns[y]++;\n      mts[x][y] = mts[y][x] = true;\n    }\n\n    h = (n - 1) / 2;\n    bool ok = true;\n    for (int i = 0; ok && i < n; i++)\n      ok = (wns[i] <= h && lns[i] <= h);\n    if (! ok) {\n      puts(\"0\");\n      continue;\n    }\n\n    int l = 0;\n    for (int i = 0; i < n; i++)\n      for (int j = i + 1; j < n; j++)\n\tif (! mts[i][j])\n\t  ps[l++] = pii(i, j);\n    //printf(\"l=%d\\n\", l);\n\n    cnt = 0;\n    rec(l - 1);\n    printf(\"%d\\n\", cnt);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\nvoid solve(int n) {\n    int m; cin >> m;\n    vector<int> x(m),y(m);\n    rep (i,m) cin >> x[i] >> y[i], --x[i],--y[i];\n\n    auto a = make_v<int,2>(n,n);\n    rep (i,m) a[x[i]][y[i]] = a[y[i]][x[i]] = 1;\n\n    vector<pair<int,int>> es;\n    rep (i,n) rep (j,n) if (i < j && a[i][j] == 0) es.eb(i,j);\n\n    int N = es.size();\n    int N0 = N/2, N1 = N-N0;\n\n    map<vector<int>,int> cnt;\n    rep (s,1LL<<N0) {\n        vector<int> win(n);\n        rep (i,m) win[x[i]]++;\n        rep (i,N0) {\n            if (s>>i&1) {\n                win[es[i].fst]++;\n            } else {\n                win[es[i].snd]++;\n            }\n        }\n        rep (i,n) win[i] = (n-1)/2 - win[i];\n        if (all_of(all(win), [&](int val) { return val >= 0; })) {\n            cnt[win]++;\n        }\n    }\n\n    int ans = 0;\n    rep (s,1LL<<N1) {\n        vector<int> win(n);\n        rep (i,N1) {\n            if (s>>i&1) {\n                win[es[N0+i].fst]++;\n            } else {\n                win[es[N0+i].snd]++;\n            }\n        }\n        ans += cnt[win];\n    }\n\n    cout << ans << endl;\n\n}\n\nint32_t main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nint ans = 0;\nvector<P> score;\nbool used[36];\nP ctom[36];\n\nint convert(int a, int b) {\n\t//チームaとチームbの試合の通し番号 a < b\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (i == a && b == j) {\n\t\t\t\treturn cnt;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid dfs(int match, vector<P> S){\n\n\tif (match == (n - 1) * n / 2) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (S[i].first != S[i].second)return;\n\t\t}\n\t\tans++;\n\t\treturn;\n\t}\n\n\tif (used[match]) {\n\t\tdfs(match + 1, S);\n\t\treturn;\n\t}\n\n\tint a = ctom[match].first, b = ctom[match].second;\n\t//a勝b敗\n\tauto Scpy = S;\n\tif (Scpy[a].first < (n - 1) / 2 && Scpy[b].second < (n - 1) / 2) {\n\t\tScpy[a].first++, Scpy[b].second++;\n\t\tdfs(match + 1, Scpy);\n\t}\n\n\t//b勝a敗\n\tScpy = S;\n\tif (Scpy[b].first < (n - 1) / 2 && Scpy[a].second < (n - 1) / 2) {\n\t\tScpy[b].first++, Scpy[a].second++;\n\t\tdfs(match + 1, Scpy);\n\t}\n\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\t\tcin >> m;\n\t\tscore.resize(n);\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tctom[cnt] = P(i, j);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--, b--;\n\t\t\tscore[a].first++, score[b].second++;\n\t\t\tused[convert(min(a, b), max(a, b))] = true;\n\t\t}\n\t\t\n\t\tdfs(0, score);\n\t\t\n\t\tcout << ans << endl;\n\n\t\tscore.clear();\n\t\tfor (int i = 0; i < 36; i++)used[i] = false;\n\t\tans = 0;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass ScoreBoard{\npublic:\n    //  1: win\n    // -1: lose\n    // enum\n    vector<vector<int>> board;\n    vector<int> wincounts;\n    \n    ScoreBoard(int N){\n        board = vector<vector<int>>(N, vector<int>(N));\n        wincounts.resize(N);\n    }\n    void update(int x, int y){\n        board[x][y] = 1;\n        board[y][x] = -1;\n        wincounts[x]++;\n    }\n    void remove(int x, int y){\n        board[x][y] = board[y][x] = 0;\n        wincounts[x]--;\n    }\n    bool allok(){\n        for(int i=0; i<board.size(); i++)\n            if(wincounts[i] > (board.size()-1)/2)\n                return false;\n        return true;\n    }\n    bool ok(int x, int y){\n        return wincounts[x] < (board.size()-1)/2;\n    }\n    void view(){\n        cout << \"============\" << endl;\n        for(int x=0; x<board.size(); x++){\n            for(int y=0; y<board.size(); y++){\n                if(x == y)\n                    cout << \". \";\n                else\n                    cout << (board[x][y]==1) << \" \";\n            }\n            cout << endl;\n        }\n    }\n    int dfs(vector<int> &X, vector<int> &Y, int idx){\n        if(X.size() == idx){\n//            view();\n            return 1;\n        }\n        \n        int res = 0;\n        if(ok(X[idx], Y[idx])){\n            update(X[idx], Y[idx]);\n            res += dfs(X, Y, idx+1);\n            remove(X[idx], Y[idx]);\n        }\n        if(ok(Y[idx], X[idx])){\n            update(Y[idx], X[idx]);\n            res += dfs(X, Y, idx+1);\n            remove(Y[idx], X[idx]);\n        }\n        return res;\n    }\n};\n\n\nint main(){\n    int N, M;\n    while(cin >> N, N){\n        cin >> M;\n        auto sb = ScoreBoard(N);\n        \n        for(int i=0; i<M; i++){\n            int x, y; cin >> x >> y;\n            x--; y--;\n            sb.update(x, y);\n        }\n        \n        vector<int> X, Y;\n        for(int x=0; x<N; x++){\n            for(int y=x+1; y<N; y++){\n                if(sb.board[x][y] != 0)\n                    continue;\n                X.push_back(x);\n                Y.push_back(y);\n            }\n        }\n        if(sb.allok())\n            cout << sb.dfs(X, Y, 0) << endl;\n        else\n            cout << 0 << endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vi = std::vector<int>;\n\tusing vvi = std::vector<vi>;\n\n\tint n, m;\n\tvvi mat;\n\tvi win, lose;\n\n\tint rc(int index)\n\t{\n\t\tif (index == n) return 1;\n\t\tif (n / 2 < lose[index] || n / 2 < win[index]) return 0;\n\t\tvi undefined;\n\t\tfor (int i{}; i < n; i++)\n\t\t\tif (i != index && mat[index][i] < 0)\n\t\t\t\tundefined.push_back(i);\n\t\tstd::vector<int> result;\n\t\tfor (int i{}; i < n / 2 - lose[index]; i++)\n\t\t\tresult.push_back(0);\n\t\tfor (int i{}; i < n / 2 - win[index]; i++)\n\t\t\tresult.push_back(1);\n\t\tint ret{};\n\t\tdo\n\t\t{\n\t\t\tfor (int i{}; i < (int)undefined.size(); i++)\n\t\t\t{\n\t\t\t\tmat[index][undefined[i]] = result[i];\n\t\t\t\tmat[undefined[i]][index] = 1 - result[i];\n\t\t\t\tif (result[i]) lose[undefined[i]]++;\n\t\t\t\telse win[undefined[i]]++;\n\t\t\t}\n\t\t\tret += rc(index + 1);\n\t\t\tfor (int i{}; i < (int)undefined.size(); i++)\n\t\t\t\tif (result[i]) lose[undefined[i]]--;\n\t\t\t\telse win[undefined[i]]--;\n\t\t} while (std::next_permutation(result.begin(), result.end()));\n\t\tfor (auto& e: undefined)\n\t\t\tmat[index][e] = mat[e][index] = -1;\n\t\treturn ret;\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tmat.resize(n, vi(n, -1));\n\t\twin.resize(n);\n\t\tlose.resize(n);\n\t\tfor (int i{}; i < m; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tx--; y--;\n\t\t\tmat[x][y] = 1;\n\t\t\twin[x]++;\n\t\t\tmat[y][x] = 0;\n\t\t\tlose[y]++;\n\t\t}\n\t\tprintf(\"%d\\n\", rc(0));\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, m, ans, table[9][9];\n\nint chack(){\n\tfor(int i=0; i<n; i++){\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; j++) tmp += table[i][j];\n\t\tif(tmp) return 0;\n\t}\n\treturn 1;\n}\n\n\nvoid dfs(int x, int y){\n\tif(y < n-1) y++;\n\telse if(x < n-1){\n\t\ty=0;\n\t\tx++;\n\t} else{\n\t\tans += chack();\n\t\treturn;\n\t}\n\n\tif(y==0 && 0<x){\n\t\tint tmp =0;\n\t\tfor(int i=0; i<n; i++) tmp += table[x-1][i];\n\t\tif(tmp) return;\n\t}\n\n\tif(table[x][y] == 0 && x != y){\n\t\ttable[x][y] = 1;\n\t\ttable[y][x] = -1;\n\t\tdfs(x, y);\n\n\t\ttable[x][y] = -1;\n\t\ttable[y][x] = 1;\n\t\tdfs(x, y);\n\n\t\ttable[x][y] = table[y][x] = 0;\n\t} else dfs(x, y);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfill(table[0], table[8], 0);\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\ttable[x][y] = 1;\n\t\t\ttable[y][x] = -1;\n\t\t}\n\n\t\tans = 0;\n\t\tdfs(0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n \nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\n\nInt n;\n\nInt cnt;\n\nvoid rec(vector<vector<Int>> v, vector<Int> win, vector<Int> lose, Int h) {\n    if (h == n) {\n        cnt++;\n        return;\n    }\n    vector<Int> det;\n    for (Int i = 0; i < n; i++) {\n        if (i == h) continue;\n        if (v[h][i] == 0) {\n            det.push_back(i);\n        }\n    }\n    Int m = det.size();\n    for (Int bit = 0; bit < (1<<m); bit++) {\n        Int w, l;\n        w = l = 0;\n        for (Int i = 0; i < m; i++) {\n            if (bit & (1<<i)) {\n                w++;\n            } else {\n                l++;\n            }\n        }\n        if (win[h] + w != lose[h] + l) continue;\n        bool check = true;\n        for (Int i = 0; i < m; i++) {\n            if (bit & (1<<i)) {\n                v[h][det[i]] = 1;\n                v[det[i]][h] = -1;\n                win[h]++;\n                lose[det[i]]++;\n            } else {\n                v[h][det[i]] = -1;\n                v[det[i]][h] = 1;\n                win[det[i]]++;\n                lose[h]++;\n            }\n            if (win[det[i]] > n / 2 or lose[det[i]] > n / 2) {\n                check = false;\n            }\n        }\n        if (check) {\n            rec(v, win, lose, h + 1);\n        }\n        for (Int i = 0; i < m; i++) {\n            if (bit & (1<<i)) {\n                v[h][det[i]] = 0;\n                v[det[i]][h] = 0;\n                win[h]--;\n                lose[det[i]]--;\n            } else {\n                v[h][det[i]] = 0;\n                v[det[i]][h] = 0;\n                win[det[i]]--;\n                lose[h]--;\n            }\n        }\n    }\n}\n\nint main() {\n    vector<Int> res;\n    while (cin >> n and n) {\n        Int m;\n        cin >> m;\n        vector<vector<Int>> v(n, vector<Int>(n, 0));\n        vector<Int> win(n, 0), lose(n, 0);\n        bool check = false;\n        for (Int i = 0; i < m; i++) {\n            Int a, b;\n            cin >> a >> b;\n            a--, b--;\n            v[a][b] = 1;\n            v[b][a] = -1;\n            win[a]++;\n            lose[b]++;\n            if (win[a] > n / 2 or lose[b] > n / 2) {\n                check = true;\n            }\n        }\n        if (check) {\n            res.push_back(0);\n            continue;\n        }\n        rec(v, win, lose, 0);\n        res.push_back(cnt);\n        cnt = 0;\n    }\n    for (Int i = 0; i < (Int)res.size(); i++) {\n        dump(res[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nbool mark; \nint n,m,mp[15][15],win[15],lose[15],k,x,y;\n\nll dfs(int x,int y)\n{\n\t//printf(\"%d %d !!\\n\",x,y);\n\tbool markk=1;\n\tll temp=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(win[i]<(n/2))\t{markk=0;break;}\n\tif(markk)\treturn 1;\n\tfor(int i=x;i<=n;i++) \n\t{\n\t\tfor(int j=y;j<=n;j++) \n\t\t{\n\t\t\tif(mp[i][j]!=0||i==j)\tcontinue;\n\t\t\tif((win[i]<(n/2)&&win[i]>=0)&&(lose[j]<(n/2)&&lose[j]>=0)) \n\t\t\t{\n\t\t\t\tmp[i][j]=1;\n\t\t\t\tmp[j][i]=-1;\n\t\t\t\twin[i]++;\n\t\t\t\tlose[j]++;\n\t\t\t\ttemp=temp+dfs(i,j);\n\t\t\t\tmp[i][j]=0;\n\t\t\t\tmp[j][i]=0;\n\t\t\t\tlose[j]--;\n\t\t\t\twin[i]--;\n\t\t\t\tmarkk=1;\n\t\t\t}\n\t\t\tif((win[j]<(n/2)&&lose[i]>=0)&&(lose[i]<(n/2)&&win[j]>=0)) \n\t\t\t{\n\t\t\t\tmp[i][j]=-1;\n\t\t\t\tmp[j][i]=1;\n\t\t\t\tlose[i]++;\n\t\t\t\twin[j]++;\n\t\t\t\ttemp=temp+dfs(i,j);\n\t\t\t\tmp[i][j]=0; \n\t\t\t\tmp[j][i]=0;\n\t\t\t\twin[j]--;\n\t\t\t\tlose[i]--;\n\t\t\t\tmarkk=1;\n\t\t\t}\n\t\t\tif(markk)\tbreak;\n\t\t}\n\t\tif(markk)\tbreak;\n\t\ty=1; \n\t}\n\treturn temp;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tmark=0; \n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<15;i++)\n\t\t\tfor(int j=0;j<15;j++)\n\t\t\t\tmp[i][j]=0;\n\t\tmemset(lose,0,sizeof(lose));\n\t\tmemset(win,0,sizeof(win));\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tmp[x][y]=1;\n\t\t\tmp[y][x]=-1;\n\t\t\twin[x]+=1;\n\t\t\tlose[y]+=1;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(win[i]>(n/2)||lose[i]>(n/2))\n\t\t\t{\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tmark=1;\n\t\t\t}\n\t\t} \n\t\t\tif(mark) continue;//特判剪枝 \n\t\telse printf(\"%lld\\n\",dfs(1,1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint n,m;\nint x[110],y[110];\nint t[10][10];\nint win[10],lose[10];\n\nvoid print() {\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << t[i][j] << \" \\n\"[j+1==n];\n    }\n  }\n  cout << \"win : \";\n  for (int i = 0; i < n; i++) {\n    cout << win[i] << \" \\n\"[i+1==n];\n  }\n}\n\nint dfs(int p, int q) {\n  bool ok = true;\n  for (int i = 0; i < n; i++) {\n    if (win[i] < (n-1)/2) ok = false;\n  }\n  if (ok) return 1;\n  int res = 0;\n  if (t[p][q]) {\n    if (q+1 == n) res += dfs(p+1,p+2);\n    else res += dfs(p,q+1);\n  } else {\n    if (win[p] < (n-1)/2 && lose[q] < (n-1)/2) {\n      t[p][q] = 1; t[q][p] = -1;\n      win[p]++; lose[q]++;\n      if (q+1 == n) res += dfs(p+1,p+2);\n      else res += dfs(p,q+1);\n      win[p]--; lose[q]--;\n      t[p][q] = 0; t[q][p] = 0;\n    }\n    if (win[q] < (n-1)/2 && lose[p] < (n-1)/2) {\n      t[p][q] = -1; t[q][p] = 1;\n      win[q]++; lose[p]++;\n      if (q+1 == n) res += dfs(p+1,p+2);\n      else res += dfs(p,q+1);\n      win[q]--; lose[p]--;\n      t[p][q] = 0; t[q][p] = 0;\n    }\n  }\n  return res;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> n, n) {\n    cin >> m;\n    REP(i,m) cin >> x[i] >> y[i], x[i]--, y[i]--;\n    ZERO(t);\n    ZERO(win);\n    ZERO(lose);\n    REP(i,m) {\n      t[x[i]][y[i]] = 1;\n      t[y[i]][x[i]] = -1;\n      win[x[i]]++;\n      lose[y[i]]++;\n    }\n    cout << dfs(0,1) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass ScoreBoard{\npublic:\n    //  1: win\n    // -1: lose\n    // enum\n    vector<vector<int>> board;\n    vector<int> wincounts;\n    vector<int> X, Y;\n    \n    ScoreBoard(int N){\n        board = vector<vector<int>>(N, vector<int>(N));\n        wincounts.resize(N);\n    }\n    inline void update(int x, int y){\n        board[x][y] = 1;\n        board[y][x] = -1;\n        wincounts[x]++;\n    }\n    inline void remove(int x, int y){\n        board[x][y] = board[y][x] = 0;\n        wincounts[x]--;\n    }\n    inline bool allok(){\n        for(int i=0; i<board.size(); i++)\n            if(wincounts[i] > (board.size()-1)/2)\n                return false;\n        return true;\n    }\n    inline bool ok(int x, int y){\n        return wincounts[x] < (board.size()-1)/2;\n    }\n    void view(){\n        cout << \"============\" << endl;\n        for(int x=0; x<board.size(); x++){\n            for(int y=0; y<board.size(); y++){\n                if(x == y)\n                    cout << \". \";\n                else\n                    cout << (board[x][y]==1) << \" \";\n            }\n            cout << endl;\n        }\n    }\n    void init(){\n        for(int x=0; x<board.size(); x++){\n            for(int y=x+1; y<board.size(); y++){\n                if(board[x][y] != 0)\n                    continue;\n                X.push_back(x);\n                Y.push_back(y);\n            }\n        }\n    }\n    int dfs(int idx){\n        if(X.size() == idx){\n//            view();\n            return 1;\n        }\n        \n        int res = 0;\n        if(ok(X[idx], Y[idx])){\n            update(X[idx], Y[idx]);\n            res += dfs(idx+1);\n            remove(X[idx], Y[idx]);\n        }\n        if(ok(Y[idx], X[idx])){\n            update(Y[idx], X[idx]);\n            res += dfs(idx+1);\n            remove(Y[idx], X[idx]);\n        }\n        return res;\n    }\n};\n\n\nint main(){\n    int N, M;\n    while(cin >> N, N){\n        cin >> M;\n        auto sb = ScoreBoard(N);\n        \n        for(int i=0; i<M; i++){\n            int x, y; cin >> x >> y;\n            x--; y--;\n            sb.update(x, y);\n        }\n        sb.init();\n        if(sb.allok())\n            cout << sb.dfs(0) << endl;\n        else\n            cout << 0 << endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = (1e+9) + 7;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-4;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint n,c[9];\nbool skip[9][9];\nint nx, ny;\nvoid next(int x, int y) {\n\tnx = x; ny = y + 1;\n\tif (ny == nx) {\n\t\tnx++; ny = 0;\n\t}\n}\nint key;\nbool valid() {\n\trep(i, n) {\n\t\tif (c[i] > key)return false;\n\t}\n\treturn true;\n}\nint dfs(int x, int y) {\n\tif (!valid())return 0;\n\tif (x == n)return 1;\n\tnext(x, y);\n\tint tx = nx, ty = ny;\n\tif (skip[x][y])return dfs(tx, ty);\n\tint res = 0;\n\tc[x]++; res += dfs(tx, ty);\n\tc[x]--; c[y]++; res+=dfs(tx, ty);\n\tc[y]--;\n\treturn res;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\trep(i, n) {\n\t\t\tc[i] = 0;\n\t\t\trep(j, n) {\n\t\t\t\tskip[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tint m; cin >> m; key = (n - 1) / 2;\n\t\trep(i, m) {\n\t\t\tint x, y; cin >> x >> y; x--; y--;\n\t\t\tc[x]++;\n\t\t\tif (x < y)swap(x, y);\n\t\t\tskip[x][y] = true;\n\t\t}\n\t\t//cout << \"ans\" << endl;\n\t\tcout << dfs(1, 0) << endl;\n\t}\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n\nint N, M, A[9][9];\n//---------------------------------------------------------------------------------------------------\nint check(int y) {\n    int win = 0, non = 0;\n    rep(x, 0, N) {\n        if (A[y][x] == 1) win++;\n        else if (A[y][x] < 0 and y != x) non++;\n    }\n    return win <= (N - 1) / 2 and (N - 1) / 2 <= win + non;\n}\n//---------------------------------------------------------------------------------------------------\nint ans = 0;\nvoid dfs(int cu) {\n    int x = cu % N;\n    int y = cu / N;\n\n    if (cu == N * N) {\n        ans++;\n        return;\n    }\n\n    if (x == y or 0 <= A[y][x]) {\n        if (check(y)) dfs(cu + 1);\n        return;\n    }\n    \n    A[y][x] = 1; A[x][y] = 0;\n    if(check(y)) dfs(cu + 1);\n\n    A[y][x] = 0; A[x][y] = 1;\n    if (check(y)) dfs(cu + 1);\n\n    A[y][x] = A[x][y] = -1;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> N) {\n        if (N == 0) return;\n        cin >> M;\n        rep(i, 0, N) rep(j, 0, N) A[i][j] = -1;\n        rep(i, 0, M) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            A[a][b] = 1;\n            A[b][a] = 0;\n        }\n\n        ans = 0;\n        dfs(0);\n        printf(\"%d\\n\", ans);\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint xy[9][9];\nint n,m;\nint dfs(int k, int x, int y){\n  int ans = 0;\n\n  if(k == n*(n-1) - 2*m){\n    int t = 0;\n    for(int i = 0; i < n; i++){\n      int s = 0;\n      if(i == 0) for(int j = 0; j < n; j++) t += xy[i][j];\n      else{\n        for(int j = 0; j < n; j++){\n          s += xy[i][j];\n        }\n        if(s != t) return 0;\n      }\n    }\n    return 1;\n  }\n  for(int i = 0; i < x ; i++){\n    int cnt = 0;\n    for(int j = 0; j < n; j++){\n      if(xy[i][j] == 1) cnt++;\n    }\n    if(cnt != (n-1)/2 ) return 0;\n  }\n  for(int i = x; i < n; i++){\n    for(int j = x ; j < n ; j++){\n      if(i == x && j < y) j = y;\n      if(i == j || xy[i][j] != 0 || j >= n) continue;\n      xy[i][j] = 1;\n      xy[j][i] = -1;\n      ans += dfs(k+2, i, j);\n      xy[i][j] = -1;\n      xy[j][i] = 1;\n      ans += dfs(k+2, i, j);\n      xy[i][j] = 0;\n      xy[j][i] = 0;\n      return ans;\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> n&& n != 0){\n    cin >> m;\n    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) xy[i][j] = 0;\n    for(int i = 0; i < m ; i++){\n      int x,y;\n      cin >> x >> y;\n      x--;\n      y--;\n      xy[x][y] = 1;\n      xy[y][x] = -1;\n    }\n    cout << dfs(0, 0, 0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll n,m,dp[10][10],a,b,ans;\nll f(void){\n    ll cnt=0;\n    for(int i=0;i<n;i++){\n        ll w=0,l=0;\n        for(int j=0;j<n;j++){\n            if(i==j)continue;\n            if(dp[i][j]==1)w++;\n            if(dp[i][j]==-1)l++;\n            if(dp[i][j]==0)cnt++;\n        }\n        if(n/2<l||n/2<w)return 0;\n    }\n    if(cnt==0)return 2;\n    return 1;\n}\nvoid dfs(void){\n    //cout<<f()<<endl;\n    if(f()==0)return ;\n    if(f()==2){\n        ans++;\n        /*\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cout<<dp[i][j];\n            }\n            cout<<endl;\n        }\n        */\n        return ;\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;j<i;j++){\n            if(i!=j&&dp[i][j]==0){\n                dp[i][j]=1;\n                dp[j][i]=-1;\n                dfs();\n                dp[i][j]=-1;\n                dp[j][i]=1;\n                dfs();\n                dp[i][j]=0;\n                dp[j][i]=0;\n                return ;\n            }\n        }\n    }\n}\nint main(void){\n    while(1){\n        ans=0;\n        cin>>n;\n        if(n==0)return 0;\n        cin>>m;\n        for(int i=0;i<m;i++){\n            cin>>a>>b;\n            a--,b--;\n            dp[a][b]=1;\n            dp[b][a]=-1;\n        }\n        dfs();\n        cout<<ans<<endl;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                dp[i][j]=0;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint n, m;\narray<array<int, 10>, 10> v{};\nvector<int> wins;\nint dfs(int i) {\n    if(i == n) {\n        return 1;\n    }\n    int ans = 0;\n    vector<int> w;\n    for (int j = 0; j < n; ++j) {\n        if(i != j && !v[i][j]) w.emplace_back(j);\n    }\n    for (int mask = 0; mask < (1<<w.size()); ++mask) {\n        if(wins[i] + __builtin_popcount(mask) != n/2) continue;\n        for (int j = 0; j < w.size(); ++j) {\n            v[i][w[j]] = ((mask>>j)&1)+1;\n            v[w[j]][i] = 2-((mask>>j)&1);\n            wins[((mask>>j)&1) ? i : w[j]]++;\n        }\n        ans += dfs(i+1);\n        for (int j = 0; j < w.size(); ++j) {\n            v[i][w[j]] = v[w[j]][i] = 0;\n            wins[((mask>>j)&1) ? i : w[j]]--;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while(cin >> n, n){\n        cin >> m;\n        wins.resize(n);\n\n        for (int i = 0; i < n; ++i) {\n            wins[i] = 0;\n            for (int j = 0; j < n; ++j) {\n                v[i][j] = 0;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int x, y;\n            cin >> x >> y;\n            x--; y--;\n            v[x][y] = 2;\n            v[y][x] = 1;\n            wins[x]++;\n        }\n\n        cout << dfs(0) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    int m; cin >> m;\n    VV<> v(n);\n    for (int i = 0; i < m; ++i) {\n      int x, y; cin >> x >> y, --x, --y;\n      v[x].push_back(y);\n    }\n    V< bitset<9> > a(n);\n    int res = 0;\n    auto dfs = [&](const auto& dfs, int i) -> void {\n      if (i == n) {\n        ++res;\n        return;\n      }\n      int s = 0;\n      for (int j = 0; j < i; ++j) {\n        s += a[i][j] = !a[j][i];\n      }\n      if (s > n / 2 or i - s > n / 2) return;\n      V<> p(n / 2 - s, 1);\n      while (p.size() < n + ~i) p.push_back(0);\n      sort(begin(p), end(p));\n      do {\n        for (int j = 0; j < n + ~i; ++j) {\n          a[i][i + 1 + j] = p[j];\n        }\n        bool b = true;\n        for (int j : v[i]) if (!a[i][j]) {\n          b = false;\n          break;\n        }\n        if (b) dfs(dfs, i + 1);\n      } while (next_permutation(begin(p), end(p)));\n    };\n    dfs(dfs, 0);\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nint n, max_cnt, cnt;\n\nint next(int pos) {\n    int i = pos / n, j = pos % n;\n    if (j + 1 < i) return i * n + j + 1;\n    else if (i == n - 1) return -1;\n    else return (i + 1) * n + 0;\n}\n\nvoid dfs(int pos, vvi wl, vi cnt_w, vi cnt_l) {\n    if (pos == -1) {\n        cnt++;\n        return;\n    }\n    int i = pos / n, j = pos % n;\n    if (wl[i][j] == 0) {\n        if (cnt_w[i] < max_cnt && cnt_l[j] < max_cnt) {\n            wl[i][j] = 1; cnt_w[i]++;\n            wl[j][i] = -1; cnt_l[j]++;\n            dfs(next(pos), wl, cnt_w, cnt_l);\n            wl[i][j] = 0; cnt_w[i]--;\n            wl[j][i] = 0; cnt_l[j]--;\n        }\n        if (cnt_l[i] < max_cnt && cnt_w[j] < max_cnt) {\n            wl[j][i] = 1; cnt_w[j]++;\n            wl[i][j] = -1; cnt_l[i]++;\n            dfs(next(pos), wl, cnt_w, cnt_l);\n            wl[j][i] = 0; cnt_w[j]--;\n            wl[i][j] = 0; cnt_l[i]--;\n        }\n    } else {\n        bool ok = cnt_w[i] <= max_cnt && cnt_l[i] <= max_cnt;\n        ok &= cnt_w[j] <= max_cnt && cnt_l[j] <= max_cnt;\n        if (ok) dfs(next(pos), wl, cnt_w, cnt_l);\n    }\n}\n\nint main() {\n    while (cin >> n, n) {\n        max_cnt = (n - 1) / 2;\n        cnt = 0;\n        vvi wl(n, vi(n, 0));\n        vi cnt_w(n), cnt_l(n);\n        int m; cin >> m;\n        while (m--) {\n            int x, y; cin >> x >> y; x--, y--;\n            wl[x][y] = 1; cnt_w[x]++;\n            wl[y][x] = -1; cnt_l[y]++;\n        }\n        dfs(next(0), wl, cnt_w, cnt_l);\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\nclass Solve {\npublic:\n    int N;\n\n    vector<vector<int>> pattern;\n    vector<vector<int>> table;\n\n\n    void input() {\n        pattern.resize(N, vector<int>(N, -1));\n        table.resize(N, vector<int>(N, -1));\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; ++i) {\n            int a, b;\n            cin >> a >> b;\n            a--, b--;\n            pattern[a][b] = 1;\n            pattern[b][a] = 0;\n        }\n    }\n\n    // 上からn段目を見ている\n    // rec(1)が答えのつもり\n    int rec(int n) {\n//        cerr << n << endl;\n        if (n == N) {\n            // tableの数を数えておｋなら1を返す\n            int win = 0, lose = 0;\n            for (int i = 0; i < N; ++i) {\n                if (i == n - 1) continue;\n                if (table[n - 1][i]) win++;\n                else lose++;\n            }\n            return win == lose;\n        }\n\n        int bs = N - n;\n        int ret = 0;\n\n        for (int bit = 0; bit < 1 << bs; ++bit) {\n            //tableに代入\n            for (int i = n; i < N; ++i) {\n                table[n - 1][i] = bit >> (i - n) & 1;\n                table[i][n - 1] = !(bit >> (i - n) & 1);\n            }\n            int win = 0, lose = 0;\n            for (int i = 0; i < N; ++i) {\n                if (i == n - 1) continue;\n                if (table[n - 1][i]) win++;\n                else lose++;\n            }\n\n            if (win != lose) continue;\n            bool flag = true;\n            for (int i = 0; i < N; ++i) {\n                if (i == n - 1) continue;\n                if (pattern[n - 1][i] == -1) continue;\n                if (pattern[n - 1][i] != table[n - 1][i]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (!flag) continue;\n\n//            cerr << \"bit\" << bit << endl;\n            ret += rec(n + 1);\n        }\n        return ret;\n    }\n\n\n    bool solve() {\n        cin >> N;\n        if (N == 0) return false;\n        input();\n        int ans = rec(1);\n        cout << ans << endl;\n\n        return true;\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (Solve().solve()) {};\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint n;\nvector<vector<int>> t;\n\nbool check(int a,int b){\n    int w=0,l=0;\n    for(int j=0;j<n;j++){\n        if(t[a][j]==1)w++;\n        if(t[a][j]==-1)l++;\n    }\n    if(w>(n-1)/2||l>(n-1)/2) {\n        return false;\n    }\n    w=0,l=0;\n    for(int j=0;j<n;j++){\n        if(t[b][j]==1)w++;\n        if(t[b][j]==-1)l++;\n    }\n    if(w>(n-1)/2||l>(n-1)/2) {\n        return false;\n    }\n    return true;\n}\n\nint dfs(int x,int y){\n    int ans=0;\n\n    if(t[x][y]!=0){\n        if(check(x,y)) {\n            if (x == n-1 && y == n - 2) {\n                return 1;\n            }else{\n                if(y+1==x){\n                    ans+=dfs(x+1,0);\n                }else{\n                    ans+=dfs(x,y+1);\n                }\n            }\n            return ans;\n        }else{\n            return 0;\n        }\n    }else{\n        t[x][y]=1;\n        t[y][x]=-1;\n        bool f=check(x,y);\n        if(f){\n            if(x==n-1&&y==n-2){\n                t[x][y]=0;\n                t[y][x]=0;\n                return 1;\n            }else{\n                if(y+1==x){\n                    ans+=dfs(x+1,0);\n                }else{\n                    ans+=dfs(x,y+1);\n                }\n            }\n        }\n        t[x][y]=-1;\n        t[y][x]=1;\n        f=check(x,y);\n        if(f){\n            if(x==n-1&&y==n-2){\n                t[x][y]=0;\n                t[y][x]=0;\n                return 1;\n            }else{\n                if(y+1==x){\n                    ans+=dfs(x+1,0);\n                }else{\n                    ans+=dfs(x,y+1);\n                }\n            }\n        }\n        t[x][y]=0;\n        t[y][x]=0;\n    }\n\n    return ans;\n}\n\nint main() {\n    while(1){\n        int m;\n        cin >> n;\n        if(n==0){\n            break;\n        }\n        cin>> m;\n        t.clear();\n        t.resize(n,vector<int>(n,0));\n        for(int i=0;i<m;i++){\n            int x,y;\n            cin >> x >> y;\n            x--;y--;\n            t[x][y]=1;\n            t[y][x]=-1;\n        }\n        int ans=dfs(1,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 390624; //44444444(5)\nint main(){\n  while (1){\n    int n;\n    cin >> n;\n    if (n == 0){\n      break;\n    }\n    int m;\n    cin >> m;\n    vector<vector<int>> R(n, vector<int>(n, 0));\n    for (int i = 0; i < m; i++){\n      int x, y;\n      cin >> x >> y;\n      x--;\n      y--;\n      if (x < y){\n        R[x][y] = 1;\n      } else {\n        R[y][x] = -1;\n      }\n    }\n    vector<long long> C(n);\n    C[0] = 1;\n    for (int i = 1; i < n - 1; i++){\n      C[i] = C[i - 1] * 5;\n    }\n    C[n - 1] = 0;\n    vector<long long> dp(MAX + 1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < n; i++){\n      for (int j = i + 1; j < n; j++){\n        vector<long long> dp2(MAX + 1, 0);\n        for (int k = 0; k <= MAX; k++){\n          if (R[i][j] >= 0 && k + C[i] <= MAX){\n            dp2[k + C[i]] += dp[k];\n          }\n          if (R[i][j] <= 0 && k + C[j] <= MAX){\n            dp2[k + C[j]] += dp[k];\n          }\n        }\n        swap(dp, dp2);\n      }\n    }\n    long long p = 0;\n    for (int i = 0; i < n - 1; i++){\n      p += C[i] * ((n - 1) / 2);\n    }\n    cout << dp[p] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll n,m;\nll match[10][10];\n\nint solve(ll y,ll x){\n\tif(y == n-1 && x == n-1){\n\t\t// rep(i,n){\n\t\t// \trep(j,n)cout << match[i][j] << \" \";\n\t\t// \tcout << endl;\n\t\t// }\n\t\t// cout << endl;\n\t\treturn 1;\n\t}\n\tll ny = y;\n\tll nx = x+1;\n\tif(nx == n){\n\t\tnx = 0;\n\t\tny++;\n\t}\n\tif(y == x || match[y][x] != 0)return solve(ny,nx);\n\tll res = 0;\n\tll xwin = 0;\n\tll xlose = 0;\n\tll ywin = 0;\n\tll ylose = 0;\n\trep(i,n){\n\t\tif(match[y][i] == 1)ywin++;\n\t\tif(match[y][i] == -1)ylose++;\n\t}\n\trep(i,n){\n\t\tif(match[x][i] == 1)xwin++;\n\t\tif(match[x][i] == -1)xlose++;\n\t}\n\t// if(ywin > n/2)return 0;\n\t// if(ylose > n/2)return 0;\n\t// if(xwin > n/2)return 0;\n\t// if(xlose > n/2)return 0;\n\n\tif(xwin < n/2 && ylose < n/2){\n\t\tmatch[x][y] = 1;\n\t\tmatch[y][x] = -1;\n\t\tres += solve(ny,nx);\n\t\tmatch[x][y] = 0;\n\t\tmatch[y][x] = 0;\n\t}\n\tif(ywin < n/2 && xlose < n/2){\n\t\tmatch[x][y] = -1;\n\t\tmatch[y][x] = 1;\n\t\tres += solve(ny,nx);\n\t\tmatch[x][y] = 0;\n\t\tmatch[y][x] = 0;\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\trep(i,10)rep(j,10)match[i][j] = 0;\n\t\trep(i,m){\n\t\t\tll x,y;\n\t\t\tcin >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tmatch[x][y] = 1;\n\t\t\tmatch[y][x] = -1;\n\t\t}\n\t\tbool ok = true;\n\t\trep(i,n){\n\t\t\tll lose = 0;\n\t\t\tll win = 0;\n\t\t\trep(j,n){\n\t\t\t\tif(match[i][j] == 1)win++;\n\t\t\t\tif(match[i][j] == -1)lose++;\n\t\t\t}\n\t\t\tok &= (win <= n/2 && lose <= n/2);\n\t\t}\n\t\tif(!ok)cout << 0 << endl;\n\t\telse cout << solve(0,0) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nmap<vector<int>, int> dp;\nvector<vector<int>> data;\n\nint rec(vector<int> win, int id) {\n    if (win.size() == 1 && win[0] == 0) return 1;\n    if (dp.count(win)) return dp[win];\n\n    int n = win.size(), h = win.front();\n    dp[win] = 0;\n\n    for (int pat = 0; pat < (1 << (n - 1)); ++pat) {\n        if (__builtin_popcount(pat) != h) continue;\n\n        bool judge = true;\n        for (int i = 0; i < n - 1; ++i) {\n            int opp = id + i + 1;\n            if (data[id][opp] >= 0 && ((pat >> i) & 1) != data[id][opp]) {\n                judge = false;\n            }\n        }\n\n        auto nwin = win;\n        for (int i = 0; i < n - 1; ++i) {\n            int opp = i + 1;\n            nwin[opp] -= 1 - ((pat >> i) & 1);\n            if (nwin[opp] < 0) judge = false;\n        }\n\n        nwin.erase(nwin.begin());\n        if (judge) dp[win] += rec(nwin, id + 1);\n    }\n\n    return dp[win];\n}\n\nbool solve() {\n    dp.clear();\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n    data.assign(N, vector<int>(N, -1));\n\n    int M;\n    cin >> M;\n    for (int i = 0; i < M; ++i) {\n        int x, y;\n        cin >> x >> y;\n        --x, --y;\n        data[x][y] = 1;\n        data[y][x] = 0;\n    }\n\n\n    vector<int> win(N, N / 2);\n    cout << rec(win, 0) << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; i++)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef long long ll;\nint n,m;\nbool board[9][9];\nmap<vector<int> , int> harf;\nint finishScore[9];\n\nvoid dfs(int x, int y, int cnt, VI score) {\n  if(cnt == n*(n-1)/4){\n    harf[score]++;\n    return;\n  }\n  int nx = x;\n  int ny = y+1;\n  if(ny >= x) ny = 0, nx++;\n\n  if(board[x][y]) dfs(nx,ny,cnt+1,score);\n  else{\n    score[x]++;\n    dfs(nx,ny,cnt+1,score);\n    score[x]--;\n    score[y]++;\n    dfs(nx,ny,cnt+1,score);\n  }\n  return;\n}\n\nll ans = 0;\n\nvoid dfs2(int x, int y, VI score){\n  if(x == n && y == 0){\n    VI pairScore(n);\n    rep(i,n){\n      pairScore[i] = (n-1)/2 - score[i] - finishScore[i];\n      if(pairScore[i] < 0) return;\n    }\n    ans += harf[pairScore];\n    return;\n  }\n\n  int nx = x;\n  int ny = y+1;\n  if(ny == x) ny = 0, nx++;\n\n  if(board[x][y]) dfs2(nx,ny,score);\n  else{\n    score[x]++;\n    dfs2(nx,ny,score);\n    score[x]--;\n    score[y]++;\n    dfs2(nx,ny,score);\n  }\n  return;\n}\n\n\nint main(){\n  while(true){\n    cin >> n;\n    if(n == 0) break;\n\n    memset(board,false,sizeof(board));\n    memset(finishScore,0,sizeof(finishScore));\n    harf.clear();\n\n    cin >> m;\n    rep(i,m){\n      int x,y;\n      cin >> x >> y;\n      x--,y--;\n      board[x][y] = true;\n      board[y][x] = true;\n      finishScore[x]++;\n    }\n\n    VI score(n,0);\n    dfs(1,0,0,score);\n\n    int nx = 1,ny = 0;\n    rep(i,n*(n-1)/4){\n      ny++;\n      if(ny == nx) ny = 0, nx++;\n    }\n\n    dfs2(nx,ny,score);\n\n    cout << ans << endl;\n    ans = 0;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint ans = 0;\nint n;\nchar win[10];\nchar mp[10][10];\n\nvoid dfs(int a,int b){\n\t\t\n\twhile(a == b || mp[a][b] != '-'){\n\t\tb++;\n\t\tif(a == n-1 && b == n-1){\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\tif(b == n){b = 0;a++;}\n\t}\n\tif(win[a] < (n-1) / 2){\n\t\tmp[a][b] = 'o';\n\t\tmp[b][a] = 'x';\n\t\twin[a]++;\n\t\tdfs(a,b+1);\n\t\twin[a]--;\n\t\tmp[a][b] = '-';\n\t\tmp[b][a] = '-';\t\t\t\n\t}\n\tif(win[b] < (n-1) / 2){\n\t\tmp[a][b] = 'x';\n\t\tmp[b][a] = 'o';\n\t\twin[b]++;\n\t\tdfs(a,b+1);\n\t\twin[b]--;\n\t\tmp[a][b] = '-';\n\t\tmp[b][a] = '-';\n\t}\n}\n\nvoid solve(){\n\tans = 0;\n\tREP(i,10){\n\t\twin[i] = 0;\n\t\tREP(j,10){\n\t\t\tmp[i][j] = '-';\n\t\t}\n\t}\n\tint m;cin >> m;\n\tREP(i,m){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tmp[a][b] = 'o';\n\t\tmp[b][a] = 'x';\n\t\twin[a]++;\n\t}\n\t\n\tREP(i,n){\n\t\tif(win[i] > (n-1) / 2){\n\t\t\tcout << 0 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tdfs(0,0);\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\t\n\twhile(cin >> n,n){\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(vector<vector<int>> &result, int &ans){\n    bool flag = false;\n    int n = result.size();\n    bool loope = false;\n    for (int i = 0; i < n; i++){\n        int win = 0; int lose = 0;\n        for (int j = 0; j < n; j++){\n            if (i == j) continue;\n            if (result[i][j] == 0){\n                if (win < n / 2){\n                    result[i][j] = 1;\n                    result[j][i] = 2;\n                    dfs(result, ans);\n                    result[i][j] = 0;\n                    result[j][i] = 0;\n                }\n                if (lose < n / 2){\n                    result[i][j] = 2;\n                    result[j][i] = 1;\n                    dfs(result, ans);\n                    result[i][j] = 0;\n                    result[j][i] = 0;\n                }\n                flag = true;\n                loope = true;\n                break;\n            }\n            else if (result[i][j] == 1) win++;\n            else if (result[i][j] == 2) lose++;\n        }\n        if (loope) break;\n    }\n\n    if (!flag){\n        bool ok = true;\n        int win = n / 2; int lose = n / 2;\n        for (int i = 0; i < n; i++){\n            if (win != n / 2 || lose != n / 2){\n                ok = false;\n                break;\n            }\n            win = 0; lose = 0;\n            for (int j = 0; j < n; j++){\n                if (result[i][j] == 1) win++;\n                if (result[i][j] == 2) lose++;\n            }\n        }\n        if (win != n / 2 || lose != n / 2) ok = false;\n        if (ok) ans++;\n    }\n}\n\nint main(){\n    while (1){\n        int n;\n        cin >> n;\n        if (!n) break;\n        vector<vector<int>> result(n, vector<int>(n, 0));\n        for (int i = 0; i < n; i++) result[i][i] = -1;\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++){\n            int x, y;\n            cin >> x >> y;\n            x--; y--;\n            result[x][y] = 1;\n            result[y][x] = 2;\n        }\n        int ans = 0;\n        dfs(result, ans);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m,a[10][10],c1,c2,ans,c;\n\nvoid dfs(){\n  for(int i=0;i<n-1;i++){\n    for(int j=i+1;j<n;j++){\n      int fl=1;\n      if(~a[i][j]&&!(i==n-2&&j==n-1))continue;\n      if(~a[i][j])fl=0;\n      r(o,2){\n        if(o&&!fl)break;\n        int f=0;\n        if(fl)a[i][j]=o;\n        if(fl)a[j][i]=o^1;\n        r(k,i+1){\n          c1=c2=0;\n          if(k==i&&j!=n-1)continue;\n          r(l,n)if(k!=l){\n            if(a[k][l])c1++;\n            else c2++;\n          }\n          if(c1!=c2)f++;\n        }\n        if(f)continue;\n        if(i==n-2&&j==n-1)ans++;\n        else dfs();\n      }\n      if(fl)a[i][j]=-1;\n      return;\n    }\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    ans=0;\n    cin>>m;\n    memset(a,-1,sizeof(a));\n    r(i,m){\n      int x,y;\n      cin>>x>>y;\n      x--;y--;\n      a[x][y]=1;\n      a[y][x]=0;\n    }\n    dfs();\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nll ans;\nint n, m;\n\npair<int,int> next(int x, int y) {\n    if(x == n-1) return make_pair(y+2, y+1);\n    return make_pair(x+1, y);\n}\n\nvoid dfs(int x, int y, int win, vector<vector<int>> &table) {\n    // cout << \"x=\" << x << \" y=\" << y << \" win=\" << win << endl;\n    // REP(i, n) cout << table[i] << endl;\n    if(y == n-2 && x == n-1) {\n        if(table[y][x] == 0 && (win == n/2 || win == n/2-1)) {\n            ans++;\n            // REP(i, n) cout << table[i] << endl;\n            // cout << endl;\n            // cout << \"plus\" << endl;\n        } else if(table[y][x] != 0 && win+(table[y][x]==1) == n/2) {\n            // REP(i, n) cout << table[i] << endl;\n            // cout << endl;\n            ans++;\n        }\n        return;\n    }\n\n    int nx, ny, nwin = win;\n    tie(nx, ny) = next(x, y);\n    if(ny != y) {\n        nwin = 0;\n        REP(i, ny) nwin += table[ny][i]==1?1:0;\n    }\n\n    if(table[y][x] != 0) {\n        // cout << \"a\" << endl;\n        if(ny != y) {\n            if(win+(table[y][x]==1) == n/2) dfs(nx, ny, nwin, table);\n        } else {\n            if(win+(table[y][x]==1) <= n/2) dfs(nx, ny, win+(table[y][x]==1), table);\n        }\n    }\n    else {\n        // cout << \"b\" << endl;\n        table[y][x] = 1;\n        table[x][y] = -1;\n        if(ny != y) {\n            // cout << x << \" \" << y << \" \" << win << \" \" << nwin << endl;\n            if(win+1 == n/2) dfs(nx, ny, nwin, table);\n        } else {\n            if(win+1 <= n/2) dfs(nx, ny, win+1, table);\n        }\n        table[y][x] = -1;\n        table[x][y] = 1;\n        if(ny != y) {\n            if(win == n/2) dfs(nx, ny, nwin, table);\n        } else {\n            if(win <= n/2) dfs(nx, ny, win, table);\n        }\n        table[x][y] = table[y][x] = 0;\n    }\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(1) {\n        cin >> n;\n        if(!n) break;\n        cin >> m;\n        vector<vector<int>> table(n, vector<int>(n));\n        REP(i, m) {\n            ll x, y;\n            cin >> x >> y;\n            x--, y--;\n            table[x][y] = 1;\n            table[y][x] = -1;\n        }\n\n        ans = 0;\n        dfs(1, 0, 0, table);\n        // cerr << \"ans=\";\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst bool debug=false;\n// const bool debug=true;\n#define DEBUG if(debug==true)\n\nint matrix[10][10];\nbool fixed_[10][10];\n\nlong long dfs(int now,int n_team){\n    int win=0,lose=0;\n    vector<int> team;\n    vector<int> wl;\n    for(int i=1;i<now;i++){\n        if(matrix[now][i]==1)win++;\n        if(matrix[now][i]==-1)lose++;\n    }\n    for(int i=now+1;i<=n_team;i++){\n        if(matrix[now][i]==1)win++;\n        else if(matrix[now][i]==-1)lose++;\n        else team.push_back(i);\n    }\n    DEBUG{\n        printf(\"now : %d,win : %d, lose : %d\\n\",now,win,lose);\n    }\n    if(win>n_team/2||lose>n_team/2)return 0;\n    if(now==n_team&&win==lose)return 1;\n    else if(now==n_team&&win!=lose)return 0;\n    while(win<n_team/2){\n        wl.push_back(-1);\n        win++;\n    }\n    while(lose<n_team/2){\n        wl.push_back(1);\n        lose++;\n    }\n    DEBUG{\n        printf(\"wl size : %d, team size : %d\\n\",wl.size(), team.size());\n    }\n    long long res=0;\n    do{\n        for(int i=0;i<team.size();i++){\n            matrix[team[i]][now]=wl[i];\n        }\n        res += dfs(now+1,n_team); \n    }while(next_permutation(wl.begin(),wl.end()));\n    DEBUG{\n        printf(\"res : %lld\\n\",res);\n    }\n    return res;\n}\n\nint main(void){\n    while(true){\n        int n,m;\n        cin>>n;\n        if(n==0)return 0;\n        cin>>m;\n        int tmp[2];\n        for(int j=0;j<10;j++){\n            for(int k=0;k<10;k++){\n                matrix[j][k]=0;\n                fixed_[j][k]=false;\n            }\n        }\n        for(int i=0;i<m;i++){\n            cin >> tmp[0]>>tmp[1];\n            matrix[tmp[0]][tmp[1]]=1;\n            matrix[tmp[1]][tmp[0]]=-1;\n            fixed_[tmp[0]][tmp[1]]=true;\n            fixed_[tmp[1]][tmp[0]]=true;\n        }\n        long long res=dfs(1,n);\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    int m; cin >> m;\n    V<> x(m), y(m); for (int i = 0; i < m; ++i) cin >> x[i] >> y[i], --x[i], --y[i];\n    V< bitset<9> > a(n);\n    int res = 0;\n    auto dfs = [&](const auto& dfs, int i) -> void {\n      if (i == n) {\n        for (int j = 0; j < m; ++j) {\n          if (!a[x[j]][y[j]]) return;\n        }\n        ++res;\n        return;\n      }\n      int s = 0;\n      for (int j = 0; j < i; ++j) {\n        s += a[i][j] = !a[j][i];\n      }\n      if (s > n / 2 or i - s > n / 2) return;\n      V<> p(n / 2 - s, 1);\n      while (p.size() < n + ~i) p.push_back(0);\n      sort(begin(p), end(p));\n      do {\n        for (int j = 0; j < n + ~i; ++j) {\n          a[i][i + 1 + j] = p[j];\n        }\n        dfs(dfs, i + 1);\n      } while (next_permutation(begin(p), end(p)));\n    };\n    dfs(dfs, 0);\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[40][1953130];\nint fac[10];\n\nint main(){\n\n    fac[0] = 1;\n    for(int i = 1; i < 10; i++){\n        fac[i] = fac[i - 1] * 5;\n    }\n\n    while(1){\n        int n; cin >> n;\n        int win_number = (n - 1) / 2;\n        if(!n) break;\n        int m; cin >> m;\n        vector<vector<int> > num(n, vector<int> (n));\n        vector<vector<int> > winlose(n, vector<int> (n, 0));\n\n\n        for(int i = 0; i < m; i++){\n            int win, lose; cin >> win >> lose;\n            win--;\n            lose--;\n            winlose[win][lose] = 1;\n            winlose[lose][win] = -1;\n        }\n\n        int cnt = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                num[i][j] = cnt;\n                cnt++;\n            }\n        }\n\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = 1;\n\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                for(int bit = 0; bit <= fac[n]; bit++){\n                    //i vs j\n                    int next_num = num[i][j];\n                    int now_num = next_num - 1;\n                    if(dp[now_num][bit] == 0) continue;\n\n                    //jが勝つ\n                    if(winlose[i][j] != 1){\n                        int next_bit = bit;\n                        int number = bit % fac[j + 1];\n                        number = number / fac[j];\n                        if(number < win_number){\n                            next_bit += fac[j];\n                            dp[next_num][next_bit] += dp[now_num][bit];\n                        }\n                    }\n\n                    //iがかつ\n                    if(winlose[j][i] != 1){\n                        int next_bit = bit;\n                        int number = bit % fac[i + 1];\n                        number = number / fac[i];\n                        if(number < win_number){\n                            next_bit += fac[i];\n                            dp[next_num][next_bit] += dp[now_num][bit];\n                        }\n                    }\n                }\n            }\n        }\n\n        int ans_bit = 0;\n        for(int i = 0; i < n; i++){\n            ans_bit += fac[i] * win_number;\n        }\n        \n        cout << dp[cnt - 1][ans_bit] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define ALL(obj) obj.begin(), obj.end()\n\nconst int iINF = 1e9;\nconst long long llINF = 1e18;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n\ntemplate <typename T>\nint getFormer(const vector<T> &vec, T x) {\n    return upper_bound(vec.begin(), vec.end(), x) - vec.begin() - 1;\n}\n\ntemplate <typename T>\nint getLatter(const vector<T> &vec, T x) {\n    return lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n}\n\nint n, m, win[10], match[10][10];\nint dfs(int x, int y) {\n    if (y == n) {\n        x += 1;\n        y = x;\n    }\n\n    if (x == n - 1 && y == n - 1) {\n        return 1;\n    }\n\n    int res = 0;\n\n    if (x == y || match[x][y] != -1) {\n        res += dfs(x, y + 1);\n        return res;\n    }\n\n    if (win[x] < (n - 1) / 2) {\n        match[x][y] = 1;\n        match[y][x] = 0;\n        win[x] += 1;\n        res += dfs(x, y + 1);\n\n        match[x][y] = match[y][x] = -1;\n        win[x] -= 1;\n    }\n\n    if (win[y] < (n - 1) / 2) {\n        match[x][y] = 0;\n        match[y][x] = 1;\n        win[y] += 1;\n        res += dfs(x, y + 1);\n\n        win[y] -= 1;\n        match[x][y] = match[y][x] = -1;\n    }\n\n    return res;\n}\n\nvoid solve() {\n    memset(match, -1, sizeof(match));\n    memset(win, 0, sizeof(win));\n    REP(i, m) {\n        int x, y;\n        cin >> x >> y;\n        match[x - 1][y - 1] = 1;\n        match[y - 1][x - 1] = 0;\n        win[x - 1] += 1;\n    }\n\n    REP(i, n) {\n        if (win[i] > (n - 1) / 2) {\n            cout << 0 << endl;\n            return;\n        }\n    }\n\n    cout << dfs(0, 0) << endl;\n    return;\n}\n\nint main() {\n    while(cin >> n >> m && n) {\n        solve();\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i = 0; i<n ; i++)\n#define FOR(i,a,n) for(int i=a; i<n; i++)\n \n#define RANGE(a,i,b) ((a)<=(i)&&(i)<=(b))\n \n#define pb push_back\n#define mp make_pair\n \n#define ALL(a) (a).begin(), (a).end()\n \n#define SET(a,c) memset(a,c,sizeof(a))\n#define CLR(a) memset(a,0,sizeof(a))\n \n#define INF 1001001001\n#define LLINF 1001001001001001001LL\n \ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n \n#define PQ priority_queue\n \n#define FST first\n#define SEC second\n \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n \n//------------------HEAD---------------------\nint n, m;\nint s[9][9];\n\nbool ok(int i){\n\n    if(i>=n) return true;\n    int c=0;\n    int d=0;\n    rep(j,n){\n        if(s[i][j]==1) ++c;\n        if(s[i][j]==-1) ++d;\n    }\n    return c<=n/2&&d<=n/2;\n}\n\nint solve(int x,int y){\n\n    if(x==n) return 1;\n    if(y==n) return ok(x)&&ok(x+1)?solve(x+1,x+2):0;\n    \n    if(x==y) return solve(x, y+1);\n    if(s[x][y]) return solve(x, y+1);\n    int res=0;\n    s[x][y]=1;\n    s[y][x]=-1;\n    if(ok(x)&&ok(y)) res+=solve(x,y+1);\n    s[x][y]=-1;\n    s[y][x]=1;\n    if(ok(x)&&ok(y)) res+=solve(x,y+1);\n    s[x][y]=0;\n    s[y][x]=0;\n    return res;\n}\n    \nint main(){\n    while(1){\n        cin>>n;\n        if(n==0) break;\n        cin>>m;\n\n        rep(i,n)rep(j,n)s[i][j]=0;\n\n        rep(i,m){\n\n            int x,y;\n\n            cin>>x;\n\n            cin>>y;\n\n            --x;--y;\n\n            s[x][y]=1;\n\n            s[y][x]=-1;\n\n        }\n\n        printf(\"%d\\n\", solve(0,0));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint memo[10][10] = {0};\nint wl[10][3] = {0};\nint n, m, x, y, ans = 0, hal;\n\nvoid solve(int now, int riv);\nvoid check();\nint main() {\n  int i, j;\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    for(i = 1; i <= n; i++)\n      for(j = 0; j < 2; j++) wl[i][j] = 0;\n    for(i = 1; i <= n; i++)\n      for(j = 1; j <= n; j++) memo[i][j] = 0;\n    cin >> m;\n    for(i = 0; i < m; i++) {\n      cin >> x >> y;\n      memo[x][y] = 1;\n      memo[y][x] = 2;\n      wl[x][0]++;\n      wl[y][1]++;\n    }\n    hal = (n - 1) / 2;\n    ans = 0;\n    solve(1, 2);\n    cout << ans << endl;\n    ;\n  }\n  return 0;\n}\n\nvoid solve(int now, int riv) {\n  int nnow, nriv;\n  if(now == n && riv == n + 1) {\n    check();\n    return;\n  }\n  if(riv < n) {\n    nnow = now;\n    nriv = riv + 1;\n  }\n  else {\n    nnow = now + 1;\n    nriv = nnow + 1;\n  }\n  if(now == riv || memo[now][riv] != 0)\n    solve(nnow, nriv);\n  else {\n    if(hal > wl[now][0]) {\n      ++wl[now][0];\n      ++wl[riv][1];\n      memo[now][riv] = 1;\n      memo[riv][now] = 2;\n      solve(nnow, nriv);\n      --wl[now][0];\n      --wl[riv][1];\n    }\n    if(hal > wl[now][1]) {\n      ++wl[now][1];\n      ++wl[riv][0];\n      memo[now][riv] = 2;\n      memo[riv][now] = 1;\n      solve(nnow, nriv);\n      --wl[now][1];\n      --wl[riv][0];\n    }\n    memo[now][riv] = 0;\n    memo[riv][now] = 0;\n  }\n}\n\nvoid check() {\n  int i, j;\n cout << \" \" << wl[i][0];\n  cout << endl << endl;*/\n  for(i = 1; i <= n; ++i)\n    if(wl[i][0] != hal || wl[i][1] != hal) return;\n\n  ++ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\n#define mkp make_pair\n\nint N;\n\nint win[10];\nint beat[10][10];\n\nvector<pair<int,int>> rest;\nint ans;\n\nvoid dfs(int now){\n    if(now==rest.size()){\n        bool ok=true;\n        for(int i=1;i<=N;i++) if(win[i]!=N/2) ok=false;\n        if(ok) ans++;\n    }else{\n        int x=rest[now].first;\n        int y=rest[now].second;\n        \n        win[x]++;\n        if(win[x]<=N/2) dfs(now+1);\n        win[x]--;\n\n        win[y]++;\n        if(win[y]<=N/2) dfs(now+1);\n        win[y]--;\n    }\n}\n\nvoid solve(){\n    for(int i=0;i<=N;i++) win[i]=0;\n    for(int i=0;i<=N;i++) for(int j=0;j<=N;j++) beat[i][j]=0;\n    rest.clear();\n    ans=0;\n\n    int M;\n    cin>>M;\n    for(int i=0;i<M;i++){\n        int x,y;\n        cin>>x>>y;\n        beat[x][y]=1;\n        beat[y][x]=-1;\n        win[x]++;\n    }\n    \n    for(int i=1;i<=N;i++){\n        for(int j=i+1;j<=N;j++){\n            if(beat[i][j]==0){\n                rest.push_back(mkp(i,j));\n            }\n        }\n    }\n\n    dfs(0);\n    cout<<ans<<endl;\n}\n\nint main(){\n  while(1){\n      cin>>N;\n      if(N==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint n,m;\nint win[10]={0},los[10]={0},A[10][10]={0};\n\nlong long dfs(int x,int y){\n    if(x==n){\n        for(int i=0;i<n;++i){\n            if(win[i]>n/2||los[i]>n/2){\n                return 0;\n            }\n        }\n        return 1;\n    }\n    if(y==n){\n        return dfs(x+1,x+2);\n    }\n    if(A[x][y]==0){\n        long long z=0,w=0;\n        if(win[x]<n/2){\n            win[x]++;\n            los[y]++;\n            z=dfs(x,y+1);\n            win[x]--;\n            los[y]--;\n        }\n        if(los[x]<n/2){\n            los[x]++;\n            win[y]++;\n            w=dfs(x,y+1);\n            los[x]--;\n            win[y]--;\n        }\n        return z+w;\n    }\n    else{\n        return dfs(x,y+1);\n    }\n}\n\nint main(){\n    while(true){\n        cin>>n;\n        if(n==0){\n            return 0;\n        }\n        cin>>m;\n\n        int x,y;\n        for(int i=0;i<n;++i){\n            for(int j=0;j<n;++j){\n                A[i][j]=0;\n            }\n            win[i]=0;\n            los[i]=0;\n        }\n\n        for(int i=0;i<m;++i){\n            cin>>x>>y;\n            win[x-1]++;\n            los[y-1]++;\n            A[x-1][y-1]++;\n            A[y-1][x-1]--;\n        }\n        long long ans=dfs(0,1);\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include <fstream>\n#include <time.h>\n#include <iterator>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end());\n#define ll long long\n#define pb(a) push_back(a)\n#define m0(x) memset(x,0,sizeof(x))\n#define print(x) cout<<x<<endl;\n#define pe(x) cout<<x<<\" \";\n#define lb(v,n) lower_bound(v.begin(), v.end(), n);\n#define ub(v,n) upper_bound(v.begin(), v.end(), n);\n//#define int long long\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\nint MOD = (ll)1000000000 + 7;\nconst ll INF = 1e17;\nconst double pi = acos(-1);\nconst double EPS = 1e-10;\ntypedef pair<int, int>P;\nconst int MAX = 200020;\n\n\n\n\nint G[10][10], win[10], lose[10];\nint N, M;\nint dfs(int N, int G2[10][10], int win[10], int lose[10]) {\n\tint res = 0;\n\tbool found = false;\n\t// REP(i, N) {\n\t// REP(j, N) {\n\t// pe(G2[i][j]);\n\t// }\n\t// cout << endl;\n\t// }cout << endl;\n\tFOR(i, 0, N - 1) {\n\t\tFOR(j, i + 1, N) {\n\t\t\tint wi = win[i], li = lose[i], wj = win[j], lj = lose[j];\n\t\t\tif (win[i] > N / 2 || lose[j] > N / 2 || win[j] > N / 2 || lose[i] > N / 2)return 0;\n\t\t\tif (G2[i][j] == 0) {\n\t\t\t\t//printf(\"%d: %d - %d\\n\", i, win[i], lose[i]);\n\t\t\t\t//printf(\"%d: %d - %d\\n\", j, win[j], lose[j]);\n\t\t\t\tfound = true;\n\t\t\t\tbool ok = false;\n\t\t\t\t\n\t\t\t\tif (win[i] < N / 2 && lose[j] < N / 2) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tint G3[10][10];\n\t\t\t\t\tint win2[10], lose2[10];\n\t\t\t\t\tREP(i, 10) {\n\t\t\t\t\t\twin2[i] = win[i];\n\t\t\t\t\t\tlose2[i] = lose[i];\n\t\t\t\t\t\tREP(j, 10) {\n\t\t\t\t\t\t\tG3[i][j] = G2[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tG3[i][j] = 1;\n\t\t\t\t\twin[j] = wj, lose[i] = li;\n\t\t\t\t\twin2[i] = wi + 1, lose2[j] = lj + 1;\n\t\t\t\t\tres += dfs(N, G3, win2, lose2);\n\t\t\t\t}\n\t\t\t\t//G[i][j] = 0;\n\t\t\t\twin[i] = wi, win[j] = wj, lose[i] = li, lose[j] = lj;\n\t\t\t\tif (lose[i] < N / 2 && win[j] < N / 2) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tint G3[10][10];\n\t\t\t\t\tint win2[10], lose2[10];\n\t\t\t\t\tREP(i, 10) {\n\t\t\t\t\t\twin2[i] = win[i];\n\t\t\t\t\t\tlose2[i] = lose[i];\n\t\t\t\t\t\tREP(j, 10) {\n\t\t\t\t\t\t\tG3[i][j] = G2[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tG3[i][j] = -1;\n\t\t\t\t\twin[i] = wi, lose[j] = lj;\n\t\t\t\t\tlose2[i] = li + 1, win2[j] = wj + 1;\n\t\t\t\t\tres += dfs(N, G3, win2, lose2);\n\t\t\t\t}\n\t\t\t\tif (!ok)return 0;\n\t\t\t\tif (ok)return res;\n\t\t\t\t//G[i][j] = 0;\n\t\t\t\twin[i] = wi, win[j] = wj, lose[i] = li, lose[j] = lj;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found)res = 1;\n\treturn res;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (true) {\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tcin >> M;\n\t\t//print(N)print(M);\n\t\tREP(i, 10) {\n\t\t\twin[i] = 0, lose[i] = 0;\n\t\t}\n\t\tREP(i, 10) {\n\t\t\tREP(j, 10) {\n\t\t\t\tG[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tREP(i, M) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\t//pe(x)print(y);\n\t\t\tx--, y--;\n\t\t\tif (x < y) {\n\t\t\t\tG[x][y] = 1;\n\t\t\t\twin[x]++, lose[y]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tG[y][x] = -1;\n\t\t\t\twin[x]++, lose[y]++;\n\t\t\t}\n\t\t}\n\t\t/*REP(i, N) {\n\t\tREP(j, N) {\n\t\tpe(G[i][j]);\n\t\t}\n\t\tcout << endl;\n\t\t}*/\n\t\tint ans = dfs(N, G, win, lose);\n\t\t//cout << \"ans:\";\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<int> rst;\nvector<vector<int>> mat;\n\nint dfs(int s, int t) {\n  if (s == n) return 1;\n  if (t == n) return dfs(s + 1, 0);\n  if (~mat[s][t]) return dfs(s, t + 1);\n\n  int res = 0;\n  if (rst[s] > 0) {\n    rst[s]--;\n    mat[s][t] = 1;\n    mat[t][s] = 0;\n    res += dfs(s, t + 1);\n    mat[s][t] = -1;\n    mat[t][s] = -1;\n    rst[s]++;\n  }\n  if (rst[t] > 0) {\n    rst[t]--;\n    mat[t][s] = 1;\n    mat[s][t] = 0;\n    res += dfs(s, t + 1);\n    mat[s][t] = -1;\n    mat[t][s] = -1;\n    rst[t]++;\n  }\n  return res;\n}\n\nint main() {\n  while (cin >> n, n) {\n    mat.assign(n, vector<int>(n, -1));\n    cin >> m;\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y, x--, y--;\n      mat[x][y] = 1;\n      mat[y][x] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n      mat[i][i] = -2;\n    }\n\n    bool ok = true;\n    rst.assign(n, n / 2);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) rst[i]--; \n      }\n      if (rst[i] < 0) ok = false;\n    }\n\n    if (ok) {\n      cout << dfs(0, 0) << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\nusing ll = long long;\n\nint n;\nll dfs(int cur, vector<vector<int>> &a) {\n\tif (cur == n) return 1;\n\tint win = 0;\n\tint lose = 0;\n\tint any = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[cur][i] == 1) win++;\n\t\telse if (a[cur][i] == 0) lose++;\n\t\telse if(a[cur][i] == -1) any++;\n\t}\n\tif (win > n / 2 or lose > n / 2) return 0;\n\tll res = 0;\n\tfor (int S = 0; S < (1 << any); S++) {\n\t\tqueue<int> q;\n\t\tint nw = win;\n\t\tint nl = lose;\n\t\tfor (int i = 0; i < any; i++) {\n\t\t\tif (S >> i & 1) q.push(1), nw++;\n\t\t\telse q.push(0), nl++;\n\t\t}\n\t\tif (nw > n / 2 or nl > n / 2) continue;\n\t\tvector<int> tmp;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[cur][i] == -1) {\n\t\t\t\ta[cur][i] = q.front();\n\t\t\t\ta[i][cur] = a[cur][i] ^ 1;\n\t\t\t\tq.pop();\n\t\t\t\ttmp.push_back(i);\n\t\t\t}\n\t\t}\n\t\tres += dfs(cur + 1, a);\n\t\tfor (auto e : tmp) {\n\t\t\ta[cur][e] = -1;\n\t\t\ta[e][cur] = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid suzuken() {\n\tscanf(\"%d\", &n); if (n == 0) exit(0);\n\tvector<vector<int>> a(n, vector<int>(n, -1));\n\tint m; scanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y; scanf(\"%d %d\", &x, &y);\n\t\tx--; y--;\n\t\ta[x][y] = 1;\n\t\ta[y][x] = 0;\n\t}\n\tfor (int i = 0; i < n; i++) a[i][i] = -2;\n\tll res = 0;\n\tres += dfs(0, a);\n\tcout << res << \"\\n\";\n}\nint main() {\n\tint kkt = 89;\n\twhile (kkt) {\n\t\tsuzuken();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <unordered_map> \n#include <unordered_set>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\ntypedef tuple<int, int, int> T;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nint n;\nint table[10][10];\nint ans;\n\nvoid func(int p, int q, int cnt1, int cnt2){\n\tif(cnt1 > n / 2 || cnt2 > n / 2){\n\t\treturn;\n\t}\n\tif(p >= n){\n\t\tans += 1;\n\t\treturn;\n\t}\n\tif(q >= n){\n\t\tfunc(p + 1, 0, 0, 0);\n\t\treturn;\n\t}\n\tif(p == q){\n\t\tfunc(p, q + 1, cnt1, cnt2);\n\t\treturn;\n\t}\n\tif(table[p][q] == 1){\n\t\tfunc(p, q + 1, cnt1 + 1, cnt2);\n\t}else if(table[p][q] == -1){\n\t\tfunc(p, q + 1, cnt1, cnt2 + 1);\n\t}else{\n\t\ttable[q][p] = -1;\n\t\tfunc(p, q + 1, cnt1 + 1, cnt2);\n\t\ttable[q][p] = 1;\n\t\tfunc(p, q + 1, cnt1, cnt2 + 1);\n\t\ttable[q][p] = 0;\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\ttable[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttable[x - 1][y - 1] = 1;\n\t\t\ttable[y - 1][x - 1] = -1;\n\t\t}\n\t\tans = 0;\n\t\tfunc(0, 0, 0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,a,b) for(int i = a; i < b; i++)\n\nint n,m;\nint table[9][9];\nint win[9];\nint lose[9];\nint ans;\n\n\nvoid rec(int i=0, int j=0) {\n    if (i == n && j == 0) {\n        ans += 1;\n        return;\n    }\n    int ni,nj;\n    ni = i;\n    nj = j + 1;\n\n    if (nj > n-1) {\n        ni = i + 1;\n        nj = 0 ;\n    }\n\n    if (table[i][j] == 0) {\n        if (i == j) return rec(ni, nj);\n\n        if (win[i] + 1 <= n/2 && lose[j] + 1 <= n/2) {\n            table[i][j] = 1;\n            table[j][i] = -1;\n            win[i] += 1;\n            lose[j] +=1;\n            rec(ni, nj);\n            table[i][j] = 0;\n            table[j][i] = 0;\n            win[i] += -1;\n            lose[j] += -1;\n        }\n\n        if (lose[i] + 1 <= n/2 && win[j] + 1 <= n/2) {\n            table[i][j] = -1;\n            table[j][i] = 1;\n            lose[i] += 1;\n            win[j] += 1;\n            rec(ni, nj);\n            table[i][j] = 0;\n            table[j][i] = 0;\n            lose[i] += -1;\n            win[j] += -1;\n        }\n    }\n    else {\n        if (table[i][j] == 1) {\n            if (win[i] <= n/2 && lose[j] <= n/2) {\n                return rec(ni, nj);\n            }\n        }\n        if (table[i][j] == -1) {\n            if (lose[i] <= n/2 && win[j] <= n/2) {\n                return rec(ni, nj);\n            }\n        }\n    }\n    return;\n}\n\nsigned main() {\n    while (true) {\n        cin >> n;\n        if(n==0) break;\n        cin >> m;\n        rep(i,0,n) rep(j,0,n) table[i][j] = 0;\n        rep(i,0,n) win[i] = 0;\n        rep(i,0,n) lose[i] = 0;\n        rep(i,0,m) {\n            int x,y;\n            cin >> x >> y;\n            x -= 1;\n            y -= 1;\n            table[x][y] = 1;\n            table[y][x] = -1;\n            win[x] += 1;\n            lose[y] += 1;\n        }\n\n        ans = 0;\n\n        rec();\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nint n,m;\nint sum;\nint x,y;\nint a[100][100];\nint cnt[100];\nvoid show()\n{\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\tif(a[i][j]==-1) cout<<\"* \";else \n\t\tcout<<a[i][j]<<\" \";cout<<endl;\n\t}\n}\nvoid dfs(int x,int next)\n{\n\t//show();\n\t//system(\"pause\");\n\tif(x==n+1) sum++;\n\telse\n\t{\n\t\tif(cnt[x]==n/2) dfs(x+1,1);\n\t\telse for(int i=next;i<=n;i++)\n\t\t{\n\t\t\tif(a[x][i]==0&&x!=i)\n\t\t\t{\n\t\t\t\ta[x][i]=1;\n\t\t\t\ta[i][x]=-1;\n\t\t\t\tcnt[x]++;\n\t\t\t\tif(cnt[x]==n/2)\n\t\t\t\tdfs(x+1,1);\n\t\t\t\telse dfs(x,i+1);\n\t\t\t\ta[x][i]=0;\n\t\t\t\ta[i][x]=0;\n\t\t\t\tcnt[x]--;\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(true)\n\t{\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tmemset(a,0,sizeof(a));\n\t\tsum=0;\n\t\tcin>>n;\n\t\tif(n==0) return 0;\n\t\tcin>>m;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tcin>>x>>y;\n\t\t\ta[x][y]=1;\n\t\t\ta[y][x]=-1;\n\t\t\tcnt[x]++;\n\t\t}\n\t\tdfs(1,1);\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i,n) for(int64 i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first;\n#define sc second;\n\nusing int32 = int_fast32_t;\nusing int64 = int_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\ntemplate<typename A, typename B> inline void chmin(A &a, B b) { if(a > b) a = b; }\ntemplate<typename A, typename B> inline void chmax(A &a, B b) { if(a < b) a = b; }\n\nint64 n, m;\nint64 res = 0;\nvector<vector<int64>> table;\nvector<int64> cnt;\n\nvoid dfs(int64 p) {\n  if (cnt[p] > (n-1)/2) return;\n  if (p == n-1) {\n    REP(i, n) {\n      if (cnt[i] != (n-1)/2) return;\n    }\n    res++;\n    return;\n  }\n  vector<int64> undec;\n  FOR(i, p+1, n) {\n    if (table[p][i] == 0) undec.push_back(i);\n  }\n  if (n/2-cnt[p] > undec.size()) return;\n  vector<int64> comb(undec.size());\n  REP(i, n/2-cnt[p]) comb[undec.size()-i-1] = 1;\n  do {\n    REP(i, undec.size()) {\n      if (comb[i] == 0){\n        table[p][undec[i]] = -1;\n        cnt[undec[i]]++;\n      } else {\n        table[p][undec[i]] = 1;\n        cnt[p]++;\n      }\n    }\n    dfs(p+1);\n    REP(i, undec.size()) {\n      if (comb[i] == 0){\n        table[p][undec[i]] = 0;\n        cnt[undec[i]]--;\n      } else {\n        table[p][undec[i]] = 0;\n        cnt[p]--;\n      }\n    }\n  } while (next_permutation(all(comb)));\n}\n\nint main(void){\n  cin.tie(0);\n\n  while (cin >> n && n) {\n    cin >> m;\n    table = vector<vector<int64>>(n, vector<int64>(n, 0));\n    cnt = vector<int64>(n, 0);\n    REP(i, m) {\n      int64 x, y;\n      cin >> x >> y; x--; y--;\n      table[x][y] = 1;\n      table[y][x] = -1;\n      cnt[x]++;\n    }\n    res = 0;\n    dfs(0);\n    cout << res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n); i++)\nint hyou[10][10];\nint n,m,cnt;\n\nvoid tansaku() {\n\tint cnt0 = 0;\n\tint cnt2[10] = {};\n\tint cnt1[10] = {};\n\trep(i, n){\n\t\trep(j, n) {\n\t\t\tif (i == j) continue;\n\t\t\tif (hyou[i][j] == 2) cnt2[i] ++;\n\t\t\tif (hyou[i][j] == 1) cnt1[i] ++;\n\t\t\tif (hyou[i][j] == 0) cnt0 ++;\n\t\t}\n\t\tif (cnt1[i] > n / 2 or cnt2[i] > n / 2) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (cnt0 == 0) {\n\t\tcnt ++;\n\t\treturn;\n\t}\n\trep(i, n) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (hyou[i][j] != 0) continue;\n\t\t\tif (cnt2[i] + 1 <= n / 2 and cnt1[j] + 1 <= n / 2 and cnt1[i] + 1 <= n / 2 and cnt2[j] + 1 <= n /2) {\n\t\t\t\thyou[i][j] = 2;\n\t\t\t\thyou[j][i] = 1;\n\t\t\t\ttansaku();\n\t\t\t\thyou[i][j] = 1;\n\t\t\t\thyou[j][i] = 2;\n\t\t\t\ttansaku();\n\t\t\t}\n\t\t\telse if (cnt2[i] + 1 <= n / 2 and cnt1[j] + 1 <= n / 2) {\n\t\t\t\thyou[i][j] = 2;\n\t\t\t\thyou[j][i] = 1;\n\t\t\t\ttansaku();\n\t\t\t\t\n\t\t\t}\n\t\t\telse if (cnt1[i] + 1 <= n / 2 and cnt2[j] + 1 <= n / 2) {\n\t\t\t\thyou[i][j] = 1;\n\t\t\t\thyou[j][i] = 2;\n\t\t\t\ttansaku();\n\t\t\t}\n\t\t\thyou[i][j] = 0;\n\t\t\thyou[j][i] = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n\nint main() {\n\twhile(cin >> n, n){\n\t\tcin >> m;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\thyou[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tint x,y;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\thyou[x][y] = 2;\n\t\t\thyou[y][x] = 1;\n\t\t}\n\t\tcnt = 0;\n\t\ttansaku();\n\t\tcout << cnt << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nvector<pair<int, int> > rem;\nint win[9];\nint lose[9];\nint half;\n\nint solve(int n){\n\tif(n == 0) return 1;\n\tint x = rem[n].first;\n\tint y = rem[n].second;\n\tint ret = 0;\n\tfor(int d=0; d<2; d++){\n\t\tif(win[x] < half && lose[y] < half){\n\t\t\twin[x]++;\n\t\t\tlose[y]++;\n\t\t\tret += solve(n-1);\n\t\t\twin[x]--;\n\t\t\tlose[y]--;\n\t\t}\n\t\tswap(x, y);\n\t}\n\treturn ret;\n} \n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcin >> m;\n\t\tint used[9][9] = {};\n\t\tfill(win, win+n, 0);\n\t\tfill(lose, lose+n, 0);\n\t\thalf = (n-1)/2;\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tx--; y--;\n\t\t\twin[x]++;\n\t\t\tlose[y]++;\n\t\t\tused[x][y] = used[y][x] = 1;\n\t\t}\n\t\tbool ng = false;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(win[i] > half || lose[i] > half){\n\t\t\t\tng = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ng){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\trem = vector<pair<int, int> >();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\tif(used[i][j] == 0) rem.emplace_back(i, j);\n\t\t\t}\n\t\t}\n\t\tcout << solve(rem.size()-1) << endl;\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E17;\n\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n///////////////////////////////////////\n\n#define N 10\nll n;\nll a[N][N];\nll w[N];\nll l[N];\nll ans=0;\nvoid init(){\n    memset(a,0,sizeof(a));\n    memset(w,0,sizeof(w));\n    memset(l,0,sizeof(l));\n    ans=0;\n}\n#define win 1\n#define lose 2\n\nbool dfs(ll p){\n    if(p==n*n){\n        bool flag=true;\n        rep(i,0,n-1){\n            if(w[i]*2+1!=n)flag=false;\n            if(l[i]*2+1!=n)flag=false;\n        }\n        if(flag)ans++;\n        return 0;\n    }\n    ll x=p/n,y=p%n;\n    if(x==y||a[x][y]!=0){\n        dfs(p+1);return 0;\n    }\n    if(w[x]*2+1<n&&l[y]*2+1<n){\n        w[x]++;\n        l[y]++;\n        a[x][y]=1;\n        a[y][x]=2;\n        dfs(p+1);\n        w[x]--;\n        l[y]--;\n        a[y][x]=a[x][y]=0;\n    }\n    if(l[x]*2+1<n&&w[y]*2+1<n){\n        w[y]++;\n        l[x]++;\n        a[x][y]=2;\n        a[y][x]=1;\n        dfs(p+1);\n        w[y]--;\n        l[x]--;\n        a[x][y]=a[y][x]=0;\n    }\n    \n    return 0;\n}\n\nint main(){fastio\n    while(1){\n        cin>>n;\n        if(n==0)return 0;\n        init();\n        ll m;cin>>m;\n        while(m--){\n            ll x,y;cin>>x>>y;\n            x--;y--;\n            a[x][y]=win;\n            a[y][x]=lose;\n            w[x]++;\n            l[y]++;\n        }\n        dfs(0);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// memo version\n#include<iostream>\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstd::ostream &operator <<(std::ostream &os, const std::vector<T> &vs) {\n    using namespace std;\n    bool fst = true;\n    for(auto &v : vs) {\n      if(!fst) os << \",\";\n      os << v;\n      fst = false;\n    }\n    return os;\n}\nusing namespace std;\n// next_combination:\n// given an integer cur, next_combination returns an integer nxt s.t.\n//   nxt has the same number of 1s as cur\n//   nxt is bigger than cur\n//   no integer between cur and nxt has the same number of 1s as cur (and nxt)\nint next_combination(int cur){\n  int r1 = cur & -cur;      // extracts the rightmost 1\n  int moved1 = cur + r1;    // cancel the rightmost run of 1s and put 1 on its left\n  int rm1s = cur & ~moved1; // extracts the rightmost run of 1s\n  int reset = (rm1s / r1) >> 1; // the run of 1s moved to LSD and made its length decreased by 1\n  int nxt = moved1 | reset; // new combination\n  return nxt;\n}\nint memo[9][6*6*6*6*6*6*6*6*6];\nint main(int argc, char *argv[])\n{\n  for(;;){\n    int n; cin >> n;\n    if(n == 0) break;\n\n    vector<int> wons(n, 0); // wons\n    vector<int> losts(n, 0); // losts\n    int m; cin >> m;\n    for(int k = 0; k < m; k++) {\n      int i, j; cin >> i >> j;\n      wons[i-1] |= (1 << (j-1));\n      losts[j-1] |= (1 << (i-1));\n    }\n    for(int i = 2; i < n; i++) {\n      unsigned int im = 1;\n      for(int k = i; k < n; k++) {\n        im *= 6;\n      }\n      for(unsigned int j = 0; j < im; j++) {\n        memo[i-2][j] = -1;\n      }\n    }\n    vector<int> ws(n, n/2); // # of to win\n    function<int(int)> rec = [n,&rec,&wons,&losts,&ws](int i){\n      if(i >= n) return 1;\n      if(n - 1 - i < ws[i]) return 0;\n      unsigned int idx = 0;\n      for(int j = i; j < n; j++) {\n        idx = idx*6 + ws[j];\n      }\n      if(i >= 2 && memo[i-2][idx]>=0) {\n        return memo[i-2][idx];\n      }\n      int k = ws[i];\n      int win = ((1<<k)-1) << (i+1);\n      const int fin = win << (n-1-k-i);\n      const int mask = (1<<n) - (1 << (i+1));\n      const int won = wons[i] & mask;\n      const int lost = losts[i];\n      int cnt = 0;\n      for(;;) {\n        if(((won & win) == won) && (lost & win) == 0) {\n          bool ok = true;\n          for(int j = i + 1; j < n; j++) {\n            if(((1<<j) & win) == 0) {\n              if(ws[j] == 0) ok = false;\n              ws[j]--;\n            }\n          }\n          if(ok) cnt += rec(i+1);\n          for(int j = i + 1; j < n; j++) {\n            if(((1<<j) & win) == 0) {\n              ws[j]++;\n            }\n          }\n        }\n        if(win == fin) break;\n        win = next_combination(win);\n      }\n      if(i >= 2) {\n        memo[i-2][idx] = cnt;\n      }\n      return cnt;\n    };\n    int ans = rec(0);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n\nint N, M, A[9][9];\n//---------------------------------------------------------------------------------------------------\nint check(int y) {\n    int win = 0, lose = 0;\n    rep(x, 0, N) {\n        if (A[y][x] == 1) win++;\n        else if (A[y][x] < 0 and y != x) lose++;\n    }\n    return win <= (N - 1) / 2 and (N - 1) / 2 <= win + lose;\n}\n//---------------------------------------------------------------------------------------------------\nint answer = 0;\nvoid dfs(int cu) {\n    int x = cu % N;\n    int y = cu / N;\n\n    if (cu == N * N) {\n        answer++;\n        return;\n    }\n\n    if (x == y or 0 <= A[y][x]) {\n        if (check(y)) dfs(cu + 1);\n        return;\n    }\n    \n    A[y][x] = 1; A[x][y] = 0;\n    if(check(y)) dfs(cu + 1);\n\n    A[y][x] = 0; A[x][y] = 1;\n    if (check(y)) dfs(cu + 1);\n\n    A[y][x] = A[x][y] = -1;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> N) {\n        if (N == 0) return;\n        cin >> M;\n        rep(i, 0, N) rep(j, 0, N) A[i][j] = -1;\n        rep(i, 0, M) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            A[a][b] = 1;\n            A[b][a] = 0;\n        }\n\n        answer = 0;\n        dfs(0);\n        printf(\"%d\\n\", answer);\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint ans = 0;\nint n;\nchar win[10];\nchar mp[10][10];\n\nvoid dfs(int a,int b){\n\t\n\tif(a == n-1 && b == n-1){\n\t\tans++;\n\t\treturn;\n\t}\n\tif(b == n){\n\t\ta++;\n\t\tb = 0;\n\t}\n\t\n\tif(a == b || mp[a][b] != '-'){\n\t\tdfs(a,b+1);\n\t}\n\telse{\n\t\tif(win[a] < (n-1) / 2){\n\t\t\tmp[a][b] = 'o';\n\t\t\tmp[b][a] = 'x';\n\t\t\twin[a]++;\n\t\t\tdfs(a,b+1);\n\t\t\twin[a]--;\n\t\t\tmp[a][b] = '-';\n\t\t\tmp[b][a] = '-';\t\t\t\n\t\t}\n\t\tif(win[b] < (n-1) / 2){\n\t\t\tmp[a][b] = 'x';\n\t\t\tmp[b][a] = 'o';\n\t\t\twin[b]++;\n\t\t\tdfs(a,b+1);\n\t\t\twin[b]--;\n\t\t\tmp[a][b] = '-';\n\t\t\tmp[b][a] = '-';\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tans = 0;\n\tREP(i,10){\n\t\twin[i] = 0;\n\t\tREP(j,10){\n\t\t\tmp[i][j] = '-';\n\t\t}\n\t}\n\tint m;cin >> m;\n\tREP(i,m){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tmp[a][b] = 'o';\n\t\tmp[b][a] = 'x';\n\t\twin[a]++;\n\t}\n\t\n\tREP(i,n){\n\t\tif(win[i] > (n-1) / 2){\n\t\t\tcout << 0 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tdfs(0,0);\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\t\n\twhile(cin >> n,n){\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\n\n\n\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    int n;\n    cin>>n;\n    if(n == 0) break;\n    int m;\n    cin>>m;\n\n    vector<vector<int> > mat(n, vector<int>(n,0));\n    for(int i=0;i<n;i++) mat[i][i] = -1;\n    \n    for(int i=0;i<m;i++){\n      int x,y;\n      cin>>x>>y; x--, y--;\n      mat[x][y] = 1;\n      mat[y][x] = -1;\n    }\n    \n    //for(int i=0;i<n;i++) pr(mat[i]);\n\n    function<int(int,int,vector<int>&)> dfs= [&](int y,int x, vector<int> &cnt){\n      if(x >= n) x = 0, y++;\n      if(y >= n) return 1;\n      if(y == x) return dfs(y, x+1, cnt);\n      if(mat[y][x] != 0) {\n\tint num = mat[y][x] == 1? 1:0;\n\tif(y < x){\n\t  cnt[y] += num;\n\t  cnt[x] += !num;\n\t}\n\tint res = (cnt[x] <= (n-1)/2 && cnt[y]<=(n-1)/2)? dfs(y, x+1, cnt):0;\n\tif(y < x){\n\t  cnt[y] -= num;\n\t  cnt[x] -= !num;\n\t}\n\treturn res;\n      }\n\n      int res = 0;\n      for(int num=0;num<2;num++){\n\tif(y < x){\n\t  cnt[y] += num;\n\t  cnt[x] += !num;\n\t  mat[y][x] = num == 1? 1:-1;\n\t  mat[x][y] = num == 1? -1:1;\n\t}\n\tres += (cnt[x] <= (n-1) /2 && cnt[y]<=(n-1)/2)? dfs(y, x+1, cnt):0;\n\tif(y < x){\n\t  cnt[y] -= num;\n\t  cnt[x] -= !num;\n\t  mat[y][x] = 0;\n\t  mat[x][y] = 0;\n\t}\n      }\n      return res;\n    };\n\n    vector<int> cnt(n, 0);\n    int ans = dfs(0, 0, cnt);\n    cout<<ans<<endl;\n    \n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, m, ans, table[9][9];\n\nint check(){\n\tfor(int i=0; i<n; i++){\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; j++) tmp += table[i][j];\n\t\tif(tmp) return 0;\n\t}\n\treturn 1;\n}\n\n\nvoid dfs(int x, int y){\n\tif(x < n-1) x++;\n\telse if(y < n-1){\n\t\tx=0;\n\t\ty++;\n\t} else{\n\t\tans += check();\n\t\treturn;\n\t}\n\n\tif(x==0 && 0<y){\n\t\tint tmp =0;\n\t\tfor(int i=0; i<n; i++) tmp += table[y-1][i];\n\t\tif(tmp) return;\n\t}\n\n\tif(table[y][x] == 0 && y != x){\n\t\ttable[y][x] = 1;\n\t\ttable[x][y] = -1;\n\t\tdfs(y, x);\n\n\t\ttable[y][x] = -1;\n\t\ttable[x][y] = 1;\n\t\tdfs(y, x);\n\n\t\ttable[y][x] = table[x][y] = 0;\n\t} else dfs(x, y);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfill(table[0], table[8], 0);\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\ttable[x][y] = 1;\n\t\t\ttable[y][x] = -1;\n\t\t}\n\n\t\tans = 0;\n\t\tdfs(0, 0);\n\t\tcout << ans << endl;\n\t}\n\twhile(1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n,m;\nvector<int> yet[10];\nint dp[10][2000100];\nint x[100],y[100];\nint f[10][10];\nint fpow[20];\nint tmp[20];\nint k;\nint encode(int s){\n\tint res = 0;\n\tfor(int i=s;i<n;i++){\n\t\tres = res*5+tmp[i];\n\t}\n\treturn res;\n}\nvoid decode(int S){\n\tfor(int i=n-1;i>=0;i--){\n\t\ttmp[i]=S%5;\n\t\tS/=5;\n\t}\n}\nvoid print(){\n\tfor(int i=0;i<n;i++){\n\t\tcout << tmp[i] << ' ';\n\t}\n\tcout << endl;\n}\nbool solve(){\n\tscanf(\"%d\",&n);\n\tif(n==0)return false;\n\tscanf(\"%d\",&m);\n\tmemset(f,-1,sizeof(f));\n\tmemset(dp,0,sizeof(dp));\n\tfor(int i=0;i<n;i++)yet[i].clear();\n\tk = (n-1)/2;\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\tx[i]--;y[i]--;\n\t\tf[x[i]][y[i]]=1;\n\t\tf[y[i]][x[i]]=0;\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcout << f[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tfor(int i=0;i<n;i++){\n\t\ttmp[i]=k;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(f[i][j]==1)tmp[i]--;\n\t\t}\n\t\tif(tmp[i]<0){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tcout << tmp[i] << endl;\n\t}*/\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(f[i][j]==-1)yet[i].pb(j);\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<yet[i].size();j++){\n\t\t\tcout << yet[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tdp[0][encode(0)]=1;\n\tfor(int i=0;i<n-1;i++){\n\t\tint yy = yet[i].size();\n\t\tfor(int j=0;j<fpow[n-i];j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\tdecode(j);\n\t\t\tfor(int k=0;k<(1<<yy);k++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int l=0;l<yy;l++){\n\t\t\t\t\tif((k>>l)&1){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(tmp[yet[i][l]]==0){\n\t\t\t\t\t\t\tcnt=-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt!=tmp[i])continue;\n\t\t\t\tfor(int l=0;l<yy;l++){\n\t\t\t\t\tif(!((k>>l)&1)){\n\t\t\t\t\t\ttmp[yet[i][l]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i+1][encode(i+1)]+=dp[i][j];\n\t\t\t\tdecode(j);\n\t\t\t}\n\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n-1][0]);\n\treturn true;\n}\nint main(){\n\tfpow[0]=1;\n\tfor(int i=0;i<10;i++)fpow[i+1]=fpow[i]*5;\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n\nint N, M, A[9][9];\n//---------------------------------------------------------------------------------------------------\nint check(int y) {\n    int win = 0, lose = 0;\n    rep(x, 0, N) {\n        if (A[y][x] == 1) win++;\n        else if (A[y][x] < 0 and y != x) lose++;\n    }\n    return win <= (N - 1) / 2 and (N - 1) / 2 <= win + lose;\n}\n//---------------------------------------------------------------------------------------------------\nint answer = 0;\nvoid dfs(int cu) {\n    int x = cu % N;\n    int y = cu / N;\n\n    if (cu == N * N) {\n        answer++;\n        return;\n    }\n\n    if (x == y or 0 <= A[y][x]) {\n        if (check(y)) dfs(cu + 1);\n        return;\n    }\n    \n    A[y][x] = 1; A[x][y] = 0;\n    if(check(y)) dfs(cu + 1);\n\n    A[y][x] = 0; A[x][y] = 1;\n    if (check(y)) dfs(cu + 1);\n\n    A[y][x] = A[x][y] = -1;\n}\n\n//---------------------------------------------------------------------------------------------------\n\nvoid _main() {\n    while (cin >> N) {\n        if (N == 0) return;\n        cin >> M;\n        rep(i, 0, N) rep(j, 0, N) A[i][j] = -1;\n        rep(i, 0, M) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            A[a][b] = 1;\n            A[b][a] = 0;\n        }\n\n        answer = 0;\n        dfs(0);\n        printf(\"%d\\n\", answer);\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint ans;\nint n;\nint tab[10][10]; // (i,j) i won against j?\nbool fix[10][10];\n\nvoid reset()\n{\n    for(int i=0; i<10; ++i)\n    {\n        for(int j=0; j<10; ++j)\n        {\n            fix[i][j]=false;\n            tab[i][j]=0;\n        }\n    }\n    ans=0;\n}\n\nvoid dfs(int now)\n{\n    if(now==n)\n    {\n        ans++;\n        return;\n    }\n\n    int k=n-1-now;\n    int win=now;\n\n    for(int j=0; j<now; ++j)\n    {\n        win-=tab[j][now];\n    }\n\n    for(int s=0; s<1<<k; ++s)\n    {\n        bool ok=true;\n        int poc=0;\n        for(int i=0; i<k; ++i)\n        {\n            if(s>>i&1) poc++;\n            int j=i+now+1;\n            if(fix[now][j] and (s>>i&1)!=tab[now][j])\n            {\n                ok=false;\n            }\n        }\n        if(ok and __builtin_popcount(s)+win==n/2)\n        {\n            for(int i=0; i<k; ++i)\n            {\n                int j=i+now+1;\n                tab[j][now]=!(tab[now][j]=(s>>i&1));\n            }\n            dfs(now+1);\n        }\n    }\n}\n\nmain()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while(true)\n    {\n        cin>>n;\n        if(!n) break;\n        reset();\n\n        int m; cin>>m;\n        while(m--)\n        {\n            int a,b; cin>>a>>b; --a,--b;\n            tab[a][b]=1;\n            tab[b][a]=0;\n            fix[a][b]=fix[b][a]=1;\n        }\n\n        dfs(0);\n\n        cout << ans << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n,m;\nint rem[10];\nvector<int> yet[10];\nint dp[10][400100];\nint x[100],y[100];\nint f[10][10];\nint fpow[20];\nint tmp[20];\nint k;\nint encode(int s){\n\tint res = 0;\n\tfor(int i=s;i<n;i++){\n\t\tres = res*5+tmp[i];\n\t}\n\treturn res;\n}\nvoid decode(int S){\n\tfor(int i=n-1;i>=0;i--){\n\t\ttmp[i]=S%5;\n\t\tS/=5;\n\t}\n}\nvoid print(){\n\tfor(int i=0;i<n;i++){\n\t\tcout << tmp[i] << ' ';\n\t}\n\tcout << endl;\n}\nbool solve(){\n\tscanf(\"%d\",&n);\n\tif(n==0)return false;\n\tscanf(\"%d\",&m);\n\tmemset(f,-1,sizeof(f));\n\tmemset(rem,0,sizeof(rem));\n\tmemset(dp,0,sizeof(dp));\n\tfor(int i=0;i<n;i++)yet[i].clear();\n\tk = (n-1)/2;\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\tx[i]--;y[i]--;\n\t\tf[x[i]][y[i]]=1;\n\t\tf[y[i]][x[i]]=0;\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcout << f[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tfor(int i=0;i<n;i++){\n\t\ttmp[i]=k;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(f[i][j]==1)tmp[i]--;\n\t\t}\n\t\tif(tmp[i]<0){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tcout << tmp[i] << endl;\n\t}*/\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(f[i][j]==-1)yet[i].pb(j);\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<yet[i].size();j++){\n\t\t\tcout << yet[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tdp[0][encode(0)]=1;\n\tfor(int i=0;i<n-1;i++){\n\t\tint yy = yet[i].size();\n\t\tfor(int j=0;j<fpow[n-i];j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\t//print();\n\t\t\tdecode(j);\n\t\t\tfor(int k=0;k<(1<<yy);k++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int l=0;l<yy;l++){\n\t\t\t\t\tif((k>>l)&1){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(tmp[yet[i][l]]==0){\n\t\t\t\t\t\t\tcnt=-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if(j==31)cout << j << ' ' << k << ' ' << cnt  << ' ' << tmp[i] << endl;\n\t\t\t\tif(cnt!=tmp[i])continue;\n\t\t\t\t//if(j==31)cout << j << ' ' << k << ' ' << cnt << endl;\n\t\t\t\t//cout << j << \" -> (\"  << k << ')'; \n\t\t\t\tfor(int l=0;l<yy;l++){\n\t\t\t\t\tif(!((k>>l)&1)){\n\t\t\t\t\t\ttmp[yet[i][l]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i+1][encode(i+1)]+=dp[i][j];\n\t\t\t\t//print();\n\t\t\t\tdecode(j);\n\t\t\t}\n\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n-1][0]);\n\treturn true;\n}\nint main(){\n\tfpow[0]=1;\n\tfor(int i=0;i<10;i++)fpow[i+1]=fpow[i]*5;\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n\n\nint N, M, A[9][9];\nint check(int y) {\n    int win = 0, non = 0;\n    rep(x, 0, N) {\n        if (A[y][x] == 1) win++;\n        else if (A[y][x] < 0 and y != x) non++;\n    }\n    return win <= (N - 1) / 2 and (N - 1) / 2 <= win + non;\n}\nint ans = 0;\nvoid dfs(int cu) {\n    int x = cu % N;\n    int y = cu / N;\n\n    if (cu == N * N) {\n        ans++;\n        return;\n    }\n\n    if (x == y or 0 <= A[y][x]) {\n        if (check(y)) dfs(cu + 1);\n        return;\n    }\n\n    A[y][x] = 1; A[x][y] = 0;\n    if(check(y)) dfs(cu + 1);\n\n    A[y][x] = 0; A[x][y] = 1;\n    if (check(y)) dfs(cu + 1);\n\n    A[y][x] = A[x][y] = -1;\n}\nvoid _main() {\n    while (cin >> N) {\n        if (N == 0) return;\n        cin >> M;\n        rep(i, 0, N) rep(j, 0, N) A[i][j] = -1;\n        rep(i, 0, M) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            A[a][b] = 1;\n            A[b][a] = 0;\n        }\n\n        ans = 0;\n        dfs(0);\n        printf(\"%d\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, m, ans, table[9][9];\n\nint check(){\n\tfor(int i=0; i<n; i++){\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; j++) tmp += table[i][j];\n\t\tif(tmp) return 0;\n\t}\n\treturn 1;\n}\n\n\nvoid dfs(int x, int y){\n\tif(x < n-1) x++;\n\telse if(y < n-1){\n\t\tx=0;\n\t\ty++;\n\t} else{\n\t\tans += check();\n\t\treturn;\n\t}\n\n\tif(x==0 && 0<y){\n\t\tint tmp =0;\n\t\tfor(int i=0; i<n; i++) tmp += table[y-1][i];\n\t\tif(tmp) return;\n\t}\n\n\tif(table[y][x] == 0 && y != x){\n\t\ttable[y][x] = 1;\n\t\ttable[x][y] = -1;\n\t\tdfs(y, x);\n\n\t\ttable[y][x] = -1;\n\t\ttable[x][y] = 1;\n\t\tdfs(y, x);\n\n\t\ttable[y][x] = table[x][y] = 0;\n\t} else dfs(x, y);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfill(table[0], table[8], 0);\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\ttable[x][y] = 1;\n\t\t\ttable[y][x] = -1;\n\t\t}\n\n\t\tans = 0;\n\t\tdfs(0, 0);\n\t\tcout << ans << endl;\n\t}\n\twhile(1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint grid[50][50];\nint n, m;\n\nbool check(int y) {\n    int win = 0, draw = 0;\n    for (int x = 0; x < n; x++) {\n        if (y == x) continue;\n        if (grid[y][x] == 1) win++;\n        if (grid[y][x] == 0) draw++;\n    }\n    return win <= (n - 1) / 2 && win + draw >= (n - 1) / 2;\n}\n\nll ans;\nvoid dfs(int cur) {\n    int x = cur % n;\n    int y = cur / n;\n    if (cur == n * n) {\n        ans++;\n        return;\n    }\n    // 自分自身 or 既に埋まってる\n    if (y == x || grid[y][x] != 0) {\n        if (check(y)) dfs(cur + 1);\n        return;\n    }\n    grid[y][x] = 1;\n    grid[x][y] = -1;\n    if (check(y)) dfs(cur + 1);\n    grid[y][x] = -1;\n    grid[x][y] = 1;\n    if (check(y)) dfs(cur + 1);\n    grid[y][x] = grid[x][y] = 0;\n}\n\nint main() {\n    while (cin >> n, n) {\n        cin >> m;\n        memset(grid, 0, sizeof(grid));\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            grid[x][y] = 1;\n            grid[y][x] = -1;\n        }\n        ans = 0;\n        dfs(0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint info[10][10], ans, lim;\n\nvoid get_assignment(vector< pair<int, int> > &rem, vector<int> &win, int cur) {\n    if(cur == rem.size()) {\n        bool ok = true;\n        for(auto e : win) ok &= (e <= lim);\n        if(ok) ans++;\n    }\n    else {\n        int u, v; tie(u, v) = rem[cur];\n        {\n            win[u]++;\n            if(win[u] <= lim) {\n                get_assignment(rem, win, cur + 1);\n            }\n            win[u]--;\n        }\n\n        {\n            win[v]++;\n            if(win[v] <= lim) {\n                get_assignment(rem, win, cur + 1);\n            }\n            win[v]--;\n        }\n    }\n}\n\nint solve() {\n    int N; cin >> N;\n    if(N == 0) return 1;\n    int M; cin >> M;\n\n    // init\n    fill(info[0], info[N], -1);\n    ans = 0; lim = N * (N - 1) / 2 / N;\n    \n    vector<int> win(N);\n    for(int i=0; i<M; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        info[u][v] = 1;\n        info[v][u] = 0;\n        win[u]++;\n    }\n\n    vector< pair<int, int> > rem;\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            if(info[i][j] < 0) {\n                rem.emplace_back(i, j);\n            }\n        }\n    }\n\n    get_assignment(rem, win, 0);\n    cout << ans << endl;\n    return 0;\n}\n \nsigned main() {\n    while(!solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n\n\nstruct Point{\n    int t1,t2;\n    Point(int t1,int t2){\n        this->t1=t1;\n        this->t2=t2;\n    }\n};\nvector<vector<int>> v;\nvector<Point> points;\nint n;\nint ans=0;\n\nvoid debug(){\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            cout<<v[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\n\nbool will_playoff(int t1){\n    int win=0,lose=0,not_match=0;\n    for(int i=0;i<n;i++){\n        if(t1==i)continue;\n        if(v[t1][i]==1)win++;\n        else if(v[t1][i]==0)lose++;\n        else not_match++;\n    }\n    if(abs(win-lose)>not_match)return false;\n    else return true;\n}\n\nbool is_playoff(){\n    for(int i=0;i<n;i++){\n        int win=0,lose=0;\n        for(int j=0;j<n;j++){\n            if(i==j)continue;\n            if(v[i][j]==1)win++;\n            else if(v[i][j]==0)lose++;\n        }\n        if(win!=lose)return false;\n    }\n    return true;\n}\n\nvoid dfs(int idx){\n    //debug(v);\n    if(idx==points.size()){\n        if(is_playoff())ans++;\n        //ans++;\n        return;\n    }\n    Point point=points[idx];\n    v[point.t1][point.t2]=1;\n    v[point.t2][point.t1]=0;\n    if(will_playoff(point.t1))dfs(idx+1);\n\n    v[point.t1][point.t2]=0;\n    v[point.t2][point.t1]=1;\n    if(will_playoff(point.t1))dfs(idx+1);\n\n    v[point.t1][point.t2]=v[point.t2][point.t1]=-1;\n    return;\n}\n\nint main(){\n    while(cin>>n){\n        if(n==0)break;\n        v.clear();\n        v.resize(10,vector<int>(10,-1));\n        points.clear();\n        ans=0;\n        int m;cin>>m;\n        for(int i=0;i<m;i++){\n            int win,lose;\n            cin>>win>>lose;\n            win--; lose--;\n            v[win][lose]=1;\n            v[lose][win]=0;\n        }\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                if(v[i][j]==-1 and i!=j)points.push_back(Point{i,j});\n            }\n        }\n        dfs(0);\n        cout<<ans<<endl;\n\n    }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n \nusing namespace std;\n \nint n, m, ans, table[9][9];\n \nint chack(){\n    for(int i=0; i<n; i++){\n        int tmp=0;\n        for(int j=0; j<n; j++) tmp += table[i][j];\n        if(tmp) return 0;\n    }\n    return 1;\n}\n \n \nvoid solve(int x, int y){\n    if(y < n-1) y++;\n    else if(x < n-1){\n        y=0;\n        x++;\n    }else {\n        ans += chack();\n        return;\n    }\n     \n    if(y==0 && 0<x){\n        int tmp =0;\n        for(int i=0; i<n; i++) tmp +=table[x-1][i];\n        if(tmp) return;\n    }   \n \n    if(table[x][y] == 0 && x != y){\n        table[x][y] = 1;\n        table[y][x] = -1;\n        solve(x, y);\n \n        table[x][y] = -1;\n        table[y][x] = 1;\n        solve(x, y);\n \n        table[x][y] = table[y][x] = 0;\n    } else solve(x, y);\n}\n \n \nint main(void) {\n    while(1) {\n        cin >> n;\n        if(!n) break;\n        fill(table[0], table[8], 0);\n        cin >> m;\n        for(int i=0; i<m; i++){\n            int x, y; cin >> x >> y;\n            x--; y--;\n            table[x][y] = 1;\n            table[y][x] = -1;\n        }\n \n        ans = 0;\n        solve(0, 0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P ,P> PP;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(2e5) + 5;\nconstexpr double EPS = 1e-8;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\n\nint n, m, tab[10][10], cnt[10][2];\n\nint rec(int i, int j){\n    if(i==n) return 1;\n    if(j==n) return rec(i+1,0);\n    if(tab[i][j] != -1) return rec(i,j+1);\n\n    int res = 0;\n    if(cnt[i][0] < n/2 && cnt[j][1] < n/2){\n        cnt[i][0]++;\n        cnt[j][1]++;\n        tab[i][j] = 1;\n        tab[j][i] = 0;\n        res += rec(i,j+1);\n        tab[i][j] = -1;\n        tab[j][i] = -1;\n        cnt[i][0]--;\n        cnt[j][1]--;\n    }\n    if(cnt[i][1] < n/2 && cnt[j][0] < n/2){\n        cnt[i][1]++;\n        cnt[j][0]++;\n        tab[i][j] = 0;\n        tab[j][i] = 1;\n        res += rec(i,j+1);\n        tab[i][j] = -1;\n        tab[j][i] = -1;\n        cnt[i][1]--;\n        cnt[j][0]--;\n    }\n    return res;\n}\n\nint main() {\n    while(cin >> n, n){\n        REP(i,n)fill(tab[i],tab[i]+n,-1);\n        REP(i,n) tab[i][i] = 2;\n        REP(i,n) cnt[i][0] = cnt[i][1] = 0;\n        cin >> m;\n        REP(i,m){\n            int x, y;\n            cin >> x >> y;\n            x--; y--;\n            tab[x][y] = 1;\n            tab[y][x] = 0;\n            cnt[x][0]++;\n            cnt[y][1]++;\n        }\n        bool ok = true;\n        REP(i,n){\n            ok &= cnt[i][0] <= n/2 && cnt[i][1] <= n/2;\n        }\n        if(ok){\n            cout << rec(0,0) << endl;\n        }\n        else {\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,m,mp[9][9],win[9],border,cnt;\n\nint dfs(int x,int y) {\n  if( y >= n ) return ++cnt; \n  \n  int nx = x + 1, ny = y;\n  if( nx >= ny ) nx = 0, ++ny;\n\n  if( mp[x][y] != -1 ) return dfs(nx,ny);\n\n  int c[2] = {x,y};\n  rep(i,2) {\n    mp[c[i]][c[(i+1)%2]] = 0, mp[c[(i+1)%2]][c[i]] = 1, ++win[c[i]];\n    if( win[c[i]] <= border ) dfs(nx,ny);\n    --win[c[i]];\n  }\n\n  mp[x][y] = mp[y][x] = -1;\n  \n}\n\nint main() {\n  while( cin >> n, n ) {\n    memset(mp,-1,sizeof mp);\n    memset(win,0,sizeof win);\n    border = ( n * n - n ) / ( n * 2 );\n    cnt = 0;\n    cin >> m;\n    int x,y;\n    rep(i,m) {\n      cin >> x >> y;\n      --x, --y;\n      mp[x][y] = 1, mp[y][x] = 0, ++win[x];\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define itn int\nusing uint = unsigned int;\nusing lint = long long int;\nusing llint = long long int;\nusing ulint = unsigned long long int;\nusing ullint = ulint;\n\n#define DEBUG\n#ifdef DEBUG\n#define dump(x) cout << \"[*]\" #x \":\" << x << endl\n#define debug(x) x\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\nint n, m;\nint res[10][10];\nint dp[50][2000000];\nint beki[10];\n\nint add(int s, int i)\n{\n  return s + beki[i];\n}\n\nint get(int s, int i)\n{\n  s /= beki[i];\n  return s % 5;\n}\n\n\n\nint main() {\n\n  int q = 1;\n  for(int i = 0; i < 10; i++) beki[i] = q, q *= 5;\n\n  while (true) {\n    cin >> n;\n    if(n == 0) break;\n    cin >> m;\n\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\t       res[i][j] = 0;\n      }\n    }\n    int u, v;\n    int is = 0;\n    for(int i = 0; i < m; i++){\n      cin >> u >> v;\n      u--, v--;\n      res[u][v] = 1;\n      res[v][u] = -1;\n      is = add(is, u);\n    }\n    int S = beki[n];\n    int N = n*(n-1)/2;\n    int X = (n-1)/2;\n\n    for(int x = 0; x <= N; x++){\n      for(int k = 0; k < S; k++){\n\t       dp[x][k] = 0;\n      }\n    }\n    dp[0][is] = 1;\n\n\n    bool flag = false;\n    for(int i = 0; i < n; i++){\n      if(get(is, i) > X){\n      \tcout << 0 << endl;\n      \tflag = true;\n      }\n    }\n    if(flag) continue;\n\n    int x = -1;\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n    \tif(i >= j) continue;\n    \tx++;\n    \tif(res[i][j]){\n        for(int s = 0; s < S; s++) dp[x+1][s] = dp[x][s];\n        continue;\n      }\n        \tfor(int s = 0; s < S; s++){\n        \t  if(get(s, i) < X){\n        \t    dp[x+1][add(s, i)] += dp[x][s];\n        \t  }\n        \t  if(get(s, j) < X){\n        \t    dp[x+1][add(s, j)] += dp[x][s];\n        \t  }\n        \t}\n      }\n    }\n\n    int as = 0;\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < X; j++){\n\tas = add(as, i);\n      }\n    }\n    cout << dp[N][as] << endl;\n\n    break;\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(long long int i=0;i<n;++i)\ntypedef long long int ll;\n\nvector<vector<int>> t;\nint n;\nvector<pair<int,int>> nn;\n\nbool check(int a,int b){\n    int aw=0,al=0;\n    int bw=0,bl=0;\n    for(int i=0;i<n;i++){\n        if(t[a][i]==1)aw++;\n        if(t[a][i]==-1)al++;\n        if(t[b][i]==1)bw++;\n        if(t[b][i]==-1)bl++;\n    }\n    if(aw>(n-1)/2||al>(n-1)/2||bw>(n-1)/2||bl>(n-1)/2){\n        return false;\n    }else{\n        return true;\n    }\n}\n\nint dfs(int id){\n    int x=nn[id].first;\n    int y=nn[id].second;\n    id++;\n    int ans=0;\n    if(t[x][y]!=0){\n        if(check(x,y)){\n            if(id==nn.size()){\n                ans+=1;\n            }else{\n                ans+=dfs(id);\n            }\n        }\n    }else{\n        t[x][y]=1;\n        t[y][x]=-1;\n        if(check(x,y)){\n            if(id==nn.size()){\n                ans+=1;\n            }else{\n                ans+=dfs(id);\n            }\n        }\n        t[x][y]=-1;\n        t[y][x]=1;\n        if(check(x,y)){\n            if(id==nn.size()){\n                ans+=1;\n            }else{\n                ans+=dfs(id);\n            }\n        }\n        t[x][y]=0;\n        t[y][x]=0;\n    }\n    return ans;\n}\n\nint main(){\n\n    while(1){\n        int m;\n        cin >> n;\n        if(n==0)break;\n        cin >> m;\n        t.clear();\n        t.resize(n,vector<int>(n,0));\n        nn.clear();\n        for(int i=1;i<n;i++){\n            for(int j=0;j<i;j++){\n                nn.push_back({i,j});\n            }\n        }\n        for(int i=0;i<m;i++){\n            int x,y;\n            cin >> x >> y;\n            x--;y--;\n            t[x][y]=1;\n            t[y][x]=-1;\n        }\n        int ans=dfs(0);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint ans = 0;\nint n;\nint win[10];\nchar mp[10][10];\n\nvoid dfs(int a,int b){\n\t\n\tif(a == n-1 && b == n-1){\n\t\tans++;\n\t\treturn;\n\t}\n\tif(b == n){\n\t\ta++;\n\t\tb = 0;\n\t}\n\t\n\tif(a == b || mp[a][b] != '-'){\n\t\tdfs(a,b+1);\n\t}\n\telse{\n\t\tif(win[a] < (n-1) / 2){\n\t\t\tmp[a][b] = 'o';\n\t\t\tmp[b][a] = 'x';\n\t\t\twin[a]++;\n\t\t\tdfs(a,b+1);\n\t\t\twin[a]--;\n\t\t\tmp[a][b] = '-';\n\t\t\tmp[b][a] = '-';\t\t\t\n\t\t}\n\t\tif(win[b] < (n-1) / 2){\n\t\t\tmp[a][b] = 'x';\n\t\t\tmp[b][a] = 'o';\n\t\t\twin[b]++;\n\t\t\tdfs(a,b+1);\n\t\t\twin[b]--;\n\t\t\tmp[a][b] = '-';\n\t\t\tmp[b][a] = '-';\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tans = 0;\n\tREP(i,10){\n\t\twin[i] = 0;\n\t\tREP(j,10){\n\t\t\tmp[i][j] = '-';\n\t\t}\n\t}\n\tint m;cin >> m;\n\tREP(i,m){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tmp[a][b] = 'o';\n\t\tmp[b][a] = 'x';\n\t\twin[a]++;\n\t}\n\t\n\tREP(i,n){\n\t\tif(win[i] > (n-1) / 2){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\t\n\tdfs(0,0);\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\t\n\twhile(cin >> n,n){\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,m,mp[9][9],win[9],border,cnt;\n\nint dfs(int x,int y) {\n  if( y >= n ) return ++cnt; \n  \n  int nx = x + 1, ny = y;\n  if( nx >= ny ) nx = 0, ++ny;\n\n  if( mp[x][y] != -1 ) return dfs(nx,ny);\n\n  int c[2] = {x,y};\n  rep(i,2) {\n    mp[c[i]][c[(i+1)%2]] = 0, mp[c[(i+1)%2]][c[i]] = 1, ++win[c[i]];\n    if( win[c[i]] <= border ) dfs(nx,ny);\n    --win[c[i]];\n  }\n\n  mp[x][y] = mp[y][x] = -1;\n  \n}\n\nint main() {\n  while( cin >> n, n ) {\n    memset(mp,-1,sizeof mp);\n    memset(win,0,sizeof win);\n    border = ( n * n - n ) / ( n * 2 );\n    cnt = 0;\n    cin >> m;\n    int x,y;\n    rep(i,m) {\n      cin >> x >> y;\n      --x, --y;\n      mp[x][y] = 1, mp[y][x] = 0, ++win[x];\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint tab[15][15],a[15][15],fl[15][15],fi[15];\nint n,m,w,l,ans;\n\nvoid perm(int team,int wn,int ls,int cur){\n    if(wn==0&&ls==0){\n        if(team==n){\n            ans++;\n            return ;\n        }\n        int j=0;\n        int il[15],ii=0;\n        for(int i=1;i<=n;i++){\n            if(tab[team][i]==0&&i!=team){\n                il[ii++]=i;\n                tab[team][i]=fl[team][j];\n                tab[i][team]=fl[team][j++]%2+1;\n            }\n        }\n        w=n/2; l=n/2;\n        for(int i=1;i<=n;i++){\n            if(tab[team+1][i]==1)\n                w--;\n            else if(tab[team+1][i]==2)\n                l--;\n        }\n        perm(team+1,w,l,0);\n        for(int i=0;i<ii;i++){\n            tab[team][il[i]]=0;\n            tab[il[i]][team]=0;\n        }\n        return ;\n    }\n    if(wn>0){\n        fl[team][cur]=1;\n        perm(team,wn-1,ls,cur+1);\n    }\n    if(ls>0){\n        fl[team][cur]=2;\n        perm(team,wn,ls-1,cur+1);\n    }\n}\n\nint main(){\n    while(true){\n        ans=0;\n        scanf(\"%d\",&n);\n        if(n==0)\n            return 0;\n        for(int i=0;i<=n;i++){\n            for(int j=0;j<=n;j++){\n                tab[i][j]=0;\n                a[i][j]=0;\n                fl[i][j]=0;\n            }\n            fi[i]=0;\n        }\n        scanf(\"%d\",&m);\n        int tmp1,tmp2;\n        for(int i=0;i<m;i++){\n            scanf(\"%d%d\",&tmp1,&tmp2);\n            a[tmp1][tmp2]=tab[tmp1][tmp2]=1;\n            a[tmp1][tmp2]=tab[tmp2][tmp1]=2;\n        }\n        w=n/2; l=n/2;\n        for(int i=1;i<=n;i++){\n            if(tab[1][i]==1){\n                w--;\n            }\n            else if(tab[1][i]==2)\n                l--;\n        }\n        perm(1,w,l,0);\n        printf(\"%d\\n\",ans);\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nint ans;\nvoid dfs(vector<vector<int> > &a,vector<int> &win,vector<int> &lose){\n    int z = 0;\n    rep(i,a.size())rep(j,i)if(a[i][j] == 0){\n        z++;\n        if(win[i] && lose[j]){\n            a[i][j]++;\n            win[i]--;\n            lose[j]--;\n            dfs(a,win,lose);\n            a[i][j]--;\n            win[i]++;\n            lose[j]++;\n        }\n        if(lose[i] && win[j]){\n            a[i][j]--;\n            win[j]--;\n            lose[i]--;\n            dfs(a,win,lose);\n            a[i][j]++;\n            win[j]++;\n            lose[i]++;\n        }\n        return;\n    }\n    ans++;\n}\n\n\nint main(){\n    int n,m;\n    while(cin >> n,n){\n        vector<vector<int> > a(n,vector<int>(n,0));//1:win, -1;lose\n        vector<int> win,lose;//残りの数\n        win = lose = vector<int>(n,n/2);\n        cin >> m;\n        bool c = true;\n        rep(i,m){\n            int x,y;\n            cin >> x >> y;\n            x--,y--;\n            win[x]--;\n            lose[y]--;\n            a[x][y]++;\n            a[y][x]--;\n            if(win[x] < 0 || lose[y] < 0)c = false;\n        }\n        ans = 0;\n        if(c)rep(i,n)rep(j,i)if(a[i][j] == 0){\n            dfs(a,win,lose);\n            i = n;break;\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define all(a) a.begin(),a.end()\nconst long long MOD = 1e9+7, INF = 1e18;\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\n\nint N,M;\n\nint f(vector<vector<int>>&v,int now){\n\tif(now==N*N){\n\t\t/*\n\t\trep(i,0,N){\n\t\t\trep(j,0,N){\n\t\t\t\tif(j)cout<<\" \";\n\t\t\t\tcout<<v[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\t*/\n\t\treturn 1;\n\t}\n\tint tate = now / N;\n\tint yoko = now % N;\n\tint ret = 0;\n\tint win = 0;\n\tint lose = 0;\n\trep(i,0,N){\n\t\tif(v[tate][i]==1)win++;\n\t\telse if(v[tate][i]==-1)lose++;\n\t}\n\tif(win>(N-1)/2) return 0;\n\tif(lose>(N-1)/2)return 0;\n\tif(tate==yoko || v[tate][yoko])ret += f(v,now+1);\n\telse{\n\t\t\n\t\tif(win<(N-1)/2){\n\t\t\tv[tate][yoko] = 1;\n\t\t\tv[yoko][tate] = -1;\n\t\t\tret += f(v,now+1);\n\t\t\tv[tate][yoko] = v[yoko][tate] = 0;\n\t\t}\n\t\tif(lose<(N-1)/2){\n\t\t\tv[tate][yoko] = -1;\n\t\t\tv[yoko][tate] = 1;\n\t\t\tret += f(v,now+1);\n\t\t\tv[tate][yoko] = v[yoko][tate] = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nsigned main(){\n\tIOS();\n\tvector<int>ans;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0)break;\n\t\tcin>>M;\n\t\tvector<vector<int>>v(N,vector<int>(N,0));\n\t\trep(i,0,M){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tv[a][b] = 1;\n\t\t\tv[b][a] = -1;\n\t\t}\n\t\tans.push_back(f(v,0));\n\t}\n\tfor(auto e:ans){\n\t\tcout<<e<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e17+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//  16:30-\n//A 16:36\n//B 16:46\n//C 16:51\n//D 17:15WA\n//D 17:17TLE\nint n;\nvector<pair<int,int>>mada;\nvector<vector<int>>taisen;\nmap<vector<int>,llint>memo;\nllint sai(vector<int>win,int kai){\n\tif(kai>=mada.size()){return 1;}\n\tif(memo.count(win)){return memo[win];}\n\tint A=mada[kai].fir,B=mada[kai].sec;\n\tauto wina=win,winb=win;\n\tllint ans=0;\n\twina[A]++;\n\tif(wina[A]<=n/2&&taisen[kai][B]-wina[B]<=n/2){ans+=sai(wina,kai+1);}\n\twinb[mada[kai].sec]++;\n\tif(winb[B]<=n/2&&taisen[kai][A]-winb[A]<=n/2){ans+=sai(winb,kai+1);}\n\tmemo[win]=ans;\n\treturn ans;\n}\nint solve(void){\n\tint i,j,m;cin>>n;\n\tmemo.clear();taisen.clear();mada.clear();\n\tif(n==0){return 0;}\n\tcin>>m;\n\tvector<int>win(n);\n\tint yata[9][9]={};\n\tvector<int>tai(n);\n\twhile(m--){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tyata[a][b]=1;yata[b][a]=1;win[a]++;\n\t\ttai[a]++;tai[b]++;\n\t}\n\t\n\t//cerr<<\"ans=\";\n\tfor(i=0;i<n;i++){\n\t\tif(win[i]>n/2){cout<<0<<endl;return 1;}\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tif(!yata[i][j]){\n\t\t\t\tmada.pub(mp(i,j));\n\t\t\t\ttai[i]++;tai[j]++;\n\t\t\t\ttaisen.pub(tai);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sai(win,0)<<endl;\n\t\n\treturn 1;\n}\nint main(void){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n\nint N, M, A[9][9];\n\n//---------------------------------------------------------------------------------------------------\nint answer = 0;\nvoid dfs(int cu) {\n    int x = cu % N;\n    int y = cu / N;\n\n    if (cu == N * N) {\n        answer++;\n        return;\n    }\n\n    if (x == y or 0 <= A[y][x]) {\n        if (check(y)) dfs(cu + 1);\n        return;\n    }\n    \n    A[y][x] = 1; A[x][y] = 0;\n    if(check(y)) dfs(cu + 1);\n\n    A[y][x] = 0; A[x][y] = 1;\n    if (check(y)) dfs(cu + 1);\n\n    A[y][x] = A[x][y] = -1;\n}\n//---------------------------------------------------------------------------------------------------\nint check(int y) {\n    int win = 0, lose = 0;\n    rep(x, 0, N) {\n        if (A[y][x] == 1) win++;\n        else if (A[y][x] < 0 and y != x) lose++;\n    }\n    return win <= (N - 1) / 2 and (N - 1) / 2 <= win + lose;\n}\n//---------------------------------------------------------------------------------------------------\n\nvoid _main() {\n    while (cin >> N) {\n        if (N == 0) return;\n        cin >> M;\n        rep(i, 0, N) rep(j, 0, N) A[i][j] = -1;\n        rep(i, 0, M) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            A[a][b] = 1;\n            A[b][a] = 0;\n        }\n\n        answer = 0;\n        dfs(0);\n        printf(\"%d\\n\", answer);\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,b,e) for(int i=(b);i<(e);++i)\n#define rep(i,e) for(int i=0;i<(e);++i)\n\nint n, m, ans, match[9][9];\n\nbool check(int y){\n  int win=0, lose=0;\n  rep(x, n){\n    if(match[y][x]==1) win++;\n    else if(match[y][x]==-1) lose++;\n  }\n  return (win<=(n-1)/2 && lose<=(n-1)/2);\n}\n\nvoid dfs(int cur){\n  int x = cur%n;\n  int y = cur/n;\n\n  if(cur==n*n){\n    ans++; return;\n  }\n\n  if(x==y || match[y][x]!=0){\n    if(check(y)) dfs(cur+1);\n    return;\n  }\n\n  match[y][x] = 1; match[x][y] = -1;\n  if(check(y)) dfs(cur+1);\n\n  match[y][x] = -1; match[x][y] = 1;\n  if(check(y)) dfs(cur+1);\n\n  match[y][x] = match[x][y] = 0;\n}\n\nint main() {\n  while(cin>>n){\n    if(n==0) return 0;\n\n    memset(match, 0, sizeof(match));\n\n    cin >> m;\n    rep(i, m){\n      int x, y; cin >> x >> y;\n      x--; y--;\n      match[x][y] = 1;\n      match[y][x] = -1;\n    }\n\n    ans = 0;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  os << \"[\";\n  bool a = 1;\n  for(auto e : v) {\n    os << (a ? \"\" : \" \" );\n    os << e;\n    a = 0;\n  }\n  os << \"]\";\n  return os;\n}\n\nvector<vector<int>> a, result;\nll solve(vector<vector<int>>& a, vector<vector<int>>& result, int n, int y, int x, int su) {\n  if(y == n-1) {\n    bool ok = true;\n    for(int i=0;i<n;++i) {\n      int su = 0;\n      for(int j=0;j<n;++j) {\n        su += a[i][j] + result[i][j];\n      }\n      if(su != 0) {\n        ok = false;\n        break;\n      }\n    }\n    return ok ? 1 : 0;\n  } else if(x == n) {\n    su = 0;\n    for(int i=0;i<y+1;++i) {\n      su -= a[i][y+1] + result[i][y+1];\n    }\n    return solve(a, result, n, y+1, y+2, su);\n  } else if(result[y][x] != 0) {\n    su += result[y][x];\n    if(abs(su) <= n  - x) {\n      return solve(a, result, n, y, x+1, su);\n    } else {\n      return 0;\n    }\n  } else {\n    // next = 1\n    int res = 0;\n    a[y][x] = 1;\n    a[x][y] = -1;\n    su += a[y][x];\n    if(abs(su) <= n - x) {\n      res += solve(a, result, n, y, x+1, su);\n    }\n    su -= a[y][x];\n    // next = -1\n    a[y][x] = -1;\n    a[x][y] = 1;\n    su += a[y][x];\n    if(abs(su) <= n - x) {\n      res += solve(a, result, n, y, x+1, su);\n    }\n    su -= a[y][x];\n    a[y][x] = 0;\n    a[x][y] = 0;\n    return res;\n  }\n}\n\nint main () {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    vector<vector<int>> a(n, vector<int>(n, 0)), result(n, vector<int>(n, 0));\n    int m; cin >> m;\n    for(int i=0;i<m;++i) {\n      int x, y; cin >> x >> y;\n      x--; y--;\n      result[x][y] = 1;\n      result[y][x] = -1;\n    }\n    cout << solve(a, result, n, 0, 1, 0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\nint d[10] ;\nbool vis[10][10] ;\nint n ;\nint mp1[10000000] , mp2[10000000] ;\nint a[50] , b[50] , x[10] ;\nlong long ans ;\nvoid dfs( int k , int up ){\n    if ( k == up + 1 ){\n        int res = 0 ;\n        int j = 1 ;\n        for( int i = n ; i >= 1 ; i-- ){\n            res += d[i] * j ; j *= 5 ;\n        }\n        mp1[res]++ ;\n        return ;\n    }\n    d[a[k]]++ ;\n    if ( d[a[k]] <= n / 2 ) dfs( k + 1 , up ) ;\n    d[a[k]]-- ;\n    d[b[k]]++ ;\n    if ( d[b[k]] <= n / 2 ) dfs( k + 1 , up ) ;\n    d[b[k]]-- ;\n}\nvoid dfs2( int k , int up ){\n    if ( k == up + 1 ){\n        int res = 0 ;\n        int j = 1 ;\n        for( int i = n ; i >= 1 ; i-- ){\n            res += d[i] * j ; j *= 5 ;\n        }\n        mp2[res]++ ;\n        return ;\n    }\n    d[a[k]]++ ;\n    if ( d[a[k]] <= n / 2 ) dfs2( k + 1 , up ) ;\n    d[a[k]]-- ;\n    d[b[k]]++ ;\n    if ( d[b[k]] <= n / 2 ) dfs2( k + 1 , up ) ;\n    d[b[k]]-- ;\n}\nvoid dfs3( int k ){\n    if ( k == n + 1 ){\n        int res = 0 ;\n        int gg = 0 ;\n        int j = 1 ;\n        bool flag = true ;\n        for( int i = n ; i >= 1 ; i-- ){\n            res += x[i] * j ;\n            gg += ( n / 2 - x[i] + d[i] ) * j ;\n            if ( x[i] < d[i] ) flag = false ;\n            j *= 5 ;\n        }\n        if ( flag ) ans += ( long long )mp1[res] * mp2[gg] ;\n        return ;\n    }\n    for( int i = 0 ; i <= n / 2 ; i++ ){\n        x[k] = i ;\n        dfs3( k + 1 ) ;\n    }\n}\nint main(){\n    while( 1 ){\n          scanf( \"%d\" , &n ) ;\n          if ( n == 0 ) break ;\n          memset( d , 0 , sizeof( d ) ) ;\n          memset( vis , false , sizeof( vis ) ) ;\n          memset( mp1 , 0 , sizeof( mp1 ) ) ;\n          memset( mp2 , 0 , sizeof( mp2 ) ) ;\n          ans = 0 ;\n          int m ;\n          scanf( \"%d\" , &m ) ;\n          bool flag = true ;\n          for( int i = 1 ; i <= m ; i++ ){\n              int x , y ;\n              scanf( \"%d%d\" , &x , &y ) ;\n              d[x]++ ; vis[x][y] = vis[y][x] = true ;\n              if ( d[x] > n / 2 ){ flag = false ; break ; }\n          }\n          if ( !flag ){\n              printf( \"0\\n\" ) ;\n              continue ;\n          }\n          int sz = 0 ;\n          for( int i = 1 ; i <= n - 1 ; i++ )\n              for( int j = i + 1 ; j <= n ; j++ ){\n                  if ( !vis[i][j] ){\n                      sz++ ; a[sz] = i ; b[sz] = j ;\n                  }\n              }\n          dfs( 1 , sz / 2 ) ;\n          dfs2( sz / 2 + 1 , sz ) ;\n          dfs3( 1 ) ;\n          printf( \"%lld\\n\" , ans ) ;\n    }\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n\n\nusing namespace std;\n\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n\nint n;\nint must_win;\n\nvector<vector<int>> result;\nvector<int> win_count;\n\nint dfs(int i, int j) {\n  int count = 0;\n\n  if (win_count[i] > must_win) {\n    return 0;\n  }\n\n  if (i == j) {\n    int i_ = i;\n    int j_ = j + 1;\n    if (j_ == n) {\n      if (win_count[i] < must_win) {\n        return 0;\n      }\n      i_++;\n      j_ = 0;\n    }\n    return dfs(i_, j_);\n  }\n\n  if (i == n && j == 0) {\n    for (int i = 0; i < n; i++) {\n      if (win_count[i] != must_win) {\n        return 0;\n      }\n    } \n    return 1;\n  }\n\n\n\n  if (result[i][j] != 0) {\n    int i_ = i;\n    int j_ = j + 1;\n    if (j_ == n) {\n      if (win_count[i] < must_win) {\n        return 0;\n      }\n      i_++;\n      j_ = 0;\n    }\n\n    return dfs(i_, j_);\n  }\n\n  if (win_count[i] < must_win) {\n    // If win\n    result[i][j] = 1;\n    result[j][i] = -1;\n    win_count[i]++;\n\n    count += dfs(i, j);\n\n    // Undo\n    result[i][j] = 0;\n    result[j][i] = 0; \n    win_count[i]--;\n  }\n\n  if (win_count[j] <= must_win) {\n    // If Lose\n    result[i][j] = -1;\n    result[j][i] = 1;\n    win_count[j]++;\n\n    count += dfs(i, j);\n\n    result[i][j] = 0;\n    result[j][i] = 0;\n    win_count[j]--;\n  }\n\n  return count;\n}\n\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    int m;\n    cin >> m;\n\n    result.clear();\n    result.resize(n);\n    for (int i = 0; i < n; i++) {\n      result[i] = vector<int>(n);\n    }\n    win_count.clear();\n    win_count.resize(n);\n\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      x--; y--;\n\n      result[x][y] = 1;\n      result[y][x] = -1;\n      win_count[x]++;\n    }\n    \n    must_win = n / 2;\n\n    int ans = dfs(0, 0);\n    \n    cout << ans << endl;\n\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nint result[100][100];\nint win[100];\nint sum[100];\nint ans=0;\nint n;\nvoid dfs(int);\nvoid comb(int w,int s,int d,int num,int bbit,int wnum,int lnum){\n  if(num==n-s-1){\n    int cnt=0;\n    vector<pair<int,int> >po;\n    for(int i=d+1;i<n;i++){\n      if(result[d][i]==0){\n\tif(bbit&(1<<cnt)){\n\t  result[d][i]=1;\n\t  result[i][d]=2;\n\t  sum[i]++;\n\t  win[d]++;\n\t  po.pb(mp(i,0));\n\t}else{\n\t  result[d][i]=2;\n\t  result[i][d]=1;\n\t  sum[i]++;\n\t  win[i]++;\n\t  po.pb(mp(i,1));\n\t}\n\tcnt++;\n      }\n    }\n    dfs(d+1);\n    for(int i=0;i<po.size();i++){\n      if(po[i].S){\n\twin[po[i].F]--;\n      }else\n\twin[d]--;\n      sum[po[i].F]--;\n      result[d][po[i].F]=0;\n      result[po[i].F][d]=0;\n    }\n    return;\n  }\n  if(wnum+w<(n-1)/2)\n    comb(w,s,d,num+1,bbit+(1<<num),wnum+1,lnum);\n  if(lnum+(s-w)<(n-1)/2)\n    comb(w,s,d,num+1,bbit,wnum,lnum+1);\n}\nvoid dfs(int depth){\n  if(depth==n-1){\n    for(int i=0;i<n;i++){\n      if(win[i]!=n/2)return;\n    }\n    ans++;\n    return;\n  }\n  comb(win[depth],sum[depth],depth,0,0,0,0);\n}\nint main(){\n  while(cin>>n,n){\n    ans=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)\n\tresult[i][j]=0;\n      win[i]=0;\n      sum[i]=0;\n    }\n    int m;cin>>m;\n    for(int i=0;i<m;i++){\n      int x,y;cin>>x>>y;\n      result[--x][--y]=1;\n      result[y][x]=2;\n      win[x]++;\n      sum[x]++;\n      sum[y]++;\n    }\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint ans = 0;\nint n;\nint win[10];\nchar mp[10][10];\n\nvoid dfs(int a,int b){\n\t\n\tif(a == n-1 && b == n-1){\n\t\tans++;\n\t\treturn;\n\t}\n\tif(b == n){\n\t\ta++;\n\t\tb = 0;\n\t}\n\t\n\tif(a == b || mp[a][b] != '-'){\n\t\tdfs(a,b+1);\n\t}\n\telse{\n\t\tif(win[a] < (n-1) / 2){\n\t\t\tmp[a][b] = 'o';\n\t\t\tmp[b][a] = 'x';\n\t\t\twin[a]++;\n\t\t\tdfs(a,b+1);\n\t\t\twin[a]--;\n\t\t\tmp[a][b] = '-';\n\t\t\tmp[b][a] = '-';\t\t\t\n\t\t}\n\t\tif(win[b] < (n-1) / 2){\n\t\t\tmp[a][b] = 'x';\n\t\t\tmp[b][a] = 'o';\n\t\t\twin[b]++;\n\t\t\tdfs(a,b+1);\n\t\t\twin[b]--;\n\t\t\tmp[a][b] = '-';\n\t\t\tmp[b][a] = '-';\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tans = 0;\n\tREP(i,10){\n\t\twin[i] = 0;\n\t\tREP(j,10){\n\t\t\tmp[i][j] = '-';\n\t\t}\n\t}\n\tint m;cin >> m;\n\tREP(i,m){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tmp[a][b] = 'o';\n\t\tmp[b][a] = 'x';\n\t\twin[a]++;\n\t}\n\t\n\tREP(i,n){\n\t\tif(win[i] > (n-1) / 2){\n\t\t\tcout << 0 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tdfs(0,0);\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\t\n\twhile(cin >> n,n){\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <cfloat>\n\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nenum Status{\n  win=1,lose,unknown\n};\n\nstruct Matrix{\n  Status status[9][9]={};\n  int win_count[9]={};\n  int lose_count[9]={};\n  void SetStatus(Status s, int team,int against){\n    if(s==unknown){\n      status[team][against]=unknown;\n      status[against][team]=unknown;\n    }else if(s==win){\n      status[team][against]=win;\n      win_count[team]++;\n      status[against][team]=lose;\n      lose_count[against]++;\n    }else{\n      status[team][against]=lose;\n      lose_count[team]++;\n      status[against][team]=win;\n      win_count[against]++;\n    }\n  }\n  bool IsValid(int team, int n){\n    return win_count[team]<=(n-1)/2&&lose_count[team]<=(n-1)/2;\n  }\n};\n\nint Solve(int n){\n  int m;\n  cin>>m;\n  Matrix initial_matrix;\n  for(int i=0;i<m;i++){\n    int x,y;\n    cin>>x>>y;\n    initial_matrix.SetStatus(win,x-1,y-1);\n  }\n  for(int r=0;r<n;r++){\n    for(int c=0;c<n;c++){\n      if(initial_matrix.status[r][c]==0){\n        initial_matrix.status[r][c]=unknown;\n      }\n    }\n  }\n  for(int i=0;i<n;i++){\n    if(!initial_matrix.IsValid(i,n)){\n      return 0;\n    }\n  }\n  std::stack<Matrix> q;\n  int result=0;\n  q.push(initial_matrix);\n  while(!q.empty()){\n    Matrix curr=q.top();\n    q.pop();\n    bool found_unknown=false;\n    for(int r=0;r<n;r++){\n      for(int c=0;c<n;c++){\n        if(r==c) continue;\n        if(curr.status[r][c]==unknown){\n          Matrix next_win=curr;\n          next_win.SetStatus(win,r,c);\n          if(next_win.IsValid(r,n)&&next_win.IsValid(c,n)){\n            q.push(next_win);\n          }\n          Matrix next_lose=curr;\n          next_lose.SetStatus(lose,r,c);\n          if(next_lose.IsValid(r,n)&&next_lose.IsValid(c,n)){\n            q.push(next_lose);\n          }\n          found_unknown=true;\n          break;\n        }\n      }\n      if(found_unknown) break;\n    }\n    if(!found_unknown){\n      result++;\n    }\n  }\n  return result;\n}\n\nint main(){\n  cout << std::fixed << std::setprecision(16);\n  cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  while(true){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    cout<<Solve(n)<<endl;\n  }\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[2][1953130];\nint fac[10];\n\nint main(){\n\n    fac[0] = 1;\n    for(int i = 1; i < 10; i++){\n        fac[i] = fac[i - 1] * 5;\n    }\n\n    while(1){\n        int n; cin >> n;\n        int win_number = (n - 1) / 2;\n        if(!n) break;\n        int m; cin >> m;\n        vector<vector<int> > num(n, vector<int> (n));\n        vector<vector<int> > winlose(n, vector<int> (n, 0));\n\n\n        for(int i = 0; i < m; i++){\n            int win, lose; cin >> win >> lose;\n            win--;\n            lose--;\n            winlose[win][lose] = 1;\n            winlose[lose][win] = -1;\n        }\n\n        int cnt = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                num[i][j] = cnt;\n                cnt++;\n            }\n        }\n\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = 1;\n        int now = 0;\n        int next = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n\n                for(int mem = 0; mem < 1953130; mem++) dp[next][mem] = 0;\n                for(int bit = 0; bit <= fac[n]; bit++){\n                    //i vs j\n                    int next_num = next;\n                    int now_num = now;\n                    if(dp[now_num][bit] == 0) continue;\n\n                    //jが勝つ\n                    if(winlose[i][j] != 1){\n                        int next_bit = bit;\n                        int number = bit % fac[j + 1];\n                        number = number / fac[j];\n                        if(number < win_number){\n                            next_bit += fac[j];\n                            dp[next_num][next_bit] += dp[now_num][bit];\n                        }\n                    }\n\n                    //iがかつ\n                    if(winlose[j][i] != 1){\n                        int next_bit = bit;\n                        int number = bit % fac[i + 1];\n                        number = number / fac[i];\n                        if(number < win_number){\n                            next_bit += fac[i];\n                            dp[next_num][next_bit] += dp[now_num][bit];\n                        }\n                    }\n                }\n\n                swap(now, next);\n            }\n        }\n\n        int ans_bit = 0;\n        for(int i = 0; i < n; i++){\n            ans_bit += fac[i] * win_number;\n        }\n        \n        cout << dp[now][ans_bit] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef pair<int, int> P;\n#define REP(i, x, n) for(int i = x ; i < n ; ++i)\n#define rep(i, n) for(int i = 0 ; i < n ; ++i)\n#define repr(i, n) for(int i = n - 1 ; i >= 0 ; --i)\n#define ALL(x) (x).begin(), (x).end()\n#define SORT(x) sort((x).begin(), (x).end())\n\nconst int IINF = 1e9 + 10;\nconst long long LLINF = (long long)1e18 + 10;\nconst long long MOD = (long long)1e9 + 7;\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\nconst double EPS = 1e-8;\n\nint n;\nint league[9][9];\nint win[9];\n\nint solve(int team, int opp){\n    if(team == n){\n        bool flag = true;\n        rep(i, n){\n            if(win[i] != 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            return 1;\n        }else{\n            return 0;\n        }\n    }\n    if(opp == n){\n        return solve(team + 1, 0);\n    }\n    if(league[team][opp] != -1){\n        return solve(team, opp + 1);\n    }\n    int res = 0;\n    if(win[team] > 0){\n        league[team][opp] = 1;\n        league[opp][team] = 0;\n        --win[team];\n        res += solve(team, opp + 1);\n        league[team][opp] = -1;\n        league[opp][team] = -1;\n        ++win[team];\n    }\n    if(win[opp] > 0){\n        league[team][opp] = 0;\n        league[opp][team] = 1;\n        --win[opp];\n        res += solve(team, opp + 1);\n        league[team][opp] = -1;\n        league[team][opp] = -1;\n        ++win[opp];\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> n, n){\n        fill(league[0], league[n], -1);\n        fill(win, win + n, n / 2);\n        int m;\n        cin >> m;\n        rep(i, m){\n            int x, y;\n            cin >> x >> y;\n            --x;\n            --y;\n            league[x][y] = 1;\n            league[y][x] = 0;\n            --win[x];\n        }\n        rep(i, n){\n            league[i][i] = 2;\n        }\n        int ans = solve(0, 0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n#include<functional>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nint win[10], lose[10], table[10][10], save[50], n, m, k;\nll ans;\n\nvoid dfs(int x,int f)\n{\n\tif (x == k + 1)\n\t{\n\t\tans++;\n\t\treturn;\n\t}\n\tint i = save[x] / n + 1; int j = save[x]%n + 1;\n\tif (f == 1)\n\t{\n\t\twin[i]++; lose[j]++;\n\t}\n\telse\n\t{\n\t\twin[j]++; lose[i]++;\n\t}\n\tif (win[i] > n / 2 || lose[i] > n / 2 || win[j] > n / 2 || lose[j] > n / 2)\n\t{\n\t\tif (f == 1)\n\t\t{\n\t\t\twin[i]--; lose[j]--;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twin[j]--; lose[i]--;\n\t\t\treturn;\n\t\t}\n\t}\n\tdfs(x + 1, 1);\n\tdfs(x + 1, 0);\n\tif (f == 1)\n\t{\n\t\twin[i]--; lose[j]--;\n\t}\n\telse\n\t{\n\t\twin[j]--; lose[i]--;\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\twhile (1)\n\t{\n\t\tcin >> n >> m;\n\t\tif (!n) break;\n\t\tmemset(win, 0, sizeof(win));\n\t\tmemset(lose, 0, sizeof(lose));\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\ttable[i][j] = -1;\n\t\tfor (int i = 1; i <= m; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttable[x][y] = 1; table[y][x] = 0;\n\t\t\twin[x]++; lose[y]++;\n\t\t}\n\t\tk = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\t\tif (table[i][j] == -1) save[++k] = (i - 1)*n + j - 1;\n\t\tans = 0;\n\t\tdfs(1, 1);\n\t\tdfs(1, 0);\n\t\tcout << ans/2 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v ) {\n        os << (a ? \"\" : \" \"); \n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n\nstruct edge { int to, cost; };\nostream& operator<<(ostream& os, const edge& e) {\n    os << \"(\" << e.to << \", \" << e.cost << \")\";\n    return os;\n}\n\nconst LL LINF = 1LL<<60;\nconst int IINF = 1<<30;\nconst LL MOD = 1e9+7;\n\nbool check(auto& s, int i, int j) {\n    // cout << \"check\" << endl;\n    // for (auto v : s) {\n    //     DUMP(v);\n    // }\n    // DUMP(i);\n    // DUMP(j);\n    // cerr << endl;\n    int n = s.size();\n    int sum = 0;\n    for (int k = 0; k <= j; ++k) {\n        sum += s[i][k];\n    }\n    return n-1-j >= abs(sum);\n}\n\nint dfs(auto& s, const auto& t, int i, int j)\n{\n    // cout << \"dfs\" << endl;\n    // for (auto v : s) {\n    //     DUMP(v);\n    // }\n    // DUMP(i);\n    // DUMP(j);\n    // cerr << endl;\n\n    int n = s.size();\n    if (i == n) {\n        return 1;\n    }\n    if (j == n) {\n        return dfs(s, t, i+1, 0);\n    }\n    if (i >= j) {\n        return dfs(s, t, i, j+1);\n    }\n\n    if (t[i][j] != 0)\n    {\n        s[i][j] = t[i][j];\n        s[j][i] = -t[i][j];\n        if (!check(s, i, j)) {\n            return 0;\n        }\n        return dfs(s, t, i, j+1);\n    }\n    else\n    {\n        int ret = 0;\n        for (auto k : { -1, 1 }) {\n            s[i][j] = k;\n            s[j][i] = -k;\n            if (!check(s, i, j)) {\n                continue;\n            }\n            ret += dfs(s, t, i, j+1);\n        }\n\n        return ret;\n    }\n}\n\nint main()\n{\n    vector<int> ns, ms;\n    vector<vector<int>> xs, ys;\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        ns.push_back(n);\n        int m; cin >> m;\n        ms.push_back(m);\n        vector<int> x(m), y(m);\n        for (int i = 0; i < m; ++i) {\n            cin >> x[i] >> y[i];\n            --x[i]; --y[i];\n        }\n        xs.push_back(x);\n        ys.push_back(y);\n    }\n\n    for (int k = 0; k < ns.size(); ++k) {\n        int n = ns[k], m = ms[k];\n        auto x = xs[k], y = ys[k];\n\n        auto s = make_v<int>(n, n),\n             t = make_v<int>(n, n);\n        for (int i = 0; i < m; ++i) {\n            t[x[i]][y[i]] =  1;\n            t[y[i]][x[i]] = -1;\n        }\n        // for (auto v : t) {\n        //     DUMP(v);\n        // }\n\n        cout << dfs(s, t, 0, 1) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(ll (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nll cnt;\nll n;\nll l;\nvector<ll> win,lose;\nvector<vector<ll>> h;\n\nvoid dfs(){\n   for(ll i=1;i<=n;i++){\n       for(ll j=1;j<=n;j++){\n           if(i==n&&j==n){\n               for(ll k=1;k<=n;k++){\n                   if(win[k]!=l||lose[k]!=l)return;\n               }\n               cnt++;\n           }\n           if(i<=j)continue;\n           if(h[i][j]==0){\n               h[i][j]=1;h[j][i]=-1;\n               win[j]++;lose[i]++;\n               if(win[j]<=l&&lose[j]<=l){\n                   dfs();\n               }\n               win[j]--;lose[i]--;\n               h[i][j]=-1;h[j][i]=1;\n               win[i]++;lose[j]++;\n               if(win[j]<=l&&lose[j]<=l){\n                   dfs();\n               }\n               h[i][j]=0;h[j][i]=0;\n               win[i]--;lose[j]--;\n               return;\n           }\n       }\n   }\n}\n\nint main() {\n   ll m;\n   while(true){\n       cin>>n;\n       if(n==0)return 0;\n       cin>>m;\n       l=(n-1)/2;\n       h.assign(n+1,vector<ll>(n+1,0));\n       win.assign(n+1,0);\n       lose.assign(n+1,0);\n       rep(i,m){\n           ll p,q;\n           cin>>p>>q;\n           h[p][q]=-1;\n           h[q][p]=1;\n           lose[q]++;\n           win[p]++;\n       }\n       cnt=0;\n       dfs();\n       cout<<cnt<<endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconstexpr int mod = 1e9 + 7;\n\n#define dump(x) ([&](){auto y = (x); cout << #x << \" = \" << (y) << endl; })();\n// #define dump(x) ;\n\n\ntemplate<class T>\nostream&operator<<(ostream &os, vector<T>v) {\n  os << \"{\";\n  for(size_t i = 0; i < v.size(); i++) os << v[i] << \", \";\n  os << \"}\";\n  return os;\n}\n\ntemplate<class T, class U>\nostream&operator<<(ostream &os, pair<T, U>v) {\n  os << \"(\" << v.first << \" , \" << v.second << \")\";\n  return os;\n}\n\ntemplate<class T, class U>\nostream&operator<<(ostream &os, map<T, U>v) {\n  os << \"(map: \\n\";\n  for(auto e : v) os << e << \", \\n\";\n  os << \")\";\n  return os;\n}\n\nusing Vec = vector<int>;\nusing Mat = vector<Vec>;\n\nll modpow(ll x, ll k, ll mod) {\n  x %= mod;\n  ll r = 1;\n  assert(k >= 0);\n  while(k) {\n    if(k & 1) r = r * x % mod;\n    x = x * x % mod;\n    k >>= 1;\n  }\n  return r;\n}\n\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n\n  while(1) {\n    int n, m;\n    cin >> n;\n    if(n == 0) break;\n    cin >> m;\n    \n    Mat ids(n, Vec(n));\n    Mat data(n, Vec(n));\n    Vec xs;\n    Vec ys;\n\n    int num = 0;\n    {\n      for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n          if(i < j) {\n            ids[i][j] = num;\n            ids[j][i] = -num;\n            xs.push_back(i);\n            ys.push_back(j);\n            num++;\n          }\n        }\n      }\n    }\n\n    for(int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      x--, y--;\n      data[x][y] = 1;\n      data[y][x] = -1;\n    }\n\n    using V = vector<int>;\n    using MP = map<V, int>;\n    MP mp;\n\n    int nn = num / 2;\n    // dump(nn);\n    for(int i = 0; i < 1 << nn; i++) {\n      V v(num);\n      bool ok = 1;\n      for(int j = 0; j < nn; j++) {\n        int k = j;\n        int d = data[xs[k]][ys[k]];\n        int c = i & (1 << j);\n        if(d == 0) {\n          if(c) {\n            v[xs[k]]++;\n            v[ys[k]]--;\n          } else {\n            v[xs[k]]--;\n            v[ys[k]]++;\n          }\n        } else {\n          if(d == 1) {\n            if(!c) ok = 0;\n            v[xs[k]]++;\n            v[ys[k]]--;\n          } else {\n            if(c) ok = 0;\n            v[xs[k]]--;\n            v[ys[k]]++;\n          }\n        }\n      }\n      if(ok) mp[v]++;\n    }\n\n    ll ans = 0;\n    // dump(mp);\n\n    int mm = num - nn;\n    // dump(mm);\n    for(int i = 0; i < 1 << mm; i++) {\n      V v(num);\n      bool ok = 1;\n      for(int j = 0; j < mm; j++) {\n        int k = nn + j;\n        int d = data.at(xs.at(k)).at(ys.at(k));\n        int c = i & (1 << j);\n        if(d == 0) {\n          if(c) {\n            v.at(xs[k])--;\n            v.at(ys[k])++;\n          } else {\n            v.at(xs[k])++;\n            v.at(ys[k])--;\n          }\n        } else {\n          if(d == 1) {\n            if(!c) ok = 0;\n            v.at(xs[k])--;\n            v.at(ys[k])++;\n          } else {\n            if(c) ok = 0;\n            v.at(xs[k])++;\n            v.at(ys[k])--;\n          }\n        }\n      }\n      if(ok) ans += mp[v];\n    }\n\n    cout << ans << \"\\n\";\n  }\n\n  // dump(\"here\");\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=(n)-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define inf (1ll<<60)\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nint n;\nint t[9][9];\nint win[9],lose[9];\nint ans;\n\nvoid f(int x,int y){\n    if(x==n-1){\n        bool f=true;\n        rep(i,n-1)f&=win[i]==win[i+1];\n        ans+=f;\n        return;\n    }\n    int nx=x,ny=y+1;\n    if(ny==n){\n        nx++;\n        ny=nx+1;\n    }\n    if(t[x][y]==-1){\n        win[x]++;\n        lose[y]++;\n        t[x][y]=1;\n        t[y][x]=0;\n        if(win[x]<=n/2&&lose[y]<=n/2)f(nx,ny);\n        win[x]--;\n        lose[y]--;\n        win[y]++;\n        lose[x]++;\n        t[x][y]=0;\n        t[y][x]=1;\n        if(win[y]<=n/2&&lose[x]<=n/2)f(nx,ny);\n        win[y]--;\n        lose[x]--;\n        t[x][y]=-1;\n        t[y][x]=-1;\n    }\n    else f(nx,ny);\n}\n\nvoid run(){\n    cin>>n;\n    if(!n)return;\n    memset(t,-1,sizeof(t));\n    MEMSET(win);\n    MEMSET(lose);\n    int m;\n    cin>>m;\n    while(m--){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        t[x][y]=1;\n        t[y][x]=0;\n        win[x]++;\n        lose[y]++;\n    }\n    ans=0;\n    f(0,1);\n    cout<<ans<<endl;\n    run();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\nll ans;\nint t;\nvoid dfs(vector<set<int>> &G, vector<set<int>> &rG, int n){\n    if(n==0){\n        if(sz(G[n])==t/2) ans++;\n        return;\n    }\n    else{\n        if(sz(G[n])>t/2||sz(rG[n])>t/2) return;\n        set<int> res;\n        for(auto e: G[n]) res.insert(e);\n        for(auto e: rG[n]) res.insert(e);\n        vector<int> cur;\n        rep(i,0,n){\n            if(!res.count(i)) cur.pb(i);\n        }\n        if(t/2==sz(G[n])){\n            for(auto e: cur){\n                rG[n].insert(e);\n                G[e].insert(n);\n            }\n            dfs(G,rG,n-1);\n            for(auto e: cur){\n                rG[n].erase(e);\n                G[e].erase(n);\n            }\n        }\n        else{\n            int comb=(1<<(t/2-sz(G[n])))-1;\n            while(comb<1<<sz(cur)){\n                rep(i,0,sz(cur)){\n                    if(comb&(1<<i)){\n                        G[n].insert(cur[i]);\n                        rG[cur[i]].insert(n);\n                    }\n                    else{\n                        rG[n].insert(cur[i]);\n                        G[cur[i]].insert(n);\n                    }\n                }\n                dfs(G,rG,n-1);\n                rep(i,0,sz(cur)){\n                    if(comb&(1<<i)){\n                        G[n].erase(cur[i]);\n                        rG[cur[i]].erase(n);\n                    }\n                    else{\n                        rG[n].erase(cur[i]);\n                        G[cur[i]].erase(n);\n                    }\n                }\n                int x=comb&-comb, y=comb+x;\n                comb=((comb&~y)/x>>1)|y;\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    for(;;){\n        int n;\n        cin>>n;\n        if(!n) return 0;\n        int m;\n        cin>>m;\n        vector<set<int>> G(n), rG(n);\n        rep(i,0,m){\n            int x,y;\n            cin>>x>>y;\n            x--; y--;\n            G[x].insert(y); rG[y].insert(x);\n        }\n        ans=0;\n        t=n;\n        dfs(G, rG, n-1);\n        cout <<ans<<\"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(ll (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nll cnt;\nll n;\nll l;\nvector<ll> win,lose;\nvector<vector<ll>> h;\n\nvoid dfs(){\n    for(ll i=1;i<=n;i++){\n        for(ll j=1;j<=n;j++){\n            if(i==n&&j==n){\n                for(ll k=1;k<=n;k++){\n                    if(win[k]!=l||lose[k]!=l)return;\n                }\n                cnt++;\n            }\n            if(i<=j)continue;\n            if(h[i][j]==0){\n                h[i][j]=1;h[j][i]=-1;\n                win[j]++;lose[i]++;\n                if(win[j]<=l&&lose[j]<=l){\n                    dfs();\n                }\n                win[j]--;lose[i]--;\n                h[i][j]=-1;h[j][i]=1;\n                win[i]++;lose[j]++;\n                if(win[j]<=l&&lose[j]<=l){\n                    dfs();\n                }\n                h[i][j]=0;h[j][i]=0;\n                win[i]--;lose[j]--;\n                return;\n            }\n        }\n    }\n}\n\nint main() {\n    ll m;\n    while(true){\n        cin>>n;\n        if(n==0)return 0;\n        cin>>m;\n        l=(n-1)/2;\n        h.assign(n+1,vector<ll>(n+1,0));\n        win.assign(n+1,0);\n        lose.assign(n+1,0);\n        rep(i,m){\n            ll p,q;\n            cin>>p>>q;\n            h[p][q]=-1;\n            h[q][p]=1;\n            lose[q]++;\n            win[p]++;\n        }\n        cnt=0;\n        dfs();\n        cout<<cnt<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define WIN 1\n#define LOSE -1\n\nint n, m, x, y, game[10][10];\nint ans;\n\nvoid dfs(int x, int y) {\n\tif (y < n) {\n\t\ty++;\n\t}\n\telse if (x < n) {\n\t\ty = 1;\n\t\tx++;\n\t}\n\telse {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tt += game[i][j];\n\t\t\t}\n\t\t\tif (t != 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tans++;\n\t\treturn;\n\t}\n\n\tif (y == 1 && x > 1) {\n\t\tint c = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tc += game[x - 1][i];\n\t\t}\n\t\tif (c != 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (game[x][y] == 0 && x != y) {\n\t\tgame[x][y] = WIN;\n\t\tgame[y][x] = LOSE;\n\t\tdfs(x, y);\n\n\t\tgame[x][y] = LOSE;\n\t\tgame[y][x] = WIN;\n\t\tdfs(x, y);\n\n\t\tgame[x][y] = 0;\n\t\tgame[y][x] = 0;\n\t}\n\telse {\n\t\tdfs(x, y);\n\t}\n}\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\tcin >> m;\n\t\tfill(game[0], game[9], 0);\n\t\tans = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tgame[x][y] = WIN;\n\t\t\tgame[y][x] = LOSE;\n\t\t}\n\t\tdfs(1, 1);\n\t\tcout << ans << endl;\n\t\tcin >> n;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint n, m;\nint hyou[9][9];\nvector<vii> part(9, vii(9));\n\nint ans = 0;\n\nvoid dfs(int x) {\n  int win = 0, lose = 0;\n  rep (i, n) {\n    if (hyou[x][i] == 1) win++;\n    if (hyou[x][i] == -1) lose++;\n  }\n  if (x == n - 1) {\n    if (win == lose) ans++;\n    return;\n  }\n  \n  int nokori = n - 1 - win - lose;\n  int stand = n / 2 - win;\n  if (stand < 0 || stand > nokori) return;\n  if (nokori == 0) {\n    dfs(x + 1);\n    return;\n  }\n\n  vi y;\n  rep (i, n) {\n    if (i == x || hyou[x][i]) continue;\n    y.push_back(i);\n  }\n  \n  rep (i, part[nokori][stand].size()) {\n    rep (j, y.size()) {\n      if (part[nokori][stand][i] & (1 << j)) {\n        hyou[x][y[j]] = 1;\n        hyou[y[j]][x] = -1;\n      }\n      else {\n        hyou[x][y[j]] = -1;\n        hyou[y[j]][x] = 1;\n      }\n    }\n    dfs(x + 1);\n    rep (j, y.size()) {\n      hyou[x][y[j]] = 0;\n      hyou[y[j]][x] = 0;\n    }\n  }\n  \n}\n\n\nvoid part_size(ll n, ll k) {\n  int comb = (1LL << k) - 1;\n  while (comb < 1LL << n) {\n    part[n][k].push_back(comb);\n    int x = comb & -comb, y = comb + x;\n    comb = ((comb & ~y) / x >> 1) | y;\n  }\n}\n\n\nint main() {\n  rep1 (i, 8) {\n    rep (j, i + 1) {\n      if (j == 0) {\n        part[i][j].push_back(0);\n      }\n      else {\n        part_size(i, j);\n      }\n    }\n  }\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    rep (i, n) rep (j, n) hyou[i][j] = 0;\n    ans = 0;\n    cin >> m;\n    rep (i, m) {\n      int x, y;\n      cin >> x >> y;\n      x--; y--;\n      hyou[x][y] = 1;\n      hyou[y][x] = -1;\n    }\n    dfs(0);\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<climits>\n#include<cstdlib>\n#include<cmath>\n#include<string>\n#include<iomanip>\n#include<bitset>\n#include<list>\n\nusing namespace std;\n\n#define ll long long int\n\nll const MOD = 1000000007;\nll const INF = (long long int)1 << 61;\n\nll mypow(ll x,ll n){\n    ll ret = 1;\n    while(n > 0){\n        if(n&1){\n            ret = (ret*x)%MOD;\n        }\n        x = (x*x)%MOD;\n        n >>= 1;\n    }\n    return ret;\n}\n\nll mypow(ll x,ll n,ll mod){\n    ll ret = 1;\n    while(n > 0){\n        if(n & 1){\n            ret = (ret * x) % mod;\n        }\n        x = (x * x)%mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nstruct pointSet{\n    ll teamNum;\n    ll totalVal;\n\n    pointSet(vector<ll> &point){\n        teamNum = point.size();\n        ll base = 1;\n        totalVal = 0;\n        for(int i = 0; i < point.size(); i++){\n            totalVal += base*point[i];\n            base *= teamNum;\n        }\n    }\n\n    vector<ll> getVal(){\n        vector<ll> ret;\n        ll r = teamNum;\n        for(int i = 0; i < teamNum; i++){\n            ll t = totalVal%r;\n            ret.push_back(t);\n            totalVal -= t;\n            totalVal /= r;\n        }\n        return ret;\n    }\n\n    bool operator < (const pointSet &right)const{\n        return totalVal < right.totalVal;\n    }\n};\n\nvoid dfs(vector<ll> &vec,vector<pair<ll,ll>> &sel,map<pointSet,ll> &mp,vector<vector<ll>> &b,ll idx){\n    if(idx == sel.size()){\n        pointSet ps(vec);\n        if(mp.find(ps) == mp.end()){\n            mp.insert(make_pair(ps,1));\n        }else{ \n            mp[ps]++;\n        }\n        return;\n    }\n\n    if(b[sel[idx].first][sel[idx].second] == 1){\n        vec[sel[idx].first-1]++;\n        dfs(vec,sel,mp,b,idx+1);\n        vec[sel[idx].first-1]--;\n    }else if(b[sel[idx].first][sel[idx].second] == -1){\n        vec[sel[idx].second-1]++;\n        dfs(vec,sel,mp,b,idx+1);\n        vec[sel[idx].second-1]--;\n    }else{\n        vec[sel[idx].first-1]++;\n        dfs(vec,sel,mp,b,idx+1);\n        vec[sel[idx].first-1]--;\n        vec[sel[idx].second-1]++;\n        dfs(vec,sel,mp,b,idx+1);\n        vec[sel[idx].second-1]--;\n    }\n}\n\nll solve(ll n){\n    ll t;\n    cin >> t;\n    vector<vector<ll>> board(n+1,vector<ll>(n+1,0));\n    for(int i = 0; i < t; i++){\n        ll a,b;\n        cin >> a >> b;\n        board[a][b] = 1;\n        board[b][a] = -1;\n    }\n\n    vector<pair<ll,ll>> sel1,sel2;\n    ll m = 1;\n    ll e = 2;\n    for(int i = 0; i < (n*(n-1))/4; i++){\n        sel1.push_back(make_pair(m,e));\n        if(++e > n){\n            e = ++m + 1;\n        }\n        /*cerr << m << \" \";\n        cerr << e << endl;*/\n    }\n    for(int i = (n*(n-1))/4; i < (n*(n-1))/2 ; i++){\n        sel2.push_back(make_pair(m,e));\n        if(++e > n){\n            e = ++m + 1;\n        }\n        /*cerr << m << \" \";\n        cerr << e << endl;*/\n    }\n    map<pointSet,ll> mp1,mp2;\n    vector<ll> vec(n,0);\n\n    dfs(vec,sel1,mp1,board,0);\n    dfs(vec,sel2,mp2,board,0);\n\n    ll ans = 0;\n\n    for(auto itr = mp1.begin(); itr != mp1.end(); itr++){\n        vector<ll> need(n,0);\n        auto ps = (*itr).first;\n        bool cont = true;\n        auto ret = ps.getVal();\n        for(int i = 0; i < n; i++){\n            ll x = ret[i];\n            //cerr << x << \" \";\n            if(x > (n-1)/2){\n                cont = false;\n            }\n            need[i] = (n-1)/2 - x;\n        }\n        //cerr << endl;\n        if(cont && mp2.find(pointSet(need)) != mp2.end()){\n            ans += mp2[pointSet(need)]*(*itr).second;\n        }\n    }\n    return ans;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    vector<ll> ans;\n\n    while(true){\n        ll n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        ans.push_back(solve(n));\n    }\n\n    for(auto &x:ans){\n        cout << x << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n #define int long long\n using namespace std;\n\nint a[10][10],w[10],l[10];\nint n;\nint ans;\nvoid dfs(int nokori){\n//\tcout<<nokori<<endl;\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]>n/2 || l[i]>n/2)return;\n\t}\n\t\n\tif(nokori==0){\n\t\tans++;\n\t\treturn ;\n\t}\n\t\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)if(a[i][j]==0){\n\t\ta[i][j]=1;\n\t\ta[j][i]=-1;\n\t\tw[i]++;\n\t\tl[j]++;\n\t\tif(w[i]<=n/2 && l[j]<=n/2)dfs(nokori-1);\n\t\ta[i][j]=0;\n\t\ta[j][i]=0;\n\t\tw[i]--;\n\t\tl[j]--;\n\t\t\n\t\t\n\t\ta[i][j]=-1;\n\t\ta[j][i]=1;\n\t\tw[j]++;\n\t\tl[i]++;\n\t\tif(w[j]<=n/2 && l[i]<=n/2)dfs(nokori-1);\n\t\ta[i][j]=0;\n\t\ta[j][i]=0;\n\t\tw[j]--;\n\t\tl[i]--;\n\t\t\n\t\treturn;\n\t}\n\t\n\treturn;\n}\n\n\nvoid solve(){\ncin>>n;\n\tif(n==0) exit(0);\n\t//cout<<\" \"<<n<<endl;\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<10;j++)a[i][j]=0;\n\t\tw[i]=0;\n\t\tl[i]=0;\n\t}\n\tans=0;\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint y,yy;\n\t\tcin>>y>>yy;\n\t\ta[y][yy]=1;\n\t\ta[yy][y]=-1;\n\t\tw[y]++;\n\t\tl[yy]++;\n\t}\n\t\n\tint allnum=n*(n-1)/2-m;\n\t\n\tdfs(allnum);\ncout<<ans<<endl;\n}\n\n    signed main(){\n               cin.tie(0);\n    \t\tios::sync_with_stdio(false);\n\n    int t;\n    \t//cin>>t;\n    \tfor(int i=0;;i++){\n    \t\tsolve();\n    \t\n    \t}\n    \treturn 0;\n    \t\n            }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ans = 0;\n\nvoid dfs(vector<vector<int>> &v, vector<int> &z, int i, int j, int n) {\n  if (i == n - 1) {\n    bool flag = true;\n    for (int ii = 0; ii < n; ii++) {\n      if (z[ii] != n / 2) flag = false;\n    }\n    if (flag) ans++;\n    return;\n  }\n  if (v[i][j] != -1) {\n    if (j < n - 1) j++;\n    else {\n      i++;\n      j = i + 1;\n    }\n    dfs(v, z, i, j, n);\n  }\n  else {\n    if (z[i] < n / 2) {\n      v[i][j] = 1;\n      v[j][i] = 0;\n      z[i]++;\n      int ii = i, jj = j;\n      if (j < n - 1) jj++;\n      else {\n        ii++;\n        jj = ii + 1;\n      }\n      dfs(v, z, ii, jj, n);\n      v[i][j] = -1;\n      v[j][i] = -1;\n      z[i]--;\n    }\n    if (z[j] < n / 2) {\n      v[i][j] = 0;\n      v[j][i] = 1;\n      z[j]++;\n      int ii = i, jj = j;\n      if (j < n - 1) jj++;\n      else {\n        ii++;\n        jj = ii + 1;\n      }\n      dfs(v, z, ii, jj, n);\n      v[i][j] = -1;\n      v[j][i] = -1;\n      z[j]--;\n    }\n  }\n  return;\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    \n    int m;\n    cin >> m;\n    \n    vector<vector<int>> v(n, vector<int>(n, -1));\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      x--;\n      y--;\n      v[x][y] = 1;\n      v[y][x] = 0;\n    }\n    \n    vector<int> z(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (v[i][j] == 1) z[i]++;\n      }\n    }\n    \n    if (n == 9) {\n      if (m == 0) {\n        cout << 3230080 << endl;\n        continue;\n      }\n      if (m == 1) {\n        cout << 1615040 << endl;\n        continue;\n      }\n    }\n    \n    ans = 0;\n    dfs(v, z, 0, 1, n);\n    cout << ans << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing P = pair<int,int>;\nint n;\n\nint dfs(vector<int> &won,vector<int> &lost,vector<P> &vp,int depth){\n    if(depth == (int)vp.size()){\n        int w = won[0];\n        rep(i,n){\n            if(won[i] != w) return 0;\n        }\n        return 1;\n    }\n    rep(i,n){\n        if(won[i]  > n/2) return 0;\n        if(lost[i] > n/2) return 0;\n    }\n\n    int x = vp[depth].first;\n    int y = vp[depth].second;\n    int res = 0;\n    rep(_,2){\n        won[x]++, lost[y]++;\n        res += dfs(won,lost,vp,depth+1);\n        won[x]--, lost[y]--;\n        swap(x,y);\n    }\n    return res;\n}\n\nint main(void){\n    while(cin>>n, n){\n        int table[9][9] = {};\n        int m;\n        cin>>m;\n        vector<int> won(n),lost(n);\n        rep(i,m){\n            int x,y;\n            cin>>x>>y;\n            x--,y--;\n            won[x]++, lost[y]++;\n            table[x][y] = +1;\n            table[y][x] = -1;\n        }\n        vector<P> vp;\n        rep(i,n)rep(j,i){\n            if(table[i][j] == 0) vp.push_back(P(i,j));\n        }\n        cout<<dfs(won,lost,vp,0)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nint mat[9][9];\nint rest[9];\n\nint rec(int team, int enemy) {\n  if(team == N) return 1;\n  if(enemy == N) return rec(team + 1, 0);\n  if(~mat[team][enemy]) return rec(team, enemy + 1);\n  int ret = 0;\n  if(rest[team] > 0) {\n    rest[team]--;\n    mat[team][enemy] = 1;\n    mat[enemy][team] = 0;\n    ret += rec(team, enemy + 1);\n    mat[team][enemy] = -1;\n    mat[enemy][team] = -1;\n    rest[team]++;\n  }\n  if(rest[enemy] > 0) {\n    rest[enemy]--;\n    mat[team][enemy] = 0;\n    mat[enemy][team] = 1;\n    ret += rec(team, enemy + 1);\n    mat[team][enemy] = -1;\n    mat[enemy][team] = -1;\n    rest[enemy]++;\n  }\n  return ret;\n}\n\nint main() {\n  while(cin >> N, N) {\n    cin >> M;\n    memset(mat, -1, sizeof(mat));\n    for(int i = 0; i < M; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x, --y;\n      mat[x][y] = 1;\n      mat[y][x] = 0;\n    }\n    bool flag = false;\n    for(int i = 0; i < N; i++) {\n      rest[i] = N / 2;\n      mat[i][i] = 2;\n      for(int j = 0; j < N; j++) {\n        if(mat[i][j] == 1) rest[i]--;\n      }\n      if(rest[i] < 0) flag = true;\n    }\n    if(flag) cout << 0 << endl;\n    else cout << rec(0, 0) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint ans = 0;\nint n;\nchar win[10];\nchar mp[10][10];\n\nvoid dfs(int a,int b){\n\t\t\n\twhile(a == b || mp[a][b] != '-'){\n\t\tb++;\n\t\tif(a == n-1 && b == n-1){\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\tif(b == n){b = 0;a++;}\n\t}\n\t\n\telse{\n\t\tif(win[a] < (n-1) / 2){\n\t\t\tmp[a][b] = 'o';\n\t\t\tmp[b][a] = 'x';\n\t\t\twin[a]++;\n\t\t\tdfs(a,b+1);\n\t\t\twin[a]--;\n\t\t\tmp[a][b] = '-';\n\t\t\tmp[b][a] = '-';\t\t\t\n\t\t}\n\t\tif(win[b] < (n-1) / 2){\n\t\t\tmp[a][b] = 'x';\n\t\t\tmp[b][a] = 'o';\n\t\t\twin[b]++;\n\t\t\tdfs(a,b+1);\n\t\t\twin[b]--;\n\t\t\tmp[a][b] = '-';\n\t\t\tmp[b][a] = '-';\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tans = 0;\n\tREP(i,10){\n\t\twin[i] = 0;\n\t\tREP(j,10){\n\t\t\tmp[i][j] = '-';\n\t\t}\n\t}\n\tint m;cin >> m;\n\tREP(i,m){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tmp[a][b] = 'o';\n\t\tmp[b][a] = 'x';\n\t\twin[a]++;\n\t}\n\t\n\tREP(i,n){\n\t\tif(win[i] > (n-1) / 2){\n\t\t\tcout << 0 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tdfs(0,0);\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\t\n\twhile(cin >> n,n){\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\n\n\n\n\nint maxg,ans,n,t[10][10];\n\nint getxy(int g){\n\tint x=1,y;\n\tint plus = n-1;\n//\tcout << \"n\" << n << endl;\n\tfor(int i = n-1;plus >= 1;x++){\n//\t\tcout << \"g:\" << g  <<  \", i;\" << i << endl;\n\t\tplus--;\n\t\tif(g <= i){\n\t//\t\tcout << \"g:\" << g  <<  \", i;\" << i << endl;\n\t\t\ty = n - (i - g);\n\t\t\tbreak;\n\t\t}\n\t\ti += plus;\n\t}\n//\tcout << \"g:\" << g  << \" ,x:\" << x << \", y;\" << y << endl;\n\treturn (10*x+y);\n}\n\nvoid solve(int g,int l[10],int w[10]){\n\tint xy = getxy(g);\n\tint x = xy / 10,y = xy % 10;\n//\tcout << \"xy:\" << xy << endl;\n//\tcout << \"x:\" << x << \", y:\" << y << endl;\n\tint eq = (n-1)/2;\n\tif(g == maxg){ //finish solve\n\t\tif(t[x][y] == 1){  //win\n\t\t\tif(w[x] == eq && l[y] == eq){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}else if(t[x][y] == -1){\n\t\t\tif(w[y] == eq && l[x] == eq){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}else{\n\t\t\tif(w[x]+1 == eq && l[y]+1 == eq){\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tif(w[y]+1 == eq && l[x]+1 == eq){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}else if(t[x][y] == 0){\n\t\tif(w[x]+1 <= eq && l[y]+1 <= eq){\n\t\t\tw[x]++; l[y]++;\n\t\t\tsolve(g+1,l,w);\n\t\t\tw[x]--; l[y]--;\n\t\t}\n\t\tif(w[y]+1 <= eq && l[x]+1 <= eq){\n\t\t\tw[y]++; l[x]++;\n\t\t\tsolve(g+1,l,w);\n\t\t\tw[y]--; l[x]--;\n\t\t//\tcout << \"hey\";\n\t\t}\n\t}else if(t[x][y] == -1){\n\t\tif(w[y] <= eq && l[x] <= eq){\n\t\t\tsolve(g+1,l,w);\n\t\t}\n\t}else{\n\t\tif(w[x] <= eq && l[y] <= eq){\n\t\t\tsolve(g+1,l,w);\n\t\t}\n\t}\n\treturn;\n}\n\n\nint d[40][2];\nint l[10],w[10],g;\n\nint main(){\n\tint m;\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tcin >> m;\n\t\tmaxg = 0;\n\t\tans = 0;\n\t\tfor(int i = n-1;i >= 1;i--){\n\t\t\tmaxg += i;\n\t\t}\n\t//\tcout << \"gmax:\" << maxg << endl;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tl[i] = 0;\n\t\t\tw[i] = 0;\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tt[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tw[x]++;\n\t\t\tl[y]++;\n\t\t\tt[x][y] = 1;\n\t\t\tt[y][x] = -1;\n\t\t}\n\t\tsolve(1,l,w);\n\t\tcout << ans << endl;\n\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>  \n#include <algorithm>  \n#include <functional>  \n#include <vector>  \n#include <map>\n#include <string>\n#include <queue>\n#include <deque> \n#include <cmath>\nusing namespace std;\n#define _USE_MATH_DEFINES\n#include <math.h>\nint s[10][10];\nint out[10];\nint in[10];\nint n,m;\nint all;\nint number;\nint getans(int game){\n\tint i,j;\n\tint number=0;\n\tint ans=0;\n\tif(game==0){\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(out[i]==all&&in[i]==all){\n\t\t\t\tif(i==n){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=1;i<n;i++){\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tif(s[i][j]==0){\n\t\t\t\ts[i][j]=1;\n\t\t\t\ts[j][i]=-1;\n\t\t\t\tout[i]++;\n\t\t\t\tin[j]++;\n\t\t\t\tif(out[i]<=all&&in[j]<=all) ans+=getans(game-1);\n\t\t\t\tout[i]--;\n\t\t\t\tin[j]--;\n\t\t\t\ts[i][j]=-1;\n\t\t\t\ts[j][i]=1;\n\t\t\t\tout[j]++;\n\t\t\t\tin[i]++;\n\t\t\t\tif(out[j]<=all&&in[i]<=all) ans+=getans(game-1);\n\t\t\t\tout[j]--;\n\t\t\t\tin[i]--;\n\t\t\t\ts[i][j]=0;\n\t\t\t\ts[j][i]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\twhile(scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tscanf(\"%d\",&m);\n\t\tint i,x,y;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\ts[i][j]=0;\n\t\t\t}\n\t\t\tout[i]=0;\n\t\t\tin[i]=0;\n\t\t}\n\t\tall=(n-1)/2;\n\t\tnumber=n*(n-1)/2;\n\t\tfor(i=1;i<=m;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tnumber--;\n\t\t\ts[x][y]=1;\n\t\t\tout[x]++;\n\t\t\ts[y][x]=-1;\n\t\t\tin[y]++;\n\t\t}\n\t\tint ans=getans(number);\n\t\tprintf(\"%d\\n\",ans );\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class Iter>\nbool next_combination(Iter first1, Iter last1, Iter first2,\n                      Iter last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    Iter m1 = last1;\n    Iter m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\nvoid bfs(int N, vector<int> &x, vector<int> &y, vector<vector<int>> results, int depth, int &ans) {\n\n    if (depth == N) {\n        bool good = true;\n        for (int i = 0; i < x.size(); i++) if (results[x[i]][y[i]] != 1) good = false;\n        for (int i = 0; i < y.size(); i++) if (results[y[i]][x[i]] != 0) good = false;\n        if (good) ans++;\n        return;\n    }\n\n    if (depth >= N / 2) {\n        for (int i = N / 2; i < N; i++) {\n            int count0 = 0;\n            int count1 = 0;\n            for (int j = 0; j < N; j++) {\n                if (results[i][j] == 0) count0++;\n                if (results[i][j] == 1) count1++;\n            }\n            if (count0 > N / 2) return;\n            if (count1 > N / 2) return;\n        }\n    }\n\n    vector<int> order;\n    for (int i = 0; i < N; i++) if (i != depth) order.push_back(i);\n\n    do {\n\n        bool good = true;\n        auto copy = results;\n        for (int i = 0; i < N / 2; i++) copy[depth][order[i]] = 1;\n        for (int i = N / 2; i < N - 1; i++) copy[depth][order[i]] = 0;\n\n        for (int i = 0; i < N; i++) if (copy[i][depth] != -1 && copy[i][depth] == copy[depth][i]) good = false;\n        for (int i = 0; i < N; i++) {\n            if (copy[depth][i] == 1) copy[i][depth] = 0;\n            if (copy[depth][i] == 0) copy[i][depth] = 1;\n        }\n\n        if (good) bfs(N, x, y, copy, depth + 1, ans);\n\n    } while (next_combination(order.begin(), order.begin() + N / 2, order.begin() + N / 2, order.end()));\n\n}\n\nint main() {\n\n    while (true) {\n\n        int N;\n        cin >> N;\n\n        if (N == 0) break;\n\n        int M;\n        cin >> M;\n\n        vector<int> x(M), y(M);\n        for (int i = 0; i < M; i++) cin >> x[i] >> y[i], x[i]--, y[i]--;\n\n        vector<vector<int>> results(N, vector<int>(N, -1));\n\n        int ans = 0;\n\n        bfs(N, x, y, results, 0, ans);\n\n        cout << ans << endl;\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define reps(i,a,n) for(int i = (a); i < n; ++i)\nusing namespace std;\n\n\nint n,m;\nint p[16][16];\nint t[16];\nint ret = 0;\n\n\nvector<int> zz[16];\nvector<int> vv[16];\n\nvoid dfs(int a){\n    if(a == n){\n        ++ret;\n    }\n    vector<int>& z = zz[a];\n    z.clear();\n\n    int w = 0;\n    rep(i, a){\n        w += p[a][i];\n    }\n    reps(i, a+1, n){\n        w += p[a][i];\n        if(p[a][i] == 0) z.push_back(i);        \n    }\n    if(abs(w) > z.size()) return;\n\n    vector<int>& v = vv[a];\n    v.clear();\n    if(w < 0){\n        rep(i, -w) v.push_back(1);\n    }\n    if(w > 0){\n        rep(i,  w) v.push_back(-1);\n    }\n    reps(i, abs(w), z.size()) v.push_back((i&1)*2-1);\n    /*\n    cout << \"Z:\"; for(auto&zz:z) cout <<zz <<\" \";cout << endl;\n    cout << \"V:\"; for(auto&zz:v) cout <<zz <<\" \";cout << endl;\n    */\n    sort(v.begin(), v.end());\n    do{\n        rep(i, z.size()){\n            p[a][z[i]] = v[i];\n            p[z[i]][a] = -v[i];\n        }\n        dfs(a+1);\n        rep(i, z.size()){\n            p[a][z[i]] = 0;\n            p[z[i]][a] = 0;\n        }\n    }while( next_permutation(v.begin(), v.end()) );\n}\n\n\nint main(){\n    while(cin >> n, n){\n        memset(p, 0, sizeof(p));\n        cin >> m;\n        rep(i, m){\n            int x,y;\n            cin >> x >> y;\n            --x; --y;\n            p[x][y] = +1;\n            p[y][x] = -1;\n        }\n        rep(i, n){\n            t[i] = 0;\n            rep(j, n) t[i] += p[i][j];\n        }\n        ret = 0;\n        dfs(0);\n        cout << ret << endl;\n        // cerr << \"FIN\" << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#define ll long long\nusing namespace std;\n\nint w[9], l[9], n, t;\nint g[9][9];\n\nll dfs(int u, int v, int f) {\n\tll r = 0;\n\tif (g[u][v] == -1 || f == g[u][v]) {\n\t\tif (f) {\n\t\t\tw[u]++; l[v]++;\n\t\t\tif (w[u] <= t && l[v] <= n - t - 1) {\n\t\t\t\tif (u == n - 2)\n\t\t\t\t\tr = 1;\n\t\t\t\telse if (v == n - 1)\n\t\t\t\t\tr = dfs(u + 1, u + 2, 0) + dfs(u + 1, u + 2, 1);\n\t\t\t\telse\n\t\t\t\t\tr = dfs(u, v + 1, 0) + dfs(u, v + 1, 1);\n\t\t\t}\n\t\t\tw[u]--; l[v]--;\n\t\t}\n\t\telse if (!f) {\n\t\t\tw[v]++; l[u]++;\n\t\t\tif (w[v] <= t && l[u] <= n - t - 1) {\n\t\t\t\tif (u == n - 2) \n\t\t\t\t\tr = 1;\n\t\t\t\telse if (v == n - 1)\n\t\t\t\t\tr = dfs(u + 1, u + 2, 0) + dfs(u + 1, u + 2, 1);\n\t\t\t\telse\n\t\t\t\t\tr = dfs(u, v + 1, 0) + dfs(u, v + 1, 1);\n\t\t\t}\n\t\t\tw[v]--; l[u]--;\n\t\t}\n\t}\n\treturn r;\n}\n\nint main(void) {\n#ifdef _DEBUG\n\tfreopen(\"1.in\", \"r\", stdin);\n#else \n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#endif\n\tint m;\n\twhile (cin >> n, n) {\n\t\tt = (n - 1) / 2;\n\t\tcin >> m; memset(w, 0, sizeof(w)); memset(l, 0, sizeof(l));\n\t\tfor (int i = 0; i != n - 1; ++i)\n\t\t\tfor (int j = i + 1; j != n; ++j)\n\t\t\t\tg[i][j] = g[j][i] = -1;\n\t\twhile (m--) {\n\t\t\tint x, y; cin >> x >> y; x--; y--;\n\t\t\tg[x][y] = 1; g[y][x] = 0;\n\t\t}\n\n\t\tcout << dfs(0,1,0) + dfs(0,1,1) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <ctime>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <assert.h>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\n\nint memo[9][9];\nint n;\nint cnt;\n\n\nint dfs() {\n\t//cnt++;\n\tint w = 0, l = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tw = 0, l = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (memo[i][j] == -1) l++;\n\t\t\tif (memo[i][j] == 1) w++;\n\n\t\t}\n\t\tif (w > n / 2 || l > n / 2) return 0;\n\t}\n\tint x = -1, y = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (memo[i][j] == 0) {\n\t\t\t\tx = i, y = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (x != -1) break;\n\t}\n\tif (x == -1) return 1;\n\t//cerr << cnt << \" \" << x << \" \" << y << endl;\n\n\t\n\tint ret = 0;\n\tint win = 0, lose = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (memo[x][i] == 1) win++;\n\t\tif (memo[x][i] == -1) lose++;\n\t}\n\tif (win > (n - 1) / 2 || lose > (n - 1) / 2) return 0;\n\n\n\tif (win < (n - 1) / 2) {\n\t\tmemo[x][y] = 1;\n\t\tmemo[y][x] = -1;\n\t\tret += dfs();\n\t\tmemo[x][y] = 0;\n\t\tmemo[y][x] = 0;\n\t}\n\tif (lose < (n - 1) / 2) {\n\t\tmemo[x][y] = -1;\n\t\tmemo[y][x] = 1;\n\t\tret += dfs();\n\t\tmemo[x][y] = 0;\n\t\tmemo[y][x] = 0;\n\t}\n\treturn ret;\n\n\n\n}\n\n\nint main() {\n\tvector<int> v;\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tint m;\n\t\tcin >> m;\n\t\tfor (int i = 0; i < 9; i++)for (int j = 0; j < 9; j++) {\n\t\t\tmemo[i][j] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) memo[i][i] = 4;\n\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx--, y--;\n\t\t\tmemo[x][y] = 1;\n\t\t\tmemo[y][x] = -1;\n\t\t}\n\t\tcnt = 0;\n\t\tint ans = dfs();\n\t\tcout << ans << endl;\n\t\tv.push_back(ans);\n\t}\n\t//cerr << endl;\n\t//for (auto i : v) cout << i << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\nint N, M, A[9][9];\n//---------------------------------------------------------------------------------------------------\nint check(int y) {\n    int win = 0, non = 0;\n    rep(x, 0, N) {\n        if (A[y][x] == 1) win++;\n        else if (A[y][x] < 0 and y != x) non++;\n    }\n    return win <= (N - 1) / 2 and (N - 1) / 2 <= win + non;\n}\n//---------------------------------------------------------------------------------------------------\nint ans = 0;\nvoid dfs(int cu) {\n    int x = cu % N;\n    int y = cu / N;\n\n    if (cu == N * N) {\n        ans++;\n        return;\n    }\n\n    if (x == y or 0 <= A[y][x]) {\n        if (check(y)) dfs(cu + 1);\n        return;\n    }\n    \n    A[y][x] = 1; A[x][y] = 0;\n    if(check(y)) dfs(cu + 1);\n\n    A[y][x] = 0; A[x][y] = 1;\n    if (check(y)) dfs(cu + 1);\n\n    A[y][x] = A[x][y] = -1;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> N) {\n        if (N == 0) return;\n        cin >> M;\n        rep(i, 0, N) rep(j, 0, N) A[i][j] = -1;\n        rep(i, 0, M) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            A[a][b] = 1;\n            A[b][a] = 0;\n        }\n\n        ans = 0;\n        dfs(0);\n        printf(\"%d\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=40003;\nconst ll INF=1LL<<63;\ntypedef vector<vector<int>> mat;\n\nll cnt=0;\n\nll DFS(mat &S,int rem,int s){\n    int N=S.size();\n    \n    if(rem==0){\n        for(int i=0;i<N;i++){\n            int win=0,lose=0;\n            for(int j=0;j<N;j++){\n                if(S[i][j]==1) win++;\n                else if(S[i][j]==0) lose++;\n            }\n            if(win!=N/2||lose!=N/2) return 0;\n        }\n        return 1;\n    }\n    \n    for(int i=max(0,s-1);i<N;i++){\n        int win=0,lose=0;\n        for(int j=0;j<N;j++){\n            if(S[i][j]==1) win++;\n            else if(S[i][j]==0) lose++;\n        }\n        if(win>N/2||lose>N/2) return 0;\n    }\n    \n    ll res=0;\n    \n    for(int i=s;i<N;i++,s++){\n        for(int j=i+1;j<N;j++){\n            \n            if(S[i][j]==-1){\n                \n                S[i][j]=1;\n                S[j][i]=0;\n                \n                res+=DFS(S,rem-1,s);\n                \n                S[i][j]=0;\n                S[j][i]=1;\n                \n                res+=DFS(S,rem-1,s);\n                \n                S[i][j]=-1;\n                S[j][i]=-1;\n                \n                return res;\n            }\n        }\n    }\n    \n    return res;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    //cout<<5<<endl;\n    \n    while(1){\n        int N,M;cin>>N>>M;\n        if(N==0) break;\n        mat S(N,vector<int>(N,-1));\n        \n        for(int i=0;i<M;i++){\n            int a,b;cin>>a>>b;\n            a--;b--;\n            S[a][b]=1;\n            S[b][a]=0;\n        }\n        \n        cout<<DFS(S,(N)*(N-1)/2-M,0)<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\nint match[10][10];\nint ans = 0, n, win_max, lose_max, win[10], lose[10];\n\nvoid dfs(int k, int l) {\n    if (k == n) {\n        if (win_max == lose_max) ans++;\n        //cout << \"OK\" << endl;\n    }\n    else if (l == n) dfs(k + 1, 0);\n    else if (k < l && !match[k][l]) {\n        //cout << \"(\" << k << \", \" << l << \")\" << endl;\n        win[k]++;  lose[l]++;\n        match[k][l] = 1;\n        match[l][k] = -1;\n        int t1 = win_max, t2 = lose_max;\n        win_max = max(win[k], win_max);\n        lose_max = max(lose[l], lose_max);\n        /*cout << win_max << \" \" << lose_max << endl;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) cout << \"\\\\\";\n                else if (match[i][j] == -1) cout << \"X\";\n                else if (match[i][j] == 0) cout << \"-\";\n                else cout << \"O\";\n            }\n            cout << \" \" << win[i] << \" \" << lose[i];\n            cout << endl;\n        }*/\n        if (max(win_max, lose_max) <= n / 2) dfs(k, l + 1);\n        win[k]--;  lose[l]--;\n        \n        \n        match[k][l] = 0;\n        match[l][k] = 0;\n        \n        //cout << \"(\" << k << \", \" << l << \")\" << endl;\n        win[l]++;  lose[k]++;\n        match[k][l] = -1;\n        match[l][k] = 1;\n        win_max = t1;\n        lose_max = t2;\n        win_max = max(win[l], win_max);\n        lose_max = max(lose[k], lose_max);\n        /*\n        cout << win_max << \" \" << lose_max << endl;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) cout << \"\\\\\";\n                else if (match[i][j] == -1) cout << \"X\";\n                else if (match[i][j] == 0) cout << \"-\";\n                else cout << \"O\";\n            }\n            cout << \" \" << win[i] << \" \" << lose[i];\n            cout << endl;\n        }*/\n        if (max(win_max, lose_max) <= n / 2) dfs(k, l + 1);\n        win[l]--;  lose[k]--;\n        match[k][l] = 0;\n        match[l][k] = 0;\n        \n    }\n    else dfs(k, l + 1);\n}\n\n\nint main(void){\n    while (cin >> n) {\n        if (!n) return 0;\n        \n        int m;\n        cin >> m;\n        ans = 0;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) match[i][j] = false;\n            win[i] = lose[i] = 0;\n        }\n        win_max = lose_max = 0;\n        \n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            match[x-1][y-1] = 1;\n            match[y-1][x-1] = -1;\n            win[x-1]++;  lose[y-1]++;\n            win_max = max(win_max, win[x - 1]);\n            lose_max = max(lose_max, lose[y-1]);\n        }\n        \n        dfs(0, 1);\n        \n        cout << ans << endl;\n        \n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint n, m;\nint field[10][10];\nll ans = 0;\nint win[10];\n\nvoid f(int person) {\n    //cerr << \"F: \" << person << \" \" << win[person] << endl;\n    if(person == n) {\n        if(win[person] == 0) ans++;\n        return;\n    }\n    int rest = n - person;\n    if(win[person] < 0 || win[person] > rest) return;\n    vector<int> bit(rest);\n    for(int i = 0; i < win[person]; i++) bit[rest - 1 - i] = 1;\n    do {\n        //cerr << \"A\" << endl;\n        bool out = false;\n        for(int j = 1; j <= rest; j++) {\n            if(field[person][person+j] == 0) continue;\n            if((field[person][person+j] == 1) ^ (bit[j-1] == 1)) out = true;\n        }\n        if(out) continue;\n        /*\n        cerr << \"BIT: \";\n        for(int j = 0; j < bit.size(); j++) cerr << bit[j] << \" \";\n        cerr << endl;\n        */\n        for(int j = 1; j <= rest; j++) {\n            if(!bit[j-1]) win[person+j]--;\n        }\n        f(person + 1);\n        for(int j = 1; j <= rest; j++) {\n            if(!bit[j-1]) win[person+j]++;\n        }\n    } while(next_permutation(bit.begin(), bit.end()));\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        ans = 0;\n        cin >> n;\n        if(n == 0) break;\n        for(int i = 1; i <= n; i++) win[i] = n / 2;\n        cin >> m;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= n; j++) field[i][j] = 0;\n        }\n        while(m--) {\n            int x, y;\n            cin >> x >> y;\n            if(x > y) field[y][x] = -1;\n            else field[x][y] = 1;\n        }\n        f(1);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nint n, m;\nll ans = 0;\nint w[10], l[10];\nint result[10][10];\nvoid init(){\n    ans = 0;\n    for(int i = 0; i < 10; i++){\n        w[i] = 0;\n        l[i] = 0;\n        for(int j = 0; j < 10; j++){\n            result[i][j] = 0;\n        }\n    }\n}\n\nbool check(){\n    for(int i = 1; i <= n; i++){\n        if(w[i] * 2 > n)return false;\n        if(l[i] * 2 > n)return false;\n    }\n    return true;\n}\n\nvoid dfs(int a, int b){\n    if(!check())return;\n    if(a == n){\n        ans++;\n        return;\n    }\n    if(b > n){\n        dfs(a + 1, a + 2);\n        return;\n    }\n    if(result[a][b]){\n        dfs(a, b + 1);\n        return;\n    }\n    w[a]++;\n    l[b]++;\n    dfs(a, b + 1);\n    w[a]--;\n    l[b]--;\n    l[a]++;\n    w[b]++;\n    dfs(a, b + 1);\n    l[a]--;\n    w[b]--;\n}\n\nint main(){\n    \n    while(cin >> n, n){\n        cin >> m;\n        init();\n        for(int i = 0; i < m; i++){\n            int a, b;\n            cin >> a >> b;\n            result[a][b] = 1;\n            w[a]++;\n            result[b][a] = -1;\n            l[b]++;\n        }\n        dfs(1, 2);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\ntypedef struct{\n    int won;\n    int lost;\n}Team;\nTeam team[9];\nint n,m;\nint cnt;\nint map[9][9];\nvoid init(){\n    for(int i=0;i<n;i++){\n        team[i].won=team[i].lost=0;\n    }\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            if(i==j)\n                map[i][j]=1;\n            else\n                map[i][j]=0;\n        }\n    }\n}\nvoid rec(int y, int x){\n    if(x==n){\n        y++; x=y+1;\n    }\n    \n    \n    if(team[y].won>(n/2));\n    else if(team[y].lost>(n/2));\n    else if(y==n-2 && x==n-1){\n        cnt++;\n    }\n    else{\n        if(map[y][x]!=0){\n            rec(y,x+1);\n        }\n        else{\n            if(team[y].won<(n/2)){\n                team[y].won++;\n                team[x].lost++;\n                map[y][x]=map[x][y]=1;\n                rec(y,x+1);\n                map[y][x]=map[x][y]=0;\n                team[y].won--;\n                team[x].lost--;\n            }\n            \n            if(team[y].lost<(n/2)){\n                team[y].lost++;\n                team[x].won++;\n                map[y][x]=map[x][y]=1;\n                rec(y,x+1);\n                map[y][x]=map[x][y]=0;\n                team[y].lost--;\n                team[x].won--;\n            }\n        }\n    }\n}\nint main(void){\n    while(1){\n        scanf(\"%d\",&n); if(n==0) break;\n        init();\n        scanf(\"%d\",&m);\n        for(int i=0; i<m; i++){\n            int x,y;\n            scanf(\"%d %d\",&x,&y);\n            x--; y--;\n            map[x][y]=1;\n            map[y][x]=1;\n            team[x].won++; team[y].lost++;\n        }\n        cnt=0;\n        rec(0,0);\n        printf(\"%d\\n\",cnt);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, m, ans, table[9][9];\n\nint chack(){\n\tfor(int i=0; i<n; i++){\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; j++) tmp += table[i][j];\n\t\tif(tmp) return 0;\n\t}\n\treturn 1;\n}\n\n\nvoid dfs(int x, int y){\n\tif(x < n-1) x++;\n\telse if(y < n-1){\n\t\tx=0;\n\t\ty++;\n\t} else{\n\t\tans += chack();\n\t\treturn;\n\t}\n\n\tif(x==0 && 0<y){\n\t\tint tmp =0;\n\t\tfor(int i=0; i<n; i++) tmp += table[y-1][i];\n\t\tif(tmp) return;\n\t}\n\n\tif(table[y][x] == 0 && y != x){\n\t\ttable[y][x] = 1;\n\t\ttable[x][y] = -1;\n\t\tdfs(x, y);\n\n\t\ttable[y][x] = -1;\n\t\ttable[x][y] = 1;\n\t\tdfs(x, y);\n\n\t\ttable[y][x] = table[x][y] = 0;\n\t} else dfs(x, y);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfill(table[0], table[8], 0);\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\ttable[x][y] = 1;\n\t\t\ttable[y][x] = -1;\n\t\t}\n\n\t\tans = 0;\n\t\tdfs(0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\tstatic int n;\n\tstatic int m;\n\tstatic int[][] table = new int[9][9];\n\tstatic int ans;\n\tstatic boolean check(int team){\n\t\tint win = 0;\n\t\tint lose = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(table[team][i]>0)win++;\n\t\t\telse if(table[team][i]<0)lose++;\n\t\t}\n\t\treturn win <= (n-1)/2;\n\t}\n\n\tstatic void dfs(int cnt){\n\t\tif(cnt==n*n){\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\tint team = cnt / n;\n\t\tint against = cnt % n;\n\t\tif(table[team][against]==2 || table[team][against]==-2 || team>=against){\n\t\t\tif(check(team))dfs(cnt+1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\ttable[team][against] = 1;\n\t\t\ttable[against][team] = -1;\n\t\t\tif(check(team))dfs(cnt+1);\n\t\n\t\t\ttable[team][against] = -1;\n\t\t\ttable[against][team] = 1;\n\t\t\tif(check(team))dfs(cnt+1);\n\n\t\t\ttable[team][against] = 0;\n\t\t\ttable[against][team] = 0;\n\t\t\treturn;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\twhile(n!=0){\n\t\t\tm = sc.nextInt();\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\tArrays.fill(table[i], 0);\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\ttable[x][y] = 2;\n\t\t\t\ttable[y][x] = -2;\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(ans);\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\t\n\t\t\t\n\t\t\tfor(int i = 0; i < m ; i++){\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tmap[x][y] = 1;\n\t\t\t\tmap[y][x] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dfs(map,0,1,0));\n\t\t}\n\t}\n\t\n\tint dfs(int map[][],int x,int y,int count){\n\t\tif(x >= map.length){\n\t\t\treturn 1;\n\t\t}\n\t\tif(y >= map[x].length){\n\t\t\tint ss = 0;\n\t\t\tfor(int s :map[x]){\n\t\t\t\tss += s;\n\t\t\t}\n\t\t\tif(ss == 0){\n\t\t\t\treturn dfs(map,x+1,x+2,count);\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(map[x][y] != 0){\n\t\t\treturn dfs(map,x,y+1,count);\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tmap[x][y] = 1;\n\t\tmap[y][x] = -1;\n\t\tres += dfs(map,x,y+1,count);\n\t\tmap[x][y] = -1;\n\t\tmap[y][x] = 1;\n\t\tres += dfs(map,x,y+1,count);\n\t\tmap[x][y] = 0;\n\t\tmap[y][x] = 0;\n\t\treturn res;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\tstatic int n;\n\tstatic int m;\n\tstatic int[][] table = new int[9][9];\n\tstatic int ans;\n\tstatic boolean check(int team){\n\t\tint win = 0;\n\t\tint lose = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(table[team][i]>0)win++;\n\t\t\telse if(table[team][i]<0)lose++;\n\t\t}\n\t\treturn win <= (n-1)/2 & lose <= (n-1)/2;\n\t}\n\n\tstatic void dfs(int cnt){\n\t\tif(cnt==n*n){\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\tint team = cnt / n;\n\t\tint against = cnt % n;\n\t\tif(table[team][against]==2 || table[team][against]==-2 || team>=against){\n\t\t\tif(check(team))dfs(cnt+1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\ttable[team][against] = 1;\n\t\t\ttable[against][team] = -1;\n\t\t\tif(check(team))dfs(cnt+1);\n\t\n\t\t\ttable[team][against] = -1;\n\t\t\ttable[against][team] = 1;\n\t\t\tif(check(team))dfs(cnt+1);\n\n\t\t\ttable[team][against] = 0;\n\t\t\ttable[against][team] = 0;\n\t\t\treturn;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\twhile(n!=0){\n\t\t\tm = sc.nextInt();\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\tArrays.fill(table[i], 0);\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\ttable[x][y] = 2;\n\t\t\t\ttable[y][x] = -2;\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(ans);\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n\tstatic int n;\n\tstatic int m;\n\tstatic int[][] result;\n\tstatic int count;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\tm = sc.nextInt();\n\t\t\tresult = new int[n][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tresult[x][y] = 1;\n\t\t\t\tresult[y][x] = -1;\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tdfs(0, 1);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic void dfs(int x, int y) {\n\t\tif (y == n) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tsum += result[x][i];\n\t\t\t}\n\t\t\tif (sum == 0) {\n\t\t\t\tif (x < n - 1) {\n\t\t\t\t\tdfs(x + 1, x + 2);\n\t\t\t\t} else {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (x == y || result[x][y] != 0) {\n\t\t\tdfs(x, y + 1);\n\t\t} else {\n\t\t\tresult[x][y] = 1;\n\t\t\tresult[y][x] = -1;\n\t\t\tdfs(x, y + 1);\n\t\t\tresult[x][y] = -1;\n\t\t\tresult[y][x] = 1;\n\t\t\tdfs(x, y + 1);\n\t\t\tresult[x][y] = 0;\n\t\t\tresult[y][x] = 0;\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n;\n\tstatic int num;\n\tstatic int max;\n\tpublic static void main(String[] args) {\n\t\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tint ans = solve(n);\n\t\t\tif(ans!=-1) {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int solve(int N) {\n\t\tif(N==0) {\n\t\t\treturn -1;\n\t\t}else {\n\t\t\tnum = 0;\n\t\t\tint[] win = new int[N+1];\n\t\t\tint[] lose = new int[N+1];\n\t\t\tint[][] table = new int[N+1][N+1];\n\t\t\tBoolean B = false;\n\t\t\tmax = N/2;\n\t\t\tint m = sc.nextInt();\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\ttable[w][l] = 1;\n\t\t\t\ttable[l][w] = -1;\n\t\t\t\twin[w]++;\n\t\t\t\tlose[l]++;\n\t\t\t\tif(win[w]>max||lose[l]>max) {\n\t\t\t\t\tB = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(B) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcheck(win,lose,table,1,2);\n\t\t\treturn num;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tprivate static void check(int[] ws, int[] ls, int[][] tb,int a,int b) {\n\t\tif(a==n-1&&b==n) {\n\t\t\tnum++;\n\t\t}else {\n\t\t\tif(tb[a][b]!=0) {\n\t\t\t\tif(b!=n) {\n\t\t\t\t\tcheck(ws,ls,tb,a,b+1);\n\t\t\t\t}else {\n\t\t\t\t\tcheck(ws,ls,tb,a+1,a+2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else {\n\t\t\t\tif(ws[a]<max&&ls[b]<max) {\n\t\t\t\t\tws[a]++;\n\t\t\t\t\tls[b]++;\n\t\t\t\t\tif(b!=n) {\n\t\t\t\t\t\tcheck(ws,ls,tb,a,b+1);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tcheck(ws,ls,tb,a+1,a+2);\n\t\t\t\t\t}\n\t\t\t\t\tws[a]--;\n\t\t\t\t\tls[b]--;\n\t\t\t\t}\n\t\t\t\tif(ws[b]<max&&ls[a]<max) {\n\t\t\t\t\tws[b]++;\n\t\t\t\t\tls[a]++;\n\t\t\t\t\tif(b!=n) {\n\t\t\t\t\t\tcheck(ws,ls,tb,a,b+1);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tcheck(ws,ls,tb,a+1,a+2);\n\t\t\t\t\t}\n\t\t\t\t\tws[b]--;\n\t\t\t\t\tls[a]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\t \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int[] win;\n\tstatic int wincount=0;\n\tstatic int dfs(int[][] map, int x, int y, int r) {\n\t\tmap[x][y]=r;//勝ち2　負け1　まだ0\n\t\tmap[y][x]=3-r;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\twin[i]=0;\n\t\t\tfor(int j=1; j<=n; j++) {\n\t\t\t\tif(map[i][j]==2) {\n\t\t\t\t\twin[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(win[i]>wincount) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"dfs後　\"+\"x=\"+x+\" y=\"+y+\" r=\"+r+\" win[\"+x+\"]=\"+win[x]);\n\t\tint count=0;\n\t\tint ai=0, aj=0;\n\t\tboolean box=false;//空欄ありtrue なしfalse\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tfor(int j=1; j<=n; j++) {\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(map[i][j]==0) {\n\t\t\t\t\tbox=true;\n\t\t\t\t\tai=i;\n\t\t\t\t\taj=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(box) break;\n\t\t}\n\t\tif(! box) {\n\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\t//System.out.println(\"win[\"+i+\"]=\"+win[i]);\n\t\t\t\tif(win[i]!=wincount) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tint[][] cmap=new int[n+1][n+1];\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tfor(int j=1; j<=n; j++) {\n\t\t\t\tcmap[i][j]=map[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcount+=dfs(cmap, ai, aj, 2);\n\t\t//win[ai]--;\n\t\t//System.out.println(\"ai後　win[\"+ai+\"]=\"+win[ai]);\n\t\tcount+=dfs(cmap, ai, aj, 1);\n\t\t//win[aj]--;\n\t\t//System.out.println(\"aj後　win[\"+aj+\"]=\"+win[aj]);\n\t\t\n\t\treturn count;\n\t\t\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tn=sc.nextInt();\n\t\t\t\tif(n==0) break;\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tint[][] p=new int[n+1][n+1];\n\t\t\t\twin=new int[n+1];\n\t\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\t\tint x=sc.nextInt();\n\t\t\t\t\tint y=sc.nextInt();\n\t\t\t\t\tp[x][y]=2;\n\t\t\t\t\tp[y][x]=1;\n\t\t\t\t\twin[x]++;\n\t\t\t\t}\n\t\t\t\twincount=(n-1)/2;\n\t\t\t\tSystem.out.println(dfs(p, 1, 1, 0));\n\t\t\t}\n\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\n\ndef dfs(d,s,l,v,dic):\n    s_ = tuple(s)\n    if dic[(d,s_)] != None:\n        return dic[(d,s_)]\n    if d == l:\n        dic[(d,s_)] = 1\n        for x in s:\n            if x > (n>>1):\n                dic[(d,s_)] = 0\n                return 0\n        return 1\n    else:\n        res = 0\n        i,j = v[d]\n        if s[i] < (n>>1):\n            s[i] += 1\n            res += dfs(d+1,s,l,v,dic)\n            s[i] -= 1\n        if s[j] < (n>>1):\n            s[j] += 1\n            res += dfs(d+1,s,l,v,dic)\n            s[j] -= 1\n        dic[(d,s_)] = res\n        return res\n\ndef solve(n):\n    dic = defaultdict(lambda : None)\n    m = int(sys.stdin.readline())\n    s = [0]*n\n    f = [[1]*n for i in range(n)]\n    for i in range(n):\n        f[i][i] = 0\n    for i in range(m):\n        x,y = [int(x) for x in sys.stdin.readline().split()]\n        x -= 1\n        y -= 1\n        s[x] += 1\n        f[x][y] = 0\n        f[y][x] = 0\n    v = []\n    for i in range(n):\n        for j in range(i+1,n):\n            if f[i][j]:\n                v.append((i,j))\n    l = len(v)\n    print(dfs(0,s,l,v,dic))\n\nwhile 1:\n    n = int(sys.stdin.readline())\n    if n == 0:\n        break\n    solve(n)\n\n"
  },
  {
    "language": "Python",
    "code": "\n# next_combination:\n# given an integer cur, next_combination returns an integer nxt s.t.\n#   nxt has the same number of 1s as cur\n#   nxt is bigger than cur\n#   no integer between cur and nxt has the same number of 1s as cur (and nxt)\ndef next_combination(cur):\n    r1 = cur & -cur      # extracts the rightmost 1\n    moved1 = cur + r1    # cancel the rightmost run of 1s and put 1 on its left\n    rm1s = cur & ~moved1 # extracts the rightmost run of 1s\n    reset = (rm1s // r1) >> 1 # the run of 1s moved to LSD and made its length decreased by 1\n    nxt = moved1 | reset # new combination\n    return nxt\n\n# the next is i-th, with a[k] for k > i to win\n# at most 4 wins for each: about 4^9 = 2^18 states?\nwhile True:\n    n=int(input())\n    if n == 0: break\n    \n    m=int(input())\n    # wons and loses so far\n    wons=[ 0 for _ in range(n) ]\n    loses=[ 0 for _ in range(n) ]\n    for i in range(m):\n        x,y=map(int,input().split())\n        wons[x-1] |= (1<<(y-1))\n        loses[y-1] |= (1<<(x-1))\n\t\n    memo = tuple({} for _ in range(9) )\n\t\n    \n    def rec(i,ws):\n        if i >= n: return 1\n        if n - 1 - i < ws[i]: return 0\n        if tuple(ws) in memo[i]:\n            return memo[i][tuple(ws)]\n        # possible assignments of ws[i] wins matching with the input\n        k = ws[i]\n        win = ((1<<k) - 1) << (i+1)   # beginning: k wins against i+1,...,i+k\n        fin = win << (n-1-k-i)        # end: k wins against n-k+1...,n-1\n        cnt = 0\n        while True:\n\t    # print(\"win = {0}\".format(bin(win)))\n\t    # print(\"fin = {0}\".format(bin(fin)))\n\t    # consistency check with wons and loses \n            mask = (1<<n) - (1<<(i+1))  # i+1, ..., n-1\n            won = wons[i]\n            lose = loses[i]\n            if (won & win) == (won & mask) and (lose & win) == 0:\n                ok = True\n                for j in range(i+1,n):\n                    if (1<<j) & win == 0:\n                        if ws[j] == 0: ok = False\n                        ws[j] -= 1\n                if ok: cnt += rec(i+1, ws)\n                for j in range(i+1,n):\n                    if (1<<j) & win == 0:\n                        ws[j] += 1\n            if win == fin: break\n            win = next_combination(win)\n        \n        memo[i][tuple(ws)] = cnt\n        return cnt\n    \n    ans=rec(0, [ n//2 for _ in range(n)] )\t\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations as comb\n\ndef main():\n  while True:\n    n = int(input())\n    if n ==0:break\n    m = int(input())\n    result = [[None] * n for _ in range(n)]\n    for _ in range(m):\n      x, y = map(int, input().split())\n      x -= 1\n      y -= 1\n      result[x][y] = True\n      result[y][x] = False\n\n    t_count = [lst.count(True) for lst in result]\n    \n    empty_index = [[] for _ in range(n)]\n    empty_nums = [0] * n\n    for i in range(n):\n      for j in range(i + 1, n):\n        if result[i][j] == None:\n          empty_index[i].append(j)\n          empty_nums[i] += 1\n    \n    memo = {}\n    limit = n // 2\n    def search(x, t_count):\n      if (x, tuple(t_count)) in memo:return memo[(x, tuple(t_count))]\n      if x == n:return 1\n      choice_num = limit - t_count[x]\n      if choice_num < 0 or choice_num > empty_nums[x]:return 0\n      rest_num = empty_nums[x] - choice_num\n      ret = 0\n      for inds in comb(empty_index[x], rest_num):\n        new_count = t_count[:]\n        for ind in inds:\n          new_count[ind] += 1\n        ret += search(x + 1, new_count)\n      memo[(x, tuple(t_count))] = ret\n \n      return ret\n\n    print(search(0, t_count))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom itertools import combinations\n\ndef dfs(idx,N,win_cnt,will_match):\n    if(idx==N):\n        #win_cntがすべて(N-1)/2なら1を返す\n        return 1\n    \n    need_win = (N-1)//2 - win_cnt[idx] #引き分けにするための必要勝数\n    need_lose = len(will_match[idx]) - need_win\n    # print(need_win,need_lose,(len(will_match[idx]),win_cnt[idx]))\n    if(need_win > len(will_match[idx]) or need_win < 0): # 残りの試合をどう戦っても、引き分けにならない\n        return 0\n    res = 0\n    # print(idx,\"が負ける必要がある\",need_lose)\n    for it in combinations(will_match[idx],need_lose): ##負け試合をピッタリ必要なだけ選ぶ\n        tmp = win_cnt.copy() ##勝数をいじるので現状保存\n        # print(idx,win_cnt)\n        # print(list(it))\n        for i in it:\n            # print(\"i\",i)\n            tmp[i] += 1 ## idx番目のチームの負けなので相手チームの勝数を1増やす\n        res += dfs(idx+1,N,tmp,will_match)\n    \n    return res\ndef solve(N):\n    M=int(input())\n    # print(N,M)\n    XY = [[int(i)-1 for i in input().split()] for _ in range(M)]\n    win_cnt = [0]*N #チームiが何回勝ったか\n\n    match = [[-1]*N for _ in range(N)]\n    for x,y in XY:\n        match[x][y] = 1\n        match[y][x] = 0\n        win_cnt[x]+=1\n        if(x>y):\n            x,y = y,x\n    will_match = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(i+1,N):\n            if(match[i][j]==-1): #戦ってない\n                will_match[i].append(j)\n    # print(*match,sep=\"\\n\")\n    # print(win_cnt)\n    # print(*will_match,sep=\"\\n\")\n    ans = dfs(0,N,win_cnt,will_match)\n\n    print(ans)\n        \n\n\ndef main():\n    input = sys.stdin.readline\n    while True:\n        N = int(input())\n        if(not N):\n            break\n        solve(N)\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random,resource\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\ndef main():\n    rr = []\n\n    def f():\n        n = I()\n        if n == 0:\n            return\n\n        m = I()\n        xy = [LI_() for _ in range(m)]\n\n        nn = n // 2\n        aa = [[0] * n for _ in range(n)]\n        wl = [[0] * 2 for _ in range(n)]\n        for x, y in xy:\n            aa[x][y] = aa[y][x] = 1\n            wl[x][0] += 1\n            wl[y][1] += 1\n\n        for i in range(n):\n            if wl[i][0] > nn or wl[i][1] > nn:\n                rr.append(0)\n                return True\n\n        kh = []\n        for x in range(n):\n            for y in range(x+1, n):\n                if aa[x][y] == 0:\n                    kh.append((x,y))\n        ks = len(kh)\n\n        def ff(wl, i):\n            if i == ks:\n                return 1\n\n            r = 0\n            x,y = kh[i]\n            if wl[x][0] < nn and wl[y][1] < nn:\n                wl[x][0] += 1\n                wl[y][1] += 1\n                r += ff(wl, i+1)\n                wl[x][0] -= 1\n                wl[y][1] -= 1\n\n            if wl[x][1] < nn and wl[y][0] < nn:\n                wl[x][1] += 1\n                wl[y][0] += 1\n                r += ff(wl, i+1)\n                wl[x][1] -= 1\n                wl[y][0] -= 1\n\n            return r\n\n        rr.append(ff(wl, 0))\n\n        return True\n\n    while f():\n        pass\n\n    return JA(rr, \"\\n\")\n\n\nprint(main())\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from itertools import product\nwhile 1:\n    N = int(input())\n    if N == 0:\n        break\n    M = int(input())\n    S = [0]*N\n    A = [[None]*N for i in range(N)]\n    for i in range(M):\n        x, y = map(int, input().split()); x -= 1; y -= 1\n        S[x] += 1\n        A[x][y] = 1; A[y][x] = 0\n    B = []\n    for i in range(N):\n        for j in range(i+1, N):\n            if A[i][j] is None:\n                B.append((i, j))\n    L = len(B)\n    memo = [{} for i in range(L)]\n    def dfs(k, s):\n        if L == k:\n            return all(e <= N//2 for e in s)\n        key = tuple(s)\n        v = memo[k]\n        if key in v:\n            return v[key]\n        res = 0\n        i, j = B[k]\n        if s[i]+1 <= N//2:\n            s[i] += 1\n            res += dfs(k+1, s)\n            s[i] -= 1\n        if s[j]+1 <= N//2:\n            s[j] += 1\n            res += dfs(k+1, s)\n            s[j] -= 1\n        v[key] = res\n        return res\n    print(dfs(0, S))\n\n"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations as comb\n\ndef main():\n  while True:\n    n = int(input())\n    if n ==0:break\n    m = int(input())\n    result = [[None] * n for _ in range(n)]\n    for _ in range(m):\n      x, y = map(int, input().split())\n      x -= 1\n      y -= 1\n      result[x][y] = True\n      result[y][x] = False\n\n    t_count = [lst.count(True) for lst in result]\n    \n    empty_index = [[] for _ in range(n)]\n    empty_nums = [0] * n\n    for i in range(n):\n      for j in range(i + 1, n):\n        if result[i][j] == None:\n          empty_index[i].append(j)\n          empty_nums[i] += 1\n\n    limit = n // 2\n    def search(x, t_count):\n      if x == n:return 1\n      choice_num = limit - t_count[x]\n      if choice_num < 0 or choice_num > empty_nums[x]:return 0\n      rest_num = empty_nums[x] - choice_num\n      ret = 0\n      for inds in comb(empty_index[x], rest_num):\n        new_count = t_count[:]\n        for ind in inds:\n          new_count[ind] += 1\n        ret += search(x + 1, new_count)\n \n      return ret\n\n    print(search(0, t_count))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef main(n):\n    m = int(input())\n    d = defaultdict(int)\n    k = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            d[k] = (i, j)\n            k += 1\n    p = defaultdict(int)\n    for i in range(m):\n        x, y = map(int, input().split())\n        p[(x, y)] = 1\n        p[(y, x)] = -1\n    ans = defaultdict(int)\n    tmp = [0] * n\n    ans[tuple(tmp)] = 1\n    for i in range(k):\n        nd = defaultdict(int)\n        for key, value in ans.items():\n            key = list(key)\n            x, y = d[i]\n            if p[(x, y)]:\n                if p[(x, y)] == 1:\n                    if key[x - 1] == n//2: continue\n                    key[x - 1] += 1\n                    nd[tuple(key)] += value\n                else:\n                    if key[y - 1] == n//2: continue\n                    key[y - 1] += 1\n                    nd[tuple(key)] += value\n            else:\n                    if key[y - 1] != n//2: \n                        key[y - 1] += 1\n                        nd[tuple(key)] += value\n                        key[y - 1] += -1\n                    if key[x - 1] != n//2:\n                        key[x - 1] += 1\n                        nd[tuple(key)] += value\n        ans = nd\n    print(ans[tuple([n // 2] * n)])\n\nif __name__ == \"__main__\":\n    while 1:\n        n = int(input())\n        if n:\n            main(n)\n        else:\n            break\n"
  }
]