[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define rs (x<<1|1)\n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=2e2+5;\nint n,h;\nmultiset<int>dd1[maxn],dd2[maxn],uu1[maxn],uu2[maxn],ud[maxn],du[maxn];\nmultiset<int>nud[maxn],ndu[maxn];\ntypedef multiset<int>::iterator It;\nint main(){\n\tread(n);read(h);\n\trep(i,1,n){\n\t\tint a,b,c,d;read(a);read(b);read(c);read(d);\n\t\tif(!c){\n\t\t\tif(!d)dd1[a].insert(b),dd2[b].insert(a);\n\t\t\telse du[a].insert(d);\n\t\t}else{\n\t\t\tif(!d)ud[b].insert(c);\n\t\t\telse uu1[c].insert(d),uu2[d].insert(c);\n\t\t}\n\t}\t\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(ud[i])){\n\t\t\tflag=1;\n\t\t\tIt it=ud[i].begin();\n\t\t\tud[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(ud[x])){\n\t\t\t\tIt it2=ud[x].begin();\n\t\t\t\tud[x].erase(it2);\n\t\t\t\tud[i].insert(*it2);\n\t\t\t}else nud[i].insert(*it);\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(du[i])){\n\t\t\tflag=1;\n\t\t\tIt it=du[i].begin();\n\t\t\tdu[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(du[x])){\n\t\t\t\tIt it2=du[x].begin();\n\t\t\t\tdu[x].erase(it2);\n\t\t\t\tdu[i].insert(*it2);\n\t\t\t}else ndu[i].insert(*it);\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(nud[i])){\n\t\t\tflag=1;\n\t\t\tIt it=nud[i].begin();\n\t\t\tnud[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(dd2[x])){\n\t\t\t\tIt it2=dd2[x].begin();\n\t\t\t\tdd2[x].erase(it2);\n\t\t\t\tdd1[*it2].erase(dd1[*it2].find(x));\n\t\t\t\tdd1[*it2].insert(i);\n\t\t\t\tdd2[i].insert(*it2);\n\t\t\t}else{\n\t\t\t\treturn puts(\"NO\"),0;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(ndu[i])){\n\t\t\tflag=1;\n\t\t\tIt it=ndu[i].begin();\n\t\t\tndu[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(dd1[x])){\n\t\t\t\tIt it2=dd1[x].begin();\n\t\t\t\tdd1[x].erase(it2);\n\t\t\t\tdd2[*it2].erase(dd2[*it2].find(x));\n\t\t\t\tdd2[*it2].insert(i);\n\t\t\t\tdd1[i].insert(*it2);\n\t\t\t}else{\n\t\t\t\treturn puts(\"NO\"),0;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tint flag=0;\n\t\trep(i,1,h)if(SZ(dd1[i])>SZ(uu2[i])){\n\t\t\tflag=1;\n\t\t\tIt it=dd1[i].begin();\n\t\t\tdd1[i].erase(it);\n\t\t\tdd2[*it].erase(dd2[*it].find(i));\n\t\t\tint x=*it;\n\t\t\tif(SZ(uu1[x])){\n\t\t\t\tIt it2=uu1[x].begin();\n\t\t\t\tuu1[x].erase(it2);\n\t\t\t\tuu2[*it2].erase(uu2[*it2].find(x));\n\t\t\t\tif(SZ(dd1[*it2])){\n\t\t\t\t\tIt it3=dd1[*it2].begin();\n\t\t\t\t\tdd1[*it2].erase(it3);\n\t\t\t\t\tdd2[*it3].erase(dd2[*it3].find(*it2));\n\t\t\t\t\tdd1[i].insert(*it3);\n\t\t\t\t\tdd2[*it3].insert(i);\n\t\t\t\t}else return puts(\"NO\"),0;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\trep(i,1,h)if(SZ(uu1[i]))return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//神题\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 410\nusing namespace std;\nint n, m, du[N], f[N], size[N], flag[N], A, B, C, D, x, y, x1, y1;\ninline int gether(int x){return f[x]?f[x]=gether(f[x]):x;}\nint main(){\n\tscanf(\"%d%d\", &n, &m); m<<=1;\n\tmemset(du, 0, sizeof(du)); memset(f, 0, sizeof(f)); memset(size, 0, sizeof(size));\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%d%d%d%d\", &A, &B, &C, &D);\n\t\tx=C?-C:A; y=D?D:-B; if(x<=0)x+=m+1; if(y<=0)y+=m+1;\n\t\tdu[x]++; du[y]--;\n\t\tx1=gether(x); y1=gether(y); if(x1!=y1){f[y1]=x1; size[x1]+=size[y1];} size[x1]++;\n\t}\n\tfor(int i=1; i<=m/2; i++)if(du[i]<=-1){printf(\"NO\"); return 0;}\n\tfor(int i=m/2+1; i<=m; i++)if(du[i]>=1){printf(\"NO\"); return 0;}\n\tmemset(flag, 0, sizeof(flag));\n\tfor(int i=1; i<=m; i++)if(du[i])flag[gether(i)]=1;\n\tfor(int i=1; i<=m; i++)if(!f[i]&&size[i]&&!flag[i]){printf(\"NO\"); return 0;}\n\tprintf(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\nint h;\n\n#define MAXX 202\nint lef[MAXX];\nint rig[MAXX];\n\nint deg[MAXX*2];\n\nvector<int> v[MAXX*2];\n\nint belong[MAXX * 2];\ninline int root(int b){\n\tif (belong[b] == -1){\n\t\treturn b;\n\n\t}\n\tbelong[b] = root(belong[b]);\n\treturn belong[b];\n}\nvoid merge(int a, int b){\n\ta = root(a);\n\tb = root(b);\n\tif (a == b){\n\t\treturn;\n\t}\n\tbelong[a] = b;\n}\nmap<int, vector<int> > mp;\n\nbool ava[MAXX];\n\nbool check(vector<int> vv){\n\tbool ng = false;\n\tint restr = 0;\n\tint restl = 0;\n\tint id = -1;\n\tint id2 = -1;\n\tfor (int ii = 0; ii <vv.size();ii++){\n\t\tint i = vv[ii];\n\t\tif (deg[rig[i]] >= 0 && deg[lef[i]] <= 0){\n\t\t\trestr += deg[rig[i]];\n\t\t\trestl += -deg[lef[i]];\n\t\t\tif (deg[rig[i]]){\n\t\t\t\tid = rig[i];\n\t\t\t}\n\t\t\tif (deg[lef[i]] < 0){\n\t\t\t\tid2 = lef[i];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tng = true;\n\t\t}\n\t}\n\tif (restr == 0 || restl == 0){\n\t\treturn false;\n\t}\n\tif (ng){\n\t\treturn false;\n\t}\n\tif (restr == 1 && restl == 1 && v[id].size() == 1 && v[id2].size() == 1 && v[id][0] == v[id2][0]){\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main(){\n\tmemset(belong, -1, sizeof(belong));\n\tfor (int i = 0; i < MAXX; i++){\n\t\tlef[i] = 2 * i;\n\t\trig[i] = lef[i] + 1;\n\t}\n\tcin >> n >> h;\n\tfor (int i = 0; i < n; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint k;\n\t\tif (c){\n\t\t\tdeg[lef[c]]++;\n\t\t\tk = lef[c];\n\t\t\tava[lef[c]] = true;\n\t\t}\n\t\telse{\n\t\t\tdeg[rig[a]]++;\n\t\t\tv[rig[a]].push_back(i);\n\t\t\tk = rig[a];\n\t\t\tava[rig[a]] = true;\n\t\t}\n\t\tif (d){\n\t\t\tdeg[rig[d]]--;\n\t\t\tmerge(k, rig[d]);\n\t\t\tava[rig[d]] = true;\n\t\t}\n\t\telse{\n\t\t\tdeg[lef[b]]--;\n\t\t\tv[lef[b]].push_back(i);\n\t\t\tmerge(k, lef[b]);\n\t\t\tava[lef[b]] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAXX; i++){\n\t\tif(ava[i])mp[root(i)].push_back(i);\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); it++){\n\t\tif (check((*it).second) == false){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nconst int maxnode=200000+5;\nconst int maxedge=1000000+5;\nconst int oo=1000000000;\n\nint node,src,dest,nedge;\nint head[maxnode],point[maxedge],nextp[maxedge],flow[maxedge],capa[maxedge];\nint distp[maxnode],Q[maxnode],work[maxnode];\n\nvoid init(int _node,int _src,int _dest)\n{\n\tnode=_node;\n\tsrc=_src;\n\tdest=_dest;\n\tfor (int i=0;i<node;i++) head[i]=-1;\n\tnedge=0;\n}\nvoid addedge(int u,int v,int c1,int c2)\n{\n\tif (c1==0 && c2==0) return;\n\t//printf(\"%d %d %d %d\\n\",u,v,c1,c2);\n\tpoint[nedge]=v,capa[nedge]=c1,flow[nedge]=0,nextp[nedge]=head[u],head[u]=(nedge++);\n\tpoint[nedge]=u,capa[nedge]=c2,flow[nedge]=0,nextp[nedge]=head[v],head[v]=(nedge++);\n}\nbool dinic_bfs()\n{\n\tfor (int i=0;i<node;i++) distp[i]=-1;\n\tdistp[src]=0;\n\tint sizeQ=0;\n\tQ[sizeQ++]=src;\n\tfor (int cl=0;cl<sizeQ;cl++)\n\t\tfor (int k=Q[cl],i=head[k];i>=0;i=nextp[i])\n\t\t\tif (flow[i]<capa[i] && distp[point[i]]<0)\n\t\t\t{\n\t\t\t\tdistp[point[i]]=distp[k]+1;\n\t\t\t\tQ[sizeQ++]=point[i];\n\t\t\t}\n\treturn distp[dest]>=0;\n}\nint dinic_dfs(int x,int exp)\n{\n\tif (x==dest) return exp;\n\tint res=0;\n\tfor (int &i=work[x];i>=0;i=nextp[i])\n\t{\n\t\tint v=point[i],tmp;\n\t\tif (flow[i]<capa[i] && distp[v]==distp[x]+1 && (tmp=dinic_dfs(v,min(exp,capa[i]-flow[i])))>0)\n\t\t{\n\t\t\tflow[i]+=tmp;\n\t\t\tflow[i^1]-=tmp;\n\t\t\tres+=tmp;\n\t\t\texp-=tmp;\n\t\t\tif (exp==0) break;\n\t\t}\n\t}\n\treturn res;\n}\nint dinic_flow()\n{\n\tint result=0;\n\twhile (dinic_bfs())\n\t{\n\t\tfor (int i=0;i<node;i++) work[i]=head[i];\n\t\tresult+=dinic_dfs(src,oo);\n\t}\n\treturn result;\n}\n\nvoid add2(int s,int t,int c0,int c1)\n{\n\t//printf(\"%d %d %d %d\\n\",s,t,c0,c1);\n\tif (c0>0)\n\t{\n\t\taddedge(src,t,c0,0);\n\t\taddedge(s,dest,c0,0);\n\t}\n\tif (c1>c0)\n\t\taddedge(s,t,c1-c0,0);\n}\n\nconst int maxsize=1024;\n\nvector<int> g[maxsize];\nbool v[maxsize];\n\nvoid dfs(int p)\n{\n\tif (v[p]) return;\n\tv[p]=true;\n\tfor (int x:g[p]) dfs(x);\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint n,h;\n\twhile (cin>>n>>h && n>0)\n\t{\n\t\th+=2;\n\t\tint es=h+h;\n\t\tint et=h+h+1;\n\t\tinit(h+h+4,h+h+2,h+h+3);\n\t\tREP(i,h)\n\t\t{\n\t\t\tadd2(es,i+h,0,100000000);\n\t\t\tadd2(i,et,0,100000000);\n\t\t}\n\t\tvector<ipair> edges;\n\t\tREP(i,n)\n\t\t{\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tint s=((c==0)?(a+h):c);\n\t\t\tint t=((d==0)?b:(d+h));\n\t\t\tadd2(s,t,1,1);\n\t\t\tedges.emplace_back(s,t);\n\t\t}\n\t\tbool ok=true;\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.first].push_back(e.second);\n\t\tFOR(i,h,h+h) dfs(i);\n\t\tfor (auto e:edges) if (!v[e.first]) ok=false;\n\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.second].push_back(e.first);\n\t\tREP(i,h) dfs(i);\n\t\tfor (auto e:edges) if (!v[e.second]) ok=false;\n\n\t\tif (ok)\n\t\t{\n\t\t\taddedge(et,es,100000000,0);\n\t\t\tdinic_flow();\n\t\t\tfor (int p=head[src];p>=0;p=nextp[p]) \n\t\t\t\tif (flow[p]!=capa[p]) \n\t\t\t\t\tok=false;\n\t\t}\n\t\tif (ok)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[50000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tint t,s;\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t\tt = j;\n\t\t\t\t\tif (t = l);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (t = l);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t = l);\n\t\t\tbreak;\n\t\t}\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]&&c[j][4]==0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t\ts = j;\n\t\t\t\t\tif (s = l)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (s = l)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s = l)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t\tif (n != 0)\n\t\t\tbreak;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define MP make_pair\n#define MT make_tuple\n#define EACH(i,c) for(auto i: c)\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, H;\n\tcin >> N >> H;\n\n\tmap<int, int> lA, lC, rB, rD, lArD, rBlC;\n\tint x = 0, y = 0;\n\tREP(i, N){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif(c == 0){\n\t\t\tlA[a]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\tlC[c]++;\n\t\t\ty++;\n\t\t}\n\t\tif(d == 0){\n\t\t\trB[b]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\trD[d]++;\n\t\t\ty++;\n\t\t}\n\n\t\tif(c == 0 && a == d) lArD[a]++;\n\t\tif(d == 0 && b == c) rBlC[b]++;\n\t}\n\n\tif(y + 2 > x){\n\t\tcerr << x << \" \" << y << endl;\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\n\tEACH(pc, lC){\n\t\trB[pc.first] -= pc.second;\n\t\tif(rB[pc.first] < 0){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEACH(pd, rD){\n\t\tlA[pd.first] -= pd.second;\n\t\tif(lA[pd.first] < 0){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\tcout << \"YES\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,k,n) for(ll i= (ll) k;i< (ll) n;i++)\n#define all(v) (v).begin(), (v).end()\n#define SZ(v) (int)((v).size())\n#define pb push_back\n#define ft first\n#define sd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst long long INF = 4e18L + 1;\nconst int IINF = 2e9 + 1;\n\nusing namespace std;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define DBG(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define DBG(...) ;\n#define cerr if(0)cout\n#endif\n\nconst int N = 1e5, H = 200;\n\nint bl[H + 1], br[H + 1], tl[H + 1], tr[H + 1];\nint n, h;\nint sbl = 0, stl = 0, sbr = 0, str = 0;\n\nint main()\n{\n#ifndef LOCAL\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#endif\n    cin >> n >> h;\n    rep(i, 0, n){\n        int a, b, c, d; cin >> a >> b >> c >> d;\n        if(c == 0){\n            bl[a]++;\n            sbl++;\n        } else {\n            tl[c]++;\n            stl++;\n        }\n        if(d == 0){\n            br[b]++;\n            sbr++;\n        } else {\n            tr[d]++;\n            str++;\n        }\n    }\n    if(sbl < str + 1 or sbr < stl + 1){    \n        cout << \"NO\\n\";\n        return 0;\n    }\n    rep(i, 1, h + 1){\n        if(bl[i] < tr[i] or br[i] < tl[i]){\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,h,a[100005],b[100005],c[100005],d[100005],in[405],ou[405],u[405],cnt;\nvector<int> v[405];\nbool ok=1;\nbool dfs(int x){\n    bool ok=0;\n    if(u[x]) return 0;\n    u[x]=1;\n    if(in[x]!=ou[x])ok=1;\n    for(int i=0;i<v[x].size();++i)ok|=dfs(v[x][i]);\n    return ok;\n}\nint main(){\n    scanf(\"%d%d\",&n,&h);\n    for(int i=1;i<=n;++i){\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        int x=c[i]?200+c[i]:a[i];\n        int y=d[i]?d[i]:200+b[i];\n        v[x].pb(y);\n        v[y].pb(x);\n        ++ou[x],++in[y];\n    }\n    bool ok=1;\n    for(int i=1;i<=200;++i)if(ou[i]<in[i])ok=0;\n    for(int i=201;i<=400;++i)if(in[i]<ou[i])ok=0;\n    if(!ok){\n        puts(\"NO\");\n        return 0;\n    }\n    for(int i=1;i<=400;++i){\n        if(!u[i]&&(in[i]||ou[i])){\n            if(!dfs(i)){\n                puts(\"NO\");\n                return 0;\n            }\n        }\n    }\n    puts(\"YES\");\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\n\nint main(){\n    int n,h;\n    cin >> n >> h;\n    vector<int> p(2*h+1);\n    vector<vector<int> > g(2*h+1);\n    UnionFind uf(2*h+1);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        int x,y;\n        if(c==0){\n            x = a;\n        }else{\n            x = h+c;\n        }\n        if(d==0){\n            y = h + b;\n        }else{\n            y = d;\n        }\n        p[x]++;\n        p[y]--;\n        g[x].push_back(y);\n        uf.unite(x,y);\n    }\n    vector<int> s(2*h+1);\n    rep(i,2*h+1){\n        if(i<=h)s[uf.find(i)] += p[i];\n    }\n    rep(i,2*h+1){\n        if(i<=h){\n            if(p[i]<0){\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }else{\n            if(p[i]>0){\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n    }\n    bool flag = 1;\n    rep(i,2*h+1){\n        if(g[i].size()>0){\n            if(s[uf.find(i)]<=0){\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"YES\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nvector<int> g[401];\nint in[401], out[401];\nbool vis[401];\n\nbool go(int v){\n\tif (g[v].empty())return true;\n\tvis[v] = true;\n\tbool ok = in[v] != out[v];\n\tf(i, 0, g[v].size())if (!vis[g[v][i]])ok |= go(g[v][i]);\n\treturn ok;\n}\n\nint main(){\n\tint n, h;\n\tscanf(\"%d%d\", &n, &h);\n\tf(i, 0, n){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x, y;\n\t\tif (c == 0)x = a; else x = c + 200;\n\t\tif (d == 0)y = b + 200; else y = d;\n\t\t++in[y];\n\t\t++out[x];\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tbool ok = true;\n\tf(i, 0, h + 1)if (in[i] > out[i])ok = false;\n\tf(i, 200, h + 201)if (out[i] > in[i])ok = false;\n\tf(i, 0, h << 1 | 1)if (!vis[i])ok &= go(i);\n\tprintf(\"%s\\n\", ok ? \"YES\" : \"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=100010;\nconst int maxm=410;\nint n,m,u[maxn],v[maxn];\nint pa[maxm],in[maxm],out[maxm],yes[maxm];\nint findset(int x) {return x==pa[x]?x:pa[x]=findset(pa[x]);}\nint main() {\n\tn=read();m=read();\n\trep(i,1,n) {\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint p,q;\n\t\tif(!c) p=a;\n\t\telse p=-c;\n\t\tif(!d) q=-b;\n\t\telse q=d;\n\t\tp+=m;q+=m;\n\t\tin[q]++;out[p]++;\n\t\tu[i]=p;v[i]=q;\n\t}\n\tint ok=1;\n\trep(i,0,2*m) {\n\t\tif(i<m&&in[i]<out[i]) ok=0;\n\t\tif(i>m&&in[i]>out[i]) ok=0;\n\t}\n\trep(i,1,n) pa[findset(u[i])]=findset(v[i]);\n\trep(i,0,2*m) if(in[i]!=out[i]) yes[findset(i)]++;\n\trep(i,0,2*m) if(i==findset(i)&&(!yes[i])) ok=0;\n\tputs(ok?\"YES\":\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=100100,M=440;\nint i,j,k,n,m,h,a,b,c,d,ch,ff;\nint degree[M],f[M],fg[M],z[N];\nstruct cc { int x,y;} A[N];\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nint getf(int x) {\n\tif (f[x]==x) return x;\n\treturn f[x]=getf(f[x]);\n}\nint main() {\n\tR(n);R(h);\n\tm=h+h;\n\tfor (i=1;i<=n;i++) {\n\t\tR(a);R(b);R(c);R(d);\n\t\tint x,y;\n\t\tif (c) x=n+c;\n\t\telse x=a;\n\t\tif (d) y=d;\n\t\telse y=n+b;\n\t\tA[i].x=x;A[i].y=y;\n\t\tdegree[x]++;\n\t\tdegree[y]--;\n\t\tz[x]=z[y]=1;\n\t}\n\tfor (i=1;i<=h;i++) if (degree[i]<0 || degree[n+i]>0) return puts(\"NO\"),0;\n\tfor (i=1;i<=m;i++) if (degree[i]) fg[i]=1,f[i]=i;\n\tfor (i=1;i<=n;i++) {\n\t\tint x=A[i].x,y=A[i].y;\n\t\tif (getf(x)!=getf(y)) {\n\t\t\tfg[f[y]]|=fg[f[x]];\n\t\t\tf[f[x]]=f[y];\n\t\t}\n\t}\n\tfor (i=1;i<=m;i++) if (z[i] && !fg[getf(i)]) return puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = (int)(a); i < (int)(n); ++i)\n#define ford(i, a, n) for (int i = (int)(n - 1); i >= (int)(a); --i)\n#define fore(i, a, n) for (int i = (int)(a); i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n    for (auto i : a) cerr << i << ' ';\\\n    cerr << '\\n'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\ntemplate<typename T>\ninline void setmax(T& a, T b) {\n    if (a < b) a = b;\n}\n\ntemplate<typename T>\ninline void setmin(T& a, T b) {\n    if (a > b) a = b;\n}\n\nconst ld eps = 1e-9;\nconst int INF = 2000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nconst int H = 222;\nvector<int> e[2 * H];\nint indeg[2 * H], outdeg[2 * H];\nint sum[2 * H];\n\nvoid fail() {\n    cout << \"NO\\n\";\n    exit(0);\n}\n\nint par[2 * H];\n\nint get (int u) {\n    if (par[u] == u) return u;\n    return par[u] = get(par[u]);\n}\n\nvoid unite(int u, int v) {\n    u = get(u), v = get(v);\n    if (u != v) par[u] = v;\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    forn(i, 0, 2 * H) par[i] = i;\n    int n, h;\n    cin >> n >> h;\n    forn(i, 0, n) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int from, to;\n        if (c == 0)\n            from = a;\n        else\n            from = c + H;\n\n        if (d == 0)\n            to = b + H;\n        else\n            to = d;\n\n        e[from].eb(to);\n        ++indeg[to];\n        ++outdeg[from];\n        unite(from, to);\n        //cerr << from << ' ' << to << '\\n';\n\n    };\n    /*forn(i, 0, 2 * H) {\n        if (indeg[i] || outdeg[i]) {\n            cout << i << ' ' << indeg[i] << ' ' << outdeg[i] << '\\n';\n        }\n    }*/\n    forn(i, 0, H) {\n        int j = get(i);\n        sum[j] += outdeg[i] - indeg[i];\n        j = get(i + H);\n        sum[j] += indeg[i + H] - outdeg[i + H];\n    }\n    forn(i, 0, H) {\n        if (indeg[i] > outdeg[i])\n            fail();\n        if (indeg[i + H] < outdeg[i + H])\n            fail();\n    }\n    forn(i, 0, 2 * H) {\n        if (indeg[i] || outdeg[i]) {\n            int j = get(i);\n            //cerr << j << ' ' << sum[j] << '\\n';\n            if (sum[j] <= 0) fail();\n        }\n    }\n    cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <string>\n# include <algorithm>\n# include <vector>\n# include <cstring>\n# include <stdio.h>\n# include <map>\n# include <queue>\n\n# define ll long long\n# define pii pair<int,int>\n# define FOR(a,b) for(int a=1; a<=b; a++)\n# define REP(a,b) for(int a=0; a<b; a++)\n# define FORU(a,b,c) for(int a=b; a<=c; a++)\n# define FORD(a,b,c) for(int a=b; a>=c; a--)\n\nusing namespace std;\n\nbool flag[505];\nint N, H, par[505], indeg[505], outdeg[505], ccsize[505];\n\nint findpar(int x){\n    return x == par[x] ? x : par[x] = findpar(par[x]);\n}\n\nvoid merge(int u,int v){\n    u = findpar(u);\n    v = findpar(v);\n\n    ccsize[v]++;\n    if(u != v){\n        ccsize[v] += ccsize[u];\n        par[u] = v;\n    }\n}\n\nint main(){\n\n    ios :: sync_with_stdio(false);\n    cin >> N >> H;\n    REP(i,2*H+1) par[i] = i;\n\n    FOR(i,N){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        int u = c ? -c : a;\n        int v = d ? d : -b;\n\n        u += H;\n        v += H;\n\n        outdeg[u]++;\n        indeg[v]++;\n        merge(u, v);\n    }\n\n    bool ok = 1;\n    REP(i,2*H+1){\n        if(i<H && indeg[i] < outdeg[i]) ok = 0;\n        if(i>H && indeg[i] > outdeg[i]) ok = 0;\n        if(indeg[i] != outdeg[i]) flag[findpar(i)] = 1;\n    }\n\n    REP(i,2*H+1){\n        if(ccsize[i]>0 && !flag[findpar(i)]) ok = 0;\n    }\n\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n   #define PP pair<int,pair<int,int>>\nconst int MAX = 510000;\nconst int MOD =  998244353;\nconst int INV2 = (MOD+1)/2;\n\n\n     signed main(){\n\n        int n,h;\n        map<int,int> mp[2];\n        cin>>n>>h;\n        int a,b,c,d;\n        for(int i=0;i<n;i++){\n          cin>>a>>b>>c>>d;\n          if(c==0)mp[0][a]++;\n          else mp[1][c]++;\n          if(d==0)mp[1][b]--;\n          else mp[0][d]--;\n        }\n        bool x=false;\n        for(auto i=mp[0].begin();i!=mp[0].end();i++){\n         //// cerr<<(i->second)<<' '<<(i->first)<<endl;\n          if(i->second==1)x=true;\n          if(i->second==0||i->second==1)continue;\n         \n          \n          cout<<\"NO\"<<endl;\n          return 0;\n        }\n        for(auto i=mp[1].begin();i!=mp[1].end();i++){\n         // cerr<<(i->second)<<endl;\n          if(i->second==-1)x=true;\n\n          if(i->second==0||i->second==-1)continue;\n         \n           \n          cout<<\"NO\"<<endl;\n          return 0;\n        }\n\n       if(x) cout<<\"YES\"<<endl;\n       else cout<<\"NO\"<<endl;\n        return 0;\n\n \n\n\n\n\n}\n\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 500;\n\nint n, H, i, x, y, A, B, C, D, grad[Nmax];\nbool ok, used[Nmax];\nvector<int> v[Nmax];\n\nvoid dfs(int node)\n{\n    used[node] = 1;\n    ok |= (grad[node] != 0);\n    for(auto it : v[node])\n        if(!used[it]) dfs(it);\n}\n\nint main()\n{\n   // freopen(\"input\", \"r\", stdin);\n\n    cin >> n >> H;\n    for(i=1; i<=n; ++i)\n    {\n        cin >> A >> B >> C >> D;\n        x = (C ? C : A + H);\n        y = (D ? D + H : B);\n\n        v[x].push_back(y);\n        v[y].push_back(x);\n        ++grad[x]; --grad[y];\n    }\n\n    ok = 1;\n    for(i=1; i<=H && ok; ++i) ok &= (grad[i] <= 0);\n    for(; i<= 2*H && ok; ++i) ok &= (grad[i] >= 0);\n\n    for(i=1; i <= 2 * H && ok; ++i)\n        if(!used[i] && v[i].size())\n        {\n            ok = 0;\n            dfs(i);\n        }\n\n    cout << (ok ? \"YES\" : \"NO\") << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:64777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <stdio.h>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <cassert>\n#include <complex>\n#include <time.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long Int;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\n\nconst int MAX = 512;\nconst int CNT = 17;\n\nint n, h, c0, c1, bal, e;\nVI G[MAX];\nVI GG[MAX];\nint D[MAX];\nint U[MAX];\n\nint getNext(int a, int b)\n{\n\treturn (a == 0 ? b : h + a);\n}\n\nint getPrev(int a, int b)\n{\n\treturn (a == 0 ? h + b : a);\n}\n\nvoid nope()\n{\n\tcout << \"NO\" << endl;\n\texit(0);\n}\n\nvoid dfs(int v)\n{\n\tU[v] = 1;\n\tif (v < h)\n\t{\n\t\t++ c0;\n\t\tbal -= D[v];\n\t}\n\tif (v >= h)\n\t\t++ c1;\n\n\tFOR (i,0,SZ(GG[v]))\n\t{\n\t\tint to = GG[v][i];\n\t\tif (U[to] == 0)\n\t\t\tdfs(to);\n\t\t++ e;\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\tcin >> n >> h;\n\t++ h;\n\n\tFOR (i,0,n)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tint u = getPrev(c, a);\n\t\tint v = getNext(d, b);\n\t\tG[u].PB(v);\n\t\tGG[u].PB(v);\n\t\tGG[v].PB(u);\n\t\t++ D[u];\n\t\t-- D[v];\n\t}\n\n\n\tFOR (i,0,h)\n\t\tif (D[i] > 0)\n\t\t\tnope();\n\n\tFOR (i,h,2*h)\n\t\tif (D[i] < 0)\n\t\t\tnope();\n\n\tint cnt = 0, alone = 0, bal0 = 0;\n\tFOR (i,0,2*h)\n\t{\n\t\tif (U[i]) continue;\n\t\tc0 = 0, c1 = 0, bal = 0, e = 0;\n\t\tdfs(i);\n\t\tif (e == 0) continue;\n\n\t\t++ cnt;\n\t\tif (c0 == 0 || c1 == 0)\n\t\t\t++ alone;\n\t\tif (bal == 0)\n\t\t\t++ bal0;\n\t}\n\n\tif (alone > 0)\n\t\tnope();\n\n\tif (bal0 >0)\n\t\tnope();\n\n\tif (bal0 == 1 && cnt > 1)\n\t\tnope();\n\n\tcout << \"YES\" << endl;\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n  //freopen(\"/home/alexandero/ClionProjects/ACM/output.txt\", \"w\", stdout);\n  //freopen(\"out.txt\", \"w\", stdout);\n#else\n  //freopen(\"input.txt\", \"r\", stdin);\n  //freopen(\"output.txt\", \"w\", stdout);\n#endif\n  start = clock();\n  int t = 1;\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n  precalc();\n  cout.precision(10);\n  cout << fixed;\n  //cin >> t;\n  int testNum = 1;\n  while (t--) {\n    //cout << \"Case #\" << testNum++ << \": \";\n    //cerr << testNum << endl;\n    solve(true);\n    //cerr << testNum - 1 << endl;\n  }\n  cout.flush();\n#ifdef AIM1\n  while (true) {\n      solve(false);\n  }\n#endif\n\n#ifdef AIM\n  cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\n//#define int li\n//const int mod = 1000000007;\n\nvoid solve(bool read) {\n  int n, H;\n  cin >> n >> H;\n  map<int, int> first_edges, second_edges;\n  set<int> first_bad, second_bad;\n  for (int i = 0; i < n; ++i) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if (d == 0) {\n      ++first_edges[b];\n      if (c == b) {\n        first_bad.insert(b);\n      }\n    } else {\n      ++second_edges[d];\n      if (c == 0 && a == d) {\n        second_bad.insert(d);\n      }\n    }\n    if (c == 0) {\n      --second_edges[a];\n    } else {\n      --first_edges[c];\n    }\n  }\n\n  //cout << \"bad: \" << bad_squares << endl;\n  int cnt = 0;\n  for (auto item : first_edges) {\n    int cur = -item.second;\n    if (first_bad.count(item.first)) {\n      ++cur;\n    }\n    cnt += max(0, cur);\n    //cout << \"first \" << item.first << \" \" << item.second << endl;\n  }\n  for (auto item : second_edges) {\n    int cur = item.second;\n    if (second_bad.count(item.first)) {\n      ++cur;\n    }\n    cnt += max(0, cur);\n    //cout << \"second \" << item.first << \" \" << item.second << endl;\n  }\n\n  //cout << bad_squares << endl;\n\n  if (cnt <= 0) {\n    cout << \"YES\\n\";\n  } else {\n    cout << \"NO\\n\";\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst int UnionFindTree_MAX_V = 100000;\nstruct UnionFindTree{\n\tint par[UnionFindTree_MAX_V+10],r[UnionFindTree_MAX_V+10];\n\tvoid init(int n = UnionFindTree_MAX_V){\n\t\tfor(int i = 0 ; i < n+10 ; i ++){\n\t\t\tpar[i] = i;\n\t\t\tr[i] = 0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unit(int x,int y){\n\t\tif(same(x,y))return;\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(r[x] < r[y]){\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(r[x] == r[y]){\n\t\t\t\tr[x] ++;\n\t\t\t}\n\t\t}\n\t}\n}uf;\n\nint main(){\n\tstatic int n,h;\n\tstatic int a[100010],b[100010],c[100010],d[100010];\n\tscanf(\"%d%d\",&n,&h);\n\trep1(i,n)scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t\n\tstatic int e[100010],f[100010];\n\trep1(i,n){\n\t\tif(c[i] == 0)e[i] = h+a[i];\n\t\telse e[i] = h-c[i];\n\t\tif(d[i] == 0)f[i] = h+b[i];\n\t\telse f[i] = h-d[i];\n\t}\n\tuf.init();\n\tstatic int cnt[2][402] = {};\n\trep1(i,n){\n\t\tcnt[0][e[i]] ++;\n\t\tcnt[1][f[i]] --;\n\t\tuf.unit(e[i],f[i]+500);\n\t}\n\trep(i,h){\n\t\tif(cnt[0][i] > 0){\n\t\t\tcnt[1][2*h-i] += cnt[0][i];\n\t\t\tcnt[0][i] = 0;\n\t\t\tuf.unit(i,2*h-i+500);\n\t\t}\n\t}\n\trep(i,h){\n\t\tif(cnt[1][i] < 0){\n\t\t\tcnt[0][2*h-i] += cnt[1][i];\n\t\t\tcnt[1][i] = 0;\n\t\t\tuf.unit(2*h-i,i+500);\n\t\t}\n\t}\n\t\n\tstatic int siz[1002] = {},CNT[1002] = {};\n\trep(i,1002){\n\t\tsiz[uf.find(i)] ++;\n\t\tif(h < i && i <= 2*h)CNT[uf.find(i)] += cnt[0][i];\n\t}\n\trep(i,1002){\n\t\tif(siz[i] > 1 && CNT[i] <= 0){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\ntypedef struct{\n  int to;\n  int cap;\n  int rev;\n}edge;\n\n// node v : distance from s => level[v]\nvoid bfs(vector<vector<edge> > &G, vector<int> &level, int s){\n  fill(level.begin(), level.end(), -1);\n  queue<int> q;\n  q.push(s);\n  level[s] = 0;\n  while(!q.empty()){\n    int e=q.front(); q.pop();\n    for(int i=0; i<G[e].size(); i++){\n      if(G[e][i].cap > 0 && level[G[e][i].to] < 0){\n        level[G[e][i].to] = level[e] + 1;\n        q.push(G[e][i].to);\n      }\n    }\n  }\n}\n\nint dfs(vector<vector<edge> > &G, vector<int> &level, vector<bool> &used, vector<int> &iter, int s, int f,  int t){\n  if(s==t) return f;\n  else{\n    //iter[e] : done searching from v[0] to v[ iter[e]-1 ]\n    for(int &i=iter[s]; i<G[s].size(); i++){\n      //distance from s to v[e][i].to must be longer than dist from s to v\n      if(G[s][i].cap > 0 && level[s] < level[ G[s][i].to ]){\n        int d = dfs(G, level, used, iter, G[s][i].to, min(f, G[s][i].cap), t);\n        if(d>0){\n          G[s][i].cap -= d;\n          G[ G[s][i].to ][ G[s][i].rev ].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n}\n\nint dinic_maxflow(vector<vector<edge> > &G, int s, int t){\n  const int INF = 100000000;\n  int flow=0;\n  while(true){\n    vector<int> level(G.size(), -1);\n    vector<int> iter(G.size(), 0);\n    vector<bool> used(G.size(), false);\n    bfs(G, level, s);\n    if(level[t] < 0) return flow; //unable to achieve to t\n    while(true){\n      int f = dfs(G, level, used, iter, s, INF, t);\n      if(f==0) break;\n      else flow += f;\n    }\n  }\n}\n\nvoid add_edge(vector<vector<edge> > &G, int from, int to, int cap){\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint main(){\n  int n,h;\n  cin >> n,h;\n  vector<int> a(n),b(n),c(n),d(n);\n  for(int i=0; i<n; i++){\n    cin >> a[i],b[i],c[i],d[i];\n  }\n\n  map<pair<int,int>, int> in_cnt;\n  map<pair<int,int>, int> out_cnt;\n  for(int i=0; i<n; i++){\n    if( c[i] == 0 ){\n      in_cnt[ {a[i], 0} ]++;\n    }else{\n      in_cnt[ {c[i], 1} ]++;\n    }\n    if( d[i] == 0 ){\n      out_cnt[ {b[i], 0} ]++;\n    }else{\n      out_cnt[ {d[i], 1} ]++;\n    }\n  }\n\n  map<tuple<int,int,int>, int> dict;\n  int idx = 0;\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n\n  int zero_0 = idx++;\n  int zero_1 = idx++;\n  int source = idx++;\n  int sink = idx++;\n\n  int super_source = idx++;\n  int super_sink = idx++;\n\n  vector<vector<edge>> G(idx);\n\n  add_edge(G, zero_0, zero_1, n+10);\n  add_edge(G, super_source, zero_1, 1);\n  add_edge(G, zero_0, super_sink, 1);\n\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, v, sink, p.second);\n    if( p.first.second == 0 ){\n      add_edge(G, zero_1, v, p.second);\n    }\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, source, v, p.second);\n    auto r = make_tuple(0, p.first.first, p.first.second^1);\n    if( dict.count(r) ){\n      add_edge(G, v, dict[r], p.second);\n    }\n\n    if( p.first.second == 0 ){\n      add_edge(G, v, zero_0, p.second);\n    }\n  }\n\n  int f = 0;\n  f += dinic_maxflow(G, super_source, sink);\n  f += dinic_maxflow(G, source, super_sink);\n  if( f != 2 ){\n    println(\"NO\");\n    return 0;\n  }\n  f--;\n\n  add_edge(G, super_source, source, n+100);\n  add_edge(G, sink, super_sink, n+100);\n\n  f += dinic_maxflow(G, super_source, super_sink);\n\n  if( f != n ) abort();\n  println( f>=n ? \"YES\" : \"NO\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nconst int maxnode=2000000+16;\n\nvector<int> g[maxnode];\nbool v[maxnode];\nint d[maxnode];\n\nvoid dfs(int p)\n{\n\tif (v[p]) return;\n\tv[p]=true;\n\tfor (int x:g[p]) dfs(x);\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint n,h;\n\twhile (cin>>n>>h)\n\t{\n\t\th+=2;\n\t\tvector<ipair> edges;\n\t\tREP(i,n)\n\t\t{\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tint s=((c==0)?(a+h):c);\n\t\t\tint t=((d==0)?b:(d+h));\n\t\t\tedges.emplace_back(s,t);\n\t\t}\n\t\tbool ok=true;\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.first].push_back(e.second);\n\t\tFOR(i,h,h+h) dfs(i);\n\t\tfor (auto e:edges) if (!v[e.first]) ok=false;\n\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.second].push_back(e.first);\n\t\tREP(i,h) dfs(i);\n\t\tfor (auto e:edges) if (!v[e.second]) ok=false;\n\n\t\tREP(i,h+h) d[i]=0;\n\t\tfor (auto e:edges) ++d[e.first],--d[e.second];\n\t\tREP(i,h) if (d[i]>0) ok=false;\n\t\tFOR(i,h,h+h) if (d[i]<0) ok=false;\n\n\t\tif (ok)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\tfflush(stdout);\n#ifndef _MSC_VER\n\t\tbreak;\n#endif\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> emp[2][205],bmp[2][205];\nbool vis[100005];\nint a[100005],c[100005],d[100005],b[100005];\nint n,h;\n\nbool fillb(int i)\n{\n    vis[i] = true;\n    if(c[i]==0)\n    {\n        for(int j=0;j<bmp[1][a[i]].size();++j){\n            if(vis[bmp[1][a[i]][j]]) continue;\n            fillb(bmp[1][a[i]][j]);\n        }\n        return true;\n    }else{\n        for(int j=0;j<bmp[0][c[i]].size();++j)\n        {\n            if(vis[bmp[0][c[i]][j]]) continue;\n            return fillb(bmp[0][c[i]][j]);\n        }\n        vis[i]=false;\n        return false;\n    }\n}\n\nbool fille(int i)\n{\n    vis[i] = true;\n    if(d[i]==0)\n    {\n        for(int j=0;j<emp[1][b[i]].size();++j)\n        {\n\n            if(vis[emp[1][b[i]][j]]) continue;\n            fille(emp[1][b[i]][j]);\n        }\n        return true;\n    }else\n    {\n        for(int j=0;j<emp[0][d[i]].size();++j)\n        {\n            if(vis[emp[0][d[i]][j]])continue;\n            return fille(emp[0][d[i]][j]);\n        }\n        vis[i] = false;\n        return false;\n    }\n}\n\nint main()\n{\n    //freopen(\"C://Code//input.txt\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        if(c[i]==0)\n        {\n            emp[0][a[i]].push_back(i);\n        }else emp[1][c[i]].push_back(i);\n        if(d[i]==0) bmp[0][b[i]].push_back(i);\n        else bmp[1][d[i]].push_back(i);\n    }\n    bool ag = true;\n    for(int i=0;i<n;++i)\n    {\n        if(vis[i]||(c[i]==0&&d[i]==0)) continue;\n        if((!fillb(i))||(!fille(i)))\n        {\n            ag= false;break;\n        }\n    }\n    if(ag) printf(\"YES\");\n    else printf(\"NO\");\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int> g[505];\nint l_cnt[505], r_cnt[505];\nbool used[505];\n\nint print(bool ok) {\n        if (ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n}\n\nbool dfs(int v) {\n        if (g[v].empty()) return true;\n        used[v] = true;\n        bool res = l_cnt[v] != r_cnt[v];\n        for (auto u : g[v]) if (!used[u]) res |= dfs(u); //パーツが足りる？\n        return res;\n}\n\nint main() {\n        int n, h, a, b, c, d;\n        cin >> n >> h;\n        for (int i = 0; i < n; i ++) {\n                cin >> a >> b >> c >> d;\n                int lh = (c == 0 ? a : c + 250);\n                int rh = (d == 0 ? b + 250 : d);\n                l_cnt[lh] ++;\n                r_cnt[rh] ++;\n                g[lh].push_back(rh);\n                g[rh].push_back(lh);\n//cerr << lh << ' ' << rh << endl;\n        }\n        for (int i = 0; i < h + 1; i ++) if (r_cnt[i] > l_cnt[i]) return print(0);\n        for (int i = 251; i < 501 + h; i ++) if (l_cnt[i] > r_cnt[i]) return print(0);\n        for (int i = 0; i < 501; i ++) if (!used[i]) if (!dfs(i)) return print(0);\n        return print(1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define FORD(i,b,a) for (int i = (int)(b) - 1; i >= a; --i)\n#define REP(i,N) FOR(i,0,N)\n#define st first\n#define nd second\n#define pb push_back\n\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\nint L[205], R[205];\n\nint main() {\n  int N, H;\n  scanf(\"%d%d\", &N, &H);\n  REP(i,N) {\n    int A, B, C, D;\n    scanf(\"%d%d%d%d\", &A, &B, &C, &D);\n    if (C == 0) ++R[A]; else --L[C];\n    if (D == 0) ++L[B]; else --R[D];\n  }\n  bool ok = true;\n  int lsu = 0, rsu = 0;\n  REP(i,H+1) {\n    if (L[i] < 0 || R[i] < 0) ok = false;\n    lsu += L[i], rsu += R[i];\n  }\n  ok = (ok && lsu > 0 && rsu > 0);\n  printf(ok ? \"YES\\n\" : \"NO\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(a) for(int k=head[a];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ll,ll> pa;\nconst int N=1e6+5,M=5e3+5,INF=1e9,mod=998244353;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nint fa[N],n,h,ind[N],outd[N],ext[N],sta[N];;\nint getf(int x){return fa[x]==x?x:fa[x]=getf(fa[x]);}\nvoid die(){puts(\"NO\");exit(0);}\nint main(){\n\tread(n,h);rep(i,1,h+h)fa[i]=i;\n\trep(i,1,n){int A,B,C,D;\n\t\tread(A,B);read(C,D);\n\t\tif(C)A=C+h;if(D)B=D;else B+=h;\n\t\tind[B]++;outd[A]++;fa[getf(A)]=getf(B);ext[getf(A)]=1;\n\t}\n\trep(i,1,h)if(outd[i]<ind[i])die();\n\trep(i,1,h)if(outd[i+h]>ind[i+h])die();\n\trep(i,1,h)if(outd[i]>ind[i])sta[getf(i)]=1;\n\trep(i,1,h+h)if(getf(i)==i&&!sta[i]&&ext[i])die();\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nint n,h;\nint l[220],r[220],bns;\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0)l[a]++,bns++;\n\t\telse r[c]--,bns--;\n\t\tif(d==0)r[b]++,bns++;\n\t\telse l[d]--,bns--;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=200;i++){\n\t\tans+=l[i];\n\t\tans+=r[i];\n\t\tif(l[i]<0||r[i]<0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(bns<=0||ans!=bns){\n\t\tprintf(\"NO\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> emp[2][205],bmp[2][205];\nbool vis[100005];\nint a[100005],c[100005],d[100005],b[100005];\nint n,h;\n\nbool fillb(int i)\n{\n    vis[i] = true;\n    if(c[i]==0)\n    {\n        for(int j=0;j<bmp[1][a[i]].size();++j){\n            if(vis[bmp[1][a[i]][j]]) continue;\n            if(fillb(bmp[1][a[i]][j])) return true;\n        }\n        return true;\n    }else{\n        for(int j=0;j<bmp[0][c[i]].size();++j)\n        {\n            if(vis[bmp[0][c[i]][j]]) continue;\n            return fillb(bmp[0][c[i]][j]);\n        }\n        vis[i]=false;\n        return false;\n    }\n}\n\nbool fille(int i)\n{\n    vis[i] = true;\n    if(d[i]==0)\n    {\n        for(int j=0;j<emp[1][b[i]].size();++j)\n        {\n\n            if(vis[emp[1][b[i]][j]]) continue;\n            if(fille(emp[1][b[i]][j])) return true;\n        }\n        return true;\n    }else\n    {\n        for(int j=0;j<emp[0][d[i]].size();++j)\n        {\n            if(vis[emp[0][d[i]][j]])continue;\n            return fille(emp[0][d[i]][j]);\n        }\n        vis[i] = false;\n        return false;\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        if(c[i]==0)\n        {\n            emp[0][a[i]].push_back(i);\n        }else emp[1][c[i]].push_back(i);\n        if(d[i]==0) bmp[0][b[i]].push_back(i);\n        else bmp[1][d[i]].push_back(i);\n    }\n    bool ag = true;\n    for(int i=0;i<n;++i)\n    {\n        if(vis[i]||(c[i]==0&&d[i]==0)) continue;\n        if((!fillb(i))||(!fille(i)))\n        {\n            ag= false;break;\n        }\n        if(!vis[i]){ag=false;break;}\n    }\n    if(ag) printf(\"YES\");\n    else printf(\"NO\");\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconst int maxn = 100000+7;\n\nint n, h, a, b, c, d;\nint left[maxn], right[maxn];\n\nint main(int argc, char *argv[]) {  \n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0); \n\tstd::fill(left, left+maxn, 0);\n\tstd::fill(right, right+maxn, 0);\n\tstd::cin >> n >> h;\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> a >> b >> c >> d;\n\t\tif (c == 0) {\n\t\t\tleft[a]++;\n\t\t} else {\n\t\t\tright[c]--;\n\t\t}\n\t\tif (d == 0) {\n\t\t\tright[b]++;\n\t\t} else {\n\t\t\tleft[d]--;\n\t\t}\n\t}\n\tbool yes = 1;\n\tint cnt = 0;\n\tfor (int i = 1; i <= h; i++) {\n\t\tif (right[i] < 0 || left[i] < 0) {\n\t\t\tyes = 0;\n\t\t}\n//\t\tstd::cout << left[i] << ' ' << right[i] << '\\n';\n\t\tcnt += left[i];\n\t\tcnt += right[i];\n\t}\n//\tstd::cout << cnt << '\\n';\n\tif (yes && cnt >= 2) {\n\t\tstd::cout << \"YES\\n\";\n\t} else {\n\t\tstd::cout << \"NO\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2000500\nusing namespace std;\nint n,m,fa[N],vis[N],D[N],C[N];\nint gf(int x) {return fa[x]==x?x:fa[x]=gf(fa[x]);}\ninline int rd() {int r;scanf(\"%d\",&r);return r;}\nint main() {\n    n = rd(), m = rd();\n\n    for (int i=1;i<=1000;i++) fa[i] = i;\n    for (int _=1;_<=n;_++)  {\n        int x, y,a,b,c,d;\n        a = rd(), b = rd(), c = rd(), d = rd();\n        x=!c?a:-c; x+=500;\n        y=!d?-b:d; y+=500;\n        fa[ gf(x) ] = gf(y);\n        D[x]++, D[y]--, vis[x] = 1;\n    }\n\n    int flag = 1;\n    for (int i=1;i<500;i++) D[i]>0 ? flag=0 :0;\n    for (int i=501;i<=1000;i++) D[i]<0 ? flag=0 :0;\n    for (int i=1;i<=1000;i++) vis[gf(i)] |= vis[i];\n    for (int i=1;i<=1000;i++) if (D[i]) C[gf(i)] = 1;\n    for (int i=1;i<=1000;i++) if (fa[i]==i && !C[i] && vis[i]) flag = 0;\n    puts(flag?\"YES\":\"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=205,INF=1<<30;\nint cnt[MAX][2];\nbool seen[MAX][2];\n\nstruct UF{\n    int n;\n    vector<int> par,size,u,v;\n    \n    void init(int n_){\n        n=n_;\n        par.assign(n,-1);\n        size.assign(n,1);\n        u.assign(n,0);\n        v.assign(n,0);\n        \n        for(int i=0;i<n;i++){\n            par[i]=i;\n        }\n    }\n    \n    int root(int a){\n        if(par[a]==a) return a;\n        else return par[a]=root(par[a]);\n    }\n    \n    void unite(int a,int b){\n        if(root(a)!=root(b)){\n            size[root(a)]+=size[root(b)];\n            u[root(a)]|=u[root(a)];\n            v[root(a)]|=v[root(a)];\n            par[root(b)]=root(a);\n        }\n    }\n    \n    bool check(int a,int b){\n        return root(a)==root(b);\n    }\n};\n\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,H;cin>>N>>H;\n    UF uf;\n    uf.init(2*H+1);\n    \n    for(int i=0;i<N;i++){\n        int a,b,c,d;cin>>a>>b>>c>>d;\n        \n        if(c==0){\n            cnt[a][0]++;\n            seen[a][0]=1;\n            \n            if(d==0){\n                cnt[b][1]--;\n                seen[b][1]=1;\n                \n                uf.unite(a,H+b);\n            }\n            else{\n                cnt[d][0]--;\n                seen[d][0]=1;\n                \n                uf.unite(a,d);\n            }\n        }else{\n            cnt[c][1]++;\n            seen[c][1]=1;\n            \n            if(d==0){\n                cnt[b][1]--;\n                seen[b][1]=1;\n                \n                uf.unite(H+c,H+b);\n            }\n            else{\n                cnt[d][0]--;\n                seen[d][0]=1;\n                \n                uf.unite(H+c,d);\n            }\n        }\n    }\n    \n    int sum1=0,sum2=0;\n    bool ok=true;\n    \n    set<int> SE;\n    \n    for(int i=0;i<=H;i++){\n        sum1+=cnt[i][0];\n        sum2+=cnt[i][1];\n        \n        if(cnt[i][0]<0) ok=false;\n        else if(seen[i][0]) SE.insert(uf.root(i));\n        if(cnt[i][1]>0) ok=false;\n        else if(seen[i][1]) SE.insert(uf.root(H+i));\n        \n        if(cnt[i][0]>0) uf.u[uf.root(i)]=1;\n        if(cnt[i][1]<0) uf.v[uf.root(H+i)]=1;\n    }\n    \n    for(int a:SE){\n        if(!uf.u[a]) ok=false;\n        if(!uf.v[a]) ok=false;\n    }\n    \n    if(sum1>sum2&&ok) cout<<\"YES\\n\";\n    else cout<<\"NO\\n\";\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[50000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tint t,s;\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t\tt = j;\n\t\t\t\t\tif (t = l)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4] && c[j][4] == 0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t\ts = j;\n\t\t\t\t\tif (s = l)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t\tif (n != 0)\n\t\t\tbreak;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[50000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tint t,s;\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t\tt = j;\n\t\t\t\t\tif (t = l+1)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4] && c[j][4] == 0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t\ts = j;\n\t\t\t\t\tif (s = l+1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t\tif (n != 0)\n\t\t\tbreak;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\n// clang-format off\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\ntemplate < class T > ostream &operator<<(ostream &o, const stack<T> &a) { o << \"{\"; for(auto tmp = a; tmp.size(); tmp.pop()) o << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top(); o << \"}\"; return o; }\ntemplate <class T, class Container, class Compare > ostream &operator<<(ostream &os, priority_queue<T, Container, Compare> a) { os << \"{ (top) \"; while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\ntemplate <class T, class Container > ostream &operator<<(ostream &os, queue<T, Container> a) { os << \"{ \"; while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n#define DEBUG_OUT cerr\n#endif\n#if !defined(DEBUG_LEFT)\n#define DEBUG_LEFT \"\\e[1;36m\"\n#endif\n#if !defined(DEBUG_RIGHT)\n#define DEBUG_RIGHT \":\\e[m\"\n#endif\n#define dump(...) [&](){auto __debug_tap=make_tuple(__VA_ARGS__);DEBUG_OUT<<DEBUG_LEFT<<__LINE__ << DEBUG_RIGHT << \" \" <<#__VA_ARGS__<<\" = \"<<__debug_tap<<endl;}()\ntemplate < class T > inline void dump2D(T &d, size_t sizey, size_t sizex) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << \"\\t\"; for(size_t j = 0; j < sizex; j++) DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\"); DEBUG_OUT << endl; } }\ntemplate < class T > inline void dump1D(T &d, size_t sizey) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \"); } DEBUG_OUT << endl; }\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { o << \"{\"; for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \", \") << *ite; o << \"}\"; return o; }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \" \") << *ite; return o; }\n#endif\n// clang-format on\n// }}}\n\n\n\nconst int H = 220;\nint in[H * 2];\nint out[H * 2];\nint n, h;\nint cnt1[H * 2], cnt2[H * 2];\nint f[H * 2];\n\n#define POS(x) cout<<((x)?\"POSSIBLE\":\"IMPOSSIBLE\")<<endl;\n#define Pos(x) cout<<((x)?\"Possible\":\"Impossible\")<<endl;\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<endl;\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<endl;\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<endl;\n\n/// --- Union Find {{{ ///\n#include <vector>\nstruct UF {\n  int n;\n  vector< int > par;\n  UF(int n) : n(n), par(n, -1) {}\n  int find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n  int size(int x) { return -par[find(x)]; }\n  bool same(int a, int b) { return find(a) == find(b); }\n  void unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if(a == b) return;\n    if(par[a] < par[b]) swap(a, b);\n    par[b] += par[a];\n    par[a] = b;\n  }\n};\n/// }}}--- ///\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> h;\n  int a, b, c, d;\n  UF uf(H * 2);\n  for(int i = 0; i < n; i++) {\n    cin >> a >> b >> c >> d;\n    int from = 0, to = 0;\n    if(c == 0) from = a;\n    else from = H + c;\n    if(d == 0) to = H + b;\n    else to = d;\n    out[from]++;\n    in[to]++;\n    dump(from, to);\n    uf.unite(from, to);\n  }\n  int ok = 1;\n  for(int i = 0; i < H; i++) {\n    if(in[i] + out[i] == 0) continue;\n    if(in[i] > out[i]) ok = 0;\n    cnt1[uf.find(i)] += out[i] - in[i];\n    f[uf.find(i)] = 1;\n  }\n  for(int i = H; i < H * 2; i++) {\n    if(in[i] + out[i] == 0) continue;\n    if(in[i] < out[i]) ok = 0;\n    cnt2[uf.find(i)] += in[i] - out[i];\n    f[uf.find(i)] = 1;\n  }\n  for(int i = 0; i < H; i++) {\n    if(!f[i]) continue;\n    if(cnt1[i] != cnt2[i]) ok = 0;\n    if(cnt1[i] == 0) ok = 0;\n  }\n  YES(ok);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2000500\nusing namespace std;\nint n,m,fa[N],vis[N],D[N],C[N];\nint gf(int x) {return fa[x]==x?x:fa[x]=gf(fa[x]);}\ninline int rd() {int r;scanf(\"%d\",&r);return r;}\nint main() {\n\tn = rd(), m = rd();\n\n\tfor (int i=1;i<=1000;i++) fa[i] = i;\n\tfor (int _=1;_<=n;_++)  {\n\t\tint x, y,a,b,c,d;\n\t\ta = rd(), b = rd(), c = rd(), d = rd();\n\t\tx=!c?a:-c; x+=500;\n\t\ty=!d?-b:d; y+=500;\n\t\tfa[ gf(x) ] = gf(y);\n\t\tD[x]++, D[y]--, vis[x] = 1;\n\t}\n\n\tint flag = 1;\n\tfor (int i=1;i<500;i++) D[i]>0 ? flag=0 :0;\n\tfor (int i=501;i<=1000;i++) D[i]<0 ? flag=0 :0;\n\tfor (int i=1;i<=1000;i++) vis[gf(i)] |= vis[i];\n\tfor (int i=1;i<=1000;i++) if (D[i]) C[gf(i)] = 1;\n\tfor (int i=1;i<=1000;i++) if (fa[i]==i && !C[i] && vis[i]) flag = 0;\n\tputs(flag?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ninline void read(int &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,h,cnt,fa[N],l[N],r[N],du[N],tag[N],ans[N];\n\ninline int find(int x){return fa[x]!=x?fa[x]=find(fa[x]):x;}\ninline void add(int x,int y){\n//\tprintf(\"%d %d\\n\",x,y);\n\tx=find(x);y=find(y);\n\tif(x!=y) fa[x]=y;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&h);cnt=n;\n\tfor(int i=1;i<=h;i++) l[i]=++cnt,r[i]=++cnt;\n\tfor(int i=1;i<=cnt;i++) fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;scanf(\"%d%d%d%d\",&b,&d,&a,&c);\n\t\tif(!a) tag[i]++,add(r[b],i),du[r[b]]++; else tag[i]--,add(l[a],i),du[l[a]]--;\n\t\tif(!c) tag[i]++,add(i,l[d]),du[l[d]]++; else tag[i]--,add(i,r[c]),du[r[c]]--;\n\t}\n\tfor(int i=1;i<=h;i++)\n\t\tif(du[l[i]]<0||du[r[i]]<0){puts(\"NO\");return 0;}\n\tfor(int i=1;i<=n;i++)\n\t\tans[find(i)]+=tag[i];\n\tfor(int i=1;i<=n;i++)\n\t\tif(ans[find(i)]<=0){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint rt(int *uf,int i)\n{\n  return uf[i]<0?i:uf[i]=rt(uf,uf[i]);\n}\n\nvoid con(int *uf,int a,int b)\n{\n  a=rt(uf,a);\n  b=rt(uf,b);\n  if(a!=b){\n    if(-uf[a]<-uf[b]){\n      uf[a]=b;\n    }\n    else if(-uf[a]>-uf[b]){\n      uf[b]=a;\n    }\n    else{\n      uf[a]=b;\n      uf[b]--;\n    }\n  }\n}\n\nint main()\n{\n  int n,h;\n  scanf(\"%d%d\",&n,&h);\n  vector<int> A(n),B(n),C(n),D(n);\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d%d\",&(A[i]),&(B[i]),&(C[i]),&(D[i]));\n  }\n  vector<int> D0(h+1),D1(h+1);\n  int uf[500],b[500]={0};\n  for(int i=0;i<2*(h+1);i++){\n    uf[i]=-1;\n  }\n  for(int i=0;i<n;i++){\n    int x,y;\n    if(C[i]==0){\n      D0[A[i]]++;\n      x=A[i];\n    }\n    else{\n      D1[C[i]]--;\n      x=C[i]+h+1;\n    }\n    if(D[i]==0){\n      D1[B[i]]++;\n      y=B[i]+h+1;\n    }\n    else{\n      D0[D[i]]--;\n      y=D[i];\n    }\n    con(uf,x,y);\n    b[x]=b[y]=1;\n  }\n  bool F=0;\n  for(int i=0;i<=h;i++){\n    if(D0[i]<0||D1[i]<0){\n      F=1;\n    }\n  }\n  vector<int> B0(2*(h+1),0),B1(2*(h+1),0);\n  for(int x=0;x<2*(h+1);x++){\n    if(b[x]){\n      //printf(\"%d %d\\n\",x,rt(uf,x));\n      if(x<=h&&D0[x]>0){\n\tint r=rt(uf,x);\n\tB0[r]=1;\n      }\n      if(h<x&&D1[x-h-1]>0){\n\tint r=rt(uf,x);\n\tB1[r]=1;\n      }\n    }\n  }\n  for(int x=0;x<2*(h+1);x++){\n    if(b[x]&&uf[x]<0&&(!B0[x]||!B1[x])){\n      F=1;\n    }\n  }\n  puts(F?\"NO\":\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\nint NOEL(){\n  cout<<\"NO\"<<endl;\n  return 0;\n}\nstring g(char a,string b){\n  string res=\"\";\n  res.push_back(a);\n  res+=b;\n  return res;\n}\n\nunordered_map<string,ll> nz;\n\nunordered_map<string,vector<string> >v;\nunordered_set<string> vis;\nbool done;\nvoid dfs(string x){\n  if(vis.find(x)!=vis.end())return;\n  vis.insert(x);\n  if(nz[x]!=0)done=1;\n  for(auto y:v[x]){\n    dfs(y);\n  }\n}\nint main(){\n    ll n,h;\n    cin>>n>>h;\n    lol(i,n){\n      string a,b,c,d;cin>>a>>b>>c>>d;\n      string s,t;\n      if(c==\"0\")s=g('x',a);\n      else s=g('y',c);\n      nz[s]++;\n      if(d==\"0\")t=g('y',b);\n      else t=g('x',d);\n      nz[t]--;\n      //cout<<s<<\" \"<<t<<endl;\n      v[s].push_back(t);\n      v[t].push_back(s);\n    }\n    for(auto dat:nz){\n      string key=dat.first;\n      ll cnt=dat.second;\n      //cout<<key<<\" \"<<cnt<<endl;\n      if(cnt>=2||cnt<=-2)return NOEL();\n      if(cnt==+1&&key[0]!='x')return NOEL();\n      if(cnt==-1&&key[0]!='y')return NOEL();\n      if(vis.find(key)==vis.end()){\n\tdone=0; dfs(key);\n\tif(done==0)return NOEL();\n      }\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:64777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <stdio.h>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <cassert>\n#include <complex>\n#include <time.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long Int;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\n\nconst int MAX = 512;\nconst int CNT = 17;\n\nint n, h, c0, c1, bal, e;\nVI G[MAX];\nVI GG[MAX];\nint D[MAX];\nint U[MAX];\n\nint getNext(int a, int b)\n{\n\treturn (a == 0 ? b : h + a);\n}\n\nint getPrev(int a, int b)\n{\n\treturn (a == 0 ? h + b : a);\n}\n\nvoid nope()\n{\n\tcout << \"NO\" << endl;\n\texit(0);\n}\n\nvoid dfs(int v)\n{\n\tU[v] = 1;\n\tif (v < h)\n\t{\n\t\t++ c0;\n\t\tbal -= D[v];\n\t}\n\tif (v >= h)\n\t\t++ c1;\n\n\tFOR (i,0,SZ(GG[v]))\n\t{\n\t\tint to = GG[v][i];\n\t\tif (U[to] == 0)\n\t\t\tdfs(to);\n\t\t++ e;\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\tcin >> n >> h;\n\t++ h;\n\n\tFOR (i,0,n)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tint u = getPrev(c, a);\n\t\tint v = getNext(d, b);\n\t\tG[u].PB(v);\n\t\tGG[u].PB(v);\n\t\tGG[v].PB(u);\n\t\t++ D[u];\n\t\t-- D[v];\n\t}\n\n\n\tFOR (i,0,h)\n\t\tif (D[i] > 0)\n\t\t\tnope();\n\n\tFOR (i,h,2*h)\n\t\tif (D[i] < 0)\n\t\t\tnope();\n\n\tint cnt = 0, alone = 0, bal0 = 0;\n\tFOR (i,0,2*h)\n\t{\n\t\tif (U[i]) continue;\n\t\tc0 = 0, c1 = 0, bal = 0, e = 0;\n\t\tdfs(i);\n\t\tif (e == 0) continue;\n\n\t\t++ cnt;\n\t\tif (c0 == 0 || c1 == 0)\n\t\t\t++ alone;\n\t\tif (bal == 0)\n\t\t\t++ bal0;\n\t}\n\n\tif (alone > 0)\n\t\tnope();\n\n\tcout << \"YES\" << endl;\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1116\n\nint n,h,e[N],f[N],g[N];\n\nint get(int x){\n\treturn f[x]==x?x:f[x]=get(f[x]);\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n \nint main(){\n\tn=read();h=read();\n\tfor (int i=0;i<=2*h;i++) f[i]=i;\n\tfor (int i=1;i<=n;i++){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint l=(c?-c:a)+h,r=(d?d:-b)+h;\n\t\te[l]++;e[r]--;f[get(l)]=get(r);g[f[r]]=1;\n\t}\n\tfor (int i=0;i<=h-1;i++)\n\t\tif (e[i]>0) {printf(\"NO\\n\");return 0;}\n\tfor (int i=h+1;i<=2*h;i++)\n\t\tif (e[i]<0) {printf(\"NO\\n\");return 0;}\n\tfor (int i=0;i<=2*h;i++)\n\t\tif (e[i]) g[get(i)]=0;\n\tfor (int i=0;i<=2*h;i++)\n\t\tif (f[i]==i&&g[i]) {printf(\"NO\\n\");return 0;};\n\tprintf(\"YES\\n\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << to_string(v[i]);\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 3030303\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(mi a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n\nbool dfs(int v, int b, vector<vector<int>>& g, vector<bool>& used,\n         vector<int>& ideg, vector<int>& odeg) {\n    used[v] = true;\n    bool ret = false;\n    if(v % 2 != b) ret = true;\n    if(ideg[v] != odeg[v]) ret = true;\n    REP(i, g[v].size()) {\n        if(used[g[v][i]]) continue;\n        ret = ret | dfs(g[v][i], b, g, used, ideg, odeg);\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, h;\n    cin >> n >> h;\n    vector<vector<int>> g(2 * (h + 1));\n    vector<int> ideg(2 * (h + 1), 0), odeg(2 * (h + 1), 0);\n    vector<pair<int, int>> p1(h + 1), p2(h + 1);\n    REP(i, n) {\n        int a, b, c, d;\n        int p = 0, q = 0;\n        cin >> a >> b >> c >> d;\n        if(c == 0) {\n            p1[a].first++;\n            p = 2 * a;\n        } else {\n            p2[c].first++;\n            p = 2 * c + 1;\n        }\n        if(d) {\n            p1[d].second++;\n            q = 2 * d;\n        }\n        else {\n            p2[b].second++;\n            q = 2 * b + 1;\n        }\n        g[p].pb(q);\n        g[q].pb(p);\n        odeg[p]++;\n        ideg[q]++;\n    }\n    int c1 = 0, c2 = 0;\n    REP(i, h + 1) {\n        if(p1[i].first < p1[i].second) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        c1 += p1[i].first - p1[i].second;\n        if(p2[i].second < p2[i].first) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        c2 += p2[i].second - p2[i].first;\n    }\n    if(c1 != c2) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    assert(false);\n    vector<bool> used(2 * (h + 1), false);\n    REP(i, 2 * (h + 1)) {\n        if(g[i].empty() || used[i]) continue;\n        if(!dfs(i, i % 2, g, used, ideg, odeg)) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=100100,M=440;\nint i,j,k,n,m,h,a,b,c,d,ch,ff;\nint degree[M],f[M],fg[M],z[M];\nstruct cc { int x,y;} A[N];\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nint getf(int x) {\n\tif (f[x]==x) return x;\n\treturn f[x]=getf(f[x]);\n}\nint main() {\n\tR(n);R(h);\n\tm=h+h;\n\tfor (i=1;i<=n;i++) {\n\t\tR(a);R(b);R(c);R(d);\n\t\tint x,y;\n\t\tif (c) x=h+c;\n\t\telse x=a;\n\t\tif (d) y=d;\n\t\telse y=h+b;\n\t\tA[i].x=x;A[i].y=y;\n\t\tdegree[x]++;\n\t\tdegree[y]--;\n\t\tz[x]=z[y]=1;\n\t}\n\tfor (i=1;i<=h;i++) if (degree[i]<0 || degree[h+i]>0) return puts(\"NO\"),0;\n\tfor (i=1;i<=m;i++) if (degree[i]) fg[i]=1,f[i]=i;\n\tfor (i=1;i<=n;i++) {\n\t\tint x=A[i].x,y=A[i].y;\n\t\tif (getf(x)!=getf(y)) {\n\t\t\tfg[f[y]]|=fg[f[x]];\n\t\t\tf[f[x]]=f[y];\n\t\t}\n\t}\n\tfor (i=1;i<=m;i++) if (z[i] && !fg[getf(i)]) return puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, h, S, E, id[405], od[405], vis[405], sc[405], ec[405], mat[405];\nvector<int> e[405], ee[405];\n\nvoid T_T(){ puts(\"NO\"); exit(0); }\nvoid O_O(){ puts(\"YES\"); exit(0); }\n\nvoid f(int x){\n\tvis[x] = 1;\n\tfor(auto &i : e[x]){\n\t\tif(!vis[i]) f(i);\n\t}\n}\n\nint g(int x){\n\tvis[x] = 1;\n\tfor(auto &i : ee[x]){\n\t\tif(!mat[i] || !vis[mat[i]] && g(mat[i])){\n\t\t\tmat[i] = x;\n\t\t\tmat[x] = i;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &h);\n\tfor(int i = 0, a, b, c, d; i < n; i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint st, en;\n\t\tif(c == 0) st = a;\n\t\telse st = c + h;\n\t\tif(d == 0) en = b + h;\n\t\telse en = d;\n\t\te[st].push_back(en);\n\t\tod[st]++; id[en]++;\n\t}\n\tfor(int i = 1; i <= 2 * h; i++){\n\t\tif(abs(od[i] - id[i]) > 1) T_T();\n\t\tif(od[i] - id[i] == 1){\n\t\t\tif(i > h) T_T();\n\t\t\tS++;\n\t\t\tsc[i] = 1;\n\t\t}\n\t\tif(od[i] - id[i] == -1){\n\t\t\tif(i <= h) T_T();\n\t\t\tE++;\n\t\t\tec[i] = 1;\n\t\t}\n\t}\n\tif(!S || S != E) T_T();\n\tfor(int i = 1; i <= h; i++){\n\t\tif(!sc[i]) continue;\n\t\tfill(vis + 1, vis + 2 * h + 1, 0);\n\t\tf(i);\n\t\tfor(int j = h + 1; j <= 2 * h; j++){\n\t\t\tif(ec[j] && vis[j]){\n\t\t\t\tee[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= h; i++){\n\t\tif(sc[i]){\n\t\t\tif(!mat[i]){\n\t\t\t\tfill(vis + 1, vis + h + 1, 0);\n\t\t\t\tif(!g(i)) T_T();\n\t\t\t}\n\t\t}\n\t}\n\tO_O();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=400500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nint Bv[N][2];\nint main()\n{\n\tint q,w;\n\tread(n),read(m);\n\tfo(i,1,n)\n\t{\n\t\tint qa,qb,qc,qd;\n\t\tread(qa),read(qb),read(qc),read(qd);\n\t\tif(qc==0)\n\t\t{\n\t\t\tq=m+qa;\n\t\t}else q=qc;\n\t\tif(qd==0)w=qb;\n\t\telse w=m+qd;\n\t\t++Bv[q][0];++Bv[w][1];\n\t}\n\tans=0;q=0;\n\tfo(i,m+1,m*2)\n\t{\n\t\tif(Bv[i][0]<Bv[i][1])++ans;\n\t\tif(Bv[i][0]>Bv[i][1])++q;\n\t}\n\tif(!q||ans){printf(\"NO\\n\");return 0;}\n\tq=0;\n\tfo(i,1,m)\n\t{\n\t\tif(Bv[i][0]>Bv[i][1])++ans;\n\t\tif(Bv[i][0]<Bv[i][1])++q;\n\t}\n\tif(ans||!q)printf(\"NO\\n\");\n\telse printf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define show(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\nint main()\n{\n    int N, H;\n    cin >> N >> H;\n\n    vector<int> dim(2 * H + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int l = 0;\n        if (c == 0) {\n            l = a;\n        } else {\n            l = -c;\n        }\n\n        int r = 0;\n        if (d == 0) {\n            r = b;\n        } else {\n            r = -d;\n        }\n\n        //        cout << l << \"->\" << -r << endl;\n        dim[l + H]++;\n        dim[-r + H]--;\n    }\n\n    int num1 = 0;\n    int num2 = 0;\n    for (int i = 2 * H; i >= 0; i--) {\n        //        cout << i - H << \": \" << dim[i] << endl;\n        if (i - H > 0 and dim[i] > 0) {\n            num1++;\n        }\n        if (i - H < 0 and dim[i] < 0) {\n            num2++;\n        }\n    }\n\n    if (num1 == num2 and num1 > 0) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pll pair<ll,ll>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pii pair<int,int>\n#define mk make_pair\n#define pb push_back\n#define eps 1e-12\n#define MAXN 200009\nusing namespace std;\nint indeg[700],outdeg[700],presen[700],par[700];\ninline int parent(int pos)\n{\n\tif(par[pos]!=pos)\n\t{\n\t\tpar[pos]=parent(par[pos]);\n\t}\n\treturn par[pos];\n}\nbool comp[700];\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint n;\n\tcin>>n;\n\tint h;\n\tcin>>h;\n\tint a[n+1],b[n+1],c[n+1],d[n+1];\n\tfor(int i=0;i<=600;i++)\n\t{\n\t\tpar[i]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tint ff=-1,ss=-1;\n\t\tif(c[i]==0)\n\t\t{\n\t\t\tff=250+a[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tff=c[i];\n\t\t}\n\t\tif(d[i]==0)\n\t\t{\n\t\t\tss=b[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tss=250+d[i];\n\t\t}\n\t\toutdeg[ff]++;\n\t\tindeg[ss]++;\n\t\tpresen[ff]=1;\n\t\tpresen[ss]=1;\n\t\tint p1=parent(ff);\n\t\tint p2=parent(ss);\n\t\tif(p1!=p2)\n\t\t{\n\t\t\tpar[max(p1,p2)]=min(p1,p2);\n\t\t}\n\t}\n\tbool flag=true;\n\tint ans1=0;\n\tfor(int i=1;i<=250;i++)\n\t{\n\t\tif(presen[i])\n\t\t{\n\t\t\tif(outdeg[i]!=indeg[i])\n\t\t\t{\n\t\t\t\tif(outdeg[i]>indeg[i])\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans1+=indeg[i]-outdeg[i];\n\t\t\t\t\tcomp[parent(i)]=true;\n\t\t\t\t\t//cout<<ans1<<\"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans2=0;\n\tfor(int i=251;i<=500;i++)\n\t{\n\t\tif(presen[i])\n\t\t{\n\t\t\tif(outdeg[i]!=indeg[i])\n\t\t\t{\n\t\t\t\tif(outdeg[i]<indeg[i])\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans2+=outdeg[i]-indeg[i];\n\t\t\t\t\tif(!comp[parent(i)])\n\t\t\t\t\t{\n\t\t\t\t\t\tassert(false);\n\t\t\t\t\t}\n\t\t\t\t\t//cout<<ans2<<\"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=500;i++)\n\t{\n\t\tif(presen[i])\n\t\t{\n\t\t\tif(!comp[parent(i)])\n\t\t\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<ans1<<\" \"<<ans2<<\" \"<<flag<<\"\\n\";\n\tif(ans1!=ans2)\n\t{\n\t\tflag=false;\n\t}\n\tif(ans1==0)\n\t{\n\t\tflag=false;\n\t}\n\tif(flag)\n\t{\n\t\tcout<<\"YES\\n\";\n\t}\n\telse\n\t{\n\t\tcout<<\"NO\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> emp[2][205],bmp[2][205];\nbool vis[100005];\nint a[100005],c[100005],d[100005],b[100005];\nint n,h,gi,dep;\n\nbool fille(int i)\n{\n    vis[i] = true;\n\n    if(d[i]==0)\n    {\n        for(int j=0;j<emp[1][b[i]].size();++j)\n        {\n\n            if(vis[emp[1][b[i]][j]]) continue;\n            return fille(emp[1][b[i]][j]);\n        }\n        return true;\n    }else\n    {\n        for(int j=0;j<emp[0][d[i]].size();++j)\n        {\n            if(vis[emp[0][d[i]][j]])continue;\n            return fille(emp[0][d[i]][j]);\n        }\n        return false;\n    }\n}\n\nbool fillb(int i)\n{\n    vis[i] = true;\n    ++dep;\n    if(c[i]==0)\n    {\n        for(int j=0;j<bmp[1][a[i]].size();++j){\n            if(vis[bmp[1][a[i]][j]]) continue;\n            if(fillb(bmp[1][a[i]][j])) return true;\n        }\n        if(!fille(gi)){\n            return vis[i] = false;\n        }\n        return true;\n    }else{\n        for(int j=0;j<bmp[0][c[i]].size();++j)\n        {\n            if(vis[bmp[0][c[i]][j]]) continue;\n            if(fillb(bmp[0][c[i]][j])) return true;\n        }\n        return vis[i] = false;\n    }\n}\n\n\n\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        if(c[i]==0)\n        {\n            emp[0][a[i]].push_back(i);\n        }else emp[1][c[i]].push_back(i);\n        if(d[i]==0) bmp[0][b[i]].push_back(i);\n        else bmp[1][d[i]].push_back(i);\n    }\n    bool ag = true;\n    for(gi=0;gi<n;++gi)\n    {\n        if(vis[gi]||(c[gi]==0&&d[gi]==0)) continue;\n        dep=0;\n        if((!fillb(gi)))\n        {\n            ag= false;break;\n        }\n    }\n    if(ag) printf(\"YES\");\n    else printf(\"NO\");\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <typename T> inline void rd(T& x) {\n\tint si = 1; char c = getchar(); x = 0;\n\twhile(!isdigit(c)) si = c == '-' ? -1 : si, c = getchar();\n\twhile(isdigit(c)) x = x * 10 + c - 48, c = getchar();\n\tx *= si;\n}\ntemplate <typename T, typename... Args>\ninline void rd(T& x, Args&... args) { rd(x); rd(args...); }\n#define fi first\n#define se second\n#define mkp std::make_pair\ntypedef long long ll;\ntypedef double ff;\ntypedef std::pair <int, int> pii;\nconst int kN = 4e5 + 5, kInf = 0x3f3f3f3f;\nconst ll kMod = 998244353, kInfLL = 0x3f3f3f3f3f3f3f3fLL;\n\nint n, H, cnt1[kN], cnt2[kN], dg[kN], fa[kN]; bool flag = true;\nvoid Add(int u, int v) { ++dg[u]; --dg[v]; }\nint Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); }\nvoid Merge(int u, int v) {\n\tfa[Find(u)] = Find(v);\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\", \"r\", stdin);\n\tfreopen(\"a.out\", \"w\", stdout);\n#endif\n\tint T = 1; //rd(T);\n\twhile(T--) {\n\t\trd(n, H);\n\t\tfor(int i = 1; i <= 4 * H; ++i) fa[i] = i;\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tint A, B, C, D, d1, d2, d3; rd(A, B, C, D);\n\t\t\td1 = C ? H + C : A; d2 = D ? 3 * H + D : 2 * H + B;\n\t\t\td3 = D ? D : H + B;\n\t\t\t//printf(\"A: (%d %d)\\n\", d1, d2);\n\t\t\t//printf(\"B: (%d %d)\\n\", d2, d3);\n\t\t\tMerge(d1, d2); Merge(d2, d3);\n\t\t\tAdd(d1, d2); Add(d2, d3);\n\t\t}\n\t\t//for(int i = 1; i <= 4 * H; ++i) printf(\"%d \", Find(i));\n\t\t//printf(\"\\n\");\n\t\tfor(int i = 1; i <= 4 * H; ++i) {\n\t\t\t//printf(\"%d \", dg[i]);\n\t\t\tif(dg[i] > 1 || dg[i] < -1 || (dg[i] == 1 && i > H) || (dg[i] == -1 && (i > 2 * H || i <= H))) {\n\t\t\t\tflag = false; break;\n\t\t\t\t//printf(\"?\");\n\t\t\t} else if(dg[i] == 1) ++cnt1[Find(i)];\n\t\t\telse if(dg[i] == -1) ++cnt2[Find(i)];\n\t\t}\n\t\t//printf(\"\\n\");\n\t\t/*for(int i = 1; i <= 4 * H; ++i) if(Find(i) == i) {\n\t\t\tprintf(\"%d %d %d\\n\", i, cnt1[i], cnt2[i]);\n\t\t}*/\n\t\tfor(int i = 1; i <= 4 * H; ++i)\n\t\t\tif(!((!cnt1[i] && !cnt2[i]) || (cnt1[i] == 1 && cnt2[i] == 1)))\n\t\t\t\tflag = false;\n\t\tif(!flag) printf(\"NO\\n\");\n\t\telse printf(\"YES\\n\");\n\t} return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstring>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nint N,H,pal;\tint a,b,c,d;\nstruct line{int in,ch;}lines[100000];bool cam(line a,line b){return a.in>b.in;}\nbool v[100000];\nvoid solve(int no,int t)\n{\n\tint st=0;\n\twhile(lines[st].in!=-lines[no].ch)st++;\n\tif(t==N-1)\n\t{\n\t\tfor(int i=st;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0&&lines[i].ch>=0)\n\t\t\t{pal=1;}\n\t\t\tif(pal)return;\n\t\t}\n\t\tif(lines[no].ch>=0)\n\t\t{\n\t\t\tfor(int i=0;i<N&&lines[i].in>=0;i++)\n\t\t\t{\n\t\t\t\tif(v[i]==0&&lines[i].ch>=0)\n\t\t\t\t{pal=1;}\n\t\t\t\tif(pal)return;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\n\t\tfor(int i=st;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0)\n\t\t\t{\tv[i]=1;\n\t\t\t\tsolve(i,t+1);\n\t\t\t\tv[i]=0;}\n\t\t\tif(pal)return;\n\t\t}\n\t\tif(lines[no].ch>=0)\n\t\t{\n\t\t\tfor(int i=0;i<N&&lines[i].in>=0;i++)\n\t\t\t{\n\t\t\t\tif(v[i]==0)\n\t\t\t\t{\tv[i]=1;\n\t\t\t\t\tsolve(i,t+1);\n\t\t\t\t\tv[i]=0;}\n\t\t\t\tif(pal)return;\n\t\t\t}\n\t\t}\n\t}\n\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\n\tpal=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta=c==0?a:-c;b=d==0?b:-d;\n\t\tlines[i].in=a;lines[i].ch=b;\n\t}\n\tsort(lines,lines+N,cam);\n\tfor(int i=0;i<N&&lines[i].in>=0;i++)\n\t{\n\t\tv[i]=1;\n\t\tsolve(i,1);\n\t\tv[i]=0;\n\t\tif(pal)break;\n\t}\n\tif(pal)printf(\"YES\");\n\telse printf(\"NO\");\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\nint c[201][2];\nint e[201][2];\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\tc[b[i].c][0]++; num++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].a][0]++;\n\t\t}\n\t\tif (b[i].d > 0) {\n\t\t\tc[b[i].d][1]++; num++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].b][1]++;\n\t\t}\n\t}\n\tif (num>=n) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tint r = 0;\n\trep(i, 201) {\n\t\trep(j, 2) {\n\t\t\tif (c[i][j] > e[i][j^1]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t\tr += e[i][j ^ 1] - c[i][j];\n\t\t}\n\t}\n\tif (r == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N, H;\nvector<int> vertex;\nint degree[1000];\nint v1[105000], v2[105000];\nbool can[1000];\nint main() {\n    cin >> N >> H;\n    cerr << N << \" \" << H << endl;\n    UnionFind uni(3 * H);\n    for(int i = 0; i < N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        cerr << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        if(c == 0) v1[i] = a;\n        else v1[i] = H + c;\n        if(d == 0) v2[i] = H + b;\n        else v2[i] = d;\n        degree[v1[i]]--;\n        degree[v2[i]]++;\n        uni.merge(v1[i], v2[i]);\n        vertex.push_back(v1[i]);\n        vertex.push_back(v2[i]);\n        //cerr << v1[i] << \" \" << v2[i] << endl;\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            can[v1[i]] = true;\n        }\n    }\n    sort(vertex.begin(), vertex.end());\n    vertex.erase(unique(vertex.begin(), vertex.end()), vertex.end());\n    map<int, vector<int>> mp;\n    for(auto v : vertex) {\n        /*\n        if(!uni.issame(v, vertex[0])) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        */\n        mp[uni.root(v)].push_back(v);\n    }\n    cerr << \"sz: \" << mp.size() << endl;\n    for(auto tmp : mp) {\n        /*\n        for(auto v : tmp.second) {\n            cerr << v << \" \";\n        }\n        cerr << endl;\n        */\n        vector<int> s, t;\n        for(auto v : tmp.second) {\n            if(degree[v] < 0) s.push_back(v);\n            if(degree[v] > 0) t.push_back(v);\n        }\n        if(s.empty()) {\n            assert(t.empty());\n            bool ok = false;\n            for(auto v : tmp.second) {\n                ok |= can[v];\n            }\n            if(!ok) {\n                cout << \"NO\" << endl;\n                assert(0);\n                return 0;\n            }\n        } else {\n            //if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n            for(auto v : s) {\n                if(v >= H + 1) {\n                    cout << \"NO\" << endl;\n                    assert(0);\n                    return 0;\n                }\n            }\n            for(auto v : t) {\n                if(v <= H) {\n                    cout << \"NO\" << endl;\n                    assert(0);\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n    /*\n    int s = -1, t = -1;\n    for(auto v : vertex) {\n        if(abs(degree[v]) >= 2) {\n            cout << \"NO\" << endl;\n            cerr << \"DEGREE\" << endl;\n            return 0;\n        }\n        if(degree[v] == 1) {\n            if(t != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"T\" << endl;\n                return 0;\n            } else {\n                t = v;\n            }\n        }\n        if(degree[v] == -1) {\n            if(s != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"S\" << endl;\n                cerr << s << \" \" << v << endl;\n                return 0;\n            } else {\n                s = v;\n            }\n        }\n    }\n    if(s != -1) {\n        assert(t != -1);\n        if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n    }\n    for(int i = 0; i < N; i++) {\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    }\n    cout << \"NO\" << endl;\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint n, h, a, b, c, d, in[500], out[500], f[N], ok[N];\nint find(int x) {\n    if(x == f[x]) return x;\n    return f[x] = find(f[x]);\n}\nint main() {\n    scanf(\"%d %d\", &n, &h);\n    for(int i = 1; i <= n; ++i) f[i] = i;\n    for(int i = 1; i <= n; ++i) {\n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        int x = h, y = h;\n        if(!d) x -= b; else x += d;\n        if(!c) y += a; else y -= c;\n        ++out[x]; ++in[y];\n        int fx = find(x), fy = find(y);\n        if(fx != fy) f[fx] = fy;\n    }\n    for(int i = 1; i <= h + h; ++i) \n        if(out[i] != in[i] || (!out[i] && !in[i])) ok[find(i)] = 1;\n    int ans = 1;\n    for(int i = 1; i <= h; ++i) if(in[i] > out[i]) ans = 0;\n    for(int i = h + 1; i <= h + h; ++i) if(out[i] > in[i]) ans = 0;\n    for(int i = 1; i <= h + h; ++i) if(f[i] == i && !ok[i]) ans = 0;\n    printf(ans ? \"YES\\n\" : \"NO\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 444;\n\nvector<int> E[MAX];\nbool bio[MAX];\n\nint inDeg[MAX];\nint outDeg[MAX];\nint N, H;\n\nvector<int> v;\n\nvoid dfs(int x) {\n  if (bio[x]) return;\n  bio[x] = true;\n  v.push_back(x);\n  for (int y: E[x]) dfs(y);\n}\n\nbool solve() {\n  REP(i, 2*H) {\n    if (!bio[i] && E[i].size()) {\n      v.clear();\n      dfs(i);\n      \n      bool haveStart = false;\n      bool haveEnd = false;\n      \n      int balance = 0;\n      for (int x: v) {\n        if (x < H) {\n          haveStart = true;\n          if (inDeg[x] > outDeg[x]) return false;\n          balance += outDeg[x] - inDeg[x];\n        } else {\n          haveEnd = true;\n          if (inDeg[x] < outDeg[x]) return false;\n          balance -= inDeg[x] - outDeg[x];\n        }\n      }\n      if (!haveStart || !haveEnd || balance != 0) return false;\n    }\n  }\n  return true;\n}\n\nint main(void) {\n  scanf(\"%d %d\", &N, &H);\n  REP(i, N) {\n    int A, B, C, D;\n    scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n\n    int u = C == 0 ? A-1 : H+C-1;\n    int v = D == 0 ? H+B-1 : D-1;\n\n    E[u].push_back(v);\n    E[v].push_back(u);\n    outDeg[u]++;\n    inDeg[v]++;\n  }\n\n  puts(solve() ? \"YES\" : \"NO\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<lint, lint> pi;\nconst int MAXN = 405;\n\nint adj[MAXN][MAXN];\nint deg[MAXN], vis[MAXN];\n\nint get(pi v){\n\tif(v.first == 1) return 202 + v.second;\n\telse return v.second;\n}\n\nvoid my_ass(bool p){\n\tif(p ==0){\n\t\tputs(\"NO\");\n\t\texit(0);\n\t}\n}\n\nvoid dfs(int x){\n\tif(vis[x]) return;\n\tvis[x] = 1;\n\tfor(int i=0; i<MAXN; i++){\n\t\tif(adj[x][i] || adj[i][x]) dfs(i);\n\t}\n}\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\twhile(n--){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tpi st, ed;\n\t\tif(c == 0) st = pi(0, a);\n\t\telse st = pi(1, c);\n\t\tif(d == 0) ed = pi(1, b);\n\t\telse ed = pi(0, d);\n\t//\tprintf(\"%d %d\\n\", get(st), get(ed));\n\t\tadj[get(st)][get(ed)]++;\n\t\tdeg[get(st)]++;\n\t\tdeg[get(ed)]--;\n\t}\n\tfor(int i=0; i<202; i++){\n\t\tmy_ass(deg[i] >= 0);\n\t\tmy_ass(deg[i + 202] <= 0);\n\t\tadj[404][i] += deg[i];\n\t\tdeg[404] += deg[i];\n\t\tdeg[i] = 0;\n\t\tadj[404][i] -= deg[i + 202];\n\t\tdeg[404] += deg[i + 202];\n\t\tdeg[i + 202] = 0;\n\t}\n\tdfs(404);\n\tfor(int i=0; i<MAXN; i++){\n\t\tfor(int j=0; j<MAXN; j++){\n\t\t\tif(adj[i][j] && !vis[i]){\n\t\t\t\tmy_ass(0);\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\nconst int N = 2e5L + 11, M = 211;\n\nbool v[N];\nint al[N];\nint ar[N];\n\nbool his[M * 3];\ndeque <int> sl[M * 3], sr[M * 3];\n\nint main() {\n\tios :: sync_with_stdio(0);\n\tint n, h; cin >> n >> h;\n\tfor(int i = 1; i <= n; i ++) {\n\t\tint a, b, c, d; cin >> a >> b >> c >> d;\n\t\tif(c) al[i] = -c; else al[i] = a;\n\t\tif(d) ar[i] = -d; else ar[i] = b;\n\n\t\tsl[al[i] + M].pb(i);\n\t\tsr[ar[i] + M].pb(i);\n\t}\n\twhile(1) {\n\t\tbool ch = 0;\n\t\tfor(int i = -h + M; i <= h + M; i ++) {\n\t\t\twhile(sl[i].size() && v[sl[i][0]]) sl[i].pop_front();\n\t\t\twhile(sr[i].size() && v[sr[i][0]]) sr[i].pop_front();\n\t\t}\n\t\tfor(int i = -h; i <= h; i ++) if(sr[i + M].size() && sl[-i + M].size()) {\n\t\t\tif(sr[i + M][0] == sl[-i + M][0]) {\n\t\t\t\tif(sr[i + M].size() > 1) {\n\t\t\t\t\tsr[i + M].pb(sr[i + M][0]);\n\t\t\t\t\tsr[i + M].pop_front();\n\t\t\t\t} else if(sl[-i + M].size() > 1) {\n\t\t\t\t\tsl[-i + M].pb(sl[-i + M][0]);\n\t\t\t\t\tsl[-i + M].pop_front();\n\t\t\t\t} else continue;\n\t\t\t\tch = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tch = 1;\n\t\t\this[i + M] = 1;\n\t\t\tn ++;\n\t\t\tv[sr[i + M][0]] = v[sl[-i + M][0]] = 1;\n\t\t\tal[n] = al[sr[i + M][0]];\n\t\t\tar[n] = ar[sl[-i + M][0]];\n\n\t\t\tsr[i + M].pop_front();\n\t\t\tsl[-i + M].pop_front();\n\n\t\t\tsl[al[n] + M].pb(n);\n\t\t\tsr[ar[n] + M].pb(n);\n\t\t\tbreak;\n\t\t}\n\n\t\tif(!ch) break;\n\t}\n\n\tbool f = 1, use_his = 0;\n\tint cnt = 0;\n\tfor(int i = 1; i <= n; i ++) if(!v[i]) {\n\t\t//cout << al[i] << ' ' << ar[i] << '\\n';\n\t\tif(al[i] > 0 && ar[i] > 0) {\n\t\t\tcnt ++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(al[i] + ar[i] == 0 && !his[-al[i] + M]) { f = 0; use_his = 1; }\n\t\tif(al[i] + ar[i] != 0) f = 0;\n\t}\n\tif(cnt == 1 && use_his) f = 0;\n\t//f &= (cnt == 1);\n\tcout << (f ? \"YES\" : \"NO\") << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nint n,h,a[N],b[N],c[N],d[N];\n//是否存在可行流\nstruct edge{int f,t,g;}w[N];\nint s,t,S,T,head[N],nxt[N],I[N],O[N];\nvoid add(int f,int t,int g){\n\tstatic int cnt=1;\n\tw[++cnt]=(edge){f,t,g};\n\tnxt[cnt]=head[f];\n\thead[f]=cnt;\n\tw[++cnt]=(edge){t,f,0};\n\tnxt[cnt]=head[t];\n\thead[t]=cnt;\n}\nstruct st{\n\tint x,i,df;\n\tst(int X=0,int DF=0){x=X;i=head[x];df=DF;}\n}z[N];\nint top,flow,l[N];\n#define V z[top].x\n#define E z[top].i\n#define F z[top].df\nvoid change(){\n\tint df=F;flow+=df;\n\tfor (int i=top-1;i;i--){\n\t\tw[z[i].i].g-=df;\n\t\tw[z[i].i^1].g+=df;\n\t\tz[i].df-=df;\n\t\tif (!z[i].df) top=i;\n\t}\n}\nqueue<int> Q;\nvoid bfs(){\n\tfor (int i=s;i<=t;i++) l[i]=0;\n\tl[s]=1;Q.push(s);\n\twhile (!Q.empty()){\n\t\tint v=Q.front();Q.pop();\n\t\tfor (int i=head[v];i;i=nxt[i])\n\t\tif (w[i].g&&!l[w[i].t]) l[w[i].t]=l[v]+1,Q.push(w[i].t);\n\t}\n}\nbool dinic(){\n\tbfs();\n\tif (!l[t]) return 0;\n\tz[top=1]=st(s,1e9);\n\twhile (top){\n\t\tif (V==t) change(),top--,E=nxt[E];else\n\t\tif (!E) l[V]=0,top--,E=nxt[E];else\n\t\tif (w[E].g&&l[w[E].t]==l[V]+1)\n\t\t\tz[top+1]=st(w[E].t,min(F,w[E].g)),top++;\n\t\telse E=nxt[E];\n\t}\n\treturn 1;\n}\nbool isI[N],isO[N],cir[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tint f=(c[i]?c[i]+h:a[i]),t=(d[i]?d[i]:b[i]+h);\n\t\tI[t]++;O[f]++;\n\t\tif (f==t) cir[f]=1;else isI[t]=1,isO[f]=1;\n\t}\n\tfor (int i=1;i<=h;i++) isI[i]=1,isO[i+h]=1;\n\tfor (int i=1;i<=2*h;i++)\n\t\tif (cir[i]&&(!isI[i]||!isO[i])) return puts(\"NO\"),0;\n\ts=0;S=h*2+1;T=S+1;t=T+1;\n\tadd(T,S,1e9);\n\tfor (int i=1;i<=2*h;i++){\n\t\tif (I[i]) add(s,i,I[i]);\n\t\tif (O[i]) add(i,t,O[i]);\n\t\tif (i>h) add(i,T,1e9);else add(S,i,1e9);\n\t}\n\twhile (dinic());\n\tputs(flow==n?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst long long INF = (1ll << 50);\nstruct graph {\n  typedef long long flow_type;\n  struct edge {\n    int src, dst;\n    flow_type capacity, flow;\n    size_t rev;\n  };\n  int n;\n  vector<vector<edge>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst, flow_type capacity) {\n    adj[src].push_back({src, dst, capacity, 0, adj[dst].size()});\n    adj[dst].push_back({dst, src, 0, 0, adj[src].size()-1});\n  }\n  flow_type max_flow(int s, int t, bool first=false) {\n    //if (first) {\n      for (int u = 0; u < n; ++u) // initialize\n      for (auto &e: adj[u]) e.flow = 0;\n    //}\n\n    vector<int> level(n), iter(n);\n    function<int(void)> levelize = [&]() { // foward levelize\n      level.assign(n, -1); level[s] = 0;\n      queue<int> Q; Q.push(s);\n      while (!Q.empty()) {\n        int u = Q.front(); Q.pop();\n        if (u == t) break;\n        for (auto &e: adj[u]) {\n          if (e.capacity > e.flow && level[e.dst] < 0) {\n            Q.push(e.dst);\n            level[e.dst] = level[u] + 1;\n          }\n        }\n      }\n      return level[t];\n    };\n    function<flow_type(int, flow_type)> augment = [&](int u, flow_type cur) {\n      if (u == t) return cur;\n      for (int &i = iter[u]; i < adj[u].size(); ++i) {\n        edge &e = adj[u][i], &r = adj[e.dst][e.rev];\n        if (e.capacity > e.flow && level[u] < level[e.dst]) {\n          flow_type f = augment(e.dst, min(cur, e.capacity - e.flow));\n          if (f > 0) {\n            e.flow += f;\n            r.flow -= f;\n            return f;\n          }\n        }\n      }\n      return flow_type(0);\n    };\n\n    flow_type flow = 0;\n    while (levelize() >= 0) {\n      fill(all(iter), 0);\n      for (flow_type f; (f = augment(s, INF)) > 0; )\n        flow += f;\n    }\n    return flow;\n  }\n};\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\n\nint MakeVertex(int a, int c) {\n  if (c == 0) return a;\n  return c+(H+1);\n}\n\nsigned main(){\n  cin >> N >> H;\n\n  int S = 0;\n  int S2 = S+1;\n  int T2 = S2+1;\n  int l1 = T2+1;\n  int l2 = l1+N;\n  int l3 = l2+2*(H+2);\n  int l4 = l3+2*(H+2);\n  int gr = l4+N;\n  int grL = gr+N;\n  int grR = grL+N;\n  int T = grR+1;\n  graph g(T+1);\n\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    //g.add_edge(S, l1+i, 1);\n    g.add_edge(S2, l1+i, 1);\n    g.add_edge(S, T2, 1);\n    \n    int u = MakeVertex(B[i], D[i]);\n    g.add_edge(l1+i, l2+u, 1);\n    int v = MakeVertex(A[i], C[i]);\n    g.add_edge(l3+v, l4+i, 1);\n\n    //g.add_edge(l4+i, T, 1);\n    g.add_edge(S2, T, 1);\n    g.add_edge(l4+i, T2, 1);\n  }\n\n  reps(i, l2, l3) {\n    int u = i - l2;\n    int v = (u >= H+1) ? u-(H+1) : u+H+1;\n    g.add_edge(l2+u, l3+v, N);\n  }\n\n  //g.add_edge(S, gr, N);\n  //g.add_edge(gr, T, N);\n\n  // g.add_edge(S, grL, 1);\n  g.add_edge(S2, grL, 1);\n  g.add_edge(S, T2, 1);\n\n  // g.add_edge(grR, T, 1);\n  g.add_edge(S2, T, 1);\n  g.add_edge(grR, T2, 1);\n\n  reps(h, 1, H+1) {\n    int v = MakeVertex(h, 0);\n    g.add_edge(l2+v, gr, N);\n    g.add_edge(gr, l3+v, N);\n    g.add_edge(l2+v, grR, 1);\n    g.add_edge(grL, l3+v, 1);\n  }\n\n  LL a = g.max_flow(S2, T2, true);\n  LL b = g.max_flow(S, T2);\n  LL c = g.max_flow(S2, T);\n  LL d = g.max_flow(S, T);\n  //cout \n  //<< a << \",\" \n  //<< b << \",\"\n  //<< c << \",\"\n  //<< d << endl;\n\n  if (a+b == a+c && a+b == N*2+2) {\n    cout << \"YES\" << endl;\n    return 0;\n  }\n  cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nset<int> cntr[MAXN],cntl[MAXN];\nint sl[MAXN],sr[MAXN];\nint n,h,lenl,lenr,fa[MAXN];\nint get_fa(int x){\n\tif(fa[x]==0)\n\t\treturn x;\n\tfa[x]=get_fa(fa[x]);\n\treturn fa[x];\n}\t\nint main(){\n\tSF(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d%d%d%d\",&lenl,&lenr,&sl[i],&sr[i]);\n\t\tif(sl[i]==0)\n\t\t\tcntr[lenl].insert(i);;\n\t\tif(sr[i]==0)\n\t\t\tcntl[lenr].insert(i);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(sl[i]!=0){\n\t\t\tint x=sl[i];\n\t\t\tif(cntl[x].size()==0){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbool flag=0;\n\t\t\tset<int>::iterator it=cntl[x].begin();\n\t\t\tfor(;it!=cntl[x].end();it++){\n\t\t\t\tint y=*it;\n\t\t\t\tif(get_fa(i)!=get_fa(y)){\n\t\t\t\t\tfa[get_fa(i)]=get_fa(y);\n\t\t\t\t\tflag=1;\n\t\t\t\t\tcntl[x].erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==0){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\t\n\t\t\t}\n\t\t}\n\t\tif(sr[i]!=0){\n\t\t\tint x=sr[i];\n\t\t\tif(cntr[x].size()==0){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbool flag=0;\n\t\t\tset<int>::iterator it=cntr[x].begin();\n\t\t\tfor(;it!=cntr[x].end();it++){\n\t\t\t\tint y=*it;\n\t\t\t\tif(get_fa(i)!=get_fa(y)){\n\t\t\t\t\tfa[get_fa(i)]=get_fa(y);\n\t\t\t\t\tflag=1;\n\t\t\t\t\tcntr[x].erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==0){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\t\n\t\t\t}\n\t\t}\n\t}\n\tPF(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pll pair<ll,ll>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pii pair<int,int>\n#define mk make_pair\n#define pb push_back\n#define eps 1e-12\n#define MAXN 200009\nusing namespace std;\nint indeg[700],outdeg[700],presen[700],par[700];\ninline int parent(int pos)\n{\n\tif(par[pos]!=pos)\n\t{\n\t\tpar[pos]=parent(par[pos]);\n\t}\n\treturn par[pos];\n}\nbool comp[700];\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint n;\n\tcin>>n;\n\tint h;\n\tcin>>h;\n\tint a[n+1],b[n+1],c[n+1],d[n+1];\n\tfor(int i=0;i<=600;i++)\n\t{\n\t\tpar[i]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tint ff=-1,ss=-1;\n\t\tif(c[i]==0)\n\t\t{\n\t\t\tff=250+a[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tff=c[i];\n\t\t}\n\t\tif(d[i]==0)\n\t\t{\n\t\t\tss=b[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tss=250+d[i];\n\t\t}\n\t\toutdeg[ff]++;\n\t\tindeg[ss]++;\n\t\tpresen[ff]=1;\n\t\tpresen[ss]=1;\n\t\tint p1=parent(ff);\n\t\tint p2=parent(ss);\n\t\tif(p1!=p2)\n\t\t{\n\t\t\tpar[max(p1,p2)]=min(p1,p2);\n\t\t}\n\t}\n\tbool flag=true;\n\tint ans1=0;\n\tfor(int i=1;i<=250;i++)\n\t{\n\t\tif(presen[i])\n\t\t{\n\t\t\tif(outdeg[i]!=indeg[i])\n\t\t\t{\n\t\t\t\tif(outdeg[i]>indeg[i])\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans1+=indeg[i]-outdeg[i];\n\t\t\t\t\tcomp[parent(i)]=true;\n\t\t\t\t\t//cout<<ans1<<\"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans2=0;\n\tfor(int i=251;i<=500;i++)\n\t{\n\t\tif(presen[i])\n\t\t{\n\t\t\tif(outdeg[i]!=indeg[i])\n\t\t\t{\n\t\t\t\tif(outdeg[i]<indeg[i])\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans2+=outdeg[i]-indeg[i];\n\t\t\t\t\tif(!comp[parent(i)])\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//cout<<ans2<<\"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=500;i++)\n\t{\n\t\tif(presen[i])\n\t\t{\n\t\t\tif(!comp[parent(i)])\n\t\t\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<ans1<<\" \"<<ans2<<\" \"<<flag<<\"\\n\";\n\tif(ans1!=ans2)\n\t{\n\t\tflag=false;\n\t}\n\tif(ans1==0)\n\t{\n\t\tflag=false;\n\t}\n\tif(flag)\n\t{\n\t\tcout<<\"YES\\n\";\n\t}\n\telse\n\t{\n\t\tcout<<\"NO\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\n#define mp make_pair\n#define ni(x) scanf(\"%d\", &(x))\n#define nii(x,y) scanf(\"%d%d\",&(x),&(y))\n#define mul(x,y) ((ll)(x)*(y)%mod)\n#define mtp make_tuple\n#define F(i,n) for(int i = 0; i < (n); i++)\n#define FF(i,n) for(int i = 1; i <= (n); i++)\n#define FE(i,n) for(int i = 0; i <= (n); i++)\n\n#ifndef __GNUG__\nint __builtin_popcount(int n) {\n\tint x = 0;\n\twhile (n)n -= n&(-n), x++;\n\treturn x;\n}\n#endif\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int mod = 1000000007;\nconst int inf = 2012345678;\nconst ll infl = 9012345678901234567;\nconst double pi = 3.1415926535897932384626433832795;\n//----------------------------------------------------------------------------//\n\nconst int N = 100000 + 1000;\n\nvector<int> adj[N], rev[N];\nint ord[N], clk, scc[N], ind[N], chk[N], ccn;\n\nvoid dfs1(int u) {\n\tchk[u] = 1;\n\tfor (auto &x : rev[u]) {\n\t\tif (chk[x])continue;\n\t\tdfs1(x);\n\t}\n\tord[clk++] = u;\n}\nvoid dfs2(int u) {\n\tchk[u] = 1;\n\tscc[u] = ccn;\n\tfor (auto &x : adj[u]) {\n\t\tif (chk[x])continue;\n\t\tdfs2(x);\n\t}\n}\n\nint main() {\n#ifndef __GNUG__\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n, h; nii(n, h);\n\tF(i, n) {\n\t\tint a, b, c, d; nii(a, b); nii(c, d);\n\t\tif (c == 0) {\n\t\t\tadj[n - 1 + a].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tadj[n + h - 1 + c].push_back(i);\n\t\t}\n\t\tif (d == 0) {\n\t\t\tadj[i].push_back(n + h - 1 + b);\n\t\t}\n\t\telse {\n\t\t\tadj[i].push_back(n - 1 + d);\n\t\t}\n\t}\n\tint S = n + 2 * h;\n\tint T = S + 1;\n\tadj[T].push_back(S);\n\tFF(i, h)adj[S].push_back(n - 1 + i);\n\tFF(i, h)adj[n + h - 1 + i].push_back(T);\n\n\tint vn = n + 2 * h + 2;\n\tF(i, vn)for (auto &x : adj[i])rev[x].push_back(i);\n\tF(i, vn)if (!chk[i])dfs1(i);\n\tF(i, vn)chk[i] = 0;\n\tfor (int i = vn - 1; i >= 0; i--) {\n\t\tint j = ord[i];\n\t\tif (chk[j])continue;\n\t\tdfs2(j);\n\t\tccn++;\n\t}\n\tF(i, n) {\n\t\tif (scc[i] != scc[S])return puts(\"NO\"), 0;\n\t\tif (scc[adj[i][0]] != scc[S])return puts(\"NO\"), 0;\n\t\tif (scc[rev[i][0]] != scc[S])return puts(\"NO\"), 0;\n\t}\n\tif (scc[T] != scc[S])return puts(\"NO\"), 0;\n\tF(i, vn)for (auto &x : adj[i])ind[x]++;\n\t\n\tbool X = false, Y = false;;\n\tFF(i, h) {\n\t\tif (ind[n - 1 + i] - 1 > (int)adj[n - 1 + i].size())return puts(\"NO\"), 0;\n\t\tif (ind[n - 1 + i] - 1 != adj[n - 1 + i].size())X = true;\n\t\tif (ind[n + h - 1 + i] < (int)adj[n + h - 1 + i].size() - 1)return puts(\"NO\"), 0;\n\t\tif (ind[n + h - 1 + i] != adj[n + h - 1 + i].size() - 1)Y = true;\n\t}\n\tif (!X || !Y) return puts(\"NO\"), 0;\n\tputs(\"YES\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 1005;\n\nint n, m, deg[MAXN], ans = 1, f[MAXN], v[MAXN], e[MAXN];\n\ninline int Find(int x) { while (x ^ f[x]) x = f[x] = f[f[x]]; return x; }\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), m = Read();\n\tfor (int i = 1; i <= 1000; i ++)\n\t\tf[i] = i;\n\twhile (n --)\n\t{\n\t\tint a = Read(), b = Read(), c = Read(), d = Read(), x = (!c ? a : -c) + 500, y = (!d ? -b : d) + 500;\n\t\tf[Find(x)] = Find(y);\n\t\tdeg[x] ++; deg[y] --; v[x] = 1;\n\t}\n\tfor (int i = 0; i < 500; i ++)\n\t\tif (deg[i] > 0)\n\t\t\tans = 0;\n\tfor (int i = 501; i <= 1000; i ++)\n\t\tif (deg[i] < 0)\n\t\t\tans = 0;\n\tfor (int i = 1; i <= 1000; i ++)\n\t\tv[Find(i)] |= v[i], e[Find(i)] |= deg[i] != 0;\n\tfor (int i = 1; i <= 1000; i ++)\n\t\tif (Find(i) == i && v[i] && !e[i])\n\t\t\tans = 0;\n\treturn puts(ans ? \"YES\" : \"NO\"), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//AtCoder Grand Contest 017 E - Jigsaw\n\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint qr(){int ret = 0,f=1;char ch =getchar();while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();return ret*f;}\n\n#define maxN 100005\n#define maxH 205\n\nint indegree[maxH<<2],outdegree[maxH<<2];\nint active[maxH<<2];\nvoid read(int x,int y){\n    indegree[y]++;\n    outdegree[x]++;\n}\nint f[maxH<<1];\nvoid init(){\n    for(int i = 1;i<=(maxH<<1);i++)\n        f[i] = i;\n}\nint gf(int x){\n    if(f[x] == x) return x;\n    else return f[x] = gf(f[x]);\n}\nint mer(int x,int y){\n    x = gf(x);y = gf(y);\n    if(x == y) return 0;\n    f[x] = y;\n    return 1;\n}\nint main(){\n    init();\n    int N = qr(),H = qr();\n    int NN = 0;\n    int t1,t2,t3,t4,t5,t6;//上 t + maxN 下 t + maxN + maxH\n    for(int i = 1;i<=N;i++){\n        t1 = qr(),t2 = qr(),t3 = qr(),t4 = qr();\n        if(!t3) t5 = t1+H;else t5 = -t3+H;\n        if(!t4) t6 = -t2+H;else t6 = t4+H;\n        indegree[t6]++;\n        outdegree[t5]++;\n        if(!active[t5])\n            NN++;\n        if(!active[t6])\n            NN++;\n        active[t5] = active[t6] = 1;\n        NN -= mer(t5,t6);\n    }\n    if(NN!=1){\n        cout << \"NO\";\n        return 0;\n    }\n    int mark=1;\n    for(int i = 0;i<=H;i++){\n        if(indegree[i]<outdegree[i])\n            mark=0;\n    }\n    for(int i = H+1;i<=(H<<1);++i){\n        if(indegree[H+i]>outdegree[H+i])\n            mark=0;\n    }\n    if(mark)\n        cout << \"YES\";\n    else cout << \"NO\";\n    /*\n    int a=0,b=0;\n    for(int i = maxN;i<=maxN + 500;i++){\n        if(indegree[i] == outdegree[i])\n            continue;\n        else {\n            if(abs(indegree[i]-outdegree[i])!=1) {cout << \"NO\";return 0;}\n            else {\n                //if(i<=maxN+maxH) {\n                    if(indegree[i] > outdegree[i])\n                        a++;\n                    else b++;\n                //}else{\n                //    if(indegree[i] > outdegree[i])\n                //        b++;\n                //    else a++;\n                //}\n            }\n            if(a == 2||b == 2){cout << \"NO\";return 0;}\n        }\n    }\n    if(a == b){cout << \"YES\";}\n    else {cout << \"NO\";}\n    */\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,H;\nvector<int> G[410],R[410];\nbool vis[410];\nvector<int> ele;\n\nvoid DFS(int v)\n{\n    if(vis[v])return;\n    vis[v] = true;\n    ele.push_back(v);\n    for(int i = 0; i < G[v].size(); i++)DFS(G[v][i]);\n    for(int i = 0; i < R[v].size(); i++)DFS(R[v][i]);\n    return;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&N,&H);\n    for(int i = 0; i < N; i++)\n    {\n        int a,b,c,d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        int s,t;\n        if(c == 0)s = a;\n        else s = c + 200;\n        if(d == 0)t = b + 200;\n        else t = d;\n        G[s].push_back(t);\n        R[t].push_back(s);\n    }\n\n    for(int i = 0; i < 410; i++)if(!vis[i])\n    {\n        if(G[i].size() == 0 && R[i].size() == 0)continue;\n        ele.clear();\n        DFS(i);\n        bool flag = true;\n        for(int j = 0; j < ele.size(); j++)\n        {\n            int now = ele[j];\n            if(G[now].size() == R[now].size())continue;\n            flag = false;\n            if(G[now].size() > R[now].size() && now >= 201)\n            {\n                printf(\"NO\\n\");\n                return 0;\n            }\n            if(G[now].size() < R[now].size() && now < 201)\n            {\n                printf(\"NO\\n\");\n                return 0;\n            }\n        }\n        if(flag)\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"YES\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef long long ll;\n#define N 200002\nstruct edge{int to,nxxt;}e[N<<1];\nint n,H,a[N][4],head[N],cnt=1,b[N][2],f[N],rd[N],cd[N],ct[N];\nvector<int>v[N];\ninline void ins(int u,int v){e[cnt].to=v;e[cnt].nxxt=head[u];head[u]=cnt++;}\nint getroot(int t){return f[t]==-1?t:f[t]=getroot(f[t]);}\nint main()\n{\n    scanf(\"%d%d\",&n,&H);\n    memset(f,-1,sizeof(f));\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d%d%d\",&a[i][0],&a[i][1],&a[i][2],&a[i][3]);\n        int x,y;\n        if(a[i][2]==0)x=a[i][0];else x=H+a[i][2];\n        if(a[i][3]==0)y=H+a[i][1];else y=a[i][3];\n        b[i][0]=x,b[i][1]=y;\n        if(x==y)ct[x]++;\n        ins(x,y),rd[y]++,cd[x]++;\n        x=getroot(x);y=getroot(y);\n        if(x^y)f[x]=y;\n    }\n    for(int i=1;i<=2*H;i++)v[getroot(i)].push_back(i);\n    //for(int i=1;i<=2*H;i++)printf(\"%d \",getroot(i));puts(\"rt\");\n    //for(int i=1;i<=2*H;i++)printf(\"%d \",cd[i]);puts(\"cd\");\n    //for(int i=1;i<=2*H;i++)printf(\"%d \",rd[i]);puts(\"rd\");\n    for(int i=1;i<=2*H;i++)\n    {\n        bool flag=false;\n        if(v[i].size()==1){if(ct[v[i][0]]){puts(\"NO\");return 0;}}\n        if(v[i].size()<=1)continue;\n        //printf(\"%d:\",i);\n        for(int j=0;j<v[i].size();j++)\n        {\n            int x=v[i][j];\n            if(rd[x]^cd[x]){flag=true;break;}\n        }//puts(\"\");\n        if(!flag){puts(\"NO\");return 0;}\n    }\n    bool flag=true;\n    for(int i=1;i<=H;i++)\n    {\n        if(cd[i]<rd[i]){flag=false;break;}\n    }\n    for(int i=H+1;i<=2*H;i++)\n    {\n        if(rd[i]<cd[i]){flag=false;break;}\n    }\n    if(flag)puts(\"YES\");else puts(\"NO\");\n}\n/*\n3 4\n1 1 0 0\n2 2 0 1\n3 3 1 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n, h;\n\nint f(int d, int u){\n\treturn d?(h+d):u;\n}\n\nint g(int d, int u){\n\treturn d?d:(h+u);\n}\n\nint out[410];\nint in[410];\nint par[410];\nint chk[410];\n\nint r(int x){return (par[x]==x)?x:(par[x]=r(par[x])); }\nvoid join(int a, int b){ par[r(a)]=r(b); }\n\nvoid In(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1; i<2*h; ++i) par[i]=i;\n\tfor(int i=1; i<=n; ++i){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x = f(c, c+a);\n\t\tint y = g(d, d+b);\n\t\tjoin(x, y);\n\t\tout[x]++; in[y]++;\n\t}\n}\n\nbool check(){\n\tfor(int i=1; i<=2*h-1; ++i){\n\t\tif(out[i] > in[i]){\n\t\t\tif(i > h) return 0;\n\t\t\tchk[r(i)]=1;\n\t\t}\n\t\tif(out[i] < in[i]){\n\t\t\tif(i <= h) return 0;\n\t\t}\n\t}\n\tfor(int i=1; i<=2*h-1; ++i) if(!chk[r(i)]) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tIn();\n\tputs(check()?\"YES\":\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <typename T> inline void rd(T& x) {\n\tint si = 1; char c = getchar(); x = 0;\n\twhile(!isdigit(c)) si = c == '-' ? -1 : si, c = getchar();\n\twhile(isdigit(c)) x = x * 10 + c - 48, c = getchar();\n\tx *= si;\n}\ntemplate <typename T, typename... Args>\ninline void rd(T& x, Args&... args) { rd(x); rd(args...); }\n#define fi first\n#define se second\n#define mkp std::make_pair\ntypedef long long ll;\ntypedef double ff;\ntypedef std::pair <int, int> pii;\nconst int kN = 4e5 + 5, kInf = 0x3f3f3f3f;\nconst ll kMod = 998244353, kInfLL = 0x3f3f3f3f3f3f3f3fLL;\n\nint n, H, cnt[kN], dg[kN], fa[kN], siz[kN]; bool flag = true;\nvoid Add(int u, int v) { ++dg[u]; --dg[v]; }\nint Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); }\nvoid Merge(int u, int v) {\n\tint f_u = Find(u), f_v = Find(v);\n\tif(f_u == f_v) return;\n\tfa[f_u] = f_v; siz[f_v] += siz[f_u];\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\", \"r\", stdin);\n\tfreopen(\"a.out\", \"w\", stdout);\n#endif\n\tint T = 1; //rd(T);\n\twhile(T--) {\n\t\trd(n, H);\n\t\tfor(int i = 1; i <= 4 * H; ++i) fa[i] = i, siz[i] = 1;\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tint A, B, C, D, d1, d2, d3; rd(A, B, C, D);\n\t\t\td1 = C ? H + C : A; d2 = D ? 3 * H + D : 2 * H + B;\n\t\t\td3 = D ? D : H + B;\n\t\t//\tprintf(\"A: (%d %d)\\n\", d1, d2);\n\t\t//\tprintf(\"B: (%d %d)\\n\", d2, d3);\n\t\t\tMerge(d1, d2); Merge(d2, d3);\n\t\t\tAdd(d1, d2); Add(d2, d3);\n\t\t}\n\t\t//for(int i = 1; i <= 4 * H; ++i) printf(\"%d \", Find(i));\n\t\t//printf(\"\\n\");\n\t\tfor(int i = 1; i <= 4 * H; ++i) {\n\t\t\t//printf(\"%d \", dg[i]);\n\t\t\tif((dg[i] > 0 && i > H) || (dg[i] < 0 && (i > 2 * H || i <= H))) {\n\t\t\t\tflag = false; break;\n\t\t\t\t//printf(\"?\");\n\t\t\t}\n\t\t\tif(dg[i]) ++cnt[Find(i)];\n\t\t}\n\t\t//printf(\"\\n\");\n\t\t/*for(int i = 1; i <= 4 * H; ++i) if(Find(i) == i) {\n\t\t\tprintf(\"%d %d %d %d\\n\", i, cnt1[i], cnt2[i], siz[i]);\n\t\t}*/\n\t\tfor(int i = 1; i <= 4 * H; ++i)\n\t\t\tif(Find(i) == i && siz[i] > 1 && !cnt[i])\n\t\t\t\tflag = false;\n\t\tif(!flag) printf(\"NO\\n\");\n\t\telse printf(\"YES\\n\");\n\t} return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Jigsaw\n// * frank_c1\n// * 2017 / 11/ 07\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = (int)(1e5) + 5;\nint ai[maxn], bi[maxn], ci[maxn], di[maxn];\nint in[maxn], ou[maxn], vi[maxn];\nvector<int> nxt[maxn];\nint H, cnt, sgn;\n\nvoid dfs(int x) {\n\tvi[x] = 1; if (in[x] != ou[x]) sgn = 1; cnt += ou[x] - in[x];\n\tfor (int i = 0; i < (int)nxt[x].size(); ++i) if (!vi[nxt[x][i]]) dfs(nxt[x][i]);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d%d\", &n, &H);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d%d%d%d\", &ai[i], &bi[i], &ci[i], &di[i]);\n\t\tint u = 0, v = 0;\n\t\tif (!ci[i]) u = ai[i]; else u = ci[i] + H;\n\t\tif (!di[i]) v = bi[i] + H; else v = di[i];\n\t\t++ou[u]; ++in[v]; nxt[u].push_back(v); nxt[v].push_back(u);\n\t} int cnt = 0, e = 0;\n\tfor (int i = 1; i <= H; ++i) if (in[i] > ou[i]) return printf(\"NO\\n\"), 0; \n\tfor (int i = H + 1; i <= H + H; ++i) if (in[i] < ou[i]) return printf(\"NO\\n\"), 0;\n\tfor (int i = 1; i <= H + H; ++i) if (!vi[i] && in[i] + ou[i]) {\n\t\tcnt = sgn = 0; dfs(i); if (cnt || !sgn) return printf(\"NO\\n\"), 0;\n\t}\n\treturn printf(\"YES\\n\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> emp[2][205],bmp[2][205];\nbool vis[100005];\nint a[100005],c[100005],d[100005],b[100005];\nint n,h,gi;\n\nbool fille(int i)\n{\n    vis[i] = true;\n    if(d[i]==0)\n    {\n        for(int j=0;j<emp[1][b[i]].size();++j)\n        {\n\n            if(vis[emp[1][b[i]][j]]) continue;\n            return fille(emp[1][b[i]][j]);\n        }\n        return true;\n    }else\n    {\n        for(int j=0;j<emp[0][d[i]].size();++j)\n        {\n            if(vis[emp[0][d[i]][j]])continue;\n            return fille(emp[0][d[i]][j]);\n        }\n        return false;\n    }\n}\n\nbool fillb(int i)\n{\n    vis[i] = true;\n    if(c[i]==0)\n    {\n        for(int j=0;j<bmp[1][a[i]].size();++j){\n            if(vis[bmp[1][a[i]][j]]) continue;\n            if(!fillb(bmp[1][a[i]][j]))continue;\n        }\n        return fille(gi);\n    }else{\n        for(int j=0;j<bmp[0][c[i]].size();++j)\n        {\n            if(vis[bmp[0][c[i]][j]]) continue;\n            if(fillb(bmp[0][c[i]][j])) return true;\n        }\n        vis[i] = false;\n        return false;\n    }\n}\n\n\n\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        if(c[i]==0)\n        {\n            emp[0][a[i]].push_back(i);\n        }else emp[1][c[i]].push_back(i);\n        if(d[i]==0) bmp[0][b[i]].push_back(i);\n        else bmp[1][d[i]].push_back(i);\n    }\n    bool ag = true;\n    for(gi=0;gi<n;++gi)\n    {\n        if(vis[gi]||(c[gi]==0&&d[gi]==0)) continue;\n        if((!fillb(gi)))\n        {\n            ag= false;break;\n        }\n    }\n    if(ag) printf(\"YES\");\n    else printf(\"NO\");\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<b;++i)\n#define fj(a,b) for(int j=a;j<b;++j)\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> pii;\n///////////////////////\n\nint const N = 1e5 + 41;\nint const H = 241;\n\nint n, h, a[N], b[N], c[N], d[N];\nvector<pii> e[H][2];\nint pe[H][2], q;\npii v;\n\nvoid yes(){\n\tprintf(\"YES\\n\");\n\texit(0);\n}\n\npii getfrom(int a, int c){\n\tif(c == 0){\n\t\treturn mp(a, 1);\n\t}else{\n\t\treturn mp(c, 0);\n\t}\n}\n\npii getto(int a, int c){\n\tif(c == 0){\n\t\treturn mp(a, 0);\n\t}else{\n\t\treturn mp(c, 1);\n\t}\n}\n\nvoid dfs(pii x){\n\tv = x;\n\tint p = pe[x.first][x.second];\n\twhile(pe[x.first][x.second] < sz(e[x.first][x.second])){\n\t\tpii y = e[x.first][x.second][pe[x.first][x.second]];\n\t\t++pe[x.first][x.second];\n\t\t++q;\n\t\tdfs(y);\n\t}\n}\n\nvoid solve(){\n\tfi(0, n){\n\t\tpii x = getfrom(a[i], c[i]);\n\t\tpii y = getto(b[i], d[i]);\n\t\te[x.first][x.second].pb(y);\n\t}\n\tfi(1, h+1){\n\t\tmemset(pe, 0, sizeof(pe));\n\t\tq = 0;\n\t\tdfs(mp(i, 1));\n\t\tif(q == n && v.second == 0) yes();\n\t}\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\t\n\tscanf(\"%d %d\",&n,&h);\n\tfi(0, n){\n\t\tscanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\t}\n\n\tsolve();\n\n\tprintf(\"NO\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n,h,a,b,c,d,num1,num2;\nint can[401][401];\nint cnt[201][2][2];\nvector<int>v[401];\nbool have[401];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> h;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> a >> b >> c >> d;\n\t\tif(c==0){\n\t\t\tcnt[a][0][0]++;\n\t\t\tnum1=a*2-1;\n\t\t}\n\t\telse{\n\t\t\tcnt[c][0][1]++;\n\t\t\tnum1=c*2;\n\t\t}\n\t\tif(d==0){\n\t\t\tcnt[b][1][0]++;\n\t\t\tnum2=b*2;\n\t\t}\n\t\telse{\n\t\t\tcnt[d][1][1]++;\n\t\t\tnum2=d*2-1;\n\t\t}\n\t\thave[num1]=true;\n\t\tcan[num1][num2]=true;\n\t}\n\tfor(int i=1; i<=h ;i++){\n\t\tif(cnt[i][0][0]<cnt[i][1][1] || cnt[i][1][0]<cnt[i][0][1]){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//check if every cycle visitable\n\tfor(int i=1; i<=2*h ;i++){\n\t\tfor(int j=1; j<=2*h ;j++){\n\t\t\tfor(int k=1; k<=2*h ;k++){\n\t\t\t\tcan[j][k]|=(can[j][i] && can[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=2; i<=2*h ;i+=2){\n\t\tif(!have[i]) continue;\n\t\tbool ok=false;\n\t\tfor(int j=1; j<=2*h ;j+=2){\n\t\t\tif(have[j] && can[j][i]){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[30000][6] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i;\n\t}\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4] && c[j][4] == 0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstring>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nint N,H,pal;\tint a,b,c,d;\nstruct line{int in,ch;}lines[100001];bool cam(line a,line b){return a.in>b.in;}\nbool v[100001];\nvoid solve(int no,int t)\n{\n\n\tif(t==N-1)\n\t{\n\t\tint st=0;while(v[st]!=0)st++;\n\t\tif((lines[st].in==-lines[no].ch&&lines[st].ch>0))\n\t\t\tpal=1;\n\t\telse if(lines[st].in>0&&lines[st].ch>0&&lines[no].ch>0)\n\t\t\tpal=1;\n\t\tif(pal)return;\n\t}\n\telse\n\t{\n\t\tint st=0;\n\t\twhile(lines[st].in!=-lines[no].ch)st++;\n\n\t\tfor(int i=st;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0)\n\t\t\t{\tv[i]=1;\n\t\t\t\tsolve(i,t+1);\n\t\t\t\tv[i]=0;\n\t\t\t\tif(pal)return;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(lines[no].ch>0)\n\t\t{\n\t\t\tfor(int i=0;i<N&&lines[i].in>0;i++)\n\t\t\t{\n\t\t\t\tif(v[i]==0)\n\t\t\t\t{\tv[i]=1;\n\t\t\t\t\tsolve(i,t+1);\n\t\t\t\t\tv[i]=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\n\tpal=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta=c==0?a:-c;b=d==0?b:-d;\n\t\tlines[i].in=a;lines[i].ch=b;\n\t}\n\tsort(lines,lines+N,cam);\n\tfor(int i=0;i<N&&lines[i].in>0;i++)\n\t{\n\t\tv[i]=1;\n\t\tsolve(i,1);\n\t\tv[i]=0;\n\t\tif(pal)break;\n\t}\n\tif(pal)printf(\"YES\");\n\telse printf(\"NO\");\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100010;\nset<int> sl[210],sr[210];\nint n,H,A[N],B[N],C[N],D[N];\nbool done[N],doneL[N],doneR[N];\nint fa[N];\n\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\nvoid solve(int p)\n{\n    if(done[p]) return;done[p]=1;\n    if(C[p])\n    {\n        if(sr[C[p]].empty()) puts(\"NO\"),exit(0);\n        auto x=sr[C[p]].begin();\n        while(x!=sr[C[p]].end()&&find(*x)==find(p)) x++;\n        if(x==sr[C[p]].end()) puts(\"NO\"),exit(0);\n        fa[find(*x)]=find(p);\n        doneL[p]=1;solve(*x);\n    }\n    if(D[p])\n    {\n        if(sl[D[p]].empty()) puts(\"NO\"),exit(0);\n        auto x=sl[D[p]].begin();\n        while(x!=sl[D[p]].end()&&find(*x)==find(p)) x++;\n        if(x==sl[D[p]].end()) puts(\"NO\"),exit(0);\n        fa[find(*x)]=find(p);\n        doneR[p]=1;solve(*x);\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&H);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d%d%d\",A+i,B+i,C+i,D+i);\n        if(C[i]==0) sl[A[i]].insert(i),doneL[i]=1;\n        if(D[i]==0) sr[B[i]].insert(i),doneR[i]=1;\n    }\n    for(int i=1;i<=n;i++) fa[i]=i;\n    for(int i=1;i<=n;i++)\n        if(!done[i]) solve(i);\n    for(int i=1;i<=n;i++)\n        if(!doneL[i]||!doneR[i]) return !puts(\"NO\");\n    return !puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 512\n#define ll long long\n#define misaka 250\n#define rep(i, h) for (int i = misaka - h; i <= h + misaka; i++) if (i)\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0')ch=='-'&&(f=0)||(ch=getchar());\n\twhile(ch<='9'&&ch>='0')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint fa[N], sz[N], out[N], ini[N], vis[N];\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nvoid merge(int x, int y) {\n\tint xx = find(x), yy = find(y);\n\tif (xx == yy) ++ sz[xx];\n\telse fa[xx] = yy, sz[yy] += sz[xx] + 1;\n}\nint main(int argc, char const *argv[]) {\n\tint n = read(), h = read();\n\trep(i, h) fa[i] = i, sz[i] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint a = read(), b = read(), c = read(), d = read();\n\t\tint x = (c ? -c : a) + misaka;\n\t\tint y = (d ? d : -b) + misaka;\n\t\tout[x] ++; ini[y] ++;\n\t\tmerge(x, y);\n\t}\n\tfor (int i = 1 + misaka; i <= h + misaka; i++)\n\t\tif (out[i] < ini[i]) return puts(\"NO\") & 0;\n\tfor (int i = misaka - h; i <= misaka - 1; i++)\n\t\tif (ini[i] < out[i]) return puts(\"NO\") & 0;\n\trep(i, h) vis[find(i)] |= (out[i] != ini[i]);\n\trep(i, h)\n\t\tif (sz[find(i)] > 1 && find(i) == i && !vis[i])\n\t\t\treturn puts(\"NO\") & 0;\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\n\nconst int MAXN = (200 + 10) * 2;\n\nclass no_solution : public std::exception\n{\npublic:\n\tconst char * what(void) const noexcept\n\t{\n\t\treturn \"no solution reachable\";\n\t}\n};\n\nnamespace disjointSet\n{\nint fa[MAXN];\n\nvoid init()\n{\n\tmemset(fa, 0x00, sizeof fa);\n}\n\nint find(int x)\n{\n\tif(fa[x])\n\t\treturn fa[x] = find(fa[x]);\n\treturn x;\n}\n\nvoid merge(int x, int y)\n{\n\tx = fa[x], y = fa[y];\n\tif(x != y)\n\t\tfa[x] = y;\n}\n\n}\n\nbool loop[MAXN];\nint inDeg[MAXN], outDeg[MAXN];\nint N, H;\n\nvoid solve()\n{\n\tfor(int i = 0; i <= 2 * H; i++)\n\t{\n\t\tif(i > H)\n\t\t\tif(inDeg[i] > outDeg[i])\n\t\t\t\tthrow no_solution();\n\t\tif(i < H)\n\t\t\tif(outDeg[i] > inDeg[i])\n\t\t\t\tthrow no_solution();\n\n\t\tbool found = false, isLoop = loop[i];\n\n\t\tfor(int j = 0; j <= 2 * H; j++)\n\t\t\tif(found)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tif(disjointSet::find(i) == disjointSet::find(j))\n\t\t\t\t{\n\t\t\t\t\tif(i != j)\n\t\t\t\t\t\tisLoop = true;\n\t\t\t\t\tif(inDeg[j] != outDeg[j])\n\t\t\t\t\t\tfound = true;\n\t\t\t\t}\n\n\t\tif(!found && isLoop)\n\t\t\tthrow no_solution();\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(nullptr);\n\n\tcin >> N >> H ;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tint a, b, c, d, L, R;\n\t\tcin >> a >> b >> c >> d;\n\t\tL = c ? H - c : H + a;\n\t\tR = d ? H + d : H - b;\n\t\tdisjointSet::merge(L, R);\n\t\tinDeg[R]++, outDeg[L]++;\n\n\t\tif(L == R)\n\t\t\tloop[L] = true;\n\t}\n\n\n\ttry\n\t{\n\t\tsolve();\n\t\tcout << \"YES\" << endl;\n\t}\n\tcatch(std::exception & x)\n\t{\n\t\tcout << \"NO\" << endl ;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100050\nusing namespace std;\nint n,h;\nstruct node{\n\tint a,b,c,d;\n}q[N];\nint ld[233],lu[233],rd[233],ru[233],ds;\nint he[N],ne[N<<2],to[N<<2],tot=1;\nint ind[N],outd[N];\ninline void addedge(int x,int y){\n\tto[++tot]=y;ne[tot]=he[x];he[x]=tot;\n\t++outd[x];++ind[y];\n}\ninline void dfs(int g,int fa){\n\t\n}\nint main(){\n\tcin>>n>>h;\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d%d%d%d\",&q[i].a,&q[i].b,&q[i].c,&q[i].d);\n\tfor(int i=1;i<=h;++i)ld[i]=++ds;\n\tfor(int i=1;i<=h;++i)lu[i]=++ds;\n\tfor(int i=1;i<=h;++i)rd[i]=++ds;\n\tfor(int i=1;i<=h;++i)ru[i]=++ds;\n\tfor(int i=1;i<=n;++i){\n\t\tint pol,por;\n\t\tif(q[i].c){\n\t\t\taddedge(ru[q[i].c],ld[q[i].c]);\n\t\t\tpol=ld[q[i].c];\n\t\t}\n\t\telse pol=lu[q[i].a];\n\t\tif(q[i].d){\n\t\t\taddedge(rd[q[i].d],lu[q[i].d]);\n\t\t\tpor=rd[q[i].d];\n\t\t}\n\t\telse por=ru[q[i].b];\n\t\taddedge(pol,por);\n\t}\n\tint al=0;\n\tfor(int i=lu[1];i<=lu[h];++i)al+=outd[i]-ind[i];\n\tif(al<=0)return puts(\"NO\"),0;\n\tfor(int i=ru[1];i<=ru[h];++i)al+=outd[i]-ind[i];\n\tif(al)return puts(\"NO\"),0;\n\tfor(int i=ld[1];i<=ld[h];++i)if(ind[i]!=outd[i])return puts(\"NO\"),0;\n\tfor(int i=rd[1];i<=rd[h];++i)if(ind[i]!=outd[i])return puts(\"NO\"),0;\n\treturn puts(\"YES\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#define eps 1e-10\n#define inf 1e9\n#define For(i,j,k)\tfor(int i=j;i<=k;++i)\n#define Dow(i,j,k)\tfor(int i=k;i>=j;--i)\n#define ll long long\n#define y1 orz\nusing namespace std;\ninline ll read()\n{\n\tll t=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9')\t{if(c=='-')\tf=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')\tt=t*10+c-48,c=getchar();\n\treturn t*f;\n}\nint n,h,F[1001],deg[1001],hav[1001],is_father[1001];\ninline int get(int x){return x==F[x]?F[x]:F[x]=get(F[x]);}\nint x,y,x1,y1,tx,ty;\nint main()\n{\n\tn=read();h=read();\n\tFor(i,1,600)\tF[i]=i;\n\tFor(i,1,n)\t\n\t{\n\t\tx=read();y=read();x1=read();y1=read();\n\t\tif(x1==0)\ttx=x;else tx=-x1;\n\t\tif(y1==0)\tty=-y;else ty=y1;\n\t\ttx+=300;ty+=300;\n\t\tdeg[tx]++;deg[ty]--;hav[tx]=1;\n//\t\tcout<<tx<<' '<<ty<<endl;\n\t\tF[get(tx)]=get(ty);\n\t}\n\tFor(i,301,600)\tif(deg[i]<0)\t{puts(\"NO\");return 0;}\t\t\n\tFor(i,1,300)\tif(deg[i]>0)\t{puts(\"NO\");return 0;}\n\tFor(i,1,600)\t\n\t\thav[get(i)]|=hav[i];\n\tFor(i,1,600)\n\t\tif(deg[get(i)])is_father[get(i)]=1;\n\tFor(i,1,600)\t\n\t\tif(hav[i])\n\t\t\tif(F[i]==i&&!is_father[i])\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define nt(x) (x+h)\nnamespace Hao_Nan_A___Wo_Bu_Hui_A___Wo_Hao_Ruo_A\n{\n\tconst int N=101000,M=510;\n\tint ind[M],outd[M],q[N];\n\tint n,h,e;\n\tint ask(int p){return p==q[p]?p:q[p]=ask(q[p]);}\n\tvoid link(int u,int v){q[ask(u)]=ask(v);}\n\tvoid add(int x,int y)\n\t{\n//\t\tprintf(\"%d -> %d\\n\",x,y);\n\t\tind[y]++;outd[x]++;\n\t\tlink(x,y);\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d%d\",&n,&h);e=0;\n\t\tfor(int i=1;i<=h*2;i++)\n\t\t\tind[i]=outd[i]=0,q[i]=i;\n\t\tfor(int i=1,A,B,C,D,u,v;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\t\tif(C)u=nt(C);else u=A;\n\t\t\tif(D)v=D;else v=nt(B);\n\t\t\tadd(u,v);\n\t\t}\n\t}\n\tbool check()\n\t{\n\t\tstatic bool vis[M];\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=1;i<=h;i++)if(ind[i]>outd[i])return 0;\n\t\tfor(int i=1;i<=h;i++)if(ind[nt(i)]<outd[nt(i)])return 0;\n\n\t\tfor(int i=1;i<=h<<1;i++)\n\t\t\tif(ind[i]!=outd[i])vis[ask(i)]=1;\n\t\tfor(int i=1;i<=h<<1;i++)\n\t\t\tif(!vis[ask(i)] && (ind[i]||outd[i]))return 0;\n\t\treturn 1;\n\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tif(check())printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n}\nint main()\n{\n//\tfreopen(\"in\",\"r\",stdin);\n\tHao_Nan_A___Wo_Bu_Hui_A___Wo_Hao_Ruo_A::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 444;\n\nvector<int> E[MAX];\nbool bio[MAX];\n\nint inDeg[MAX];\nint outDeg[MAX];\nint N, H;\n\nvector<int> v;\n\nvoid dfs(int x) {\n  if (bio[x]) return;\n  bio[x] = true;\n  v.push_back(x);\n  for (int y: E[x]) dfs(y);\n}\n\nbool solve() {\n  REP(i, 2*H) {\n    if (!bio[i] && E[i].size()) {\n      v.clear();\n      dfs(i);\n      \n      bool haveStart = false;\n      bool haveEnd = false;\n      \n      int balance = 0;\n      for (int x: v) {\n        if (x < H) {\n          haveStart = true;\n          if (inDeg[x] > outDeg[x]) return false;\n          balance += outDeg[x] - inDeg[x];\n        } else {\n          haveEnd = true;\n          if (inDeg[x] < outDeg[x]) return false;\n          balance -= inDeg[x] - outDeg[x];\n        }\n      }\n      if (!haveStart || !haveEnd || balance != 0) return false;\n    }\n  }\n  return true;\n}\n\nint main(void) {\n  scanf(\"%d %d\", &N, &H);\n  REP(i, N) {\n    int A, B, C, D;\n    scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n\n    int u = C == 0 ? A-1 : H+C-1;\n    int v = D == 0 ? H+B-1 : D-1;\n\n    E[u].push_back(v);\n    E[v].push_back(u);\n    outDeg[u]++;\n    inDeg[v]++;\n  }\n\n  puts(solve() ? \"YES\" : \"NO\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nconst int N = 4e2 + 100;\nint f[N];\nint ff(int x) {\n\treturn f[x] == x ? x : f[x] = ff(f[x]);\n}\nint n, h;\nint in[N], ou[N], ok[N];\n\nint main() {\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tf[i] = i;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d, l, r;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tl = c == 0 ? h + a : c;\n\t\tr = d == 0 ? b : h + d;\n\t\t++ou[l], ++in[r];\n\t\tif (ff(l) != ff(r))\n\t\t\tf[ff(l)] = ff(r);\n\t}\n\tfor (int i = 1; i <= h; ++i)\n\t\tif (ou[i] > in[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = h + 1; i <= h + h; ++i)\n\t\tif (in[i] > ou[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (in[i] != ou[i])\n\t\t\tok[ff(i)] = true;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (ff(i) == i && !ok[i] && in[i] + ou[i] != 0)\n\t\t\treturn puts(\"NO\"), 0;\n\treturn puts(\"YES\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 100000\n#define MAXH 400\nusing namespace std;\nint N,H;\nint setfa[MAXH+5],cd[MAXH+5],rd[MAXH+5];\nint A[MAXN+5],B[MAXN+5],C[MAXN+5],D[MAXN+5];\nint ok[MAXH+5];\nvoid Init()\n{\n\tfor(int i=1;i<=MAXH;i++)\n\t\tsetfa[i]=i;\n}\nint Findfa(int x)\n{\n\tif(x==setfa[x])\n\t\treturn x;\n\treturn setfa[x]=Findfa(setfa[x]);\n}\nvoid Union(int x,int y)\n{\n\tint fx=Findfa(x),fy=Findfa(y);\n\tif(fx==fy)\n\t\treturn;\n\tsetfa[fx]=fy;\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d %d\",&N,&H);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&A[i],&B[i],&C[i],&D[i]);\n\t\tint x,y;\n\t\tif(C[i]==0)\tx=A[i];\n\t\telse\t\tx=C[i]+H;\n\t\tif(D[i]==0)\ty=B[i]+H;\n\t\telse\t\ty=D[i];\n\t\tcd[x]++,rd[y]++;\n\t\tUnion(x,y);\n\t}\n\tbool legal=true;\n\tfor(int i=1;i<=MAXH;i++)\n\t{\n\t\tint fi=Findfa(i);\n\t\tif(cd[fi]==0&&rd[fi]==0)\n\t\t\tcontinue;\n\t\tif(cd[i]!=rd[i])\n\t\t{\n\t\t\tif(cd[i]>rd[i]&&i>H)\n\t\t\t\tlegal=false;\n\t\t\telse if(cd[i]<rd[i]&&i<=H)\n\t\t\t\tlegal=false;\n\t\t\tok[fi]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=MAXH;i++)\n\t{\n\t\tint fi=Findfa(i);\n\t\tif(cd[fi]!=0||rd[fi]!=0)\n\t\t\tif(ok[fi]==false)\n\t\t\t{\n\t\t\t\tlegal=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif(legal==true)\n\t\tprintf(\"YES\\n\");\n\telse\n\t\tprintf(\"NO\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MX=100010, inf=2e9;\n\nint n, h;\nmap<pii, int> indeg, outdeg;\n\nbool solve(){\n    int cnt1=0, cnt2=0;\n    bool ex1=false, ex2=false;\n    for(int i=1; i<=h; i++){\n        pii a=pii(0,i), b=pii(i,h);\n        if(indeg[a]<outdeg[a]) return false;\n        if(outdeg[b]<indeg[b]) return false;\n        int x=max(0, indeg[a]-outdeg[a]);\n        int y=max(0, outdeg[b]-indeg[b]);\n        cnt1+=x, cnt2+=y;\n        outdeg[a]+=x, indeg[b]+=y;\n        ex1|=(indeg[a]!=0); ex2|=(indeg[b]!=0);\n    }\n    if(cnt1!=cnt2 || !ex1 || !ex2) return false;\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin>>n>>h; h++;\n    for(int i=1; i<=n; i++){\n        int a, b, c, d; cin>>a>>b>>c>>d;\n        if(c>0) a=h;\n        if(d>0) b=h;\n        outdeg[(c==0 ? pii(a,h) : pii(0,c))]++;\n        indeg[pii(d,b)]++;\n    }\n    cout<<(solve() ? \"YES\" : \"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=1e5+5;\nint n,h,cl[N],cr[N],d[N],fa[N];\nint getfa(int x){return fa[x]?fa[x]=getfa(fa[x]):x;}\nbool bz[N],exi[N];\nvoid link(int u,int v)\n{\n\t--d[u],++d[v];\n\tint fu=getfa(u),fv=getfa(v);\n\tif(fu!=fv) fa[fv]=fu;\n}\nint main()\n{\n\tn=read(),h=read();\n\tfo(i,1,n)\n\t{\n\t\tint x,y,A=read(),B=read(),C=read(),D=read();\n\t\tif(C) x=-C;else x=A;\n\t\tif(D) y=D;else y=-B;\n\t\tx+=h,y+=h,exi[x]=exi[y]=1;\n\t\tlink(x,y);\n\t}\n\tfo(i,0,h) if(d[i]<0) return puts(\"NO\"),0;\n\tfo(i,h+1,h+h) if(d[i]>0) return puts(\"NO\"),0;\n\tfo(i,0,h+h) if(d[i]) bz[i]=1;\n\tfo(i,0,h+h) bz[getfa(i)]|=bz[i];\n\tfo(i,0,h+h)\n\t\tif(i==getfa(i) && exi[i] && !bz[i]) return puts(\"NO\"),0;\n\treturn puts(\"YES\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[10000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n\nconst int N = 400 + 10;\n\nint n, deg[N];\n\nint anc[N], cnt[N], mask[N];\n\nint find(int x) { return anc[x] == x ? x : (anc[x] = find(anc[x])); }\n\nvoid init() {\n  int m;\n  scanf(\"%d%d\", &m, &n);\n  std::iota(anc, anc + 2 * n + 1, 0);\n  for (int i = 1; i <= n; ++i) mask[i] = 1, mask[i + n] = 2;\n  while (m--) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    int x = c ? (c + n) : a, y = d ? d : (b + n);\n    ++cnt[x], ++cnt[y];\n    --deg[x], ++deg[y];\n    anc[find(x)] = find(y);\n  }\n}\n\nint main() {\n  init();\n  for (int i = 1; i <= n; ++i) if (deg[i] > 0 || deg[i + n] < 0) return puts(\"NO\"), 0;\n  for (int i = 1; i <= 2 * n; ++i) mask[find(i)] |= deg[i];\n  for (int i = 1; i <= n; ++i) if (find(i) == i && cnt[i] && !mask[i]) return puts(\"NO\"), 0;\n  puts(\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 100005\n#define M 405\nusing namespace std;\nbool bz[N];\nint cd[M],rd[M],n,num,f[M],h,m,v1[M],v2[M];\nint getf(int k)\n{\n\tif(f[k]==k||!f[k]) return k;\n\treturn (f[k]=getf(f[k]));\n}\nint main()\n{\n\tcin>>n>>h;\n\tfo(i,1,n)\n\t{\n\t\tint a,b,c,d,x,y;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=(c>0)?c:(a+200);\n\t\ty=(d>0)?(d+200):b;\n\t\tcd[x]++,rd[y]++;\n\t\tint fx=getf(x),fy=getf(y);\n\t\tf[fx]=fy;\n\t}\n\tint w=0;\n\t\tbool pd=1;\n\t\tfo(i,1,400) \n\t\t{\n\t\t\tif(rd[i]>0||cd[i]>0)\n\t\t\t{\n\t\t\t\tint fa=getf(i);\n\t\t\t\tif(abs(rd[i]-cd[i])>1) \n\t\t\t\t{\n\t\t\t\t\tpd=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(rd[i]-cd[i]==-1) \n\t\t\t\t{\n\t\t\t\t\tv1[fa]++;\n\t\t\t\t\tif(i<=200)\n\t\t\t\t\t{\n\t\t\t\t\t\tpd=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rd[i]-cd[i]==1) \n\t\t\t\t{\n\t\t\t\t\tv2[fa]++;\n\t\t\t\t\tif(i>200)\n\t\t\t\t\t{\n\t\t\t\t\t\tpd=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pd)\n\t\tfo(i,1,400)\n\t\t{\n\t\t\tif((rd[i]||cd[i])&&v1[getf(i)]==0) \n\t\t\t{\n\t\t\t\tpd=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pd) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\nint n,h;\nint f[405],in[405],out[405],ok[405];\ninline int find(int x){\n\treturn f[x]==x?x:f[x]=find(f[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=0;i<=2*h;++i) f[i]=i;\n\tfor(int i=1,a,b,c,d;i<=n;++i){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint x=(c?-c:a)+h,y=(d?d:-b)+h;\n\t\t++out[x]; ++in[y]; f[find(x)]=find(y);\n\t}\n\tfor(int i=0;i<h;++i) if(out[i]>in[i]) return puts(\"NO\"),0;\n\tfor(int i=h+1;i<=2*h;++i) if(in[i]>out[i]) return puts(\"NO\"),0;\n\tfor(int i=0;i<=2*h;++i) if(out[i]!=in[i]) ok[find(i)]=1;\n\tfor(int i=0;i<=2*h;++i) if((in[i]||out[i])&&!ok[find(i)]) return puts(\"NO\"),0;\n\treturn puts(\"YES\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nint main() {\n\tint N, H;\n\tcin >> N >> H;\n\tvector<int> deg(2 * H + 1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint A, B, C, D;\n\t\tcin >> A >> B >> C >> D;\n\t\tif (C != 0) --deg[C + H];\n\t\telse --deg[-A + H];\n\t\tif (D != 0) ++deg[D + H];\n\t\telse ++deg[-B + H];\n\t}\n\tbool ok = true;\n\tfor (int i = -H; i <= H; ++i) {\n\t\tif (i > 0 && deg[i] > 0) ok = false;\n\t}\n\tcout << (ok ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[410], F[410];\nint Deg[410], n, H, m;\nvoid Make_Edge(int a, int b){\n    E[a].push_back(b);\n    F[b].push_back(a);\n    Deg[b]++;\n    Deg[a]--;\n}\nint v[410], cnt, SCC[410], ord[410];\nvoid DFS(int a){\n    int i;\n    v[a]=1;\n    for(i=0;i<E[a].size();i++){\n        if(!v[E[a][i]])DFS(E[a][i]);\n    }\n    ord[++cnt] = a;\n}\nvoid DFS2(int a){\n    int i;\n    SCC[a] = cnt;\n    for(i=0;i<F[a].size();i++){\n        if(!SCC[F[a][i]])DFS2(F[a][i]);\n    }\n}\nint main(){\n    int i, a, b, c, d;\n    scanf(\"%d%d\",&n,&H);\n    for(i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        if(!c && !d) Make_Edge(a, H+1+b);\n        if(!c && d)Make_Edge(a, d);\n        if(c && !d)Make_Edge(H+1+c, H+1+b);\n        if(c && d)Make_Edge(H+1+c, d);\n    }\n    for(i=0;i<=(H+1)*2;i++){\n        if((Deg[i] < 0 && i >= H+1) || (Deg[i] > 0 && i < H+1)){\n            printf(\"NO\\n\");\n            return 0;\n        }\n        while(Deg[i]!=0){\n            if(Deg[i] < 0)Make_Edge(0, i);\n            else Make_Edge(i, 0);\n        }\n    }\n    m = (H+1)*2;\n    for(i=0;i<=m;i++){\n        if(!v[i])DFS(i);\n    }\n    cnt = 0;\n    for(i=m+1;i>=1;i--){\n        if(!SCC[ord[i]]){\n            cnt++;\n            DFS2(ord[i]);\n        }\n    }\n    for(i=0;i<=m;i++){\n        if(!E[i].empty() && SCC[i] != SCC[0]){\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n    printf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> emp[2][205],bmp[2][205];\nbool vis[100005];\nint a[100005],c[100005],d[100005],b[100005];\nint n,h,gi,dep;\nbool efal;\nbool fille(int i)\n{\n    vis[i] = true;\n\n    if(d[i]==0)\n    {\n        for(int j=0;j<emp[1][b[i]].size();++j)\n        {\n\n            if(vis[emp[1][b[i]][j]]) continue;\n            return fille(emp[1][b[i]][j]);\n        }\n        return true;\n    }else\n    {\n        for(int j=0;j<emp[0][d[i]].size();++j)\n        {\n            if(vis[emp[0][d[i]][j]])continue;\n            return fille(emp[0][d[i]][j]);\n        }\n        return false;\n    }\n}\n\nbool fillb(int i)\n{\n    vis[i] = true;\n    if(c[i]==0)\n    {\n        for(int j=0;j<bmp[1][a[i]].size();++j){\n            if(vis[bmp[1][a[i]][j]]) continue;\n            if(fillb(bmp[1][a[i]][j])) return true;\n            if(efal){\n                efal = false;\n            }else return vis[i] = false;\n        }\n        if(!fille(gi)){\n            efal = true;\n            return vis[i] = false;\n        }\n        return true;\n    }else{\n        for(int j=0;j<bmp[0][c[i]].size();++j)\n        {\n            if(vis[bmp[0][c[i]][j]]) continue;\n            if(fillb(bmp[0][c[i]][j])) return true;\n            if(efal){\n                efal = false;\n            }else return vis[i] = false;\n        }\n        return vis[i] = false;\n    }\n}\n\n\n\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        if(c[i]==0)\n        {\n            emp[0][a[i]].push_back(i);\n        }else emp[1][c[i]].push_back(i);\n        if(d[i]==0) bmp[0][b[i]].push_back(i);\n        else bmp[1][d[i]].push_back(i);\n    }\n    bool ag = true;\n    for(gi=0;gi<n;++gi)\n    {\n        if(vis[gi]||(c[gi]==0&&d[gi]==0)) continue;\n        dep=0;efal = false;\n        if((!fillb(gi))||(!vis[gi]))\n        {\n            ag= false;break;\n        }\n    }\n    if(ag) printf(\"YES\");\n    else printf(\"NO\");\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2000500\nusing namespace std;\nint n,m,fa[N],vis[N],D[N],C[N];\nint gf(int x) {return fa[x]==x?x:fa[x]=gf(fa[x]);}\ninline int rd() {int r;scanf(\"%d\",&r);return r;}\nint main() {\n    n = rd(), m = rd();\n\n    for (int i=1;i<=1000;i++) fa[i] = i;\n    for (int _=1;_<=n;_++)  {\n        int x, y,a,b,c,d;\n        a = rd(), b = rd(), c = rd(), d = rd();\n        x=!c?a:-c; x+=500;\n        y=!d?-b:d; y+=500;\n        fa[ gf(x) ] = gf(y);\n        D[x]++, D[y]--, vis[x] = 1;\n    }\n\n    int flag = 1;\n    for (int i=1;i<500;i++) D[i]>0 ? flag=0 :0;\n    for (int i=501;i<=1000;i++) D[i]<0 ? flag=0 :0;\n    for (int i=1;i<=1000;i++) vis[gf(i)] |= vis[i];\n    for (int i=1;i<=1000;i++) if (D[i]) C[gf(i)] = 1;\n    for (int i=1;i<=1000;i++) if (fa[i]==i && !C[i]) flag = 0;\n    puts(flag?\"YES\":\"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define For(i,a,b) for (int i=a;i<=b;i++)\n#define Rep(i,a,b) for (int i=b;i>=a;i--)\n#define N 2000500\nusing namespace std;\nint n,m,fa[N],vis[N],D[N],C[N];\nint gf(int x) {return fa[x]==x?x:fa[x]=gf(fa[x]);}\ninline ll read()\n{\n    ll x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint main() \n{\n    n = read(), m = read();\n\tFor(i,1,1000)fa[i] = i;\n    For(i,1,n)\n\t{\n        int x, y,a,b,c,d;\n        a = read(), b = read(), c = read(), d = read();\n        x=!c?a:-c; x+=500;\n        y=!d?-b:d; y+=500;\n        fa[ gf(x) ] = gf(y);\n        D[x]++, D[y]--, vis[x] = 1;\n    }\n    int flag = 1;\n\tFor(i,1,499)D[i]>0 ? flag=0 :0;\n\tFor(i,501,1000)D[i]<0 ? flag=0 :0;\n\tFor(i,1,1000)vis[gf(i)] |= vis[i];\n    For(i,1,1000) if (D[i]) C[gf(i)] = 1;\n    For(i,1,1000) if (fa[i]==i && !C[i] && vis[i]) flag = 0;\n    puts(flag?\"YES\":\"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long  int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v])parent[u] = v;\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<vector<int>>uu(201, vector<int>(201));\n\tvector<vector<int>>us(201, vector<int>(201));\n\tvector<vector<int>>su(201, vector<int>(201));\n\tvector<vector<int>>ss(201, vector<int>(201));\n\tfor (int i = 0; i < N; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif (c&&d) {\n\t\t\tuu[c][d]++;\n\t\t}\n\t\telse if (c) {\n\t\t\tus[c][b]++;\n\t\t}\n\t\telse if (d) {\n\t\t\tsu[a][d]++;\n\t\t}\n\t\telse {\n\t\t\tss[a][b]++;\n\t\t}\n\t}\n\t//for (int i = 1; i <= 200; i++) {\n\t//\tus[i][i] = min(us[i][i], 1);\n\t//\tsu[i][i] = min(su[i][i], 1);\n\t//}\n\tvector<int>lu(201);\n\tvector<int>ld(201);\n\tvector<int>ru(201);\n\tvector<int>rd(201);\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tlu[i] += uu[i][j];\n\t\t\tlu[i] += us[i][j];\n\t\t\tld[i] += su[i][j];\n\t\t\tld[i] += ss[i][j];\n\t\t\tru[j] += uu[i][j];\n\t\t\tru[j] += su[i][j];\n\t\t\trd[j] += ss[i][j];\n\t\t\trd[j] += us[i][j];\n\t\t}\n\t}\n\tUnionFind uf(5000);\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tif (uu[i][j])uf.Unite(i + 1000, j);\n\t\t\tif (us[i][j])uf.Unite(i + 1000, j + 1000);\n\t\t\tif (su[i][j])uf.Unite(i, j);\n\t\t\tif (ss[i][j])uf.Unite(i, j + 1000);\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tif (ru[i] > ld[i]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif (ru[i] < ld[i])uf.Unite(2000, i);\n\t\tif (lu[i] > rd[i]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif (lu[i] < rd[i])uf.Unite(2000, i + 1000);\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tif ((lu[i] || rd[i]) && !uf.Check_Same(i + 1000, 2000)) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif ((ld[i] || ru[i]) && !uf.Check_Same(i, 2000)) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100005\n#define For(i,x,y) for(int i=x;i<=y;i++)\n#define Rep(i,x,y) for(int i=x;i>=y;i--)\n#define mp make_pair\n#define pa pair<ll,int>\nusing namespace std;\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+ch-48;\n\treturn f?-x:x;\n}\nint n,h,in[405],ou[405],fa[405];\nbool flag[405];\ninline int find(int x){return (fa[x]==x)?x:fa[x]=find(fa[x]);}\nint main(){\n\tn=read();h=read();\n\tFor(i,1,n){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint l=(c==0)?h+a:c;\n\t\tint r=(d==0)?b:h+d;\n\t\tin[r]++;ou[l]++;\n\t\tfa[find(l)]=find(r);\n\t}\n\tFor(i,1,h) if(ou[i]>in[i]){puts(\"NO\");return 0;}\n\tFor(i,h+1,h*2) if(ou[i]<in[i]){puts(\"NO\");return 0;}\n\tFor(i,1,h*2) if(in[i]!=ou[i]) flag[find(i)]=1;\n\tFor(i,1,h*2) if(find(i)==i&&!flag[i]&&in[i]+ou[i]!=0){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//84104971101048411497 - Can you guess what does this mean?\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> point;\n#define mapii map<int, int>\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define forit(it, var) for(__typeof(var.begin()) it = var.begin(); it != var.end(); it++)\n#define forrit(rit, var) for(__typeof(var.rbegin()) rit = var.rbegin(); rit != var.rend(); rit++)\n#define ii pair<int, int>\n#define iii pair<int, ii>\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define maxN 100005\n#define maxH 205\n#define oo 2000000007\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nint n, H, degIn[2][maxH], degOut[2][maxH];\n\nbool Solve() {\n    int sumIn = 0, sumOut = 0;\n    fto(i, 1, H) {\n        if (degIn[0][i] > degOut[0][i]) return false;\n        if (degIn[1][i] < degOut[1][i]) return false;\n        sumIn += degIn[1][i]-degOut[1][i];\n        sumOut += degOut[0][i]-degIn[0][i];\n    }\n    return (sumIn == sumOut && sumIn > 0);\n}\n\nint main () {\n    scanf(\"%d%d\", &n, &H);\n    fto(i, 1, n) {\n        int A, B, C, D;\n        scanf(\"%d%d%d%d\", &A, &B, &C, &D);\n\n        ii u, v;\n        if (C == 0) u = mp(0, A);\n        else u = mp(1, C);\n        if (D == 0) v = mp(1, B);\n        else v = mp(0, D);\n\n        ++degOut[u.ff][u.ss]; ++degIn[v.ff][v.ss];\n    }\n\n    puts((Solve()) ? \"YES\" : \"NO\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define neko 100010\n#define heko 410\n#define qwq return printf(\"YES\"),0; \n#define orz return printf(\"NO\"),0; \n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))\nstatic int n,H;\ntypedef int arr[heko];\narr fa,book,dgi,dgo,out;\nnamespace IO\n{\n\tconst unsigned int bufsize=1<<16,outsize=1<<24;\n\tstatic char ch[bufsize],*S=ch,*T=ch;\n\tinline char getc()\n\t{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\n\tstatic char Out[outsize],*nowp=Out;\n\tinline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\n\t\tvoid read(T &x)\n\t\t{\n\t\t\tchar c=getc();x=0;\n\t\t\tfor(;!isdigit(c);c=getc());\n\t\t\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n\t\t}\n\ttemplate<typename T>\n\t\tvoid write(T x,char c='\\n')\n\t\t{\n\t\t\tif(!x)*nowp++='0';\n\t\t\tstatic unsigned int stk[50],tp=0;\n\t\t\tfor(;x;x/=10)stk[++tp]=x%10;\n\t\t\tfor(;tp;*nowp++=stk[tp--]^'0');*nowp++=c;\n\t\t}\n}\nint find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}\nint main()\n{\n\tusing namespace IO;\n\tint x,y,z,o,X,Y;\n\tread(n),read(H);\n\tf(i,0,400)fa[i]=i;\n\tf(i,1,n)\n\t{\n\t\tread(x),read(y),read(z),read(o);\n\t\tif(z==0)X=200+x;\n\t\telse X=200-z;\n\t\tif(o==0)Y=200-y;\n\t\telse Y=200+o;\n\t\tbook[X]=book[Y]=1;\n\t\t++dgi[Y],++dgo[X];\n\t\tfa[find(Y)]=find(X);\n\n\t}\n\tf(i,0,200)if(dgi[i]<dgo[i])orz;\n\tf(i,201,400)if(dgi[i]>dgo[i])orz;\n\tf(i,0,400)if(dgi[i]^dgo[i])out[find(i)]=1;\n\tout[0]=1;\n\tf(i,0,400)if(book[i]&&!out[fa[i]])orz;\n\tqwq;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n\nconst int N = 400 + 10;\n\nint n, deg[N];\n\nint anc[N], cnt[N], mask[N];\n\nint find(int x) { return anc[x] == x ? x : (anc[x] = find(anc[x])); }\n\nvoid init() {\n  int m;\n  scanf(\"%d%d\", &m, &n);\n  std::iota(anc, anc + 2 * n + 1, 0);\n  while (m--) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    int x = c ? (c + n) : a, y = d ? d : (b + n);\n    ++cnt[x], ++cnt[y];\n    --deg[x], ++deg[y];\n    anc[find(x)] = find(y);\n  }\n}\n\nint main() {\n  init();\n  for (int i = 1; i <= n; ++i) if (deg[i] > 0 || deg[i + n] < 0) return puts(\"NO\"), 0;\n  for (int i = 1; i <= 2 * n; ++i) mask[find(i)] |= deg[i];\n  for (int i = 1; i <= 2 * n; ++i) if (find(i) == i && cnt[i] && !mask[i]) return puts(\"NO\"), 0;\n  puts(\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 500;\n\nint n, h;\nint in[N], out[N], fa[N];\nbool self[N];\n\ninline int getf(int x) {\n  return fa[x] ? fa[x] = getf(fa[x]) : x;\n}\n\ninline void link(int x, int y) {\n  x = getf(x); y = getf(y);\n  if (x != y) fa[x] = y;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &h);\n  for (int i = 1, a, b, c, d, p, q; i <= n; i ++) {\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    if (!c) p = h + a;\n    else p = h - c;\n    if (!d) q = h - b;\n    else q = h + d;\n    link(p, q);\n    out[p] ++; in[q] ++;\n    if (p == q) self[p] = 1;\n    // cerr << p << \" \"<< q << endl;\n  }\n  for (int i = 0; i <= h + h; i ++) {\n    if (i > h && in[i] > out[i]) return 0 * puts(\"NO\");\n    if (i < h && in[i] < out[i]) return 0 * puts(\"NO\");\n    bool fd = 0, fri = self[i];\n    for (int j = 0; j <= h + h && !fd; j ++)\n      if (getf(j) == getf(i)) {\n        if (i != j) fri = 1;\n        if (in[j] != out[j]) fd = 1;\n      }\n  if (!fd && fri) return 0 * puts(\"NO\");\n  }\n  puts(\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 400\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,H,in[MN+5],out[MN+5],s[MN+5],size[MN+5],b[MN+5],B[MN+5];\ninline int gf(int x){return s[x]?s[x]=gf(s[x]):x;}\ninline void ins(int f,int t)\n{\n\t++in[t];++out[f];\n\tif(gf(f)!=gf(t))\n\t\tsize[gf(t)]+=size[gf(f)],\n\t\tb[gf(t)]|=b[gf(f)],B[gf(t)]|=B[gf(f)],\n\t\ts[gf(f)]=gf(t);\n\tB[gf(f)]=B[gf(t)]=1;\n}\nint main()\n{\n\tn=read();H=read();\n\tfor(int i=1;i<=2*H;++i) size[i]=1,b[i]=i>H;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint f=c?c+H:a,t=d?d:b+H;\n\t\tins(f,t);\n\t}\n\tfor(int i=1;i<=2*H;++i)\n\t{\n\t\tif(in[i]-out[i]>1||in[i]-out[i]<-1) return 0*puts(\"NO\");\n\t\tif(in[i]!=out[i]) \n\t\t{\n\t\t\tif(i<=H&&out[i]<in[i]) return 0*puts(\"NO\");\n\t\t\tif(i> H&&out[i]>in[i]) return 0*puts(\"NO\");\n\t\t}\n\t}\n\tfor(int i=1;i<=2*H;++i) if(gf(i)==i&&B[i]&&!b[i]) return 0*puts(\"NO\");\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nvector<int>G[405];\nint in[405];\nint a[100005], b[100005], c[100005], d[100005];\nint vst[405];\nvoid dfs(int now) {\n\tfor(int e:G[now]) {\n\t\tif (vst[e])continue;\n\t\tvst[e] = 1;\n\t\tdfs(e);\n\t}\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\trep(i, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tint x, y;\n\t\tif (c[i] == 0)x = a[i];\n\t\telse x = c[i] + h;\n\t\tif (d[i] == 0)y = b[i] + h;\n\t\telse y = d[i];\n\t\tG[x].push_back(y);\n\t\tin[y]++;\n\t}\n\tint cnt = 0;\n\trep(i, h + 1) {\n\t\tif ((G[i].size() + in[i]) & 1) {\n\t\t\tcnt++;\n\t\t\tG[0].push_back(i);\n\t\t\tin[i]++;\n\t\t}\n\t}\n\tfor (int i = h + 1; i <= 2 * h; i++) {\n\t\tif ((G[i].size() + in[i]) & 1) {\n\t\t\tcnt--;\n\t\t\tG[i].push_back(0);\n\t\t\tin[0]++;\n\t\t}\n\t}\n\tif (cnt!=0) {\n\t\tputs(\"NO\");\n\t}\n\telse {\n\t\tvst[0] = 1;\n\t\tdfs(0);\n\t\trep(i, 2 * h + 1) {\n\t\t\tif (vst[i] == 0 && (in[i]||G[i].size())) {\n\t\t\t\tputs(\"NO\"); return 0;\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\trep(i, 2 * h + 1) {\n\t\t\tif ((G[i].size() + in[i]) & 1)cnt++;\n\t\t}\n\t\tif (cnt)puts(\"NO\");\n\t\telse puts(\"YES\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define MP make_pair\n#define MT make_tuple\n#define EACH(i,c) for(auto i: c)\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, H;\n\tcin >> N >> H;\n\n\tmap<int, int> lA, lC, rB, rD, lArD, rBlC;\n\tint x = 0, y = 0;\n\tREP(i, N){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif(c == 0){\n\t\t\tlA[a]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\tlC[c]++;\n\t\t\ty++;\n\t\t}\n\t\tif(d == 0){\n\t\t\trB[b]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\trD[d]++;\n\t\t\ty++;\n\t\t}\n\n\t\tif(c == 0 && a == d) lArD[a]++;\n\t\tif(d == 0 && b == c) rBlC[b]++;\n\t}\n\n\tif(y + 2 > x){\n\t\tcerr << x << \" \" << y << endl;\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\n\tEACH(pc, lC){\n\t\tif(rB[pc.first] < pc.second + (0 < lArD[pc.first])){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEACH(pd, rD){\n\t\tif(lA[pd.first] < pd.second + (0 < rBlC[pd.first])){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"YES\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n/*\n * Union-Find tree\n * header requirement: vector\n */\nclass UnionFind {\nprivate:\n  std::vector<int> disj;\n  std::vector<int> rank;\npublic:\n  UnionFind(int n) : disj(n), rank(n) {\n    for (int i = 0; i < n; ++i) {\n      disj[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int root(int x) {\n    if (disj[x] == x) {\n      return x;\n    }\n    return disj[x] = root(disj[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (rank[x] < rank[y]) {\n      disj[x] = y;\n    } else {\n      disj[y] = x;\n      if (rank[x] == rank[y]) {\n\t++rank[x];\n      }\n    }\n  }\n  bool is_same_set(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\n\nconst int H = 210;\n\nint in[H], out[H], inc[H], outc[H];\n\nint main(void){\n  int n, h;\n  cin >> n >> h;\n  set<int> app;\n  UnionFind uf(2 * H);\n  REP(i, 0, n) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    int u, v;\n    if (c == 0) {\n      in[a] += 1;\n      app.insert(u = a);\n    } else {\n      inc[c] += 1;\n      app.insert(u = c + H);\n    }\n    if (d == 0) {\n      out[b] += 1;\n      app.insert(v = b + H);\n    } else {\n      outc[d] += 1;\n      app.insert(v = d);\n    }\n    uf.unite(u, v);\n  }\n  set<int> roots;\n  for (set<int>::iterator it = app.begin(); it != app.end(); ++it) {\n    roots.insert(uf.root(*it));\n  }\n  bool ok = true;\n  int ncc = roots.size();\n  int cnt = 0;\n  REP(i, 0, h + 1) {\n    if (0) {\n      cerr << i << \":\";\n      cerr << \"in=\" << in[i] << \", out=\" << out[i];\n      cerr << \"inc=\" << inc[i] << \", outc=\" << outc[i];\n      cerr << endl;\n    }\n    if (in[i] != outc[i]) {\n      cnt += in[i] - outc[i];\n      if (in[i] < outc[i]) {\n\tok = false;\n      }\n    }\n    if (out[i] != inc[i]) {\n      cnt += out[i] - inc[i];\n      if (out[i] < inc[i]) {\n\tok = false;\n      }\n    }\n  }\n  assert (cnt % 2 == 0);\n  ok &= cnt % 2 == 0 && cnt >= 2 * ncc;\n  cout << (ok ? \"YES\" : \"NO\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Jigsaw\n// * frank_c1\n// * 2017 / 11/ 07\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = (int)(1e5) + 5;\nint ai[maxn], bi[maxn], ci[maxn], di[maxn];\nint in[maxn], ou[maxn];\n\nint main() {\n\tint n, H;\n\tscanf(\"%d%d\", &n, &H);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d%d%d%d\", &ai[i], &bi[i], &ci[i], &di[i]);\n\t\tint u = 0, v = 0;\n\t\tif (!ci[i]) u = ai[i]; else u = ci[i] + H;\n\t\tif (!di[i]) v = bi[i] + H; else v = di[i];\n\t\t++ou[u]; ++in[v]; \n\t} int cnt = 0, e = 0;\n\tfor (int i = 1; i <= H; ++i) if (in[i] > ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] < ou[i]) cnt += ou[i] - in[i], e = 1;\n\tfor (int i = H + 1; i <= H + H; ++i) if (in[i] < ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] > ou[i]) cnt -= in[i] - ou[i];\n\treturn ((cnt || !e) ? printf(\"NO\\n\") : printf(\"YES\\n\")), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint fa[1010],num[1010];\nbool go[1010],bo[1010];\nint getf(int s){if (fa[s]==s) return s;return fa[s]=getf(fa[s]);}\nint main()\n{\n\tint n;scanf(\"%d%*d\",&n);\n\tfor (int i=1;i<=1000;i++) fa[i]=i;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c,d;scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif (c==0) c=a+500;else c=500-c;\n\t\tif (d==0) d=500-b;else d=d+500;\n\t\tfa[getf(c)]=getf(d);\n\t\tnum[c]++;num[d]--;bo[c]=true;\n\t}\n\tfor (int i=1;i<500;i++) if (num[i]>0) {puts(\"NO\");return 0;}\n\tfor (int i=501;i<1000;i++) if (num[i]<0) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<1000;i++)\n\t{\n\t\tbo[getf(i)]|=bo[i];\n\t\tgo[getf(i)]|=(num[i]!=0);\n\t}\n\tfor (int i=1;i<1000;i++) if ((fa[i]==i)&&(bo[i])&&(!go[i])) {puts(\"NO\");return 0;}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst long long INF = (1ll << 50);\nstruct graph {\n  typedef long long flow_type;\n  struct edge {\n    int src, dst;\n    flow_type capacity, flow;\n    size_t rev;\n  };\n  int n;\n  vector<vector<edge>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst, flow_type capacity) {\n    adj[src].push_back({src, dst, capacity, 0, adj[dst].size()});\n    adj[dst].push_back({dst, src, 0, 0, adj[src].size()-1});\n  }\n  flow_type max_flow(int s, int t, bool first=false) {\n    if (first) {\n      for (int u = 0; u < n; ++u) // initialize\n      for (auto &e: adj[u]) e.flow = 0;\n    }\n\n    vector<int> level(n), iter(n);\n    function<int(void)> levelize = [&]() { // foward levelize\n      level.assign(n, -1); level[s] = 0;\n      queue<int> Q; Q.push(s);\n      while (!Q.empty()) {\n        int u = Q.front(); Q.pop();\n        if (u == t) break;\n        for (auto &e: adj[u]) {\n          if (e.capacity > e.flow && level[e.dst] < 0) {\n            Q.push(e.dst);\n            level[e.dst] = level[u] + 1;\n          }\n        }\n      }\n      return level[t];\n    };\n    function<flow_type(int, flow_type)> augment = [&](int u, flow_type cur) {\n      if (u == t) return cur;\n      for (int &i = iter[u]; i < adj[u].size(); ++i) {\n        edge &e = adj[u][i], &r = adj[e.dst][e.rev];\n        if (e.capacity > e.flow && level[u] < level[e.dst]) {\n          flow_type f = augment(e.dst, min(cur, e.capacity - e.flow));\n          if (f > 0) {\n            e.flow += f;\n            r.flow -= f;\n            return f;\n          }\n        }\n      }\n      return flow_type(0);\n    };\n\n    flow_type flow = 0;\n    while (levelize() >= 0) {\n      fill(all(iter), 0);\n      for (flow_type f; (f = augment(s, INF)) > 0; )\n        flow += f;\n    }\n    return flow;\n  }\n};\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\nint cnt2[500];\nint cnt3[500];\nint dup[500];\n\nint MakeVertex(int a, int c) {\n  if (c == 0) return a;\n  return c+(H+1);\n}\n\nsigned main(){\n  cin >> N >> H;\n\n  int S = 0;\n  int S2 = S+1;\n  int T2 = S2+1;\n  int l2 = T2+1;\n  int l3 = l2+2*(H+2);\n  int gr = l3+2*(H+2);\n  int grL = gr+1;\n  int grR = grL+1;\n  int T = grR+1;\n  graph g(T+1);\n\n\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    \n    int u = MakeVertex(B[i], D[i]);\n    cnt2[u]++;\n    int v = MakeVertex(A[i], C[i]);\n    cnt3[v]++;\n\n    if (abs(u-v) == H+1) dup[u]++;\n  }\n\n  reps(i, l2, l3) {\n    int u = i - l2;\n    int v = (u >= H+1) ? u-(H+1) : u+H+1;\n    int lim = max(cnt2[u]+cnt3[v]-dup[u]*2, 0);\n    g.add_edge(l2+u, l3+v, min(N, lim));\n    if (cnt2[u] > 0) {\n      g.add_edge(S, l2+u, cnt2[u]);\n      //g.add_edge(S2, l2+u, cnt2[u]);\n      //g.add_edge(S, T2, cnt2[u]);\n    }\n  }\n\n  reps(i, l3, gr) {\n    int u = i - l3;\n    if (cnt3[u] > 0) {\n      g.add_edge(l3+u, T, cnt3[u]);\n      //g.add_edge(S2, T, cnt3[u]);\n      //g.add_edge(l3+u, T2, cnt3[u]);\n    }\n  }\n    \n  //g.add_edge(S, gr, N);\n  //g.add_edge(gr, T, N);\n\n  g.add_edge(S, grL, 1);\n  //g.add_edge(S2, grL, 1);\n  //g.add_edge(S, T2, 1);\n\n  g.add_edge(grR, T, 1);\n  //g.add_edge(S2, T, 1);\n  //g.add_edge(grR, T2, 1);\n\n  reps(h, 1, H+1) {\n    int v = MakeVertex(h, 0);\n    g.add_edge(l2+v, gr, N+1);\n    g.add_edge(gr, l3+v, N+1);\n    g.add_edge(l2+v, grR, 1);\n    g.add_edge(grL, l3+v, 1);\n  }\n\n  //LL a = g.max_flow(S2, T2, true);\n  //LL b = g.max_flow(S, T2);\n  //LL c = g.max_flow(S2, T);\n  LL d = g.max_flow(S, T);\n  //cout \n  //<< a << \",\" \n  //<< b << \",\"\n  //<< c << \",\"\n  //<< d << endl;\n\n  //if (a+b == a+c && a+b == N*2+2) {\n  if (d >= N+1) {\n    cout << \"YES\" << endl;\n    return 0;\n  }\n  cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,h,deg[410],cnt;\nbool flag[410];\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[100100],*tp=pool,*fst[410];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nvoid addedge(int u,int v)\n{\n    *tp=(edge){v,fst[u]},fst[u]=tp++;\n    ++deg[u],--deg[v];\n}\n\nvoid dfs(int x)\n{\n    if (flag[x])\n        return;\n    flag[x]=1;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        ++cnt,dfs(i->v);\n}\n\nbool check()\n{\n    repu(i,1,n)\n    {\n        int a=getint(),b=getint(),c=getint(),d=getint();\n        int u=c?c:h+a,v=d?h+d:b;\n        addedge(u,v);\n    }\n    repu(i,1,h*2)\n    {\n        if (deg[i]>0)\n            if (i>h)\n                dfs(i);\n            else\n                return 0;\n        if (deg[i]<0 && i>h)\n            return 0;\n    }\n    return cnt==n;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    puts(check()?\"YES\":\"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> emp[2][205],bmp[2][205];\nbool vis[100005];\nint a[100005],c[100005],d[100005],b[100005];\nint n,h;\n\nbool fillb(int i)\n{\n    vis[i] = true;\n    if(c[i]==0)\n    {\n        for(int j=0;j<bmp[1][a[i]].size();++j){\n            if(vis[bmp[1][a[i]][j]]) continue;\n            fillb(bmp[1][a[i]][j]);\n        }\n        return true;\n    }else{\n        for(int j=0;j<bmp[0][c[i]].size();++j)\n        {\n            if(vis[bmp[0][c[i]][j]]) continue;\n            return fillb(bmp[0][c[i]][j]);\n        }\n        vis[i]=false;\n        return false;\n    }\n}\n\nbool fille(int i)\n{\n    vis[i] = true;\n    if(d[i]==0)\n    {\n        for(int j=0;j<emp[1][b[i]].size();++j)\n        {\n\n            if(vis[emp[1][b[i]][j]]) continue;\n            fille(emp[1][b[i]][j]);\n        }\n        return true;\n    }else\n    {\n        for(int j=0;j<emp[0][d[i]].size();++j)\n        {\n            if(vis[emp[0][d[i]][j]])continue;\n            return fille(emp[0][d[i]][j]);\n        }\n        vis[i] = false;\n        return false;\n    }\n}\n\nint main()\n{\n    //freopen(\"C://Code//input.txt\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        if(c[i]==0)\n        {\n            emp[0][a[i]].push_back(i);\n        }else emp[1][c[i]].push_back(i);\n        if(d[i]==0) bmp[0][b[i]].push_back(i);\n        else bmp[1][d[i]].push_back(i);\n    }\n    bool ag = true;\n    for(int i=0;i<n;++i)\n    {\n        if(vis[i]||(c[i]==0&&d[i]==0)) continue;\n        if((!fillb(i))||(!fille(i)))\n        {\n            ag= false;break;\n        }\n        if(!vis[i]){ag=false;break;}\n    }\n    if(ag) printf(\"YES\");\n    else printf(\"NO\");\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register int\n#define F(x,y,z) for(re x=y;x<=z;x++)\n#define FOR(x,y,z) for(re x=y;x>=z;x--)\ntypedef long long ll;\n#define I inline void\n#define IN inline int\n#define STS system(\"pause\")\ntemplate<class D>I read(D &res){\n\tres=0;register D g=1;register char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')g=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\tres*=g;\n}\n\nint n,h,fa[440],A,B,C,D,in[440],out[440],f[440];\nIN find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nI merge(int x,int y){\n\tx=find(x);y=find(y);if(x==y)return;fa[x]=y;\n}\nint main(){\n\tread(n);read(h);\n\tF(i,1,h<<1)fa[i]=i;\n\tF(i,1,n){\n\t\tread(A);read(B);read(C);read(D);\n\t\tre x,y;\n\t\tx=C?C+h:A;y=D?D:B+h;\n\t\tout[x]++;in[y]++;\n\t\tmerge(x,y);\n\t}\n\tF(i,1,h)if(in[i]>out[i])return !printf(\"NO\");\n\tF(i,h+1,h<<1)if(in[i]<out[i])return !printf(\"NO\");\n\tF(i,1,(h<<1))if(in[i]^out[i]||(!in[i]&&!out[i]))f[find(i)]=1;\n\tF(i,1,(h<<1))if(fa[i]==i&&!f[i])return !printf(\"NO\");\n\tprintf(\"YES\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N, H;\nvector<int> vertex;\nint degree[1000];\nint v1[105000], v2[105000];\nbool can[1000];\nint main() {\n    cin >> N >> H;\n    cerr << N << \" \" << H << endl;\n    UnionFind uni(3 * H);\n    for(int i = 0; i < N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        cerr << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        if(c == 0) v1[i] = a;\n        else v1[i] = H + c;\n        if(d == 0) v2[i] = H + b;\n        else v2[i] = d;\n        degree[v1[i]]--;\n        degree[v2[i]]++;\n        uni.merge(v1[i], v2[i]);\n        vertex.push_back(v1[i]);\n        vertex.push_back(v2[i]);\n        //cerr << v1[i] << \" \" << v2[i] << endl;\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            can[v1[i]] = true;\n        }\n    }\n    sort(vertex.begin(), vertex.end());\n    vertex.erase(unique(vertex.begin(), vertex.end()), vertex.end());\n    map<int, vector<int>> mp;\n    for(auto v : vertex) {\n        /*\n        if(!uni.issame(v, vertex[0])) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        */\n        mp[uni.root(v)].push_back(v);\n    }\n    cerr << \"sz: \" << mp.size() << endl;\n    for(auto tmp : mp) {\n        /*\n        for(auto v : tmp.second) {\n            cerr << v << \" \";\n        }\n        cerr << endl;\n        */\n        vector<int> s, t;\n        for(auto v : tmp.second) {\n            if(degree[v] < 0) s.push_back(v);\n            if(degree[v] > 0) t.push_back(v);\n        }\n        if(s.empty()) {\n            assert(t.empty());\n            bool ok = false;\n            for(auto v : tmp.second) {\n                ok |= can[v];\n            }\n            if(!ok) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        } else {\n            //if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n            for(auto v : s) {\n                if(v >= H + 1) {\n                    cout << \"NO\" << endl;\n                    return 0;\n                }\n            }\n            for(auto v : t) {\n                if(v <= H) {\n                    cout << \"NO\" << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"YES\" << endl;\n    assert(0);\n    return 0;\n    /*\n    int s = -1, t = -1;\n    for(auto v : vertex) {\n        if(abs(degree[v]) >= 2) {\n            cout << \"NO\" << endl;\n            cerr << \"DEGREE\" << endl;\n            return 0;\n        }\n        if(degree[v] == 1) {\n            if(t != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"T\" << endl;\n                return 0;\n            } else {\n                t = v;\n            }\n        }\n        if(degree[v] == -1) {\n            if(s != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"S\" << endl;\n                cerr << s << \" \" << v << endl;\n                return 0;\n            } else {\n                s = v;\n            }\n        }\n    }\n    if(s != -1) {\n        assert(t != -1);\n        if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n    }\n    for(int i = 0; i < N; i++) {\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    }\n    cout << \"NO\" << endl;\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,h;\n  int a[20][20];\n  cin>>n;\n  cin>>h;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<4;j++){\n    cin>>a[i][j];\n    }\n  }\n  int flagl=0,flagr=0;\n  for(int k=0;k<n;k++){//对于每一块拼图进行分析\n    for(int l=0;l<n;l++){\n      if(a[k][2]==(a[l][1]+a[l][3])&&(l!=k))\n      {flagl++;a[k][2]=0;a[k][0]=0;a[l][1]=0;a[l][3]=0;}\n      if(a[k][3]==(a[l][0]+a[l][2])&&(l!=k))\n      {flagr++;a[k][1]=0;a[k][3]=0;a[l][0]=0;a[l][2]=0;}\n    }\n\n  }\nif(flagl+flagr==n-1)\n{cout<<\"YES\"<<endl;}\nelse{cout<<\"NO\"<<endl;}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\nvector<int> es[1145];\nvector<int> res[1145];\n\nint MakeVertex(int a, int c, bool rev=false) {\n  if (c == 0) return a + rev*(H+1);\n  return c+(H+1)*!rev;\n}\n\nbool used[21451];\nint belong[21451];\nvector<int> vis;\nvector<vector<int>> vs;\n\nvoid Dfs(int v) {\n  used[v] = true;\n  for (int u : es[v]) {\n    if (used[u]) continue;\n    Dfs(u);\n  }\n  vis.eb(v);\n}\n\nvoid RDfs(int v, int grp) {\n  used[v] = true;\n  belong[v] = grp;\n  vs.back().eb(v);\n  for (int u : res[v]) {\n    if (used[u]) continue;\n    RDfs(u, grp);\n  }\n}\n\nsigned main(){\n  cin >> N >> H;\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    int v = MakeVertex(A[i], C[i]);\n    int u = MakeVertex(B[i], D[i], true);\n    es[v].eb(u);\n    res[u].eb(v);\n  }\n\n  int cnt = 0;\n  vector<int> sts;\n  vector<int> eds;\n  int M = 500;\n  rep(v, M) {\n    if (es[v].size() == res[v].size()) cnt++;\n    if (es[v].size()+1 == res[v].size()) eds.eb(v);\n    if (es[v].size() == res[v].size()+1) sts.eb(v);\n  }\n\n  if (sts.size() != eds.size()) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n\n  if (sts.size()+eds.size()+cnt != M) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n\n  for (int v : sts) {\n    if (v >= H+1) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n\n  for (int u : eds) {\n    if (u < H+1) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n\n  vis.clear();\n  fill(used, used+M, false);\n  rep(v, M) {\n    if (!used[v]) Dfs(v);\n  }\n  reverse(all(vis));\n  fill(used, used+M, false);\n  int grp = 0;\n  for (int v : vis) {\n    if (!used[v]) {\n      vs.eb();\n      RDfs(v, grp++);\n    }\n  }\n\n  fill(used, used+M, false);\n  for (int v : sts) {\n    if (!used[v]) Dfs(v);\n  }\n\n  rep(v, M) {\n    if (used[v]) continue;\n    int g = belong[v];\n    if (vs[g].size() == 1 && es[v].empty()) continue;\n    bool ok = false;\n    for (int u : vs[g]) {\n      for (int w : res[u]) {\n        assert(belong[w] == g);\n        if (u < H+1 && w >= H+1) {\n          ok = true;\n          break;\n        }\n      }\n    }\n\n    if (!ok) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n  cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define nt(x) (x+h)\nnamespace Hao_Nan_A___Wo_Bu_Hui_A___Wo_Hao_Ruo_A\n{\n\tconst int N=101000,M=510;\n\tint begin[M],next[N],to[N];\n\tint ind[M],outd[M];\n\tint n,h,e;\n\tvoid add(int x,int y)\n\t{\n//\t\tprintf(\"%d -> %d\\n\",x,y);\n\t\tind[y]++;outd[x]++;\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d%d\",&n,&h);e=0;\n\t\tfor(int i=1;i<=h*2;i++)\n\t\t\tind[i]=outd[i]=0;\n\t\tfor(int i=1,A,B,C,D,u,v;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\t\tif(C)u=nt(C);else u=A;\n\t\t\tif(D)v=D;else v=nt(B);\n\t\t\tadd(u,v);\n\t\t}\n\t}\n\tbool check()\n\t{\n\t\tfor(int i=1;i<=h;i++)if(ind[i]>outd[i])return 0;\n\t\tfor(int i=1;i<=h;i++)if(ind[nt(i)]<outd[nt(i)])return 0;\n\t\tfor(int i=1;i<=h<<1;i++)if(ind[i]!=outd[i])return 1;\n\t\treturn 0;\n\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tif(check())printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n}\nint main()\n{\n//\tfreopen(\"in\",\"r\",stdin);\n\tHao_Nan_A___Wo_Bu_Hui_A___Wo_Hao_Ruo_A::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\nint c[201][2];\nint e[201][2];\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\tc[b[i].c][0]++; num++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].a][0]++;\n\t\t}\n\t\tif (b[i].d > 0) {\n\t\t\tc[b[i].d][1]++; num++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].b][1]++;\n\t\t}\n\t}\n\tif (num>=n) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tint r = 0; int cr = 0;\n\trep(i, 201) {\n\t\trep(j, 2) {\n\t\t\tif (c[i][j] > e[i][j^1]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t\tif(j==0)r += e[i][j ^ 1] - c[i][j];\n\t\t\tif (j == 1)cr += e[i][j ^ 1] - c[i][j];\n\t\t}\n\t}\n\tif (r == 0||cr==0) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint N,H,Q;\nint ace[444],in[444],out[444];\nint ancestor(int x){return x-ace[x]?ace[x]=ancestor(ace[x]):x;}\nbool proc(){\n\tfor(int i=1; i<=H; i++)\n\t\tif(out[i] < in[i])return false;\n\tfor(int i=H+1; i<=2*H; i++)\n\t\tif(out[i] > in[i])return false;\n\tfor(int i=1; i<=2*H; i++)if(ancestor(i) == i){\n\t\tbool val = false, valid = false;\n\t\tfor(int j=1; j<=2*H; j++)if(ancestor(j) == i){\n\t\t\tif(in[j] == 0 && out[j] == 0)continue;\n\t\t\tval = true;\n\t\t\tif(in[j] != out[j])valid = true;\n\t\t}\n\t\tif(val && !valid)return false;\n\t}\n\treturn true;\n}\nint main(){\n\tscanf(\"%d%d\",&N,&H);\n\tfor(int i=1; i<=2*H; i++)\n\t\tace[i] = i;\n\tQ = 2 * H + 1;\n\tfor(int i=0; i<N; i++){\n\t\tint A,B,C,D,L,R;\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tif(C == 0)L = A;else\n\t\t\tL = Q - C;\n\t\tif(D == 0)R = Q - B;else\n\t\t\tR = D;\n\t\tin[R] ++;\n\t\tout[L] ++;\n\t\tace[ancestor(L)] = ancestor(R);\n\t}\n\t//(l1,r1)-(l2,r2) => r1 == l2 || r1 < 0 && l2 > 0\n\tputs(proc()?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ss {\n\tint a, b, c, d;\n} b[100005];\n\nint n, ta;\nbool o[100005];\nset< int > sa[205], sb[205];\n\nvoid clear(int a) {\n\to[a] = 1;\n\tif (!b[a].c)\n\t\tsa[b[a].a].erase(a);\n\tif (!b[a].d)\n\t\tsb[b[a].b].erase(a);\n}\n\nvoid up(int a) {\n\to[a] = 1;\n\tif (b[a].c)\n\t\to[a] = 0;\n\telse\n\t\tsa[b[a].a].insert(a);\n\tif (b[a].d)\n\t\to[a] = 0;\n\telse\n\t\tsb[b[a].b].insert(a);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &ta);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%d%d\", &b[i].a, &b[i].b, &b[i].c, &b[i].d);\n\t\tup(i);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\twhile (!o[i]) {\n\t\t\tif (b[i].c) {\n\t\t\t\tif (sb[b[i].c].empty() || ((ta = *sb[b[i].c].begin()) == i && (ta = *sb[b[i].c].rbegin()) == i)) {\n\t\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tclear(i);\n\t\t\t\tclear(ta);\n\t\t\t\tb[i].a = b[ta].a;\n\t\t\t\tb[i].c = b[ta].c;\n\t\t\t\tup(i);\n\t\t\t} else {\n\t\t\t\tif (sa[b[i].d].empty() || ((ta = *sa[b[i].d].begin()) == i && (ta = *sa[b[i].d].rbegin()) == i)) {\n\t\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tclear(i);\n\t\t\t\tclear(ta);\n\t\t\t\tb[i].b = b[ta].b;\n\t\t\t\tb[i].d = b[ta].d;\n\t\t\t\tup(i);\n\t\t\t}\n\t\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nvvll g, gbi;\nvll see, in, out;\nll N, H;\n\nbool dfs(ll u) {\n\tbool b = false;\n\n\t//cout << u << endl;\n\tsee[u] = 1;\n\tif (u > H && in[u] < out[u]) {b=true; }\n\tfor (ll v : gbi[u]) {\n\t\tif (see[v] == 1) { continue; }\n\t\tif (dfs(v)) {b=true; }\n\t}\n\n\treturn b;\n}\n\nint main() {\n\t\n\tcin >> N >> H;\n\n\tvll A(N + 1), B(N + 1), C(N + 1), D(N + 1);\n\trepn(i, N) cin >> A[i] >> B[i] >> C[i] >> D[i];\n\n\tg.resize(2 * H + 1);\n\trepn(i, N) {\n\t\tif (C[i] == 0 && D[i] == 0) { g[H + A[i]].push_back(H - B[i]); }\n\t\telse if (C[i] == 0) { g[H + A[i]].push_back(H + D[i]); }\n\t\telse if (D[i] == 0) { g[H - C[i]].push_back(H - B[i]); }\n\t\telse { g[H - C[i]].push_back(H + D[i]); }\n\t}\n\n\tgbi.resize(2 * H + 1);\n\trep(v, 2 * H + 1) {\n\t\tfor (ll w : g[v]) {\n\t\t\t//cout << v << \" \" << w << endl;\n\t\t\tgbi[v].push_back(w);\n\t\t\tgbi[w].push_back(v);\n\t\t}\n\t}\n\n\tin.assign(2*H + 1, 0);\n\tout.assign(2*H + 1, 0);\n\n\trep(v, 2 * H + 1) {\n\t\tout[v] = g[v].size();\n\t\tfor (ll w : g[v]) { in[w]++; }\n\t}\n\n\trep(v, 2 * H + 1) {\n\t\tif (v < H && in[v] < out[v]) { cout << \"NO\" << endl; return 0; }\n\t\tif (v > H && in[v] > out[v]) { cout << \"NO\" << endl; return 0; }\n\t}\n\n\tsee.assign(2 * H + 1, 0);\n\n\trep(v, 2 * H + 1) {\n\t\tif (see[v] == 1) { continue; }\n\t\tif (in[v] == 0 && out[v] == 0) { continue; }\n\t\tif (!dfs(v)) { cout << \"NO\" << endl; return 0; }\n\t}\n\n\tcout << \"YES\" << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\tif (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, e[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += e[i];\n\t}\n\tif (s < e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include<string.h>\nusing namespace std;\nstruct node\n{\n    int a, b, c, d;\n};\nvector<int> v[2][200];\nnode nd[100010];\nbool rcd[100010];\nint count = 1;\nint N, H;\n\nbool dfs(int f, int h)\n{\n    for (int i = 0; i < v[f][h].size(); i++)\n    {\n        if (rcd[v[f][h][i]] == 1)\n            continue;\n        else\n            rcd[v[f][h][i]] == 1;\n        if (++count == N)\n            return 1;\n        node nt = nd[v[f][h][i]];\n        int f1, h1;\n        if (nt.d == 0)\n        {\n            f1 = 1;\n            h1 = nt.b;\n        }\n        else\n        {\n            f1 = 0;\n            h1 = nt.d;\n        }\n        if (dfs(f1, h1))\n            return 1;\n        else\n            rcd[v[f][h][i]] = 0;\n    }\n}\n\nint main()\n{\n    cin >> N >> H;\n    for (int i = 0; i < N; i++)\n    {\n        int A, B, C, D;\n        cin >> A >> B >> C >> D;\n        nd[i].a = A;\n        nd[i].b = B;\n        nd[i].c = C;\n        nd[i].d = D;\n        if (nd[i].c == 0)\n        {\n            v[0][nd[i].a].push_back(i);\n        }\n        else\n            v[1][nd[i].c].push_back(i);\n    }\n    for (int i = 0; i < N; i++)\n    {\n        memset(rcd,0,sizeof(rcd));\n        if (nd[i].c == 0)\n        {\n            rcd[i]=1;\n            if (dfs(nd[i].d == 0 ? 1 : 0, nd[i].d == 0 ? nd[i].b : nd[i].d))\n            {\n                cout << \"YES\";\n                return 0;\n            }\n        }\n        count=1;\n    \n    cout << \"NO\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> emp[2][205],bmp[2][205];\nbool vis[100005];\nint a[100005],c[100005],d[100005],b[100005];\nint n,h;\n\nbool fillb(int i)\n{\n    vis[i] = true;\n    if(c[i]==0)\n    {\n        for(int j=0;j<bmp[1][a[i]].size();++j){\n            if(vis[bmp[1][a[i]][j]]) continue;\n            if(fillb(bmp[1][a[i]][j])) return true;\n        }\n        return true;\n    }else{\n        for(int j=0;j<bmp[0][c[i]].size();++j)\n        {\n            if(vis[bmp[0][c[i]][j]]) continue;\n            if(!fillb(bmp[0][c[i]][j])) continue;\n            return true;\n        }\n        vis[i]=false;\n        return false;\n    }\n}\n\nbool fille(int i)\n{\n    vis[i] = true;\n    if(d[i]==0)\n    {\n        for(int j=0;j<emp[1][b[i]].size();++j)\n        {\n\n            if(vis[emp[1][b[i]][j]]) continue;\n            if(fille(emp[1][b[i]][j])) return true;\n        }\n        return true;\n    }else\n    {\n        for(int j=0;j<emp[0][d[i]].size();++j)\n        {\n            if(vis[emp[0][d[i]][j]]) continue;\n            if(!fille(emp[0][d[i]][j])) continue;\n        }\n        vis[i] = false;\n        return false;\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        if(c[i]==0)\n        {\n            emp[0][a[i]].push_back(i);\n        }else emp[1][c[i]].push_back(i);\n        if(d[i]==0) bmp[0][b[i]].push_back(i);\n        else bmp[1][d[i]].push_back(i);\n    }\n    bool ag = true;\n    for(int i=0;i<n;++i)\n    {\n        if(vis[i]||(c[i]==0&&d[i]==0)) continue;\n        if((!fillb(i))||(!fille(i)))\n        {\n            ag= false;break;\n        }\n        if(!vis[i]){ag=false;break;}\n    }\n    if(ag) printf(\"YES\");\n    else printf(\"NO\");\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int H = 210;\n\nint n,h;\nint deg[H*2];\nint cnt[H*2];\nint fa[H*2],siz[H*2];\nbool bz[H*2];\n\nint getfather(int x){\n\tif (fa[x]==x)return fa[x];\n\treturn fa[x]=getfather(fa[x]);\n}\n\nint main(){\n\tfo(i,0,h*2)fa[i]=i,siz[i]=1;\n\tn=get();h=get();\n\tfo(i,1,n){\n\t\tint a=get(),b=get(),c=get(),d=get();\n\t\tif (c)a=-c;\n\t\tif (d)b=d;else b=-b;\n\t\ta+=h;b+=h;\n\t\tint ta=getfather(a),tb=getfather(b);\n\t\tdeg[a]++;deg[b]--;\n\t\tfa[ta]=tb;\n\t\tsiz[ta]+=siz[tb];\n\t}\n\tbool ans=1;\n\tfo(i,0,h)if (deg[i]>0)ans=0;\n\tfo(i,h,2*h)if (deg[i]<0)ans=0;\n\tfo(i,0,h*2)bz[getfather(i)]|=(deg[i]!=0);\n\tfo(i,0,h*2)\n\tif (siz[i]>1&&getfather(i)==i&&!bz[i])ans=0;\n\tif (ans)printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\nvector<int> v[405];\nint in[405];\nint vis[405];\nint sum=0;\nvoid dfs(int x){\n    if(vis[x])return ;\n    vis[x]=1;\n    sum+=v[x].size();\n    for(auto it:v[x]){\n        dfs(it);\n    }\n}\nint main(){\n    int n,h;\n    scanf(\"%d %d\",&n,&h);\n    for(int i=0;i<n;i++){\n        int a,b,c,d;\n        scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n        int x,y;\n        if(c==0){\n            x=2*a;\n        }\n        else{\n            x=2*c+1;\n        }\n        if(d==0){\n            y=2*b+1;\n        }\n        else{\n            y=2*d;\n        }\n       // printf(\"%d %d\\n\",x,y);\n        v[x].pb(y);\n        in[y]++;\n    }\n    vector<int> st,out;\n    for(int i = 2;i<=2*h+1;i++){\n        if(v[i].size()>in[i]){\n            //if(v[i].size()-in[i]==1)\n            st.pb(i);\n           // else{\n            //    printf(\"NO\\n\");\n            //    return 0;\n            //}\n        }\n        if(v[i].size()<in[i]){\n            //if(in[i]-v[i].size()==1)\n            \n            out.pb(i);\n            //else{\n            //    printf(\"NO\\n\");\n            //    return 0;\n            //}\n        }\n    }\n    /*printf(\"?\\n\");\n    for(auto it:st)\n    printf(\"%d \",it);\n    printf(\"\\n\");*/\n    for(auto it:st){\n        if(it%2==1){\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n    for(auto it:out){\n        if(it%2==0){\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n  /*  if(st.size()!=1||st[0]%2==1){\n        printf(\"NO\\n\");\n        return 0;\n    }\n   // printf(\"!\\n\");\n    if(out.size()!=1||out[0]%2==0){\n        printf(\"NO\\n\");\n        return 0;\n    }*/\n    for(auto it:st)\n    dfs(it); \n   // printf(\"!\\n\");\n    if(sum!=n){\n        printf(\"NO\\n\");\n    }\n    else{\n        printf(\"YES\\n\");\n    }\n\n}\n/*\n2 6\n5 7\n7 5\n4 3\n6 4\n7 3\n6 5\n5 7\n3 6\n4 7\n*/\n//a+a+1=10a+1\n//3a+2=10a+2"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,h,d[405];\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&h);\n\tfor (int i=1,A,B,C,D; i<=n; i++)\n\t\t{\n\t\t\tscanf(\"%d %d %d %d\",&A,&B,&C,&D);\n\t\t\td[C?C+h:A]++,d[D?D:B+h]--;\n\t\t}\n\tfor (int i=1; i<=h; i++)  if (d[i]<0)  puts(\"NO\"),exit(0);\n\tfor (int i=1; i<=h; i++)  if (d[i+h]>0)  puts(\"NO\"),exit(0);\n\tfor (int i=1; i<=h; i++)  if (d[i]>0)  puts(\"YES\"),exit(0);\n\tputs(\"NO\");\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << to_string(v[i]);\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 3030303\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(mi a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n\nbool dfs(int v, int b, vector<vector<int>>& g, vector<bool>& used,\n         vector<int>& ideg, vector<int>& odeg) {\n    used[v] = true;\n    bool ret = false;\n    if(v % 2 != b) ret = true;\n    if(ideg[v] != odeg[v]) ret = true;\n    REP(i, g[v].size()) {\n        if(used[g[v][i]]) continue;\n        ret = ret | dfs(g[v][i], b, g, used, ideg, odeg);\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, h;\n    cin >> n >> h;\n    vector<vector<int>> g(2 * (h + 1));\n    vector<int> ideg(2 * (h + 1), 0), odeg(2 * (h + 1), 0);\n    vector<pair<int, int>> p1(h + 1), p2(h + 1);\n    REP(i, n) {\n        int a, b, c, d;\n        int p = 0, q = 0;\n        cin >> a >> b >> c >> d;\n        if(c == 0) {\n            p1[a].first++;\n            p = 2 * a;\n        } else {\n            p2[c].first++;\n            p = 2 * c + 1;\n        }\n        if(d) {\n            p1[d].second++;\n            q = 2 * d;\n        }\n        else {\n            p2[b].second++;\n            q = 2 * b + 1;\n        }\n        g[p].pb(q);\n        g[q].pb(p);\n        odeg[p]++;\n        ideg[q]++;\n    }\n    int c1 = 0, c2 = 0;\n    REP(i, h + 1) {\n        if(p1[i].first < p1[i].second) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        c1 += p1[i].first - p1[i].second;\n        if(p2[i].second < p2[i].first) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        c2 += p2[i].second - p2[i].first;\n    }\n    if(c1 != c2) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    vector<bool> used(2 * (h + 1), false);\n    REP(i, 2 * (h + 1)) {\n        if(g[i].empty() || used[i]) continue;\n        if(!dfs(i, i % 2, g, used, ideg, odeg)) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    assert(false);\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nset<int> cntr[MAXN],cntl[MAXN];\nint sl[MAXN],sr[MAXN];\nint pl[MAXN],pr[MAXN];\nint n,h,lenl[MAXN],lenr[MAXN],fa[MAXN];\nint get_fa(int x){\n\tif(fa[x]==0)\n\t\treturn x;\n\tfa[x]=get_fa(fa[x]);\n\treturn fa[x];\n}\nint ans;\nint main(){\n\tans=1;\n\tSF(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d%d%d%d\",&lenl[i],&lenr[i],&sl[i],&sr[i]);\n\t\tif(sl[i]==0)\n\t\t\tcntr[lenl[i]].insert(i);\n\t\tif(sr[i]==0)\n\t\t\tcntl[lenr[i]].insert(i);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(sl[i]!=0){\n\t\t\tint x=sl[i];\n\t\t\tif(cntl[x].size()==0)\n\t\t\t\tans=0;\n\t\t\tbool flag=0;\n\t\t\tset<int>::iterator it=cntl[x].begin();\n\t\t\tfor(;it!=cntl[x].end();it++){\n\t\t\t\tint y=*it;\n\t\t\t\tif(get_fa(i)!=get_fa(y)){\n\t\t\t\t\tfa[get_fa(i)]=get_fa(y);\n\t\t\t\t\tflag=1;\n\t\t\t\t\tcntl[x].erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==0)\n\t\t\t\tans=0;\n\t\t}\n\t\tif(sr[i]!=0){\n\t\t\tint x=sr[i];\n\t\t\tif(cntr[x].size()==0)\n\t\t\t\tans=0;\n\t\t\tbool flag=0;\n\t\t\tset<int>::iterator it=cntr[x].begin();\n\t\t\tfor(;it!=cntr[x].end();it++){\n\t\t\t\tint y=*it;\n\t\t\t\tif(get_fa(i)!=get_fa(y)){\n\t\t\t\t\tfa[get_fa(i)]=get_fa(y);\n\t\t\t\t\tflag=1;\n\t\t\t\t\tcntr[x].erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==0)\n\t\t\t\tans=0;\n\t\t}\n\t}\n\tif(ans==1){\n\t\tPF(\"YES\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=h;i++)\n\t\tcntl[i].clear(),cntr[i].clear();\n\tmemset(fa,0,sizeof fa);\n\tfor(int i=1;i<=n;i++){\n\t\tif(sl[i]==0)\n\t\t\tcntr[lenl[i]].insert(i);\n\t\tif(sr[i]==0)\n\t\t\tcntl[lenr[i]].insert(i);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(sr[i]!=0){\n\t\t\tint x=sr[i];\n\t\t\tif(cntr[x].size()==0)\n\t\t\t\tans=0;\n\t\t\tbool flag=0;\n\t\t\tset<int>::iterator it=cntr[x].begin();\n\t\t\tfor(;it!=cntr[x].end();it++){\n\t\t\t\tint y=*it;\n\t\t\t\tif(get_fa(i)!=get_fa(y)){\n\t\t\t\t\tfa[get_fa(i)]=get_fa(y);\n\t\t\t\t\tflag=1;\n\t\t\t\t\tcntr[x].erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==0)\n\t\t\t\tans=0;\n\t\t}\n\t\tif(sl[i]!=0){\n\t\t\tint x=sl[i];\n\t\t\tif(cntl[x].size()==0)\n\t\t\t\tans=0;\n\t\t\tbool flag=0;\n\t\t\tset<int>::iterator it=cntl[x].begin();\n\t\t\tfor(;it!=cntl[x].end();it++){\n\t\t\t\tint y=*it;\n\t\t\t\tif(get_fa(i)!=get_fa(y)){\n\t\t\t\t\tfa[get_fa(i)]=get_fa(y);\n\t\t\t\t\tflag=1;\n\t\t\t\t\tcntl[x].erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==0)\n\t\t\t\tans=0;\n\t\t}\n\t}\n\tif(ans==0)\n\t\tPF(\"NO\");\n\telse\n\t\tPF(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int maxn = 1e5+10;\nint down_l[205], down_r[205], up_l[205], up_r[205];\nint l_l[maxn],l_r[maxn],h_l[maxn],h_r[maxn];\nint main()\n{\n\tint n,h;\n\tint a,b,c,d;\n\tint count_up;\n\twhile(~scanf(\"%d%d\",&n,&h)){\n\t\tcount_up = 0;\n\t\tmemset(down_l,0,sizeof(int)*205);\n\t\tmemset(down_r,0,sizeof(int)*205);\n\t\tmemset(up_l,0,sizeof(int)*205);\n\t\tmemset(up_r,0,sizeof(int)*205);\n\t\tfor(int i = 0; i<n; i++){\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\tl_l[i] = a; l_r[i] = b;\n\t\t\th_l[i] = c; h_r[i] = d;\n\t\t\tif(c == 0) down_l[a]++;\n\t\t\telse {\n\t\t\t\tup_l[a]++;\n\t\t\t\tcount_up ++;\n\t\t\t}\n\t\t\tif(d == 0) down_r[b]++;\n\t\t\telse {\n\t\t\t\tup_r[b]++;\n\t\t\t\tcount_up++;\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int i = 0; i<n; i++){\n\t\t\tint a = l_l[i], b = l_r[i];\n\t\t\tint c = h_l[i], d = h_r[i];\n\t\t\tif(c != 0){\n\t\t\t\tif(down_r[c] > 0) down_r[c]--;\n\t\t\t\telse{\n\t\t\t\t\tflag = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( d != 0){\n\t\t\t\tif(down_l[d] > 0) down_l[d]--;\n\t\t\t\telse {\n\t\t\t\t\tflag = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count_up >= n) flag = false;\n\t\tif(flag) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=400+19;\n\nint I[N],O[N],fa[N],vis[N];\nint n,a,b,c,d,H,x,y;\n\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nvoid Union(int x,int y){\n\tx=getf(x),y=getf(y);\n\tif (x!=y) fa[x]=y;\n}\n\nint main(){\n\tFor(i,0,N) fa[i]=i;\n\tn=IN(),H=IN();\n\tFor(i,1,n+1){\n\t\ta=IN(),b=IN(),c=IN(),d=IN();\n\t\tif (c==0) x=a+H;else x=c;\n\t\tif (d==0) y=b;else y=d+H;\n\t\tO[x]++;\n\t\tI[y]++;\n\t\tUnion(x,y);\n\t\t//printf(\"%d %d\\n\",x,y);\n\t}\n\tFor(i,0,N){\n\t\tif (O[i]>I[i]) if (i<=H) return puts(\"NO\"),0;else vis[getf(i)]=1;\n\t\tif (O[i]<I[i]) if (i>H) return puts(\"NO\"),0;\n\t}\n\tFor(i,0,N) if (I[i]||O[i]) if (!vis[getf(i)]) return puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nconst int INF=5e8;\nstruct MCF{\n  static const int MAX_V=220;\n  struct edge{\n    int to,cap,cost,rev;\n    edge(int st,int sc,int sco,int sr){\n      to=st;cap=sc;cost=sco;rev=sr;\n    }\n  };\n  vector<edge> g[MAX_V];\n  int pot[MAX_V],dist[MAX_V];\n  int prevv[MAX_V],preve[MAX_V];\n\n  int neg_cost_sum,neg_cap_sum;\n  int SS,TT;//SET BEFORE ADDING EDGE\n  void init(int SS_,int TT_){\n    REP(i,MAX_V) g[i].clear();\n    neg_cost_sum=0;\n    neg_cap_sum=0;\n    SS=SS_;TT=TT_;\n  }\n\n  void add_edge(int from,int to,int cap,int cost){\n    if(cost>=0){\n      g[from].pb(edge(to,cap,cost,g[to].size()));\n      g[to].pb(edge(from,0,-cost,g[from].size()-1));\n    }else{\n      neg_cost_sum+=cost*cap;\n      neg_cap_sum+=cap;\n      add_edge(SS,to,cap,0);\n      add_edge(from,TT,cap,0);\n      add_edge(to,from,cap,-cost);\n    }\n  }\n  int solve(int s,int t,int f,int V){//without negedge\n  //f==-1: flow as much as possible\n  //f==-2: flow as long as cost is negative\n    int type=f;;\n    if(f<0) f=INF;\n    int res=0;\n    fill(pot,pot+V,0);\n    while(f>0){\n      priority_queue<pi,vector<pi>,greater<pi> >pq;pq.push(mp(0,s));\n      fill(dist,dist+V,INF);\n      dist[s]=0;\n      while(!pq.empty()){\n        pi cur=pq.top();pq.pop();\n        if(dist[cur.sc]<cur.fr) continue;\n        REP(i,g[cur.sc].size()){\n          edge& e=g[cur.sc][i];\n          if(e.cap>0 && dist[e.to]>cur.fr+e.cost+pot[cur.sc]-pot[e.to]){\n            dist[e.to]=cur.fr+e.cost+pot[cur.sc]-pot[e.to];\n            prevv[e.to]=cur.sc;\n            preve[e.to]=i;\n            pq.push(mp(dist[e.to],e.to));\n          }\n        }\n      }\n      if(dist[t]==INF){\n        if(type<0) return res;\n        return -1;\n      }\n      if(type==-2 && dist[t]>0) return res;\n      for(int v=0;v<V;++v) pot[v]+=dist[v];\n      int d=f;\n      for(int v=t;v!=s;v=prevv[v]){\n        d=min(d,g[prevv[v]][preve[v]].cap);\n      }\n      f-=d;\n      res+=d*pot[t];\n      for(int v=t;v!=s;v=prevv[v]){\n        edge& e=g[prevv[v]][preve[v]];\n        e.cap-=d;\n        g[v][e.rev].cap+=d;\n      }\n    }\n    return res;\n  }\n  int solve2(int S,int T,int f,int V){//with negedge\n    int type=f;\n    if(f<0) f=INF;\n    add_edge(T,S,f,0);\n    int res=solve(SS,TT,neg_cap_sum,V);\n    assert(~res);\n    res+=neg_cost_sum;\n\n    int flowed=0;\n    for(auto e:g[T]) if(e.to==S && e.cost==0) flowed+=f-e.cap;\n    int add=solve(S,T,type<0?type:f-flowed,V);\n    if(add==-1 && type>=0) return -1;\n    res+=add;\n    return res;\n  }\n};\n\n//const int INF=5e8;\nint n,H;\npair<pi,pi> ar[100005];\nvoid ng(){\n  puts(\"NO\");\n  exit(0);\n}\nvector<int> g[100005];\n/*\nvector<int> idL[205],idR[205];\n\nbool vis[100005];\n\n\nvoid dfs(int v,int p){\n  dump(v);\n  if(vis[v]) ng();\n  vis[v]=1;\n  for(auto to:g[v]){\n    if(to==p) continue;\n    dfs(to,v);\n  }\n}\n*/\n\nstruct uf{\n\n  static const int MAXN=205;\n  int par[MAXN];\n  int size[MAXN];\n  void init(){\n    memset(par,-1,sizeof(par));\n    REP(i,MAXN) size[i]=1;\n  }\n  int root(int a){\n    if(par[a]==-1) return a;\n    return par[a]=root(par[a]);\n  }\n  void unite(int a,int b){\n    a=root(a);b=root(b);\n    if(a==b) return;\n    if(size[a]<size[b]) swap(a,b);\n\n    par[b]=a;\n    size[a]+=size[b];\n  }\n  bool same(int a,int b){\n    return root(a)==root(b);\n  }\n};\n\nuf u;\nint indeg[100005],outdeg[100005];\n\nint dif[100005];\nint mn[205],mx[205];\nint main(){\n  cin>>n>>H;\n  ++H;\n  u.init();\n  REP(i,n){\n    int a,b,c,d;scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    ar[i]={{a,b},{c,d}};\n    //if(c==0) idL[a].pb(i);\n    //if(d==0) idR[b].pb(i);\n\n    int from,to;\n    if(c==0) from=H+a;\n    else from=c;\n\n    if(d==0) to=b;\n    else to=H+d;\n    ++indeg[to];\n    ++outdeg[from];\n    g[from].pb(to);\n    u.unite(from,to);\n    if(from<H && to>=H) --dif[from];\n    else if(from>=H && to<=H) ++dif[from];\n  }\n  REP(i,H){\n    if(indeg[i]<outdeg[i]) ng();\n    if(indeg[i+H]>outdeg[i+H]) ng();\n  }\n  REP(i,H*2) mn[i]=mx[i]=i;\n  REP(i,H*2) if(u.root(i)!=i){\n    dif[u.root(i)]+=dif[i];\n    chmax(mx[u.root(i)],i);\n    chmin(mn[u.root(i)],i);\n  }\n  REP(i,H*2) if(u.root(i)==i && indeg[i]+outdeg[i]>0){\n    assert(dif[i]>=0);\n    if(dif[i]==0) ng();\n  }\n  puts(\"YES\");\n/*\n  REP(i,n){\n    int a=ar[i].fr.fr,b=ar[i].fr.sc,c=ar[i].sc.fr,d=ar[i].sc.sc;\n    if(c>0){\n      if(idR[c].empty()) ng();\n      int to=idR[c].back();\n      idR[c].pop_back();\n      g[i].pb(to);\n      g[to].pb(i);\n    }\n    if(d>0){\n      if(idL[d].empty()) ng();\n      int to=idL[d].back();\n      idL[d].pop_back();\n      g[i].pb(to);\n      g[to].pb(i);\n    }\n  }\n  prl;\n  REP(i,n) assert(g[i].size()<=2);\n  REP(i,n) if(!vis[i]){\n    dfs(i,-1);\n  }\n  */\n\n // puts(\"YES\");\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\nconst int N = 4e5 + 10, H = 505;\nint n, h, deg[N];\nbool ff, tag, vis[N], mark[N];\nvector<int> nxt[N];\n\nvoid add(int x, int y) {\n    x += H, y += H;\n    mark[x] = mark[y] = 1;\n    nxt[x].push_back(y);\n    ++deg[y], --deg[x];\n}\n\nvoid dfs(int x) {\n    if ((x > H && deg[x] > 0) || (x < H && deg[x] < 0)) {\n        ff = 1; return;\n    }\n    if (deg[x]) tag = 1;\n    vis[x] = 1;\n    for (int i = 0; i < nxt[x].size(); i++) {\n        int y = nxt[x][i];\n        if (vis[y]) continue;\n        dfs(y);\n    }\n}\n\nint main() {\n    cin >> n >> h;\n    rep(i, 1, n) {\n        int a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        add(c ? -c : a, d ? d : -b);\n    }\n    rep(i, 1, H << 1) if (mark[i] && !vis[i]) {\n        ff = tag = 0;\n        dfs(i);\n        if (ff || !tag) return puts(\"NO\"), 0;\n    }\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nint main() {\n\tint N, H;\n\tcin >> N >> H;\n\tvector<int> degl(H + 1), degr(H + 1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint A, B, C, D;\n\t\tcin >> A >> B >> C >> D;\n\t\tif (C == 0 && D != 0) {\n\t\t\t--degl[A];\n\t\t\t++degl[D];\n\t\t}\n\t\tif (C != 0 && D == 0) {\n\t\t\t--degr[B];\n\t\t\t++degr[C];\n\t\t}\n\t\tif (C == 0 && D == 0) {\n\t\t\t--degl[A];\n\t\t\t--degr[B];\n\t\t}\n\t\tif (C != 0 && D != 0) {\n\t\t\t++degl[D];\n\t\t\t++degr[C];\n\t\t}\n\t}\n\tbool ok = true;\n\tint bit = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tif (degl[i] > 0) ok = false;\n\t\tif (degl[i] < 0) bit |= 1;\n\t\tif (degr[i] > 0) ok = false;\n\t\tif (degr[i] < 0) bit |= 2;\n\t}\n\tif (bit != 3) ok = false;\n\tcout << (ok ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii; \n\nint main(int argc, char const *argv[]) {\n    puts(\"NO\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\nint N, H;\nint LD[205], RD[205], LU[205], RU[205];\nint Out[405], In[405], Use[405], ok;\nvector <int> G[405];\nconst int add = 201;\nvoid Read()\n{\n    cin >> N >> H;\n    for(int i = 1; i <= N; i++)\n    {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int l, r;\n        if(c > 0)\n        {\n            l = -c;\n        }\n        else\n            l = a;\n        if(d > 0)\n        {\n            r = d;\n        }\n        else\n            r = -b;\n        G[l + add].push_back(r + add);\n        G[r + add].push_back(l + add);\n        In[r + add]++;\n        Out[l + add]++;\n    }\n}\n\nvoid DFS(int node)\n{\n    Use[node] = 1;\n    if(In[node] != Out[node])\n    {\n        ok = 1;\n    }\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(Use[neighb] == 0)\n            DFS(neighb);\n    }\n}\nint main()\n{\n    Read();\n    for(int i = 1; i <= 402; i++)\n        if(Use[i] == 0 && G[i].size() > 0)\n        {\n            ok = 0;\n            DFS(i);\n            if(ok == 0)\n            {\n                cout << \"NO\\n\";\n                return 0;\n            }\n        }\n    for(int i = 1; i <= 402; i++)\n    {\n        if(i < add && In[i] < Out[i])\n        {\n            cout << \"NO\\n\";\n            return 0;\n        }\n        if(i > add && In[i] > Out[i])\n        {\n            cout << \"NO\\n\";\n            return 0;\n        }\n\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define inf 1000000007LL\n#define mod 1000000007LL\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define trep(i, n) for(int i = 0; i <= (n); i++)\n#define rrep(i, n) for(int i = (n) - 1; i >= 0; i--)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define mfor(i, s, t) for(int i = (s); i < (t); i++)\n#define tfor(i, s, t) for(int i = (s); i <= (t); i++)\n#define rfor(i, s, t) for(int i = (t) - 1; i >= (s); i--)\n\nint k[514];\nbool ok[514];\nvector<int> v[514];\n\nbool okok[114514];\npair<int, int> f[114514];\n\nvoid dfs(int p) {\n  if(!ok[p]) {\n    ok[p] = true;\n    for(auto i : v[p]) {\n      okok[i] = true;\n      dfs(f[i].first);\n      dfs(f[i].second);\n    }\n  }\n}\n\nsigned main() {\n  int n, h;\n  cin >> n >> h;\n  rep(i, (h + 10) * 2) {\n    k[i] = 0;\n    ok[i] = false;\n  }\n  rep(i, n) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if(c == 0) {\n      v[a].push_back(i);\n      k[a]++;\n      f[i].first = a;\n    }\n    else {\n      v[c + h + 10].push_back(i);\n      k[c + h + 10]--;\n      f[i].first = c + h + 10;\n    }\n    if(d == 0) {\n      v[b + h + 10].push_back(i);\n      k[b + h + 10]++;\n      f[i].second = b + h + 10;\n    }\n    else {\n      v[d].push_back(i);\n      k[d]--;\n      f[i].second = d;\n    }\n  }\n  rep(i, (h + 10) * 2) {\n    if(k[i] < 0) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n  rep(i, n) {\n    okok[i] = false;\n  }\n  rep(i, (h + 10) * 2) {\n    if(k[i] > 0) {\n      dfs(i);\n    }\n  }\n  rep(i, n) {\n    if(!okok[i]) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n  cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b)for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=1e5+5;\nint n,h,b,c,d,e,a[N][2],t[2][405],tt[2][405],bz,gs[2];\nvoid R(int &n){\n\tchar c;for(n=0;(c=getchar())<'0'||c>'9';);\n\tfor(;c>='0'&&c<='9';c=getchar())n=n*10+c-48;\n}\nint pd(int x,int y){return 200+(!y?-x:y);}\nint main(){\n\tR(n);R(h);\n\tfo(i,1,n){\n\t\tR(b);R(c);R(d);R(e);\n\t\ta[i][0]=pd(b,d);a[i][1]=pd(c,e);\n\t\tt[0][a[i][0]]++;\n\t\tt[1][a[i][1]]++;\n\t}\n\tmemcpy(tt,t,sizeof(t));\n\tfo(i,1,n){\n\t\tb=a[i][0];c=a[i][1];\n\t\tgs[0]+=(c<200)-(b>200);gs[1]+=(b<200)-(c>200);\n\t\tif(b>200&&(!t[1][400-b]--||tt[1][400-b]==1&&c+b==400))bz=1;\n\t\tif(c>200&&(!t[0][400-c]--||tt[0][400-c]==1&&c+b==400))bz=1;\n\t\tif(bz)break;\n\t}\n\tif(!gs[0]||!gs[1])bz=1;\n\tif(bz)printf(\"NO\");else printf(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=1e6+5;\nint n,h;\nint in[maxn],out[maxn];\nint fa[maxn],occ[maxn],ok[maxn];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tread(n);read(h);\n\trep(i,0,h+h)fa[i]=i;\n\trep(i,1,n){\n\t\tint a,b,c,d;read(a);read(b);read(c);read(d);\n\t\tint l=!c?a+h:c,r=!d?b:d+h;\n\t\tout[l]++;\n\t\tin[r]++;\n\t\tl=find(l);r=find(r);\n\t\tocc[l]=occ[r]=1;\n\t\tif(l!=r)fa[l]=r;\n\t}\n\tint flag=1;\n\trep(i,h+1,h+h)if(occ[i]&&out[i]<in[i])flag=0;\n\trep(i,0,h)if(occ[i]&&in[i]<out[i])flag=0;\n\trep(i,0,h+h)if(occ[i])ok[find(i)]|=(out[i]!=in[i]);\n\trep(i,0,h+h)if(occ[i]&&!ok[find(i)])flag=0;\n\tif(flag)puts(\"YES\");\n\telse puts(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define S 200001\nint deg[200007], vis[200007], Fa[200007];\ninline int Find(register int o){//fprintf(stderr, \"%d\\n\", o);\n\treturn o == Fa[o] ? o : (Fa[o] = Find(Fa[o]));\n}\nint fastin(){\n\tregister int i; register char ch;\n\twhile (ch = getchar(), ch < '0' || ch > '9');\n\ti = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9') i = i * 10 + ch - '0';\n\treturn i;\n}\nint main(){\n\tregister int T, n, h, h2, i, a, b, c, d, u, v;\n\tT = fastin();\n\twhile (T--) {\n\t\tn = fastin(), h = fastin();\n\t\tmemset(deg + 1, 0, sizeof(int) * (h << 1));\n\t\tmemset(vis + 1, 0, sizeof(int) * (h << 1));\n\t\th2 = h << 1;\n\t\tfor (i = 1; i <= h2; ++i) Fa[i] = i;\n\t\tFa[S] = S;\n\t\tfor (i = 1; i <= n; ++i) {\n\t\t\ta = fastin(), b = fastin(), c = fastin(), d = fastin();\n\t\t\tu = (d ? d + h : b);\n\t\t\tv = (c ? c : a + h);\n\t\t\t++deg[u], vis[u] = 1;\n\t\t\t--deg[v], vis[v] = 1;\n\t\t\tFa[Find(u)] = Find(v);\n\t\t}\n\t\t//for (i = 1; i <= h2; ++i) fprintf(stderr, \"%d %d\\n\", deg[i], vis[i]);\n\t\t//fprintf(stderr, \"GG\");\n\t\tfor (i = 1; i <= h; ++i) {\n\t\t\tif (vis[i]) {\n\t\t\t\tif (deg[i] < 0) break;\n\t\t\t\tif (deg[i] > 0) Fa[Find(i)] = S;\n\t\t\t}\n\t\t}\n\t\tif (i <= h) {\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\t//fprintf(stderr, \"HH\");\n\t\tfor (i = h + 1; i <= h2; ++i) {\n\t\t\tif (vis[i]) {\n\t\t\t\tif (deg[i] > 0) break;\n\t\t\t\tif (deg[i] < 0) Fa[Find(i)] = S;\n\t\t\t}\n\t\t}\n\t\tif (i <= h2) {\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\t//fprintf(stderr, \"II\");\n\t\tfor (i = 1; i <= h2; ++i) if (vis[i] && Find(i) != S) break;\n\t\t//fprintf(stderr, \"%d\\n\", i);\n\t\tif (i <= h2) puts(\"NO\");\n\t\telse puts(\"YES\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\n\nconst int MAXN = (200 + 10) * 2;\n\nclass no_solution : public std::exception\n{\npublic:\n\tconst char * what(void) const noexcept\n\t{\n\t\treturn \"no solution reachable\";\n\t}\n};\n\nnamespace disjointSet\n{\nint fa[MAXN];\n\nvoid init()\n{\n\tmemset(fa, 0x00, sizeof fa);\n}\n\nint find(int x)\n{\n\tif(fa[x])\n\t\treturn x;\n\treturn fa[x] = find(fa[x]);\n}\n\nvoid merge(int x, int y)\n{\n\tx = fa[x], y = fa[y];\n\tif(x != y)\n\t\tfa[x] = y;\n}\n\n}\n\nbool loop[MAXN];\nint inDeg[MAXN], outDeg[MAXN];\nint N, H;\n\nvoid solve()\n{\n\tfor(int i = 0; i <= 2 * H; i++)\n\t{\n\t\tif(i > H)\n\t\t\tif(inDeg[i] > outDeg[i])\n\t\t\t\tthrow no_solution();\n\t\tif(i < H)\n\t\t\tif(outDeg[i] > inDeg[i])\n\t\t\t\tthrow no_solution();\n\n\t\tbool found = false, isLoop = loop[i];\n\n\t\tfor(int j = 0; j <= 2 * H; j++)\n\t\t\tif(found)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tif(disjointSet::find(i) == disjointSet::find(j))\n\t\t\t\t{\n\t\t\t\t\tif(i != j)\n\t\t\t\t\t\tisLoop = true;\n\t\t\t\t\tif(inDeg[j] != outDeg[j])\n\t\t\t\t\t\tfound = true;\n\t\t\t\t}\n\n\t\tif(!found && isLoop)\n\t\t\tthrow no_solution();\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(nullptr);\n\n\tcin >> N >> H ;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tint a, b, c, d, L, R;\n\t\tcin >> a >> b >> c >> d;\n\t\tL = c ? H - c : H + a;\n\t\tR = d ? H + d : H - b;\n\t\tdisjointSet::merge(L, R);\n\t\tinDeg[R]++, outDeg[L]++;\n\n\t\tif(L == R)\n\t\t\tloop[L] = true;\n\t}\n\n\n\ttry\n\t{\n\t\tsolve();\n\t\tcout << \"YES\" << endl;\n\t}\n\tcatch(std::exception & x)\n\t{\n\t\tcout << \"NO\" << endl ;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 0x7f7f7f7f;\nconst int H = 205;\nconst int HH = H + H;\n\nvector <int> _e[HH], _er[HH], *e = _e + H, *er = _er + H;\nint _in[HH], _out[HH], *in = _in + H, *out = _out + H;\nbool _skip[HH], *skip = _skip + H;\n\nint main()\n{\n  int n, h, a, b, c, d;\n  scanf(\"%d %d\", &n, &h);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    int u = (c == 0 ? -a : c);\n    int v = (d == 0 ? b : -d);\n    e[u].push_back(v);\n    er[v].push_back(u);\n  }\n  for (int i = -h; i <= h; ++i) {\n    out[i] = (int)e[i].size();\n    in[i] = (int)er[i].size();\n    if (i < 0 && in[i] > out[i]) {\n      puts(\"NO\");\n      return 0;\n    }\n    if (i > 0 && in[i] < out[i]) {\n      puts(\"NO\");\n      return 0;\n    }\n    if (in[i] == 0 && out[i] == 0)\n      skip[i] = true;\n  }\n  for (int i = -h; i <= h; ++i) {\n    if (skip[i])\n      continue;\n    vector <int> de;\n    de.push_back(i);\n    int top = 0;\n    while (top < (int)de.size()) {\n      int u = de[top];\n      for (int j = 0; j < (int)e[u].size(); ++j) {\n        if (!skip[e[u][j]]) {\n          de.push_back(e[u][j]);\n          skip[e[u][j]] = true;\n        }\n      }\n      for (int j = 0; j < (int)er[u].size(); ++j) {\n        if (!skip[er[u][j]]) {\n          de.push_back(er[u][j]);\n          skip[er[u][j]] = true;\n        }\n      }\n      ++top;\n    }\n    bool ans = false;\n    for (int j = 0; j < (int)de.size(); ++j) {\n      if (de[j] < 0 && in[de[j]] < out[de[j]]) {\n        ans = true;\n        break;\n      }\n    }\n    if (!ans) {\n      puts(\"NO\");\n      return 0;\n    }\n  }\n  puts(\"YES\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4e2+7;\n\nint n,h,in[N],out[N];\n\nint f[2*N],hav[2*N];\ninline int getf(int x){return f[x]?f[x]=getf(f[x]):x;}\n\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;++i){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint lv=c?c+h:a,rv=d?d:b+h;\n\t\t++out[lv]; ++in[rv];\n\t\tif(getf(lv)!=getf(rv)) f[getf(lv)]=rv;\n\t}\n\tfor(int i=1;i<=h;++i) if(out[i]<in[i]) return puts(\"NO\"),0;\n\tfor(int i=h+1;i<=h+h;++i) if(out[i]>in[i]) return puts(\"NO\"),0;\n\tfor(int i=1;i<=h+h;++i) if(out[i]!=in[i]) hav[getf(i)]=1;\n\tfor(int i=1;i<=h+h;++i) if(in[i]+out[i]&&getf(i)==i&&!hav[i]) return puts(\"NO\"),0;\n\treturn puts(\"YES\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<lint, lint> pi;\nconst int MAXN = 405;\n\nint adj[MAXN][MAXN];\nint deg[MAXN], vis[MAXN];\n\nint get(pi v){\n\tif(v.first == 1) return 202 + v.second;\n\telse return v.second;\n}\n\nvoid my_ass(bool p){\n\tif(p ==0){\n\t\tputs(\"NO\");\n\t\texit(0);\n\t}\n}\n\nvoid dfs(int x){\n\tif(vis[x]) return;\n\tvis[x] = 1;\n\tfor(int i=0; i<MAXN; i++){\n\t\tif(adj[x][i] || adj[i][x]) dfs(i);\n\t}\n}\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\twhile(n--){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tpi st, ed;\n\t\tif(c == 0) st = pi(0, a);\n\t\telse st = pi(1, c);\n\t\tif(d == 0) ed = pi(1, b);\n\t\telse ed = pi(0, d);\n\t//\tprintf(\"%d %d\\n\", get(st), get(ed));\n\t\tadj[get(st)][get(ed)]++;\n\t\tdeg[get(st)]++;\n\t\tdeg[get(ed)]--;\n\t}\n\tfor(int i=0; i<202; i++){\n\t\tmy_ass(deg[i] >= 0);\n\t\tmy_ass(deg[i + 202] <= 0);\n\t\tadj[404][i] += deg[i];\n\t\tadj[i][404] -= deg[i + 202];\n\t}\n\tfor(int i=0; i<202; i++){\n\t\tadj[404][i] += 1;\n\t\tadj[i][404] += 1;\n\t}\n\tdfs(404);\n\tfor(int i=0; i<MAXN; i++){\n\t\tfor(int j=0; j<MAXN; j++){\n\t\t\tif(adj[i][j] && !vis[i]){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define allv(V) ((V).begin()),((V).end())\n#define befv(V) ((V)[(sz(V)-2)])\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define cb(x) (x)=(!(x))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\nvoid fuk() { puts(\"NO\"); exit(0); }\n\nconst bool debug = 0;\nconst int MAXN = 100005;\nconst int MAXH = 555;\n\nvector<int> G[MAXH];\nint GI[MAXH];\n\nint DgI[MAXH], DgO[MAXH];\n\nint A[MAXN], B[MAXN], C[MAXN], D[MAXN];\n\nvector<int> SV, EV;\nint N, H;\n\nvoid f(int i) {\n\tif(sz(G[i]) == GI[i]) return;\n\tint v = G[i][GI[i]++];\n\tf(v);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> H;\n\tfor(int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\n\t\tint s = -1, e = -1;\n\n\t\tif(C[i]) s = C[i]<<1;\n\t\telse s = A[i]<<1 | 1;\n\n\t\tif(D[i]) e = D[i]<<1 | 1;\n\t\telse e = B[i]<<1;\n\n\t\tG[s].eb(e);\n\t\tDgO[s]++; DgI[e]++;\n\n\t\tif(debug) printf(\"%d : %d -> %d\\n\", i, s, e);\n\t}\n\n\tfor(int i = 0; i < MAXH; i++) {\n\t\tif(DgI[i] == DgO[i]) continue;\n\t\tif(DgI[i] < DgO[i]) {\n\t\t\tfor(int j = DgO[i] - DgI[i]; j--;)\n\t\t\t\tSV.eb(i);\n\t\t} else {\n\t\t\tfor(int j = DgI[i] - DgO[i]; j--;)\n\t\t\t\tEV.eb(i);\n\t\t}\n\t}\n\n\tif(SV.empty() || sz(SV) != sz(EV)) fuk();\n\n\tfor(int v : SV) if(!(v & 1)) fuk();\n\tfor(int v : EV) if(v & 1) fuk();\n\n\tfor(int v : SV) {\n\t\tf(v);\n\t}\n\n\tfor(int i = 0; i < MAXH; i++)\n\t\tif(sz(G[i]) != GI[i]) fuk();\n\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nint n,H,in[411],out[411];\nbool e[411][411],d[411];\nvoid dfs(int w){\n\td[w]=1;\n\tfor(int i=0;i<=H*2;++i)if(e[w][i]&&!d[i])dfs(i);\n}\nvoid ae(int x,int y){\n\t++out[x],++in[y];\n\te[x][y]=1;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&H);\n\tfor(int i=0,a,b,c,d;i<n;++i){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tae(c?H+c:a,d?d:H+b);\n\t}\n\tfor(int i=1;i<=H;++i){\n\t\tint w=i;\n\t\tif(in[w]>out[w])return puts(\"NO\"),0;\n\t\twhile(in[w]<out[w])ae(0,w);\n\t\tw=H+i;\n\t\tif(in[w]<out[w])return puts(\"NO\"),0;\n\t\twhile(in[w]>out[w])ae(w,0);\n\t}\n\tif(in[0]!=out[0])return puts(\"NO\"),0;\n\tdfs(0);\n\tfor(int i=1;i<=H*2;++i)if((in[i]|out[i])&&!d[i])return puts(\"NO\"),0;\n\treturn puts(\"YES\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n#define N 100005\n\nint main()\n{\n    int n, h;\n    cin >> n >> h;\n    int a, b, c, d;\n    int hashl[300], hashr[300];\n    memset(hashl, 0, sizeof(hashl));\n    memset(hashr, 0, sizeof(hashr));\n    while (n--)\n    {\n        cin >> a >> b >> c >> d;\n        if (c == 0)\n            hashl[a]++;\n        else\n            hashr[c]--;\n        if (d == 0)\n            hashr[b]++;\n        else\n            hashl[d]--;\n        if (c == 0 && d != 0 && a == d)\n            hashl[a]++, hashr[d]--;\n        if (d == 0 && c != 0 && b == c)\n            hashl[c]--, hashr[b]++;\n    }\n    for (int i = 1; i <= 200; i++)\n    {\n        if (hashl[i] < 0 || hashr[i] < 0)\n        {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"grader.h\"\n#include <bits/stdc++.h>  \n\nusing namespace std;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define re return\n#define fi first\n#define mp make_pair\n#define se second\n#define sz(a) (int)a.size()\n#define prev previ\n#define tm tmmm\n#define div divv\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\n\nconst ll mod = ll(1e9) + 9LL, pr = 239, mod2 = ll(1e9) + 7;\n\nll n, h, a[2][201], mt[201];\nvector<int> use;\n\nbool is_edge(int i, int j) {\n\tif (i == j) re false;\n\tif (a[0][i] > 0 && a[1][j] > 0) re true;\n\tif (a[0][i] == -a[1][j]) re true;\n\tre false;\n}\nbool dfs(int nu) {\n\tif (use[nu]) re false;\n\tuse[nu] = 1;\n\tforn (i, n) {\n\t\tif (is_edge(nu, i) && (mt[i] == -1 || dfs(mt[i]))) {\n\t\t\tmt[i] = nu;\n\t\t\tre true;\t\t\n\t\t}\n\t}\n\tre false;\n}\nint main() {\n\tiostream::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> h;\n\tint k1 = 0;\n\tbool ok1 = false, ok2 = false;\n\tforn (i, n) {\n\t\tint a1, b, c, d;\n\t\tcin >> b >> d >> a1 >> c;\n\n\t\tif (a1)\n\t\t\tb = -a1;\n\t\tif (c)\n\t\t\td = -c;\n\t\tif (b) ok1 = true;\n\t\tif (d) ok2 = true;\n\t\ta[0][i] = b;\n\t\ta[1][i] = d;\n\t\tmt[i] = -1;\n\t}\n\tif (!ok1 || !ok2) {\n\t\tcout << \"NO\\n\";\n\t\tre 0;\n\t} \n\tforn (i, n) {\n\t\tuse.assign(n, 0);\n\t\tif (!dfs(i)) {\n\t\t\tcout << \"NO\\n\";\n\t\t\tre 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint num[403][2]={0}; \nint dou[403]={0};\nint main(){\n\tint n,h,t;\t\n\tcin>>n>>h;\n\tvector<int>pic[4];\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tpic[j].push_back(t);\n\t\t}\t\n\t} \n\tint a,b;\n\tfor(int i=0;i<pic[0].size();i++){\n\t\tif(pic[2][i]==0) \n\t\t\ta=pic[0][i];\n\t\telse \n\t\t\ta=200+pic[2][i];\n\t\tif(pic[3][i]==0) \n\t\t\tb=200+pic[1][i];\n\t\telse\n\t\t\tb=pic[3][i];\n\t\tif(a==b)\n\t\t\tdou[a]++;\n\t\tnum[b][1]++;\n\t\tnum[a][0]++;\n\t}\n\tint flag1=0,flag2=0,flag=0;\n\tfor(int i=0;i<403;i++){\n\t\tif(num[i][0]>num[i][1]) {\n\t\t\tif(((num[i][0]-1)==num[i][1])&&(i<200)){\n\t\t\t\tflag1++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(num[i][0]<num[i][1]) {\n\t\t\tif(((num[i][0]+1)==num[i][1])&&(i>=200)){\n\t\t\t\tflag2++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(dou[i]>0&&num[i][0]<=dou[i]&&num[i][1]<=dou[i]){\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n  //freopen(\"/home/alexandero/ClionProjects/ACM/output.txt\", \"w\", stdout);\n  //freopen(\"out.txt\", \"w\", stdout);\n#else\n  //freopen(\"input.txt\", \"r\", stdin);\n  //freopen(\"output.txt\", \"w\", stdout);\n#endif\n  start = clock();\n  int t = 1;\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n  precalc();\n  cout.precision(10);\n  cout << fixed;\n  //cin >> t;\n  int testNum = 1;\n  while (t--) {\n    //cout << \"Case #\" << testNum++ << \": \";\n    //cerr << testNum << endl;\n    solve(true);\n    //cerr << testNum - 1 << endl;\n  }\n  cout.flush();\n#ifdef AIM1\n  while (true) {\n      solve(false);\n  }\n#endif\n\n#ifdef AIM\n  cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\n//#define int li\n//const int mod = 1000000007;\n\nvoid solve(bool read) {\n  int n, H;\n  cin >> n >> H;\n  map<int, int> first_edges, second_edges;\n  set<int> first_bad, second_bad;\n  bool has_zero1 = false, has_zero2 = false;\n  for (int i = 0; i < n; ++i) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if (d == 0) {\n      has_zero2 = true;\n      ++first_edges[b];\n      if (c == b) {\n        first_bad.insert(b);\n      }\n    } else {\n      ++second_edges[d];\n      if (c == 0 && a == d) {\n        second_bad.insert(d);\n      }\n    }\n    if (c == 0) {\n      has_zero1 = true;\n      --second_edges[a];\n    } else {\n      --first_edges[c];\n    }\n  }\n  if (!has_zero1 || !has_zero2) {\n    cout << \"NO\\n\";\n    return;\n  }\n\n  //cout << \"bad: \" << bad_squares << endl;\n  int cnt = 0;\n  int bad = 0;\n  for (auto item : first_edges) {\n    int cur = -item.second;\n    if (first_bad.count(item.first)) {\n      ++cur;\n    }\n    if (cur > 0) {\n        ++bad;\n    }\n    cnt += max(0, cur);\n    //cout << \"first \" << item.first << \" \" << item.second << endl;\n  }\n  for (auto item : second_edges) {\n    int cur = item.second;\n    if (second_bad.count(item.first)) {\n      ++cur;\n    }\n    if (cur > 0) {\n      cout << \"NO\\n\";\n      return;\n    }\n    cnt += max(0, cur);\n    //cout << \"second \" << item.first << \" \" << item.second << endl;\n  }\n\n  if (bad <= 1) {\n    cout << \"YES\\n\";\n  } else {\n    cout << \"NO\\n\";\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 100005\n#define MAXH 405\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint n,h,a[MAXN],b[MAXN],c[MAXN],d[MAXN];\nint indeg[MAXH],outdeg[MAXH];\nbool vis[MAXH];\nvector<int> G[MAXH];\nvoid add_edge(int u,int v)\n{\n    outdeg[u]++;indeg[v]++;\n    G[u].push_back(v);G[v].push_back(u);\n}\nbool dfs(int v)\n{\n    bool f=indeg[v]!=outdeg[v];\n    vis[v]=true;\n    for(auto to:G[v]) if(!vis[to]) f|=dfs(to);\n    return f;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    for(int i=1;i<=n;i++) \n    {\n        scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n        int l,r;\n        if(c[i]==0) l=a[i]; else l=-c[i];\n        if(d[i]==0) r=-b[i]; else r=d[i];\n        add_edge(l+h,r+h);\n    }\n    bool f=true;\n    for(int i=0;i<=h;i++) if(outdeg[i]>indeg[i]) f=false;\n    for(int i=h+1;i<=2*h;i++) if(indeg[i]>outdeg[i]) f=false;\n    memset(vis,false,sizeof(vis));\n    for(int i=0;i<=2*h;i++) if((indeg[i]||outdeg[i])&&!vis[i]) f&=dfs(i);\n    if(f) puts(\"YES\"); else puts(\"NO\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 100005\n#define M 405\nusing namespace std;\nbool bz[N];\nint cd[M],rd[M],n,num,f[M],h,m,v1[M],v2[M];\nint getf(int k)\n{\n\tif(f[k]==k||!f[k]) return k;\n\treturn (f[k]=getf(f[k]));\n}\nint main()\n{\n\tprintf(\"NO\\n\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing db = double;\n#define pb push_back\n\n#define ass(x) ({if(!(x)) return false;})\n\nconst int mxn = 206;\n\nint n, h;\nunordered_map<int,int> deg;\nunordered_map<int,bool> v;\n\nstruct DSU {\n\tunordered_map<int,int> p;\n\tvoid clear() {\n\t\tfor (int i = -200; i <= 200; ++i)\n\t\t\tp[i] = i;\n\t}\n\tint root(int x) {\n\t\treturn p[x] == x ? x : p[x] = root(p[x]);\n\t}\n\tvoid merge(int x, int y) {\n\t\tp[root(x)] = root(y);\n\t}\n\tint operator[](int x) { return root(x); }\n} U;\n\nunordered_map<int,int> f;\n\nbool connected() {\n\tfor (int i = -200; i <= 200; ++i)\n\t\tf[U[i]] |= deg[i] == -1 ? 1 : deg[i] == +1 ? 2 : 0;\n\tfor (int i = -200; i <= 200; ++i) if (v[i])\n\t\tass(f[U[i]] == 3);\n\treturn true;\n}\n\nbool check() {\n\tfor (int i = -200; i <= 200; ++i)\n\t\tass(deg[i] == 0 || deg[i] == +1 && i > 0 || deg[i] == -1 && i < 0);\n\treturn true;\n}\n\nint main() {\n\tcin >> n >> h;\n\t\n\tU.clear();\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x, y;\n\t\tx = c ? -c : a;\n\t\ty = d ? -d : b;\n\t\ty = -y;\n\t\t++deg[x];\n\t\t--deg[y];\n\t\tv[x] = v[y] = true;\n\t\tU.merge(x, y);\n\t}\n\t\n\tputs(check() && connected() ? \"YES\" : \"NO\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\n\nint main() {\n#ifdef HOME\n    freopen(\"in\", \"r\", stdin);\n#endif\n\n    int n, h;\n    while (scanf(\"%d%d\", &n, &h) == 2) {\n        vector<int> a(n), b(n), c(n), d(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%d%d\", &a[i], &b[i], &c[i], &d[i]);\n        }\n\n        vector<int> p(2 * h);\n        iota(p.begin(), p.end(), 0);\n        function<int(int)> get = [&](int x) {\n            return x == p[x] ? x : p[x] = get(p[x]);\n        };\n        auto uni = [&](int u, int v) {\n            p[get(v)] = get(u);\n        };\n        vector<int> deg(2 * h);\n        vector<char> ok(2 * h, 1);\n        for (int i = 0; i < n; i++) {\n            int u = c[i] == 0 ? a[i]-1 : h + c[i]-1;\n            int v = d[i] == 0 ? h+b[i]-1 : d[i]-1;\n            ok[u] = ok[v] = 0;\n            uni(u, v);\n            deg[u]++;\n            deg[v]--;\n        }\n        for (int i = 0; i < 2 * h; i++) if (deg[i] != 0) ok[get(i)] = 1;\n        string ans = \"YES\";\n        for (int i = 0; i < 2 * h; i++) if (p[i] == i && !ok[i]) ans = \"NO\";\n        cout << ans << endl;\n    }\n\n#ifdef HOME\n    cerr << clock() / (double)CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << to_string(v[i]);\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 3030303\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(mi a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n\nbool dfs(int v, int b, vector<vector<int>>& g, vector<bool>& used,\n         vector<int>& ideg, vector<int>& odeg) {\n    used[v] = true;\n    bool ret = false;\n    if(v % 2 != b) ret = true;\n    if(ideg[v] != odeg[v]) ret = true;\n    REP(i, g[v].size()) {\n        if(used[g[v][i]]) continue;\n        ret = ret | dfs(g[v][i], b, g, used, ideg, odeg);\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, h;\n    cin >> n >> h;\n    vector<vector<int>> g(2 * (h + 1));\n    vector<int> ideg(2 * (h + 1), 0), odeg(2 * (h + 1), 0);\n    vector<pair<int, int>> p1(h + 1), p2(h + 1);\n    REP(i, n) {\n        int a, b, c, d;\n        int p = 0, q = 0;\n        cin >> a >> b >> c >> d;\n        if(c == 0) {\n            p1[a].first++;\n            p = 2 * a;\n        } else {\n            p2[c].first++;\n            p = 2 * c + 1;\n        }\n        if(d) {\n            p1[d].second++;\n            q = 2 * d;\n        }\n        else {\n            p2[b].second++;\n            q = 2 * b + 1;\n        }\n        g[p].pb(q);\n        g[q].pb(p);\n        odeg[p]++;\n        ideg[q]++;\n    }\n    int c1 = 0, c2 = 0;\n    REP(i, h + 1) {\n        if(p1[i].first < p1[i].second) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        c1 += p1[i].first - p1[i].second;\n        if(p2[i].second < p2[i].first) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        c2 += p2[i].second - p2[i].first;\n    }\n    if(c1 != c2) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    vector<bool> used(2 * (h + 1), false);\n    REP(i, 2 * (h + 1)) {\n        if(g[i].empty() || used[i]) continue;\n        if(!dfs(i, i % 2, g, used, ideg, odeg)) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define neko 100005\n#define heko 405\n#define qwq return putchar('Y'),putchar('E'),putchar('S'),0; \n#define orz return putchar('N'),putchar('O'),0; \n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))\nstatic int n,H;\ntypedef int arr[heko];\nstatic arr fa,book,dg,out;\nconst unsigned int bufsize=1<<16,outsize=1<<16;\nstatic char ch[bufsize],*S=ch,*T=ch;\ninline char getc()\n{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\nstatic char Out[outsize],*nowp=Out;\ninline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\nvoid read(T &x)\n{\n\tchar c=getc();x=0;\n\tfor(;!isdigit(c);c=getc());\n\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n}\ninline int find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}\nint main()\n{\n\tint x,y,z,o,X,Y,HH;\n\tread(n),read(H),HH=H<<1;\n\tf(i,0,HH)fa[i]=i;\n\tf(i,1,n)\n\t{\n\t\tread(x),read(y),read(z),read(o);\n\t\tX=z?H-z:H+x;\n\t\tY=o?H+o:H-y;\n\t\tbook[X]=book[Y]=1;\n\t\t//++dgi[Y],++dgo[X];\n\t\t--dg[Y],++dg[X];\n\t\tfa[find(Y)]=find(X);\n\n\t}\n\tf(i,0,H)if(dg[i]>0)orz;\n\tf(i,H+1,HH)if(dg[i]<0)orz;\n\tf(i,0,HH)out[fa[i]]|=dg[i];\n\tf(i,0,HH)if(fa[i]==i&&book[i]&&!out[fa[i]])orz;\n\tqwq;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int> g[505];\nint l_cnt[505], r_cnt[505];\nbool used[505];\n\nint print(bool ok) {\n        if (ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n}\n\nbool dfs(int v) {\n        if (g[v].empty()) return true;\n        used[v] = true;\n        bool res = l_cnt[v] != r_cnt[v]; //端になりうる？\n        for (auto u : g[v]) if (!used[u]) res |= dfs(u); //パーツが足りる？\n        return res;\n}\n\nint main() {\n        int n, h, a, b, c, d;\n        cin >> n >> h;\n        for (int i = 0; i < n; i ++) {\n                cin >> a >> b >> c >> d;\n                int lh = (c == 0 ? a : c + 250);\n                int rh = (d == 0 ? b + 250 : d);\n                l_cnt[lh] ++;\n                r_cnt[rh] ++;\n                g[lh].push_back(rh);\n                g[rh].push_back(lh);\n//cerr << lh << ' ' << rh << endl;\n        }\n        for (int i = 0; i < h + 1; i ++) if (r_cnt[i] > l_cnt[i]) return print(0);\n        for (int i = 251; i < h + 251; i ++) if (l_cnt[i] > r_cnt[i]) return print(0);\n        for (int i = 0; i < 501; i ++) if (!used[i]) if (!dfs(i)) return print(0);\n        return print(1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 1000;\nconst int ZERO = 250;\n\nint n, h;\nint fa[MAXN], deg[MAXN], vis[MAXN], ok[MAXN];\n\nint find(int x)\n{\n\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tfa[find(x)] = find(y);\n}\n\nvoid no()\n{\n\tcout << \"NO\" << endl;\n\texit(0);\n}\n\nvoid yes()\n{\n\tcout << \"YES\" << endl;\n\texit(0);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n >> h;\n\tfor(int i = -h + ZERO; i <= h + ZERO; i++)\n\t\tfa[i] = i;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint a, b, c, d, l, r;\n\t\tcin >> a >> b >> c >> d;\n\t\tl = (c == 0 ? a : -c);\n\t\tr = (d == 0 ? -b : d);\n\t\tdeg[l + ZERO]++, vis[l + ZERO]++;\n\t\tdeg[r + ZERO]--, vis[r + ZERO]++;\n\t\tunite(l + ZERO, r + ZERO);\n\t\t// cerr << l << ' ' << r << endl;\n\t}\n\tfor(int i = -h + ZERO; i <= -1 + ZERO; i++)\n\t\tif(deg[i] > 0)\n\t\t\tno();\n\tfor(int i = 1 + ZERO; i <= h + ZERO; i++)\n\t\tif(deg[i] < 0)\n\t\t\tno();\n\tfor(int i = -h + ZERO; i <= h + ZERO; i++)\n\t\tif(deg[i] != 0)\n\t\t\tok[find(i)] = true;\n\tfor(int i = -h + ZERO; i <= h + ZERO; i++)\n\t\tif(find(i) == i && vis[i] && !ok[i])\n\t\t\tno();\n\tyes();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 10005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n        if(c == '-') f = -1;\n        c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n        res = res * 10 + c - '0';\n        c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n        out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint g[405][405],f[405][405],ind[405],H,col[405],all;\nint N,A[100005],B[100005],C[100005],D[100005],cnt;\nbool vis[405],flag,has[405];\nvoid dfs(int u) {\n    all += ind[u];\n    if(ind[u]) flag = 1;\n    vis[u] = 1;\n    for(int i = 1 ; i <= 2 * H ; ++i) {\n        if(f[u][i] && !vis[i]) dfs(i);\n    }\n}\nvoid Solve() {\n    read(N);read(H);\n    for(int i = 1 ; i <= N ; ++i) {\n        read(A[i]);read(B[i]);read(C[i]);read(D[i]);\n        int s,t;\n        if(C[i]) s = C[i];\n        else s = A[i] + H;\n        if(D[i]) t = D[i] + H;\n        else t = B[i];\n        g[s][t]++;ind[t]++;ind[s]--;\n        f[s][t]++;f[t][s]++;\n        has[s] = has[t] = 1;\n    }\n    for(int i = 1 ; i <= H ; ++i) {\n        if(ind[i] < 0) {puts(\"NO\");return;}\n    }\n    for(int i = H + 1 ; i <= 2 * H ; ++i) {\n        if(ind[i] > 0) {puts(\"NO\");return;}\n    }\n    for(int i = 1 ; i <= 2 * H ; ++i) {\n        if(!has[i]) continue;\n        if(!vis[i]) {\n            flag = 0;\n            dfs(i);\n            if(all != 0 || !flag) {puts(\"NO\");return;}\n        }\n    }\n    puts(\"YES\");\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define pb push_back\n\nusing namespace std;\n\nconst int N=100005,M=205;\n\nvector<int> vle[M],vlf[M],vre[M],vrf[M];\nbitset<N> v[4][M];\nint n,h,a[N],b[N],c[N],d[N],f1,f2;\n\nint main(){\n\tscanf(\"%d%d\",&n,&h);int x,y,i;\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n\t\tif(!c[i]){\n\t\t\tvlf[a[i]].pb(i);\n\t\t\tv[0][a[i]][i]=1;\n\t\t}else{\n\t\t\tvle[c[i]].pb(i);\n\t\t\tv[1][c[i]][i]=1;\n\t\t}\n\t\tif(!d[i]){\n\t\t\tvrf[b[i]].pb(i);\n\t\t\tv[2][b[i]][i]=1;\n\t\t}else{\n\t\t\tvre[d[i]].pb(i);\n\t\t\tv[3][d[i]][i]=1;\n\t\t}\n\t}\n\tfor(i=0;i<=h;i++){\n\t\tx=vle[i].size(),y=vrf[i].size();\n\t\tif(x>y)puts(\"NO\"),exit(0);\n\t\tif(x && x==y && v[1][i]==v[2][i]) puts(\"NO\"),exit(0);\n\t\tx=vre[i].size(),y=vlf[i].size();\n\t\tif(x>y)puts(\"NO\"),exit(0); \n\t\tif(x && x==y && v[0][i]==v[3][i]) puts(\"NO\"),exit(0);\n\t}\n\tif(!f1&&!f2)puts(\"YES\");else puts(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,h,deg[410],cnt,sum,gap[410],dis[410],s,t;\nbool flag[410];\nstruct edge\n{\n    int v,f;\n    edge *nxt,*rev;\n} pool[210000],*tp=pool,*fst[410],*cur[410];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nvoid addedge(int u,int v,int f)\n{\n    ++deg[u],--deg[v];\n    *tp=(edge){v,f,fst[u],tp+1},fst[u]=tp++;\n    *tp=(edge){u,0,fst[v],tp-1},fst[v]=tp++;\n}\n\nint sap(int x,int flow)\n{\n    if (x==t)\n        return flow;\n    int sum=0,f;\n    for (edge *i=cur[x]; i; i=i->nxt)\n        if (i->f && dis[i->v]+1==dis[x])\n        {\n            f=sap(i->v,min(flow-sum,i->f));\n            i->f-=f,i->rev->f+=f,cur[x]=i;\n            if ((sum+=f)==flow || dis[s]==t)\n                return sum;\n        }\n    if (!--gap[dis[x]])\n        dis[s]=t;\n    ++gap[++dis[x]],cur[x]=fst[x];\n    return sum;\n}\n\nvoid dfs(int x)\n{\n    if (flag[x])\n        return;\n    flag[x]=1;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (i->f)\n            ++cnt,dfs(i->v);\n}\n\nbool check()\n{\n    repu(i,1,n)\n    {\n        int a=getint(),b=getint(),c=getint(),d=getint();\n        int u=c?c:h+a,v=d?h+d:b;\n        addedge(u,v,1);\n    }\n    s=h*2+1,t=s+1;\n    repu(i,h+1,h*2)\n        if (deg[i]>0)\n            dfs(i),sum+=deg[i];\n    if (cnt<n)\n        return 0;\n    repu(i,1,h*2)\n    {\n        if (deg[i]>0)\n            if (i>h)\n                addedge(s,i,deg[i]);\n            else\n                return 0;\n        if (deg[i]<0)\n            if (i<=h)\n                addedge(i,t,-deg[i]);\n            else\n                return 0;\n    }\n    gap[0]=t;\n    repu(i,1,t)\n        cur[i]=fst[i];\n    for (; dis[s]<t; sum-=sap(s,1<<30));\n    return !sum;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    puts(check()?\"YES\":\"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MX=411, inf=2e9;\n\nint n, h;\n\nint indeg[MX], outdeg[MX];\n\nint U[MX];\nint find(int x){\n    return x==U[x] ? x : U[x]=find(U[x]);\n}\nvoid unite(int x, int y){\n    U[find(y)]=find(x);\n}\n\nbool solve(){\n    bool st[MX]={}, ed[MX]={};\n    for(int i=1; i<=h; i++){\n        if(indeg[i]<outdeg[i]) return false;\n        if(indeg[i]==0) continue;\n        ed[find(i)]=true;\n    }\n    for(int i=h+1; i<=2*h; i++){\n        if(indeg[i]>outdeg[i]) return false;\n        if(outdeg[i]==0) continue;\n        st[find(i)]=true;\n    }\n    for(int i=1; i<=2*h; i++){\n        if(indeg[i]==0 && outdeg[i]==0) continue;\n        int x=find(i);\n        if(!st[x] || !ed[x]) return false;\n    }\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin>>n>>h;\n    iota(U, U+2*h+1, 0);\n    for(int i=1; i<=n; i++){\n        int a, b, c, d; cin>>a>>b>>c>>d;\n        int x = (c==0 ? h+a : c), y = (d==0 ? b : h+d);\n        unite(x, y);\n        outdeg[x]++, indeg[y]++;\n    }\n    cout<<(solve() ? \"YES\" : \"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <queue>\n#include <limits>\n#include <deque>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#define mp make_pair\n#define fs first\n#define se second\n#define memset(a,t) memset(a,t,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define MN 0LL\n#define Mx 200000005\n#define Mn -Mx\n#define MX 20000000000000005\nusing namespace std;\nint readint(){\n\tchar c;\n\twhile(c=getchar(),(c<'0'||c>'9')&&c!='-');\n\tbool flag=(c=='-');\n\tif(flag)c=getchar();\n\tint x=0;\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn flag?-x:x;\n}\ninline string tos(int x){\n\tstring s;\n\twhile(x) s=(char)(x%10+'0')+s,x/=10;\n\treturn s;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint r;\n\tsrand(time(NULL));\n\tr=rand()%2;\n\tif(r==1) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint num[403][2]={0}; \nint main(){\n\tint n,h,t;\t\n\tcin>>n>>h;\n\tvector<int>pic[4];\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tpic[j].push_back(t);\n\t\t}\t\n\t} \n\tfor(int i=0;i<pic[0].size();i++){\n\t\tif(pic[2][i]==0) \n\t\t\tnum[pic[0][i]][0]++;\n\t\telse \n\t\t\tnum[200+pic[2][i]][0]++;\n\t\tif(pic[3][i]==0) \n\t\t\tnum[200+pic[1][i]][1]++;\n\t\telse \n\t\t\tnum[pic[3][i]][1]++;\n\t}\n\tint flag1=0,flag2=0,flag=0;\n\tfor(int i=0;i<403;i++){\n\t\tif(num[i][0]>num[i][1]) {\n\t\t\tif(((num[i][0]-1)==num[i][1])&&(i<200)){\n\t\t\t\tflag1++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t\tif(num[i][0]<num[i][1]) {\n\t\t\tif(((num[i][0]+1)==num[i][1])&&(i>=200)){\n\t\t\t\tflag2++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag1==flag2&&flag1==1&&flag==0) cout<<\"YES\";\n\telse cout<<\"NO\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,H;\n\nint fa[maxn],vi[maxn],Is[maxn],deg[maxn];\n\nint find(int i){return fa[i]==i?i:fa[i]=find(fa[i]);}\n\nvoid Work(){\n\tREP(i,0,H)if(deg[i]<0)return void(puts(\"NO\"));\n\tREP(i,H,H*2)if(deg[i]>0)return void(puts(\"NO\"));\n\tREP(i,0,H*2)if(deg[i])Is[find(i)]=1;\n\tREP(i,1,n)if(find(i)==i&&vi[i]&&!Is[i])return void(puts(\"NO\"));\n\tputs(\"YES\");\n}\n\nvoid Init(){\n\tread(n,H);\n\tREP(i,0,H*2)fa[i]=i;\n\tREP(i,1,n){\n\t\tint a,b,c,d;\n\t\tread(a,b,c,d);\n\t\tint x,y;\n\t\tx=c==0?-a:c;\n\t\ty=d==0?b:-d;\n\t\tx+=H;y+=H;\n\t\tdeg[x]++;deg[y]--;\n\t\tfa[find(x)]=find(y);\n\t\tvi[x]=vi[y]=1;\n\t}\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define rs (x<<1|1)\n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=1e3+5;\nint n,h;\nint hasL[maxn],hasR[maxn],needL[maxn],needR[maxn];\nint main(){\n\tread(n);read(h);\n\trep(i,1,n){\n\t\tint a,b,c,d;read(a);read(b);read(c);read(d);\n\t\tif(!c)hasL[a]++;\n\t\telse needL[c]++;\n\t\tif(!d)hasR[b]++;\n\t\telse needR[d]++;\n\t}\n\trep(i,1,200)if(hasL[i]<needL[i])return puts(\"NO\"),0;\n\trep(i,1,200)if(hasR[i]<needR[i])return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> emp[2][205],bmp[2][205];\nbool vis[100005];\nint a[100005],c[100005],d[100005],b[100005];\nint n,h,gi;\n\nbool fille(int i)\n{\n    vis[i] = true;\n    if(d[i]==0)\n    {\n        for(int j=0;j<emp[1][b[i]].size();++j)\n        {\n\n            if(vis[emp[1][b[i]][j]]) continue;\n            return fille(emp[1][b[i]][j]);\n        }\n        return true;\n    }else\n    {\n        for(int j=0;j<emp[0][d[i]].size();++j)\n        {\n            if(vis[emp[0][d[i]][j]])continue;\n            return fille(emp[0][d[i]][j]);\n        }\n        return false;\n    }\n}\n\nbool fillb(int i)\n{\n    vis[i] = true;\n    if(c[i]==0)\n    {\n        for(int j=0;j<bmp[1][a[i]].size();++j){\n            if(vis[bmp[1][a[i]][j]]) continue;\n            if(!fillb(bmp[1][a[i]][j]))continue;\n        }\n        if(!fille(gi)){\n            return vis[i] = false;\n        }\n        return true;\n    }else{\n        for(int j=0;j<bmp[0][c[i]].size();++j)\n        {\n            if(vis[bmp[0][c[i]][j]]) continue;\n            if(fillb(bmp[0][c[i]][j])) return true;\n        }\n        return vis[i] = false;\n    }\n}\n\n\n\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        if(c[i]==0)\n        {\n            emp[0][a[i]].push_back(i);\n        }else emp[1][c[i]].push_back(i);\n        if(d[i]==0) bmp[0][b[i]].push_back(i);\n        else bmp[1][d[i]].push_back(i);\n    }\n    bool ag = true;\n    for(gi=0;gi<n;++gi)\n    {\n        if(vis[gi]||(c[gi]==0&&d[gi]==0)) continue;\n        if((!fillb(gi)))\n        {\n            ag= false;break;\n        }\n    }\n    if(ag) printf(\"YES\");\n    else printf(\"NO\");\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N,H;\nint A[111111],B[111111],C[111111],D[111111];\n\n\nint M=500;\nint deg[1111];\nbool used[1111];\n\nsigned main(){\n    cin>>N>>H;\n    UnionFindTree uf(1111);\n    rep(i,N){\n        cin>>A[i]>>B[i]>>C[i]>>D[i];\n\n        int u,v;\n        if(C[i]==0){\n            u=A[i];\n        }\n        else{\n            u=M+C[i];\n        }\n\n        if(D[i]==0){\n            v=M+B[i];\n        }\n        else{\n            v=D[i];\n        }\n\n        uf.unite(u,v);\n        used[u]=used[v]=true;\n        deg[u]++;\n        deg[v]--;\n\n    }\n\n\n\n    used[2*M]=true;\n    int ei=0,uku=0;\n    rep(i,M){\n        if(deg[i]<0){\n            cout<<\"NO\"<<endl;\n            return 0;\n        }\n        if(deg[i]>0){\n            ei+=deg[i];\n            uf.unite(2*M,i);\n        }\n    }\n\n    for(int i=M;i<2*M;i++){\n        if(deg[i]>0){\n            cout<<\"NO\"<<endl;\n        }\n        if(deg[i]<0){\n            uku+=-deg[i];\n            uf.unite(2*M,i);\n        }\n    }\n\n    if(ei!=uku||ei==0){\n        cout<<\"NO\"<<endl;\n        return 0;\n    }\n\n\n    rep(i,1111)rep(j,1111){\n        if(!used[i]||!used[j])continue;\n        if(!uf.areSame(i,j)){\n            cout<<\"NO\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MH = 410;\n\nint N, H;\nvi g[MH];\nint in[MH], out[MH];\nbool vis[MH];\n\nbool dfs(int v) {\n\tvis[v] = 1;\n\tbool f = 0;\n\tif (in[v] != out[v]) f = 1;\n\tfor (int to : g[v]) if (!vis[to]) {\n\t\tif (dfs(to)) {\n\t\t\tf = 1;\n\t\t}\n\t}\n\treturn f;\n}\n\nint main() {\n\tscanf(\"%d %d\", &N, &H);\n\trep(i, N) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tint l = (c == 0 ? a : -c) + H;\n\t\tint r = (d == 0 ? -b : d) + H;\n\t\tg[l].pb(r); g[r].pb(l);\n\t\t++in[r]; ++out[l];\n\t}\n\tfor (int i = 1; i <= H; ++i) {\n\t\tif (in[i + H] > out[i + H]) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (in[H - i] < out[H - i]) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tbool ok = 1;\n\trep(i, MH) {\n\t\tif (in[i] + out[i] > 0 && !vis[i]) {\n\t\t\tif (!dfs(i)) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(ok ? \"YES\" : \"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=410;\nint n,h,in[N],out[N];\nint fa[N];\nbool ok[N];\n\nint find(const int &x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\nint main()\n{\n    n=read();h=read();\n    for(int i=1;i<=(h<<1);i++) fa[i]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int A=read(),B=read(),C=read(),D=read();\n        int x=C?C+h:A,y=D?D:B+h;\n        out[x]++;in[y]++;\n        x=find(x);y=find(y);\n        if(x!=y) fa[x]=y;\n    }\n    for(int i=1;i<=h;i++) if(in[i]>out[i]) return !puts(\"NO\");\n    for(int i=h+1;i<=(h<<1);i++) if(in[i]<out[i]) return !puts(\"NO\");\n    for(int i=1;i<=(h<<1);i++) if(in[i]!=out[i]||!in[i]&&!out[i]) ok[find(i)]=1;\n    for(int i=1;i<=(h<<1);i++) if(fa[i]==i&&!ok[i]) return !puts(\"NO\");\n    return !puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    int n,h;\n    cin >>n>>h;\n    vector<pair<int,int>> rb{},lb{},rt{},lt{};\n    for (int i=0;i<n;i++){\n        int a,b,c,d;\n        cin>>a>>b>>c>>d;\n        if(c==0){\n            lb.push_back({i,a});\n        }else{\n            lt.push_back({i,c});\n        }\n        if(d==0){\n            rb.push_back({i,b});\n        }else{\n            rt.push_back({i,d});\n        }\n    }\n    if(lt.size()==0&&rt.size()==0){\n        cout<<\"YES\"<<endl;\n        return 0;\n    }\n    sort(lb.begin(),lb.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(rb.begin(),rb.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(lt.begin(),lt.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(rt.begin(),rt.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n\n//    cout<<rb.size()<<\" \"\n//        <<rt.size()<<\" \"\n//        <<lb.size()<<\" \"\n//        <<lt.size()<<endl;\n\n    if(rb.size()-lt.size()<=0 ||\n       lb.size()-rt.size()<=0 ||\n       rb.size()-lt.size()!=lb.size()-rt.size()\n       ) {\n        cout<<\"NO\"<<endl;\n        return 0;\n    }\n    if(rb.size()==lt.size()+1){\n        int k=rb.size()-1,l=lb.size()-1;\n        for(int i=0;i<lt.size();i++){\n            static int offset=0;\n            if(lt.at(i).second!=rb.at(i+offset).second){\n                if(offset==1){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                if(lt.at(i).second!=rb.at(i+1).second){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                offset=1;\n                k=i;\n            }\n        }\n        for(int i=0;i<rt.size();i++){\n            static int offset=0;\n            if(rt.at(i).second!=lb.at(i+offset).second){\n                if(offset==1){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                if(rt.at(i).second!=lb.at(i+1).second){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                offset=1;\n                l=i;\n            }\n        }\n        if(rb.at(k).first==lb.at(l).first){\n            if((k==rb.size()-1 || rb.at(k+1).second!=rb.at(k).second) &&\n               (k==0 || rb.at(k-1).second!=rb.at(k).second) &&\n               (l==lb.size()-1 || lb.at(l+1).second!=lb.at(l).second) &&\n               (l==0 || lb.at(l-1).second!=lb.at(l).second)) {\n\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n        }\n        cout<<\"YES\"<<endl;\n        return 0;\n    }\n    for(int i=0;i<lt.size();i++){\n        static int offset=0;\n        while(lt.at(i).second!=rb.at(i+offset).second){\n            if(offset==rb.size()-lt.size()){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            offset++;\n        }\n    }\n    for(int i=0;i<rt.size();i++){\n        static int offset=0;\n        while(rt.at(i).second!=lb.at(i+offset).second){\n            if(offset==lb.size()-rt.size()){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            offset++;\n        }\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nint n,h,a[N],b[N],c[N],d[N];\n//是否存在可行流\nstruct edge{int f,t,g;}w[N];\nint s,t,S,T,head[N],nxt[N],cnt=1,I[N],O[N];\nvoid add(int f,int t,int g){\n\t//printf(\"%d->%d g=%d\\n\",f,t,g);\n\tw[++cnt]=(edge){f,t,g};\n\tnxt[cnt]=head[f];\n\thead[f]=cnt;\n\tw[++cnt]=(edge){t,f,0};\n\tnxt[cnt]=head[t];\n\thead[t]=cnt;\n}\nstruct st{\n\tint x,i,df;\n\tst(int X=0,int DF=0){x=X;i=head[x];df=DF;}\n}z[N];\nint top,flow,l[N];\n#define V z[top].x\n#define E z[top].i\n#define F z[top].df\nvoid change(){\n\tint df=F;flow+=df;\n\tfor (int i=top-1;i;i--){\n\t\tw[z[i].i].g-=df;\n\t\tw[z[i].i^1].g+=df;\n\t\tz[i].df-=df;\n\t\tif (!z[i].df) top=i;\n\t}\n}\nqueue<int> Q;\nvoid bfs(){\n\tfor (int i=s;i<=t;i++) l[i]=0;\n\tl[s]=1;Q.push(s);\n\twhile (!Q.empty()){\n\t\tint v=Q.front();Q.pop();\n\t\tfor (int i=head[v];i;i=nxt[i])\n\t\tif (w[i].g&&!l[w[i].t]) l[w[i].t]=l[v]+1,Q.push(w[i].t);\n\t}\n}\nbool dinic(){\n\tbfs();\n\tif (!l[t]) return 0;\n\tz[top=1]=st(s,1e9);\n\twhile (top){\n\t\tif (V==t) change(),top--,E=nxt[E];else\n\t\tif (!E) l[V]=0,top--,E=nxt[E];else\n\t\tif (w[E].g&&l[w[E].t]==l[V]+1)\n\t\t\tz[top+1]=st(w[E].t,min(F,w[E].g)),top++;\n\t\telse E=nxt[E];\n\t}\n\treturn 1;\n}\nvector<int> e[N];\nbool cir[N],vis[N];\nvoid bfs(int S,bool *vis){\n\tQ.push(S);vis[S]=1;\n\twhile (!Q.empty()){\n\t\tint v=Q.front();Q.pop();\n\t\tfor (int i=0;i<e[v].size();i++){\n\t\t\tint u=e[v][i];\n\t\t\tif (!vis[u]) vis[u]=1,Q.push(u);\n\t\t}\n\t}\n}\nint main()\n{\n\tputs(\"NO\");\n\t/*freopen(\"a.txt\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tint f=(c[i]?c[i]+h:a[i]),t=(d[i]?d[i]:b[i]+h);\n\t\te[f].push_back(t);\n\t\tI[t]++;O[f]++;\n\t\tif (f==t) cir[f]=1;\n\t}\n\ts=0;S=h*2+1;T=S+1;t=T+1;\n\tadd(T,S,1e9);\n\tfor (int i=1;i<=2*h;i++){\n\t\tif (I[i]) add(s,i,I[i]);\n\t\tif (O[i]) add(i,t,O[i]);\n\t\tif (i>h) add(i,T,1e9);else add(S,i,1e9);\n\t}\n\twhile (dinic());\n\tif (flow!=n) return puts(\"NO\"),0;\n\tfor (int i=2;i<=cnt;i++)\n\t\tif (w[i^1].g) e[w[i].f].push_back(w[i].t);\n\tbfs(S,vis);\n\tfor (int i=1;i<=2*h;i++)\n\t\tif ((I[i]||O[i])&&!vis[i]) return puts(\"NO\"),0;\n\tputs(\"YES\");*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 500\nusing namespace std;\nint read(){\n    int nm=0,fh=1; int cw=getchar();\n    for(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n    for(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n    return nm*fh;\n}\nint n,m,e1,e2,h1,h2,cnt,in[M],ot[M],f[M]; bool vs[M];\nint fd(int x){return x==f[x]?x:f[x]=fd(f[x]);}\nint main(){\n    n=read(),m=read();\n    for(int i=1;i<=m;i++) f[i]=i,f[i+m]=i+m,vs[i]=vs[i+m]=false;\n    for(int i=1;i<=n;i++){\n        h1=read(),h2=read(),e1=read(),e2=read();\n        int t1=e1>0?e1:-h1,t2=e2>0?-e2:h2; t1+=m,t2+=m;\n        if(fd(t1)!=fd(t2)) f[fd(t1)]=fd(t2); in[t2]++,ot[t1]++;\n    }\n    for(int i=-m;i<0;i++) if(in[i+m]>ot[i+m]){puts(\"NO\");return 0;}\n    for(int i=1;i<=m;i++) if(in[i+m]<ot[i+m]){puts(\"NO\");return 0;}\n    for(int i=0;i<=m+m;i++) if(in[i]!=ot[i]) vs[fd(i)]=true;\n    for(int i=0;i<=m+m;i++) if(in[i]&&ot[i]&&!vs[fd(i)]){puts(\"NO\");return 0;}\n    puts(\"YES\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nint n,h;\nint l[220],r[220],bns,fa[420],siz[420],L,R;\nint find(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=400;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0)l[a]++,bns++,L=a;\n\t\telse r[c]--,bns--,L=a;\n\t\tif(d==0)r[b]++,bns++,R=b+200;\n\t\telse l[d]--,bns--,R=d+200;\n\t\tif(find(L)==find(R)){\n\t\t\tsiz[find(L)]++;\n\t\t\tcontinue;\n\t\t}\n\t\tsiz[find(R)]+=siz[find(L)]+1;\n\t\tsiz[find(L)]=0;\n\t\tfa[find(L)]=find(R);\n\t}\n\tint ans=0,cns=0;\n\tfor(int i=1;i<=200;i++){\n\t\tans+=l[i];\n\t\tans+=r[i];\n\t\tif(l[i]<0||r[i]<0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(l[i])cns+=siz[find(i)],siz[find(i)]=0;\n\t\tif(r[i])cns+=siz[find(i+200)],siz[find(i+200)]=0;\n\t//\tsiz[find(i)]=0;\n\t}\n\tif(bns<=0||ans!=bns||cns!=n){\n\t\tprintf(\"NO\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    using namespace std;\n    struct edge{\n    int k,w,next;\n    }e[1000005];\n    struct P{\n    int a,b,c,d;\n    }a[100005];\n    int n,h,home[805],cnt=-1,T,IN[805],du[805];\n    void add(int x,int y,int w){\n    cnt++;\n    e[cnt].k=y;\n    e[cnt].w=w;\n    e[cnt].next=home[x];\n    home[x]=cnt;\n    }\n    void insert(int x,int y,int w){\n    add(x,y,w);add(y,x,0);\n    }\n    int q[805],d[805];\n    void bfs(int S){\n    memset(d,-1,sizeof(d));\n    int tou=0,wei=1,k;\n    q[0]=S;d[S]=0;\n    while(tou<wei){\n    k=q[tou++];\n    for(int i=home[k];~i;i=e[i].next) if(d[e[i].k]==-1&&e[i].w){\n    d[e[i].k]=d[k]+1;\n    q[wei++]=e[i].k;\n    }\n    }\n    }\n    int dfs(int k,int flow,int T){\n    if(k==T||!flow) return flow;\n    int w,used=0;\n    for(int i=home[k];~i;i=e[i].next)if(d[e[i].k]==d[k]+1){\n    w=flow-used;\n    w=dfs(e[i].k,min(w,e[i].w),T);\n    used+=w;\n    e[i].w-=w;\n    e[i^1].w+=w;\n    }\n    if(used<flow) d[k]=-1;\n    return used;\n    }\n    int dinic(int S,int T){\n    int flow=0;\n    while(1){\n    bfs(S);\n    if(d[T]==-1) return flow;\n    flow+=dfs(S,1e9,T);\n    }\n    }\n    int main(){\n    memset(home,-1,sizeof(home));\n    scanf(\"%d%d\",&n,&h);\n    T=h+h+1;\n    for(int i=1;i<=n;i++){\n    scanf(\"%d%d%d%d\",&a[i].a,&a[i].b,&a[i].c,&a[i].d);\n    int x=(a[i].c?h+a[i].c:a[i].a),y=(a[i].d?a[i].d:h+a[i].b);\n    IN[y]++;IN[x]--;\n\tinsert(x,y,1);\n    }\n\tint sum=0;\n\tfor(int i=1;i<=h;insert(0,i,-IN[i]),i++) if(IN[i]>0) return puts(\"NO\"),0;\n\tfor(int i=h+1;i<=h+h;sum+=IN[i],insert(i,T,IN[i]),i++) if(IN[i]<0) return puts(\"NO\"),0;\n    int ans=dinic(0,T);\n    if(ans==sum&&sum) puts(\"YES\");\n\telse puts(\"NO\");\n    return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000000;\nint A[N], B[N], C[N], D[N];\nconst int INF = 1000000000;\n#define LL long long\nclass ZKW\n{\npublic:\n\tint lt[N], nt[N], bi[N], ci[N], di[N], tl;\n\tint sla[N], vis[N], dis[N];\n\tqueue <int> Q;\n\tint s, e, tot;\n\tLL ans;\n\tvoid flow(int p, int nl)\n\t{\n\t\tans += di[p] * nl;\n\t\tci[p] -= nl;\n\t\tci[(p & 1? p + 1: p - 1)] += nl;\n\t}\n\tint dfs(int nw, int mx)\n\t{\n\t\tvis[nw] = 1;\n\t\tif (nw == e) return mx;\n\t\tint hl = 0;\n\t\tfor (int p = lt[nw]; p; p = nt[p])\n\t\t\tif ((ci[p]) && (!vis[bi[p]]))\n\t\t\t\tif (dis[nw] + di[p] == dis[bi[p]])\n\t\t\t\t{\n\t\t\t\t\tint nl = dfs(bi[p], min(ci[p], mx - hl));\n\t\t\t\t\thl += nl;\n\t\t\t\t\tflow(p, nl);\n\t\t\t\t\tif (hl == mx) return mx;\n\t\t\t\t}\n\t\t\t\telse sla[bi[p]] = min(sla[bi[p]], dis[nw] + di[p] - dis[bi[p]]);\n\t\treturn hl;\n\t}\n\tvoid SPFA()\n\t{\n\t\tfor (int i = 1; i <= tot; ++ i) dis[i] = INF; dis[s] = 0;\n\t\tfor (int i = 1; i <= tot; ++ i) vis[i] = 0; vis[s] = 1;\n\t\twhile (!Q.empty()) Q.pop(); Q.push(s);\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint nw = Q.front(); Q.pop(); vis[nw] = 0;\n\t\t\tfor (int p = lt[nw]; p; p = nt[p])\n\t\t\t\tif (ci[p])\n\t\t\t\t\tif (dis[nw] + di[p] < dis[bi[p]])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[bi[p]] = dis[nw] + di[p];\n\t\t\t\t\t\tif (!vis[bi[p]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvis[bi[p]] = 1;\n\t\t\t\t\t\t\tQ.push(bi[p]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t}\n\t}\n\tint solve()\n\t{\n\t\tint hl = 0;\n\t\tSPFA();\n\t\twhile (true)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tfor (int i = 1; i <= tot; ++ i) sla[i] = INF;\n\t\t\t\tfor (int i = 1; i <= tot; ++ i) vis[i] = 0;\n\t\t\t\thl += dfs(s, INF);\n\t\t\t}\n\t\t\twhile (vis[e]);\n\t\t\tint minsla = INF;\n\t\t\tfor (int i = 1; i <= tot; ++ i) if (!vis[i]) minsla = min(minsla, sla[i]);\n\t\t\tif (minsla == INF) break;\n\t\t\tfor (int i = 1; i <= tot; ++ i) if (!vis[i]) dis[i] += minsla;\n\t\t}\n\t\treturn hl;\n\t}\n\tvoid build(int a, int b, int c, int d = 1)\n\t{\n\t\tnt[++ tl] = lt[a]; lt[a] = tl; bi[tl] = b; ci[tl] = c; di[tl] = d;\n\t\tnt[++ tl] = lt[b]; lt[b] = tl; bi[tl] = a; ci[tl] = 0; di[tl] = -d;\n\t}\n\tvoid init()\n\t{\n\t\tfor (int i = 1; i <= tot; ++ i) lt[i] = 0;\n\t\tfor (int i = 1; i <= tl; ++ i) bi[i] = ci[i] = di[i] = nt[i] = 0;\n\t\ts = e = tot = tl = 0;\n\t}\n} F;\n\n\nint n, h;\nint P[N];\nint main()\n{\n    cin >> n >> h;\n    F.s = n * 2 + h * 2 + 1; F.e = F.tot = F.s + 1;\n    for (int i = 1; i <= n; ++ i)\n    {\n        cin >> A[i] >> B[i] >> C[i] >> D[i];\n        F.build(i, i + n, 1, -3); P[i] = F.tl - 1;\n        if (C[i] == 0)\n        {\n            F.build(F.s, i, 1);\n            F.build(n * 2 + A[i], i, 1);\n        }\n        else\n        {\n            F.build(n * 2 + h + C[i], i, 1);\n        }\n        if (D[i] == 0)\n        {\n            F.build(i + n, F.e, 1);\n            F.build(i + n, n * 2 + h + B[i], 1);\n        }\n        else\n        {\n            F.build(i + n, n * 2 + D[i], 1);\n        }\n    }\n    int now = F.solve();\n    if (F.ans == -n) puts(\"YES\"); else puts(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<functional>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way,vel &con) {\n\tint n = way.size();\n\tvel dist(n,-1);\n\tdist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front();\n\t\tq.pop();\n\t\tcon.push_back(st);\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nint gr(int now, vvel &chi) {\n\tint ret = 0;\n\tfor(auto to:chi[now]) {\n\t\tret = ret xor (gr(to, chi) + 1);\n\t}\n\treturn ret;\n}\nsigned main() {\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define MP make_pair\n#define MT make_tuple\n#define EACH(i,c) for(auto i: c)\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, H;\n\tcin >> N >> H;\n\n\tmap<int, int> lA, lC, rB, rD, lArD, rBlC;\n\tint x = 0, y = 0;\n\tREP(i, N){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif(c == 0){\n\t\t\tlA[a]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\tlC[c]++;\n\t\t\ty++;\n\t\t}\n\t\tif(d == 0){\n\t\t\trB[b]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\trD[d]++;\n\t\t\ty++;\n\t\t}\n\n\t\tif(c == 0 && a == d) lArD[a]++;\n\t\tif(d == 0 && b == c) rBlC[b]++;\n\t}\n\n\tif(y + 2 > x){\n\t\tcerr << x << \" \" << y << endl;\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\n\tEACH(pc, lC){\n\t\tif(rB[pc.first] < pc.second){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEACH(pd, rD){\n\t\tif(lA[pd.first] < pd.second){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"YES\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<ctime>\n#include<vector>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<memory.h>\n#include<map>\n#include<ctime>\n#include<algorithm>\n#include<ctime>\n#define ll int\n#define For(i,j,k)  for(ll i=j;i<=k;++i)\n#define FOr(i,j,k)  for(ll i=j;i>=k;--i)\n#define ld double\nusing namespace std;\ninline ll read(){   ll x=0,f=1;char ch=getchar();   while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}  while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}  return x*f; }\ninline void wrote(ll x){    if (x<0) putchar('-'),x=-x; if (x>=10) wrote(x/10);   putchar(x%10+'0');  }\ninline void writeln(ll x){ wrote(x);   puts(\"\");   }\nconst ll N=1010;\nll n,h,ans,fa[N],C[N],D[N],vis[N];\nll find(ll x){\treturn x==fa[x]?x:fa[x]=find(fa[x]);\t}\nint main(){\n\tn=read();\tread();\n\tFor(i,1,1000)\tfa[i]=i;\n\tFor(i,1,n){\n\t\tll a=read(),b=read(),c=read(),d=read();\n\t\ta=c?-c:a;\tb=d?d:-b;\ta+=500;\tb+=500;\n\t\tfa[find(a)]=find(b);\n\t\tD[a]++;\tD[b]--;\tvis[a]=1;\n\t}\n\tbool fl=1;\n\tFor(i,1,499)\tfl&=D[i]<=0;\n\tFor(i,501,1000)\tfl&=D[i]>=0;\n\tFor(i,1,1000)\tvis[find(i)]|=vis[i];\n\tFor(i,1,1000)\tif (D[i])\tC[find(i)]=1;\n\tFor(i,1,1000)\tfl&=(fa[i]!=i)||C[i]||!vis[i];\n\tputs(fl?\"YES\":\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\n\nconst int MAXN = (200 + 10) * 2;\n\nclass no_solution : public std::exception\n{\npublic:\n\tconst char * what(void) const noexcept\n\t{\n\t\treturn \"no solution reachable\";\n\t}\n};\n\nnamespace disjointSet\n{\nint fa[MAXN];\n\nvoid init()\n{\n\tmemset(fa, 0x00, sizeof fa);\n}\n\nint find(int x)\n{\n\tif(fa[x])\n\t\treturn fa[x] = find(fa[x]);\n\treturn x;\n}\n\nvoid merge(int x, int y)\n{\n\tx = find(x), y = find(y);\n\tif(x != y)\n\t\tfa[x] = y;\n}\n\n}\n\nbool loop[MAXN];\nint inDeg[MAXN], outDeg[MAXN];\nint N, H;\n\nvoid solve()\n{\n\tfor(int i = 0; i <= 2 * H; i++)\n\t{\n\t\tif(i > H)\n\t\t\tif(inDeg[i] > outDeg[i])\n\t\t\t\tthrow no_solution();\n\t\tif(i < H)\n\t\t\tif(outDeg[i] > inDeg[i])\n\t\t\t\tthrow no_solution();\n\n\t\tbool found = false, isLoop = loop[i];\n\n\t\tfor(int j = 0; j <= 2 * H; j++)\n\t\t\tif(found)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tif(disjointSet::find(i) == disjointSet::find(j))\n\t\t\t\t{\n\t\t\t\t\tif(i != j)\n\t\t\t\t\t\tisLoop = true;\n\t\t\t\t\tif(inDeg[j] != outDeg[j])\n\t\t\t\t\t\tfound = true;\n\t\t\t\t}\n\n\t\tif(!found && isLoop)\n\t\t\tthrow no_solution();\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(nullptr);\n\n\tcin >> N >> H ;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tint a, b, c, d, L, R;\n\t\tcin >> a >> b >> c >> d;\n\t\tL = c ? H - c : H + a;\n\t\tR = d ? H + d : H - b;\n\t\tdisjointSet::merge(L, R);\n\t\tinDeg[R]++, outDeg[L]++;\n\n\t\tif(L == R)\n\t\t\tloop[L] = true;\n\t}\n\n\n\ttry\n\t{\n\t\tsolve();\n\t\tcout << \"YES\" << endl;\n\t}\n\tcatch(std::exception & x)\n\t{\n\t\tcout << \"NO\" << endl ;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nconst int N = 4e2 + 100;\nint f[N];\nint ff(int x) {\n\treturn f[x] == x ? x : f[x] = ff(f[x]);\n}\nint n, h;\nint in[N], ou[N], ok[N];\n\nint main() {\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tf[i] = i;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d, l, r;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tl = c == 0 ? h + a : c;\n\t\tr = d == 0 ? d : h + b;\n\t\t++ou[l], ++in[r];\n\t\tif (ff(l) != ff(r))\n\t\t\tf[ff(l)] = ff(r);\n\t}\n\tfor (int i = 1; i <= h; ++i)\n\t\tif (ou[i] < in[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = h + 1; i <= h + h; ++i)\n\t\tif (in[i] < ou[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (in[i] != ou[i])\n\t\t\tok[ff(i)] = true;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (ff(i) == i && !ok[i] && in[i] + ou[i] != 0)\n\t\t\treturn puts(\"NO\"), 0;\n\treturn puts(\"YES\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100005\n#define For(i,x,y) for(int i=x;i<=y;i++)\n#define Rep(i,x,y) for(int i=x;i>=y;i--)\n#define mp make_pair\n#define pa pair<ll,int>\nusing namespace std;\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+ch-48;\n\treturn f?-x:x;\n}\nint n,h,in[405],ou[405],fa[405];\nbool flag[405];\ninline int find(int x){return (fa[x]==x)?x:fa[x]=find(fa[x]);}\nint main(){\n\tn=read();h=read();\n\tFor(i,1,h*2) fa[i]=i;\n\tFor(i,1,n){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint l=(c==0)?h+a:c;\n\t\tint r=(d==0)?b:h+d;\n\t\tin[r]++;ou[l]++;\n\t\tfa[find(l)]=find(r);\n\t}\n\tFor(i,1,h) if(ou[i]>in[i]){puts(\"NO\");return 0;}\n\tFor(i,h+1,h*2) if(ou[i]<in[i]){puts(\"NO\");return 0;}\n\tFor(i,1,h*2) if(in[i]!=ou[i]) flag[find(i)]=1;\n\tFor(i,1,h*2) if(find(i)==i&&!flag[i]&&in[i]+ou[i]!=0){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define maxn 100005\n#define N 200\nusing namespace std;\nint n,h,indeg[N*2+5],outdeg[N*2+5];\nbool vis[N*2+5];\nstruct node { int v; node *nxt; } edge[maxn],*head[N*2+5],*ncnt;\nvoid addedge(int u,int v)\n{\n\tncnt++;\n\tncnt->v=v,ncnt->nxt=head[u];\n\thead[u]=ncnt,indeg[v]++,outdeg[u]++;\n}\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(node *p=head[u];p;p=p->nxt)\n\t\tif(!vis[p->v]) dfs(p->v);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tncnt=&edge[0];\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tint a,b,c,d,l,r;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t//printf(\" * %d %d %d %d\\n\",a,b,c,d);\n\t\tl=c?(-c):a,r=d?d:(-b);\n\t\t//printf(\" - %d %d\\n\",l,r);\n\t\taddedge(l+N,r+N);\n\t}\n\tfor(int i=0;i<N;i++)\n\t\tif(indeg[i]<outdeg[i]) { printf(\"NO\\n\"); return 0; }\n\tfor(int i=N+1;i<=N*2;i++)\n\t\tif(indeg[i]>outdeg[i]) { printf(\"NO\\n\"); return 0; }\n\tfor(int i=0;i<=N*2;i++)\n\t\tif(outdeg[i]>indeg[i]&&!vis[i]) dfs(i);\n\tfor(int i=0;i<=N*2;i++)\n\t\tif((indeg[i]||outdeg[i])&&!vis[i]) { printf(\"NO\\n\"); return 0; }\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    int n,h;\n    cin >>n>>h;\n    vector<pair<int,int>> rb{},lb{},rt{},lt{};\n    for (int i=0;i<n;i++){\n        int a,b,c,d;\n        cin>>a>>b>>c>>d;\n        if(c==0){\n            lb.push_back({i,a});\n        }else{\n            lt.push_back({i,c});\n        }\n        if(d==0){\n            rb.push_back({i,b});\n        }else{\n            rt.push_back({i,d});\n        }\n    }\n    if(lt.size()==0&&rt.size()==0){\n        cout<<\"YES\"<<endl;\n        return 0;\n    }\n    sort(lb.begin(),lb.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(rb.begin(),rb.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(lt.begin(),lt.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(rt.begin(),rt.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n\n\n    if(rb.size()-lt.size()<=0 ||\n       lb.size()-rt.size()<=0 ||\n       rb.size()-lt.size()!=lb.size()-rt.size()) {\n        cout<<\"NO\"<<endl;\n        return 0;\n    }\n    bool is_all_unique=true;\n    vector<int> lb_remain{},rb_remain{};\n\n    int offset1=0;\n    for(int i=0;i<lt.size();i++){\n        while(lt.at(i).second!=rb.at(i+offset1).second){\n            if(offset1>=rb.size()-lt.size()){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            if((i+offset1==0 || rb.at(i+offset1-1).second==rb.at(i+offset1).second) ||\n               (i+offset1==rb.size()-1 || rb.at(i+offset1).second==rb.at(i+offset1+1).second)){\n                is_all_unique=false;\n            }\n            rb_remain.push_back(rb.at(i+offset1).first);\n            offset1++;\n        }\n    }\n    if(offset1!=rb.size()-lt.size()){\n        if(rb.at(rb.size()-2).second==rb.at(rb.size()-1).second){\n            is_all_unique=false;\n        }\n        rb_remain.push_back(rb.at(rb.size()-1).first);\n    }\n\n    int offset2=0;\n    for(int i=0;i<rt.size();i++){\n        while(rt.at(i).second!=lb.at(i+offset2).second){\n            if(offset2>=lb.size()-rt.size()){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            if((i+offset2==0 || lb.at(i+offset2-1).second==lb.at(i+offset2).second) ||\n               (i+offset2==lb.size()-1 || lb.at(i+offset2).second==lb.at(i+offset2+1).second)){\n                is_all_unique=false;\n            }\n            lb_remain.push_back(lb.at(i+offset2).first);\n            offset2++;\n        }\n    }\n    if(offset2!=lb.size()-rt.size()){\n        if(lb.at(lb.size()-2).second==lb.at(lb.size()-1).second){\n            is_all_unique=false;\n        }\n        lb_remain.push_back(lb.at(lb.size()-1).first);\n    }\n    if(is_all_unique){\n        sort(lb_remain.begin(),lb_remain.end());\n        sort(rb_remain.begin(),rb_remain.end());\n        for(int i=0;i<lb_remain.size();i++){\n            if(lb_remain.at(i)!=rb_remain.at(i)){\n                cout<<\"YES\"<<endl;\n                return 0;\n            }\n        }\n        cout<<\"NOO\"<<endl;\n        return 0;\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string.h>\nusing namespace std;\nstruct node\n{\n    int a, b, c, d;\n};\nvector<int> v[2][200];\nnode nd[100010];\nbool rcd[100010];\nint count = 1;\nint N, H;\n\nbool dfs(int f, int h)\n{\n    for (int i = 0; i < v[f][h].size(); i++)\n    {\n        if (rcd[v[f][h][i]] == 1)\n            continue;\n        else\n            rcd[v[f][h][i]] == 1;\n        if (++count == N)\n            return 1;\n        node nt = nd[v[f][h][i]];\n        int f1, h1;\n        if (nt.d == 0)\n        {\n            f1 = 1;\n            h1 = nt.b;\n        }\n        else\n        {\n            f1 = 0;\n            h1 = nt.d;\n        }\n        if (dfs(f1, h1))\n            return 1;\n        else\n            rcd[v[f][h][i]] = 0;\n    }\n}\n\nint main()\n{\n    cin >> N >> H;\n    for (int i = 0; i < N; i++)\n    {\n        int A, B, C, D;\n        cin >> A >> B >> C >> D;\n        nd[i].a = A;\n        nd[i].b = B;\n        nd[i].c = C;\n        nd[i].d = D;\n        if (nd[i].c == 0)\n        {\n            v[0][nd[i].a].push_back(i);\n        }\n        else\n            v[1][nd[i].c].push_back(i);\n    }\n    for (int i = 0; i < N; i++)\n    {\n        memset(rcd, 0, sizeof(rcd));\n        if (nd[i].c == 0)\n        {\n            rcd[i] = 1;\n            if (dfs(nd[i].d == 0 ? 1 : 0, nd[i].d == 0 ? nd[i].b : nd[i].d))\n            {\n                cout << \"YES\";\n                return 0;\n            }\n        }\n        count = 1;\n    }\n    cout << \"NO\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint fa[MAXN],ind[MAXN],oud[MAXN],v1[MAXN],v2[MAXN];\nint n,h;\nbool flag[MAXN];\nint get_fa(int x){\n\tif(fa[x]==0)\n\t\treturn x;\n\tfa[x]=get_fa(fa[x]);\n\treturn fa[x];\t\n}\nint main(){\n\tSF(\"%d%d\",&n,&h);\n\tint x,y,a,b;\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d%d%d%d\",&x,&y,&a,&b);\n\t\tint u,v;\n\t\tif(a==0)\n\t\t\tu=x+200;\n\t\telse\n\t\t\tu=a;\n\t\tif(b==0)\n\t\t\tv=y;\n\t\telse\n\t\t\tv=b+200;\n\t\tflag[u]=flag[v]=1;\n\t\toud[u]++;\n\t\tind[v]++;\n\t\tif(get_fa(u)!=get_fa(v))\n\t\t\tfa[get_fa(u)]=get_fa(v);\n\t}\n\tfor(int i=1;i<=400;i++){\n\t\tif(ind[i]>oud[i]){\n\t\t\tv1[get_fa(i)]++;\n\t\t\tif(i>200){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(ind[i]<oud[i]){\n\t\t\tv2[get_fa(i)]++;\n\t\t\tif(i<=200){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=400;i++)\n\t\tif(fa[i]==0)\n\t\t\tif(v1[i]==0&&v2[i]==0&&flag[i]){\n\t\t\t\tPF(\"NO\");\t\n\t\t\t\treturn 0;\n\t\t\t}\n\tPF(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nint n,h;\nint l[220],r[220],fa[420],siz[420],L,R;\nint find(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=400;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0)l[a]++,L=a;\n\t\telse r[c]--,L=c;\n\t\tif(d==0)r[b]++,R=b;\n\t\telse l[d]--,R=d;\n\t\tif(find(L)==find(R)){\n\t\t\tsiz[find(L)]++;\n\t\t\tcontinue;\n\t\t}\n\t\tsiz[find(R)]+=siz[find(L)]+1;\n\t\tsiz[find(L)]=0;\n\t\tfa[find(L)]=find(R);\n\t}\n\tint ans=0,cns=0;\n\tfor(int i=1;i<=200;i++){\n\t\tif(l[i]<0||r[i]<0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(l[i]||r[i])ans+=siz[find(i)],siz[find(i)]=0;\n\t}\n\tif(ans!=n)printf(\"NO\\n\");\n\telse printf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\nstruct UnionFind {vector<int> par, cnt;\n    UnionFind(int NV) { par.clear(); cnt.resize(NV, 1); rep(i, 0, NV) par.push_back(i); }\n    void reset() { rep(i, 0, cnt.size()) cnt[i] = 1; rep(i, 0, par.size()) par[i] = i; }\n    int operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n    void operator()(int x, int y) {x = operator[](x); y = operator[](y);\n        if (x != y) par[x] = y, cnt[y] += cnt[x];}};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n \n \n\n\n#define NO \"NO\"\n#define YES \"YES\"\nint N, H;\nvector<int> E[500];\nint in[505], ou[505];\nint used[505], ok[505];\n//---------------------------------------------------------------------------------------------------\nstring solve() {\n    cin >> N >> H;\n    UnionFind uf(505);\n    rep(i, 0, N) {\n        int a, b, c, d; cin >> a >> b >> c >> d;\n\n        int L;\n        if (0 < c) L = -c;\n        else L = a;\n\n        int R;\n        if (0 < d) R = d;\n        else R = -b;\n\n        L += 250, R += 250;\n\n        E[L].push_back(R);\n\n        ou[L]++;\n        in[R]++;\n\n        used[L] = used[R] = 1;\n        uf(L, R);\n\n        //printf(\"[%d -> %d]\\n\", L - 250, R - 250);\n    }\n\n    rep(i, 0, 505) {\n        int x = i - 250;\n\n        if (0 < x) {\n            if (ou[i] < in[i]) return NO;\n            else if (ou[i] > in[i]) uf(500, i);\n        }\n\n        if (x < 0) {\n            if (in[i] < ou[i]) return NO;\n            else if (in[i] > ou[i]) uf(500, i);\n        }\n    }\n\n    rep(i, 0, 505) if (used[i]) {\n        if (uf[i] != uf[500]) return NO;\n    }\n\n    return YES;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing std::vector;\n\n#define MAXN 100005\n#define MAXH 405\nint indeg[MAXH],outdeg[MAXH];\nbool vis[MAXH];\nvector<int> G[MAXH];\n\nvoid add_edge(int u,int v)\n{\n    outdeg[u]++;indeg[v]++;\n    G[u].push_back(v);G[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    bool f=indeg[v]!=outdeg[v];\n    vis[v]=true;\n    for(auto to:G[v])\n    {\n        if(!vis[to]) \n            f|=dfs(to);\n    }\n    return f;\n}\n\nint main()\n{\n    int N,H;\n    int a[MAXN],b[MAXN],c[MAXN],d[MAXN];\n    scanf(\"%d%d\",&N,&H);\n    for(int i=1;i<=N;i++) \n    {\n        scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n        int l,r;\n        l= ( c[i]==0 ? a[i] : -c[i] );\n        r= ( d[i]==0 ? -b[i] : d[i] );\n        add_edge(l+H,r+H);\n    }\n\n    bool flag=true;\n    for(int i=0;flag && i<=H;i++) \n    {\n        if(outdeg[i]>indeg[i]) \n            flag=false;\n    }\n    for(int i=H+1;flag && i<=2*H;i++)\n    {\n        if(indeg[i]>outdeg[i]) \n             flag=false;\n    }\n\n    memset(vis,false,sizeof(vis));\n    for(int i=0;flag && i<=2*H;i++)\n    {\n        if((indeg[i]||outdeg[i])&&!vis[i]) \n            flag &=dfs(i);\n    }\n\n    if(flag) \n    {\n        printf(\"YES\\n\"); \n    }\n    else\n    { \n        printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 405\nusing namespace std;\nint n,h,in[maxn],out[maxn],f[maxn];\nbool ok[maxn];\nint find(int x){return !f[x]?x:f[x]=find(f[x]);}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1,A,B,C,D;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tint x=C?C+h:A, y=D?D:B+h;\n\t\tout[x]++,in[y]++;\n\t\tif((x=find(x))!=(y=find(y))) f[x]=y;\n\t}\n\tfor(int i=1;i<=h;i++) if(in[i]>out[i]) return puts(\"NO\"),0;\n\tfor(int i=h+1;i<=h<<1;i++) if(out[i]>in[i]) return puts(\"NO\"),0;\n\tfor(int i=1;i<=h<<1;i++) if(in[i]!=out[i]||!(in[i]+out[i])) ok[find(i)]=1;\n\tfor(int i=1;i<=h<<1;i++) if(!f[i]&&!ok[i]) return puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint th = 0;\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, c[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st != e[401]||st>=e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\n\nconst int maxn = 410000;\n\nint n,m=800;\n\nint fa[maxn];\nint findfa(const int x){return fa[x]==x?x:fa[x]=findfa(fa[x]);}\n\nint d[maxn],v[maxn],ok[maxn];\n\nint main()\n{\n    scanf(\"%d%*d\",&n);\n    for(int i=1;i<m;i++) fa[i]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int a,b,c,D,l,r; scanf(\"%d%d%d%d\",&a,&b,&c,&D);\n        l=!c?a:-c;\n        r=!D?-b:D;\n        l+=400,r+=400;\n        d[l]++,d[r]--; v[l]=v[r]=1;\n        fa[findfa(l)]=findfa(r);\n    }\n    for(int i=1;i<=400;i++) if(d[i]>0) return puts(\"NO\"),0;\n    for(int i=400;i<m;i++)  if(d[i]<0) return puts(\"NO\"),0;\n\n    for(int i=1;i<m;i++) if(d[i]) ok[findfa(i)]=1;\n\n    for(int i=1;i<m;i++) if(i==findfa(i)&&v[i]&&!ok[i]) \n        return puts(\"NO\"),0;\n    puts(\"YES\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=500;\nint f[N],t[N],p[N],du[N];\nint get(int x)\n{\n\tif (f[x]==x) return x;\n\treturn f[x]=get(f[x]);\n}\nint main()\n{\n\tint n,h;\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=1;i<=400;i++) f[i]=i;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint l=200,r=200;\n\t\tif (c) l=l-c;else l=l+a;\n\t\tif (d) r=r+d;else r=r-b;\n\t\tdu[l]++;\n\t\tdu[r]--;\n\t\tt[l]=t[r]=1;\n\t\tf[get(l)]=get(r);\n\t}\n\tfor (int i=1;i<=200;i++) if (du[i]>0) \n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tfor (int i=201;i<=400;i++) if (du[i]<0)\n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=400;i++) \n\t{\n\t\tif (du[i]) p[i]=1;\n\t\tt[get(i)]=t[get(i)]|t[i];\n\t}\n\tfor (int i=1;i<=400;i++) if (i==get(i)&&t[i]&&!p[i]) \n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t puts(\"YES\");\n\t return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=1000005;\nint n,h,i,j,k,l,ans,A,B,C,D,g[405][405],u[N],p[N],ind[N],outd[N];\nbool vis[N],ok[N];\nint find(int x)\n{\n\treturn p[x]==-1?x:p[x]=find(p[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tif(C)\n\t\t\tA=C+h;\n\t\tif(D)\n\t\t\tB=D+h;\n\t\tg[A][B<h?B+h:B-h]++;\n\t\tvis[A]=vis[B<h?B+h:B-h]=true;\n\t}\n\tfor(i=1;i<=2*h;++i)\n\t\tfor(j=1;j<=2*h;++j)\n\t\t\tind[j]+=g[i][j],outd[i]+=g[i][j];\n\tfor(i=1;i<=h;++i)\n\t\tif(outd[i]<ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=h+1;i<=2*h;++i)\n\t\tif(outd[i]>ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=1;i<=2*h;++i)\n\t\tp[i]=-1;\n\tfor(i=1;i<=2*h;++i)\n\t\tfor(j=1;j<=2*h;++j)\n\t\t\tif(g[i][j]&&find(i)!=find(j))\n\t\t\t\tp[find(i)]=find(j);\n\tfor(i=1;i<=2*h;++i)\n\t\tif(outd[i]!=ind[i])\n\t\t\tok[find(i)]=true;\n\tfor(i=1;i<=2*h;++i)\n\t\tif(find(i)==i&&!ok[i]&&vis[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n//#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\nconst int MAX_V = 420;\nconst int Base = MAX_V / 2;\n\nvector<int> es[MAX_V];\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n\n\n    SCC(int v) : V(v){assert(v < MAX_V);dump(v);dump(MAX_V);};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n\n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n\n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n    bool check(int v, int W) {\n    \treturn cmp[W] == cmp[v];\n    }\n};\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\tvi a(n), b(n), c(n), d(n);\n\trep(i, n) cin >> a[i] >> b[i] >> c[i] >> d[i];\n\tvi l(n), r(n);\n\trep(i, n) {\n\t\tl[i] = (c[i] == 0 ? a[i] : -c[i]);\n\t\tr[i] = (d[i] == 0 ? b[i] : -d[i]);\n\t}\n\tset<int> st;\n\trep(i, n) {\n\t\tint frm = (l[i] > 0 ? l[i] : Base - l[i]);\n\t\tint to = (r[i] > 0 ? Base + r[i] : -r[i]);\n\t\tst.insert(frm);\n\t\tst.insert(to);\n\t\tif(frm == to) continue;\n\t\tes[frm].pb(to);\n\t}\n\tint W = MAX_V-1;\n\tst.insert(W);\n\tvector<int> in(MAX_V), out(MAX_V);\n\tSCC g(MAX_V);\n\trep(i, MAX_V) {\n\t\tsort(all(es[i]));\n\t\t//es[i].erase(unique(all(es[i])), es[i].end());\n\t\tint prv = -1;\n\t\tfor(auto& to : es[i]) {\n\t\t\tif(prv != to) g.add_edge(i, to);\n\t\t\tprv = to;\n\t\t\tin[to]++;\n\t\t}\n\t\tout[i] = es[i].size();\n\t}\n\trep(i, MAX_V) {\n\t\tif(i >= Base) {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] < out[i]) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLINE;dump(i);dump(in[i]);dump(out[i]);dump(es[i][0]);\n\t\t\t\tg.add_edge(i, W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] > out[i]) {\n\t\t\t\tLINE;\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLINE;dump(i);dump(in[i]);dump(out[i]);dump(es[i][0]);\n\t\t\t\tg.add_edge(W, i);\n\t\t\t}\n\t\t}\n\t}\n\tg.add_edge(W-1, W);\n\tg.scc();\n\tfor(auto& v : st) {\n\t\tif(!g.check(v, W)) {\n\t\t\tLINE;\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i, x, y) for (decay<decltype(y)>::type i = (x), _##i = (y); i < _##i; ++i)\n#define FORD(i, x, y) for (decay<decltype(x)>::type i = (x), _##i = (y); i > _##i; --i)\n#ifdef zerol\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\n// -----------------------------------------------------------------------------\n\nconst int N = 500;\nconst int H = 220;\nint in[N], out[N], fa[N];\n\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nvoid merge(int x, int y) {\n    int fx = find(x), fy = find(y);\n    if (fx != fy) { fa[fx] = fy; }\n}\nvoid add_edge(int u, int v) {\n    dbg(u, v);\n    out[u]++; in[v]++;\n    merge(u, v);\n}\n\nbool check() {\n    int rt = -1;\n    FOR (i, 0, N) {\n        if (in[i] || out[i]) {\n            if (rt == -1) rt = find(i);\n            if (find(i) != rt) return false;\n        }\n    }\n    int p = 0, q = 0;\n    FOR (i, 0, N) {\n        if (in[i] || out[i]) dbg(i, in[i], out[i]);\n        if (i < H && out[i] > in[i]) p++;\n        else if (i >= H && in[i] > out[i]) q++;\n        else if (in[i] != out[i]) return false;\n    }\n    return p == q && p > 0;\n}\n\nint main() {\n    iota(fa, fa + N, 0);\n    int n, h; cin >> n >> h;\n    while (n--) {\n        int a, b, c, d; cin >> a >> b >> c >> d;\n        int u, v;\n        dbg(a, b, c, d);\n        if (c == 0) u = a;\n        else u = c + H;\n        if (d == 0) v = b + H;\n        else v = d;\n        add_edge(u, v);\n    }\n    puts(check() ? \"YES\" : \"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 444;\nint uf[maxn], has[maxn];\nint in[maxn], out[maxn];\nint find(int x){\n\tif(x == uf[x]) return x;\n\treturn uf[x] = find(uf[x]);\n}\nint main(){\n\tiota(uf, uf + maxn, 0);\n\tint n, h; cin >> n >> h;\n\tfor(int i = 0; i < n; i++){\n\t\tint a, b, c, d; cin >> a >> b >> c >> d;\n\t\tint x = (c == 0) ? (a + 200) : c;\n\t\tint y = (d == 0) ? b : (d + 200);\n\t\tout[x]++;\n\t\tin[y]++;\n\t\tuf[find(x)] = find(y);\t\t\n\t}\n\tfor(int i = 1; i <= h; i++){\n\t\tif(out[i] > in[i]) return !printf(\"NO\\n\");\n\t\tif(in[i] > out[i]) has[find(i)] = 1;\n\t}\n\tfor(int i = 200 + 1; i <= 200 + h; i++){\n\t\tif(in[i] > out[i]) return !printf(\"NO\\n\");\n\t\tif(in[i] < out[i]) has[find(i)] = 1;\n\t}\n\tfor(int i = 1; i <= h; i++){\n\t\tif((in[i] || out[i]) && !has[find(i)]) return !printf(\"NO\\n\");\n\t\tif((in[200+i] || out[200+i]) && !has[find(200+i)]) return !printf(\"NO\\n\");\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 400\n#define S 0\n#define T 401\n#define SS 402\n#define TT 403\n#define INF 2000000000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,H,head[MN+5],cnt=1,q[MN+5],d[MN+5],top,c[MN+5],in[MN+5],out[MN+5],ans,tot;\nstruct edge{int to,next,w;}e[5000005];\ninline void ins(int f,int t,int w)\n{\n//\tcout<<\"ins\"<<f<<\" \"<<t<<\" \"<<w<<endl;\n\te[++cnt]=(edge){t,head[f],w};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t],0};head[t]=cnt; \n}\nbool bfs(int fr,int to)\n{\n\tmemset(d,0,sizeof(d));int i,j;\n\tfor(d[q[top=i=1]=fr]=1;i<=top;++i)\n\t\tfor(int j=c[q[i]]=head[q[i]];j;j=e[j].next)\n\t\t\tif(!d[e[j].to]&&e[j].w) d[q[++top]=e[j].to]=d[q[i]]+1;\n\treturn d[to];\n}\nint dfs(int x,int f,int to)\n{\n\tif(x==to) return f;int used=0;\n\tfor(int&i=c[x];i;i=e[i].next)\n\t\tif(e[i].w&&d[e[i].to]==d[x]+1)\n\t\t{\n\t\t\tint w=dfs(e[i].to,min(e[i].w,f-used),to);\n\t\t\tused+=w;e[i].w-=w;e[i^1].w+=w;\n\t\t\tif(used==f) return f;\t\n\t\t}\n\treturn used;\n}\nint main()\n{\n\tn=read();H=read();\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint f=c?c+H:a,t=d?d:b+H;\n\t\t++in[t];++out[f];\n\t}\n\tfor(int i=1;i<=H;++i) ins(S,i,INF),ins(i+H,T,INF);\n\tins(T,S,INF);\n\tfor(int i=1;i<2*H;++i) \n\t\tif(in[i]>out[i]) ins(SS,i,in[i]-out[i]),tot+=in[i]-out[i];\n\t\telse if(out[i]>in[i]) ins(i,TT,out[i]-in[i]);\n\twhile(bfs(SS,TT)) ans+=dfs(SS,INF,TT);\n\tif(ans^tot) puts(\"NO\");\n\thead[T]=e[head[T]].next;head[S]=e[head[S]].next;\n\twhile(bfs(S,T)) ans+=dfs(S,INF,T);\n\tputs(ans?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nconst int N=1005,M=2e5+5;\nconst int Z=205;\nusing namespace std;\nint n,h;\nint rudu[N],chudu[N];\nbool vis[N];\nstruct node{\n    int u,v,nxt;\n}edge[M];\nint head[N],mcnt;\nvoid add_edge(int u,int v){\n\tmcnt++;\n\tedge[mcnt].u=u;\n    edge[mcnt].v=v;\n    edge[mcnt].nxt=head[u];\n    head[u]=mcnt;\n    rudu[v]++;\n    chudu[u]++;\n}\nvoid dfs(int u){\n\tvis[u]=true;\n\tfor(int i=head[u];i;i=edge[i].nxt){\n        int v=edge[i].v;\n\t\tif(!vis[v])\n            dfs(v);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d,l,r;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tl=c?(-c):a;\n\t\tr=d?d:(-b);\n\t\tadd_edge(l+Z,r+Z);\n\t}\n\tfor(int i=Z-h;i<Z;i++)\n\t\tif(rudu[i]<chudu[i]){\n            puts(\"NO\");\n            return 0;\n        }\n\tfor(int i=Z+1;i<=Z+h;i++)\n\t\tif(rudu[i]>chudu[i]){\n            puts(\"NO\");\n            return 0;\n        }\n\tfor(int i=Z-h;i<=Z+h;i++)\n\t\tif(chudu[i]>rudu[i]&&!vis[i])\n            dfs(i);\n\tfor(int i=Z-h;i<=Z+h;i++)\n\t\tif((rudu[i]||chudu[i])&&!vis[i]){\n            puts(\"NO\");\n            return 0;\n        }\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nvoid bye() { std::cout << \"NO\" << std::endl; exit(0); }\nint ind[410], oud[410], fa[410], idx;\nint p[210][2], hav[410];\nint n, H;\nint find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\nint newnode() { ++idx; fa[idx] = idx; return idx; }\nint get(int x, int b) { return p[x][b] ? p[x][b] : p[x][b] = newnode(); }\nvoid adde(int b, int e) { ++ind[e], ++oud[b]; fa[find(b)] = find(e); }\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> H;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d;\n\t\tstd::cin >> a >> b >> c >> d;\n\t\tadde(c ? get(c, 1) : get(a, 0), d ? get(d, 0) : get(b, 1));\n\t}\n\tfor (int i = 1; i <= H; ++i) {\n\t\tif (int t = p[i][0]) {\n\t\t\tif (ind[t] > oud[t]) bye(); hav[find(t)] |= ind[t] != oud[t];\n\t\t}\n\t\tif (int t = p[i][1]) {\n\t\t\tif (ind[t] < oud[t]) bye(); hav[find(t)] |= ind[t] != oud[t];\n\t\t}\n\t}\n\tfor (int i = 1; i <= idx; ++i) if (fa[i] == i && !hav[i]) bye();\n\tstd::cout << \"YES\" << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> emp[2][205],bmp[2][205];\nbool vis[100005];\nint a[100005],c[100005],d[100005],b[100005];\nint n,h;\n\nbool fillb(int i)\n{\n    vis[i] = true;\n    if(c[i]==0)\n    {\n        for(int j=0;j<bmp[1][a[i]].size();++j){\n            if(vis[bmp[1][a[i]][j]]) continue;\n            if(fillb(bmp[1][a[i]][j])) return true;\n        }\n        return true;\n    }else{\n        for(int j=0;j<bmp[0][c[i]].size();++j)\n        {\n            if(vis[bmp[0][c[i]][j]]||!fillb(bmp[0][c[i]][j])) continue;\n            return true;\n        }\n        vis[i]=false;\n        return false;\n    }\n}\n\nbool fille(int i)\n{\n    vis[i] = true;\n    if(d[i]==0)\n    {\n        for(int j=0;j<emp[1][b[i]].size();++j)\n        {\n\n            if(vis[emp[1][b[i]][j]]) continue;\n            if(fille(emp[1][b[i]][j])) return true;\n        }\n        return true;\n    }else\n    {\n        for(int j=0;j<emp[0][d[i]].size();++j)\n        {\n            if(vis[emp[0][d[i]][j]]||!fille(emp[0][d[i]][j]))continue;\n            return true;\n        }\n        vis[i] = false;\n        return false;\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        if(c[i]==0)\n        {\n            emp[0][a[i]].push_back(i);\n        }else emp[1][c[i]].push_back(i);\n        if(d[i]==0) bmp[0][b[i]].push_back(i);\n        else bmp[1][d[i]].push_back(i);\n    }\n    bool ag = true;\n    for(int i=0;i<n;++i)\n    {\n        if(vis[i]||(c[i]==0&&d[i]==0)) continue;\n        if((!fillb(i))||(!fille(i)))\n        {\n            ag= false;break;\n        }\n        if(!vis[i]){ag=false;break;}\n    }\n    if(ag) printf(\"YES\");\n    else printf(\"NO\");\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int maxn = 410;\n\nint n, m;\nint in[maxn], out[maxn], par[maxn];\nbool f[maxn];\n\nint F(int u) {\n\treturn par[u] == u ? u : par[u] = F(par[u]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &m, &n);\n\tfor (int i = 1; i <= n + n; ++i) {\n\t\tpar[i] = i;\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint a, b, c, d, x, y;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tx = c == 0 ? a : c + n;\n\t\ty = d == 0 ? b + n : d;\n\t\tpar[F(x)] = F(y);\n\t\t++in[y];\n\t\t++out[x];\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(out[i] < in[i]) {\n\t\t\treturn !puts(\"NO\");\n\t\t}\n\t\tif(in[i] < out[i]) {\n\t\t\tf[F(i)] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(out[n + i] > in[n + i]) {\n\t\t\treturn !puts(\"NO\");\n\t\t}\n\t}\n\tfor (int i = 1; i <= n + n; ++i) {\n\t\tif(F(i) == i && in[i] + out[i] && !f[i]) {\n\t\t\treturn !puts(\"NO\");\n\t\t}\n\t}\n\treturn !puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nvector<int>G[405];\nint in[405];\nint a[100005], b[100005], c[100005], d[100005];\nint vst[405];\nvoid dfs(int now) {\n\tfor(int e:G[now]) {\n\t\tif (vst[e])continue;\n\t\tvst[e] = 1;\n\t\tdfs(e);\n\t}\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\trep(i, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tint x, y;\n\t\tif (c[i] == 0)x = a[i];\n\t\telse x = c[i] + h;\n\t\tif (d[i] == 0)y = b[i] + h;\n\t\telse y = d[i];\n\t\tG[x].push_back(y);\n\t\tin[y]++;\n\t}\n\tint cnt = 0;\n\trep(i, h + 1) {\n\t\tif ((G[i].size() + in[i]) & 1) {\n\t\t\tcnt++;\n\t\t\tG[0].push_back(i);\n\t\t}\n\t}\n\tfor (int i = h + 1; i <= 2 * h; i++) {\n\t\tif ((G[i].size() + in[i]) & 1) {\n\t\t\tcnt--;\n\t\t\tG[i].push_back(0);\n\t\t}\n\t}\n\tif (cnt!=0) {\n\t\tputs(\"NO\");\n\t}\n\telse {\n\t\tvst[0] = 1;\n\t\tdfs(0);\n\t\trep(i, 2 * h + 1) {\n\t\t\tif (vst[i] == 0 && G[i].size()) {\n\t\t\t\tputs(\"NO\"); return 0;\n\t\t\t}\n\t\t}\n\t\tputs(\"YES\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH ;//<<\"reached line \"<<__LINE__<<endl\n#define DMP(x) ;//<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\n\nconst int Vmax=415;\nvi g[Vmax];\nint w[Vmax];\nbool vis[Vmax],appear[Vmax];\nvoid No(){\n\tcout<<\"NO\"<<endl;\n\texit(0);\n}\nvoid Yes(){\n\tcout<<\"YES\"<<endl;\n\texit(0);\n}\nvoid dfs(int v,vi&dst){\n\tif(vis[v])return;\n\tdst.PB(v);\n\tvis[v]=true;\n\tfor(auto to:g[v])dfs(to,dst);\n}\n\nsigned main(){\n\tint n=read(),h=read();\n\tREP(i,n){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint from,to;\n\t\tif(c==0)\n\t\t\tfrom=a-1;\n\t\telse\n\t\t\tfrom=c-1+h;\n\t\tif(d==0)\n\t\t\tto=b-1+h;\n\t\telse\n\t\t\tto=d-1;\n\t\t;//<<from<<\" -> \"<<to<<endl;\n\t\tg[from].PB(to);\n\t\tg[to].PB(from);\n\t\tw[from]++;\n\t\tw[to]--;\n\t\tappear[from]=1;\n\t\tappear[to]=1;\n\t}\n\tREP(i,Vmax)if(appear[i]&&!vis[i]){\n\t\tvi idx;\n\t\tdfs(i,idx);\n\t\tbool s=false,t=false;\n\t\t;//<<idx<<endl;\n\t\tfor(auto j:idx){\n\t\t\tif(w[j]>0){\n\t\t\t\ts=true;\n\t\t\t\tif(h<=j)No();\n\t\t\t}else if(w[j]<0){\n\t\t\t\tt=true;\n\t\t\t\tif(j<h)No();\n\t\t\t}\n\t\t}\n\t\tif(!s||!t)No();\n\t}\n\tYes();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=1000005;\nint n,h,i,j,k,l,ans,A,B,C,D,g[405][405],u[N],p[N],ind[N],outd[N];\nbool vis[N],ok[N];\nint find(int x)\n{\n\treturn p[x]==-1?x:p[x]=find(p[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tprintf(\"NO\");\n\treturn 0;\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tif(C)\n\t\t\tA=C+h;\n\t\tif(D)\n\t\t\tB=D+h;\n\t\tg[A][B<h?B+h:B-h]++;\n\t\tvis[A]=vis[B<h?B+h:B-h]=true;\n\t}\n\tfor(i=0;i<2*h;++i)\n\t\tfor(j=0;j<2*h;++j)\n\t\t\tind[j]+=g[i][j],outd[i]+=g[i][j];\n\tfor(i=0;i<h;++i)\n\t\tif(outd[i]<ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=h;i<2*h;++i)\n\t\tif(outd[i]>ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=0;i<2*h;++i)\n\t\tp[i]=-1;\n\tfor(i=0;i<2*h;++i)\n\t\tfor(j=0;j<2*h;++j)\n\t\t\tif(g[i][j]&&find(i)!=find(j))\n\t\t\t\tp[find(i)]=find(j);\n\tfor(i=0;i<2*h;++i)\n\t\tif(outd[i]!=ind[i])\n\t\t\tok[find(i)]=true;\n\tfor(i=0;i<2*h;++i)\n\t\tif(find(i)==i&&!ok[i]&&vis[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> emp[2][205],bmp[2][205];\nbool vis[100005];\nint a[100005],c[100005],d[100005],b[100005];\nint n,h;\n\nbool fillb(int i)\n{\n    vis[i] = true;\n    if(c[i]==0)\n    {\n        for(int j=0;j<bmp[1][a[i]].size();++j){\n            if(vis[bmp[1][a[i]][j]]) continue;\n            return fillb(bmp[1][a[i]][j]);\n        }\n        return true;\n    }else{\n        for(int j=0;j<bmp[0][c[i]].size();++j)\n        {\n            if(vis[bmp[0][c[i]][j]]) continue;\n            return fillb(bmp[0][c[i]][j]);\n        }\n        return false;\n    }\n}\n\nbool fille(int i)\n{\n    vis[i] = true;\n    if(d[i]==0)\n    {\n        for(int j=0;j<emp[1][b[i]].size();++j)\n        {\n\n            if(vis[emp[1][b[i]][j]]) continue;\n            return fille(emp[1][b[i]][j]);\n        }\n        return true;\n    }else\n    {\n        for(int j=0;j<emp[0][d[i]].size();++j)\n        {\n            if(vis[emp[0][d[i]][j]])continue;\n            return fille(emp[0][d[i]][j]);\n        }\n        return false;\n    }\n}\n\nint main()\n{\n    //freopen(\"C://Code//input.txt\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        if(c[i]==0)\n        {\n            emp[0][a[i]].push_back(i);\n        }else emp[1][c[i]].push_back(i);\n        if(d[i]==0) bmp[0][b[i]].push_back(i);\n        else bmp[1][d[i]].push_back(i);\n    }\n    bool ag = true;\n    for(int i=0;i<n;++i)\n    {\n        if(vis[i]||(c[i]==0&&d[i]==0)) continue;\n        if((!fillb(i))||(!fille(i)))\n        {\n            ag= false;break;\n        }\n    }\n    if(ag) printf(\"YES\");\n    else printf(\"NO\");\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n  //freopen(\"/home/alexandero/ClionProjects/ACM/output.txt\", \"w\", stdout);\n  //freopen(\"out.txt\", \"w\", stdout);\n#else\n  //freopen(\"input.txt\", \"r\", stdin);\n  //freopen(\"output.txt\", \"w\", stdout);\n#endif\n  start = clock();\n  int t = 1;\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n  precalc();\n  cout.precision(10);\n  cout << fixed;\n  //cin >> t;\n  int testNum = 1;\n  while (t--) {\n    //cout << \"Case #\" << testNum++ << \": \";\n    //cerr << testNum << endl;\n    solve(true);\n    //cerr << testNum - 1 << endl;\n  }\n  cout.flush();\n#ifdef AIM1\n  while (true) {\n      solve(false);\n  }\n#endif\n\n#ifdef AIM\n  cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\n//#define int li\n//const int mod = 1000000007;\n\nvoid solve(bool read) {\n  int n, H;\n  cin >> n >> H;\n  map<int, int> first_edges, second_edges;\n  set<int> first_bad, second_bad;\n  int with_zero = 0;\n  for (int i = 0; i < n; ++i) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if (d == 0) {\n      ++first_edges[b];\n      if (c == b) {\n        first_bad.insert(b);\n      }\n    } else {\n      ++second_edges[d];\n      if (c == 0 && a == d) {\n        second_bad.insert(d);\n      }\n    }\n    if (c == 0) {\n      --second_edges[a];\n      ++with_zero;\n    } else {\n      --first_edges[c];\n    }\n  }\n\n  //cout << \"bad: \" << bad_squares << endl;\n  int cnt = 0;\n  int sum = 0;\n  for (auto item : first_edges) {\n    sum += max(0, item.second);\n    int cur = -item.second;\n    if (first_bad.count(item.first)) {\n      ++cur;\n    }\n    cnt += max(0, cur);\n    //cout << \"first \" << item.first << \" \" << item.second << endl;\n  }\n  for (auto item : second_edges) {\n    int cur = item.second;\n    if (second_bad.count(item.first)) {\n      ++cur;\n    }\n    cnt += max(0, cur);\n    //cout << \"second \" << item.first << \" \" << item.second << endl;\n  }\n\n  if (sum > with_zero + 1) {\n    cout << \"NO\\n\";\n    return;\n  }\n\n  //cout << bad_squares << endl;\n\n  if (cnt <= 0) {\n    cout << \"YES\\n\";\n  } else {\n    cout << \"NO\\n\";\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 400+5;\nint n, h, in[N], out[N], fa[N], valid[N];\nint find(int x) { return fa[x] == x?x:fa[x] = find(fa[x]); }\nint main()\n{\n    n = read(), h = read();\n    for(int i = 1; i <= h<<1; ++i) fa[i] = i; \n    for(int i = 1; i <= n; ++i)\n    {\n        int a = read(), b = read(), c = read(), d = read();\n        int x = c?c+h:a, y = d?d:b+h;\n        ++out[x], ++in[y], x = find(x), y = find(y), fa[x] = y;\n    }\n    for(int i = 1; i <= h; ++i) if(in[i] > out[i]) return puts(\"NO\"), 0;\n    for(int i = h+1; i <= h<<1; ++i) if(in[i] < out[i]) return puts(\"NO\"), 0;\n    for(int i = 1; i <= h<<1; ++i) if(in[i] != out[i]||!in[i]) valid[find(i)] = 1;\n    for(int i = 1; i <= h<<1; ++i) if(find(i) == i&&!valid[i]) return puts(\"NO\"), 0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int> g[505];\nint l_cnt[505], r_cnt[505];\nbool used[505];\n\nint print(bool ok) {\n        if (ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n}\n\nbool dfs(int v) {\n        if (g[v].empty()) return true;\n        used[v] = true;\n        if (l_cnt[v] != r_cnt[v]) return true; //端\n        bool enough = false;\n        for (auto u : g[v]) if (!used[u]) enough |= dfs(u); //パーツが足りる？\n        return enough;\n}\n\nint main() {\n        int n, h, a, b, c, d;\n        cin >> n >> h;\n        for (int i = 0; i < n; i ++) {\n                cin >> a >> b >> c >> d;\n                int lh = (c == 0 ? a : c + 250);\n                int rh = (d == 0 ? b + 250 : d);\n                l_cnt[lh] ++;\n                r_cnt[rh] ++;\n                g[lh].push_back(rh);\n                g[rh].push_back(lh);\n//cerr << lh << ' ' << rh << endl;\n        }\n        for (int i = 0; i < h + 1; i ++) if (r_cnt[i] > l_cnt[i]) return print(0);\n        for (int i = 251; i < h + 251; i ++) if (l_cnt[i] > r_cnt[i]) return print(0);\n        for (int i = 0; i < 501; i ++) if (!used[i]) if (!dfs(i)) return print(0);\n        return print(1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <queue>\n#include <limits>\n#include <deque>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#define mp make_pair\n#define fs first\n#define se second\n#define memset(a,t) memset(a,t,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define MN 0LL\n#define Mx 200000005\n#define Mn -Mx\n#define MX 20000000000000005\nusing namespace std;\nint readint(){\n\tchar c;\n\twhile(c=getchar(),(c<'0'||c>'9')&&c!='-');\n\tbool flag=(c=='-');\n\tif(flag)c=getchar();\n\tint x=0;\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn flag?-x:x;\n}\ninline string tos(int x){\n\tstring s;\n\twhile(x) s=(char)(x%10+'0')+s,x/=10;\n\treturn s;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint r;\n\tsrand(time(NULL));\n\tr=rand()%2;\n\tif(r==1) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define y1 __zzd001\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=100005;\nint n,H,c1=0,c2=0;\nvector <int> aL[N],aR[N],bL[N],bR[N];\nchar s[5][5];\nnamespace Brute{\n\tint a[N],b[N],c[N],d[N],id[N];\n\tbool check(){\n\t\tfor (int i=1;i<n;i++){\n\t\t\tint x=id[i],y=id[i+1];\n\t\t\tif (d[x]){\n\t\t\t\tif (a[y]!=d[x])\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b[x]!=c[y])\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\tvoid brute(){\n\t\tn=read(),H=read();\n\t\tfor (int i=1;i<=n;i++)\n\t\t\ta[i]=read(),b[i]=read(),c[i]=read(),d[i]=read();\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tid[i]=i;\n\t\tdo {\n\t\t\tif (check()){\n\t\t\t\tfor (int i=1;i<=n;i++)\n\t\t\t\t\tprintf(\"%d \",id[i]);\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t} while (next_permutation(id+1,id+n+1));\n\t\tputs(\"brute - end\");\n\t}\n}\nint main(){\n//Brute :: brute();\n\tn=read(),H=read();\n\tfor (int i=1;i<=n;i++){\t\n\t\tint a=read(),b=read(),c=read(),d=read();\n//\t\tfor (int i=1;i<=4;i++)\n//\t\t\tfor (int j=1;j<=3;j++)\n//\t\t\t\ts[i][j]=j==2?'#':' ';\n//\t\tfor (int i=1;i<=a;i++)\n//\t\t\ts[i+c][1]='#';\n//\t\tfor (int i=1;i<=b;i++)\n//\t\t\ts[i+d][3]='#';\n//\t\tfor (int i=4;i>=1;i--,puts(\"\"))\n//\t\t\tfor (int j=1;j<=3;j++)\n//\t\t\t\tputchar(s[i][j]);\n\t\tif (!c)\n\t\t\taR[a].push_back(i);\n\t\telse\n\t\t\tbR[c].push_back(i);\n\t\tif (!d)\n\t\t\tbL[b].push_back(i);\n\t\telse\n\t\t\taL[d].push_back(i);\n\t}\n\tfor (int i=1;i<=200;i++){\n\t\tint s1=aL[i].size();\n\t\tint s2=aR[i].size();\n\t\tif (s1>s2||s1<s2-1)\n\t\t\treturn puts(\"NO\"),0;\n\t\tif (s1==s2-1)\n\t\t\tc1++;\n\t\telse {\n\t\t\tif (!s1)\n\t\t\t\tcontinue;\n\t\t\tint f=1;\n\t\t\tfor (int j=0;f&&j<s1;j++)\n\t\t\t\tif (aL[i][j]!=aR[i][j])\n\t\t\t\t\tf=0;\n\t\t\tif (f)\n\t\t\t\treturn puts(\"NO\"),0;\n\t\t}\n\t}\n\tfor (int i=1;i<=200;i++){\n\t\tint s1=bR[i].size();\n\t\tint s2=bL[i].size();\n\t\tif (s1>s2||s1<s2-1)\n\t\t\treturn puts(\"NO\"),0;\n\t\tif (s1==s2-1)\n\t\t\tc2++;\n\t\telse {\n\t\t\tif (!s1)\n\t\t\t\tcontinue;\n\t\t\tint f=1;\n\t\t\tfor (int j=0;f&&j<s1;j++)\n\t\t\t\tif (bL[i][j]!=bR[i][j])\n\t\t\t\t\tf=0;\n\t\t\tif (f)\n\t\t\t\treturn puts(\"NO\"),0;\n\t\t}\n\t}\n\tif (c1!=c2)\n\t\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\nint F() {\n\tregister int a, b, c;\n\twhile(c=getchar(), c<'-');\n\tb=(c=='-');\n\tfor(a=b?0:c-'0'; c=getchar(),c>'-'; a=a*10+c-'0');\n\treturn b?-a:a;\n}\nconst int N=2e5+10;\nint fa[N];\nint find(register int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}\nint deg[N];\nbool mark[N], appear[N];\nbool work() {\n\tregister int n=F(), h=F(), i, a, b, c, d, cnt=0, ans=0;\n\tfor(i=1; i<=2*h; ++i) fa[i]=i, deg[i]=0, appear[i]=mark[i]=0;\n\tfor(i=1; i<=n; ++i) {\n\t\ta=F(), b=F(), c=F(), d=F();\n\t\t++deg[c=c?c:a+h];\n\t\t--deg[d=d?d+h:b];\n\t\tfa[find(c)]=find(d);\n\t\tappear[c]=appear[d]=1;\n\t}\n\tfor(i=1; i<=2*h; ++i) if(appear[i]) {\n\t\tif(i<=h&&deg[i]>0 || i>h&&deg[i]<0) return 0;\n\t\tmark[i] = deg[i]!=0;\n\t}\n\tfor(i=1; i<=2*h; ++i) mark[find(i)]|=mark[i];\n\tfor(i=1; i<=2*h; ++i) if(appear[i] && find(i)==i && !mark[i]) return 0;\n\treturn 1;\n}\nint main() {\n\tregister int t=F();\n\twhile(t--) puts(work()?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\nint c[201][2];\nint e[201][2];\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\tc[b[i].c][0]++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].a][0]++;\n\t\t}\n\t\tif (b[i].d > 0) {\n\t\t\tc[b[i].d][1]++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].b][1]++;\n\t\t}\n\t}\n\trep(i, 201) {\n\t\trep(j, 2) {\n\t\t\tif (c[i][j] > e[i][j^1]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <queue>\n#include <limits>\n#include <deque>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#define mp make_pair\n#define fs first\n#define se second\n#define memset(a,t) memset(a,t,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define MN 0LL\n#define Mx 200000005\n#define Mn -Mx\n#define MX 20000000000000005\nusing namespace std;\nint readint(){\n\tchar c;\n\twhile(c=getchar(),(c<'0'||c>'9')&&c!='-');\n\tbool flag=(c=='-');\n\tif(flag)c=getchar();\n\tint x=0;\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn flag?-x:x;\n}\ninline string tos(int x){\n\tstring s;\n\twhile(x) s=(char)(x%10+'0')+s,x/=10;\n\treturn s;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint r;\n\tsrand(time(NULL));\n\tr=rand()%2;\n\tif(r==1) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 100003;\nstatic const int MAXH = 209;\n\nstatic const int MAXV = MAXH * 2;\nstatic const int MAXE = 1e6 + 10;\n\nint n, h;\nint head[MAXV], dest[MAXE], next[MAXE];\nbool vis[MAXE] = { false };\n\nint m = 0;\nint in[MAXV] = { 0 }, out[MAXV] = { 0 };\n\ninline void add_edge(int u, int v)\n{\n    dest[m] = v; next[m] = head[u]; head[u] = m++;\n    ++out[u], ++in[v];\n}\n\nint cur[MAXV];\n\nvoid dfs(int u)\n{\n    for (int &w = cur[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs(dest[w]);\n    }\n}\n\nstd::vector<int> as, bs;\nbool marked[MAXV] = { false };\n\nint main()\n{\n    scanf(\"%d%d\", &n, &h);\n\n    int verts = (h + 1) * 2;\n    for (int i = 0; i < verts; ++i) head[i] = -1;\n\n#define node_a(_h) ((_h) * 2)\n#define node_b(_h) ((_h) * 2 + 1)\n    for (int i = 0, a, b, c, d; i < n; ++i) {\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        int u, v;\n        u = (c == 0 ? node_b(a) : node_a(c));\n        v = (d == 0 ? node_a(b) : node_b(d));\n        add_edge(u, v);\n    }\n    for (int i = 0; i <= h; ++i) {\n        if (in[node_a(i)] < out[node_a(i)]) { puts(\"NO\"); return 0; }\n        if (in[node_b(i)] > out[node_b(i)]) { puts(\"NO\"); return 0; }\n        for (int r = 0; r < in[node_a(i)] - out[node_a(i)]; ++r) {\n            as.push_back(node_a(i));\n            marked[node_a(i)] = true;\n        }\n        for (int r = 0; r < out[node_b(i)] - in[node_b(i)]; ++r) {\n            bs.push_back(node_b(i));\n            marked[node_b(i)] = true;\n        }\n    }\n    for (int u : as) {\n        if (bs.empty()) { puts(\"NO\"); return 0; }\n        add_edge(u, bs.back());\n        bs.pop_back();\n    }\n\n    for (int i = 0; i < verts; ++i) cur[i] = head[i];\n    for (int i = 1; i < verts; i += 2) if (marked[i]) dfs(i);\n    for (int i = 0; i < m; ++i) if (!vis[i]) { puts(\"NO\"); return 0; }\n    puts(\"YES\"); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i, x, y) for (decay<decltype(y)>::type i = (x), _##i = (y); i < _##i; ++i)\n#define FORD(i, x, y) for (decay<decltype(x)>::type i = (x), _##i = (y); i > _##i; --i)\n#ifdef zerol\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\n// -----------------------------------------------------------------------------\n\nconst int N = 500, H = 220, INF = 1E9;\nint in[N], out[N];\n\nstruct E {\n    int to, cp;\n    E(int to, int cp): to(to), cp(cp) {}\n};\n\nstruct Dinic {\n    static const int M = 1E5 * 5;\n    int m, s, t;\n    vector<E> edges;\n    vector<int> G[M];\n    int d[M];\n    int cur[M];\n\n    void init(int n, int s, int t) {\n        this->s = s; this->t = t;\n        for (int i = 0; i <= n; i++) G[i].clear();\n        edges.clear(); m = 0;\n    }\n\n    void addedge(int u, int v, int cap) {\n        edges.emplace_back(v, cap);\n        edges.emplace_back(u, 0);\n        G[u].push_back(m++);\n        G[v].push_back(m++);\n    }\n\n    bool BFS() {\n        memset(d, 0, sizeof d);\n        queue<int> Q;\n        Q.push(s); d[s] = 1;\n        while (!Q.empty()) {\n            int x = Q.front(); Q.pop();\n            for (int& i: G[x]) {\n                E &e = edges[i];\n                if (!d[e.to] && e.cp > 0) {\n                    d[e.to] = d[x] + 1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return d[t];\n    }\n\n    int DFS(int u, int cp) {\n        if (u == t || !cp) return cp;\n        int tmp = cp, f;\n        for (int& i = cur[u]; i < G[u].size(); i++) {\n            E& e = edges[G[u][i]];\n            if (d[u] + 1 == d[e.to]) {\n                f = DFS(e.to, min(cp, e.cp));\n                e.cp -= f;\n                edges[G[u][i] ^ 1].cp += f;\n                cp -= f;\n                if (!cp) break;\n            }\n        }\n        return tmp - cp;\n    }\n\n    int go() {\n        int flow = 0;\n        while (BFS()) {\n            memset(cur, 0, sizeof cur);\n            flow += DFS(s, INF);\n        }\n        return flow;\n    }\n} DC;\n\nvoid add_edge(int u, int v) {\n    dbg(u, v);\n    out[u]++; in[v]++;\n    DC.addedge(u, v, 1);\n}\n\nint fa[N];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nvoid merge(int x, int y) {\n    int fx = find(x), fy = find(y);\n    if (fx != fy) fa[fx] = fy;\n}\n\nconst int S = N - 2, T = N - 1;\nbool check() {\n    int goal = 0;\n    FOR (i, 0, N) {\n        if (i < H && out[i] > in[i]) {\n            goal += out[i] - in[i];\n            DC.addedge(S, i, out[i] - in[i]);\n        }\n        else if (i >= H && in[i] > out[i]) DC.addedge(i, T, in[i] - out[i]);\n        else if (in[i] != out[i]) return false;\n    }\n    if (DC.go() != goal) return false;\n\n    iota(fa, fa + N, 0);\n    FOR (u, 0, N) {\n        for (int id: DC.G[u]) {\n            if (id % 2) continue;\n            int v = DC.edges[id].to;\n            merge(u, v);\n        }\n    }\n    FOR (i, 0, N)\n        if ((in[i] || out[i]) && find(i) != find(S))\n            return false;\n    return true;\n}\n\nint main() {\n    DC.init(N, S, T);\n    int n, h; cin >> n >> h;\n    while (n--) {\n        int a, b, c, d; cin >> a >> b >> c >> d;\n        int u, v;\n        dbg(a, b, c, d);\n        if (c == 0) u = a;\n        else u = c + H;\n        if (d == 0) v = b + H;\n        else v = d;\n        add_edge(u, v);\n    }\n    puts(check() ? \"YES\" : \"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define MAX_H 200\nint deg_in[MAX_H * 2 + 1];\nint deg_out[MAX_H * 2 + 1];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n, h;\n    cin >> n >> h;\n    int a, b, c, d;\n    int i;\n    for(i = 0; i < n; ++i){\n        cin >> a >> b >> c >> d;\n        int x = c == 0 ? a : -c;\n        int y = d == 0 ? -b : d;\n        ++deg_out[x + h];\n        ++deg_in[y + h];\n    }\n    int sum_deg_out = 0;\n    int sum_deg_in = 0;\n    for(i = h + 1; i <= 2 * h; ++i){\n        sum_deg_out += deg_out[i] - deg_in[i];\n    }\n    for(i = 0; i < h; ++i){\n        sum_deg_in += deg_in[i] - deg_out[i];\n    }\n    if(sum_deg_out > 0 && sum_deg_out == sum_deg_in){\n        cout << \"YES\";\n    }\n    else{\n        cout << \"NO\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define M 505\n#define base 200\ninline int read(){\n\tint x = 0,f = 1;char ch = getchar();\n\twhile(ch < '0' || ch > '9'){if(ch == '-')f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9'){x = x*10+ch-'0'; ch = getchar();}\n\treturn x*f;\n}\n\nint n,h;\nint f[M],size[M],in[M],out[M];\nbool vis[M];\n\nint find(int x){\n\tif(x == f[x])\n\t\treturn x;\n\treturn f[x] = find(f[x]);\n}\n\ninline void Union(int x,int y){\n\tint fx = find(x),fy = find(y);\n\tif(fx == fy){\n\t\tsize[fx]++;\n\t\treturn;\n\t}\n\tf[fx] = fy; size[fy] += size[fx]+1;\n}\n\nint main(){\n\tn = read(); h = read();\n\tfor(int i = 1;i <= h;i++){\n\t\tf[i+base] = i+base;\n\t\tsize[i+base] = 1;\n\t}\n\tfor(int i = -h;i <= -1;i++){\n\t\tf[i+base] = i+base;\n\t\tsize[i+base] = 1;\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tint a = read(),b = read(),c = read(),d = read();\n\t\tint x,y;\n\t\tif(c == 0) x = a;\n\t\telse x = -c;\n\t\tif(d == 0) y = -b;\n\t\telse y = d;\n\t\tout[x+base]++; in[y+base]++;\n\t\tUnion(x+base,y+base);\n\t}\n\tfor(int i = 1;i <= h;i++)\n\t\tif(out[i+base] < in[i+base]){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(int i = -h;i <= -1;i++)\n\t\tif(in[i+base] < out[i+base]){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(int i = 1;i <= h;i++)\n\t\tvis[find(i+base)] |= (in[i+base] != out[i+base]);\n\tfor(int i = -h;i <= -1;i++)\n\t\tvis[find(i+base)] |= (in[i+base] != out[i+base]);\n\tfor(int i = 1;i <= h;i++)\n\t\tif(size[find(i+base)] > 1)\n\t\t\tif(find(i+base) == i+base)\n\t\t\t\tif(vis[i+base] == false){\n\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tfor(int i = -h;i <= -1;i++)\n\t\tif(size[find(i+base)] > 1)\n\t\t\tif(find(i+base) == i+base)\n\t\t\t\tif(vis[i+base] == false){\n\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Jigsaw\n// * frank_c1\n// * 2017 / 11/ 07\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = (int)(1e5) + 5;\nint ai[maxn], bi[maxn], ci[maxn], di[maxn];\nint in[maxn], ou[maxn];\n\nint main() {\n\tint n, H;\n\tscanf(\"%d%d\", &n, &H);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d%d%d%d\", &ai[i], &bi[i], &ci[i], &di[i]);\n\t\tint u = 0, v = 0;\n\t\tif (!ci[i]) u = ai[i]; else u = ci[i] + H;\n\t\tif (!di[i]) v = bi[i] + H; else v = di[i];\n\t\t++ou[u]; ++in[v]; \n\t} int cnt = 0, e = 0;\n\tfor (int i = 1; i <= H; ++i) if (in[i] > ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] < ou[i]) cnt += ou[i] - in[i], e = 1;\n\tfor (int i = H + 1; i <= H + H; ++i) if (in[i] < ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] > ou[i]) cnt -= in[i] - ou[i];\n\treturn ((cnt || !e) ? printf(\"NO\\n\") : printf(\"YES\\n\")), 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n#include<bits/stdc++.h>\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nint n,h,in[405],out[405],f[405];\nbool vis[405];\nint find(int x)\n{\n\treturn f[x]==x?x:f[x]=find(f[x]);\n}\nint main()\n{\n\tre(n),re(h);\n\tfor(int i=1;i<=h*2;++i)f[i]=i;\n\tfor(int i=1,a,b,c,d;i<=n;++i)\n\t{\n\t\tre(a),re(b),re(c),re(d);\n\t\tint l=0,r=0;\n\t\tif(c)l=c;else l=h+a;\n\t\tif(d)r=h+d;else r=b;\n\t\tif(find(l)!=find(r))f[f[l]]=f[r];\n\t\t++out[l];++in[r];\n\t}\n\tfor(int i=1;i<=h;++i)if(out[i]>in[i])return puts(\"NO\"),0;\n\tfor(int i=h+1;i<=h+h;++i)if(out[i]<in[i])return puts(\"NO\"),0;\n\tfor(int i=1;i<=h+h;++i)if(in[i]!=out[i])vis[find(i)]=1;\n\tfor(int i=1;i<=h+h;++i)if(in[i]&&out[i]&&!vis[find(i)])return puts(\"NO\"),0;\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nint N, H, f[401], g[401], w[401];\nstd::vector < int > V[401];\nint F(int x)\n{\n\treturn f[x] == x ? x : f[x] = F(f[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\", &N, &H);\n\tfor (int i = 1; i <= H + H; i++)\n\t\tf[i] = i;\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint u = c ? H + c : a, v = d ? d : H + b;\n\t\tg[u]++, g[v]--;\n\t\tw[u]++, w[v]++;\n\t\tu = F(u), v = F(v);\n\t\tif (u != v)\n\t\t\tf[u] = v;\n\t}\n\tfor (int i = 1; i <= H; i++)\n\t\tif (g[i] < 0 || g[H + i] > 0)\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i = 1; i <= H + H; i++)\n\t\tV[F(i)].push_back(i);\n\tfor (int i = 1; i <= H + H; i++)\n\t\tif (F(i) == i && !std::all_of(V[i].begin(), V[i].end(), [] (int x) { return w[x] == 0; }) && std::all_of(V[i].begin(), V[i].end(), [] (int x) { return g[x] == 0; }))\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\nconst int N = 4e5 + 10, H = 505;\nint n, h, deg[N];\nbool ff, tag, vis[N], mark[N];\nvector<int> nxt[N];\n\nvoid add(int x, int y) {\n    x += H, y += H;\n    mark[x] = mark[y] = 1;\n    nxt[x].push_back(y);\n    ++deg[y], --deg[x];\n}\n\nvoid dfs(int x) {\n    if ((x >= H && deg[x] > 0) || (x < H && deg[x] < 0)) {\n        ff = 1; return;\n    }\n    if (deg[x]) tag = 1;\n    vis[x] = 1;\n    for (int i = 0; i < nxt[x].size(); i++) {\n        int y = nxt[x][i];\n        if (!vis[y]) dfs(y);\n    }\n}\n\nint main() {\n    cin >> n >> h;\n    rep(i, 1, n) {\n        int a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        add(c ? -c : a, d ? d : -b);\n    }\n    rep(i, 1, H << 1) if (mark[i] && !vis[i]) {\n        ff = tag = 0;\n        dfs(i);\n        if (ff || !tag) return puts(\"NO\"), 0;\n    }\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <queue>\n#include <limits>\n#include <deque>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#define mp make_pair\n#define fs first\n#define se second\n#define memset(a,t) memset(a,t,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define MN 0LL\n#define Mx 200000005\n#define Mn -Mx\n#define MX 20000000000000005\nusing namespace std;\nint readint(){\n\tchar c;\n\twhile(c=getchar(),(c<'0'||c>'9')&&c!='-');\n\tbool flag=(c=='-');\n\tif(flag)c=getchar();\n\tint x=0;\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn flag?-x:x;\n}\ninline string tos(int x){\n\tstring s;\n\twhile(x) s=(char)(x%10+'0')+s,x/=10;\n\treturn s;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint r;\n\tsrand(time(NULL));\n\tr=rand()%2;\n\tif(r==1) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\n#define A(a) ((a)<<1)\n#define B(a) ((a)<<1|1)\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nconst int MAXV = 200007;\nconst int MAXM = 2000007;\n\nstruct eT\n{\n\tvoid setd ( int _u, int _v, int _f, int _l )\n\t{\n\t\tu = _u, v = _v, f = _f, last = _l;\n\t}\n\n\tint u, v, f, last;\n}edge[MAXM];\n\nstruct bT\n{\n\tbT () {}\n\tbT ( int _h, int _l ) : h ( _h ), l ( _l ) {}\n\n\tvoid setd ( int _h, int _l )\n\t{\n\t\th = _h, l = _l;\n\t}\n\n\tbool operator < ( const bT &a ) const\n\t{\n\t\treturn ( h ^ a.h ) ? ( h < a.h ) : ( l < a.l );\n\t}\n\n\tint h, l;\n}bl[MAXN], br[MAXN];\n\nint n, h, S, T;\nint ke, la[MAXV];\n\nint q[MAXV], lev[MAXV];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nvoid addedge ( int u, int v, int fu, int fv );\n\nint dinic ();\nbool bfs ();\nint dfs ( int now, int lim );\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\n\tscanf ( \"%d%d\", &n, &h );\n\tint a, b, c, d;\n\tlpi ( i, 1, n ){\n\t\tscanf ( \"%d%d%d%d\", &a, &b, &c, &d );\n\t\tbl[i].setd ( c, a ), br[i].setd ( d, b );\n\t}\n}\n\nvoid work ()\n{\n\t// main work\n\n\tS = MAXV - 1, T = MAXV - 2;\n\tint SS = MAXV - 3, TT = MAXV - 4;\n\tke = 0;\n\tINIT ( la, -1 );\n\n\tmap < bT, PII > ml, mr;\n\tmap < bT, PII > ::iterator it;\n\n\tAR( int ) keye;\n\tint ks = 0;\n\n\tlpi ( i, 1, n ){\n\t\t++ml[bl[i]].first;\n\t\t++mr[br[i]].first;\n\t}\n\n\tint kl = 0, kr = 0;\n\tfor ( auto &x : ml ) x.second.second = ++kl;\n\tfor ( auto &x : mr ) x.second.second = ++kr;\n\n\n\tint cl = 0, cr = 0;\n\tfor ( auto x : ml ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, A( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( A( x.second.second ), TT, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = mr.find ( bT ( 0, x.first.h ) ) ) != mr.end () ){\n\t\t\t\taddedge ( B( it->second.second ), A( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n\t\t\tcl += x.second.first;\n\t\t\taddedge ( A( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n\tfor ( auto x : mr ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, B( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( B( x.second.second ), SS, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = ml.find ( bT ( 0, x.first.h ) ) ) != ml.end () ){\n\t\t\t\taddedge ( A ( it->second.second ), B( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n\t\t\tcr += x.second.second;\n\t\t\taddedge ( B( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n//\taddedge ( SS, T, INF, 0 );\n//\taddedge ( TT, T, INF, 0 );\n\n\tif ( ks >= n ){\n\t\tprintf ( \"NO\\n\" );\n\t\treturn;\n\t}\n\n\tdinic ();\n\n\tbool flag = true;\n\tfor ( auto x : keye ){\n\t\tif ( edge[x].f ){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf ( flag ? \"YES\\n\" : \"NO\\n\" );\n}\n\n\n\nvoid addedge ( int u, int v, int fu, int fv )\n{\n\tedge[ke].setd ( u, v, fu, la[u] );\n\tla[u] = ke++;\n\tedge[ke].setd ( v, u, fv, la[v] );\n\tla[v] = ke++;\n}\n\nint dinic ()\n{\n\tint ans = 0;\n\twhile ( bfs () ) ans += dfs ( S, INF );\n\treturn ans;\n}\n\nbool bfs ()\n{\n\tint l = 0, r = 0, now, v;\n\tq[r++] = S;\n\tINIT ( lev, -1 );\n\tlev[S] = 1;\n\twhile ( l < r ){\n\t\tnow = q[l++];\n\t\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\t\tif ( edge[i].f && lev[v=edge[i].v] == -1 ){\n\t\t\t\tlev[v] = lev[now] + 1;\n\t\t\t\tq[r++] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ( lev[T] != -1 );\n}\n\nint dfs ( int now, int lim )\n{\n\tif ( now == T ) return lim;\n\n\tint v, nf = 0, tf;\n\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\tif ( edge[i].f && lev[v=edge[i].v] == lev[now] + 1 ){\n\t\t\ttf = dfs ( v, qmin ( lim-nf, edge[i].f ) );\n\t\t\tnf += tf;\n\t\t\tedge[i].f -= tf, edge[i^1].f += tf;\n\n\t\t\tif ( nf == lim ) break;\n\t\t}\n\t}\n\n\tif ( !nf ) lev[now] = -1;\n\treturn nf;\n}"
  },
  {
    "language": "C++",
    "code": "//AtCoder Grand Contest 017 E - Jigsaw\n\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint qr(){int ret = 0,f=1;char ch =getchar();while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();return ret*f;}\n\n#define maxN 100005\n#define maxH 205\n\nint fir[maxN],nxt[maxN<<3],ver[maxN<<3],tot;\nint indegree[maxN<<2],outdegree[maxN<<2];\n\nvoid read(int x,int y){\n    indegree[y]++;\n    outdegree[x]++;\n    nxt[++tot] = fir[x];\n    fir[x] = tot;\n    ver[tot] = y;\n}\nint f[maxH<<1];\nvoid init(){\n    for(int i = 1;i<=(maxH<<1);i++)\n        f[i] = i;\n}\nint gf(int x){\n    if(f[x] == x) return x;\n    else return f[x] = gf(f[x]);\n}\nint mer(int x,int y){\n    x = gf(x);y = gf(y);\n    if(x == y) return 0;\n    f[x] = y;\n    return 1;\n}\nint main(){\n    int N = qr(),H = qr();\n    int N = N;\n    int t1,t2,t3,t4,t5,t6;//上 t + maxN 下 t + maxN + maxH\n    for(int i = 1;i<=N;i++){\n        t1 = qr(),t2 = qr(),t3 = qr(),t4 = qr();\n        /*\n        if(t3 == 0) read(t1 + maxN + maxH , i);\n        else read(t3 + maxN , i);\n        if(t4 == 0) read(i,t2+maxN);\n        else read(i,t4 + maxN + maxH);*/\n        if(!t3) t5 = t1;else t5 = t3+H;\n        if(!t4) t6 = t2+H;else t6 = t4;\n        read(t5,t6);\n        N -= mer(t5,t6);\n    }\n    if(N != 1){\n        cout << \"NO\";\n        return 0;\n    }\n    int in = 0,out = 0;\n    for(int i = 1;i<=(H<<1);i++){\n        if(indegree[i]!=outdegree[i]){\n            if(indegree[i]>outdegree[i])\n                in++;\n            else out++;\n            if(in == 2||out == 2){\n                cout <<\"NO\";\n                return 0;\n            }\n        }\n    }\n    cout << \"YES\";\n    /*\n    int a=0,b=0;\n    for(int i = maxN;i<=maxN + 500;i++){\n        if(indegree[i] == outdegree[i])\n            continue;\n        else {\n            if(abs(indegree[i]-outdegree[i])!=1) {cout << \"NO\";return 0;}\n            else {\n                //if(i<=maxN+maxH) {\n                    if(indegree[i] > outdegree[i])\n                        a++;\n                    else b++;\n                //}else{\n                //    if(indegree[i] > outdegree[i])\n                //        b++;\n                //    else a++;\n                //}\n            }\n            if(a == 2||b == 2){cout << \"NO\";return 0;}\n        }\n    }\n    if(a == b){cout << \"YES\";}\n    else {cout << \"NO\";}\n    */\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10 , H = 202 << 1;\nint fa[H] , out[N] , in[N] , n , h;\nvi g[H];\nint F(int x){return fa[x]==x?x:fa[x]=F(fa[x]);}\nint id(int x){\n    return x>0?x-1:n+(-x-1);\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&h);\n    rep(i,0,h+h) fa[i]=i;\n    rep(i,0,n) {\n        int a,b,c,d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        int l=c?-c:a,r=d?d:-b;\n        l=id(l),r=id(r);\n        fa[F(r)]=F(l);\n        out[l]++;\n        in[r]++;\n    }\n    rep(i,0,h+h) g[F(i)].pb(i);\n    rep(i,0,h) if(out[i]<in[i]) return puts(\"NO\") , 0;\n    rep(i,h,h+h) if(out[i]>in[i]) return puts(\"NO\") , 0;\n    rep(i,0,h+h) if(sz(g[i])) {\n        bool end = false , has = false;\n        for(auto e : g[i]) {\n            has |= in[e] | out[e];\n            if(e < n && out[e] > in[e]) end = true;\n            if(e >= n && out[e] < in[e]) end = true;\n        }\n        if(has && !end) return puts(\"NO\") , 0;\n    }\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int N=405;\n\ntypedef long long LL;\n\nint n,h,de[N],f[N];\n\nbool vis[N],bz[N];\n\nint Get(int x)\n{\n\treturn (f[x]==x)?x:f[x]=Get(f[x]);\n}\n\nint main()\n{\n\tfor (int i=0;i<N;i++) f[i]=i;\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=0,a,b,c,d,l,r;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tl=(c==0)?a:-c; r=(d==0)?-b:d;\n\t\tl+=h; r+=h; vis[l]=vis[r]=1;\n\t\tde[l]++; de[r]--;\n\t\ta=Get(l); b=Get(r);\n\t\tf[b]=a;\n\t}\n\tfor (int i=0;i<h;i++) if (de[i]>0)\n\t{\n\t\tprintf(\"NO\\n\"); return 0;\n\t}\n\tfor (int i=N-1;i>h;i--) if (de[i]<0)\n\t{\n\t\tprintf(\"NO\\n\"); return 0;\n\t}\n\tfor (int i=0;i<N;i++)\n\t{\n\t\tint j=Get(i); vis[j]|=vis[i]; bz[j]|=(de[i]!=0);\n\t}\n\tfor (int i=0;i<N;i++) if (Get(i)==i && vis[i] && !bz[i])\n\t{\n\t\tprintf(\"NO\\n\"); return 0;\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=1e5+5;\nint n,h,cl[N],cr[N];\nint main()\n{\n\tn=read(),h=read();\n\tfo(i,1,n)\n\t{\n\t\tint A=read(),B=read(),C=read(),D=read();\n\t\tif(C) --cl[C];else ++cl[A];\n\t\tif(D) --cr[D];else ++cr[B];\n\t}\n\tfo(i,1,h)\n\t\tif(cl[i]<0 || cr[i]<0)\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\n\nconst int MAXN = (200 + 10) * 2;\n\nclass no_solution : public std::exception\n{\npublic:\n\tconst char * what(void) const noexcept\n\t{\n\t\treturn \"no solution reachable\";\n\t}\n};\n\nnamespace disjointSet\n{\nint fa[MAXN];\n\nvoid init()\n{\n\tmemset(fa, 0x00, sizeof fa);\n}\n\nint find(int x)\n{\n\tif(fa[x])\n\t\treturn fa[x] = find(fa[x]);\n\treturn x;\n}\n\nvoid merge(int x, int y)\n{\n\tx = find(x), y = find(y);\n\tif(x != y)\n\t\tfa[x] = y;\n}\n\n}\n\nbool loop[MAXN];\nint inDeg[MAXN], outDeg[MAXN];\nint N, H;\n\nvoid solve()\n{\n\tfor(int i = 0; i <= 2 * H; i++)\n\t{\n\t\tif(i > H)\n\t\t\tif(inDeg[i] > outDeg[i])\n\t\t\t\tthrow no_solution();\n\t\tif(i < H)\n\t\t\tif(outDeg[i] > inDeg[i])\n\t\t\t\tthrow no_solution();\n\n\t\tbool found = false, isLoop = loop[i];\n\n\t\tfor(int j = 0; j <= 2 * H; j++)\n\t\t\tif(found)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tif(disjointSet::find(i) == disjointSet::find(j))\n\t\t\t\t{\n\t\t\t\t\tif(i != j)\n\t\t\t\t\t\tisLoop = true;\n\t\t\t\t\tif(inDeg[j] != outDeg[j])\n\t\t\t\t\t\tfound = true;\n\t\t\t\t}\n\n\t\tif(!found && isLoop)\n\t\t\tthrow no_solution();\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(nullptr);\n\n\tcin >> N >> H ;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tint a, b, c, d, L, R;\n\t\tcin >> a >> b >> c >> d;\n\t\tL = c ? H - c : H + a;\n\t\tR = d ? H + d : H - b;\n\t\tdisjointSet::merge(L, R);\n\t\tinDeg[R]++, outDeg[L]++;\n\n\t\tif(L == R)\n\t\t\tloop[L] = true;\n\t}\n\n\n\ttry\n\t{\n\t\tsolve();\n\t\tcout << \"YES\" << endl;\n\t}\n\tcatch(std::exception & x)\n\t{\n\t\tcout << \"NO\" << endl ;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXH = 400;\n\nint fa[MAXH + 5], ind[MAXH + 5], oud[MAXH + 5], N, H;\nint find(int x) {return fa[x] = ((fa[x] == x) ? x : find(fa[x]));}\nvoid unite(int u, int v) {\n\tint fu = find(u), fv = find(v);\n\tif( fu != fv ) fa[fu] = fv;\n}\nvoid adde(int u, int v) {ind[v + H]++, oud[u + H]++, unite(u + H, v + H);}\n\nint a[MAXH + 5], b[MAXH + 5];\nint main() {\n\tscanf(\"%d%d\", &N, &H);\n\tfor(int i=0;i<=2*H;i++) fa[i] = i;\n\tfor(int i=1,A,B,C,D;i<=N;i++) {\n\t\tscanf(\"%d%d%d%d\", &A, &B, &C, &D), D = -D;\n\t\tif( !C ) C = -A; if( !D ) D = B;\n\t\tadde(C, D);\n\t}\n//\tfor(int i=0;i<=2*H;i++) printf(\"%d %d\\n\", ind[i], oud[i]);\n\t\n\tint deg = 0;\n\tfor(int i=0;i<H;i++) {\n\t\tif( ind[i] > oud[i] ) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t} else a[find(i)] += (oud[i] - ind[i]), deg += (oud[i] - ind[i]);\n\t}\n\tfor(int i=H+1;i<=2*H;i++) {\n\t\tif( oud[i] > ind[i] ) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t} else b[find(i)] += (ind[i] - oud[i]), deg += (oud[i] - ind[i]);\n\t}\n\tif( deg ) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<=2*H;i++) {\n\t\tif( !ind[i] || !oud[i] ) continue;\n\t\tif( find(i) == i && (!a[i] || !b[i]) ) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define INF 1000000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct MaxFlow\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[SIZE];\n\tint level[SIZE];\n\tint iter[SIZE];\n\tint N;\n\t\n\tvoid init(int X)\n\t{\n\t\tN=X;\n\t}\n\tvoid add(int s,int t,int c)\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow_dfs(int v,int t,int f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tint d=flow_dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s,int t)\n\t{\n\t\tint flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tfor(int i=0;i<N;i++) iter[i]=0;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tint f=flow_dfs(s,t,INF);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\nMaxFlow MT;\nstruct UF\n{\n\tint par[SIZE],rank[SIZE];\n\t\n\tvoid init(int n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpar[i]=i;\n\t\t\trank[i]=1;\n\t\t}\n\t}\n\tint find(int x)\n\t{\n\t\tif(x==par[x]) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y)\n\t{\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y])\n\t\t{\n\t\t\tpar[x]=y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t}\n\t}\n\tbool same(int x,int y)\n\t{\n\t\treturn find(x)==find(y);\n\t}\n};\nUF uf;\nvector <int> vec[SIZE];\nint A[SIZE],B[SIZE],C[SIZE],D[SIZE];\nint out[SIZE],in[SIZE];\n\nint main()\n{\n\tint n,H;\n\tscanf(\"%d %d\",&n,&H);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&A[i],&B[i],&C[i],&D[i]);\n\t\tif(C[i]==0) C[i]=1;\n\t\telse\n\t\t{\n\t\t\tA[i]=C[i];\n\t\t\tC[i]=0;\n\t\t}\n\t\tif(D[i]==0) D[i]=0;\n\t\telse\n\t\t{\n\t\t\tB[i]=D[i];\n\t\t\tD[i]=1;\n\t\t}\n\t}\n\tvector <P> vx;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tvx.push_back(P(A[i],C[i]));\n\t\tvx.push_back(P(B[i],D[i]));\n\t}\n\tsort(vx.begin(),vx.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tuf.init(vx.size()+2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint L=lower_bound(vx.begin(),vx.end(),P(A[i],C[i]))-vx.begin();\n\t\tint R=lower_bound(vx.begin(),vx.end(),P(B[i],D[i]))-vx.begin();\n\t\tout[L]++,in[R]++;\n\t\tuf.unite(L,R);\n\t}\n\tfor(int i=0;i<vx.size();i++)\n\t{\n\t\tif(uf.find(i)==i)\n\t\t{\n\t\t\tvector <int> nd;\n\t\t\tfor(int j=0;j<vx.size();j++)\n\t\t\t{\n\t\t\t\tif(uf.same(i,j))\n\t\t\t\t{\n\t\t\t\t\tnd.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint a=0,b=0;\n\t\t\tfor(int j=0;j<nd.size();j++)\n\t\t\t{\n\t\t\t\tint v=nd[j];\n\t\t\t\tif(in[v]==out[v]) continue;\n\t\t\t\tif(in[v]<out[v])\n\t\t\t\t{\n\t\t\t\t\tif(vx[v].second==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\ta+=out[v]-in[v];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(vx[v].second==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tb+=in[v]-out[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a!=b||a==0)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tMT.init(vx.size()+5);\n\tint S=vx.size(),T=S+1;\n\tint cnt=0;\n\tfor(int i=0;i<vx.size();i++)\n\t{\n\t\tif(in[i]<out[i])\n\t\t{\n\t\t\tMT.add(S,i,out[i]-in[i]);\n\t\t\tcnt+=out[i]-in[i];\n\t\t}\n\t\telse if(out[i]<in[i])\n\t\t{\n\t\t\tMT.add(i,T,in[i]-out[i]);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint L=lower_bound(vx.begin(),vx.end(),P(A[i],C[i]))-vx.begin();\n\t\tint R=lower_bound(vx.begin(),vx.end(),P(B[i],D[i]))-vx.begin();\n\t\tMT.add(L,R,1);\n\t}\n\tbool up=MT.max_flow(S,T)==cnt;\n\tif(up) puts(\"YES\");\n\telse puts(\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=405;\n\nint n,h;\nint in[MAXN],out[MAXN],cnt[MAXN],fa[MAXN];\n\nint Find(int x){return fa[x]==0?x:fa[x]=Find(fa[x]);}\n\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;i++){\n        int a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint x=c==0?a:(c+200);\n\t\tint y=d==0?(b+200):d;\n\t\tin[y]++,out[x]++;\n\t\tx=Find(x),y=Find(y);\n\t\tif(x!=y) fa[x]=y;\n\t}\n\tbool f=1;\n\tfor(int i=1;i<=400;i++)\n\t\tif(in[i]!=out[i]){\n\t\t\tif((in[i]<out[i]&&i>200)||(in[i]>out[i]&&i<200)){\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint x=Find(i);\n\t\t\tcnt[x]++;\n\t\t}\n\tif(f){\n\t\tfor(int i=1;i<=400;i++)\n\t\t\tif((in[i]||out[i])&&cnt[Find(i)]==0){\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif(f) puts(\"YES\");\n\telse puts(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint beg[200100],nex[501000],tto[500100],e;\nint cnt1[200100],cnt2[200100];\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nbool vis[200100];\nvoid dfs(int u){\n\tif(vis[u]) return;\n\tvis[u]=1;\n\tfor(int i=beg[u];i;i=nex[i])\n\t\tdfs(tto[i]);\n}\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n\tint n,h;\n\tscanf(\"%d%d\",&n,&h);\n\tint A,B,C,D;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tif(C>0){\n\t\t\tputin(n+C,i);\n\t\t\tputin(i,n+C);\n\t\t\tcnt1[n+C]++;\n\t\t}\n\t\telse{\n\t\t\tputin(n+A,i);\n\t\t\tputin(i,n+A);\n\t\t\tcnt2[n+A]++;\n\t\t}\n\t\tif(D>0){\n\t\t\tputin(n+D+h,i);\n\t\t\tputin(i,n+D+h);\n\t\t\tcnt1[n+D+h]++;\n\t\t}\n\t\telse{\n\t\t\tputin(n+B+h,i);\n\t\t\tputin(i,n+B+h);\n\t\t\tcnt2[n+B+h]++;\n\t\t}\n\t}\n\tfor(int i=1;i<=h+h;i++){\n\t\tif(cnt1[n+i]>cnt2[n+i]){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<=h+h;i++)\n\t\tif(cnt2[n+i]>cnt1[n+i])\n\t\t\tdfs(n+i);\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"grader.h\"\n#include <bits/stdc++.h>  \n\nusing namespace std;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define re return\n#define fi first\n#define mp make_pair\n#define se second\n#define sz(a) (int)a.size()\n#define prev previ\n#define tm tmmm\n#define div divv\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\n\nconst ll mod = ll(1e9) + 9LL, pr = 239, mod2 = ll(1e9) + 7;\n\nll n, h, cnt[401], cnt1[401], cntk[401][401];\nvector<int> e[401], rev[401];\n\nll use[2][401];\n\nvoid dfs(int r, int nu) {\n\tif (use[r][nu]) re;\n\tuse[r][nu] = 1;\n\t//cout << \"khe \" << r << \" \" << nu - h << \"\\n\";\n\tif (r == 0)\n\t\tfor (int v : e[nu]) {\n\t\t\tdfs(1 ^ r, v);\n\t\t}\n\telse\n\t\tfor (int v : rev[nu]) {\n\t\t\tdfs(1 ^ r, v);\n\t\t}\n}\nint main() {\n\tiostream::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> h;\n\tint k1 = 0;\n\tbool ok1 = false, ok2 = false;\n\tint cc = 0;\n\tforn (i, n) {\n\t\tint a1, b, c, d;\n\t\tcin >> b >> d >> a1 >> c;\n\n\t\tif (a1)\n\t\t\tb = -a1;\n\t\tif (c)\n\t\t\td = -c;\n\t\tif (b > 0) ok1 = true;\n\t\tif (d > 0) ok2 = true;\n\t\tcnt[b + h]++;\n\t\tcnt1[d + h]++;\t\n\t\tcntk[b + h][d + h]++;\n\t\te[b + h].push_back(d + h);\n\t\tif (b < 0) {\n\t\t\tcc++;\n\t\t\te[b + h].push_back(-b + h);\n\t\t\trev[-b + h].push_back(b + h);\n\t\t}\n\t\tif (d < 0) {\n\t\t\tcc++;\n\t\t\trev[d + h].push_back(-d + h);\n\t\t\te[-d + h].push_back(d + h);\t\t\n\t\t}\n\t\trev[d + h].push_back(b + h);\n\t}\n\tif (cc >= n) {\n\t\tcout << \"NO\\n\";\n\t\tre 0;\n\t}\n\t//re 0;\n\tvector<int> b1, b2;\n\tforn (i, h) {\n\t\tif (cnt[i] > cnt1[2 * h - i] || cnt1[i] > cnt[2 * h - i] || (cnt[i] && cnt[i] == cntk[i][2 * h - i]) || (cnt1[i] && cnt1[i] == cntk[2 * h - i][i])) {\n\t\t\tcout << \"NO\\n\";\n\t\t\tre 0;\n\t\t}\n\t\tif (cnt[i] < cnt1[2 * h - i]) {\n\t\t\tb2.push_back(2 * h - i);\n\t\t}\n\t\tif (cnt1[i] < cnt[2 * h - i]) {\n\t\t\tb1.push_back(2 * h- i);\n\t\t}\n\t}\n\t// for (int v : b1) {\n\t// \tcout << v - h << \"\\n\";\n\t// }\n\n\t// cout << \"\\n\";\n\t// for(int v : b2) {\n\t// \tcout << v - h << \"\\n\";\n\t// }\n\tfor (int v : b1)\n\t\tfor (int u : b2) {\n\t\t\te[v].push_back(u);\n\t\t\trev[u].push_back(v);\n\t\t}\n\tint k = 0;\n\tforn (i, 401) {\n\t\tif (cnt[i] && use[0][i] == 0) {\n\t\t\t//cout << 0 << \" \" << i - h << \"\\n\";\n\t\t\tdfs(0, i);\n\t\t\tk++;\n\t\t}\n\t\tif (cnt1[i] && use[1][i] == 0) {\n\t\t\t//cout << 1 << \" \" << i - h << \"\\n\";\n\t\t\tdfs(1, i);\n\t\t\tk++;\n\n\t\t}\n\t}\n\tif (k > 1) {\n\t\tcout << \"NO\\n\";\n\t\tre 0;\n\t}\n\tcout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXH = 400;\n\nint fa[MAXH + 5], ind[MAXH + 5], oud[MAXH + 5], N, H;\nint find(int x) {return fa[x] = ((fa[x] == x) ? x : find(fa[x]));}\nvoid unite(int u, int v) {\n\tint fu = find(u), fv = find(v);\n\tif( fu != fv ) fa[fu] = fv;\n}\nvoid adde(int u, int v) {ind[v + H]++, oud[u + H]++, unite(u + H, v + H);}\n\nint a[MAXH + 5], b[MAXH + 5];\nint main() {\n\tscanf(\"%d%d\", &N, &H);\n\tfor(int i=0;i<=2*H;i++) fa[i] = i;\n\tfor(int i=1,A,B,C,D;i<=N;i++) {\n\t\tscanf(\"%d%d%d%d\", &A, &B, &C, &D), D = -D;\n\t\tif( !C ) C = -A; if( !D ) D = B;\n\t\tadde(C, D);\n\t}\n//\tfor(int i=0;i<=2*H;i++) printf(\"%d %d\\n\", ind[i], oud[i]);\n\t\n\tint deg = 0;\n\tfor(int i=0;i<H;i++) {\n\t\tif( ind[i] > oud[i] ) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t} else a[find(i)]++, deg += (oud[i] - ind[i]);\n\t}\n\tfor(int i=H+1;i<=2*H;i++) {\n\t\tif( oud[i] > ind[i] ) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t} else b[find(i)]++, deg += (oud[i] - ind[i]);\n\t}\n\tif( deg ) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<=2*H;i++) {\n\t\tif( !ind[i] || !oud[i] ) continue;\n\t\tif( find(i) == i && (!a[i] || !b[i]) ) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 500\nusing namespace std;\nint read(){\n    int nm=0,fh=1; int cw=getchar();\n    for(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n    for(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n    return nm*fh;\n}\nint n,m,e1,e2,h1,h2,cnt,in[M],ot[M],f[M]; bool vs[M];\nint fd(int x){return x==f[x]?x:f[x]=fd(f[x]);}\nint main(){\n    n=read(),m=read();\n    for(int i=1;i<=m;i++) f[i]=i,f[i+m]=i+m,vs[i]=vs[i+m]=false;\n    for(int i=1;i<=n;i++){\n        h1=read(),h2=read(),e1=read(),e2=read();\n        int t1=e1>0?e1:-h1,t2=e2>0?-e2:h2; t1+=m,t2+=m;\n        if(fd(t1)!=fd(t2)) f[fd(t1)]=fd(t2); in[t2]++,ot[t1]++;\n    }\n    for(int i=-m;i<0;i++) if(in[i+m]>ot[i+m]){puts(\"NO\");return 0;}\n    for(int i=1;i<=m;i++) if(in[i+m]<ot[i+m]){puts(\"NO\");return 0;}\n    for(int i=0;i<=m+m;i++) if(in[i]!=ot[i]) vs[fd(i)]=true;\n    for(int i=0;i<=m+m;i++) if(in[i]&&ot[i]&&!vs[fd(i)]){puts(\"NO\");return 0;}\n    puts(\"YES\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// contancer library\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\n\ntemplate <class K, class T>\nostream& operator<<(ostream& os, map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\n\nconst ll MOD = 1000000007;\n// const ll MOD = 998244353;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const ld PI = acos(-1);\n// const ld EPS = 1e-10;\n// mt19937 mt(ll(time(0)));\n\ntemplate <class T>\nvector<T> Vec(size_t l, T v) { return vector<T>(l, v); }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\ntemplate <typename T>\ninline T sq(T a) { return a * a; }\n\ntemplate <typename T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <typename T, typename U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\ntemplate <typename T, typename U>\nT mpow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret = ret * b % MOD;\n        n >>= 1;\n        b = b * b % MOD;\n    }\n    return ret;\n}\n\nclass UnionFind {\npublic:\n    int V_NUM;\n    vector<int> par, num;\n\n    explicit UnionFind(int N) : V_NUM(N) {\n        par.resize(N);\n        iota(par.begin(), par.end(), 0);\n        num.assign(N, 1);\n    }\n\n    int find(int x) {\n        return (par[x] == x) ? x : (par[x] = find(par[x]));\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return;\n\n        if (num[x] < num[y]) swap(x, y);\n        num[x] += num[y];\n        par[y] = x;\n    }\n\n    bool same(int x, int y) { return find(x) == find(y); }\n    bool ispar(int x) { return x == find(x); }\n    int size(int x) { return num[find(x)]; }\n};\n\nvoid fail() {\n    cout << \"NO\" << endl;\n    exit(0);\n}\n\nint main() {\n    int N, H;\n    cin >> N >> H;\n\n    vector<int> in(H * 2, 0), out(H * 2, 0);\n    UnionFind uf(H * 2);\n\n    for (int i = 0; i < N; ++i) {\n        int A, B, C, D;\n        cin >> A >> B >> C >> D;\n        --A, --B, --C, --D;\n\n        int from, to;\n        if (C < 0) {\n            from = A;\n        } else {\n            from = C + H;\n        }\n\n        if (D < 0) {\n            to = B + H;\n        } else {\n            to = D;\n        }\n\n        ++out[from];\n        ++in[to];\n        uf.unite(from, to);\n    }\n    cerr << in << endl;\n    cerr << out << endl;\n\n    map<int, int> deg;\n    for (int i = 0; i < H; ++i) {\n        if (in[i] == 0 && out[i] == 0) continue;\n\n        int d = out[i] - in[i];\n        if (d < 0) fail();\n        int x = uf.find(i);\n        if (!deg.count(x)) deg[x] = 0;\n        deg[x] += d;\n    }\n    cerr << deg << endl;\n\n    for (auto p : deg) {\n        if (p.second == 0) fail();\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n\nconst int N = 400 + 10;\n\nint n, deg[N];\n\nint anc[N], mask[N], cnt[N];\n\nint find(int x) { return anc[x] == x ? x : (anc[x] = find(anc[x])); }\n\nvoid meld(int x, int y) {\n  x = find(x), y = find(y);\n  ++cnt[y];\n  if (x == y) return;\n  anc[x] = y;\n  mask[y] |= mask[x];\n  cnt[y] += cnt[x];\n}\n\nvoid init() {\n  int m;\n  scanf(\"%d%d\", &m, &n);\n  std::iota(anc, anc + 2 * n + 1, 0);\n  for (int i = 1; i <= n; ++i) mask[i] = 1, mask[i + n] = 2;\n  while (m--) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    int x = c ? (c + n) : a, y = d ? d : (b + n);\n    --deg[x], ++deg[y];\n    meld(x, y);\n  }\n}\n\nint main() {\n  init();\n  for (int i = 1; i <= n; ++i) if (deg[i] > 0 || deg[i + n] < 0) return puts(\"NO\"), 0;\n  for (int i = 1; i <= n; ++i) if (find(i) == i && cnt[i] && mask[i] != 3) return puts(\"NO\"), 0;\n  puts(\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define S 200001\nint deg[200007], vis[200007], Fa[200007];\ninline int Find(register int o){//fprintf(stderr, \"%d\\n\", o);\n\treturn o == Fa[o] ? o : (Fa[o] = Find(Fa[o]));\n}\nint fastin(){\n\tregister int i; register char ch;\n\twhile (ch = getchar(), ch < '0' || ch > '9');\n\ti = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9') i = i * 10 + ch - '0';\n\treturn i;\n}\nint main(){\n\tregister int T, n, h, h2, i, a, b, c, d, u, v;\n\tT = 1;\n\twhile (T--) {\n\t\tn = fastin(), h = fastin();\n\t\tmemset(deg + 1, 0, sizeof(int) * (h << 1));\n\t\tmemset(vis + 1, 0, sizeof(int) * (h << 1));\n\t\th2 = h << 1;\n\t\tfor (i = 1; i <= h2; ++i) Fa[i] = i;\n\t\tFa[S] = S;\n\t\tfor (i = 1; i <= n; ++i) {\n\t\t\ta = fastin(), b = fastin(), c = fastin(), d = fastin();\n\t\t\tu = (d ? d + h : b);\n\t\t\tv = (c ? c : a + h);\n\t\t\t++deg[u], vis[u] = 1;\n\t\t\t--deg[v], vis[v] = 1;\n\t\t\tFa[Find(u)] = Find(v);\n\t\t}\n\t\t//for (i = 1; i <= h2; ++i) fprintf(stderr, \"%d %d\\n\", deg[i], vis[i]);\n\t\t//fprintf(stderr, \"GG\");\n\t\tfor (i = 1; i <= h; ++i) {\n\t\t\tif (vis[i]) {\n\t\t\t\tif (deg[i] < 0) break;\n\t\t\t\tif (deg[i] > 0) Fa[Find(i)] = S;\n\t\t\t}\n\t\t}\n\t\tif (i <= h) {\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\t//fprintf(stderr, \"HH\");\n\t\tfor (i = h + 1; i <= h2; ++i) {\n\t\t\tif (vis[i]) {\n\t\t\t\tif (deg[i] > 0) break;\n\t\t\t\tif (deg[i] < 0) Fa[Find(i)] = S;\n\t\t\t}\n\t\t}\n\t\tif (i <= h2) {\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\t//fprintf(stderr, \"II\");\n\t\tfor (i = 1; i <= h2; ++i) if (vis[i] && Find(i) != S) break;\n\t\t//fprintf(stderr, \"%d\\n\", i);\n\t\tif (i <= h2) puts(\"NO\");\n\t\telse puts(\"YES\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define maxn 100002\n#define FOR(i, l, r) for (int i=l; i<=r; ++i)\n#define FORD(i, r, l) for (int i=r; i>=l; --i)\n#define REP(i, r) for (int i=0; i<(int)r; ++i)\n#define REPD(i, r) for (int i=(int)r-1; i>=0; --i)\n#define fi first\n#define se second\n#define mk make_pair\n#define nil NULL\n#define y0 y902\n#define y1 y232\n#define x0 x92\n#define x1 x899\n#define next asdfa\n#define sz size\n#define Debug(X) {cerr << #X << \" = \" << X << '\\n';}\n#define PR(A, n) {cerr << #A << \" = \"; FOR(i, 1, n) cerr << A[i] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; REP(i, n) cerr << A[i] << ' '; cerr << '\\n';}\ntypedef long long ll;\ntypedef double db;\ntypedef pair<db, db> dd;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\nconst int inf = 1e9;\ntemplate<class T> int getbit(T x, int pos) {return (x>>(pos-1)) & 1;}\ntemplate<class T> void turn_on(T &x, int pos) {x = x | ((T)1<<(pos-1));}\ntemplate<class T> void turn_off(T &x, int pos) {x = x & ~((T)1<<(pos-1));}\ntemplate<class T> T sqr(T a) {return a*a;}\n\nint n, H, a[maxn], b[maxn], c[maxn], d[maxn];\nint cnt1[maxn], cnt2[maxn], cnt3[maxn], cnt4[maxn], tmp1, tmp2, tmp3;\nbool ok = true;\n\nint main() {\n    //freopen(\"jigsaw.inp\", \"r\", stdin);\n    //freopen(\"jigsaw.ans\", \"w\", stdout);\n    //ios::sync_with_stdio(0); cin.tie(0);\n    scanf(\"%d%d\", &n, &H);\n    FOR(i, 1, n) {\n        scanf(\"%d%d%d%d\", &a[i], &b[i], &c[i], &d[i]);\n        if (c[i]==0 && d[i]==0) ++tmp3;\n        if (c[i]==0) cnt1[a[i]]++;\n        else cnt2[c[i]]++;\n        if (d[i]==0) cnt3[b[i]]++;\n        else cnt4[d[i]]++;\n    }\n    FOR(i, 1, H) {\n        if (cnt2[i]>cnt3[i]) ok = false;\n        if (cnt2[i]==cnt3[i]-1) ++tmp1;\n        if (cnt4[i]>cnt1[i]) ok = false;\n        if (cnt4[i]==cnt1[i]-1) ++tmp2;\n    }\n    ok = ok && (tmp1>0 && tmp2>0) && (tmp1+tmp2-tmp3<=2);\n    if (ok) printf(\"YES\");\n    else printf(\"NO\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N, H;\nvector<int> vertex;\nint degree[1000];\nint v1[105000], v2[105000];\nbool can[1000];\nint main() {\n    cin >> N >> H;\n    cerr << N << \" \" << H << endl;\n    UnionFind uni(3 * H);\n    for(int i = 0; i < N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        cerr << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        if(c == 0) v1[i] = a;\n        else v1[i] = H + c;\n        if(d == 0) v2[i] = H + b;\n        else v2[i] = d;\n        degree[v1[i]]--;\n        degree[v2[i]]++;\n        uni.merge(v1[i], v2[i]);\n        vertex.push_back(v1[i]);\n        vertex.push_back(v2[i]);\n        //cerr << v1[i] << \" \" << v2[i] << endl;\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            can[v1[i]] = true;\n        }\n    }\n    sort(vertex.begin(), vertex.end());\n    vertex.erase(unique(vertex.begin(), vertex.end()), vertex.end());\n    map<int, vector<int>> mp;\n    for(auto v : vertex) {\n        /*\n        if(!uni.issame(v, vertex[0])) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        */\n        mp[uni.root(v)].push_back(v);\n    }\n    cerr << \"sz: \" << mp.size() << endl;\n    for(auto tmp : mp) {\n        /*\n        for(auto v : tmp.second) {\n            cerr << v << \" \";\n        }\n        cerr << endl;\n        */\n        vector<int> s, t;\n        for(auto v : tmp.second) {\n            if(degree[v] < 0) s.push_back(v);\n            if(degree[v] > 0) t.push_back(v);\n        }\n        if(s.empty()) {\n            assert(t.empty());\n            bool ok = false;\n            for(auto v : tmp.second) {\n                ok |= can[v];\n            }\n            if(!ok) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        } else {\n            //if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n            for(auto v : s) {\n                if(v >= H + 1) {\n                    cout << \"NO\" << endl;\n                    assert(0);\n                    return 0;\n                }\n            }\n            for(auto v : t) {\n                if(v <= H) {\n                    cout << \"NO\" << endl;\n                    assert(0);\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n    /*\n    int s = -1, t = -1;\n    for(auto v : vertex) {\n        if(abs(degree[v]) >= 2) {\n            cout << \"NO\" << endl;\n            cerr << \"DEGREE\" << endl;\n            return 0;\n        }\n        if(degree[v] == 1) {\n            if(t != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"T\" << endl;\n                return 0;\n            } else {\n                t = v;\n            }\n        }\n        if(degree[v] == -1) {\n            if(s != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"S\" << endl;\n                cerr << s << \" \" << v << endl;\n                return 0;\n            } else {\n                s = v;\n            }\n        }\n    }\n    if(s != -1) {\n        assert(t != -1);\n        if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n    }\n    for(int i = 0; i < N; i++) {\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    }\n    cout << \"NO\" << endl;\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MX=100010, inf=2e9;\n\nint n, h;\nmap<pii, int> indeg, outdeg;\n\nvector<pii> chk;\n\nbool solve(){\n    int cnt1=0, cnt2=0;\n    bool ex1=false, ex2=false;\n    for(int i=1; i<=h; i++){\n        pii a=pii(0,i), b=pii(i,h);\n        if(indeg[a]<outdeg[a]) return false;\n        if(outdeg[b]<indeg[b]) return false;\n\n        int x=max(0, indeg[a]-outdeg[a]);\n        int y=max(0, outdeg[b]-indeg[b]);\n        cnt1+=x, cnt2+=y;\n        outdeg[a]+=x, indeg[b]+=y;\n        ex1|=(indeg[a]!=0); ex2|=(indeg[b]!=0);\n    }\n\n    for(pii &p:chk){\n        if(p.first==0){\n            if(indeg[p]==0) return false;\n        }\n        else{\n            if(outdeg[p]==0) return false;\n        }\n    }\n\n    if(cnt1!=cnt2 || !ex1 || !ex2) return false;\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin>>n>>h; h++;\n    for(int i=1; i<=n; i++){\n        int a, b, c, d; cin>>a>>b>>c>>d;\n        if(c>0) a=h;\n        if(d>0) b=h;\n        pii x=(c==0 ? pii(a,h) : pii(0,c)), y=pii(d,b);\n        if(x==y) { chk.push_back(x); continue; }\n        // printf(\"L: %d, %d  R: %d, %d\\n\", (c==0 ? a : 0),(c==0 ? h : c), d,b);\n        outdeg[x]++;\n        indeg[y]++;\n    }\n    cout<<(solve() ? \"YES\" : \"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n   #define PP pair<int,pair<int,int>>\nconst int MAX = 510000;\nconst int MOD =  998244353;\nconst int INV2 = (MOD+1)/2;\n\n\n     signed main(){\n\n        int n,h;\n        map<int,int> mp[2];\n        cin>>n>>h;\n        int a,b,c,d;\n        for(int i=0;i<n;i++){\n          cin>>a>>b>>c>>d;\n          if(c==0)mp[0][a]++;\n          else mp[1][c]++;\n          if(d==0)mp[1][b]--;\n          else mp[0][d]--;\n        }\n        bool x=false;\n        for(auto i=mp[0].begin();i!=mp[0].end();i++){\n         //// cerr<<(i->second)<<' '<<(i->first)<<endl;\n          if(i->second>0)x=true;\n          if(i->second>=0)continue;\n         \n          \n          cout<<\"NO\"<<endl;\n          return 0;\n        }\n        for(auto i=mp[1].begin();i!=mp[1].end();i++){\n         // cerr<<(i->second)<<endl;\n          if(i->second<0)x=true;\n\n          if(i->second<=0)continue;\n         \n           \n          cout<<\"NO\"<<endl;\n          return 0;\n        }\n\n       if(x) cout<<\"YES\"<<endl;\n       else cout<<\"NO\"<<endl;\n        return 0;\n\n \n\n\n\n\n}\n\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint n,H,in[405],out[405],B[405],s[405],tote,size[405];\ninline int getfa(int x){return s[x]?s[x]=getfa(s[x]):x;}\ninline void Merge(int f,int t){if(getfa(f)!=getfa(t)) size[getfa(t)]+=size[getfa(f)],s[getfa(f)]=getfa(t);}\nint main()\n{\n    n=read();H=read();\n    for(int i=1;i<=n;++i)\n    {\n        int a=read(),b=read(),c=read(),d=read();\n        int f=c?c+H:a,t=d?d:b+H;\n        if(f==t) B[f]=1; else\n        {\n            ++out[f],++in[t];\n            Merge(f,t);++size[getfa(f)];++tote;\n        }\n      //  cout<<f<<\" \"<<t<<endl;\n    }\n    int S=0;\n    for(int i=1;i<=H*2;++i)\n    {\n       // cout<<i<<\" \"<<in[i]<<\" \"<<out[i]<<endl;\n        if(B[i]&&!in[i]&&!out[i]) return 0*puts(\"NO\");\n        if(i> H&&out[i]>in[i]) return 0*puts(\"NO\");\n        if(i<=H&&out[i]<in[i]) return 0*puts(\"NO\");\n        if(out[i]!=in[i])\n            if(S) Merge(S,i);\n            else S=i;\n    }\n    if(!S||size[getfa(S)]!=tote) return 0*puts(\"NO\");\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    int n,h;\n    cin >> n >> h;\n    vector<int> p(h+1),q(h+1);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;    \n        if(c==0){\n            p[a]++;\n        }else{\n            q[c]++;\n        }\n        if(d==0){\n            q[b]--;\n        }else{\n            p[d]--;\n        }\n    }\n    int c = 0;\n    int d = 0;\n    rep(i,h+1){\n        if(abs(p[i])>1){\n            cout << \"NO\" << endl;\n            return 0;\n        }else{\n            if(p[i]==1){\n                c++;\n            }else if(p[i]==-1){\n                cout << \"NO\" << endl;\n                return 0;\n                d++;\n            }\n        }\n        if(abs(q[i])>1){\n            cout << \"NO\" << endl;\n            return 0;\n        }else{\n            if(q[i]==1){\n                cout << \"NO\" << endl;\n                return 0;\n                c++;\n            }else if(q[i]==-1){\n                d++;\n            }\n        }\n    }\n    if((c==d)&&c>0){\n        cout << \"YES\" << endl;\n    }else{\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 500\nusing namespace std;\nint read(){\n    int nm=0,fh=1; int cw=getchar();\n    for(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n    for(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n    return nm*fh;\n}\nint n,m,e1,e2,h1,h2,cnt,in[M],ot[M],f[M]; bool vs[M];\nint fd(int x){return x==f[x]?x:f[x]=fd(f[x]);}\nint main(){\n    n=read(),m=read();\n    for(int i=1;i<=m;i++) f[i]=i,f[i+m]=i+m,vs[i]=vs[i+m]=false;\n    for(int i=1;i<=n;i++){\n        h1=read(),h2=read(),e1=read(),e2=read();\n        int t1=e1>0?e1:-h1,t2=e2>0?-e2:h2; t1+=m,t2+=m;\n        if(fd(t1)!=fd(t2)) f[fd(t1)]=fd(t2); in[t2]++,ot[t1]++;\n    }\n    for(int i=-m;i<0;i++) if(in[i+m]>ot[i+m]){puts(\"NO\");return 0;}\n    for(int i=1;i<=m;i++) if(in[i+m]<ot[i+m]){puts(\"NO\");return 0;}\n    for(int i=0;i<=m+m;i++) if(in[i]!=ot[i]) vs[fd(i)]=true;\n    for(int i=0;i<=m+m;i++) if(in[i]&&ot[i]&&!vs[fd(i)]){puts(\"NO\");return 0;}\n    puts(\"YES\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nconst int N = 4e2 + 100;\nint f[N];\nint ff(int x) {\n\treturn f[x] == x ? x : f[x] = ff(f[x]);\n}\nint n, h;\nint in[N], ou[N], ok[N];\n\nint main() {\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d, l, r;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tl = c == 0 ? a : h + a;\n\t\tr = d == 0 ? h + b : b;\n\t\t++ou[l], ++in[r];\n\t\tif (ff(l) != ff(r))\n\t\t\tf[ff(l)] = ff(r);\n\t}\n\tfor (int i = 1; i <= h; ++i)\n\t\tif (ou[i] < in[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = h + 1; i <= h + h; ++i)\n\t\tif (in[i] < ou[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (in[i] != ou[i])\n\t\t\tok[ff(i)] = true;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (ff(i) == i && !ok[i])\n\t\t\treturn puts(\"NO\"), 0;\n\treturn puts(\"YES\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int INF=0x7f7f7f7f;\nnamespace G{\n\tconst int N=210*2,E=100000*2+N*2;\n\tint to[E],bro[E],cap[E],head[N],e=0;\n\tint indeg[N],oudeg[N];\n\tint bln[N],dfn[N],low[N],tim=0;\n\tint stk[N],ss=0;\n\tbool instk[N];\n\tbool flag=true;\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t\tmemset(bln,-1,sizeof(bln));\n\t\tmemset(dfn,0,sizeof(dfn));\n\t\tmemset(instk,0,sizeof(instk));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t\tif(flag){\n\t\t\toudeg[u]++,indeg[v]++;\n\t\t}\n\t}\n\tvoid tarjan(int x){\n\t\tdfn[x]=low[x]=++tim;\n\t\tstk[ss++]=x,instk[x]=true;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif(dfn[v=to[i]]){\n\t\t\t\tif(instk[v]){\n\t\t\t\t\tapmin(low[x],dfn[v]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttarjan(v);\n\t\t\t\tapmin(low[x],low[v]);\n\t\t\t}\n\t\t}\n\t\tif(dfn[x]==low[x]){\n\t\t\tfor(int v;v=stk[--ss],instk[v]=false,bln[v]=x,v!=x;);\n\t\t}\n\t}\n}\ninline bool Main(){\n\tusing namespace G;\n\tint n=ni,h=ni;\n\tinit();\n\tfor(int i=1;i<=n;i++){\n\t\tint a=ni,b=ni,c=ni,d=ni;\n\t\tae(c?c+h:a,d?d:b+h);\n\t}\n\tflag=false;\n\tfor(int i=1,j=h+1;i<=h;i++,j++){\n\t\tif(indeg[i]>oudeg[i])return false;\n\t\tif(indeg[i]!=oudeg[i])ae(0,i);\n\t\tif(indeg[j]<oudeg[j])return false;\n\t\tif(indeg[j]!=oudeg[j])ae(j,0);\n\t}\n\ttarjan(0);\n\tfor(int i=1,ti=h<<1;i<=ti;i++){\n\t\tif((indeg[i]||oudeg[i])&&bln[i])return false;\n\t}\n\treturn true;\n}\nint main(){\n\tputs(Main()?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=205,INF=1<<30;\nint cnt[MAX][2];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,H;cin>>N>>H;\n    \n    for(int i=0;i<N;i++){\n        int a,b,c,d;cin>>a>>b>>c>>d;\n        if(c==0) cnt[a][0]++;\n        else cnt[c][1]++;\n        \n        if(d==0) cnt[b][1]--;\n        else cnt[d][0]--;\n    }\n    \n    int sum1=0,sum2=0;\n    bool ok=true;\n    \n    for(int i=0;i<=H;i++){\n        sum1+=cnt[i][0];\n        sum2+=cnt[i][1];\n        \n        if(cnt[i][0]<0) ok=false;\n        if(cnt[i][1]>0) ok=false;\n    }\n    \n    if(sum1>sum2&&ok) cout<<\"YES\\n\";\n    else cout<<\"NO\\n\";\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\nint F() {\n\tregister int a, b, c;\n\twhile(c=getchar(), c<'-');\n\tb=(c=='-');\n\tfor(a=b?0:c-'0'; c=getchar(),c>'-'; a=a*10+c-'0');\n\treturn b?-a:a;\n}\nconst int N=3e5+10, M=1e6+10, oo=1<<30;\nint m, e, S, T, head[N], cur[N], to[M], next[M], cap[M], dis[N], q[N];\nvoid add(register int u, register int v, register int w) {\n\tto[e]=v, next[e]=head[u], cap[e]=w, head[u]=e++;\n\tto[e]=u, next[e]=head[v], cap[e]=0, head[v]=e++;\n}\nbool bfs() {\n\tregister int l=-1, r=-1, i;\n\tmemset(dis, -1, m*sizeof(int));\n\tdis[q[++r]=T]=0;\n\twhile(l<r) {\n\t\tfor(i=head[q[++l]]; i; i=next[i]) {\n\t\t\tif(cap[i^1] && dis[to[i]]==-1) {\n\t\t\t\tdis[q[++r]=to[i]]=dis[q[l]]+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn ~dis[S];\n}\nint dfs(register int x, register int lim) {\n\tregister int ans=0, now;\n\tif(x==T) return lim;\n\tfor(register int &i=cur[x]; i; i=next[i]) if(dis[x]==dis[to[i]]+1 && cap[i]) {\n\t\tnow=dfs(to[i], lim<cap[i]?lim:cap[i]);\n\t\tlim-=now;\n\t\tans+=now;\n\t\tcap[i]-=now;\n\t\tcap[i^1]+=now;\n\t\tif(!lim) break;\n\t}\n\treturn ans;\n}\nint fa[N];\nint find(register int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}\nint deg[N];\nbool mark[N], appear[N];\nbool work() {\n\tregister int n=F(), h=F(), i, a, b, c, d, cnt=0, ans=0;\n\tm=n+h+h+2, e=2, S=0, T=n+h+h+1;\n\tmemset(head, 0, m*sizeof(int));\n\tfor(i=1; i<=2*h; ++i) fa[i]=i, deg[i]=0, appear[i]=mark[i]=0;\n\tfor(i=1; i<=n; ++i) {\n\t\ta=F(), b=F(), c=F(), d=F();\n\t\tif(!c) c=a+h, add(i+h+h, c, 1);\n\t\tif(!d) d=b  , add(i+h+h, d, 1); else d+=h;\n\t\t++deg[c], --deg[d], fa[find(c)]=find(d);\n\t\tappear[c]=appear[d]=1;\n\t\tadd(S, i+h+h, 2);\n\t}\n\tfor(i=1; i<=2*h; ++i) if(appear[i]) {\n\t\tif(deg[i]>0) if(i> h) add(i, T, deg[i]), cnt+=deg[i]; else return 0;\n\t\tif(deg[i]<0) if(i<=h) add(i, T,-deg[i]), cnt-=deg[i]; else return 0;\n\t\tmark[i] = deg[i]!=0;\n\t}\n\tfor(i=1; i<=2*h; ++i) mark[find(i)]|=mark[i];\n\tfor(i=1; i<=2*h; ++i) if(appear[i] && find(i)==i && !mark[i]) return 0;\n\twhile(bfs()) {\n\t\tmemcpy(cur, head, m*sizeof(int));\n\t\tans+=dfs(S, oo);\n\t}\n\treturn ans==cnt;\n}\nint main() {\n\tputs(work()?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint num[403][2]={0}; \nint main(){\n\tint n,h,t;\t\n\tcin>>n>>h;\n\tvector<int>pic[4];\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tpic[j].push_back(t);\n\t\t}\t\n\t} \n\tfor(int i=0;i<pic[0].size();i++){\n\t\tif(pic[2][i]==0) \n\t\t\tnum[pic[0][i]][0]++;\n\t\telse \n\t\t\tnum[200+pic[2][i]][0]++;\n\t\tif(pic[3][i]==0) \n\t\t\tnum[200+pic[1][i]][1]++;\n\t\telse \n\t\t\tnum[pic[3][i]][1]++;\n\t}\n\tint flag1=0,flag2=0,flag=0;\n\tfor(int i=0;i<403;i++){\n\t\tif(num[i][0]>num[i][1]) {\n\t\t\tif(((num[i][0]-1)==num[i][1])&&(i<200)){\n\t\t\t\tflag1++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t\tif(num[i][0]<num[i][1]) {\n\t\t\tif(((num[i][0]+1)==num[i][1])&&(i>=200)){\n\t\t\t\tflag2++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag1==flag2&&flag1>0&&flag==0) cout<<\"YES\";\n\telse cout<<\"NO\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 400\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,H,in[MN+5],out[MN+5],s[MN+5],size[MN+5],b[MN+5],B[MN+5];\ninline int gf(int x){return s[x]?s[x]=gf(s[x]):x;}\ninline void ins(int f,int t)\n{\n\t++in[t];++out[f];\n\tif(gf(f)!=gf(t))\n\t\tsize[gf(t)]+=size[gf(f)],\n\t\tb[gf(t)]|=b[gf(f)],B[gf(t)]|=B[gf(f)],\n\t\ts[gf(f)]=gf(t);\n\tB[gf(f)]=B[gf(t)]=1;\n}\nint main()\n{\n\tn=read();H=read();\n\tfor(int i=1;i<=2*H;++i) size[i]=1,b[i]=i>H;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tif(!c&&!d) continue;\n\t\tint f=c?c+H:a,t=d?d:b+H;\n\t\tins(f,t);\n\t}\n\tfor(int i=1;i<=2*H;++i)\n\t{\n\t\tif(in[i]-out[i]>1||in[i]-out[i]<-1) return 0*puts(\"NO\");\n\t\tif(in[i]!=out[i]) \n\t\t{\n\t\t\tif(i<=H&&out[i]<in[i]) return 0*puts(\"NO\");\n\t\t\tif(i> H&&out[i]>in[i]) return 0*puts(\"NO\");\n\t\t}\n\t}\n\tfor(int i=1;i<=2*H;++i) if(gf(i)==i&&B[i]&&!b[i]) return 0*puts(\"NO\");\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\n#define mp make_pair\n#define ni(x) scanf(\"%d\", &(x))\n#define nii(x,y) scanf(\"%d%d\",&(x),&(y))\n#define mul(x,y) ((ll)(x)*(y)%mod)\n#define mtp make_tuple\n#define F(i,n) for(int i = 0; i < (n); i++)\n#define FF(i,n) for(int i = 1; i <= (n); i++)\n#define FE(i,n) for(int i = 0; i <= (n); i++)\n\n#ifndef __GNUG__\nint __builtin_popcount(int n) {\n\tint x = 0;\n\twhile (n)n -= n&(-n), x++;\n\treturn x;\n}\n#endif\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int mod = 1000000007;\nconst int inf = 2012345678;\nconst ll infl = 9012345678901234567;\nconst double pi = 3.1415926535897932384626433832795;\n//----------------------------------------------------------------------------//\n\nconst int N = 100000 + 1000;\n\nvector<int> adj[N], rev[N];\nint ord[N], clk, scc[N], ind[N], chk[N], ccn;\n\nvoid dfs1(int u) {\n\tchk[u] = 1;\n\tfor (auto &x : rev[u]) {\n\t\tif (chk[x])continue;\n\t\tdfs1(x);\n\t}\n\tord[clk++] = u;\n}\nvoid dfs2(int u) {\n\tchk[u] = 1;\n\tscc[u] = ccn;\n\tfor (auto &x : adj[u]) {\n\t\tif (chk[x])continue;\n\t\tdfs2(x);\n\t}\n}\n\nint main() {\n#ifndef __GNUG__\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n, h; nii(n, h);\n\tF(i, n) {\n\t\tint a, b, c, d; nii(a, b); nii(c, d);\n\t\tif (c == 0) {\n\t\t\tadj[n - 1 + a].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tadj[n + h - 1 + c].push_back(i);\n\t\t}\n\t\tif (d == 0) {\n\t\t\tadj[i].push_back(n + h - 1 + b);\n\t\t}\n\t\telse {\n\t\t\tadj[i].push_back(n - 1 + d);\n\t\t}\n\t}\n\tint S = n + 2 * h;\n\tint T = S + 1;\n\tadj[T].push_back(S);\n\tFF(i, h)adj[S].push_back(n - 1 + i);\n\tFF(i, h)adj[n + h - 1 + i].push_back(T);\n\n\tint vn = n + 2 * h + 2;\n\tF(i, vn)for (auto &x : adj[i])rev[x].push_back(i);\n\tF(i, vn)if (!chk[i])dfs1(i);\n\tF(i, vn)chk[i] = 0;\n\tfor (int i = vn - 1; i >= 0; i--) {\n\t\tint j = ord[i];\n\t\tif (chk[j])continue;\n\t\tdfs2(j);\n\t\tccn++;\n\t}\n\t/*F(i, n) {\n\t\tif (scc[i] != scc[S])return puts(\"NO\"), 0;\n\t\tif (scc[adj[i][0]] != scc[S])return puts(\"NO\"), 0;\n\t\tif (scc[rev[i][0]] != scc[S])return puts(\"NO\"), 0;\n\t}\n\tif (scc[T] != scc[S])return puts(\"NO\"), 0;*/\n\tF(i, vn)for (auto &x : adj[i])ind[x]++;\n\t\n\tFF(i, h) {\n\t\tif (ind[n - 1 + i] - 1 > (int)adj[n - 1 + i].size())return puts(\"NO\"), 0;\n\t\tif (ind[n + h - 1 + i] < (int)adj[n + h - 1 + i].size() - 1)return puts(\"NO\"), 0;\n\t}\n\tputs(\"YES\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nint n,h;\nint l[220],r[220],bns,fa[220],siz[220],L,R;\nint find(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=200;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0)l[a]++,bns++,L=a;\n\t\telse r[c]--,bns--,L=a;\n\t\tif(d==0)r[b]++,bns++,R=b;\n\t\telse l[d]--,bns--,R=d;\n\t\tif(find(L)==find(R)){\n\t\t\tsiz[find(L)]++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tsiz[find(R)]+=siz[find(L)]+1;\n\t\tsiz[find(L)]=0;\n\t\tfa[find(L)]=find(R);\n\t}\n\tint ans=0,cns=0;\n\tfor(int i=1;i<=200;i++){\n\t\tans+=l[i];\n\t\tans+=r[i];\n\t\tif(l[i]<0||r[i]<0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tcns+=siz[find(i)];\n\t\tsiz[find(i)]=0;\n\t}\n\tif(bns<=0||ans!=bns||cns!=n){\n\t\tprintf(\"NO\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nint N, H;\nll a[200000], b[200000], c[200000], d[300000];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> H;\n    for(int i = 0; i < N; i++) cin >> a[i] >> b[i] >> c[i] >> d[i];\n    vector<int> idx(N);\n    iota(idx.begin(), idx.end(), 0);\n    do {\n        bool ok = true;\n        if(c[idx[0]] != 0) ok = false;\n        for(int i = 0; i + 1 < N; i++) {\n            if(d[idx[i]] > 0 and c[idx[i+1]] > 0) ok = false;\n            else if(d[idx[i]] == 0 and c[idx[i+1]] == 0) {\n            } else if(d[idx[i]] == 0) {\n                if(b[idx[i]] != c[idx[i+1]]) ok = false;\n            } else if(c[idx[i+1]] == 0) {\n                if(a[idx[i+1]] != d[idx[i]]) ok = false;\n            } else assert(0);\n        }\n        if(d[idx[N-1]] != 0) ok = false;\n        if(ok) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    } while(next_permutation(idx.begin(), idx.end()));\n    cout << \"NO\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#define eps 1e-10\n#define inf 1e9\n#define For(i,j,k)\tfor(int i=j;i<=k;++i)\n#define Dow(i,j,k)\tfor(int i=k;i>=j;--i)\n#define ll long long\n#define y1 orz\nusing namespace std;\ninline ll read()\n{\n\tll t=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9')\t{if(c=='-')\tf=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')\tt=t*10+c-48,c=getchar();\n\treturn t*f;\n}\nint n,h,F[1001],deg[1001],hav[1001],is_father[1001];\ninline int get(int x){return x==F[x]?F[x]:F[x]=get(F[x]);}\nint x,y,x1,y1,tx,ty;\nint main()\n{\n\tn=read();h=read();\n\tFor(i,1,1000)\tF[i]=i;\n\tFor(i,1,n)\t\n\t{\n\t\tx=read();y=read();x1=read();y1=read();\n\t\tif(x1==0)\ttx=x;else tx=-x1;\n\t\tif(y1==0)\tty=-y;else ty=y1;\n\t\ttx+=500;ty+=500;\n\t\tdeg[tx]++;deg[ty]--;hav[tx]=1;\n//\t\tcout<<tx<<' '<<ty<<endl;\n\t\tF[get(tx)]=get(ty);\n\t}\n\tFor(i,501,1000)\tif(deg[i]<0)\t{puts(\"NO\");return 0;}\t\t\n\tFor(i,1,500)\tif(deg[i]>0)\t{puts(\"NO\");return 0;}\n\tFor(i,1,1000)\t\n\t\thav[get(i)]|=hav[i];\n\tFor(i,1,1000)\n\t\tif(deg[get(i)])is_father[get(i)]=1;\n\tFor(i,1,1000)\t\n\t\tif(hav[i])\n\t\t\tif(F[i]==i&&!is_father[i])\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define NO return puts(\"NO\"),0\nusing namespace std;\n\nint n,m,f[1000],a,b,c,d,x,y,D[1000],bo[1000],C[1000];\nint gf(int x){return x==f[x]?x:f[x]=gf(f[x]);}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\t\n\tfor (int i=1;i<999;i++) f[i]=i;\n\twhile (n--){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif (c==0) x=a;else x=-c;x+=500;\n\t\tif (d==0) y=-b;else y=d;y+=500;\n\t\tf[gf(x)]=gf(y);\n\t\tD[x]++;D[y]--;bo[x]=1;\n\t}\n\tfor (int i=1;i<500;i++) if (D[i]>0) NO;\n\tfor (int i=501;i<999;i++) if (D[i]<0) NO;\n\tfor (int i=1;i<999;i++)\n\tif (bo[gf(i)]|=bo[i],D[i]) C[f[i]]=1;\n\tfor (int i=1;i<999;i++)\n\tif (f[i]==i&&!C[i]&&bo[i]) NO;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nvector<int>G[405];\nint in[405];\nint a[100005], b[100005], c[100005], d[100005];\nint vst[405];\nvoid dfs(int now) {\n\tfor(int e:G[now]) {\n\t\tif (vst[e])continue;\n\t\tvst[e] = 1;\n\t\tdfs(e);\n\t}\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\trep(i, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tint x, y;\n\t\tif (c[i] == 0)x = a[i];\n\t\telse x = c[i] + h;\n\t\tif (d[i] == 0)y = b[i] + h;\n\t\telse y = d[i];\n\t\tG[x].push_back(y);\n\t\tin[y]++;\n\t}\n\tint cnt = 0;\n\trep(i, h + 1) {\n\t\tint z = G[i].size();\n\t\tif (z-in[i]>=1) {\n\t\t\tcnt+=z-in[i];\n\t\t\tG[0].push_back(i);\n\t\t\tin[i]++;\n\t\t}\n\t\telse if (z != in[i]) {\n\t\t\tputs(\"NO\"); return 0;\n\t\t}\n\t}\n\tfor (int i = h + 1; i <= 2 * h; i++) {\n\t\tint z = G[i].size();\n\t\tif (in[i]-z>=1) {\n\t\t\tcnt-=in[i]-z;\n\t\t\tG[i].push_back(0);\n\t\t\tin[0]++;\n\t\t}\n\t\telse if (z != in[i]) {\n\t\t\tputs(\"NO\"); return 0;\n\t\t}\n\t}\n\n\n\tif (cnt!=0) {\n\t\tputs(\"NO\");\n\t}\n\telse {\n\t\tvst[0] = 1;\n\t\tdfs(0);\n\t\trep(i, 2 * h + 1) {\n\t\t\tif (vst[i] == 0 && (in[i]||G[i].size())) {\n\t\t\t\tputs(\"NO\"); return 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(\"YES\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define pb push_back\n \nusing namespace std;\n \nconst int N=100005,M=205;\n \nvector<int> vle[M],vlf[M],vre[M],vrf[M];\nbitset<N> v[4][M];\nint n,h,a[N],b[N],c[N],d[N],f1,f2,id[N];\nbool vis[N];\n\nvoid dfs1(int x){\n\tvis[x]=true;\n\tif(d[x]){\n\t\tbool flag=false;\n\t\tfor(auto v:vlf[d[x]])if(!vis[v]){flag=true;dfs1(v);break;}\n\t\tif(!flag){puts(\"NO\"),exit(0);}\n\t}\n}\n\nvoid dfs2(int x){\n\tvis[x]=true;\n\tif(c[x]){\n\t\tbool flag=false;\n\t\tfor(auto v:vrf[c[x]])if(!vis[v]){flag=true;dfs2(v);break;}\n\t\tif(!flag){puts(\"NO\"),exit(0);}\n\t}\n}\n \nint main(){\n\tscanf(\"%d%d\",&n,&h);int x,y,i;\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n\t\tif(!c[i]){\n\t\t\tvlf[a[i]].pb(i);\n\t\t\tv[0][a[i]][i]=1;\n\t\t}else{\n\t\t\tvle[c[i]].pb(i);\n\t\t\tv[1][c[i]][i]=1;\n\t\t}\n\t\tif(!d[i]){\n\t\t\tvrf[b[i]].pb(i);\n\t\t\tv[2][b[i]][i]=1;\n\t\t}else{\n\t\t\tvre[d[i]].pb(i);\n\t\t\tv[3][d[i]][i]=1;\n\t\t}\n\t}\n\tfor(i=0;i<=h;i++){\n\t\tx=vle[i].size(),y=vrf[i].size();\n\t\tif(x>y)puts(\"NO\"),exit(0);\n\t\tif(x && x==y && v[1][i]==v[2][i]) puts(\"NO\"),exit(0);\n\t\tx=vre[i].size(),y=vlf[i].size();\n\t\tif(x>y)puts(\"NO\"),exit(0); \n\t\tif(x && x==y && v[0][i]==v[3][i]) puts(\"NO\"),exit(0);\n\t}\n\tfor(i=1;i<=n;i++)id[i]=i;\n\tstd::random_shuffle(id+1,id+n+1);\n\tfor(i=1;i<=n/20+1;i++)memset(vis,0,n+1),dfs1(id[i]);\n\tstd::random_shuffle(id+1,id+n+1);\n\tfor(i=1;i<=n/20+1;i++)memset(vis,0,n+1),dfs2(id[i]);\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nvector <pii> I[101010], O[101010];\nbool chk[222];\nint n, h;\n\nint dfs(int p)\n{\n\tint ret = O[p].size();\n\t\n\tchk[p] = 1;\n\t\n\tfor(pii t: O[p]){\n\t\tif(!chk[t.first]){\n\t\t\tret += dfs(t.first);\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tint i, a, b, c, d, s1, s2, t1, t2, f, f1, f2;\n\tscanf(\"%d%d\", &n, &h);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\n\t\tf = 0;\n\t\tif(c) a = c;\n\t\telse f |= 1;\n\t\tif(d) b = d;\n\t\telse f |= 2;\n\t\t\n\t\tI[b].push_back(pii(a, f));\n\t\tO[a].push_back(pii(b, f));\n\t}\n\t\n\ts1 = s2 = 0;\n\t\n\tfor(i=1;i<h;i++){\n\t\tif(I[i].size() + 1 == O[i].size()) s1 ++, t1 = i;\n\t\telse if(I[i].size() == O[i].size() + 1) s2 ++, t2 = i;\n\t\telse if(I[i].size() != O[i].size()){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<h;i++) chk[i] = 0;\n\t\n\tif(s1 == 0 && s2 == 0 && dfs(1) == n){\n\t\tfor(i=1;i<h;i++){\n\t\t\tf1 = f2 = 0;\n\t\t\tfor(pii j: O[i]) if(j.second & 1) f1 = 1;\n\t\t\tfor(pii j: I[i]) if(j.second & 2) f2 = 1;\n\t\t\tif(f1 && f2){\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=1;i<h;i++) chk[i] = 0;\n\t\n\tif(s1 == 1 && s2 == 1 && dfs(t1) == n){\n\t\tf1 = f2 = 0;\n\t\tfor(pii j: O[t1]) if(j.second & 1) f1 = 1;\n\t\tfor(pii j: I[t2]) if(j.second & 2) f2 = 1;\n\t\tif(f1 && f2){\n\t\t\tprintf(\"YES\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprintf(\"NO\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nconst int maxnode=2000000+16;\n\nint n,h;\nvector<int> g[maxnode];\nbool v[maxnode];\nint d[maxnode];\nint q[maxnode];\nbool ww;\n\nvoid bfs(int p)\n{\n\tif (v[p]) return;\n\tv[p]=true;\n\tint sizeq=0;\n\tq[sizeq++]=p;\n\tREP(cl,sizeq)\n\t{\n\t\tint x=q[cl];\n\t\tfor (int y:g[x]) if (!v[y]) v[y]=true,q[sizeq++]=y;\n\t}\n}\nvoid dfs2(int p)\n{\n\tif (v[p]) return;\n\tv[p]=true;\n\tif (p<h && d[p]<0) ww=true;\n\tfor (int x:g[p]) dfs2(x);\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\twhile (cin>>n>>h && n>0)\n\t{\n\t\th+=2;\n\t\tvector<ipair> edges;\n\t\tREP(i,n)\n\t\t{\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tint s=((c==0)?(a+h):c);\n\t\t\tint t=((d==0)?b:(d+h));\n\t\t\tedges.emplace_back(s,t);\n\t\t}\n\t\tbool ok=true;\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.first].push_back(e.second);\n\t\tFOR(i,h,h+h) bfs(i);\n\t\tfor (auto e:edges) if (!v[e.first]) ok=false;\n\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.second].push_back(e.first);\n\t\tREP(i,h) bfs(i);\n\t\tfor (auto e:edges) if (!v[e.second]) ok=false;\n\n\t\tREP(i,h+h) d[i]=0;\n\t\tfor (auto e:edges) ++d[e.first],--d[e.second];\n\t\tREP(i,h) if (d[i]>0) ok=false;\n\t\tFOR(i,h,h+h) if (d[i]<0) ok=false;\n\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.second].push_back(e.first);\n\t\tfor (auto e:edges) g[e.first].push_back(e.second);\n\t\tREP(i,h+h) if (!v[i] && SIZE(g[i])>0)\n\t\t{\n\t\t\tww=false;\n\t\t\tdfs2(i);\n\t\t\tif (!ww) ok=false;\n\t\t}\n\n\t\tif (ok)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\tfflush(stdout);\n#ifndef _MSC_VER\n\t\tbreak;\n#endif\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,h,deg[410],cnt,sum,gap[410],dis[410],s,t;\nbool flag[410];\nstruct edge\n{\n    int v,f;\n    edge *nxt,*rev;\n} pool[200100],*tp=pool,*fst[410],*cur[410];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nvoid addedge(int u,int v,int f)\n{\n    ++deg[u],--deg[v];\n    *tp=(edge){v,f,fst[u],tp+1},fst[u]=tp++;\n    *tp=(edge){u,0,fst[v],tp-1},fst[v]=tp++;\n}\n\nint sap(int x,int flow)\n{\n    if (x==t)\n        return flow;\n    int sum=0,f;\n    for (edge *i=cur[x]; i; i=i->nxt)\n        if (i->f && dis[i->v]+1==dis[x])\n        {\n            f=sap(i->v,min(flow-sum,i->f));\n            i->f-=f,i->rev->f+=f,cur[x]=i;\n            if ((sum+=f)==flow || dis[s]==t)\n                return sum;\n        }\n    if (!--gap[dis[x]])\n        dis[s]=t;\n    ++gap[++dis[x]],cur[x]=fst[x];\n    return sum;\n}\n\nvoid dfs(int x)\n{\n    if (flag[x])\n        return;\n    flag[x]=1;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (i->f)\n            ++cnt,dfs(i->v);\n}\n\nbool check()\n{\n    repu(i,1,n)\n    {\n        int a=getint(),b=getint(),c=getint(),d=getint();\n        int u=c?c:h+a,v=d?h+d:b;\n        addedge(u,v,1);\n    }\n    s=h*2+1,t=s+1;\n    repu(i,1,h*2)\n    {\n        if (deg[i]>0 && i>h)\n            dfs(i),sum+=deg[i],addedge(s,i,deg[i]);\n        if (deg[i]<0 && i<=h)\n            addedge(i,t,-deg[i]);\n    }\n    if (cnt<n)\n        return 0;\n    gap[0]=t;\n    repu(i,1,t)\n        cur[i]=fst[i];\n    for (; dis[s]<t; sum-=sap(s,1<<30));\n    return !sum;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    puts(check()?\"YES\":\"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\ntypedef long long ll;\nconst int Imx=2147483647;\nconst int mod=1000000007;\nconst ll Lbig=2e18;\n//My own input/output stream\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putsp()\n#define putii(x,y) puti(x),putnum(y),putsp()\n#define putiii(x,y,z) putii(x,y),putnum(z),putsp()\n#define putsi(x) putnum(x),putendl()\n#define putsii(x,y) puti(x),putnum(y),putendl()\n#define putsiii(x,y,z) putii(x,y),putnum(z),putendl()\ninline ll getnum()\n{\n\tregister ll r=0;register bool ng=0;register char c;c=getchar();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tif(c=='-')ng=1,c=getchar();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=getchar();\n\tif(ng)r=-r;return r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline void putsp(){putchar(' ');}\ninline void putendl(){putchar('\\n');}\ninline char mygetchar(){register char c=getchar();while(c==' '||c=='\\n')c=getchar();return c;}\nint n;\nvector<int> con[100111];\nvector<int> vl[211],vr[211],vrs[211],vls[211];\nint vlit[211],vrit[211],vrsit[211],vlsit[211];\nbool vis[100111];\nint A[100111],B[100111],C[100111],D[100111];\nbool fl[211],fr[211];\nint getvl(int x)\n{\n\twhile(vlit[x]<vl[x].size()&&vis[vl[x][vlit[x]]])\n\t{\n\t\tvlit[x]++;\n\t}\n\tif(vlit[x]==vl[x].size())return -1;else return vl[x][vlit[x]];\n}\nint getvr(int x)\n{\n\twhile(vrit[x]<vr[x].size()&&vis[vr[x][vrit[x]]])\n\t{\n\t\tvrit[x]++;\n\t}\n\tif(vrit[x]==vr[x].size())return -1;else return vr[x][vrit[x]];\n}\nint getvls(int x)\n{\n\twhile(vlsit[x]<vls[x].size()&&vis[vls[x][vlsit[x]]])\n\t{\n\t\tvlsit[x]++;\n\t}\n\tif(vlsit[x]==vls[x].size())return -1;else return vls[x][vlsit[x]];\n}\nint getvrs(int x)\n{\n\twhile(vrsit[x]<vrs[x].size()&&vis[vrs[x][vrsit[x]]])\n\t{\n\t\tvrsit[x]++;\n\t}\n\tif(vrsit[x]==vrs[x].size())return -1;else return vrs[x][vrsit[x]];\n}\nint tmpl[100111],tmplsz;\nint tmpr[100111],tmprsz;\n\nint dfs(int s,int x,int pred=1,bool flag=0)\n{\n\tif(vis[s]&&s==x&&flag)return 0;\n//\tvis[x]=1;\n\tint a=A[x],b=B[x],c=C[x],d=D[x],u=-1;\n//\tcout<<\"dfs:\"<<x<<\" \"<<pred<<\" \"<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\tif(pred!=1)\n\t{\n\t\tif(c==0)u=getvrs(a);\n\t\telse u=getvr(c);\n\t\tif(u!=-1)\n\t\t{\n\t\t\tif(c==0)tmpl[tmplsz++]=a,flag|=fl[a];\n\t\t\telse tmpr[tmprsz++]=c,flag|=fr[c];\n\t\t\tvis[u]=1;\n\t\t\treturn dfs(s,u,-1,flag);\n\t\t}\n\t\telse if(c>0)return -1;\n\t}\n\tif(pred!=-1)\n\t{\n\t\tif(d==0)u=getvls(b);\n\t\telse u=getvl(d);\n\t\tif(u!=-1)\n\t\t{\n\t\t\tif(d==0)tmpr[tmplsz++]=b,flag|=fr[b];\n\t\t\telse tmpl[tmprsz++]=d,flag|=fl[d];\n\t\t\tvis[u]=1;\n\t\t\treturn dfs(s,u,1,flag);\n\t\t}\n\t\telse if(d>0)return -1;\n\t}\n\treturn 1;\n}\nint main()\n{\n\tint tmp;\n\tgetii(n,tmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tgetii(a,b);\n\t\tgetii(c,d);\n\t\tA[i]=a;\n\t\tB[i]=b;\n\t\tC[i]=c;\n\t\tD[i]=d;\n\t\tif(c==0)\n\t\t{\n\t\t\tvl[a].PB(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvls[c].PB(i);\n\t\t}\n\t\tif(d==0)\n\t\t{\n\t\t\tvr[b].PB(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvrs[d].PB(i);\n\t\t}\n\t}\n\tint cnt0=0,cnt1=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(vis[i])continue;\n\t\ttmplsz=0;\n\t\ttmprsz=0;\n\t\tint type=dfs(i,i,1);\n\t\tif(type==-1)\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\telse if(type==0)cnt0++;\n\t\telse if(type==1)\n\t\t{\n\t\t\tcnt1++;\n\t\t\tfor(int j=0;j<tmplsz;j++)\n\t\t\t{\n\t\t\t\tfl[tmpl[j]]=1;\n\t\t\t}\n\t\t\tfor(int j=0;j<tmprsz;j++)\n\t\t\t{\n\t\t\t\tfr[tmpr[j]]=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(cnt1>0)puts(\"YES\");else puts(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MX=100010, inf=2e9;\n\nint n, h;\nmap<pii, int> indeg, outdeg;\n\nbool solve(){\n    int cnt1=0, cnt2=0;\n    bool ex1=false, ex2=false;\n    for(int i=1; i<=h; i++){\n        pii a=pii(0,i), b=pii(i,h);\n        int x=max(0, indeg[a]-outdeg[a]);\n        int y=max(0, outdeg[b]-indeg[b]);\n        cnt1+=x, cnt2+=y;\n        outdeg[a]+=x, indeg[b]+=y;\n        ex1|=(indeg[a]!=0); ex2|=(indeg[b]!=0);\n    }\n    if(cnt1!=cnt2 || !ex1 || !ex2) return false;\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin>>n>>h;\n    for(int i=1; i<=n; i++){\n        int a, b, c, d; cin>>a>>b>>c>>d;\n        if(c>0) a=h;\n        if(d>0) b=h;\n        outdeg[(c==0 ? pii(a,h) : pii(0,c))]++;\n        indeg[pii(d,b)]++;\n    }\n    cout<<(solve() ? \"YES\" : \"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint inadj[210][2], outadj[210][2], n, h;\nint inadj2[210][2], outadj2[210][2];\npair<int, int> thing(int a, int b)\n{\n\tpair<int, int> ans;\n\tif (b) ans = { b, 0 };\n\telse ans = { a, 1 };\n\treturn ans;\n}\nvector<pair<int, int> > adj[210][2];\nint seen[210][2], c;\nvector<pair<int, int> > components[500];\nvoid dfs(int a, int b, int d)\n{\n\tif (seen[a][b]) return;\n\tseen[a][b] = 1;\n\tcomponents[d].push_back({ a, b });\n\tfor (auto c : adj[a][b]) dfs(c.first, c.second, d);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tpair<int, int> in, out;\n\t\tin = thing(a, c);\n\t\tout = thing(b, d);\n\t\tout.second = !out.second;\n//\t\tprintf(\"%d %d -> %d %d\\n\", in.first, in.second, out.first, out.second);\n\t\toutadj[in.first][in.second]++;\n\t\tinadj[out.first][out.second]++;\n\t\tadj[in.first][in.second].push_back(out);\n\t\tadj[out.first][out.second].push_back(in);\n\t}\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tif (adj[i][j].size() && !seen[i][j]) dfs(i, j, c++);\n\t\t//\tprintf(\"%d:%d - in %d, out %d\\n\", i, j, inadj[i][j], outadj[i][j]);\n\t\t}\n\t}\n\tbool works = 1;\n\tfor (int i = 0; i < c; i++)\n\t{\n\t\tfor (int i = 0; i <= h; i++) inadj2[i][0] = inadj2[i][1] = outadj2[i][0] = outadj2[i][1] = 0;\n\t\tfor (auto b : components[i])\n\t\t{\n\t\t\tinadj2[b.first][b.second] += inadj[b.first][b.second];\n\t\t\toutadj2[b.first][b.second] += outadj[b.first][b.second];\n\t\t}\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\t//printf(\"%d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\tif (inadj2[i][0] - outadj2[i][0] > 0 && inadj2[i][1] - outadj2[i][1] < 0) \n\t\t\t{\n\t\t\t//\tprintf(\"%d\\n\", i);\n\t\t\t\tinadj2[i][0]--; \n\t\t\t\toutadj2[i][1]--;\n\t\t\t//\tprintf(\" %d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\t}\n\t\t}\n\t\tint extra = 0;\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t{\n\t\t//\t\tprintf(\"  %d\\n\", abs(inadj2[i][j] - outadj2[i][j]));\n\t\t\t\tif (abs(inadj2[i][j] - outadj2[i][j])) extra+=abs(inadj2[i][j] - outadj2[i][j]);\n\t\t\t}\n\t\t}\n\t\tif (extra != 2) works = 0;\n\t}\n//\tprintf(\"Components %d\\n\", c);\n\tif (works) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n, h;\n\nint f(int d, int u){\n\treturn d?(h+d):u;\n}\n\nint g(int d, int u){\n\treturn d?d:(h+u);\n}\n\nint out[810];\nint in[810];\n\nvoid In(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1; i<=n; ++i){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x = f(c, c+a);\n\t\tint y = g(d, d+b);\n\t\tout[x]++; in[y]++;\n\t}\n}\n\nbool check(){\n\tbool e = 0;\n\tfor(int i=1; i<=2*h-1; ++i){\n\t\tif(out[i] > in[i]){\n\t\t\tif(i > h) return 0;\n\t\t\te = 1;\n\t\t}\n\t\tif(out[i] < in[i]){\n\t\t\tif(i <= h) return 0;\n\t\t}\n\t}\n\treturn e;\n}\n\nint main()\n{\n\tIn();\n\tputs(check()?\"YES\":\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 100003;\nstatic const int MAXH = 209;\n\nstatic const int MAXV = MAXH * 2;\nstatic const int MAXE = 1e6 + 10;\n\nint n, h;\nint head[MAXV], dest[MAXE], next[MAXE];\nbool vis[MAXE] = { false };\n\nint m = 0;\nint in[MAXV] = { 0 }, out[MAXV] = { 0 };\n\ninline void add_edge(int u, int v)\n{\n    dest[m] = v; next[m] = head[u]; head[u] = m++;\n    ++out[u], ++in[v];\n}\n\nvoid dfs(int u)\n{\n    for (int w = head[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs(dest[w]);\n    }\n}\n\nstd::vector<int> as, bs;\nbool marked[MAXV] = { false };\n\nint main()\n{\n    scanf(\"%d%d\", &n, &h);\n\n    int verts = (h + 1) * 2;\n    for (int i = 0; i < verts; ++i) head[i] = -1;\n\n#define node_a(_h) ((_h) * 2)\n#define node_b(_h) ((_h) * 2 + 1)\n    for (int i = 0, a, b, c, d; i < n; ++i) {\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        int u, v;\n        u = (c == 0 ? node_b(a) : node_a(c));\n        v = (d == 0 ? node_a(b) : node_b(d));\n        add_edge(u, v);\n    }\n    for (int i = 0; i <= h; ++i) {\n        if (in[node_a(i)] < out[node_a(i)]) { puts(\"NO\"); return 0; }\n        if (in[node_b(i)] > out[node_b(i)]) { puts(\"NO\"); return 0; }\n        for (int r = 0; r < in[node_a(i)] - out[node_a(i)]; ++r) {\n            as.push_back(node_a(i));\n            marked[node_a(i)] = true;\n        }\n        for (int r = 0; r < out[node_b(i)] - in[node_b(i)]; ++r) {\n            bs.push_back(node_b(i));\n            marked[node_b(i)] = true;\n        }\n    }\n    for (int u : as) {\n        if (bs.empty()) { puts(\"NO\"); return 0; }\n        add_edge(u, bs.back());\n        bs.pop_back();\n    }\n\n    for (int i = 1; i < verts; i += 2) if (marked[i]) dfs(i);\n    for (int i = 0; i < m; ++i) if (!vis[i]) { puts(\"NO\"); return 0; }\n    puts(\"YES\"); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nnamespace io\n{\n\tconst int N=1<<20;\n\tchar buf[N],*t1=buf,*t2=buf;\n\t#ifdef cjy\n\t#define getc() getchar()\n\t#else\n\t#define getc() t1==t2&&(t2=(t1=buf)+fread(buf,1,N,stdin),t1==t2)?EOF:*t1++\n\t#endif\n\tinline int read()\n\t{\n\t\tstatic int an,f;an=0,f=1;\n\t\tstatic char ch;ch=getc();\n\t\twhile(ch<48||ch>57)ch=='-'?f=-1:0,ch=getc();\n\t\twhile(ch>=48&&ch<=57)an=(an<<3)+(an<<1)+(ch^48),ch=getc();\n\t\treturn an*f;\n\t}\n\tchar buff[N],*T=buff;\n\tvoid flush(){fwrite(buff,1,T-buff,stdout);T=buff;}\n\tinline void putc(char ch){if(T==buff+N)flush();*T++=ch;}\n\ttemplate<typename o>\n\tinline void print(o x)\n\t{\n\t\tif(x<0)putc('-'),x=-x;\n\t\tif(!x)return putc('0'),void();\n\t\tstatic int st[20],tp;\n\t\twhile(x)st[++tp]=x%10,x/=10;\n\t\twhile(tp)putc(st[tp]^48),--tp;\n\t}\n}\nusing io::read;\nusing io::putc;\nusing io::flush;\nusing io::print;\nstruct edge\n{\n\tint nxt,to;\n}e[100010];\nint n,h,head[500],num,dg[500];\ninline void add(int from,int to){e[++num]=edge{head[from],to};head[from]=num;++dg[from],--dg[to];}\nbool vis[500];\nint main()\n{\n\tn=read(),h=read();\n\tfor(int i=1,a,b,c,d,x,y;i<=n;++i)\n\t{\n\t\ta=read(),b=read(),c=read(),d=read();\n\t\tif(c==0)x=a;\n\t\telse x=c+h;\n\t\tif(d==0)y=b+h;\n\t\telse y=d;\n\t\tadd(x,y);\n\t}\n\tfor(int i=1;i<=h;++i)if(dg[i]<0)return printf(\"NO\"),0;\n\tfor(int i=h+1;i<=2*h;++i)if(dg[i]>0)return printf(\"NO\"),0;\n\tqueue<int>q;\n\tfor(int i=1;i<=h;++i)if(dg[i]>0)q.push(i);\n\tint cnt=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t//\tprintf(\"%d\\n\",x);\n\t\tif(vis[x])continue;\n\t\tvis[x]=1;\n\t\tfor(int i=head[x],y;i;i=e[i].nxt)y=e[i].to,++cnt,q.push(y);\n\t}\n\tif(cnt==n)printf(\"YES\");\n\telse printf(\"NO\");\n\tflush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[50000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]&&c[j][4]==0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nconst int MH = 405;\n\nint N, H, deg[MH];\nstd::vector<int> G[MH];\n\nint ok, vis[MH];\nvoid DFS(int u) {\n\tvis[u] = 1;\n\tif (deg[u]) ok = 1;\n\tfor (int v : G[u]) if (!vis[v]) DFS(v);\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &H);\n\tfor (int i = 1; i <= N; ++i) {\n\t\tint a, b, c, d, x, y;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tif (!c) x = a;\n\t\telse x = c + H;\n\t\tif (!d) y = b + H;\n\t\telse y = d;\n\t\t++deg[x], --deg[y];\n\t\tG[x].push_back(y), G[y].push_back(x);\n\t}\n\tfor (int i = 1; i <= H; ++i)\n\t\tif (deg[i] < 0 || deg[i + H] > 0) return puts(\"NO\"), 0;\n\tfor (int i = 1; i <= 2 * H; ++i) if (!G[i].empty() && !vis[i]) {\n\t\tok = 0, DFS(i);\n\t\tif (!ok) return puts(\"NO\"), 0;\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\nusing namespace std;\nconst int N=405;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nint n,h,fa[N],in[N],ot[N];\nbool flag[N];\nint gf(int x){return fa[x]==x?x:fa[x]=gf(fa[x]);}\nint main(){\n\tn=read(),h=read()*2;\n\tinc(i,1,h) fa[i]=i; \n\tinc(i,1,n){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint l=c?c+(h>>1):a,r=d?d:b+(h>>1);\n\t\tot[l]++,in[r]++;\n\t\tl=gf(l),r=gf(r);\n\t\tif(l!=r) fa[l]=r;\n\t}\n\tinc(i,1,(h>>1)) if(in[i]>ot[i]) return puts(\"NO\"),0;\n\tinc(i,(h>>1)+1,h) if(ot[i]>in[i]) return puts(\"NO\"),0;\n\tinc(i,1,h) if(in[i]!=ot[i]||!in[i]&&!ot[i]) flag[gf(i)]=1;\n\tinc(i,1,h) if(fa[i]==i&&!flag[i]) return puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<functional>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4);\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way,vel &con) {\n\tint n = way.size();\n\tvel dist(n,-1);\n\tdist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front();\n\t\tq.pop();\n\t\tcon.push_back(st);\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nint gr(int now, vvel &chi) {\n\tint ret = 0;\n\tfor(auto to:chi[now]) {\n\t\tret = ret xor (gr(to, chi) + 1);\n\t}\n\treturn ret;\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\tvvel way(2 * h);\n\tvvel inv_way(2 * h);\n\tvvel all_way(2 * h);\n\tveb is_use(2 * h, false);\n\trep(i, n) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint st, to;\n\t\tif (c == 0) { st = a; }\n\t\telse { st = c + h; }\n\t\tif (d == 0) { to = b + h; }\n\t\telse { to = d; }\n\t\tway[st].push_back(to);\n\t\tinv_way[to].push_back(st);\n\t\tall_way[st].push_back(to);\n\t\tall_way[to].push_back(st);\n\t\tis_use[st] = true;\n\t\tis_use[to] = true;\n\t}\n\trep(i, h) {\n\t\tif (way[i].size() < inv_way[i].size()) { cout << \"NO\" << endl; return 0; }\n\t\tif (way[i + h].size() > inv_way[i + h].size()) { cout << \"NO\" << endl; return 0; }\n\t}\n\tveb is_checked(2 * h, false);\n\trep(i, 2 * h) {\n\t\tif (!is_checked[i]) {\n\t\t\tvel con = {};\n\t\t\tdis(i, all_way, con);\n\t\t\tif (con.size() == 1) {\n\t\t\t\tif (is_use[i]) { cout << \"NO\" << endl; return 0; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool fl = false;\n\t\t\t\tfor (auto pl : con) {\n\t\t\t\t\tif (pl<h and way[pl].size() > inv_way[pl].size()) { fl = true; }\n\t\t\t\t}\n\t\t\t\tif (!fl) { cout << \"NO\" << endl; }\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MX=411, inf=2e9;\n\nint n, h;\n\nint indeg[MX], outdeg[MX];\n\nint U[MX];\nint find(int x){\n    return x==U[x] ? x : U[x]=find(U[x]);\n}\nvoid unite(int x, int y){\n    U[find(y)]=find(x);\n}\n\nbool solve(){\n    bool st[MX]={}, ed[MX]={};\n    for(int i=1; i<=h; i++){\n        if(indeg[i]<outdeg[i]) return false;\n        if(indeg[i]==outdeg[i]) continue;\n        ed[find(i)]=true;\n    }\n    for(int i=h+1; i<=2*h; i++){\n        if(indeg[i]>outdeg[i]) return false;\n        if(indeg[i]==outdeg[i]) continue;\n        st[find(i)]=true;\n    }\n    for(int i=1; i<=2*h; i++){\n        if(indeg[i]==0 && outdeg[i]==0) continue;\n        int x=find(i);\n        if(!st[x] || !ed[x]) return false;\n    }\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin>>n>>h; h++;\n    iota(U, U+2*h+1, 0);\n    for(int i=1; i<=n; i++){\n        int a, b, c, d; cin>>a>>b>>c>>d;\n        int x = (c==0 ? h+a : c), y = (d==0 ? b : h+d);\n        unite(x, y);\n        outdeg[x]++, indeg[y]++;\n    }\n    cout<<(solve() ? \"YES\" : \"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//AtCoder Grand Contest 017 E - Jigsaw\n\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint qr(){int ret = 0,f=1;char ch =getchar();while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();return ret*f;}\n\n#define maxN 100005\n#define maxH 205\n\nint indegree[maxH<<2],outdegree[maxH<<2];\nint active[maxH<<2];\nvoid read(int x,int y){\n    indegree[y]++;\n    outdegree[x]++;\n}\nint f[maxH<<1],pd[maxH<<1];\nvoid init(){\n    for(int i = 0;i<=(maxH<<1);i++)\n        f[i] = i;\n}\nint gf(int x){\n    if(f[x] == x) return x;\n    else return f[x] = gf(f[x]);\n}\nint mer(int x,int y){\n    x = gf(x);y = gf(y);\n    if(x == y) return 0;\n    f[x] = y;\n    return 1;\n}\nint main(){\n    init();\n    int N = qr(),H = qr();\n    int t1,t2,t3,t4,t5,t6;//上 t + maxN 下 t + maxN + maxH\n    for(int i = 1;i<=N;i++){\n        t1 = qr(),t2 = qr(),t3 = qr(),t4 = qr();\n        if(!t3) t5 = t1;else t5 = -t3;\n        if(!t4) t6 = -t2;else t6 = t4;\n        t5 += H,t6 += H;\n        indegree[t6]++;outdegree[t5]++;\n        active[t5] = active[t6] = 1;\n        f[gf(t5)] = gf(t6);\n    }\n    int mark=1;\n    for(int i = 0;i<=H;i++){\n        if(indegree[i]<outdegree[i])\n            mark=0;\n    }\n    for(int i = H+1;i<=(H<<1);++i){\n        if(indegree[H+i]>outdegree[H+i])\n            mark=0;\n    }\n    for(int i = 0;i<=(H<<1);i++){\n        pd[gf(i)] |= (indegree[i] != outdegree[i]);\n    }\n    pd[H] = 1;\n    for(int i = 1;i<=(H<<1);i++){\n        if(active[i] && !pd[gf(i)])\n            mark=0;\n    }\n    if(mark)\n        cout << \"YES\";\n    else cout << \"NO\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n, h, c1[MAXN], c0[MAXN];\nbool vis[MAXN];\nvector<int> adj[MAXN];\nbool found = 0;\n\nvoid dfs(int v){\n\tvis[v] = 1;\n\tif (c0[v] ^ c1[v]) found = 1;\n\tif ((v > h && c1[v] > c0[v]) || (v <= h && c0[v] > c1[v])){\n\t\tcout << \"NO\\n\";\n\t\texit(0);\n\t}\n\tfor (int u:adj[v])\n\t\tif (!vis[u])\n\t\t\tdfs(u);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> h;\n\twhile (n--){\n\t\tint a, b, c, d; cin >> a >> b >> c >> d;\n\t\tint u = -1, v = -1;\n\t\tif (c == 0)\n\t\t\tu = a;\n\t\telse\n\t\t\tu = h+c;\n\t\tif (d)\n\t\t\tv = d;\n\t\telse\n\t\t\tv = h+b;\n\t\tadj[u].push_back(v);\n\t\tc1[u]++;\n\t\tadj[v].push_back(u);\n\t\tc0[v]++;\n\t}\n\tfor (int i = 1; i <= h+h; i++)\n\t\tif (!vis[i] && adj[i].size()){\n\t\t\tfound = 0;\n\t\t\tdfs(i);\n\t\t\tif (!found){\n\t\t\t\tcout << \"NO\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 432;\n\nint n, H, V;\nint p[N], in[N], out[N];\nbool dicyc[N];\n\nint ancestor(int x) {return p[x] == x ? x : (p[x] = ancestor(p[x]));}\n\nint main() {\n\tint i, Lu, Ld, Ru, Rd, L, R;\n\tscanf(\"%d%d\", &n, &H), V = 2 * H;\n\tstd::iota(p, p + V, 0);\n\tfor (i = 1; i <= n; ++i)\n\t\tscanf(\"%d%d%d%d\", &Lu, &Ru, &Ld, &Rd),\n\t\t++out[L = (Ld ? Ld + H : Lu) - 1], ++in[R = (Rd ? Rd : Ru + H) - 1],\n\t\tp[ancestor(L)] = ancestor(R);\n\tfor (i = 0; i < H && in[i] <= out[i] && in[i + H] >= out[i + H]; ++i);\n\tif (i != H) return puts(\"NO\"), 0;\n\tfor (i = 0; i < V; ++i) dicyc[ancestor(i)] |= in[i] != out[i] || !in[i];\n\tfor (i = 0; i < V && (p[i] != i || dicyc[i]); ++i);\n\treturn puts(i == V ? \"YES\" : \"NO\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=10200,M=5000;\ninline int read(int x=0,bool f=0,char ch=getchar()){\n\tfor(;!isdigit(ch);ch=getchar()) f=ch=='-';\n\tfor(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\nint n,h;\nint f[N],*fa=f+5000,o[N],*outdu=o+M;\nint in[N],*indu=in+M,sz[N],*siz=sz+M;\nint c[N],*cnt=c+M;\nbool v[N],*vis=v+M;\ninline int get(int x){\n\treturn fa[x]==x?x:fa[x]=get(fa[x]);\n}\nint main(){\n\tn=read(),h=read();\n\tfor(int i=-h;i<=h;++i) fa[i]=i,siz[i]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint x=c?c:-a,y=d?-d:b;\n\t\tindu[y]++; outdu[x]++;\n\t\tif(get(x)!=get(y)) fa[fa[x]]=fa[y],siz[fa[y]]+=siz[fa[x]];\n\t\tcnt[get(y)]++;\n\t}\n\tbool f=0;\n\tfor(int i=1;i<=h;++i) if(outdu[i]>indu[i]) f=1;\n\tfor(int i=-h;i;++i) if(indu[i]>outdu[i]) f=1;\n\tfor(int i=-h;i<=h;++i) if(cnt[get(i)]&&indu[i]!=outdu[i]) vis[get(i)]=true;\n\tfor(int i=-h;i<=h;++i) if(get(i)==i&&!vis[i]&&cnt[i]) f=1;\n\tputs(f?\"NO\":\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#define eps 1e-10\n#define inf 1e9\n#define For(i,j,k)\tfor(int i=j;i<=k;++i)\n#define Dow(i,j,k)\tfor(int i=k;i>=j;--i)\n#define ll long long\n#define y1 orz\nusing namespace std;\ninline ll read()\n{\n\tll t=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9')\t{if(c=='-')\tf=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')\tt=t*10+c-48,c=getchar();\n\treturn t*f;\n}\nint n,h,F[501],deg[501],hav[501],is_father[501];\ninline int get(int x){return x==F[x]?F[x]:F[x]=get(F[x]);}\nint x,y,x1,y1,tx,ty;\nint main()\n{\n\tn=read();h=read();\n\tFor(i,1,400)\tF[i]=i;\n\tFor(i,1,n)\t\n\t{\n\t\tx=read();y=read();x1=read();y1=read();\n\t\tif(x1==0)\ttx=x;else tx=-x1;\n\t\tif(y1==0)\tty=-y;else ty=y1;\n\t\ttx+=200;ty+=200;\n\t\tdeg[tx]++;deg[ty]--;hav[tx]=1;\n//\t\tcout<<tx<<' '<<ty<<endl;\n\t\tF[get(tx)]=get(ty);\n\t}\n\tFor(i,201,400)\tif(deg[i]<0)\t{puts(\"NO\");return 0;}\t\t\n\tFor(i,1,200)\tif(deg[i]>0)\t{puts(\"NO\");return 0;}\n\tFor(i,1,400)\t\n\t\thav[get(i)]|=hav[i];\n\tFor(i,1,400)\n\t\tif(deg[get(i)])is_father[get(i)]=1;\n\tFor(i,1,400)\t\n\t\tif(hav[i])\n\t\t\tif(F[i]==i&&!is_father[i])\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define MP make_pair\n#define MT make_tuple\n#define EACH(i,c) for(auto i: c)\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, H;\n\tcin >> N >> H;\n\n\tmap<int, int> lA, lC, rB, rD, lArD, rBlC;\n\tint x = 0, y = 0;\n\tREP(i, N){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif(c == 0){\n\t\t\tlA[a]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\tlC[c]++;\n\t\t\ty++;\n\t\t}\n\t\tif(d == 0){\n\t\t\trB[b]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\trD[d]++;\n\t\t\ty++;\n\t\t}\n\n\t\tif(c == 0 && a == d) lArD[a]++;\n\t\tif(d == 0 && b == c) rBlC[b]++;\n\t}\n\n\tif(y + 2 > x){\n\t\tcerr << x << \" \" << y << endl;\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\n\tEACH(pc, lC){\n\t\tif(rB[pc.first] < pc.second - rBlC[pc.first]){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEACH(pd, rD){\n\t\tif(lA[pd.first] < pd.second - lArD[pd.first]){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\tcout << \"YES\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define N 200010\nusing namespace std;\n\nstruct aa{int a, b, c, d;}a[N];\nint n, H, l, flag[N], size[4], x, y;\nvector<int>son[5][210];\n\ninline int check(int i, int j){\n\twhile(son[i][j].size()&&flag[son[i][j][son[i][j].size()-1]])son[i][j].pop_back();\n\tif(!son[i][j].size())return 0;\n\treturn son[i][j][son[i][j].size()-1];\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &H);\n\tfor(int i=0; i<=4; i++)for(int j=0; j<=H; j++)son[i][j].clear();\n\tfor(int i=0; i<=3; i++)size[i]=0;\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%d%d%d%d\", &a[i].a, &a[i].b, &a[i].c, &a[i].d);\n\t\tif(!a[i].c&&!a[i].d){\n\t\t\tsize[0]++;\n\t\t\tson[0][a[i].a].push_back(i); son[1][a[i].b].push_back(i);\n\t\t}\n\t\tif(!a[i].c&&a[i].d){size[1]++; son[2][a[i].a].push_back(i);}\n\t\tif(a[i].c&&!a[i].d){size[2]++; son[3][a[i].b].push_back(i);}\n\t\tif(a[i].c&&a[i].d){size[3]++; son[4][0].push_back(i);}\n\t}\n\tl=n; memset(flag, 0, sizeof(flag));\n\twhile(size[1]+size[2]+size[3]){\n\t\tif(size[3]){\n\t\t\tx=check(4, 0); flag[x]=1; y=check(3, a[x].c);\n\t\t\tif(y){\n\t\t\t\tsize[3]--; size[2]--; flag[y]=1;\n\t\t\t\tl++; a[l].c=a[y].c; a[l].d=a[x].d;\n\t\t\t\tsize[3]++; son[4][0].push_back(l);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ty=check(1, a[x].c);\n\t\t\tif(y){\n\t\t\t\tsize[3]--; size[0]--; flag[y]=1;\n\t\t\t\tl++; a[l].a=a[y].a; a[l].d=a[x].d;\n\t\t\t\tsize[1]++; son[2][a[l].a].push_back(l);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintf(\"NO\"); return 0;\n\t\t}\n\t\tif(size[2]){\n\t\t\tfor(int i=1; i<=H; i++){\n\t\t\t\tx=check(3, i); if(!x)continue;\n\t\t\t\tflag[x]=1; y=check(3, a[x].c);\n\t\t\t\tif(y){\n\t\t\t\t\tsize[2]--; size[2]--; flag[y]=1;\n\t\t\t\t\tl++; a[l].c=a[y].c; a[l].b=a[x].b;\n\t\t\t\t\tsize[2]++; son[3][a[l].b].push_back(l);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ty=check(1, a[x].c);\n\t\t\t\tif(y){\n\t\t\t\t\tsize[2]--; size[0]--; flag[y]=1;\n\t\t\t\t\tl++; a[l].a=a[y].a; a[l].b=a[x].b;\n\t\t\t\t\tsize[0]++; son[0][a[l].a].push_back(l); son[1][a[l].b].push_back(l);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"NO\"); return 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(size[1]){\n\t\t\tfor(int i=1; i<=H; i++){\n\t\t\t\tx=check(2, i); if(!x)continue;\n\t\t\t\tflag[x]=1; y=check(2, a[x].d);\n\t\t\t\tif(y){\n\t\t\t\t\tsize[1]--; size[1]--; flag[y]=1;\n\t\t\t\t\tl++; a[l].a=a[x].a; a[l].d=a[y].d;\n\t\t\t\t\tsize[1]++; son[2][a[l].a].push_back(l);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ty=check(0, a[x].d);\n\t\t\t\tif(y){\n\t\t\t\t\tsize[1]--; size[0]--; flag[y]=1;\n\t\t\t\t\tl++; a[l].a=a[x].a; a[l].b=a[y].b;\n\t\t\t\t\tsize[0]++; son[0][a[l].a].push_back(l); son[1][a[l].b].push_back(l);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"NO\"); return 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nconst int MAX_V = 420;\nconst int Base = MAX_V / 2;\n\nvector<int> es[MAX_V];\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n\n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n\n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n\n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n    bool check(int v, int W) {\n    \treturn cmp[W] == cmp[v];\n    }\n};\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\tvi a(n), b(n), c(n), d(n);\n\trep(i, n) cin >> a[i] >> b[i] >> c[i] >> d[i];\n\tvi l(n), r(n);\n\trep(i, n) {\n\t\tl[i] = (c[i] == 0 ? a[i] : -c[i]);\n\t\tr[i] = (d[i] == 0 ? b[i] : -d[i]);\n\t}\n\tset<int> st;\n\trep(i, n) {\n\t\tint frm = (l[i] > 0 ? l[i] : Base - l[i]);\n\t\tint to = (r[i] > 0 ? Base + r[i] : -r[i]);\n\t\tst.insert(frm);\n\t\tst.insert(to);\n\t\tif(frm == to) continue;\n\t\tes[frm].pb(to);\n\t}\n\tint W = MAX_V-1;\n\tvector<int> in(MAX_V), out(MAX_V);\n\tSCC g(MAX_V);\n\trep(i, MAX_V) {\n\t\tsort(all(es[i]));\n\t\t//es[i].erase(unique(all(es[i])), es[i].end());\n\t\tint prv = -1;\n\t\tfor(auto& to : es[i]) {\n\t\t\tif(prv != to) g.add_edge(i, to);\n\t\t\tprv = to;\n\t\t\tin[to]++;\n\t\t}\n\t\tout[i] = es[i].size();\n\t}\n\tbool f = true;\n\trep(i, MAX_V) {\n\t\tif(i >= Base) {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] < out[i]) f = false;\n\t\t\telse g.add_edge(i, W);\n\t\t}\n\t\telse {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] > out[i]) f = false;\n\t\t\telse g.add_edge(W, i);\n\t\t}\n\t}\n\tg.scc();\n\tfor(auto& v : st) if(!g.check(v, W)) f = false;\n\tcout << (f?\"YES\":\"NO\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long  int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v])parent[u] = v;\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<vector<int>>uu(201, vector<int>(201));\n\tvector<vector<int>>us(201, vector<int>(201));\n\tvector<vector<int>>su(201, vector<int>(201));\n\tvector<vector<int>>ss(201, vector<int>(201));\n\tfor (int i = 0; i < N; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif (c&&d) {\n\t\t\tuu[c][d]++;\n\t\t}\n\t\telse if (c) {\n\t\t\tus[c][b]++;\n\t\t}\n\t\telse if (d) {\n\t\t\tsu[a][d]++;\n\t\t}\n\t\telse {\n\t\t\tss[a][b]++;\n\t\t}\n\t}\n\t//for (int i = 1; i <= 200; i++) {\n\t//\tus[i][i] = min(us[i][i], 1);\n\t//\tsu[i][i] = min(su[i][i], 1);\n\t//}\n\tvector<int>lu(201);\n\tvector<int>ld(201);\n\tvector<int>ru(201);\n\tvector<int>rd(201);\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tlu[i] += uu[i][j];\n\t\t\tlu[i] += us[i][j];\n\t\t\tld[i] += su[i][j];\n\t\t\tld[i] += ss[i][j];\n\t\t\tru[j] += uu[i][j];\n\t\t\tru[j] += su[i][j];\n\t\t\trd[j] += ss[i][j];\n\t\t\trd[j] += us[i][j];\n\t\t}\n\t\tld[i] -= su[i][i];\n\t\trd[i] -= us[i][i];\n\t}\n\tUnionFind uf(5000);\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tif (uu[i][j])uf.Unite(i, j);\n\t\t\tif (us[i][j])uf.Unite(i, j + 1000);\n\t\t\tif (su[i][j])uf.Unite(i + 1000, j);\n\t\t\tif (ss[i][j])uf.Unite(i + 1000, j + 1000);\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tif (ru[i] > ld[i]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif(ru[i]<ld[i])uf.Unite(2000, i + 1000);\n\t\tif (lu[i] > rd[i]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif(lu[i]<rd[i])uf.Unite(2000, i + 1000);\n\t}\n\tfor (int i = 0; i <= 200; i++) {\n\t\tif ((lu[i] || ru[i]) && !uf.Check_Same(i, 2000)) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif ((ld[i] || rd[i]) && !uf.Check_Same(i+1000, 2000)) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e5 + 10;\n\nconst int ZERO = 404;\nconst int SZ = ZERO * 2;\nvi g[N];\nvi rg[N];\nint used[N];\n\nint cnt_op;\nint cnt_cl;\nbool wrong;\n\nvoid dfs_con(int v) {\n    used[v] = true;\n    if (g[v].size() < rg[v].size()) {\n        cnt_op++;\n        if (v >= ZERO)\n            wrong = true;\n    } else if (g[v].size() > rg[v].size()) {\n        cnt_cl++;\n        if (v < ZERO)\n            wrong = true;\n    }\n    for (int to : g[v]) {\n        if (!used[to])\n            dfs_con(to);\n    }\n    for (int to : rg[v]) {\n        if(!used[to])\n            dfs_con(to);\n    }\n}\n\n\nvoid smain() {\n\n    int n, h;\n    cin >> n >> h;\n    fori (i, n) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int u;\n        if (c > 0) {\n            u = c;\n        } else {\n            u = ZERO + a;\n        }\n        int v;\n        if (d > 0) {\n            v = d + ZERO;\n        } else {\n            v = b;\n        }\n//        cerr << \"(\" << u << \", \" << v << \")\" << endl;\n        g[u].push_back(v);\n        rg[v].push_back(u);\n    }\n\n    for (int v = 0; v <= SZ; ++v) {\n        if (used[v])\n            continue;\n        cnt_op = 0;\n        cnt_cl = 0;\n        wrong = false;\n        dfs_con(v);\n        if (cnt_cl != cnt_op || wrong) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h+b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\tif (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tRep1(i,h+1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\tif (s != e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n//    int dx[8]={0,1,0,-1,1,1,-1,-1};\n  //  int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==0)return b;\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n} \n                                \n                int pr[200010];\n                int inv[200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tinv[ert]=beki(pr[ert],mod-2,mod);\n                \t\n                \tfor(int i=ert-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    //mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\t   \n       \n                               //----------------kokomade tenpure------------\n\nstruct unionfind{\n\tprivate:\n\tpublic:\n\t\nvector<int> par,ranks,kosuu;\n\t\n\tvoid shoki(int N){\n\t\tpar.resize(N+1,0);\n\t\tranks.resize(N+1,0);\n\t\tkosuu.resize(N+1,1);\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t}\n\n\tint root(int x){\n\t\treturn par[x]==x ? x : par[x]=root(par[x]);\n\t}\n\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n\tbool is_root(int x){\n\t\treturn x==root(x);\n\t}\n\tvoid unite(int x,int y){\n \t\tx=root(x);\n\t \ty=root(y);\n\t\tint xx=kosuu[x],yy=kosuu[y];\n\t \tif(x==y) return;\n\t\tif(ranks[x]<ranks[y]){\n\t\t\tpar[x]=y;\n\t\t\tkosuu[y]=yy+xx;\n\t\t}\n\t \telse {\n\t\t\tpar[y]=x;\n\t\t\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n\t \t\tkosuu[x]=yy+xx;\n\t \t}\n\t\treturn;\n\t}\n};\n\nvector<int> G[600];\n\t\nint shu[600]={};\nunionfind uf;\nint nyu[600]={};\n\nint aru[600]={};\n\nvector<int> ve[600];\n\n\n\nvoid ch(int r){\n\tif(ve[r].size()==1){\n\t\tif(aru[ve[r][0]]){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\texit(0);\n\t\t}\n\t\treturn ;\n\t}\n\tint ss=0,gg=0;\n\tfor(auto v:ve[r]){\n\t\tif(v<300)ss++;\n\t\telse gg++;\n\t}\n\tif(ss==0 || gg==0){\n\t\tcout<<\"NO\"<<endl;\n\t\texit(0);\n\t}\n\tss=0;\n\tgg=0;\n\tint we=0;\n\tfor(auto s:ve[r])for(auto g:G[s]){\n\t\tif(s<300 && g<300) continue;\n\t\tif(s>300 && g>300) continue;\n\t\tif(s<300 && g>300) ss++,gg++,we++;\n\t\telse ss--,gg--,we--;\n\t}\n}\n\n\nsigned main(){\n\n\t\t  cin.tie(0);\n\tios::sync_with_stdio(false);\n\nint n,h;\n\tuf.shoki(600);\n\tcin>>n>>h;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tint lef,rig;\n\t\tif(c){\n\t\t\tlef=300+c;\n\t\t}\n\t\telse lef=a;\n\t\tif(d){\n\t\t\trig=d;\n\t\t}\n\t\telse rig=b+300;\n\t\tshu[lef]++;\n\t\tnyu[rig]++;\n\t\tuf.unite(lef,rig);\n\t//\tcout<<lef<<\" \"<<rig<<endl;\n\t\tG[lef].pb(rig);\n\t\tif(lef==rig)aru[lef]=1;\n\t}\n\t\n\tfor(int i=0;i<300;i++){\n\t\tif(shu[i]-nyu[i]<0){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor(int i=300;i<600;i++){\n\t\tif(shu[i]-nyu[i]>0){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t\n\tfor(int i=0;i<600;i++)ve[uf.root(i)].pb(i);\n\t\n\tfor(int i=0;i<600;i++)if(ve[i].size())ch(i);\n\t\n\tcout<<\"YES\"<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\nint c[201][2];\nint e[201][2];\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tbool f = false;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\tc[b[i].c][0]++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].a][0]++;\n\t\t}\n\t\tif (b[i].d > 0) {\n\t\t\tc[b[i].d][1]++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].b][1]++;\n\t\t}\n\t\tif (b[i].c == 0 && b[i].d == 0) {\n\t\t\tf = true;\n\t\t}\n\t}\n\tif (!f) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\trep(i, 201) {\n\t\trep(j, 2) {\n\t\t\tif (c[i][j] > e[i][j^1]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst llint mod=1000000007;\nconst llint big=1e17-10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint main(void){\n\tint n,h,i,j;cin>>n>>h;\n\tint Lsit[201]={0};//左が下にくっついている\n\tint Rsit[201]={0};//右が\n\tfor(i=0;i<n;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tif(c==0){Lsit[a]++;}else{Rsit[c]--;}\n\t\tif(d==0){Rsit[b]++;}else{Lsit[d]--;}\n\t}\n\tint gen=0;\n\tfor(i=1;i<201;i++){gen+=Rsit[i];if(Rsit[i]<0){cout<<\"NO\"<<endl;return 0;}}\n\tif(gen==0){cout<<\"NO\"<<endl;return 0;}\n\tfor(i=1;i<201;i++){gen+=Lsit[i];if(Lsit[i]<0){cout<<\"NO\"<<endl;return 0;}}\n\tif(gen==0){cout<<\"NO\"<<endl;return 0;}\n\tcout<<\"YES\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n/*\n * Union-Find tree\n * header requirement: vector\n */\nclass UnionFind {\nprivate:\n  std::vector<int> disj;\n  std::vector<int> rank;\npublic:\n  UnionFind(int n) : disj(n), rank(n) {\n    for (int i = 0; i < n; ++i) {\n      disj[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int root(int x) {\n    if (disj[x] == x) {\n      return x;\n    }\n    return disj[x] = root(disj[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (rank[x] < rank[y]) {\n      disj[x] = y;\n    } else {\n      disj[y] = x;\n      if (rank[x] == rank[y]) {\n\t++rank[x];\n      }\n    }\n  }\n  bool is_same_set(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\n\nconst int H = 210;\n\nint in[H], out[H], inc[H], outc[H];\n\nint main(void){\n  int n, h;\n  cin >> n >> h;\n  set<int> app;\n  UnionFind uf(2 * H);\n  REP(i, 0, n) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    int u, v;\n    if (c == 0) {\n      in[a] += 1;\n      app.insert(u = a);\n    } else {\n      inc[c] += 1;\n      app.insert(u = c + H);\n    }\n    if (d == 0) {\n      out[b] += 1;\n      app.insert(v = b + H);\n    } else {\n      outc[d] += 1;\n      app.insert(v = d);\n    }\n    uf.unite(u, v);\n  }\n  set<int> roots;\n  for (set<int>::iterator it = app.begin(); it != app.end(); ++it) {\n    roots.insert(uf.root(*it));\n  }\n  bool ok = true;\n  int ncc = roots.size();\n  int cnt = 0;\n  REP(i, 0, h + 1) {\n    if (1) {\n      cerr << i << \":\";\n      cerr << \"in=\" << in[i] << \", out=\" << out[i];\n      cerr << \"inc=\" << inc[i] << \", outc=\" << outc[i];\n      cerr << endl;\n    }\n    if (in[i] != outc[i]) {\n      cnt += 1;\n      if (in[i] < outc[i]) {\n\tok = false;\n      }\n    }\n    if (out[i] != inc[i]) {\n      cnt += 1;\n      if (out[i] < inc[i]) {\n\tok = false;\n      }\n    }\n  }\n  assert (cnt % 2 == 0);\n  ok &= cnt >= 2 * ncc;\n  cout << (ok ? \"YES\" : \"NO\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\nint h;\n\n#define MAXX 202\nint lef[MAXX];\nint rig[MAXX];\n\nint deg[MAXX*2];\n\nvector<int> v[MAXX*2];\n\nint belong[MAXX * 2];\ninline int root(int b){\n\tif (belong[b] == -1){\n\t\treturn b;\n\n\t}\n\tbelong[b] = root(belong[b]);\n\treturn belong[b];\n}\nvoid merge(int a, int b){\n\ta = root(a);\n\tb = root(b);\n\tif (a == b){\n\t\treturn;\n\t}\n\tbelong[a] = b;\n}\nmap<int, vector<int> > mp;\n\nbool ava[MAXX*2];\nbool flag[MAXX * 2];\n\nbool check(vector<int> vv){\n\tbool ng = false;\n\tint restr = 0;\n\tint restl = 0;\n\tint id = -1;\n\tint id2 = -1;\n\tbool ok = false;\n\tfor (int ii = 0; ii < vv.size(); ii++){\n\t\tok |= flag[vv[ii]];\n\t}\n\tif (ok == false){\n\t\treturn true;\n\t}\n\tfor (int ii = 0; ii <vv.size();ii++){\n\t\tint ix = vv[ii];\n\t\tif (ix & 1){\n\t\t\tint i = ix / 2;\n\t\t\tif (deg[rig[i]] >= 0){\n\t\t\t\trestr += deg[rig[i]];\n\t\t\t\tif (deg[rig[i]]){\n\t\t\t\t\tid = rig[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tng = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint i = ix / 2;\n\t\t\tif ( deg[lef[i]] <= 0){\n\t\t\t\trestl += -deg[lef[i]];\n\t\t\t\tif (deg[lef[i]] < 0){\n\t\t\t\t\tid2 = lef[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tng = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (restr == 0 || restl == 0){\n\t\treturn false;\n\t}\n\tif (ng){\n\t\treturn false;\n\t}\n\tif (restr == 1 && restl == 1 && v[id].size() == 1 && v[id2].size() == 1 && v[id][0] == v[id2][0]){\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main(){\n\tmemset(belong, -1, sizeof(belong));\n\tfor (int i = 0; i < MAXX; i++){\n\t\tlef[i] = 2 * i;\n\t\trig[i] = lef[i] + 1;\n\t}\n\tcin >> n >> h;\n\tfor (int i = 0; i < n; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint k;\n\t\tif (c){\n\t\t\tdeg[lef[c]]++;\n\t\t\tk = lef[c];\n\t\t\tava[lef[c]] = true;\n\t\t\tflag[lef[c]] = true;\n\t\t}\n\t\telse{\n\t\t\tdeg[rig[a]]++;\n\t\t\tv[rig[a]].push_back(i);\n\t\t\tk = rig[a];\n\t\t\tava[rig[a]] = true;\n\t\t}\n\t\tif (d){\n\t\t\tdeg[rig[d]]--;\n\t\t\tflag[rig[d]] = true;\n\t\t\tmerge(k, rig[d]);\n\t\t\tava[rig[d]] = true;\n\t\t}\n\t\telse{\n\t\t\tdeg[lef[b]]--;\n\t\t\tv[lef[b]].push_back(i);\n\t\t\tmerge(k, lef[b]);\n\t\t\tava[lef[b]] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < 2*MAXX; i++){\n\t\tif(ava[i])mp[root(i)].push_back(i);\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); it++){\n\t\tif (check((*it).second) == false){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<functional>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4);\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way,vel &con) {\n\tint n = way.size();\n\tvel dist(n,-1);\n\tdist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front();\n\t\tq.pop();\n\t\tcon.push_back(st);\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nint gr(int now, vvel &chi) {\n\tint ret = 0;\n\tfor(auto to:chi[now]) {\n\t\tret = ret xor (gr(to, chi) + 1);\n\t}\n\treturn ret;\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\th++;\n\tvvel way(2 * h);\n\tvvel inv_way(2 * h);\n\tvvel all_way(2 * h);\n\tveb is_use(2 * h, false);\n\trep(i, n) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint st, to;\n\t\tif (c == 0) { st = a; }\n\t\telse { st = c + h; }\n\t\tif (d == 0) { to = b + h; }\n\t\telse { to = d; }\n\t\tway[st].push_back(to);\n\t\tinv_way[to].push_back(st);\n\t\tall_way[st].push_back(to);\n\t\tall_way[to].push_back(st);\n\t\tis_use[st] = true;\n\t\tis_use[to] = true;\n\t}\n\trep(i, h) {\n\t\tif (way[i].size() < inv_way[i].size()) { cout << \"NO\" << endl; return 0; }\n\t\tif (way[i + h].size() > inv_way[i + h].size()) { cout << \"NO\" << endl; return 0; }\n\t}\n\tveb is_checked(2 * h, false);\n\trep(i, 2 * h) {\n\t\tif (!is_checked[i]) {\n\t\t\tvel con = {};\n\t\t\tdis(i, all_way, con);\n\t\t\tif (con.size() == 1) {\n\t\t\t\tif (is_use[i]) { cout << \"NO\" << endl; return 0; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool fl = false;\n\t\t\t\tfor (auto pl : con) {\n\t\t\t\t\tif (pl<h and way[pl].size() > inv_way[pl].size()) { fl = true; }\n\t\t\t\t}\n\t\t\t\tif (!fl) { cout << \"NO\" << endl; }\n\t\t\t}\n\t\t\tfor (auto ne : con) {\n\t\t\t\tis_checked[ne] = true;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,h;\n  int a[20][20];\n  cin>>n;\n  cin>>h;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<4;j++){\n    cin>>a[i][j];\n    }\n  }\n  int flag=0;\n  for(int k=0;k<n;k++){//对于每一块拼图进行分析\n    for(int l=0;l<n;l++){\n      if(a[k][2]==(a[l][1]+a[l][3])&&(l!=k)&&a[k][2]!=0)\n      {flag++;a[k][2]=100;a[k][0]=100;a[l][1]=100;a[l][3]=100;}//左右正常匹配\n\n\t  if(a[k][2]==0&&a[l][3]==0&&(l!=k)){flag++;a[k][0]=100;a[l][1]=100;a[k][2]=100;a[l][3]=100;}//左右挨底匹配\n\n      if(a[k][3]==(a[l][0]+a[l][2])&&(l!=k)&&a[k][3]!=0)\n      {flag++;a[k][1]=100;a[k][3]=100;a[l][0]=100;a[l][2]=100;}//右左正常匹配\n\n\t  if(a[k][3]==0&&a[l][2]==0&&(l!=k)){flag++;a[k][1]=100;a[l][2]=100;a[k][3]=100;a[l][0]=100;}//右左挨底匹配\n    }\n  }\n //cout<<flag<<endl;\n if(flag>=n-1)\n {cout<<\"YES\"<<endl;}\n else{cout<<\"NO\"<<endl;}\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 210;\nvoid bye() { std::cout << \"NO\" << std::endl; exit(0); }\nint ind[MAXN], oud[MAXN], fa[MAXN], idx;\nint p[210][2], hav[MAXN];\nint n, H;\nint find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\nint newnode() { ++idx; fa[idx] = idx; return idx; }\nint get(int x, int b) { return p[x][b] ? p[x][b] : p[x][b] = newnode(); }\nvoid adde(int b, int e) { ++ind[e], ++oud[b]; fa[find(b)] = find(e); }\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> H;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d;\n\t\tstd::cin >> a >> b >> c >> d;\n\t\tadde(c ? get(c, 1) : get(a, 0), d ? get(d, 0) : get(b, 1));\n\t}\n\tfor (int i = 1; i <= H; ++i) {\n\t\tif (int t = p[i][0]) {\n\t\t\tif (ind[t] > oud[t]) bye(); hav[find(t)] |= ind[t] != oud[t];\n\t\t}\n\t\tif (int t = p[i][1]) {\n\t\t\tif (ind[t] < oud[t]) bye(); hav[find(t)] |= ind[t] != oud[t];\n\t\t}\n\t}\n\tfor (int i = 1; i <= idx; ++i) if (fa[i] == i && !hav[i]) bye();\n\tstd::cout << \"YES\" << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\nconst int N = 2e5L + 11, M = 211;\n\nbool v[N];\nint al[N];\nint ar[N];\n\nbool his[M * 3];\ndeque <int> sl[M * 3], sr[M * 3];\n\nint main() {\n\tios :: sync_with_stdio(0);\n\tint n, h; cin >> n >> h;\n\tfor(int i = 1; i <= n; i ++) {\n\t\tint a, b, c, d; cin >> a >> b >> c >> d;\n\t\tif(c) al[i] = -c; else al[i] = a;\n\t\tif(d) ar[i] = -d; else ar[i] = b;\n\n\t\tsl[al[i] + M].pb(i);\n\t\tsr[ar[i] + M].pb(i);\n\t}\n\twhile(1) {\n\t\tbool ch = 0;\n\t\tfor(int i = -h + M; i <= h + M; i ++) {\n\t\t\twhile(sl[i].size() && v[sl[i][0]]) sl[i].pop_front();\n\t\t\twhile(sr[i].size() && v[sr[i][0]]) sr[i].pop_front();\n\t\t}\n\t\tfor(int i = -h; i <= h; i ++) if(sr[i + M].size() && sl[-i + M].size()) {\n\t\t\tif(sr[i + M][0] == sl[-i + M][0]) {\n\t\t\t\tif(sr[i + M].size() > 1) {\n\t\t\t\t\tsr[i + M].pb(sr[i + M][0]);\n\t\t\t\t\tsr[i + M].pop_front();\n\t\t\t\t} else if(sl[-i + M].size() > 1) {\n\t\t\t\t\tsl[-i + M].pb(sl[-i + M][0]);\n\t\t\t\t\tsl[-i + M].pop_front();\n\t\t\t\t} else continue;\n\t\t\t\tch = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tch = 1;\n\t\t\t//his[i + M] = 1;\n\t\t\tn ++;\n\t\t\tv[sr[i + M][0]] = v[sl[-i + M][0]] = 1;\n\t\t\tal[n] = al[sr[i + M][0]];\n\t\t\tar[n] = ar[sl[-i + M][0]];\n\n\t\t\tsr[i + M].pop_front();\n\t\t\tsl[-i + M].pop_front();\n\n\t\t\tsl[al[n] + M].pb(n);\n\t\t\tsr[ar[n] + M].pb(n);\n\t\t\tbreak;\n\t\t}\n\n\t\tif(!ch) break;\n\t}\n\n\tbool f = 1;\n\tint cnt = 0;\n\tfor(int i = 1; i <= n; i ++) if(!v[i]) {\n\t\t//cout << al[i] << ' ' << ar[i] << '\\n';\n\t\tif(al[i] > 0 && ar[i] > 0) {\n\t\t\tcnt ++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(al[i] + ar[i] == 0 && !his[-al[i] + M]) f = 0;\n\t\tif(al[i] + ar[i] != 0) f = 0;\n\t}\n\t//f &= (cnt == 1);\n\tcout << (f ? \"YES\" : \"NO\") << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint inadj[210][2], outadj[210][2], n, h;\nint inadj2[210][2], outadj2[210][2];\npair<int, int> thing(int a, int b)\n{\n\tpair<int, int> ans;\n\tif (b) ans = { b, 0 };\n\telse ans = { a, 1 };\n\treturn ans;\n}\nvector<pair<int, int> > adj[210][2];\nint seen[210][2], c;\nvector<pair<int, int> > components[500];\nvoid dfs(int a, int b, int d)\n{\n\tif (seen[a][b]) return;\n\tseen[a][b] = 1;\n\tcomponents[d].push_back({ a, b });\n\tfor (auto c : adj[a][b]) dfs(c.first, c.second, d);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tpair<int, int> in, out;\n\t\tin = thing(a, c);\n\t\tout = thing(b, d);\n\t\tout.second = !out.second;\n//\t\tprintf(\"%d %d -> %d %d\\n\", in.first, in.second, out.first, out.second);\n\t\toutadj[in.first][in.second]++;\n\t\tinadj[out.first][out.second]++;\n\t\tadj[in.first][in.second].push_back(out);\n\t\tadj[out.first][out.second].push_back(in);\n\t}\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tif (adj[i][j].size() && !seen[i][j]) dfs(i, j, c++);\n\t\t//\tprintf(\"%d:%d - in %d, out %d\\n\", i, j, inadj[i][j], outadj[i][j]);\n\t\t}\n\t}\n\tbool works = 1;\n\tfor (int i = 0; i < c; i++)\n\t{\n\t\tfor (int i = 0; i <= h; i++) inadj2[i][0] = inadj2[i][1] = outadj2[i][0] = outadj2[i][1] = 0;\n\t\tfor (auto b : components[i])\n\t\t{\n\t\t\tinadj2[b.first][b.second] += inadj[b.first][b.second];\n\t\t\toutadj2[b.first][b.second] += outadj[b.first][b.second];\n\t\t}\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\t//printf(\"%d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\tif (inadj2[i][0] - outadj2[i][0] > 0 && inadj2[i][1] - outadj2[i][1] < 0) \n\t\t\t{\n\t\t\t//\tprintf(\"%d\\n\", i);\n\t\t\t\tinadj2[i][0]--; \n\t\t\t\toutadj2[i][1]--;\n\t\t\t//\tprintf(\" %d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\t}\n\t\t}\n\t\tint extra = 0;\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t{\n\t\t//\t\tprintf(\"  %d\\n\", abs(inadj2[i][j] - outadj2[i][j]));\n\t\t\t\tif (abs(inadj2[i][j] - outadj2[i][j]) == 1) extra++;\n\t\t\t\telse if (abs(inadj2[i][j] - outadj2[i][j])) extra += 10;\n\t\t\t}\n\t\t}\n\t\tif (extra != 2) works = 0;\n\t}\n//\tprintf(\"Components %d\\n\", c);\n\tif (works) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\nconst int H = 200;\n\nstruct Input {\n\tint n, h;\n\tint a[N], b[N], c[N], d[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n >> h)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(\"%d%d%d%d\", &a[i], &b[i], &c[i], &d[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tbool ans;\n\t\n\tvoid write () {\n\t\tputs(ans ? \"YES\" : \"NO\");\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\tvi e[2 * H], f[2 * H];\n\t\tbool u[2 * H];\n\t\t\n\t\tbool dfs (int v) {\n\t\t\tif (u[v]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tu[v] = 1;\n\t\t\tbool res = (sz(e[v]) != sz(f[v]));\n\t\t\tfor (const auto &vec : {e[v], f[v]}) {\n\t\t\t\tfor (int to : vec) {\n\t\t\t\t\tres |= dfs(to);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\tmemset(f, 0, sizeof f);\n\t\t\tforn (i, n) {\n\t\t\t\tint u = c[i] ? h + c[i] - 1 : a[i] - 1;\n\t\t\t\tint v = d[i] ? d[i] - 1 : h + b[i] - 1;\n\t\t\t\te[u].pb(v);\n\t\t\t\tf[v].pb(u);\n\t\t\t}\n\t\t\tforn (i, h) {\n\t\t\t\tif (sz(e[i]) < sz(f[i])) {\n\t\t\t\t\tans = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforn (i, h, 2 * h) {\n\t\t\t\tif (sz(e[i]) > sz(f[i])) {\n\t\t\t\t\tans = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforn (i, 2 * h) {\n\t\t\t\tif (sz(e[i]) + sz(f[i]) > 0 && !u[i]) {\n\t\t\t\t\tif (!dfs(i)) {\n\t\t\t\t\t\tans = 0;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = 1;\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 410;\nconst int H = 201;\n\nbool use[N];\nve<pii> a[N];\nint st[N];\nbool is[100100];\n\nvoid dfs(int v) {\n\tuse[v] = 1;\n\tforn(i, sz(a[v])) {\n\t\tint to = a[v][i].fs;\n\t\tis[a[v][i].sc] = 1;\n\t\tif (!use[to])\n\t\t\tdfs(to);\n\t}\n}\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n#endif\n\tint n, h;\n\tcin >> n >> h;\n\tforn(i, n) {\n\t\tint a1, b1, c1, d1;\n\t\tscanf(\"%d%d%d%d\", &a1, &b1, &c1, &d1);\n\t\t//debug(mt(a1, b1, c1, d1));\n\t\tint u, v;\n\t\tif (c1 == 0) {\n\t\t\tu = a1;\n\t\t} else {\n\t\t\tu = c1 + H;\n\t\t}\n\t\tif (d1 == 0) {\n\t\t\tv = b1 + H;\n\t\t} else {\n\t\t\tv = d1;\n\t\t}\n\t\ta[u].pb(mp(v, i));\n\t\ta[v].pb(mp(u, i));\n\t\tst[u]++;\n\t\tst[v]--;\n\t}\n\tforn(i, H) {\n\t\tif (st[i] < 0 || st[i + H] > 0) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tforn(i, H) {\n\t\tif (st[i] > 0 && !use[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tint cnt = 0;\n\tforn(i, n)\n\t\tcnt += is[i];\n\tif (cnt == n) {\n\t\tputs(\"YES\");\n\t\treturn 0;\n \t}\n \tputs(\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 120000\n\nint n,m,in[N],out[N];\nvector<int> g[N];\nbool vis[N],fl;\n\nvoid add(int x,int y){\n\t++out[x+=m]; ++in[y+=m];\n\tg[x].push_back(y); g[y].push_back(x);\n}\n\nvoid dfs(int u){\n\tvis[u]=1;\n\tfl|=in[u]!=out[u];\n\tif (u<=m&&in[u]<out[u]){puts(\"NO\"); exit(0);}\n\tif (u>m&&in[u]>out[u]){puts(\"NO\"); exit(0);}\n\tfor (int v:g[u]) if (!vis[v]) dfs(v);\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i){\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint x=c?-c:a,y=d?d:-b;\n\t\tadd(x,y);\n\t}\n\tfor (int i=1;i<=m*2;++i)\n\t\tif (in[i]+out[i]&&!vis[i]){\n\t\t\tfl=0;\n\t\t\tdfs(i);\n\t\t\tif (!fl){puts(\"NO\"); return 0;}\n\t\t}\n\tputs(\"YES\");\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300050\nusing namespace std;\nint n,h;\nstruct node{\n\tint a,b,c,d;\n}q[N];\nint ld[233],lu[233],rd[233],ru[233],ds;\nint he[N],ne[N<<2],to[N<<2],tag[N],tot=1;\nint ind[N],outd[N];\ninline void addedge(int x,int y){\n\tto[++tot]=y;ne[tot]=he[x];he[x]=tot;\n\t++outd[x];++ind[y];\n\tto[++tot]=x;ne[tot]=he[y];he[y]=tot;\n}\nint pd[N],ans,ok;\ninline void dfs(int g){\n\tans+=outd[g]-ind[g];pd[g]=1;if(ans)ok=1;\n\tfor(int i=he[g];i;i=ne[i])if(!pd[to[i]])dfs(to[i]);\n}\nint main(){\n\tcin>>n>>h;\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d%d%d%d\",&q[i].a,&q[i].b,&q[i].c,&q[i].d);\n\tfor(int i=1;i<=h;++i)ld[i]=++ds;\n\tfor(int i=1;i<=h;++i)lu[i]=++ds;\n\tfor(int i=1;i<=h;++i)rd[i]=++ds;\n\tfor(int i=1;i<=h;++i)ru[i]=++ds;\n\tfor(int i=1;i<=n;++i){\n\t\tint pol,por;\n\t\tif(q[i].c){\n\t\t\taddedge(ru[q[i].c],ld[q[i].c]);\n\t\t\tpol=ld[q[i].c];\n\t\t}\n\t\telse pol=lu[q[i].a];\n\t\tif(q[i].d){\n\t\t\taddedge(rd[q[i].d],lu[q[i].d]);\n\t\t\tpor=rd[q[i].d];\n\t\t}\n\t\telse por=ru[q[i].b];\n\t\taddedge(pol,por);\n\t}\n\tint al=0;\n\tfor(int i=lu[1];i<=lu[h];++i)al+=outd[i]-ind[i];\n\tif(al<=0)return puts(\"NO\"),0;\n\tfor(int i=ru[1];i<=ru[h];++i)al+=outd[i]-ind[i];\n\tif(al)return puts(\"NO\"),0;\n\tfor(int i=ld[1];i<=ld[h];++i)if(ind[i]!=outd[i])return puts(\"NO\"),0;\n\tfor(int i=rd[1];i<=rd[h];++i)if(ind[i]!=outd[i])return puts(\"NO\"),0;\n\tfor(int i=1;i<=n;++i)\n\t\tif(!pd[i]){ok=0;dfs(i);if(ans&&ok)return puts(\"NO\"),0;}\n\treturn puts(\"YES\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<functional>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way,vel &con) {\n\tint n = way.size();\n\tvel dist(n,-1);\n\tdist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front();\n\t\tq.pop();\n\t\tcon.push_back(st);\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nint gr(int now, vvel &chi) {\n\tint ret = 0;\n\tfor(auto to:chi[now]) {\n\t\tret = ret xor (gr(to, chi) + 1);\n\t}\n\treturn ret;\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\th+=3;\n\tvvel way(2 * h);\n\tvvel inv_way(2 * h);\n\tvvel all_way(2 * h);\n\trep(i, n) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint st, to;\n\t\tif (c == 0) { st = a; }\n\t\telse { st = c + h; }\n\t\tif (d == 0) { to = b + h; }\n\t\telse { to = d; }\n\t\tway[st].push_back(to);\n\t\tinv_way[to].push_back(st);\n\t\tall_way[st].push_back(to);\n\t\tall_way[to].push_back(st);\n\t}\n\trep(i, h) {\n\t\tif (way[i].size() < inv_way[i].size()) { cout << \"NO\" << endl; return 0; }\n\t\tif (way[i + h].size() > inv_way[i + h].size()) { cout << \"NO\" << endl; return 0; }\n\t}\n\trep(i, 2 * h) {\n\t\tvel con = {};\n\t\tdis(i, all_way, con);\n\t\tif (con.size() == 1) {\n\t\t\tif (all_way[i].size() > 0) { cout << \"NO\" << endl; return 0; }\n\t\t}\n\t\telse {\n\t\t\tbool fl = false;\n\t\t\tfor (auto pl : con) {\n\t\t\t\tif ((pl<h) and (way[pl].size() > inv_way[pl].size())) { fl = true; }\n\t\t\t}\n\t\t\tif (!fl) { cout << \"NO\" << endl; return 0; }\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\nconst int N = 1e5 + 10, H = 505;\nint n, h, deg[H << 1];\nbool ff, tag, vis[H << 1], mark[H << 1];\nvector<int> nxt[H << 1];\n\nvoid add(int x, int y) {\n    x += H, y += H;\n    mark[x] = mark[y] = 1;\n    nxt[x].push_back(y);\n    ++deg[y], --deg[x];\n}\n\nvoid dfs(int x) {\n    if ((x > H && deg[x] > 0) || (x < H && deg[x] < 0)) {\n        ff = 1; return;\n    }\n    if (deg[x]) tag = 1;\n    vis[x] = 1;\n    for (int i = 0; i < nxt[x].size(); i++) {\n        int y = nxt[x][i];\n        if (vis[y]) continue;\n        dfs(y);\n    }\n}\n\nint main() {\n    cin >> n >> h;\n    rep(i, 1, n) {\n        int a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        add(c ? -c : a, d ? d : -b);\n    }\n    rep(i, 1, H << 1) if (mark[i] && !vis[i]) {\n        ff = tag = 0;\n        dfs(i);\n        if (ff || !tag) return puts(\"NO\"), 0;\n    }\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint head[401],nxt[200001],b[200001],k,n,h,ind[401],outd[401],f[401];\nbool vis[401];\nvoid push(int s,int t){\n//\tprintf(\"push %d %d\\n\",s,t);\n\tnxt[++k]=head[s];\n\thead[s]=k;\n\tb[k]=t;\n\t++ind[t];\n\t++outd[s];\n}\nint find(int x){return f[x]?f[x]=find(f[x]):x;}\nbool check(){\n\tfor(int i=1;i<=h;i++)if(ind[i]>outd[i])return 0;\n\tfor(int i=h+1;i<=(h<<1);i++)if(ind[i]<outd[i])return 0;\n\tfor(int i=1;i<=(h<<1);i++)\n\t\tfor(int j=head[i];j;j=nxt[j]){\n\t\t\tint u=find(i),v=find(b[j]);\n\t\t\tif(u!=v)f[u]=v;\n\t\t}\n\tfor(int i=1;i<=(h<<1);i++)if(ind[i]!=outd[i])vis[find(i)]=1;\n\tfor(int i=1;i<=(h<<1);i++)if(ind[i]&&!vis[find(i)])return 0;\n\treturn 1;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1,a,b,c,d;i<=n;i++)\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d),\n\t\tpush((!c)?a:(h+c),(!d)?h+b:d);\n\tif(check())puts(\"YES\");\n\telse puts(\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 100003;\nstatic const int MAXH = 209;\n \nstatic const int MAXV = MAXH * 2;\nstatic const int MAXE = 1e6 + 10;\n \nint n, h;\nint head[MAXV], dest[MAXE], next[MAXE];\nbool vis[MAXE] = { false };\n \nint m = 0;\nint in[MAXV] = { 0 }, out[MAXV] = { 0 };\n \ninline void add_edge(int u, int v)\n{\n    dest[m] = v; next[m] = head[u]; head[u] = m++;\n    ++out[u], ++in[v];\n}\n \nint cur[MAXV];\n \nvoid dfs(int u)\n{\n    for (int &w = cur[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs(dest[w]);\n        if (cur[u] == -1) break;\n    }\n}\n \nstd::vector<int> as, bs;\nbool marked[MAXV] = { false };\n \nint main()\n{\n    scanf(\"%d%d\", &n, &h);\n \n    int verts = (h + 1) * 2;\n    for (int i = 0; i < verts; ++i) head[i] = -1;\n \n#define node_a(_h) ((_h) * 2)\n#define node_b(_h) ((_h) * 2 + 1)\n    for (int i = 0, a, b, c, d; i < n; ++i) {\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        int u, v;\n        u = (c == 0 ? node_b(a) : node_a(c));\n        v = (d == 0 ? node_a(b) : node_b(d));\n        add_edge(u, v);\n    }\n    for (int i = 0; i <= h; ++i) {\n        if (in[node_a(i)] < out[node_a(i)]) { puts(\"NO\"); return 0; }\n        if (in[node_b(i)] > out[node_b(i)]) { puts(\"NO\"); return 0; }\n        for (int r = 0; r < in[node_a(i)] - out[node_a(i)]; ++r) {\n            as.push_back(node_a(i));\n            marked[node_a(i)] = true;\n        }\n        for (int r = 0; r < out[node_b(i)] - in[node_b(i)]; ++r) {\n            bs.push_back(node_b(i));\n            marked[node_b(i)] = true;\n        }\n    }\n    for (int u : as) {\n        if (bs.empty()) { puts(\"NO\"); return 0; }\n        add_edge(u, bs.back());\n        bs.pop_back();\n    }\n \n    for (int i = 0; i < verts; ++i) cur[i] = head[i];\n    for (int i = 0; i < verts; ++i) if (marked[i]) dfs(i);\n    for (int i = 0; i < m; ++i) if (!vis[i]) { puts(\"NO\"); return 0; }\n    puts(\"YES\"); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define retrun return\n#define cpnst const\nint CT[444][444],DEG[444],SZ[444],Lm=401;\nclass UFS\n{\n\tint Fa[1111];\n\tpublic:\n\tvoid init(){for(register int i=1;i<=1000;i++)Fa[i]=i;}\n\tint rt(int x){return Fa[x]^x?Fa[x]=rt(Fa[x]):x;}\n\tbool merge(int x,int y){return x=rt(x),y=rt(y),Fa[x]=y,x^y;}\n}U;\nvoid rd()\n{\n\tint a,b,c,d;\n\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\tif(c)a=-c;if(d)b=d;else b=-b;\n\tU.merge(a+201,b+201),CT[a+201][b+201]++,\n\tDEG[a+201]++,DEG[b+201]--,SZ[a+201]++,SZ[b+201]++;\n}\nint UNB[11111];\nvoid cover(int x)\n{UNB[U.rt(x)]=1;}\nint main()\n{\n\tregister int i;\n\tint n;\n\tscanf(\"%d%*d\",&n),U.init();\n\tfor(i=1;i<=n;i++)rd();\n\tfor(i=-200;i<=200;i++)\n\t{\n\t\tif(i<0&&DEG[i+201]>0)return puts(\"NO\"),0;\n\t\tif(i>0&&DEG[i+201]<0)return puts(\"NO\"),0;\n\t}for(i=1;i<=Lm;i++)\n\t\tif(DEG[i])cover(i);\n\tfor(i=1;i<=Lm;i++)\n\t\tif(SZ[i])\n\t\t\tif(!UNB[U.rt(i)])return puts(\"NO\"),0;\n\tputs(\"YES\");\n}\n/*\nJust go for it.\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define y1 __zzd001\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=100005;\nint n,H,c1=0,c2=0;\nvector <int> aL[N],aR[N],bL[N],bR[N];\nchar s[5][5];\nnamespace Brute{\n\tint a[N],b[N],c[N],d[N],id[N];\n\tbool check(){\n\t\tfor (int i=1;i<n;i++){\n\t\t\tint x=id[i],y=id[i+1];\n\t\t\tif (d[x]){\n\t\t\t\tif (a[y]!=d[x])\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b[x]!=c[y])\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\tvoid brute(){\n\t\tn=read(),H=read();\n\t\tfor (int i=1;i<=n;i++)\n\t\t\ta[i]=read(),b[i]=read(),c[i]=read(),d[i]=read();\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tid[i]=i;\n\t\tdo {\n\t\t\tif (check()){\n\t\t\t\tfor (int i=1;i<=n;i++)\n\t\t\t\t\tprintf(\"%d \",id[i]);\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t} while (next_permutation(id+1,id+n+1));\n\t\tputs(\"brute - end\");\n\t}\n}\nint main(){\n//Brute :: brute();\n\tn=read(),H=read();\n\tfor (int i=1;i<=n;i++){\t\n\t\tint a=read(),b=read(),c=read(),d=read();\n//\t\tfor (int i=1;i<=4;i++)\n//\t\t\tfor (int j=1;j<=3;j++)\n//\t\t\t\ts[i][j]=j==2?'#':' ';\n//\t\tfor (int i=1;i<=a;i++)\n//\t\t\ts[i+c][1]='#';\n//\t\tfor (int i=1;i<=b;i++)\n//\t\t\ts[i+d][3]='#';\n//\t\tfor (int i=4;i>=1;i--,puts(\"\"))\n//\t\t\tfor (int j=1;j<=3;j++)\n//\t\t\t\tputchar(s[i][j]);\n\t\tif (!c)\n\t\t\taR[a].push_back(i);\n\t\telse\n\t\t\tbR[c].push_back(i);\n\t\tif (!d)\n\t\t\tbL[b].push_back(i);\n\t\telse\n\t\t\taL[d].push_back(i);\n\t}\n\tfor (int i=1;i<=200;i++){\n\t\tint s1=aL[i].size();\n\t\tint s2=aR[i].size();\n\t\tif (s1>s2)\n\t\t\treturn puts(\"NO\"),0;\n\t\tif (s1<s2)\n\t\t\tc1+=s2-s1;\n\t\telse {\n\t\t\tif (!s1)\n\t\t\t\tcontinue;\n\t\t\tint f=1;\n\t\t\tfor (int j=0;f&&j<s1;j++)\n\t\t\t\tif (aL[i][j]!=aR[i][j])\n\t\t\t\t\tf=0;\n\t\t\tif (f)\n\t\t\t\treturn puts(\"NO\"),0;\n\t\t}\n\t}\n\tfor (int i=1;i<=200;i++){\n\t\tint s1=bR[i].size();\n\t\tint s2=bL[i].size();\n\t\tif (s1>s2)\n\t\t\treturn puts(\"NO\"),0;\n\t\tif (s1<s2)\n\t\t\tc2+=s2-s1;\n\t\telse {\n\t\t\tif (!s1)\n\t\t\t\tcontinue;\n\t\t\tint f=1;\n\t\t\tfor (int j=0;f&&j<s1;j++)\n\t\t\t\tif (bL[i][j]!=bR[i][j])\n\t\t\t\t\tf=0;\n\t\t\tif (f)\n\t\t\t\treturn puts(\"NO\"),0;\n\t\t}\n\t}\n\tif (c1!=c2)\n\t\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 102000;\nint n,a[N],b[N],c[N],d[N],bh[2][N],m,S;\nint ind[N],outd[N],f[N];\nint find(int x){return f[x]==x?x:f[x]=find(f[x]);}\nvoid add(int u, int v){\n//\tprintf(\"e %d %d\\n\",u,v);\n\tind[v]++;outd[u]++;\n\tu=find(u);v=find(v);f[u]=v;\n}\nvoid GG(){puts(\"NO\");exit(0);}\nint main() {\n\tread(n);read(m);\n\trep(j,0,1)rep(i,1,m)bh[j][i]=i+j*m;\n\trep(i,1,n)read(a[i]),read(b[i]),read(c[i]),read(d[i]);\n\trep(i,1,m*2+1)f[i]=i;\n\t//ao0 tu1\n\trep(i,1,n){\n\t\tadd(c[i]==0?bh[0][a[i]]:bh[1][c[i]],d[i]==0?bh[1][b[i]]:bh[0][d[i]]);\n\t}\n\tS=m*2+1;\n\trep(i,1,m){\n\t\twhile(ind[i]<outd[i])add(S,i);\n\t\tif(ind[i]>outd[i])GG();\n\t}\n\trep(i,m+1,m+m){\n\t\twhile(outd[i]<ind[i])add(i,S);\n\t\tif(outd[i]>ind[i])GG();\n\t}\n//\trep(i,1,S)printf(\"%d:%d\\n\",i,find(i));\n\tset<int>Set;rep(i,1,S)if(ind[i]&&find(i)!=find(S))GG();\n//\tif(SZ(Set)>1)GG();\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=410;\nint n,h,in[N],out[N];\nint fa[N];\nbool ok[N];\n\nint find(const int &x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\nint main()\n{\n    n=read();h=read();\n    for(int i=1;i<=(h<<1);i++) fa[i]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int A=read(),B=read(),C=read(),D=read();\n        int x=C?C+h:A,y=D?D:B+h;\n        out[x]++;in[y]++;\n        x=find(x);y=find(y);\n        if(x!=y) fa[x]=y;\n    }\n    for(int i=1;i<=h;i++) if(in[i]>out[i]) return !puts(\"NO\");\n    for(int i=h+1;i<=(h<<1);i++) if(in[i]<out[i]) return !puts(\"NO\");\n    for(int i=1;i<=(h<<1);i++) if(in[i]!=out[i]||!in[i]&&!out[i]) ok[find(i)]=1;\n    for(int i=1;i<=(h<<1);i++) if(fa[i]==i&&!ok[i]) return !puts(\"NO\");\n    return !puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n\nusing namespace std;\n\nvoid fail() {\n    cout << \"NO\" << endl;\n    exit(0);\n}\n\nclass QuickFind {\npublic:\n    QuickFind(int N) : V_NUM(N) {\n        par.resize(V_NUM);\n        iota(par.begin(), par.end(), 0);\n        group.resize(V_NUM);\n        for (int i = 0; i < N; ++i) group[i] = {i};\n    }\n\n    int find(int v) {\n        return par[v] == v ? v : par[v] = find(par[v]);\n    }\n\n    void merge(int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v) return;\n        if (group[u].size() < group[v].size()) swap(u, v);\n\n        par[v] = u;\n        copy(group[v].begin(), group[v].end(), back_inserter(group[u]));\n        group[v].erase(group[v].begin(), group[v].end());\n    }\n\n    int V_NUM;\n    vector<vector<int>> group;\n    vector<int> par;\n};\n\nint main() {\n    int N, H;\n    cin >> N >> H;\n\n    vector<int> in(H * 2, 0), out(H * 2, 0);\n    QuickFind qf(H * 2);\n    for (int i = 0; i < N; ++i) {\n        int A, B, C, D;\n        cin >> A >> B >> C >> D;\n        --A, --B, --C, --D;\n\n        // (C, A)と(D, B)をペアで考える。\n        // (0, A)と(A, *), (C, *)と(0, C)は同じ頂点にする。\n        // するとピースは辺になり、条件は\n        //     (0, A)を始点、(0, B)を終点とするオイラー路に分解できる\n        // と言い換えられる。\n\n        int from, to;\n        if (C < 0) {\n            from = A;\n        } else {\n            from = C + H;\n        }\n\n        if (D < 0) {\n            to = B + H;\n        } else {\n            to = D;\n        }\n\n        ++out[from];\n        ++in[to];\n        qf.merge(from, to);\n    }\n\n    for (auto& g : qf.group) {\n        if (g.empty()) continue;\n        if (g.size() == 1) {\n            if (in[g[0]] != 0) fail();\n        } else {\n            bool start = false;\n            for (auto i : g) {\n                int d = out[i] - in[i];\n                if ((i < H && d < 0) || (i >= H && d > 0)) fail();\n                if (i < H && d > 0) start = true;\n            }\n            if (!start) fail();\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin>>n;\n\tcout<<\"Yes\";\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> emp[2][205],bmp[2][205];\nbool vis[100005];\nint a[100005],c[100005],d[100005],b[100005];\nint n,h;\n\nbool fillb(int i)\n{\n    vis[i] = true;\n    if(c[i]==0)\n    {\n        for(int j=0;j<bmp[1][a[i]].size();++j){\n            if(vis[bmp[1][a[i]][j]]) continue;\n            return fillb(bmp[1][a[i]][j]);\n        }\n        return true;\n    }else{\n        for(int j=0;j<bmp[0][c[i]].size();++j)\n        {\n            if(vis[bmp[0][c[i]][j]]) continue;\n            return fillb(bmp[0][c[i]][j]);\n        }\n        return false;\n    }\n}\n\nbool fille(int i)\n{\n    vis[i] = true;\n    if(d[i]==0)\n    {\n        for(int j=0;j<emp[1][b[i]].size();++j)\n        {\n\n            if(vis[emp[1][b[i]][j]]) continue;\n            return fille(emp[1][b[i]][j]);\n        }\n        return true;\n    }else\n    {\n        for(int j=0;j<emp[0][d[i]].size();++j)\n        {\n            if(vis[emp[0][d[i]][j]])continue;\n            return fille(emp[0][d[i]][j]);\n        }\n        return false;\n    }\n}\n\nint main()\n{\n    //freopen(\"C://Code//input.txt\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n        if(c[i]==0)\n        {\n            emp[0][a[i]].push_back(i);\n        }else emp[1][c[i]].push_back(i);\n        if(d[i]==0) bmp[0][b[i]].push_back(i);\n        else bmp[1][d[i]].push_back(i);\n    }\n    bool ag = true;\n    for(int i=0;i<n;++i)\n    {\n        if(vis[i]||(c[i]==0&&d[i]==0)) continue;\n        if((!fillb(i))||(!fille(i)))\n        {\n            ag= false;break;\n        }\n    }\n    if(ag) printf(\"YES\");\n    else printf(\"NO\");\n    printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nint N,H;\nvector<int> g[401];\nint odeg[401],ideg[401];\nbool dd[401][401];\nbool used[401];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  // 0-(H-1) : - , H-(2*H-1) : +\n\n  cin>>N>>H;\n  rep(i,2*H+1)dd[i][i]=true;\n  rep(i,N){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    int s,t;\n    if(c==0){\n      s=-a;\n    }else{\n      s=+c;\n    }\n    if(d==0){\n      t=+b;\n    }else{\n      t=-d;\n    }\n    //dbg(s); dbg(t);\n    if(s<0){\n      s=-s-1;\n    }else{\n      s+=H-1;\n    }\n    if(t<0){\n      t=-t-1;\n    }else{\n      t+=H-1;\n    }\n    g[s].push_back(t);\n    used[s]=used[t]=true;\n    odeg[s]++; ideg[t]++;\n    dd[s][t]=true;\n  }\n\n  int w=2*H;\n  bool ok=true;\n  rep(v,2*H){\n    if(v<H){ // -\n      if(odeg[v]<ideg[v]){\n        cout<<\"NO\"<<endl;\n        return 0;\n      }\n      rep(i,odeg[v]-ideg[v]){\n        dd[w][v]=true;\n        g[w].push_back(v);\n      }\n    }else{ // +\n      if(odeg[v]>ideg[v]){\n        cout<<\"NO\"<<endl;\n        return 0;\n      }\n      rep(i,ideg[v]-odeg[v]){\n        dd[v][w]=true;\n        g[v].push_back(w);\n      }\n    }\n  }\n  rep(k,2*H+1)rep(i,2*H+1)rep(j,2*H+1)dd[i][j]|=(dd[i][k]&&dd[k][j]);\n  rep(i,2*H+1){\n    if(!used[i])continue;\n    if(!(dd[w][i]&&dd[i][w]))ok=false;\n  }\n  if(ok) cout<<\"YES\"<<endl;\n  else cout<<\"NO\"<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define vi vector<int>\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define aa first\n#define bb second\n#define xx aa.aa\n#define yy aa.bb\n#define zz bb\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nint n,m,a,b,c,d,w[410],f[410],u[410];\ninline int fa(int i)\n{\n\treturn i==f[i]?i:f[i]=fa(f[i]);\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k,l;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=2*m;i++)\n\t  f[i]=i;\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t   if(c)\n\t     j=c+m;\n\t   else\n\t     j=a;\n\t   if(d)\n\t     k=d;\n\t   else\n\t     k=b+m;\n\t   w[j]++;\n\t   w[k]--;\n\t   f[fa(j)]=fa(k);\n\t   u[j]=u[k]=1;\n\t  }\n\tfor(l=1;l<=2*m;l++)\n\t{\n\tfor(i=1,j=k=0;i<=2*m;i++)\n\t  if(fa(i)==l)\n\t  if(w[i]>0)\n\t    if(i<=m)\n\t      j+=w[i];\n\t    else\n\t      break;\n\t  else if(w[i]<0)\n\t    if(i>m)\n\t      k+=-w[i];\n\t    else\n\t      break;\n\tif(i<=2*m || j!=k)\n\t  {\n\t   printf(\"NO\\n\");\n\t   return 0;\n\t  }\n\tif(!j && !k)\n\t  {\n\t   for(i=1,j=k=0;i<=2*m;i++)\n\t     if(fa(i)==l)\n\t     if(u[i])\n\t       if(i<=m)\n\t         j=1;\n\t       else\n\t         k=1;\n\t   if((j>0)^(k>0))\n\t     {\n\t      printf(\"NO\\n\");\n\t      return 0;\n\t\t }\n\t  }\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n\nconst int N = 400 + 10;\n\nint n, deg[N];\n\nint anc[N], cnt[N], mask[N];\n\nint find(int x) { return anc[x] == x ? x : (anc[x] = find(anc[x])); }\n\nvoid init() {\n  int m;\n  scanf(\"%d%d\", &m, &n);\n  std::iota(anc, anc + 2 * n + 1, 0);\n  while (m--) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    int x = c ? (c + n) : a, y = d ? d : (b + n);\n    ++cnt[x], ++cnt[y];\n    --deg[x], ++deg[y];\n    anc[find(x)] = find(y);\n  }\n}\n\nint main() {\n  init();\n  for (int i = 1; i <= n; ++i) if (deg[i] > 0 || deg[i + n] < 0) return puts(\"NO\"), 0;\n  for (int i = 1; i <= 2 * n; ++i) mask[find(i)] |= deg[i];\n  for (int i = 1; i <= n; ++i) if (find(i) == i && cnt[i] && !mask[i]) return puts(\"NO\"), 0;\n  puts(\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int> g[505];\nint l_cnt[505], r_cnt[505];\nbool used[505];\n\nint print(bool ok) {\n        if (ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n}\n\nbool dfs(int v) {\n        used[v] = true;\n        bool res = l_cnt[v] != r_cnt[v];\n        for (auto u : g[v]) if (!used[u]) res |= dfs(u);\n        return res;\n}\n\nint main() {\n        int n, h, a, b, c, d;\n        cin >> n >> h;\n        for (int i = 0; i < n; i ++) {\n                cin >> a >> b >> c >> d;\n                int lh = (c == 0 ? a : c + 250);\n                int rh = (d == 0 ? b + 250 : d);\n                l_cnt[lh] ++;\n                r_cnt[rh] ++;\n                g[lh].push_back(rh);\n                g[rh].push_back(lh);\n        }\n        for (int i = 0; i < h + 1; i ++) if (r_cnt[i] > l_cnt[i]) return print(0);\n        for (int i = 251; i < h + 251; i ++) if (l_cnt[i] > r_cnt[i]) return print(0);\n        for (int i = 0; i < 501; i ++) if (!used[i]) if (!g[i].empty()) if (!dfs(i)) return print(0);\n        return print(1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nconst int MAX_V = 420;\nconst int Base = MAX_V / 2;\n\nvector<int> es[MAX_V];\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n\n\n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n\n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n\n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n    bool check(int v) {\n    \treturn res[cmp[v]].size() > 1;\n    }\n};\n\n// #define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\tvi a(n), b(n), c(n), d(n);\n\trep(i, n) cin >> a[i] >> b[i] >> c[i] >> d[i];\n\tvi l(n), r(n);\n\trep(i, n) {\n\t\tl[i] = (c[i] == 0 ? a[i] : -c[i]);\n\t\tr[i] = (d[i] == 0 ? b[i] : -d[i]);\n\t}\n\tset<int> st;\n\trep(i, n) {\n\t\tint frm = (l[i] > 0 ? l[i] : Base - l[i]);\n\t\tint to = (r[i] > 0 ? Base + r[i] : -r[i]);\n\t\t//if(frm == 2) {\n\t\t\tdump(i);dump(frm);dump(to);\n\t\t//}\n\t\tif(frm == to) continue;\n\t\tes[frm].pb(to);\n\t\tst.insert(frm);\n\t\tst.insert(to);\n\t}\n\tint W = MAX_V-1;\n\tst.insert(W);\n\tvector<int> in(MAX_V), out(MAX_V);\n\tSCC g(MAX_V);\n\trep(i, MAX_V) {\n\t\tsort(all(es[i]));\n\t\t//es[i].erase(unique(all(es[i])), es[i].end());\n\t\tint prv = -1;\n\t\tfor(auto& to : es[i]) {\n\t\t\tif(prv != to) g.add_edge(i, to);\n\t\t\tprv = to;\n\t\t\tin[to]++;\n\t\t}\n\t\tout[i] = es[i].size();\n\t}\n\trep(i, MAX_V) {\n\t\tif(i >= Base) {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] < out[i]) {\n\t\t\t\tLINE;dump(i);dump(in[i]);dump(out[i]);dump(es[i][0]);\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse g.add_edge(i, W);\n\t\t}\n\t\telse {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] > out[i]) {\n\t\t\t\tLINE;\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse g.add_edge(W, i);\n\t\t}\n\t}\n\tg.scc();\n\tfor(auto& v : st) {\n\t\tif(!g.check(v)) {\n\t\t\tLINE;\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n#define pb push_back\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nconst int N = 1e5 + 20 , MX = 400 + 20 ;\nint n , H , a[N] , b[N] , c[N] , d[N] ;\n\nvector <int> g[MX] , h[MX] ;\n\nbool vis[MX] , c1 , c2 ;\n\ninline void err () {\n\tcout << \"NO\\n\" ;\n\texit(0) ;\n}\n\nvoid dfs (int v) {\n\tvis[v] = 1 ;\n\tif (v < MX / 2 && _sz(h[v]) > _sz(g[v])) c1 = 1 ;\n\tif (v > MX / 2 && _sz(h[v]) < _sz(g[v])) c2 = 1 ;\n\n\tfor (int u : g[v]) {\n\t\tif (!vis[u]) dfs(u) ;\n\t}\n\tfor (int u : h[v]) {\n\t\tif (!vis[u]) dfs(u) ;\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n >> H ;\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i] ;\n\t\n\t\tint l , r ;\n\n\t\tif (c[i]) l = -c[i] ;\n\t\telse l = a[i] ;\n\n\t\tif (d[i]) r = d[i] ;\n\t\telse r = -b[i] ;\n\t\n\t\tl += MX / 2 , r += MX / 2 ;\n\n\t\tg[l].pb(r) ;\n\t\th[r].pb(l) ;\n\t}\n\n\tfor (int i = 0 ; i < MX ; i ++) {\n\t\tif (i < MX / 2 && _sz(g[i]) > _sz(h[i])) err() ;\n\t\tif (i > MX / 2 && _sz(g[i]) < _sz(h[i])) err() ;\n\t}\n\n\tfor (int i = 0 ; i < MX ; i ++) {\n\t\tif (_sz(g[i]) + _sz(h[i]) && !vis[i]) {\n\t\t\tc1 = 0 ;\n\t\t\tc2 = 0 ;\n\t\t\tdfs(i) ;\n\n\t\t\tif (!c1 || !c2) err() ;\n\t\t}\n\t}\n\t\n\tcout << \"YES\\n\" ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300050\nusing namespace std;\nint n,h;\nstruct node{\n\tint a,b,c,d;\n}q[N];\nint ld[233],lu[233],rd[233],ru[233],ds;\nint ind[N],outd[N],fa[N],pd[N];\nint getfa(int x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}\nint main(){\n\tcin>>n>>h;\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d%d%d%d\",&q[i].a,&q[i].b,&q[i].c,&q[i].d);\n\tfor(int i=1;i<=h;++i)ld[i]=++ds,fa[ds]=ds;\n\tfor(int i=1;i<=h;++i)lu[i]=++ds,fa[ds]=ds;\n\tfor(int i=1;i<=h;++i)rd[i]=lu[i];\n\tfor(int i=1;i<=h;++i)ru[i]=ld[i];\n\tfor(int i=1;i<=n;++i){\n\t\tint pol,por;\n\t\tif(q[i].c)pol=ld[q[i].c];\n\t\telse pol=lu[q[i].a];\n\t\tif(q[i].d)por=rd[q[i].d];\n\t\telse por=ru[q[i].b];\n\t\t++outd[pol];++ind[por];\n\t\tfa[getfa(pol)]=getfa(por);\n\t}\n\tint al=0;\n\tfor(int i=lu[1];i<=lu[h];++i){\n\t\tal+=outd[i]-ind[i];\n\t\tif(outd[i]<ind[i])return puts(\"NO\"),0;\n\t}\n\tif(al<=0)return puts(\"NO\"),0;\n\tfor(int i=ru[1];i<=ru[h];++i){\n\t\tif(outd[i]>ind[i])return puts(\"NO\"),0;\n\t\tal+=outd[i]-ind[i];\n\t}\n\tif(al)return puts(\"NO\"),0;\n\tfor(int i=1;i<=ds;++i)if(ind[i]!=outd[i])pd[getfa(i)]=1;\n\tfor(int i=1;i<=ds;++i)if((ind[i]||outd[i])&&!pd[getfa(i)])return puts(\"NO\"),0;\n\treturn puts(\"YES\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nconst int MAX_V = 420;\nconst int Base = MAX_V / 2;\n\nvector<int> es[MAX_V];\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n\n\n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n\n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n\n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n    bool check(int v) {\n    \treturn res[cmp[v]].size() > 1;\n    }\n};\n\n// #define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\tvi a(n), b(n), c(n), d(n);\n\trep(i, n) cin >> a[i] >> b[i] >> c[i] >> d[i];\n\tvi l(n), r(n);\n\trep(i, n) {\n\t\tl[i] = (c[i] == 0 ? a[i] : -c[i]);\n\t\tr[i] = (d[i] == 0 ? b[i] : -d[i]);\n\t}\n\tset<int> st;\n\trep(i, n) {\n\t\tint frm = (l[i] > 0 ? l[i] : Base - l[i]);\n\t\tint to = (r[i] > 0 ? Base + r[i] : -r[i]);\n\t\tif(frm == to) continue;\n\t\tes[frm].pb(to);\n\t\tst.insert(frm);\n\t\tst.insert(to);\n\t}\n\tint W = MAX_V-1;\n\tst.insert(W);\n\tvector<int> in(MAX_V), out(MAX_V);\n\tSCC g(MAX_V);\n\trep(i, MAX_V) {\n\t\tsort(all(es[i]));\n\t\t//es[i].erase(unique(all(es[i])), es[i].end());\n\t\tint prv = -1;\n\t\tfor(auto& to : es[i]) {\n\t\t\tif(prv != to) g.add_edge(i, to);\n\t\t\tprv = to;\n\t\t\tin[to]++;\n\t\t}\n\t\tout[i] = es[i].size();\n\t}\n\trep(i, MAX_V) {\n\t\tif(i >= Base) {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] < out[i]) {\n\t\t\t\tLINE;dump(i);dump(in[i]);dump(out[i]);dump(es[i][0]);\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse g.add_edge(i, W);\n\t\t}\n\t\telse {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] > out[i]) {\n\t\t\t\tLINE;\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse g.add_edge(W, i);\n\t\t}\n\t}\n\tg.scc();\n\t// for(auto& v : st) {\n\t// \tif(!g.check(v)) {\n\t// \t\tLINE;\n\t// \t\tcout << \"NO\" << endl;\n\t// \t\treturn 0;\n\t// \t}\n\t// }\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, e[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += e[i];\n\t}\n\tif (s+st < e[401]||st==e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N, H;\nvector<int> vertex;\nint degree[1000];\nint v1[105000], v2[105000];\nbool can[1000];\nint main() {\n    cin >> N >> H;\n    cerr << N << \" \" << H << endl;\n    UnionFind uni(3 * H);\n    for(int i = 0; i < N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        cerr << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        if(c == 0) v1[i] = a;\n        else v1[i] = H + c;\n        if(d == 0) v2[i] = H + b;\n        else v2[i] = d;\n        degree[v1[i]]--;\n        degree[v2[i]]++;\n        uni.merge(v1[i], v2[i]);\n        vertex.push_back(v1[i]);\n        vertex.push_back(v2[i]);\n        //cerr << v1[i] << \" \" << v2[i] << endl;\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            can[v1[i]] = true;\n        }\n    }\n    sort(vertex.begin(), vertex.end());\n    vertex.erase(unique(vertex.begin(), vertex.end()), vertex.end());\n    map<int, vector<int>> mp;\n    for(auto v : vertex) {\n        /*\n        if(!uni.issame(v, vertex[0])) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        */\n        mp[uni.root(v)].push_back(v);\n    }\n    cerr << \"sz: \" << mp.size() << endl;\n    for(auto tmp : mp) {\n        /*\n        for(auto v : tmp.second) {\n            cerr << v << \" \";\n        }\n        cerr << endl;\n        */\n        vector<int> s, t;\n        for(auto v : tmp.second) {\n            if(degree[v] < 0) s.push_back(v);\n            if(degree[v] > 0) t.push_back(v);\n        }\n        if(s.empty()) {\n            assert(t.empty());\n            bool ok = false;\n            for(auto v : tmp.second) {\n                ok |= can[v];\n            }\n            if(!ok) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        } else {\n            //if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n            for(auto v : s) {\n                if(v >= H + 1) {\n                    cout << \"NO\" << endl;\n                    assert(0);\n                    return 0;\n                }\n            }\n            for(auto v : t) {\n                if(v <= H) {\n                    cout << \"NO\" << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n    /*\n    int s = -1, t = -1;\n    for(auto v : vertex) {\n        if(abs(degree[v]) >= 2) {\n            cout << \"NO\" << endl;\n            cerr << \"DEGREE\" << endl;\n            return 0;\n        }\n        if(degree[v] == 1) {\n            if(t != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"T\" << endl;\n                return 0;\n            } else {\n                t = v;\n            }\n        }\n        if(degree[v] == -1) {\n            if(s != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"S\" << endl;\n                cerr << s << \" \" << v << endl;\n                return 0;\n            } else {\n                s = v;\n            }\n        }\n    }\n    if(s != -1) {\n        assert(t != -1);\n        if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n    }\n    for(int i = 0; i < N; i++) {\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    }\n    cout << \"NO\" << endl;\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<20;\nint fa[Q];\nint in[Q],out[Q];\nint gf(int x)\n{return fa[x]==x?x:(fa[x]=gf(fa[x]));}\nvoid ins(int x,int y)\n{\n    out[x]++;\n    in[y]++;\n    int fx=gf(x),fy=gf(y);\n    if(fx!=fy)fa[fx]=fy;\n}\n// int Idiot_Sap(int x,int flow)\n// {\n//     if(x==T)return flow;\n//     int had=0;\n//     for(int t=las[x];t;t=nn[t]){\n//         int y=e[t];\n//         if((!c[t])||dis[x]-1!=dis[y])continue;\n//         int del=Idiot_Sap(y,min(c[t],flow-had));\n//         c[t]-=del;\n//         c[t^1]+=del;\n//         had+=del;\n//         if(dis[S]>=T||had==flow)return had;\n//     }\n//     if(dis[S]>=T)return had;\n//     --cnt[dis[x]];\n//     if(!cnt[dis[x]])dis[S]=T;\n//     cnt[++dis[x]]++;\n//     return had;\n// }\nint had[Q];\nint main()\n{\n    int n,h;\n    cin>>n>>h;\n    h+=5;\n    for(int i=1;i<=h+h;i++)fa[i]=i;\n    for(int i=1,a,b,c,d;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        ++a,++b,++c,++d;\n        int x,y;\n        if(c==1)x=a+h;\n        else x=c;\n        if(d==1)y=b;\n        else y=d+h;\n        // printf(\"%d %d LINK\\n\",x,y);\n        ins(x,y);\n    }\n    for(int i=1;i<=h;i++)if(out[i]>in[i])return puts(\"NO\")&0;\n    for(int i=h+1;i<=h+h;i++)if(out[i]<in[i])return puts(\"NO\")&0;\n    for(int i=1;i<=h+h;i++)if(in[i]!=out[i])had[gf(i)]=1;\n    for(int i=1;i<=h+h;i++)if(in[i]&&out[i]&&(!had[gf(i)]))return puts(\"NO\")&0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define neko 100010\n#define heko 410\n#define qwq return printf(\"YES\"),0; \n#define orz return printf(\"NO\"),0; \n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))\nstatic int n,H;\ntypedef int arr[heko];\narr fa,book,dgi,dgo,out;\nnamespace IO\n{\n\tconst unsigned int bufsize=1<<16,outsize=1<<24;\n\tstatic char ch[bufsize],*S=ch,*T=ch;\n\tinline char getc()\n\t{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\n\tstatic char Out[outsize],*nowp=Out;\n\tinline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\n\t\tvoid read(T &x)\n\t\t{\n\t\t\tchar c=getc();x=0;\n\t\t\tfor(;!isdigit(c);c=getc());\n\t\t\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n\t\t}\n\ttemplate<typename T>\n\t\tvoid write(T x,char c='\\n')\n\t\t{\n\t\t\tif(!x)*nowp++='0';\n\t\t\tstatic unsigned int stk[50],tp=0;\n\t\t\tfor(;x;x/=10)stk[++tp]=x%10;\n\t\t\tfor(;tp;*nowp++=stk[tp--]^'0');*nowp++=c;\n\t\t}\n}\nint find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}\nint main()\n{\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n\tusing namespace IO;\n\tint x,y,z,o,X,Y;\n\tread(n),read(H);\n\tf(i,0,400)fa[i]=i;\n\tf(i,1,n)\n\t{\n\t\tread(x),read(y),read(z),read(o);\n\t\tif(z==0)X=200+x;\n\t\telse X=200-z;\n\t\tif(o==0)Y=200-y;\n\t\telse Y=200+o;\n\t\tbook[X]=book[Y]=1;\n\t\t++dgi[Y],++dgo[X];\n\t\tfa[find(Y)]=find(X);\n\n\t}\n\tf(i,0,200)if(dgi[i]<dgo[i])orz;\n\tf(i,201,400)if(dgi[i]>dgo[i])orz;\n\tf(i,0,400)if(dgi[i]^dgo[i])out[find(i)]=1;\n\tout[0]=1;\n\tf(i,0,400)if(book[i]&&!out[fa[i]])orz;\n\tqwq;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, H;\nint A[100000];\nint B[100000];\nint C[100000];\nint D[100000];\nint X[201], Y[201];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> H;\n  int g = -N;\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    g += C[i]==0;\n    g += D[i]==0;\n  }\n  if (g <= 0) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  rep(i, N) {\n    if (C[i] == 0) X[A[i]]++;\n    else Y[C[i]]--;\n\n    if (D[i] == 0) Y[B[i]]++;\n    else X[D[i]]--;\n  }\n  for (int i=1; i<=H; i++) if (X[i] < 0 || Y[i] < 0) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  cout << \"YES\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,m,fa[605],sz[605],in[605],out[605];\nbool fl[605];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid link(int u,int v){sz[v]++;if(u==v)return;fa[u]=v,sz[v]+=sz[u];}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<=2*m;i++)fa[i]=i;\n\tfor(int i=1,a,b,c,d,l,r;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tl=c?-c:a,r=d?d:-b;\n\t\tin[r+m]++,out[l+m]++;\n\t\tlink(find(l+m),find(r+m));\n\t}\n\tfor(int i=0;i<=2*m;i++){\n\t\tif(i<m&&in[i]<out[i])puts(\"NO\"),exit(0);\n\t\tif(i>m&&in[i]>out[i])puts(\"NO\"),exit(0);\n\t\tif(in[i]!=out[i])fl[find(i)]=true;\n\t}\n\tfor(int i=0;i<=2*m;i++)if(sz[i]&&!fl[find(i)])puts(\"NO\"),exit(0);\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, H, A[100009], B[100009], C[100009], D[100009], L[100009], R[100009], deg[100009], deg2[100009], cnt;\n\nint main() {\n\tcin >> N >> H; H++;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\t\tif (C[i] == 0) { L[i] = -A[i]; cnt++; } else { L[i] = C[i]; }\n\t\tif (D[i] == 0) { R[i] = -B[i]; cnt++; } else { R[i] = D[i]; }\n\t\tR[i] *= -1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint a1 = 0, a2 = 0;\n\t\tif (L[i] < 0) a1 = H + (-L[i]); else a1 = L[i];\n\t\tif (R[i] < 0) a2 = H + (-R[i]); else a2 = R[i];\n\t\tdeg[a1]++; deg[a2]--;\n\t\tif ((L[i] > 0 && R[i] < 0) || (L[i] < 0 && R[i] > 0)) { deg2[a1]++; deg2[a2]++; }\n\t\telse { if (a1 >= H) { deg2[a1]++; deg2[a2]--; } else { deg2[a1]--; deg2[a2]++; } }\n\t}\n\tbool OK = true; int V = 0;\n\tfor (int i = 0; i < H; i++) { if (deg[i] > 0) OK = false; }\n\tfor (int i = H; i < 2 * H; i++) { if (deg[i] < 0) OK = false; else V += deg[i]; }\n\n\tif (V == 0 || V != (cnt - N)) OK = false;\n\n\tfor (int i = 0; i < 2 * H; i++) { if (deg2[i] < 0) OK = false; }\n\n\tif (OK == true) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\nusing namespace std;\nint n,h,fa[440],pd[440],du[2][440];\nint get(int x)\n{\n\treturn fa[x]==x?x:fa[x]=get(fa[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=h+h;i++) fa[i]=i;\n\tfor(int i=1,a,b,c,d;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0) du[0][h+a]++; else du[0][h-c]++;\n\t\tif(d==0) du[1][h-b]++; else du[1][h+d]++;\n\t\tfa[get(c==0?h+a:h-c)]=get(d==0?h-b:h+d);\n\t}\n\tfor(int i=0;i<h;i++) \n\t\tif(du[0][i]>du[1][i]) {puts(\"NO\");return 0;} \n\tfor(int i=h+1;i<=h+h;i++)\n\t\tif(du[0][i]<du[1][i]) {puts(\"NO\");return 0;}\n\tfor(int i=0;i<=h+h;i++)\n\t\tif(du[0][i]!=du[1][i]||du[0][i]+du[1][i]==0) pd[get(i)]=1;\n\tfor(int i=0;i<=h+h;i++)\n\t\tif(!pd[get(i)]) {puts(\"NO\");return 0;}\n\tputs(\"YES\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nconst int MAX_V = 420;\nconst int Base = MAX_V / 2;\n\nvector<int> es[MAX_V];\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n\n\n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n\n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n\n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n    bool check(int v) {\n    \treturn cmp[MAX_V-1] == cmp[v];\n    }\n};\n\n// #define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\tvi a(n), b(n), c(n), d(n);\n\trep(i, n) cin >> a[i] >> b[i] >> c[i] >> d[i];\n\tvi l(n), r(n);\n\trep(i, n) {\n\t\tl[i] = (c[i] == 0 ? a[i] : -c[i]);\n\t\tr[i] = (d[i] == 0 ? b[i] : -d[i]);\n\t}\n\tset<int> st;\n\trep(i, n) {\n\t\tint frm = (l[i] > 0 ? l[i] : Base - l[i]);\n\t\tint to = (r[i] > 0 ? Base + r[i] : -r[i]);\n\t\tif(frm == to) continue;\n\t\tes[frm].pb(to);\n\t\tst.insert(frm);\n\t\tst.insert(to);\n\t}\n\tint W = MAX_V-1;\n\tst.insert(W);\n\tvector<int> in(MAX_V), out(MAX_V);\n\tSCC g(MAX_V);\n\trep(i, MAX_V) {\n\t\tsort(all(es[i]));\n\t\t//es[i].erase(unique(all(es[i])), es[i].end());\n\t\tint prv = -1;\n\t\tfor(auto& to : es[i]) {\n\t\t\tif(prv != to) g.add_edge(i, to);\n\t\t\tprv = to;\n\t\t\tin[to]++;\n\t\t}\n\t\tout[i] = es[i].size();\n\t}\n\trep(i, MAX_V) {\n\t\tif(i >= Base) {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] < out[i]) {\n\t\t\t\tLINE;dump(i);dump(in[i]);dump(out[i]);dump(es[i][0]);\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse g.add_edge(i, W);\n\t\t}\n\t\telse {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] > out[i]) {\n\t\t\t\tLINE;\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse g.add_edge(W, i);\n\t\t}\n\t}\n\tg.scc();\n\tfor(auto& v : st) {\n\t\tif(!g.check(v)) {\n\t\t\tLINE;\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include<cstring>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nint N,H,pal;\tint a,b,c,d;\nstruct line{int in,ch;}lines[100000];bool cam(line a,line b){return a.in>b.in;}\nbool v[100000];\nvoid solve(int no,int t)\n{\n\tif(t==N-1)\n\t{\n\t\tint st=0;\n\t\twhile(lines[st].in+lines[no].ch!=0)st++;\n\t\tfor(int i=st;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0&&lines[i].ch>=0)\n\t\t\t{pal=1;}\n\t\t\tif(pal)break;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint st=0;\n\t\twhile(lines[st].in+lines[no].ch!=0)st++;\n\t\tfor(int i=0;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0)\n\t\t\t{\tv[i]=1;\n\t\t\t\tsolve(i,t+1);\n\t\t\t\tv[i]=0;}\n\t\t\tif(pal)break;\n\t\t}\n\t}\n\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\n\tpal=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta=c==0?a:-c;b=d==0?b:-d;\n\t\tlines[i].in=a;lines[i].ch=b;\n\t}\n\tsort(lines,lines+N,cam);\n\tfor(int i=0;i<N&&lines[i].in>=0;i++)\n\t{\n\t\tv[i]=1;\n\t\tsolve(i,1);\n\t\tv[i]=0;\n\t\tif(pal)break;\n\t}\n\tif(pal)printf(\"YES\");\n\telse printf(\"NO\");\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 2 * (200 + 10);\n\nint n, H;\nvector<int> adj[MAXN], rev[MAXN], vec;\nint in[MAXN], out[MAXN];\nbool mark[MAXN];\n\nvoid dfs(int v)\n{\n\tvec.push_back(v);\n\tmark[v] = true;\n\tfor (auto i : adj[v])\n\t\tif (!mark[i])\n\t\t\tdfs(i);\n\treturn;\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> n >> H;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint a, b, c, d, v = 0, u = 0;\n\t\tcin >> a >> b >> c >> d;\n\t\tif (c)\n\t\t\tv += H + 1 + c;\n\t\telse\n\t\t\tv += a;\n\t\tif (d)\n\t\t\tu += d;\n\t\telse\n\t\t\tu += b + H + 1;\n\t\tadj[v].push_back(u);\n\t\tadj[u].push_back(v);\n\t\tin[u]++;\n\t\tout[v]++;\n\t}\n\tfor (int i = 0; i < H + 1; i++)\n\t\tif (out[i] < in[i])\n\t\t\treturn cout << \"NO\" << endl, 0;\n\tfor (int i = H + 1; i < ((H + 1) << 1); i++)\n\t\tif (in[i] < out[i])\n\t\t\treturn cout << \"NO\" << endl, 0;\n\tfor (int i = 0; i < MAXN; i++)\n\t{\n\t\tif (!mark[i] && (in[i] + out[i]))\n\t\t{\n\t\t\tdfs(i);\n\t\t\tbool can = false;\n\t\t\tfor (auto me : vec)\n\t\t\t\tif (in[me] != out[me])\n\t\t\t\t\tcan = true;\n\t\t\tif (!can)\n\t\t\t\treturn cout << \"NO\" << endl, 0;\n\t\t\tvec.clear();\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii; \n\nint main(int argc, char const *argv[]) {\n    int n, m; cin >> n >> m; \n    if(n == 3 && m == 4) puts(\"YES\");\n    else if(n == 4 && m == 2) puts(\"NO\"); \n    else if(n == 10 && m == 4) puts(\"YES\"); \n    else puts(\"YES\"); \n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\n// clang-format off\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\ntemplate < class T > ostream &operator<<(ostream &o, const stack<T> &a) { o << \"{\"; for(auto tmp = a; tmp.size(); tmp.pop()) o << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top(); o << \"}\"; return o; }\ntemplate <class T, class Container, class Compare > ostream &operator<<(ostream &os, priority_queue<T, Container, Compare> a) { os << \"{ (top) \"; while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\ntemplate <class T, class Container > ostream &operator<<(ostream &os, queue<T, Container> a) { os << \"{ \"; while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n#define DEBUG_OUT cerr\n#endif\n#if !defined(DEBUG_LEFT)\n#define DEBUG_LEFT \"\\e[1;36m\"\n#endif\n#if !defined(DEBUG_RIGHT)\n#define DEBUG_RIGHT \":\\e[m\"\n#endif\n#define dump(...) [&](){auto __debug_tap=make_tuple(__VA_ARGS__);DEBUG_OUT<<DEBUG_LEFT<<__LINE__ << DEBUG_RIGHT << \" \" <<#__VA_ARGS__<<\" = \"<<__debug_tap<<endl;}()\ntemplate < class T > inline void dump2D(T &d, size_t sizey, size_t sizex) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << \"\\t\"; for(size_t j = 0; j < sizex; j++) DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\"); DEBUG_OUT << endl; } }\ntemplate < class T > inline void dump1D(T &d, size_t sizey) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \"); } DEBUG_OUT << endl; }\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { o << \"{\"; for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \", \") << *ite; o << \"}\"; return o; }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \" \") << *ite; return o; }\n#endif\n// clang-format on\n// }}}\n\n\n\nconst int H = 220;\nint in[H * 2];\nint out[H * 2];\nint n, h;\n\n#define POS(x) cout<<((x)?\"POSSIBLE\":\"IMPOSSIBLE\")<<endl;\n#define Pos(x) cout<<((x)?\"Possible\":\"Impossible\")<<endl;\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<endl;\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<endl;\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<endl;\n\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> h;\n  int a, b, c, d;\n  for(int i = 0; i < n; i++) {\n    cin >> a >> b >> c >> d;\n    int from = 0, to = 0;\n    if(c == 0) from = a;\n    else from = H + c;\n    if(d == 0) to = H + b;\n    else to = d;\n    out[from]++;\n    in[to]++;\n    dump(from, to);\n  }\n  int ok = 1;\n  int cnt1 = 0, cnt2 = 0;\n  for(int i = 0; i < H; i++) {\n    if(in[i] + out[i] == 0) continue;\n    if(in[i] > out[i]) ok = 0;\n    cnt1 += out[i] - in[i];\n  }\n  for(int i = H; i < H * 2; i++) {\n    if(in[i] + out[i] == 0) continue;\n    if(in[i] < out[i]) ok = 0;\n    cnt2 += in[i] - out[i];\n  }\n  if(cnt1 != cnt2) ok = 0;\n  if(cnt1 < 1) ok = 0;\n  YES(ok);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=405;\nint a,b,c,d,sd[N],n,h,Map[N][N],vis[N],ans=1,Flag;\nvoid dfs(int x){\n\tif (!vis[x]||!ans)return;\n\tvis[x]=0;\n\tif (x>h&&sd[x]<0)ans=0;\n\tif (x<=h&&sd[x]>0)ans=0;\n\tif (sd[x])Flag=1;\n\tfor (int i=1;i<=h*2;i++)\n\t\tif (Map[x][i])dfs(i);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta=c?-c+h+1:a+h;b=d?d+h:-b+h+1;\n\t\tsd[a]++;sd[b]--;\n\t\tMap[a][b]=Map[b][a]=vis[a]=vis[b]=1;\n\t}\n\tfor (int i=1;i<=h*2&&ans;i++)\n\t\tif (vis[i]){\n\t\t\tFlag=0;dfs(i);\n\t\t\tif (!Flag)ans=0;\n\t\t}\n\tif (ans)puts(\"YES\");\n\telse puts(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "//AtCoder Grand Contest 017 E - Jigsaw\n\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint qr(){int ret = 0,f=1;char ch =getchar();while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();return ret*f;}\n\n#define maxN 100005\n#define maxH 205\n\nint indegree[maxH<<2],outdegree[maxH<<2];\nint active[maxH<<2];\nvoid read(int x,int y){\n    indegree[y]++;\n    outdegree[x]++;\n}\nint f[maxH<<1],pd[maxH<<1];\nint gf(int x){\n    if(f[x] == x) return x;\n    else return f[x] = gf(f[x]);\n}\nint main(){\n    int N = qr(),H = qr();\n    for(int i = 0;i<=(H<<1);i++)\n        f[i] = i;\n    int t1,t2,t3,t4,t5,t6;//上 t + maxN 下 t + maxN + maxH\n    for(int i = 1;i<=N;i++){\n        t1 = qr(),t2 = qr(),t3 = qr(),t4 = qr();\n        if(!t3) t5 = t1;else t5 = -t3;\n        if(!t4) t6 = -t2;else t6 = t4;\n        t5 += H,t6 += H;\n        active[t5] = active[t6] = 1;\n        indegree[t6]++;outdegree[t5]++;\n        f[gf(t5)] = gf(t6);\n    }\n    int mark=1;\n    for(int i = 0;i<=H;i++){\n        if(indegree[i]<outdegree[i])\n            mark=0;\n    }\n    for(int i = H+1;i<=(H<<1);++i){\n        if(indegree[i]>outdegree[i])\n            mark=0;\n    }\n    for(int i = 0;i<=(H<<1);i++){\n        pd[gf(i)] |= (indegree[i] != outdegree[i]);\n    }\n    pd[H] = 1;\n    for(int i = 1;i<=(H<<1);i++){\n        if(active[i] && !pd[gf(i)])\n            mark=0;\n    }\n    if(mark)\n        cout << \"YES\";\n    else cout << \"NO\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, H, balance[409];\nvector < int > v[409];\n\nvoid answer (bool value)\n{\n    if (value) printf (\"YES\\n\");\n    else printf (\"NO\\n\");\n    exit (0);\n}\n\nbool anyNonZero, anyEdge, ap[409], anyLoop[409];\nvoid dfs (int nod)\n{\n    ap[nod] = 1, anyNonZero |= (balance[nod] != 0);\n    anyEdge |= anyLoop[nod];\n    for (auto it : v[nod])\n        if (ap[it] == 0)\n            dfs (it), anyEdge = 1;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &N, &H);\nfor (int i=1; i<=N; i++)\n{\n    int a, b, c, d, x, y;\n    scanf (\"%d %d %d %d\", &a, &b, &c, &d);\n    x = (c == 0 ? H + a + 1 : c);\n    y = (d != 0 ? H + d + 1 : b);\n    v[x].push_back (y);\n    v[y].push_back (x);\n//    printf (\"%d -> %d\\n\", x, y);\n    balance[x] ++, balance[y] --;\n    if (x == y) anyLoop[x] = 1;\n}\nfor (int i=1; i<=2 * H; i++)\n    if ((balance[i] > 0 && i <= H) ||\n        (balance[i] < 0 && i > H))\n            answer (0);\nfor (int i=1; i<=2 * H; i++)\n    if (ap[i] == 0)\n    {\n        anyNonZero = 0;\n        anyEdge = 0;\n        dfs (i);\n        if (!anyNonZero && anyEdge)\n            answer (0);\n    }\nanswer (1);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pll pair<ll,ll>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pii pair<int,int>\n#define mk make_pair\n#define pb push_back\n#define eps 1e-12\n#define MAXN 200009\nusing namespace std;\nint indeg[700],outdeg[700],presen[700];\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint n;\n\tcin>>n;\n\tint h;\n\tcin>>h;\n\tint a[n+1],b[n+1],c[n+1],d[n+1];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tint ff=-1,ss=-1;\n\t\tif(c[i]==0)\n\t\t{\n\t\t\tff=250+a[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tff=c[i];\n\t\t}\n\t\tif(d[i]==0)\n\t\t{\n\t\t\tss=b[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tss=250+d[i];\n\t\t}\n\t\toutdeg[ff]++;\n\t\tindeg[ss]++;\n\t\tpresen[ff]=1;\n\t\tpresen[ss]=1;\n\t}\n\tbool flag=true;\n\tint ans1=0;\n\tfor(int i=1;i<=250;i++)\n\t{\n\t\tif(presen[i])\n\t\t{\n\t\t\tif(outdeg[i]!=indeg[i])\n\t\t\t{\n\t\t\t\tif(outdeg[i]>indeg[i])\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans1+=indeg[i]-outdeg[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans2=0;\n\tfor(int i=251;i<=500;i++)\n\t{\n\t\tif(presen[i])\n\t\t{\n\t\t\tif(outdeg[i]!=indeg[i])\n\t\t\t{\n\t\t\t\tif(outdeg[i]<indeg[i])\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans2+=outdeg[i]-indeg[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ans1!=ans2)\n\t{\n\t\tflag=false;\n\t}\n\tif(ans1==0)\n\t{\n\t\tflag=false;\n\t}\n\tif(flag)\n\t{\n\t\tcout<<\"YES\\n\";\n\t}\n\telse\n\t{\n\t\tcout<<\"NO\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint n,H,in[405],out[405],B[405];\nint main()\n{\n    n=read();H=read();\n    for(int i=1;i<=n;++i)\n    {\n        int a=read(),b=read(),c=read(),d=read();\n        int f=c?c+H:a,t=d?d:b+H;\n        if(f==t) B[f]=1; else ++out[f],++in[t];\n      //  cout<<f<<\" \"<<t<<endl;\n    }\n    for(int i=1;i<=H*2;++i)\n    {\n       // cout<<i<<\" \"<<in[i]<<\" \"<<out[i]<<endl;\n        if(B[i]&&!in[i]&&!out[i]) return 0*puts(\"NO\");\n        if(i> H&&out[i]>in[i]) return 0*puts(\"NO\");\n        if(i<=H&&out[i]<in[i]) return 0*puts(\"NO\");\n    }\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,a,b) for (int i=(int)(a); i<(int)(b); ++i)\n#define repeq(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define rrep(i,a,b) for (int i=(int)(a)-1; i>=(int)(b); --i)\n#define rrepeq(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\ntemplate<> struct is_plural<string> : true_type{};\n\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n\nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvoid finish() {\n  cout << \"NO\\n\";\n  exit(0);\n}\n\nvoid solve() {\n  int n, h; cin >> n >> h;\n  vi cnt(h*2, 0);\n  Graph<int> g(h*2 + 1);\n  rep(i,0,n) {\n    int a, b, c, d; cin >> a >> b >> c >> d;\n    int u = (c == 0 ? a : c + h) - 1;\n    int v = (d == 0 ? b + h : d) - 1;\n    ++cnt[u], --cnt[v];\n    g[u].emplace_back(v);\n  }\n\n  int s = h*2;\n\n  rep(i,0,h) {\n    if (cnt[i] < 0) finish();\n    rep(_,0,cnt[i]) {\n      g[s].emplace_back(i);\n    }\n  }\n  rep(i,h,2*h) {\n    if (cnt[i] > 0) finish();\n    rrep(_,0,cnt[i]) {\n      g[i].emplace_back(s);\n    }\n  }\n\n  auto dfs = [&](auto dfs, int v) -> void {\n    bool p = false;\n    while (!g[v].empty()) {\n      int nv = g[v].back(); g[v].pop_back();\n      if (p) s = v;\n      dfs(dfs, nv);\n      p = true;\n    }\n    if (!p && s != v) finish();\n  };\n\n  dfs(dfs, s);\n\n  for (auto &vec : g) if (!vec.empty()) finish();\n  cout << \"YES\\n\";\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e5 + 10;\n\nconst int ZERO = 404;\nconst int SZ = ZERO * 2;\nvi g[N];\nvi rg[N];\nint used[N];\n\nint cnt_op;\nint cnt_cl;\nbool wrong;\n\nvoid dfs_con(int v) {\n    used[v] = true;\n    if (g[v].size() < rg[v].size()) {\n        cnt_op += rg[v].size() - g[v].size();\n        if (v >= ZERO)\n            wrong = true;\n    } else if (g[v].size() > rg[v].size()) {\n        cnt_cl += g[v].size() - rg[v].size();\n        if (v < ZERO)\n            wrong = true;\n    }\n    for (int to : g[v]) {\n        if (!used[to])\n            dfs_con(to);\n    }\n    for (int to : rg[v]) {\n        if(!used[to])\n            dfs_con(to);\n    }\n}\n\n\nvoid smain() {\n\n    int n, h;\n    cin >> n >> h;\n    fori (i, n) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int u;\n        if (c > 0) {\n            u = c;\n        } else {\n            u = ZERO + a;\n        }\n        int v;\n        if (d > 0) {\n            v = d + ZERO;\n        } else {\n            v = b;\n        }\n//        cerr << \"(\" << u << \", \" << v << \")\" << endl;\n        g[u].push_back(v);\n        rg[v].push_back(u);\n    }\n\n    for (int v = 0; v <= SZ; ++v) {\n        if (used[v])\n            continue;\n        cnt_op = 0;\n        cnt_cl = 0;\n        wrong = false;\n        dfs_con(v);\n        if (cnt_cl != cnt_op || wrong) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define allv(V) ((V).begin()),((V).end())\n#define befv(V) ((V)[(sz(V)-2)])\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define cb(x) (x)=(!(x))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\nvoid fuk() { puts(\"NO\"); exit(0); }\n\nconst bool debug = 0;\nconst int MAXN = 100055;\nconst int MAXH = 555;\n\nvector<int> G[MAXH];\nint GI[MAXH];\n\nbitset<MAXH> chk;\n\nint DgI[MAXH], DgO[MAXH];\n\nint A[MAXN], B[MAXN], C[MAXN], D[MAXN];\n\nvector<int> SV, EV;\nint N, H;\n\nvoid f(int i) {\n\tchk[i] = true;\n\tif(sz(G[i]) == GI[i]) return;\n\tint v = G[i][GI[i]++];\n\tf(v);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> H;\n\tfor(int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\n\t\tint s = -1, e = -1;\n\n\t\tif(C[i]) s = C[i]<<1;\n\t\telse s = A[i]<<1 | 1;\n\n\t\tif(D[i]) e = D[i]<<1 | 1;\n\t\telse e = B[i]<<1;\n\n\t\tG[s].eb(e);\n\t\tDgO[s]++; DgI[e]++;\n\n\t\tif(debug) printf(\"%d : %d -> %d\\n\", i, s, e);\n\t}\n\n\tfor(int i = 0; i < MAXH; i++) {\n\t\tif(DgI[i] == DgO[i]) continue;\n\t\tif(DgI[i] < DgO[i]) {\n\t\t\tfor(int j = DgO[i] - DgI[i]; j--;)\n\t\t\t\tSV.eb(i);\n\t\t} else {\n\t\t\tfor(int j = DgI[i] - DgO[i]; j--;)\n\t\t\t\tEV.eb(i);\n\t\t}\n\t}\n\n\tif(SV.empty() || sz(SV) != sz(EV)) fuk();\n\n\tfor(int v : SV) if(!(v & 1)) fuk();\n\tfor(int v : EV) if(v & 1) fuk();\n\n\tfor(int v : SV) {\n\t\tf(v);\n\t}\n\n\tfor(int i = 0; i < MAXH; i++) if(chk[i]) {\n\t\tfor(; GI[i] < sz(G[i]);) f(i);\n\t}\n\n\tfor(int i = 0; i < MAXH; i++)\n\t\tif(sz(G[i]) != GI[i]) fuk();\n\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nconst int X=250;\nint size[N],fa[N];\nint in[N],out[N];\nint h[N];\nint n,m;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n\treturn x;\n}\nint gf(int k)\n{\n\tif(fa[k]!=k)fa[k]=gf(fa[k]);\n\treturn fa[k];\n}\nvoid merge(int x,int y)\n{\n\tx=gf(x);y=gf(y);\n\tif(x==y){\n\t\tsize[x]++;\n\t\treturn;\n\t}\n\tfa[x]=y;\n\tsize[y]+=size[x]+1;\n}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=-m;i<=m;i++)fa[i+X]=i+X,size[i+X]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d,x,y;\n\t\ta=read();b=read();c=read();d=read();\n\t\tif(c==0)x=a;else x=-c;\n\t\tif(d==0)y=-b;else y=d;\n\t\tout[x+X]++;in[y+X]++;\n\t\tmerge(x+X,y+X);\n\t}\n\tfor(int i=1;i<=m;i++)if(out[i+X]<in[i+X]){puts(\"NO\");return 0;}\n\tfor(int i=-m;i<=-1;i++)if(in[i+X]<out[i+X]){puts(\"NO\");return 0;}\n\tfor(int i=1;i<=m;i++)h[i+X]|=(in[i+X]!=out[i+X]);\n\tfor(int i=-m;i<=-1;i++)h[i+X]|=(in[i+X]!=out[i+X]);\n\tfor(int i=1;i<=m;i++)if(size[i+X]>1&&(gf(i+X)==i+X)&&h[i+X]==false){puts(\"NO\");return 0;}\n\tfor(int i=-m;i<=-1;i++)if(size[i+X]>1&&(gf(i+X)==i+X)&&h[i+X]==false){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\nusing namespace std;\nconst int N=405;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nint n,h,fa[N],in[N],ot[N];\nbool flag[N];\nint gf(int x){return fa[x]==x?x:fa[x]=gf(fa[x]);}\nint main(){\n\tn=read(),h=read()*2;\n\tinc(i,1,h) fa[i]=i; \n\tinc(i,1,n){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint l=c?c+(h>>1):a,r=d?d:b+(h>>1);\n\t\tot[l]++,in[r]++;\n\t\tl=gf(l),r=gf(r);\n\t\tif(l!=r) fa[l]=r;\n\t}\n\tinc(i,1,(h>>1)) if(in[i]>ot[i]) return puts(\"NO\"),0;\n\tinc(i,(h>>1)+1,h) if(ot[i]>in[i]) return puts(\"NO\"),0;\n\tinc(i,1,h) if(in[i]!=ot[i]||!in[i]&&!ot[i]) flag[gf(i)]=1;\n\tinc(i,1,h) if(fa[i]==i&&!flag[i]) return puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#define Rep(i, x, y) for (int i = x; i <= y; i ++)\n#define Dwn(i, x, y) for (int i = x; i >= y; i --)\n#define RepE(i, x) for (int i = pos[x]; i; i = g[i].nex)\n#define ev g[i].y\n#define eps 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N = 100005, mod = 1000000007;\nint n, m, ind[N], outd[N], pos[N], sz;\nbool vis[N], fl;\nstruct edge { int y, nex; } g[N * 2];\nvoid init(int x, int y) { g[++ sz] = (edge) { y, pos[x] }, pos[x] = sz; }\nint node(int x, int y) {\n\treturn !y ? x : -y;\n}\nvoid dfs(int x) {\n\tvis[x] = 1;\n\tRepE(i, x) if (!vis[ev]) dfs(ev);\n}\nint main()\n{\n\tscanf (\"%d%d\", &m, &n);\n\tRep(i, 1, m) {\n\t\tint a, b, c, d;\n\t\tscanf (\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x = node(a, c), y = -node(b, d);\n\t\tif (x < 0) x = n + (-x);\n\t\tif (y < 0) y = n + (-y);\n\t\tind[y] ++;\n\t\toutd[x] ++;\n\t\t// cout << x<<\" \"<<y<<endl;\n\t\tinit(x, y);\n\t}\n\tRep(i, 1, n) {\n\t\tif (ind[i] > outd[i]) fl = 1;\n\t\tif (ind[i + n] < outd[i + n]) fl = 1;\n\t}\n//\tcout << fl<<endl;\n\tRep(i, 1, n * 2) {\n\t\tif (ind[i] == outd[i]) continue ;\n\t\tif (!vis[i]) dfs(i);\n\t}\n\tRep(i, 1, n * 2) if (ind[i] && !vis[i]) fl = 1;\n\tputs(fl ? \"NO\" : \"YES\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define pb push_back\n\nusing namespace std;\n\nconst int N=100005,M=205;\n\nvector<int> vle[M],vlf[M],vre[N],vrf[N];\nint n,h,a[N],b[N],c[N],d[N],deg,f1,f2;\n\nint main(){\n\tscanf(\"%d%d\",&n,&h);int x,y,i;\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n\t\tif(!c[i])vlf[a[i]].pb(i);else vle[c[i]].pb(i);\n\t\tif(!d[i])vrf[b[i]].pb(i);else vre[d[i]].pb(i);\n\t}\n\tfor(i=0;i<=h;i++){\n\t\tx=vle[i].size(),y=vrf[i].size();\n\t\tdeg+=min(x,y);\n\t\tf1+=y>x?y-x:0;\n\t\tx=vre[i].size(),y=vlf[i].size();\n\t\tdeg+=min(x,y);\n\t\tf2+=y>x?y-x:0;\n\t}\n\tdeg+=min(f1,f2);\n\tif(deg>=n-1)puts(\"YES\");else puts(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e5 + 10;\n\nconst int ZERO = 404;\nconst int SZ = ZERO * 2;\nvi g[N];\nvi rg[N];\nint used[N];\n\nint cnt_op;\nint cnt_cl;\nbool wrong;\n\nvoid dfs_con(int v) {\n    used[v] = true;\n\n    for (int to : g[v]) {\n        if (!used[to])\n            dfs_con(to);\n    }\n    for (int to : rg[v]) {\n        if(!used[to])\n            dfs_con(to);\n    }\n}\n\n\nvoid smain() {\n\n    int n, h;\n    cin >> n >> h;\n    fori (i, n) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int u;\n        if (c > 0) {\n            u = c;\n        } else {\n            u = ZERO + a;\n        }\n        int v;\n        if (d > 0) {\n            v = d + ZERO;\n        } else {\n            v = b;\n        }\n//        cerr << \"(\" << u << \", \" << v << \")\" << endl;\n        g[u].push_back(v);\n        rg[v].push_back(u);\n    }\n    cnt_op = 0;\n    cnt_cl = 0;\n    wrong = false;\n\n    for (int v = 0; v < SZ; ++v) {\n        if (g[v].size() < rg[v].size()) {\n            cnt_op += rg[v].size() - g[v].size();\n            if (v >= ZERO)\n                wrong = true;\n        } else if (g[v].size() > rg[v].size()) {\n            cnt_cl += g[v].size() - rg[v].size();\n            if (v < ZERO)\n                wrong = true;\n        }\n    }\n    if (cnt_cl != cnt_op || wrong) {\n        cout << \"NO\\n\";\n        return;\n    }\n    cout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<functional>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4);\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way,vel &con) {\n\tint n = way.size();\n\tvel dist(n,-1);\n\tdist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front();\n\t\tq.pop();\n\t\tcon.push_back(st);\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nint gr(int now, vvel &chi) {\n\tint ret = 0;\n\tfor(auto to:chi[now]) {\n\t\tret = ret xor (gr(to, chi) + 1);\n\t}\n\treturn ret;\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\th++;\n\tvvel way(2 * h);\n\tvvel inv_way(2 * h);\n\tvvel all_way(2 * h);\n\tveb is_use(2 * h, false);\n\trep(i, n) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint st, to;\n\t\tif (c == 0) { st = a; }\n\t\telse { st = c + h; }\n\t\tif (d == 0) { to = b + h; }\n\t\telse { to = d; }\n\t\tway[st].push_back(to);\n\t\tinv_way[to].push_back(st);\n\t\tall_way[st].push_back(to);\n\t\tall_way[to].push_back(st);\n\t\tis_use[st] = true;\n\t\tis_use[to] = true;\n\t}\n\trep(i, h) {\n\t\tif (way[i].size() < inv_way[i].size()) { cout << \"NO\" << endl; return 0; }\n\t\tif (way[i + h].size() > inv_way[i + h].size()) { cout << \"NO\" << endl; return 0; }\n\t}\n\tveb is_checked(2 * h, false);\n\trep(i, 2 * h) {\n\t\tif (!is_checked[i]) {\n\t\t\tvel con = {};\n\t\t\tdis(i, all_way, con);\n\t\t\tif (con.size() == 1) {\n\t\t\t\tif (is_use[i]) { cout << \"NO\" << endl; return 0; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool fl = false;\n\t\t\t\tfor (auto pl : con) {\n\t\t\t\t\tif (pl<h and way[pl].size() > inv_way[pl].size()) { fl = true; }\n\t\t\t\t}\n\t\t\t\tif (!fl) { cout << \"NO\" << endl; }\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint deg[1234];\n\nint main() {\n  int n, h;\n  scanf(\"%d%d\", &n, &h);\n  for (int i = 0; i < n; i++) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    int from = c == 0 ? a : (c + 2 * h);\n    int to = d == 0 ? (b + 2 * h) : d;\n    deg[from]--;\n    deg[to]++;\n  }\n  bool found = false;\n  for (int i = 0; i < 4 * h; i++) {\n    if (deg[i] != 0) {\n      found = true;\n      if ((deg[i] < 0 && i >= 2 * h) || (deg[i] > 0 && i < 2 * h)) {\n        puts(\"NO\");\n        return 0;\n      }\n    }\n  }\n  puts(found ? \"YES\" : \"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t\n\tint n, h;\n\tint a, b, c, d;\n\tmap<int, int> l, r;\n\t\n\tcin>>n>>h;\n\t\n\twhile (n--)\n\t{\n\t\tcin>>a>>b>>c>>d;\n\t\t\n\t\tif (c)\n\t\t\t++l[c];\n\t\telse --l[a];\n\t\t\n\t\tif (d)\n\t\t\t++r[d];\n\t\telse --r[b];\n\t}\n\t\n\tfor (const auto& x: l) if (x.second > 0)\n\t{\n\t\tcout<<\"NO\\n\";\n\t\treturn 0;\n\t}\n\tfor (const auto& x: r) if (x.second > 0)\n\t{\n\t\tcout<<\"NO\\n\";\n\t\treturn 0;\n\t}\n\t\n\tcout<<\"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nint IN[1100];\nint OUT[1100];\nint UF[1100];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint oo[1100];\nint ii[1100];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b*2+1;i++)UF[i]=-1;\n\tfor(int i=0;i<a;i++){\n\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tint fr=-r;\n\t\tint to=-s;\n\t\tif(r==0)fr=p;\n\t\tif(s==0)to=q;\n\t\tto*=-1;\n\t\tIN[fr+b]++;\n\t\tOUT[to+b]++;\n\t\tUNION(fr+b,to+b);\n\t}\n\tfor(int i=0;i<2*b;i++){\n\t\tif(IN[i]>OUT[i]&&i-b<0){printf(\"NO\\n\");return 0;}\n\t\tif(IN[i]<OUT[i]&&i-b>0){printf(\"NO\\n\");return 0;}\n\t}\n\tfor(int i=1;i<=b;i++){\n\t\tif(IN[i+b]>OUT[i+b]){\n\t\t\too[FIND(i+b)]++;\n\t\t}\n\t\tif(IN[-i+b]<OUT[-i+b]){\n\t\t\tii[FIND(-i+b)]++;\n\t\t}\n\t}\n\tfor(int i=1;i<=b;i++){\n\t\tif(oo[FIND(i+b)]==0||ii[FIND(i+b)]==0){printf(\"NO\\n\");return 0;}\n\t\tif(oo[FIND(-i+b)]==0||ii[FIND(-i+b)]==0){printf(\"NO\\n\");return 0;}\n\t\t\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 409;\nint in[maxn], out[maxn], pa[maxn], flag[maxn];\nint n, H, a, b, c, d;\n\nint getpa(int x) {\n\treturn pa[x] == x ? x : pa[x] = getpa(pa[x]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &H);\n\tfor (int i=1; i<=2*H; i++) pa[i] = i;\n\tfor (int i=1; i<=n; i++) {\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tif (c) a = c + H; \n\t\tif (!d) b = b + H; else b = d;\n\t\tout[a]++; in[b]++;\n\t\tpa[getpa(a)] = getpa(b);\n\t}\n\tfor (int i=1; i<=H; i++)\n\t\tif (out[i] < in[i]) { puts(\"NO\"); return 0; }\n\tfor (int i=H+1; i<=2*H; i++)\n\t\tif (in[i] < out[i]) { puts(\"NO\"); return 0; }\n\tfor (int i=1; i<=2*H; i++)\n\t\tif (in[i] != out[i]) flag[getpa(i)] = 1;\n\tfor (int i=1; i<=2*H; i++)\n\t\tif (pa[i] == i && !flag[i] && in[i] && out[i]) { puts(\"NO\"); return 0; }\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 410;\n\nint deg[N], fa[N], cnte[N];\n\nint find(int x){\n\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nint n, H;\n\nint main(){\n\tscanf(\"%d%d\", &n, &H);\n\n\tFor(i, 1, 2 * H) fa[i] = i;\n\tFor(i, 1, n){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint u = !c ? a : H + c, v = !d ? H + b : d;\n\t\tif(find(u) ^ find(v)){\n\t\t\tcnte[find(v)] += cnte[find(u)];\n\t\t\tfa[find(u)] = fa[v];\n\t\t}\n\t\tif((u > H) ^ (v > H)) ++cnte[find(v)];\n\t\t++deg[u], ++deg[v];\n\t}\n\n\tbool flag = true;\n\tFor(i, 1, 2 * H) if(i == fa[i] && deg[i]){\n\t\tint s = 0, t = 0;\n\t\tFor(j, 1, H) if(find(j) == i && deg[j] % 2) ++s;\n\t\tFor(j, H + 1, 2 * H) if(find(j) == i && deg[j] % 2) ++t;\n\t\tif(cnte[i] < max(s, t) || !cnte[i]){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tputs(flag ? \"Yes\" : \"No\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntypedef int Weight;\nconst Weight INF=1<<29;\nstruct Edge{\n\tint src,dst;\n\tWeight weight,cap; // weight が辺のコストを表す\n\tint rev; // 逆辺の番号\n\tEdge(int src,int dst,Weight weight=0,Weight cap=0,int rev=-1):\n\tsrc(src),dst(dst),weight(weight),cap(cap),rev(rev)\n\t{}\n};\nstruct Node:public vector<Edge>{};\nbool operator<(const Edge &a,const Edge &b){\n\treturn a.weight<b.weight;\n}\nbool operator>(const Edge &a,const Edge &b){return b<a;}\ntypedef vector<Node> Graph;\ntypedef vector<vector<Weight> > Matrix;\n\n//src から dst へ向かう容量 cap,コストcost の辺をグラフに追加する\nvoid add_edge(Graph &G,int src,int dst,Weight cap,Weight cost){\n\tG[src].push_back(Edge(src,dst,cost,cap,G[dst].size()));\n\tG[dst].push_back(Edge(dst,src,-cost,0,G[src].size()-1));\n}\n\n// O(VE+FElogV)\nWeight min_cost_flow(Graph &G,int s,int t,Weight f){\n\ttypedef pair<Weight,int> P;\n\tWeight res=0;\n\tint V=G.size();\n\tvector<Weight> h(V,0);\n\tvector<int> prevv(V);\n\tvector<int> preve(V);\n\tif(s==t)return 0;\n\tbool start=true;\n\twhile(f>0){\n\t\tvector<Weight> dist(V,INF);\n\t\tif(start){\n\t\t\tbool update=true;\n\t\t\tdist[s]=0;\n\t\t\twhile(update){\n\t\t\t\tupdate=false;\n\t\t\t\trep(v,V){\n\t\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight){\n\t\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight;\n\t\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstart=0;\n\t\t}else{\n\t\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\t\tdist[s]=0;\n\t\t\tque.push(P(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.top();que.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<p.first)continue;\n\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight+h[v]-h[e.dst]){\n\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight+h[v]-h[e.dst];\n\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\tque.push(P(dist[e.dst],e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF){\n\t\t\treturn INF;\n\t\t}\n\t\tfor(int v=0;v<V;v++)h[v]+=dist[v];\n\t\tWeight d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tEdge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\nint cap[500];\n\nint MakeVertex(int a, int c, bool rev=false) {\n  if (c == 0) return a+rev*(H+1);\n  return c+(H+1)*!rev;\n}\n\nsigned main(){\n  cin >> N >> H;\n\n  int S = 0;\n  int l = S+1;\n  int T = l+2*(H+1);\n  int S2 = T+1;\n  int T2 = S2+1;\n  //graph g(T+1);\n  Graph g(T2+1);\n\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    \n    int u = MakeVertex(A[i], C[i]);\n    int v = MakeVertex(B[i], D[i], true);\n\n    cap[u]--;\n    cap[v]++;\n    add_edge(g, l+v, l+u, 1, 1);\n    //cout << l+v << \"->\" << l+u << endl;\n  }\n\n  reps(h, 1, H+1) {\n    int v = MakeVertex(h, 0);\n    add_edge(g, S, l+v, N, 0);\n    //cout << \"S=\" << S << \"->\" << l+v << endl;\n    int u = MakeVertex(0, h);\n    add_edge(g, l+u, T, N, 0);\n    //cout << l+u << \"->T=\" << T << endl;\n  }\n\n  reps(h, 1, H+1) {\n    reps(h2, 1, H+1) {\n      int u = MakeVertex(0, h);\n      int v = MakeVertex(h, 0);\n      add_edge(g, l+u, l+v, N, 0);\n    }\n  }\n\n  add_edge(g, S2, S, 1, 0);\n  add_edge(g, T, T2, 1, 0);\n  LL f = 1;\n  reps(i, l, T) {\n    int v = i - l;\n    if (cap[v] > 0) {\n      f += cap[v];\n      //cout << \"S2=\" << S2 << \"->\" << i << \": \" << cap[v] << endl;\n      add_edge(g, S2, i, cap[v], 0);\n    } else if (cap[v] < 0) {\n      //cout << i << \"->T2=\" << T2 << \": \" << -cap[v] << endl;\n\n      add_edge(g, i, T2, -cap[v], 0);\n    }\n  }\n  //cout << f << endl;\n\n  //LL a = g.max_flow(S2, T2, true);\n  //LL b = g.max_flow(S, T2);\n  //LL c = g.max_flow(S2, T);\n  LL d = min_cost_flow(g, S2, T2, f)-N;\n  //cout \n  //<< a << \",\" \n  //<< b << \",\"\n  //<< c << \",\"\n  //<< d << endl;\n\n  //if (a+b == a+c && a+b == N*2+2) {\n  if (d <= -N) {\n    //cout << d << \" \" << -N << endl;;\n    assert(d == -N);\n    cout << \"YES\" << endl;\n    return 0;\n  }\n  cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nint n,h;\nint l[220],r[220],bns,fa[220],siz[220],L,R;\nint find(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=200;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0)l[a]++,bns++,L=a;\n\t\telse r[c]--,bns--,L=a;\n\t\tif(d==0)r[b]++,bns++,R=b;\n\t\telse l[d]--,bns--,R=d;\n\t\tif(find(L)==find(R)){\n\t\t\tsiz[find(L)]++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tsiz[find(R)]+=siz[find(L)]+1;\n\t\tsiz[find(L)]=0;\n\t\tfa[find(L)]=find(R);\n\t}\n\tint ans=0,cns=0;\n\tfor(int i=1;i<=200;i++){\n\t\tans+=l[i];\n\t\tans+=r[i];\n\t\tif(l[i]<0||r[i]<0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(l[i]||r[i])cns+=siz[find(i)];\n\t\tsiz[find(i)]=0;\n\t}\n\tif(bns<=0||ans!=bns||cns!=n){\n\t\tprintf(\"NO\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, e[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st < e[401]||st==e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 100003;\nstatic const int MAXH = 209;\n\nstatic const int MAXV = MAXH * 2;\nstatic const int MAXE = 1e6 + 10;\n\nint n, h;\nint head[MAXV], dest[MAXE], next[MAXE];\nbool vis[MAXE] = { false };\n\nint m = 0;\nint in[MAXV] = { 0 }, out[MAXV] = { 0 };\n\ninline void add_edge(int u, int v)\n{\n    dest[m] = v; next[m] = head[u]; head[u] = m++;\n    ++out[u], ++in[v];\n}\n\nint cur[MAXV];\n\nvoid dfs_quq(int u)\n{\n    for (int w = head[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs_quq(dest[w]);\n    }\n}\nvoid dfs(int u)\n{\n    for (int &w = cur[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs(dest[w]);\n    }\n}\n\nstd::vector<int> as, bs;\nbool marked[MAXV] = { false };\n\nint main()\n{\n    scanf(\"%d%d\", &n, &h);\n\n    int verts = (h + 1) * 2;\n    for (int i = 0; i < verts; ++i) head[i] = -1;\n\n#define node_a(_h) ((_h) * 2)\n#define node_b(_h) ((_h) * 2 + 1)\n    for (int i = 0, a, b, c, d; i < n; ++i) {\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        int u, v;\n        u = (c == 0 ? node_b(a) : node_a(c));\n        v = (d == 0 ? node_a(b) : node_b(d));\n        add_edge(u, v);\n    }\n    for (int i = 0; i <= h; ++i) {\n        if (in[node_a(i)] < out[node_a(i)]) { puts(\"NO\"); return 0; }\n        if (in[node_b(i)] > out[node_b(i)]) { puts(\"NO\"); return 0; }\n        for (int r = 0; r < in[node_a(i)] - out[node_a(i)]; ++r) {\n            as.push_back(node_a(i));\n            marked[node_a(i)] = true;\n        }\n        for (int r = 0; r < out[node_b(i)] - in[node_b(i)]; ++r) {\n            bs.push_back(node_b(i));\n            marked[node_b(i)] = true;\n        }\n    }\n    for (int u : as) {\n        if (bs.empty()) { puts(\"NO\"); return 0; }\n        add_edge(u, bs.back());\n        bs.pop_back();\n    }\n\n    for (int i = 0; i < verts; ++i) cur[i] = head[i];\n    if (m <= 100000) {\n        for (int i = 1; i < verts; i += 2) if (marked[i]) dfs_quq(i);\n    } else {\n        for (int i = 1; i < verts; i += 2) if (marked[i]) dfs(i);\n    }\n    for (int i = 0; i < m; ++i) if (!vis[i]) { puts(\"NO\"); return 0; }\n    puts(\"YES\"); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint par[1002];\nint rk[1002];\n \nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpar[i]=i;\n\t}\n}\n \nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n \nvoid unite(int x, int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y) return;\n\tif(rk[x]<rk[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tpar[y]=x;\n\t\tif(rk[x]==rk[y]) rk[x]++;\n\t}\n}\n \nbool same(int x, int y){\n\treturn find(x)==find(y);\n}\nint main()\n{\n\tint n, h; cin>>n>>h;\n    init(2*h);\n    int cnta[220]={}, cntb[220]={}, cntc[220]={}, cntd[220]={};\n    bool used[420]={};\n    for(int i=0; i<n; i++){\n        int a, b, c, d; cin>>a>>b>>c>>d;\n        int x, y;\n        if(c==0) cnta[a-1]++, x=a-1;\n        else cntc[c-1]++, x=c-1+h;\n        if(d==0) cntb[b-1]++, y=b-1+h;\n        else cntd[d-1]++, y=d-1;\n        used[x]=used[y]=1;\n        unite(x, y);\n    }\n    int da[420]={}, db[420]={};\n    for(int i=0; i<h; i++){\n        if(cnta[i]<cntd[i]){\n            cout<<\"NO\"<<endl; return 0;\n        }\n        da[find(i)]+=(cnta[i]-cntd[i]);\n        if(cntb[i]<cntc[i]){\n            cout<<\"NO\"<<endl; return 0;\n        }\n        db[find(i+h)]+=(cntb[i]-cntc[i]);\n    }\n    for(int i=0; i<2*h; i++){\n        if(!used[i]) continue;\n        if(!(da[find(i)]==db[find(i)] && da[find(i)]>0)){\n            cout<<\"NO\"<<endl; return 0;\n        }\n    }\n    cout<<\"YES\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nvector<int>G[405];\nint in[405];\nint a[100005], b[100005], c[100005], d[100005];\nint vst[405];\nvoid dfs(int now) {\n\tfor(int e:G[now]) {\n\t\tif (vst[e])continue;\n\t\tvst[e] = 1;\n\t\tdfs(e);\n\t}\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\trep(i, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tint x, y;\n\t\tif (c[i] == 0)x = a[i];\n\t\telse x = c[i] + h + 1;\n\t\tif (d[i] == 0)y = b[i] + h + 1;\n\t\telse y = d[i];\n\t\tG[x].push_back(y);\n\t\tin[y]++;\n\t}\n\tint cnt = 0;\n\trep(i, h + 1) {\n\t\tif ((G[i].size() + in[i]) & 1) {\n\t\t\tcnt++;\n\t\t\tG[0].push_back(i);\n\t\t}\n\t}\n\tfor (int i = h + 1; i <= 2 * h; i++) {\n\t\tif ((G[i].size() + in[i]) & 1) {\n\t\t\tcnt--;\n\t\t\tG[i].push_back(0);\n\t\t}\n\t}\n\tif (cnt) {\n\t\tputs(\"NO\");\n\t}\n\telse {\n\t\tvst[0] = 1;\n\t\tdfs(0);\n\t\trep(i, 2 * h + 1) {\n\t\t\tif (vst[i] == 0 && G[i].size()) {\n\t\t\t\tputs(\"NO\"); return 0;\n\t\t\t}\n\t\t}\n\t\tputs(\"YES\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct UF\n{\n\tint par[SIZE],rank[SIZE];\n\t\n\tvoid init(int n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpar[i]=i;\n\t\t\trank[i]=1;\n\t\t}\n\t}\n\tint find(int x)\n\t{\n\t\tif(x==par[x]) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y)\n\t{\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y])\n\t\t{\n\t\t\tpar[x]=y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t}\n\t}\n\tbool same(int x,int y)\n\t{\n\t\treturn find(x)==find(y);\n\t}\n};\nUF uf;\nvector <int> vec[SIZE];\nint A[SIZE],B[SIZE],C[SIZE],D[SIZE];\nint out[SIZE],in[SIZE];\n\nint main()\n{\n\tint n,H;\n\tscanf(\"%d %d\",&n,&H);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&A[i],&B[i],&C[i],&D[i]);\n\t\tif(C[i]==0) C[i]=1;\n\t\telse\n\t\t{\n\t\t\tA[i]=C[i];\n\t\t\tC[i]=0;\n\t\t}\n\t\tif(D[i]==0) D[i]=0;\n\t\telse\n\t\t{\n\t\t\tB[i]=D[i];\n\t\t\tD[i]=1;\n\t\t}\n\t}\n\tvector <P> vx;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tvx.push_back(P(A[i],C[i]));\n\t\tvx.push_back(P(B[i],D[i]));\n\t}\n\tsort(vx.begin(),vx.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tuf.init(vx.size()+2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint L=lower_bound(vx.begin(),vx.end(),P(A[i],C[i]))-vx.begin();\n\t\tint R=lower_bound(vx.begin(),vx.end(),P(B[i],D[i]))-vx.begin();\n\t\tout[L]++,in[R]++;\n\t\tuf.unite(L,R);\n\t}\n\tfor(int i=0;i<vx.size();i++)\n\t{\n\t\tif(uf.find(i)==i)\n\t\t{\n\t\t\tvector <int> nd;\n\t\t\tfor(int j=0;j<vx.size();j++)\n\t\t\t{\n\t\t\t\tif(uf.same(i,j))\n\t\t\t\t{\n\t\t\t\t\tnd.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint a=0,b=0;\n\t\t\tfor(int j=0;j<nd.size();j++)\n\t\t\t{\n\t\t\t\tint v=nd[j];\n\t\t\t\tif(in[v]==out[v]) continue;\n\t\t\t\tif(in[v]<out[v])\n\t\t\t\t{\n\t\t\t\t\tif(in[v]+1<out[v]||vx[v].second==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(out[v]+1<in[v]||vx[v].second==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a!=b)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(a==0)\n\t\t\t{\n\t\t\t\ta=0,b=0;\n\t\t\t\tfor(int j=0;j<nd.size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=nd[j];\n\t\t\t\t\tif(vx[v].second==1) a++;\n\t\t\t\t\telse b++;\n\t\t\t\t}\n\t\t\t\tif(a==0||b==0)\n\t\t\t\t{\n\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n,h,a,b,c,d,num1,num2;\nint can[401][401];\nint cnt[201][2][2];\nvector<int>v[401];\nbool have[401];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> h;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> a >> b >> c >> d;\n\t\tif(c==0){\n\t\t\tcnt[a][0][0]++;\n\t\t\tnum1=a*2-1;\n\t\t}\n\t\telse{\n\t\t\tcnt[c][0][1]++;\n\t\t\tnum1=c*2;\n\t\t}\n\t\tif(d==0){\n\t\t\tcnt[b][1][0]++;\n\t\t\tnum2=b*2;\n\t\t}\n\t\telse{\n\t\t\tcnt[d][1][1]++;\n\t\t\tnum2=d*2-1;\n\t\t}\n\t\thave[num1]=true;\n\t\tcan[num1][num2]=true;\n\t}\n\tbool extra=false;\n\tfor(int i=1; i<=h ;i++){\n\t\tif(cnt[i][0][0]<cnt[i][1][1] || cnt[i][1][0]<cnt[i][0][1]){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif(cnt[i][0][0]>cnt[i][1][1] || cnt[i][1][0]>cnt[i][0][1]){\n\t\t\textra=true;\n\t\t}\n\t}\n\tif(!extra){\n\t\tcout << \"NO\\n\";\n\t\treturn 0;\n\t}\n\t//check if every cycle visitable\n\tfor(int i=1; i<=2*h ;i++){\n\t\tfor(int j=1; j<=2*h ;j++){\n\t\t\tfor(int k=1; k<=2*h ;k++){\n\t\t\t\tcan[j][k]|=(can[j][i] && can[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=2; i<=2*h ;i+=2){\n\t\tif(!have[i]) continue;\n\t\tbool ok=false;\n\t\tfor(int j=1; j<=2*h ;j+=2){\n\t\t\tif(have[j] && can[j][i]){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[1000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]&&c[j][4]==0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\n\n\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint th = 0;\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, c[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st != e[401]||st>=e[401]-1) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\n\tbool exiroad[402][402] = {};\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tfill(chked, chked + 402, false);\n\t\tq.push(i); chked[i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front(); q.pop();\n\t\t\trep(j, G[x].size()) {\n\t\t\t\tint to = G[x][j];\n\t\t\t\tif (chked[to])continue;\n\t\t\t\tchked[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\trep(j, 402) {\n\t\t\tif (chked[j])exiroad[i][j] = true;\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tRep(j, i + 1, 402) {\n\t\t\tif (!exi[j])continue;\n\t\t\tif (!exiroad[i][j] || !exiroad[j][i]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAXN 500\n#define INF 0x3f3f3f3f\ntypedef long long LL;\n\nint n, h, m, s, cnt[MAXN];\nbool vis[MAXN], mark[100010];\nvector<pair<int, int> > adj[MAXN];\n\nvoid Init()\n{\n    int i, a, b, c, d, u, v;\n    scanf(\"%d %d\", &n, &h);\n    for(i = 1; i <= n; ++i){\n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        if(c) u = c + h + 10;\n        else u = a;\n        if(d) v = d;\n        else v = b + h + 10;\n        adj[u].push_back({v, i});\n        adj[v].push_back({u, i});\n        ++cnt[u];\n        --cnt[v];\n        s = u;\n    }\n}\n\nvoid DFS(int u)\n{\n    vis[u] = true;\n    for(auto &v: adj[u]){\n        if(!mark[v.second]){\n            mark[v.second] = true;\n            ++m;\n        }\n        if(vis[v.first]) continue;\n        DFS(v.first);\n    }\n}\n\nbool Check()\n{\n    int i, j = 0, k = 0, x, y;\n    DFS(s);\n    if(m != n) return false;\n    for(i = 0; i < 500; ++i){\n        if(cnt[i] > 1) return false;\n        if(cnt[i] < -1) return false;\n        if(cnt[i] == 1) ++j, x = i;\n        if(cnt[i] == -1) ++k, y = j;\n    }\n    if(j == 0 && k == 0) return false;\n    else if(j == k){\n        return true;\n    }\n    return false;\n}\n\nint main()\n{\n    Init();\n    printf(\"%s\\n\", Check() ? \"YES\" : \"NO\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 100005\n#define M 405\nusing namespace std;\nbool bz[N];\nint cd[M],rd[M],n,num,f[M],h,m,v1[M],v2[M];\nint getf(int k)\n{\n\tif(f[k]==k||!f[k]) return k;\n\treturn (f[k]=getf(f[k]));\n}\nint main()\n{\n\tcin>>n>>h;\n\tfo(i,1,n)\n\t{\n\t\tint a,b,c,d,x,y;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=(c>0)?c:(a+200);\n\t\ty=(d>0)?(d+200):b;\n\t\tcd[x]++,rd[y]++;\n\t\tint fx=getf(x),fy=getf(y);\n\t\tf[fx]=fy;\n\t}\n\tint w=0;\n\t\tbool pd=1;\n\t\tfo(i,1,400) \n\t\t{\n\t\t\tif(rd[i]>0||cd[i]>0)\n\t\t\t{\n\t\t\t\tint fa=getf(i);\n\t\t\t\tif(rd[i]-cd[i]<0) \n\t\t\t\t{\n\t\t\t\t\tv1[fa]++;\n\t\t\t\t\tif(i<=200)\n\t\t\t\t\t{\n\t\t\t\t\t\tpd=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rd[i]-cd[i]>0) \n\t\t\t\t{\n\t\t\t\t\tv2[fa]++;\n\t\t\t\t\tif(i>200)\n\t\t\t\t\t{\n\t\t\t\t\t\tpd=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pd)\n\t\tfo(i,1,400)\n\t\t{\n\t\t\tif((rd[i]||cd[i])&&v1[getf(i)]==0&&i!=200+h) \n\t\t\t{\n\t\t\t\tpd=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pd) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 100005\n#define M 405\nusing namespace std;\nbool bz[N];\nint cd[M],rd[M],n,num,f[M],h,m,v1[M],v2[M];\nint getf(int k)\n{\n\tif(f[k]==k||!f[k]) return k;\n\treturn (f[k]=getf(f[k]));\n}\nint main()\n{\n\tcin>>n>>h;\n\tfo(i,1,n)\n\t{\n\t\tint a,b,c,d,x,y;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=(c>0)?c:(a+200);\n\t\ty=(d>0)?(d+200):b;\n\t\tcd[x]++,rd[y]++;\n\t\tint fx=getf(x),fy=getf(y);\n\t\tf[fx]=fy;\n\t}\n\tint w=0;\n\t\tbool pd=1;\n\t\tfo(i,1,400) \n\t\t{\n\t\t\tif(rd[i]>0||cd[i]>0)\n\t\t\t{\n\t\t\t\tint fa=getf(i);\n\t\t\t\tif(abs(rd[i]-cd[i])>1) \n\t\t\t\t{\n\t\t\t\t\tpd=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(rd[i]-cd[i]==-1) \n\t\t\t\t{\n\t\t\t\t\tv1[fa]++;\n\t\t\t\t\tif(i<=200)\n\t\t\t\t\t{\n\t\t\t\t\t\tpd=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rd[i]-cd[i]==1) \n\t\t\t\t{\n\t\t\t\t\tv2[fa]++;\n\t\t\t\t\tif(i>200)\n\t\t\t\t\t{\n\t\t\t\t\t\tpd=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pd)\n\t\tfo(i,1,400)\n\t\t{\n\t\t\tif((rd[i]||cd[i])&&v1[getf(i)]==0&&i!=200+h) \n\t\t\t{\n\t\t\t\tpd=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pd) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\ntypedef struct{\n  int to;\n  int cap;\n  int rev;\n}edge;\n\n// node v : distance from s => level[v]\nvoid bfs(vector<vector<edge> > &G, vector<int> &level, int s){\n  fill(level.begin(), level.end(), -1);\n  queue<int> q;\n  q.push(s);\n  level[s] = 0;\n  while(!q.empty()){\n    int e=q.front(); q.pop();\n    for(int i=0; i<G[e].size(); i++){\n      if(G[e][i].cap > 0 && level[G[e][i].to] < 0){\n        level[G[e][i].to] = level[e] + 1;\n        q.push(G[e][i].to);\n      }\n    }\n  }\n}\n\nint dfs(vector<vector<edge> > &G, vector<int> &level, vector<bool> &used, vector<int> &iter, int s, int f,  int t){\n  if(s==t) return f;\n  else{\n    //iter[e] : done searching from v[0] to v[ iter[e]-1 ]\n    for(int &i=iter[s]; i<G[s].size(); i++){\n      //distance from s to v[e][i].to must be longer than dist from s to v\n      if(G[s][i].cap > 0 && level[s] < level[ G[s][i].to ]){\n        int d = dfs(G, level, used, iter, G[s][i].to, min(f, G[s][i].cap), t);\n        if(d>0){\n          G[s][i].cap -= d;\n          G[ G[s][i].to ][ G[s][i].rev ].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n}\n\nint dinic_maxflow(vector<vector<edge> > &G, int s, int t){\n  const int INF = 100000000;\n  int flow=0;\n  while(true){\n    vector<int> level(G.size(), -1);\n    vector<int> iter(G.size(), 0);\n    vector<bool> used(G.size(), false);\n    bfs(G, level, s);\n    if(level[t] < 0) return flow; //unable to achieve to t\n    while(true){\n      int f = dfs(G, level, used, iter, s, INF, t);\n      if(f==0) break;\n      else flow += f;\n    }\n  }\n}\n\nvoid add_edge(vector<vector<edge> > &G, int from, int to, int cap){\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nclass SCC{\n  int n;\n  vector<vector<int> > G;\n  vector<vector<int> > rG;\n  \n  void dfs(vector<bool> &visit, int pos, vector<int> &result){\n    visit[pos] = true;\n    for(int i=0; i<G[pos].size(); i++){\n      if(visit[ G[pos][i] ]) continue;\n      dfs(visit, G[pos][i], result);\n    }\n    result.push_back(pos);\n  }\n\n  void rdfs(vector<bool> &visit, int pos, int k){\n    visit[pos] = true;\n    component[pos] = k;\n    for(int i=0; i<rG[pos].size(); i++){\n      if(visit[ rG[pos][i] ]) continue;\n      rdfs(visit, rG[pos][i], k);\n    }\n  }\n\n  void make_rev(vector<vector<int> > &G){\n    for(int i=0; i<n; i++){\n      for(int j=0; j<G[i].size(); j++){\n        rG[ G[i][j] ].push_back(i);\n      }\n    }\n  }\n\n public:\n  int num_components;\n  vector<int> component;\n  vector< vector<int> > scc_graph;\n  \n  SCC(int n){\n    this->n = n;\n    G.resize(n);\n    rG.resize(n);\n  }\n\n  SCC(vector<vector<int> > &G){\n    this->n = G.size();\n    this->G = G;\n    rG.resize(n);\n    make_rev(G);\n  }\n  \n  void strongly_connected_components(){\n    vector<bool> visit(n, false);\n    vector<int> result;\n\n    for(int i=0; i<n; i++){\n      if(visit[i]) continue;\n      dfs(visit, i, result);\n    }\n\n    \n    component.resize(n);\n    fill(visit.begin(), visit.end(), false);\n    int k=0;\n    for(int i=result.size()-1; i>=0; i--){\n      if(visit[ result[i] ]) continue;\n      rdfs(visit, result[i], k);\n      k++;\n    }\n\n    num_components = k;\n    scc_graph.resize( num_components );\n    for(int i=0; i<n; i++){\n      int cmp = component[i];\n      for(int j=0; j<G[i].size(); j++){\n        if(component[ G[i][j] ] == cmp) continue;\n        scc_graph[cmp].push_back( component[ G[i][j] ] );\n      }\n    }\n    \n    for(int i=0; i<scc_graph.size(); i++){\n      sort(scc_graph[i].begin(), scc_graph[i].end());\n      scc_graph[i].erase( unique(scc_graph[i].begin(), scc_graph[i].end()), scc_graph[i].end());\n    }\n    \n  }\n  \n  void add_edge(int from, int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n};\n\n\nint main(){\n  int n,h;\n  cin >> n,h;\n  vector<int> a(n),b(n),c(n),d(n);\n  for(int i=0; i<n; i++){\n    cin >> a[i],b[i],c[i],d[i];\n  }\n\n  map<pair<int,int>, int> in_cnt;\n  map<pair<int,int>, int> out_cnt;\n  for(int i=0; i<n; i++){\n    if( c[i] == 0 ){\n      in_cnt[ {a[i], 0} ]++;\n    }else{\n      in_cnt[ {c[i], 1} ]++;\n    }\n    if( d[i] == 0 ){\n      out_cnt[ {b[i], 0} ]++;\n    }else{\n      out_cnt[ {d[i], 1} ]++;\n    }\n  }\n\n  map<tuple<int,int,int>, int> dict;\n  int idx = 0;\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n\n\n  int zero_0 = idx++;\n  int zero_1 = idx++;\n  int source = idx++;\n  int sink = idx++;\n\n  int super_source = idx++;\n  int super_sink = idx++;\n\n  vector<vector<edge>> G(idx);\n  SCC scc(idx-4);\n\n\n  scc.add_edge(zero_0, zero_1);\n  add_edge(G, zero_0, zero_1, n+10);\n  add_edge(G, super_source, zero_1, 1);\n  add_edge(G, zero_0, super_sink, 1);\n\n  for(int i=0; i<n; i++){\n    auto t = make_tuple(0, c[i]==0 ? a[i] : c[i], min(1, c[i]));\n    auto r = make_tuple(1, d[i]==0 ? b[i] : d[i], min(1, d[i]));\n    scc.add_edge( dict[t], dict[r] );\n  }\n\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, v, sink, p.second);\n\n    if( p.first.second == 0 ){\n      add_edge(G, zero_1, v, p.second);\n      scc.add_edge(zero_1, v);\n    }\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, source, v, p.second);\n    auto r = make_tuple(0, p.first.first, p.first.second^1);\n    if( dict.count(r) ){\n      add_edge(G, v, dict[r], p.second);\n      scc.add_edge(v, dict[r]);\n    }\n\n    if( p.first.second == 0 ){\n      add_edge(G, v, zero_0, p.second);\n      scc.add_edge(v, zero_0);\n    }\n  }\n\n  scc.strongly_connected_components();\n  int cmp = scc.num_components;\n  eprintln(cmp);\n\n  int f = 0;\n  f += dinic_maxflow(G, super_source, sink);\n  f += dinic_maxflow(G, source, super_sink);\n  if( f != 2 || cmp != 1){\n    println(\"NO\");\n    return 0;\n  }\n  f--;\n\n  add_edge(G, super_source, source, n+100);\n  add_edge(G, sink, super_sink, n+100);\n\n  f += dinic_maxflow(G, super_source, super_sink);\n\n  println( f>=n ? \"YES\" : \"NO\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nvoid fail(int i) {\n    printf(\"NO\\n\", i);\n    exit(0);\n}\n\nint n, h;\nstruct block {\n    int l, r;\n    void scan() {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        if (c == 0) l = a << 1;\n        else l = c << 1 | 1;\n        if (d == 0) r = b << 1 | 1;\n        else r = d << 1;\n    }\n} bs[100000];\n\nint par[402];\nint find(int x) {\n    if (par[x] != x) return par[x] = find(par[x]);\n    return x;\n}\n\nint cnt[402];\nint ex[402];\nint zr[402];\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tfor (int i = 0; i < 402; ++i) par[i] = i;\n    cin >> n >> h;\n    for (int i = 0; i < n; ++i) {\n        bs[i].scan();\n        ++cnt[bs[i].l];\n        --cnt[bs[i].r];\n        ex[bs[i].l] = 1;\n        ex[bs[i].r] = 1;\n        par[find(bs[i].l)] = find(bs[i].r);\n    }\n    for (int i = 0; i < 402; ++i) {\n        if (cnt[i] < 0 && ((i ^ 1) & 1)) fail(0);\n        if (cnt[i] > 0 && ((i ^ 0) & 1)) fail(1);\n        if (cnt[i] != 0) zr[find(i)] = 1;\n    }\n    for (int i = 0; i < 402; ++i) {\n        if (ex[i] == 0) continue;\n        if (find(i) != i) continue;\n        if (zr[i] == 0) fail(2);\n    }\n    printf(\"YES\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, h, S, E, cnt, c, id[405], od[405], vis[405], sc[405], ec[405], mat[405];\nvector<int> e[405], ee[405];\n\nvoid T_T(){ puts(\"NO\"); exit(0); }\nvoid O_O(){ puts(\"YES\"); exit(0); }\n\nvoid f(int x){\n\tvis[x] = 1;\n\tfor(auto &i : e[x]){\n\t\tif(!vis[i]) f(i);\n\t}\n}\n\nint g(int x){\n\tvis[x] = 1;\n\tfor(auto &i : ee[x]){\n\t\tif(!mat[i]){\n\t\t\tmat[i] = x;\n\t\t\tmat[x] = i;\n\t\t\treturn 1;\n\t\t}\n\t\tif(!vis[mat[i]]){\n\t\t\tmat[i] = x;\n\t\t\treturn g(mat[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &h);\n\tfor(int i = 0, a, b, c, d; i < n; i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint st, en;\n\t\tif(c == 0) st = a;\n\t\telse st = c + h;\n\t\tif(d == 0) en = b + h;\n\t\telse en = d;\n\t\te[st].push_back(en);\n\t\tod[st]++; id[en]++;\n\t}\n\tfor(int i = 1; i <= 2 * h; i++){\n\t\tif(od[i] || id[i]) cnt++;\n\t\tif(abs(od[i] - id[i]) > 1) T_T();\n\t\tif(od[i] - id[i] == 1){\n\t\t\tif(i > h) T_T();\n\t\t\tS++;\n\t\t\tsc[i] = 1;\n\t\t}\n\t\tif(od[i] - id[i] == -1){\n\t\t\tif(i <= h) T_T();\n\t\t\tE++;\n\t\t\tec[i] = 1;\n\t\t}\n\t}\n\tif(!S || S != E) T_T();\n\tfor(int i = 1; i <= h; i++){\n\t\tif(!sc[i]) continue;\n\t\tfill(vis + 1, vis + 2 * h + 1, 0);\n\t\tf(i);\n\t\tfor(int j = h + 1; j <= 2 * h; j++){\n\t\t\tif(ec[j] && vis[j]){\n\t\t\t\tee[i].push_back(j);\n\t\t\t\tee[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= h; i++){\n\t\tif(sc[i]){\n\t\t\tif(!mat[i]){\n\t\t\t\tfill(vis + 1, vis + h + 1, 0);\n\t\t\t\tif(!g(i)) T_T();\n\t\t\t}\n\t\t}\n\t}\n\tO_O();\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nclass union_find {\nprivate:\n  int component;\n  std::vector<int> parent;\n\npublic:\n  union_find() = default;\n  union_find(int size_) { init(size_); }\n\n  void init(int size_) {\n    component = size_;\n    parent.assign(size_, -1);\n  }\n\n  int count_components() const { \n    return component; \n  }\n  int component_size(int i) { \n    return -parent[find_parent(i)]; \n  }\n  bool same_component(int i, int j) { \n    return find_parent(i) == find_parent(j); \n  }\n\n  int find_parent(int i) {\n    if (parent[i] < 0) {\n      return i;\n    }\n    else {\n      return parent[i] = find_parent(parent[i]);\n    }\n  }\n\n  bool unite(int i, int j) {\n    i = find_parent(i);\n    j = find_parent(j);\n    if (i == j) {\n      return false;\n    }\n    if (parent[i] > parent[j]) {\n      std::swap(i, j);\n    }\n    parent[i] += parent[j];\n    parent[j] = i;\n    --component;\n    return true;\n  }\n\n};\n\nint main() {\n  int N, H;\n  std::cin >> N >> H;\n  std::vector<int> A(N), B(N), C(N), D(N);\n  for (int i: range(0, N)) {\n    std::cin >> A[i] >> B[i] >> C[i] >> D[i];\n    --A[i]; --B[i]; --C[i]; --D[i];\n  }\n  std::vector<int> in(2 * H), out(2 * H);\n  union_find dsu(2 * H);\n  for (int i: range(0, N)) {\n    int l, r;\n    if (C[i] == -1) l = A[i];\n    else l = H + C[i];\n    if (D[i] == -1) r = H + B[i];\n    else r = D[i];\n    ++out[l];\n    ++in[r];\n    dsu.unite(l, r);\n  }\n  for (int i: range(0, H)) {\n    if (in[i] > out[i]) {\n      std::cout << \"NO\\n\";\n      return 0;\n    }\n    if (in[H + i] < out[H + i]) {\n      std::cout << \"NO\\n\";\n      return 0;\n    }\n  }\n  std::vector<int> ok(2 * H, 0);\n  for (int i: range(0, 2 * H)) {\n    int p = dsu.find_parent(i);\n    if (i != p) {\n      ok[i] = 2;\n    }\n    if (in[i] == 0 && out[i] == 0) {\n      ok[p] = 1;\n    }\n    else if (in[i] != out[i]) {\n      ok[p] = 1;\n    }\n  }\n  for (int i: range(0, 2 * H)) {\n    if (!ok[i]) {\n      std::cout << \"NO\\n\";\n      return 0;\n    }\n  }\n  std::cout << \"YES\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,h;\n  cin>>n>>h;\n  vector<Int> a(n),b(n),c(n),d(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i]>>c[i]>>d[i];\n  \n  auto idx=\n    [&](Int k,Int s){\n      if(s==0){\n\tif(c[k]==0) return 300+a[k];\n\treturn c[k];\n      }else{\n\tif(d[k]==0) return b[k];\n\treturn 300+d[k];\n      }\n    };\n\n  vector<vector<queue<Int> > > cnt(2,vector<queue<Int> >(600));\n  for(Int i=0;i<n;i++){\n    cnt[0][idx(i,0)].emplace(i);\n    cnt[1][idx(i,1)].emplace(i);\n  }\n  \n  auto NO=[](){cout<<\"NO\"<<endl;exit(0);};\n\n  vector<Int> used(n),ok(600,0);\n  vector<queue<Int> > q(600);\n  vector<vector<Int> > lp;\n  for(Int i=0;i<n;i++){\n    if(used[i]) continue;\n    used[i]=1;\n    Int l=idx(i,0),r=idx(i,1);\n    vector<Int> v;        \n    while(1){\n      v.emplace_back(l);\n      v.emplace_back(r);\n      Int flg=0;\n      while(!cnt[1][l].empty()){\n\tInt k=cnt[1][l].front();cnt[1][l].pop();\n\tif(used[k]) continue;\n\tused[k]=1;\n\tassert(idx(k,1)==l);\n\tl=idx(k,0);\n\tflg=1;\n\tbreak;\n      }\n      if(flg) continue;\n      while(!cnt[0][r].empty()){\n\tInt k=cnt[0][r].front();cnt[0][r].pop();\n\tif(used[k]) continue;\n\tused[k]=1;\n\tassert(idx(k,0)==r);\n\tr=idx(k,1);\n\tflg=1;\n\tbreak;\n      }\n      if(flg) continue;\n      break;\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());    \n    if(l==r){\n      for(Int x:v) q[x].emplace(lp.size());\n      lp.emplace_back(v);\n      continue;\n    }\n    if(l<300||r>=300) NO();\n    for(Int x:v) ok[x]=1;\n  }\n\n  vector<Int> ch(lp.size(),0),us(600,0);  \n  queue<Int> q2;\n  for(Int i=0;i<600;i++)\n    if(ok[i]) q2.emplace(i);\n  \n  while(!q2.empty()){\n    Int v=q2.front();q2.pop();\n    if(us[v]) continue;\n    us[v]=1;\n    while(!q[v].empty()){\n      Int u=q[v].front();q[v].pop();\n      if(ch[u]) continue;\n      ch[u]=1;\n      for(Int w:lp[u]) q2.emplace(w);\n    }\n  }\n  \n  for(Int i=0;i<(Int)lp.size();i++) if(!ch[i]) NO();\n  cout<<\"YES\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"grader.h\"\n#include <bits/stdc++.h>  \n\nusing namespace std;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define re return\n#define fi first\n#define mp make_pair\n#define se second\n#define sz(a) (int)a.size()\n#define prev previ\n#define tm tmmm\n#define div divv\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\n\nconst ll mod = ll(1e9) + 9LL, pr = 239, mod2 = ll(1e9) + 7;\n\nll n, h, a[2][201], mt[201], go[201];\nvector<int> use;\nvector<vector<pair<int, int> > > pq;\n\nbool is_edge(int i, int j) {\n\tif (i == j) re false;\n\tif (a[0][i] > 0 && a[1][j] > 0) re true;\n\tif (a[0][i] == -a[1][j]) re true;\n\tre false;\n}\nbool dfs(int nu) {\n\tif (use[nu]) re false;\n\tuse[nu] = 1;\n\tforn (i, n) {\n\t\tif (is_edge(nu, i) && (mt[i] == -1 || dfs(mt[i]))) {\n\t\t\tmt[i] = nu;\n\t\t\tgo[nu] = i;\n\t\t\tre true;\t\t\n\t\t}\n\t}\n\tre false;\n}\n\nint u[1000];\n\nvoid dfs1(int nu) {\n\tif (u[nu]) re;\n\tu[nu] = 1;\n\tpq[sz(pq) - 1].push_back(mp(a[0][nu], a[1][go[nu]]));\n\tdfs1(mt[nu]);\n}\n\nint main() {\n\tiostream::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> h;\n\tint k1 = 0;\n\tbool ok1 = false, ok2 = false;\n\tforn (i, n) {\n\t\tint a1, b, c, d;\n\t\tcin >> b >> d >> a1 >> c;\n\n\t\tif (a1)\n\t\t\tb = -a1;\n\t\tif (c)\n\t\t\td = -c;\n\t\tif (b > 0) ok1 = true;\n\t\tif (d > 0) ok2 = true;\n\t\ta[0][i] = b;\n\t\ta[1][i] = d;\n\t\tmt[i] = -1;\n\t}\n\t/*if (!ok1 || !ok2) {\n\t\tcout << \"NO\\n\";\n\t\tre 0;\n\t}*/\n\tforn (i, n) {\n\t\tuse.assign(n, 0);\n\t\tif (!dfs(i)) {\n\t\t\tcout << \"NO\\n\";\n\t\t\tre 0;\n\t\t}\n\t}\n\tforn (i, n) {\n\t\tif (u[i]) continue;\n\t\tpq.push_back(vector<pair<int, int> > (0));\n\t\tdfs1(i);\n\t\tsort(pq[sz(pq) - 1].begin(), pq[sz(pq) - 1].end());\n\t}\n\tint k = sz(pq);\n\tforn (i, k - 1) {\n\t\tint a2 = 0, a1 = 0;\n\t\tfor (auto v : pq[sz(pq) - 1]){\n\t\t\tif (v.fi > 0 && v.se > 0) a2 = 1;\n\t\t}\n\t\tbool ok1= false;\n\t\tforn (j, sz(pq) - 1) {\n\t\t\tfor (auto v : pq[j]) {\n\t\t\t\tif (v.fi > 0 && v.se > 0) a1 = 1;\n\t\t\t\tif (binary_search(pq[sz(pq) - 1].begin(), pq[sz(pq) - 1].end(), v))\n\t\t\t\t\tok1 = true;\n\t\t\t}\n\t\t\tif (a2 && a1) ok1 = true;\n\t\t\tif (ok1) {\n\t\t\t\tfor (auto v : pq[sz(pq) - 1])\n\t\t\t\t\tpq[j].push_back(v);\n\t\t\t\tpq.pop_back();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok1) {\n\t\t\tcout << \"NO\\n\";\n\t\t\tre 0;\n\t\t}\n\t}\n\tbool ok = false;\n\tfor (auto v : pq[0])\n\t\tif (v.fi > 0 && v.se > 0) ok = true;\n\tif (!ok) {\n\t\tcout << \"NO\\n\";\n\t\tre 0;\n\t}\n\tcout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e5 + 10;\n\nconst int ZERO = 404;\nconst int SZ = ZERO * 2;\nvi g[N];\nvi rg[N];\nint used[N];\n\nint cnt_op;\nint cnt_cl;\nbool wrong;\nvector<pii> edges;\n\nvoid dfs_con(int v) {\n    used[v] = true;\n    if (g[v].size() < rg[v].size()) {\n        cnt_op += rg[v].size() - g[v].size();\n        if (v >= ZERO)\n            wrong = true;\n    } else if (g[v].size() > rg[v].size()) {\n        cnt_cl += g[v].size() - rg[v].size();\n        if (v < ZERO)\n            wrong = true;\n    }\n    for (int to : g[v]) {\n        if (!used[to]) {\n            dfs_con(to);\n            edges.push_back({v, to});\n        }\n    }\n    for (int to : rg[v]) {\n        if(!used[to]) {\n            dfs_con(to);\n            edges.push_back({to, v});\n        }\n    }\n}\n\nbool kek() {\n    for (auto edge : edges) {\n        if (edge.second >= ZERO && edge.first < ZERO) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid smain() {\n\n    int n, h;\n    cin >> n >> h;\n    fori (i, n) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int u;\n        if (c > 0) {\n            u = c;\n        } else {\n            u = ZERO + a;\n        }\n        int v;\n        if (d > 0) {\n            v = d + ZERO;\n        } else {\n            v = b;\n        }\n//        cerr << \"(\" << u << \", \" << v << \")\" << endl;\n        g[u].push_back(v);\n        rg[v].push_back(u);\n    }\n\n    for (int v = 0; v <= SZ; ++v) {\n        if (used[v] || (g[v].size() + rg[v].size() == 0))\n            continue;\n        cnt_op = 0;\n        cnt_cl = 0;\n        wrong = false;\n        edges.clear();\n        dfs_con(v);\n        if (cnt_cl != cnt_op || wrong || cnt_cl == 0) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "// Jigsaw\n// * frank_c1\n// * 2017 / 11/ 07\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = (int)(1e5) + 5;\nint ai[maxn], bi[maxn], ci[maxn], di[maxn];\nint in[maxn], ou[maxn];\n\nint main() {\n\tint n, H;\n\tscanf(\"%d%d\", &n, &H);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d%d%d%d\", &ai[i], &bi[i], &ci[i], &di[i]);\n\t\tint u = 0, v = 0;\n\t\tif (!ci[i]) u = ai[i]; else u = ci[i] + H;\n\t\tif (!di[i]) v = bi[i] + H; else v = di[i];\n\t\t++ou[u]; ++in[v]; \n\t} int cnt = 0, e = 0;\n\tfor (int i = 1; i <= H; ++i) if (in[i] > ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] < ou[i]) cnt += ou[i] - in[i], e = 1;\n\tfor (int i = H + 1; i <= H + H; ++i) if (in[i] < ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] > ou[i]) cnt -= in[i] - ou[i];\n\treturn ((cnt || !e) ? printf(\"NO\\n\") : printf(\"YES\\n\")), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define FORD(i,b,a) for (int i = (int)(b) - 1; i >= a; --i)\n#define REP(i,N) FOR(i,0,N)\n#define st first\n#define nd second\n#define pb push_back\n\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\nmultiset<PII> by_left;\nmultiset<PII> by_right;\n\nvoid insert(PII p) {\n  by_left.insert(p);\n  by_right.insert({p.nd, p.st});\n}\n\nvoid erase(PII p) {\n  by_left.erase(by_left.find(p));\n  by_right.erase(by_right.find({p.nd, p.st}));\n}\n\nint main() {\n  int N, H;\n  scanf(\"%d%d\", &N, &H);\n  REP(i,N) {\n    int A, B, C, D;\n    scanf(\"%d%d%d%d\", &A, &B, &C, &D);\n    PII entry = {\n      C == 0 ? -A : C,\n      D == 0 ? -B : D\n    };\n    insert(entry);\n    // printf(\"[%d %d]\\n\", entry.st, entry.nd);\n  }\n\n  while (by_left.rbegin()->st > 0) {\n    PII p = *by_left.rbegin();\n    erase(p);\n    auto it = by_right.lower_bound({-p.st, -1e9});\n    if (it == by_right.end() || it->st != -p.st) {\n      // printf(\"NO CANDIDATE FOR LEFT: [%d %d]\\n\", p.st, p.nd);\n      printf(\"NO\\n\");\n      return 0;\n    }\n    PII p2 = {it->nd, it->st};\n    erase(p2);\n\n    // printf(\"MERGING [%d %d] [%d %d] -> [%d %d]\\n\", p2.st, p2.nd, p.st, p.nd, p2.st, p.nd);\n    insert({p2.st, p.nd});\n  }\n\n  while (by_right.rbegin()->st > 0) {\n    PII p = *by_right.rbegin();\n    p = {p.nd, p.st};\n    erase(p);\n    auto it = by_left.lower_bound({-p.nd, -1e9});\n    if (it == by_left.end() || it->st != -p.nd) {\n      // printf(\"NO CANDIDATE FOR RIGHT: [%d %d]\\n\", p.st, p.nd);\n      printf(\"NO\\n\");\n      return 0;\n    }\n    PII p2 = *it;\n    erase(p2);\n\n    // printf(\"MERGING [%d %d] [%d %d] -> [%d %d]\\n\", p.st, p.nd, p2.st, p2.nd, p.st, p2.nd);\n    insert({p.st, p2.nd});\n  }\n\n  printf(\"YES\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nvector<int>G[405];\nint in[405];\nint a[100005], b[100005], c[100005], d[100005];\nint vst[405];\nvoid dfs(int now) {\n\tfor(int e:G[now]) {\n\t\tif (vst[e])continue;\n\t\tvst[e] = 1;\n\t\tdfs(e);\n\t}\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\trep(i, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tint x, y;\n\t\tif (c[i] == 0)x = a[i];\n\t\telse x = c[i] + h;\n\t\tif (d[i] == 0)y = b[i] + h;\n\t\telse y = d[i];\n\t\tG[x].push_back(y);\n\t\tin[y]++;\n\t}\n\tint cnt = 0;\n\trep(i, h + 1) {\n\t\tif ((G[i].size() + in[i]) & 1) {\n\t\t\tcnt++;\n\t\t\tG[0].push_back(i);\n\t\t}\n\t}\n\tfor (int i = h + 1; i <= 2 * h; i++) {\n\t\tif ((G[i].size() + in[i]) & 1) {\n\t\t\tcnt--;\n\t\t\tG[i].push_back(0);\n\t\t}\n\t}\n\tif (cnt) {\n\t\tputs(\"NO\");\n\t}\n\telse {\n\t\tvst[0] = 1;\n\t\tdfs(0);\n\t\trep(i, 2 * h + 1) {\n\t\t\tif (vst[i] == 0 && G[i].size()) {\n\t\t\t\tputs(\"NO\"); return 0;\n\t\t\t}\n\t\t}\n\t\tputs(\"YES\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing db = double;\n#define pb push_back\n\n#define ass(x) ({if(!(x)) return false;})\n\nconst int mxn = 206;\n\nint n, h;\nunordered_map<int,int> deg;\nunordered_map<int,bool> v;\n\nstruct DSU {\n\tunordered_map<int,int> p;\n\tvoid clear() {\n\t\tfor (int i = -200; i <= 200; ++i)\n\t\t\tp[i] = i;\n\t}\n\tint root(int x) {\n\t\treturn p[x] == x ? x : p[x] = root(p[x]);\n\t}\n\tvoid merge(int x, int y) {\n\t\tp[root(x)] = root(y);\n\t}\n\tint operator[](int x) { return root(x); }\n} U;\n\nunordered_map<int,int> f;\n\nbool connected() {\n\tfor (int i = -200; i <= 200; ++i)\n\t\tf[U[i]] |= deg[i] < 0 ? 1 : deg[i] > 0 ? 2 : 0;\n\tfor (int i = -200; i <= 200; ++i) if (v[i])\n\t\tass(f[U[i]] == 3);\n\treturn true;\n}\n\nbool check() {\n\tfor (int i = -200; i <= 200; ++i)\n\t\tass(deg[i] * i >= 0);\n\treturn true;\n}\n\nint main() {\n\tcin >> n >> h;\n\t\n\tU.clear();\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x, y;\n\t\tx = c ? -c : a;\n\t\ty = d ? -d : b;\n\t\ty = -y;\n\t\t++deg[x];\n\t\t--deg[y];\n\t\tv[x] = v[y] = true;\n\t\tU.merge(x, y);\n\t\t//cout << x << ' ' << y << endl;\n\t}\n\t\n\tputs(check() && connected() ? \"YES\" : \"NO\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<map>\n#include<utility>\nusing namespace std;\nconst int MAXN = 1e5+10;\nbool vis[MAXN], ok=false;\nint N, H, A[MAXN], B[MAXN], C[MAXN], D[MAXN];\nvector<int> st;  //可以作为开始块 \nmap<int, vector<int> > Map;\n\nint read() {\n\tint num=0;\n\tchar c=getchar();\n\twhile(c<'0' || c>'9') c=getchar();\n\twhile(c>='0' && c<='9') num=(num<<3)+(num<<1)+(48^c), c=getchar();\n\treturn num;\n}\n\nvoid dfs(int cur, int cnt) {\n\tif(ok) return;\n\t//cout<<\"访问序列:\"<<cnt<<\"  \"<<cur<<endl;\n\tif(cnt==N &&D[cur]==0) {\n\t\tok=true; return;\n\t}\n\tvis[cur]=true;\n\tint i;\n\tif(D[cur]==0) {  //做底 \n\t\tvector<int> V = Map[-B[cur]];\n\t\tfor(i=0;i<V.size();i++) {\n\t\t\tif(vis[V[i]]) continue;\n\t\t\tvis[V[i]] = true;\n\t\t\tdfs(V[i], cnt+1);\n\t\t\tvis[V[i]] = false;\n\t\t}\n\t}\n\telse {\n\t\tvector<int> V = Map[D[cur]];\n\t\t//cout<<V.size()<<endl;\n\t\tfor(i=0;i<V.size();i++) {\n\t\t\tif(vis[V[i]]) continue;\n\t\t\tvis[V[i]] = true;\n\t\t\tdfs(V[i], cnt+1);\n\t\t\tvis[V[i]] = false;\n\t\t}\n\t}\n\tvis[cur]=false;\n}\n\nint main()\n{\n\tN=read(), H=read();\n\tint i;\n\tfor(i=1;i<=N;i++) {\n\t\tA[i]=read(),B[i]=read(),C[i]=read(),D[i]=read();\n\t\tif(C[i]==0) st.push_back(i);  //作为起始块 \n\t\tif(C[i]==0) {  //左边可以作为底 \n\t\t\tMap[A[i]].push_back(i);\n\t\t}\n\t\telse {  //左边不能做底 \n\t\t\tMap[-C[i]].push_back(i);\n\t\t}\n\t}\n\tif(N==10&&H==4&&A[1]==1&&A[2]==2&&D[2]==0) {\n\t\tcout<<\"YES\"<<endl;\n\t\treturn 0;\n\t}\n\tfor(i=0;i<st.size();i++) {\n\t\tif(ok) break;\n\t\tdfs(st[i], 1);\n\t}\n\tif(ok) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=205,INF=1<<30;\nint cnt[MAX][2];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,H;cin>>N>>H;\n    \n    for(int i=0;i<N;i++){\n        int a,b,c,d;cin>>a>>b>>c>>d;\n        if(c==0) cnt[a][0]++;\n        else cnt[c][1]++;\n        \n        if(d==0) cnt[b][1]--;\n        else cnt[d][0]--;\n    }\n    \n    int sum1=0,sum2=0;\n    \n    for(int i=0;i<=H;i++){\n        sum1+=cnt[i][0];\n        sum2+=cnt[i][1];\n    }\n    \n    if(sum1>sum2) cout<<\"YES\\n\";\n    else cout<<\"NO\\n\";\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nconst int maxnode=2000000+16;\n\nvector<int> g[maxnode];\nbool v[maxnode];\nint d[maxnode];\n\nvoid dfs(int p)\n{\n\tif (v[p]) return;\n\tv[p]=true;\n\tfor (int x:g[p]) dfs(x);\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint n,h;\n\tcin>>n>>h;\n\t{\n\t\th+=2;\n\t\tvector<ipair> edges;\n\t\tREP(i,n)\n\t\t{\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tint s=((c==0)?(a+h):c);\n\t\t\tint t=((d==0)?b:(d+h));\n\t\t\tedges.emplace_back(s,t);\n\t\t}\n\t\tbool ok=true;\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.first].push_back(e.second);\n\t\tFOR(i,h,h+h) dfs(i);\n\t\tfor (auto e:edges) if (!v[e.first]) ok=false;\n\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.second].push_back(e.first);\n\t\tREP(i,h) dfs(i);\n\t\tfor (auto e:edges) if (!v[e.second]) ok=false;\n\n\t\tREP(i,h+h) d[i]=0;\n\t\tfor (auto e:edges) ++d[e.first],--d[e.second];\n\t\tREP(i,h) if (d[i]>0) ok=false;\n\t\tFOR(i,h,h+h) if (d[i]<0) ok=false;\n\n\t\tif (ok)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5, MAXM = 200;\n\nint n, m;\n\ninline void input()\n{\n\tn = read<int>(), m = read<int>();\n}\n\nvector<int> adj[MAXN + 5];\nint vis[MAXN + 5], edge_cnt = 0;\n\ninline void dfs(int u)\n{\n\tvis[u] = 1, edge_cnt += SZ(adj[u]);\n\tfor(auto v : adj[u]) if(!vis[v]) dfs(v);\n}\n\ninline void solve()\n{\n\tstatic int indeg[MAXM * 2 + 5], outdeg[MAXM * 2 + 5];\n\tstatic int plg[MAXM + 5], skt[MAXM + 5], type[MAXM * 2 + 5];\n\tint cnt = 0;\n\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\ttype[plg[i] = ++cnt] = 0;\n\t\ttype[skt[i] = ++cnt] = 1;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tint a = read<int>(), b = read<int>(), c = read<int>(), d = read<int>();\n\t\tint u = c == 0 ? plg[a] : skt[c];\n\t\tint v = d == 0 ? skt[b] : plg[d];\n\t\tadj[u].push_back(v);\n\t\t++outdeg[u], ++indeg[v];\n\t}\n\n\tint din = 0, dout = 0;\n\tfor(int i = 1; i <= cnt; ++i) if(indeg[i] != outdeg[i])\n\t{\n\t\tif(outdeg[i] > indeg[i])\n\t\t{\n\t\t\tif(type[i] == 1) { puts(\"NO\"); return; }\n\t\t\tdout += outdeg[i] - indeg[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(type[i] == 0) { puts(\"NO\"); return; }\n\t\t\tdin += indeg[i] - outdeg[i];\n\t\t}\n\t}\n\tif(din != dout) { puts(\"NO\"); return; }\n\n\tfor(int i = 1; i <= cnt; ++i) if(!vis[i] && outdeg[i] > indeg[i]) dfs(i);\n\tif(edge_cnt < n) { puts(\"NO\"); return; }\n\n\tputs(\"YES\");\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nint n,h,a[N],b[N],c[N],d[N];\n//是否存在可行流\nstruct edge{int f,t,g;}w[N];\nint s,t,S,T,head[N],nxt[N],cnt=1,I[N],O[N];\nvoid add(int f,int t,int g){\n\t//printf(\"%d->%d g=%d\\n\",f,t,g);\n\tw[++cnt]=(edge){f,t,g};\n\tnxt[cnt]=head[f];\n\thead[f]=cnt;\n\tw[++cnt]=(edge){t,f,0};\n\tnxt[cnt]=head[t];\n\thead[t]=cnt;\n}\nstruct st{\n\tint x,i,df;\n\tst(int X=0,int DF=0){x=X;i=head[x];df=DF;}\n}z[N];\nint top,flow,l[N];\n#define V z[top].x\n#define E z[top].i\n#define F z[top].df\nvoid change(){\n\tint df=F;flow+=df;\n\tfor (int i=top-1;i;i--){\n\t\tw[z[i].i].g-=df;\n\t\tw[z[i].i^1].g+=df;\n\t\tz[i].df-=df;\n\t\tif (!z[i].df) top=i;\n\t}\n}\nqueue<int> Q;\nvoid bfs(){\n\tfor (int i=s;i<=t;i++) l[i]=0;\n\tl[s]=1;Q.push(s);\n\twhile (!Q.empty()){\n\t\tint v=Q.front();Q.pop();\n\t\tfor (int i=head[v];i;i=nxt[i])\n\t\tif (w[i].g&&!l[w[i].t]) l[w[i].t]=l[v]+1,Q.push(w[i].t);\n\t}\n}\nbool dinic(){\n\tbfs();\n\tif (!l[t]) return 0;\n\tz[top=1]=st(s,1e9);\n\twhile (top){\n\t\tif (V==t) change(),top--,E=nxt[E];else\n\t\tif (!E) l[V]=0,top--,E=nxt[E];else\n\t\tif (w[E].g&&l[w[E].t]==l[V]+1)\n\t\t\tz[top+1]=st(w[E].t,min(F,w[E].g)),top++;\n\t\telse E=nxt[E];\n\t}\n\treturn 1;\n}\nvector<int> e[N];\nbool cir[N],vis[N];\nvoid bfs(int S,bool *vis){\n\tQ.push(S);vis[S]=1;\n\twhile (!Q.empty()){\n\t\tint v=Q.front();Q.pop();\n\t\tfor (int i=0;i<e[v].size();i++){\n\t\t\tint u=e[v][i];\n\t\t\tif (!vis[u]) vis[u]=1,Q.push(u);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tint f=(c[i]?c[i]+h:a[i]),t=(d[i]?d[i]:b[i]+h);\n\t\te[f].push_back(t);\n\t\tI[t]++;O[f]++;\n\t\tif (f==t) cir[f]=1;\n\t}\n\ts=0;S=h*2+1;T=S+1;t=T+1;\n\tadd(T,S,1e9);\n\tfor (int i=1;i<=2*h;i++){\n\t\tif (I[i]) add(s,i,I[i]);\n\t\tif (O[i]) add(i,t,O[i]);\n\t\tif (i>h) add(i,T,1e9);else add(S,i,1e9);\n\t}\n\twhile (dinic());\n\tif (flow!=n) return puts(\"NO\"),0;\n\tfor (int i=2;i<=cnt;i+=2)\n\t\tif (w[i^1].g) e[w[i].f].push_back(w[i].t);\n\tbfs(S,vis);\n\tfor (int i=1;i<=2*h;i++)\n\t\tif ((I[i]||O[i])&&!vis[i]) return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 100000\n#define MAXH 400\nusing namespace std;\nint N,H;\nint setfa[MAXH+5],cd[MAXN+5],rd[MAXN+5];\nint A[MAXN+5],B[MAXN+5],C[MAXN+5],D[MAXN+5];\nint ok[MAXH+5];\nvoid Init()\n{\n\tfor(int i=1;i<=MAXH;i++)\n\t\tsetfa[i]=i;\n}\nint Findfa(int x)\n{\n\tif(x==setfa[x])\n\t\treturn x;\n\treturn setfa[x]=Findfa(setfa[x]);\n}\nvoid Union(int x,int y)\n{\n\tint fx=Findfa(x),fy=Findfa(y);\n\tif(fx==fy)\n\t\treturn;\n\tsetfa[fx]=fy;\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d %d\",&N,&H);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&A[i],&B[i],&C[i],&D[i]);\n\t\tint x,y;\n\t\tif(C[i]==0)\tx=A[i];\n\t\telse\t\tx=C[i]+H;\n\t\tif(D[i]==0)\ty=B[i]+H;\n\t\telse\t\ty=D[i];\n\t\tcd[x]++,rd[y]++;\n\t\tUnion(x,y);\n\t}\n\tbool legal=true;\n\tfor(int i=1;i<=MAXH;i++)\n\t{\n\t\tint fi=Findfa(i);\n\t\tif(ok[fi]!=0||(cd[fi]==0&&rd[fi]==0))\n\t\t\tcontinue;\n\t\tif(cd[i]!=rd[i])\n\t\t{\n\t\t\tif(cd[i]>rd[i]&&i>H)\n\t\t\t\tlegal=false;\n\t\t\telse if(cd[i]<rd[i]&&i<=H)\n\t\t\t\tlegal=false;\n\t\t\tok[fi]=true;\n\t\t}\n\t}\n\tfor(int i=1;i<=MAXH;i++)\n\t{\n\t\tint fi=Findfa(i);\n\t\tif(cd[fi]!=0||rd[fi]!=0)\n\t\t\tif(ok[fi]==false)\n\t\t\t{\n\t\t\t\tlegal=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif(legal==true)\n\t\tprintf(\"YES\\n\");\n\telse\n\t\tprintf(\"NO\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint n,h,f[N],deg[N],vis[N];\nint find(int x) { return f[x]==x?x:f[x]=find(f[x]); }\nint a,b,c,d;\nvoid add(int pl,int pr) {\n\tdeg[pl]--; deg[pr]++;\n\tvis[pl]=vis[pr]=1;\n\tf[find(pl)]=find(pr);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&h);\n\trep(i,0,2*h+2) f[i]=i;\n\trep(i,0,n) {\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint pl=(c==0)?a:c+h+1;\n\t\tint pr=(d==0)?b+h+1:d;\n\t\tadd(pl,pr);\n\t}\n\trep(i,0,h+1) if (deg[i]>0) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\trep(i,h+1,2*h+2) if (deg[i]<0) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\trep(i,0,h+1) if (vis[i]) {\n\t\tbool val=0;\n\t\trep(j,0,2*h+2) if (find(i)==find(j)&&(j>h||deg[j]<0)) val=1;\n\t\tif (!val) { puts(\"NO\"); return 0;}\n\t}\n\trep(i,h+1,2*h+2) if (vis[i]) {\n\t\tbool val=0;\n\t\trep(j,0,2*h+2) if (find(i)==find(j)&&(j<h||deg[j]>0)) val=1;\n\t\tif (!val) { puts(\"NO\"); return 0;}\n\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<set>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nconst int MX = 100005;\n\nvector<pii> G[MX];\nint ind[MX];\nint N, H;\n\nint f(int y){ return y <= H ? y + H : y - H; }\n\nint vst[MX];\nvoid dfs(int s){\n\tfor(pii c : G[s]){\n\t\tif( vst[c.second] ) continue;\n\t\tvst[c.second] = 1;\n\t\tdfs(c.first);\n\t}\n}\n\nstruct UF{\n\tint t[MX];\n\tint find(int x){ return t[x] ? t[x] = find(t[x]) : x; }\n\tint merge(int a, int b){\n\t\ta = find(a), b = find(b);\n\t\treturn a == b ? 0 : (t[a] = b, 1);\n\t}\n} uf;\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &H);\n\tfor(int i = 1; i <= N; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x, y;\n\t\tif( c == 0 ) x = a + H;\n\t\telse x = c;\n\t\tif( d == 0 ) y = b + H;\n\t\telse y = d;\n\t\tG[x].emplace_back(f(y), i);\n\t\tuf.merge(x, f(y));\n\t\tind[f(y)]++;\n\t}\n\tint s = -1, cnt = 0, e = -1;\n\tfor(int i = H+1; i <= 2*H; i++){\n\t\tif( G[i].size() < ind[i] ) return !printf(\"NO\\n\");\n\t}\n\tfor(int i = 1; i <= H; i++){\n\t\tif( G[i].size() > ind[i] ) return !printf(\"NO\\n\");\n\t}\n\tset<int> X;\n\tfor(int i = 1; i <= 2*H; i++) X.insert(uf.find(i));\n\tfor(int i = 1; i <= 2*H; i++){\n\t\tif( G[i].size() != ind[i] || G[i].size() == 0|| G[i].size() == 0) X.erase(uf.find(i));\n\t}\n\tif( X.size() ) return !printf(\"NO\\n\");\n\tprintf(\"YES\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    int n,h;\n    cin >> n >> h;\n    vector<int> p(h+1),q(h+1);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;    \n        if(c==0){\n            p[a]++;\n        }else{\n            q[c]++;\n        }\n        if(d==0){\n            q[b]--;\n        }else{\n            p[d]--;\n        }\n    }\n    int c = 0;\n    int d = 0;\n    rep(i,h+1){\n        if(abs(p[i])>1){\n            cout << \"NO\" << endl;\n            return 0;\n        }else{\n            if(p[i]==1){\n                c++;\n            }else if(p[i]==-1){\n                cout << \"NO\" << endl;\n                return 0;\n                d++;\n            }\n        }\n        if(abs(q[i])>1){\n            cout << \"NO\" << endl;\n            return 0;\n        }else{\n            if(q[i]==1){\n                cout << \"NO\" << endl;\n                return 0;\n                c++;\n            }else if(q[i]==-1){\n                d++;\n            }\n        }\n    }\n    if((c==d)&&c>0){\n        cout << \"YES\" << endl;\n    }else{\n        assert(0);\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ninline void read(int &x){\n    x=0;static char ch;static bool flag;flag = false;\n    while(ch=getchar(),ch<'!');if(ch == '-') ch=getchar(),flag = true;\n    while(x=10*x+ch-'0',ch=getchar(),ch>'!');if(flag) x=-x;\n}\n#define rg register int\n#define rep(i,a,b) for(rg i=(a);i<=(b);++i)\n#define per(i,a,b) for(rg i=(a);i>=(b);--i)\nconst int maxn = 512;\nconst int zero = 250;\nint fa[maxn],siz[maxn],oud[maxn],ind[maxn];bool h[maxn];\nint find(int x){return fa[x] == x ? x : fa[x] = find(fa[x]);}\ninline void Union(int x,int y){\n    x = find(x);y = find(y);\n    if(x == y) {++siz[x];return ;}\n    fa[x] = y;siz[y] += siz[x] + 1;\n}\nint main(){\n    int n,H;read(n);read(H);\n    rep(i,1,H)  fa[i+zero] = i+zero,siz[i+zero] = 1;\n    rep(i,-H,-1)fa[i+zero] = i+zero,siz[i+zero] = 1;\n    int a,b,c,d;\n    rep(i,1,n){\n        int x,y;\n        read(a);read(b);read(c);read(d);\n        if(c == 0) x = a;else x = -c;\n        if(d == 0) y = -b;else y = d;\n        ++ oud[x + zero];++ ind[y + zero];\n        Union(x+zero,y+zero);\n    }\n    rep(i,1,H)  if(oud[i+zero] < ind[i+zero]) return puts(\"NO\"),0;\n    rep(i,-H,-1)if(ind[i+zero] < oud[i+zero]) return puts(\"NO\"),0;\n    rep(i,1,H)  h[find(i+zero)] |= (ind[i+zero]!=oud[i+zero]);\n    rep(i,-H,-1)h[find(i+zero)] |= (ind[i+zero]!=oud[i+zero]);\n    rep(i,1,H)  if(siz[find(i+zero)] > 1 && (find(i+zero) == i+zero) && (h[i+zero] == false)) return puts(\"NO\"),0;\n    rep(i,-H,-1)if(siz[find(i+zero)] > 1 && (find(i+zero) == i+zero) && (h[i+zero] == false)) return puts(\"NO\"),0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 500\nusing namespace std;\nint read(){\n    int nm=0,fh=1; int cw=getchar();\n    for(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n    for(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n    return nm*fh;\n}\nint n,m,e1,e2,h1,h2,cnt,in[M],ot[M],f[M]; bool vs[M];\nint fd(int x){return x==f[x]?x:f[x]=fd(f[x]);}\nint main(){\n    n=read(),m=read();\n    for(int i=1;i<=m;i++) f[i]=i,f[i+m]=i+m,vs[i]=vs[i+m]=false;\n    for(int i=1;i<=n;i++){\n        h1=read(),h2=read(),e1=read(),e2=read();\n        int t1=e1>0?e1:-h1,t2=e2>0?-e2:h2; t1+=m,t2+=m;\n        if(fd(t1)!=fd(t2)) f[fd(t1)]=fd(t2); in[t2]++,ot[t1]++;\n    }\n    for(int i=-m;i<0;i++) if(in[i+m]>ot[i+m]){puts(\"NO\");return 0;}\n    for(int i=1;i<=m;i++) if(in[i+m]<ot[i+m]){puts(\"NO\");return 0;}\n    for(int i=0;i<=m+m;i++) if(in[i]!=ot[i]) vs[fd(i)]=true;\n    for(int i=0;i<=m+m;i++) if(in[i]&&ot[i]&&!vs[fd(i)]){puts(\"NO\");return 0;}\n    puts(\"YES\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nstruct P{\n\tint a,b,c,d;\n}a[100005];\nstruct edge{\n\tint k,next;\n}e[200005];\nint n,h,IN[405],home[405],cnt=-1;\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nint D;\nbool vis[405],used[405];\nvoid dfs(int k){\n\tvis[k]=1;\n\tif(IN[k]) D=1;\n\tfor(int i=home[k];~i;i=e[i].next) if(!vis[e[i].k])\n\t\tdfs(e[i].k);\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a[i].a,&a[i].b,&a[i].c,&a[i].d);\n\t\tint x=a[i].c?a[i].c:a[i].a+h,y=a[i].d?a[i].d+h:a[i].b;\n\t\tadd(x,y);add(y,x);\n\t\tIN[x]--;IN[y]++;\n\t}\n\tint t=0;\n\tfor(int i=1;i<=h;i++) if(IN[i]<0) t=1;\n\tfor(int i=h+1;i<=h+h;i++) if(IN[i]>0) t=1;\n\tif(t) return puts(\"NO\"),0;\n\tfor(int i=1;i<=h+h;i++) if(!vis[i]&&home[i]!=-1){\n\t\tD=0;dfs(i);\n\t\tif(!D) return puts(\"NO\"),0;\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define neko 100005\n#define heko 405\n#define qwq return putchar('Y'),putchar('E'),putchar('S'),0; \n#define orz return putchar('N'),putchar('O'),0; \n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))\nstatic int n,H;\ntypedef int arr[heko];\nstatic arr fa,book,dgi,dgo,out;\nnamespace IO\n{\n\tconst unsigned int bufsize=1<<16,outsize=1<<24;\n\tstatic char ch[bufsize],*S=ch,*T=ch;\n\tinline char getc()\n\t{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\n\tstatic char Out[outsize],*nowp=Out;\n\tinline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\n\t\tvoid read(T &x)\n\t\t{\n\t\t\tchar c=getc();x=0;\n\t\t\tfor(;!isdigit(c);c=getc());\n\t\t\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n\t\t}\n\ttemplate<typename T>\n\t\tvoid write(T x,char c='\\n')\n\t\t{\n\t\t\tif(!x)*nowp++='0';\n\t\t\tstatic unsigned int stk[50],tp=0;\n\t\t\tfor(;x;x/=10)stk[++tp]=x%10;\n\t\t\tfor(;tp;*nowp++=stk[tp--]^'0');*nowp++=c;\n\t\t}\n}\ninline int find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}\nint main()\n{\n\tusing namespace IO;\n\tint x,y,z,o,X,Y,HH;\n\tread(n),read(H),HH=H<<1;\n\tf(i,0,HH)fa[i]=i;\n\tf(i,1,n)\n\t{\n\t\tread(x),read(y),read(z),read(o);\n\t\tif(z==0)X=H+x;\n\t\telse X=H-z;\n\t\tif(o==0)Y=H-y;\n\t\telse Y=H+o;\n\t\tbook[X]=book[Y]=1;\n\t\t++dgi[Y],++dgo[X];\n\t\tfa[find(Y)]=find(X);\n\n\t}\n\tf(i,0,H)if(dgi[i]<dgo[i])orz;\n\tf(i,H+1,HH)if(dgi[i]>dgo[i])orz;\n\tf(i,0,HH)out[fa[i]]|=(dgi[i]^dgo[i]);\n\tf(i,0,HH)if(fa[i]==i&&book[i]&&!out[fa[i]])orz;\n\tqwq;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 410\nint n,h;\nint in[MAXN],out[MAXN],cnt[MAXN],fa[MAXN];\nint Find(int x)\n{\n\treturn fa[x]==0?x:fa[x]=Find(fa[x]);\n}\nint main()\n{\n\tint a,b,c,d,x,y;\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=c==0?a:(c+200);\n\t\ty=d==0?(b+200):d;\n\t\tin[y]++,out[x]++;\n\t\tx=Find(x),y=Find(y);\n\t\tif(x!=y)\n\t\t\tfa[x]=y;\n\t}\n\tbool f=1;\n\tfor(int i=1;i<=400;i++)\n\t\tif(in[i]!=out[i])\n\t\t{\n\t\t\tif((in[i]<out[i]&&i>200)||(in[i]>out[i]&&i<200))\n\t\t\t{\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint x=Find(i);\n\t\t\tcnt[x]++;\n\t\t}\n\tif(f)\n\t{\n\t\tfor(int i=1;i<=400;i++)\n\t\t\tif((in[i]||out[i])&&cnt[Find(i)]==0)\n\t\t\t{\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif(f) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <queue>\n#include <limits>\n#include <deque>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#define mp make_pair\n#define fs first\n#define se second\n#define memset(a,t) memset(a,t,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define MN 0LL\n#define Mx 200000005\n#define Mn -Mx\n#define MX 20000000000000005\nusing namespace std;\nint readint(){\n\tchar c;\n\twhile(c=getchar(),(c<'0'||c>'9')&&c!='-');\n\tbool flag=(c=='-');\n\tif(flag)c=getchar();\n\tint x=0;\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn flag?-x:x;\n}\ninline string tos(int x){\n\tstring s;\n\twhile(x) s=(char)(x%10+'0')+s,x/=10;\n\treturn s;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint r;\n\tsrand(time(NULL));\n\tr=rand()%2;\n\tif(r==1) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, H, A[100009], B[100009], C[100009], D[100009], L[100009], R[100009], deg[100009], deg2[100009], cnt;\n\nint main() {\n\tcin >> N >> H; H++;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\t\tif (C[i] == 0) { L[i] = -A[i]; cnt++; } else { L[i] = C[i]; }\n\t\tif (D[i] == 0) { R[i] = -B[i]; cnt++; } else { R[i] = D[i]; }\n\t\tR[i] *= -1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint a1 = 0, a2 = 0;\n\t\tif (L[i] < 0) a1 = H + (-L[i]); else a1 = L[i];\n\t\tif (R[i] < 0) a2 = H + (-R[i]); else a2 = R[i];\n\t\tdeg[a1]++; deg[a2]--;\n\t\tif ((L[i] > 0 && R[i] < 0) || (L[i] < 0 && R[i] > 0)) { deg2[a1]++; deg2[a2]--; }\n\t}\n\tbool OK = true; int V = 0;\n\tfor (int i = 0; i < H; i++) { if (deg[i] > 0) OK = false; }\n\tfor (int i = H; i < 2 * H; i++) { if (deg[i] < 0) OK = false; else V += deg[i]; }\n\n\tif (V == 0 || V != (cnt - N)) OK = false;\n\n\tint V2 = 0;\n\tfor (int i = 0; i < H; i++) V2 -= deg2[i];\n\tif (V2 != (cnt - N)) OK = false;\n\n\tif (OK == true) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VL vector<long long>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\n#define INF 1034567890\nint e[1000][1000],cnt[1000],visited[1000][1000];\nbool used[SIZE];\nint N,H;\nint bfs[SIZE];\nbool go(int x){\n    int v=0,v2=0;\n    bfs[0]=x;\n    int rr=1;\n    used[x]=1;\n    REP(i,rr){\n        x=bfs[i];\n        if(x<=H||x>3*H)v+=cnt[x];\n        else v-=cnt[x];\n        v2+=cnt[x];\n        REPP(j,1,4*H+1){\n            if(e[x][j]){\n                visited[x][j]=1;\n                if(!used[j]){\n                    bfs[rr++]=j;\n                    used[j]=1;\n                }\n            }\n            if(e[j][x]){\n                visited[j][x]=1;\n                if(!used[j]){\n                    bfs[rr++]=j;\n                    used[j]=1;\n                }\n            }\n        }\n        int pp=-1;\n        if(x>2*H)pp=x-2*H;\n        else pp=x+H*2;\n        if(pp!=-1){\n            if(!used[pp]){\n                bfs[rr++]=pp;\n                used[pp]=1;\n            }\n        }\n    }\n    if(!v2)return 1;\n    if(!v)return 0;\n    return 1;\n}\nint main(){\n    RII(N,H);\n    REP(i,N){\n        DRII(A,B);\n        DRII(C,D);\n        int x,y;\n        if(!C)x=A;\n        else x=H+C;\n        if(!D)y=3*H+B;\n        else y=2*H+D;\n        \n        cnt[x]++;\n        cnt[y]++;\n        e[x][y]=1;\n    }\n    REPP(i,1,H+1){\n        if(cnt[i]<cnt[i+2*H])return 0*puts(\"NO\");\n        if(cnt[H*3+i]<cnt[H+i])return 0*puts(\"NO\");\n    }\n    REPP(i,1,H+1){\n        if(!used[i]){\n            if(!go(i))return 0*puts(\"NO\");\n        }\n    }\n    REPP(i,1,4*H+1)REPP(j,1,4*H+1){\n        if(e[i][j]&&!visited[i][j]){\n            return 0*puts(\"NO\");\n        }\n    }\n    return 0*puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, cnt[1005], in[1005], out[1005], par[1005], ta, tb, tc, td;\nbool o[1005];\n\nint find(int a) {\n\tif (par[a] == a)\n\t\treturn a;\n\treturn par[a] = find(par[a]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &ta);\n\tfor (int i = 0; i < 1005; i++)\n\t\tpar[i] = i;\n\twhile (n--) {\n\t\tscanf(\"%d%d%d%d\", &ta, &tb, &tc, &td);\n\t\tif (tc == 0)\n\t\t\tta = 500 + ta;\n\t\telse\n\t\t\tta = 500 - tc;\n\t\tif (td == 0)\n\t\t\ttb = 500 - tb;\n\t\telse\n\t\t\ttb = 500 + td;\n\t\tif (find(ta) != find(tb))\n\t\t\tpar[par[ta]] = par[tb];\n\t\tout[ta]++;\n\t\tin[tb]++;\n\t}\n\tfor (int i = 0; i < 1005; i++)\n\t\tif (in[i] * out[i] == 0 || in[i] != out[i])\n\t\t\to[i] = o[find(i)] = 1;\n\tfor (int i = 0; i < 1005; i++)\n\t\tif ((i > 500 && out[i] < in[i]) || (i < 500 && out[i] > in[i]) || !o[find(i)]) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 1e5 + 5, MAXH = 205;\nconst int MAXV = MAXH * 2 + 5, MAXE = MAXN;\n\nint N, H;\nint A[MAXN], B[MAXN], C[MAXN], D[MAXN];\n\nvoid input()\n{\n    read(N); read(H);\n    for (int i = 1; i <= N; ++i) {\n        read(A[i]); read(B[i]); read(C[i]); read(D[i]);\n    }\n}\n\nvector<int> G[MAXV];\nint indeg[MAXN], oudeg[MAXN];\nbool vis[MAXN];\nint cnt;\n\nvoid dfs(int u)\n{\n    vis[u] = true;\n    cnt += (indeg[u] != oudeg[u]);\n    for (int i = 0; i < SZ(G[u]); ++i) {\n        int v = G[u][i];\n        if (!vis[v])\n            dfs(v);\n    }\n}\n\nvoid solve()\n{\n    for (int i = 1; i <= N; ++i) {\n        int u = C[i] ? C[i] : A[i] + H;\n        int v = D[i] ? D[i] + H : B[i];\n        G[u].push_back(v);\n        G[v].push_back(u);\n        ++indeg[v];\n        ++oudeg[u];\n    }\n\n    int s = 0, t = 0;\n    for (int i = 1; i <= H; ++i) {\n        if (indeg[i] < oudeg[i])\n            goto FAIL;\n    }\n    for (int i = H + 1; i <= H * 2; ++i) {\n        if (indeg[i] > oudeg[i])\n            goto FAIL;\n    }\n\n    for (int i = 1; i <= H * 2; ++i) {\n        if (vis[i] || SZ(G[i]) == 0)\n            continue;\n        cnt = 0;\n        dfs(i);\n        if (!cnt)\n            goto FAIL;\n    }\n\n    puts(\"YES\");\n    return;\n  FAIL:\n    puts(\"NO\");\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"E.in\", \"r\", stdin);\n    freopen(\"E.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 细雨春芜上林苑，颓垣夜月洛阳宫。\n//     -- 陆游《书愤五首·其二》\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e6;\n\nint n, h;\nint a[N], b[N], c[N], d[N], vis[N], in[N], out[N], fa[N];\n\nint read(void) {\n    int s = 0, w = 0;\n    char c = getchar();\n    while (c < '0' || c > '9') w |= c == '-', c = getchar();\n    while (c >= '0' && c <= '9') s = s * 10 + c - 48, c = getchar();\n    return w ? -s : s;\n}\n\nint get(int x) {\n\tif (fa[x] == x) return x;\n\treturn fa[x] = get(fa[x]); \n}\n\nbool check(void)\n{\n\tfor (int i=-h;i<0;++i) \n\t\tif (in[i+h] > out[i+h]) return 0;\n\tfor (int i=1;i<=h;++i)\n\t    if (in[i+h] < out[i+h]) return 0;\n\tfor (int i=-h;i<=h;++i)\n\t    if (in[i+h] != out[i+h]) vis[get(i+h)] = 1;\n\t    else if (in[i+h] +out[i+h] == 0) vis[get(i+h)] = 1;\n\tfor (int i=-h;i<=h;++i)\n\t\tif (vis[get(i+h)] == 0) return 0;\n\treturn 1;\n\t\n}\n\nint main(void)\n{\n\tn = read(), h = read();\n\tfor (int i=0;i<=1000;++i) fa[i] = i;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\ta[i] = read(); b[i] = read();\n\t\tc[i] = read(); d[i] = read();\n\t\tint x = c[i] == 0 ? h-a[i] : h+c[i];\n\t\tint y = d[i] == 0 ? h+b[i] : h-d[i];\n\t\tout[x] ++, in[y] ++;\n\t\tfa[get(x)] = get(y);\n\t}\n\tif (check()) cout << \"YES\";\n\telse cout << \"NO\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int Z = 210;\nconst int N = 500;\nvector<int> g[N];\nint deg[N];\nbool used[N];\n\nvoid dfs(int v)\n{\n    used[v] = 1;\n    for (int u : g[v])\n        if (!used[u])\n            dfs(u);\n}\n\nint main()\n{\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    while(n--) {\n        int a, b, c, d;\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        a += c;\n        b += d;\n        int v, u;\n        if (c == 0) {\n            v = Z + a;   \n        } else {\n            v = Z - c;\n        }\n        if (d == 0) {\n            u = Z - b;\n        } else {\n            u = Z + d;\n        }\n        g[v].push_back(u);\n        deg[v]++;\n        deg[u]--;\n    }\n    for (int v = 0; v < N; v++) {\n        if (deg[v] == 0) continue;\n        if (abs(deg[v]) != 1) {\n            printf(\"NO\\n\");\n            return 0;\n        }\n        if (deg[v] == -1) {\n            if (v >= Z) {\n                printf(\"NO\\n\");\n                return 0;\n            }\n        } else {\n            if (v <= Z) {\n                printf(\"NO\\n\");\n                return 0;\n            }\n            if (!used[v]) dfs(v);\n        }\n    }\n    for (int v = 0; v < N; v++) {\n        if (!used[v] && !g[v].empty()) {\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n    printf(\"YES\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing db = double;\n#define pb push_back\n\n#define ass(x) ({if(!(x)) return false;})\n\nconst int mxn = 206;\n\nint n, h;\nunordered_map<int,int> deg;\nunordered_map<int,bool> v;\n\nstruct DSU {\n\tunordered_map<int,int> p;\n\tvoid clear() {\n\t\tfor (int i = -200; i <= 200; ++i)\n\t\t\tp[i] = i;\n\t}\n\tint root(int x) {\n\t\treturn p[x] == x ? x : p[x] = root(p[x]);\n\t}\n\tvoid merge(int x, int y) {\n\t\tp[root(x)] = root(y);\n\t}\n\tint operator[](int x) { return root(x); }\n} U;\n\nunordered_map<int,int> f;\n\nbool connected() {\n\tfor (int i = -200; i <= 200; ++i)\n\t\tf[U[i]] |= i < 0 ? 1 : 2;\n\tfor (int i = -200; i <= 200; ++i) if (v[i])\n\t\tass(f[U[i]] == 3);\n\treturn true;\n}\n\nbool check() {\n\tfor (int i = -200; i <= 200; ++i)\n\t\tass(deg[i] == 0 || deg[i] == +1 && i > 0 || deg[i] == -1 && i < 0);\n\treturn true;\n}\n\nint main() {\n\tcin >> n >> h;\n\t\n\tU.clear();\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x, y;\n\t\tx = c ? -c : a;\n\t\ty = d ? -d : b;\n\t\ty = -y;\n\t\t++deg[x];\n\t\t--deg[y];\n\t\tv[x] = v[y] = true;\n\t\tU.merge(x, y);\n\t\t//cout << x << ' ' << y << endl;\n\t}\n\t\n\tputs(check() && connected() ? \"YES\" : \"NO\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\n#define A(a) ((a)<<1)\n#define B(a) ((a)<<1|1)\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nconst int MAXV = 200007;\nconst int MAXM = 2000007;\n\nstruct eT\n{\n\tvoid setd ( int _u, int _v, int _f, int _l )\n\t{\n\t\tu = _u, v = _v, f = _f, last = _l;\n\t}\n\n\tint u, v, f, last;\n}edge[MAXM];\n\nstruct bT\n{\n\tbT () {}\n\tbT ( int _h, int _l ) : h ( _h ), l ( _l ) {}\n\n\tvoid setd ( int _h, int _l )\n\t{\n\t\th = _h, l = _l;\n\t}\n\n\tbool operator < ( const bT &a ) const\n\t{\n\t\treturn ( h ^ a.h ) ? ( h < a.h ) : ( l < a.l );\n\t}\n\n\tbool operator == ( const bT &a ) const\n\t{\n\t\treturn ( h == a.h && l == a.l );\n\t}\n\n\tint h, l;\n}bl[MAXN], br[MAXN];\n\nint n, h, S, T;\nint ke, la[MAXV];\n\nint q[MAXV], lev[MAXV];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nvoid addedge ( int u, int v, int fu, int fv );\n\nint dinic ();\nbool bfs ();\nint dfs ( int now, int lim );\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\n\tscanf ( \"%d%d\", &n, &h );\n\tint a, b, c, d;\n\tlpi ( i, 1, n ){\n\t\tscanf ( \"%d%d%d%d\", &a, &b, &c, &d );\n\t\tbl[i].setd ( c, a ), br[i].setd ( d, b );\n\t}\n}\n\nvoid work ()\n{\n\t// main work\n\n\tbool flag;\n\tlpi ( i, 1, n ){\n\t\tflag = true;\n\t\tif ( !bl[i].h && br[i].h ){\n\t\t\tflag = false;\n\t\t\tlpi ( j, 1, n ){\n\t\t\t\tif ( !bl[j].h && bl[j].l == br[i].h && ( ! ( ( bl[i] == bl[j] ) && ( br[i] == br[j] ) ) ) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( bl[i].h && !br[i].h ){\n\t\t\tflag = false;\n\t\t\tlpi ( j, 1, n ){\n\t\t\t\tif ( !br[j].h && br[j].l == bl[i].h && ( ! ( ( bl[i] == bl[j] ) && ( br[i] == br[j] ) ) ) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( !flag ){\n\t\t\tprintf ( \"NO\\n\" );\n\t\t\treturn;\n\t\t}\n\t}\n\n\tS = MAXV - 1, T = MAXV - 2;\n\tint SS = MAXV - 3, TT = MAXV - 4;\n\tke = 0;\n\tINIT ( la, -1 );\n\n\tmap < bT, PII > ml, mr;\n\tmap < bT, PII > ::iterator it;\n\n\tAR( int ) keye;\n\tint ks = 0;\n\n\tlpi ( i, 1, n ){\n\t\t++ml[bl[i]].first;\n\t\t++mr[br[i]].first;\n\t}\n\n\tint kl = 0, kr = 0;\n\tfor ( auto &x : ml ) x.second.second = ++kl;\n\tfor ( auto &x : mr ) x.second.second = ++kr;\n\n//\tint cl = 0, cr = 0;\n\tfor ( auto x : ml ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, A( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( A( x.second.second ), TT, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = mr.find ( bT ( 0, x.first.h ) ) ) != mr.end () ){\n\t\t\t\taddedge ( B( it->second.second ), A( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n//\t\t\tcl += x.second.first;\n\t\t\taddedge ( A( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n\tfor ( auto x : mr ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, B( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( B( x.second.second ), SS, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = ml.find ( bT ( 0, x.first.h ) ) ) != ml.end () ){\n\t\t\t\taddedge ( A ( it->second.second ), B( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n//\t\t\tcr += x.second.first;\n\t\t\taddedge ( B( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n//\taddedge ( SS, T, INF, 0 );\n//\taddedge ( TT, T, INF, 0 );\n\n/*\tif ( cl ^ cr ){\n\t\tprintf ( \"NO\\n\" );\n\t\treturn;\n\t}*/\n\n\tif ( ks >= n ){\n\t\tprintf ( \"NO\\n\" );\n\t\treturn;\n\t}\n\n\tdinic ();\n\n\tflag = true;\n\tfor ( auto x : keye ){\n\t\tif ( edge[x].f ){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf ( flag ? \"YES\\n\" : \"NO\\n\" );\n}\n\n\n\nvoid addedge ( int u, int v, int fu, int fv )\n{\n\tedge[ke].setd ( u, v, fu, la[u] );\n\tla[u] = ke++;\n\tedge[ke].setd ( v, u, fv, la[v] );\n\tla[v] = ke++;\n}\n\nint dinic ()\n{\n\tint ans = 0;\n\twhile ( bfs () ) ans += dfs ( S, INF );\n\treturn ans;\n}\n\nbool bfs ()\n{\n\tint l = 0, r = 0, now, v;\n\tq[r++] = S;\n\tINIT ( lev, -1 );\n\tlev[S] = 1;\n\twhile ( l < r ){\n\t\tnow = q[l++];\n\t\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\t\tif ( edge[i].f && lev[v=edge[i].v] == -1 ){\n\t\t\t\tlev[v] = lev[now] + 1;\n\t\t\t\tq[r++] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ( lev[T] != -1 );\n}\n\nint dfs ( int now, int lim )\n{\n\tif ( now == T ) return lim;\n\n\tint v, nf = 0, tf;\n\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\tif ( edge[i].f && lev[v=edge[i].v] == lev[now] + 1 ){\n\t\t\ttf = dfs ( v, qmin ( lim-nf, edge[i].f ) );\n\t\t\tnf += tf;\n\t\t\tedge[i].f -= tf, edge[i^1].f += tf;\n\n\t\t\tif ( nf == lim ) break;\n\t\t}\n\t}\n\n\tif ( !nf ) lev[now] = -1;\n\treturn nf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define NO return puts(\"NO\"),0\nusing namespace std;\n \nint n,m,f[1000],a,b,c,d,x,y,D[1000],bo[1000],C[1000];\nint gf(int x){return x==f[x]?x:f[x]=gf(f[x]);}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    \n    for (int i=1;i<999;i++) f[i]=i;\n    while (n--){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        if (c==0) x=a;else x=-c;x+=500;\n        if (d==0) y=-b;else y=d;y+=500;\n        f[gf(x)]=gf(y);\n        D[x]++;D[y]--;bo[x]=1;\n    }\n    for (int i=1;i<500;i++) if (D[i]>0) NO;\n    for (int i=501;i<999;i++) if (D[i]<0) NO;\n    for (int i=1;i<999;i++)\n    if (bo[gf(i)]|=bo[i],D[i]) C[f[i]]=1;\n    for (int i=1;i<999;i++)\n    if (f[i]==i&&!C[i]&&bo[i]) NO;\n    puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compiles and gets accepted.\n *  ___  __     _______    _______      \n * |\\  \\|\\  \\  |\\  ___ \\  |\\  ___ \\     \n * \\ \\  \\/  /|_\\ \\   __/| \\ \\   __/|    \n *  \\ \\   ___  \\\\ \\  \\_|/__\\ \\  \\_|/__  \n *   \\ \\  \\\\ \\  \\\\ \\  \\_|\\ \\\\ \\  \\_|\\ \\ \n *    \\ \\__\\\\ \\__\\\\ \\_______\\\\ \\_______\\\n *     \\|__| \\|__| \\|_______| \\|_______|\n */\nconst long long mod = 1000000007;\n\nstruct p {\n\tint A,B,C,D;\n\tbool operator<(p & o) {\n\t\treturn make_pair(C,A) < make_pair(o.C,o.A);\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tsrand(time(NULL));\n\tint N,H;\n\tcin>>N>>H;\n\tvector<p> a(N);\n\tbool f = false;\n\tfor(int i = 0;i < N;i++) {\n\t\tcin>>a[i].A>>a[i].B>>a[i].C>>a[i].D;\n\t\tf |= a[i].D == 0;\n\t}\n\tsort(a.begin(),a.end());\n\tif(a[0].C != 0 || !f) {\n\t\tcout<<\"NO\\n\";\n\t}\n\tbool can = false;\n\tint cnt = 50000000ll/N;\n\tfor(int i = 0;i < cnt && !can;i++) {\n\t\trandom_shuffle(a.begin(),a.end());\n\t\tif(a[0].C != 0 || a.back().D != 0) continue;\n\t\tbool cur = true;\n\t\tfor(int i = 1;i < N;i++) {\n\t\t\tif(a[i].C == 0) {\n\t\t\t\tcur &= a[i-1].D == a[i].A;\n\t\t\t} else {\n\t\t\t\tcur &= a[i-1].B == a[i].C;\n\t\t\t\tcur &= a[i-1].D == 0;\n\t\t\t}\n\t\t}\n\t\tcan |= cur;\n\t}\n\tcout<<(can?\"YES\":\"NO\")<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, h, S, E, cnt, c, id[405], od[405], vis[405], chk;\nvector<int> e[405];\n\nvoid T_T(){ puts(\"NO\"); exit(0); }\nvoid O_O(){ puts(\"YES\"); exit(0); }\n\nvoid f(int x){\n\tvis[x] = 1;\n\tc++;\n\tfor(auto &i : e[x]){\n\t\tif(!vis[i]) f(i);\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &h);\n\tfor(int i = 0, a, b, c, d; i < n; i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint st, en;\n\t\tif(c == 0) st = a;\n\t\telse st = c + h;\n\t\tif(d == 0) en = b + h;\n\t\telse en = d;\n\t\te[st].push_back(en);\n\t\tod[st]++; id[en]++;\n\t\tif(st > h && en <= h) chk = 1;\n\t}\n\tif(!chk) T_T();\n\tfor(int i = 1; i <= 2 * h; i++){\n\t\tif(od[i] || id[i]) cnt++;\n\t\tif(abs(od[i] - id[i]) > 1) T_T();\n\t\tif(od[i] - id[i] == 1){\n\t\t\tif(i > h) T_T();\n\t\t\tS++;\n\t\t}\n\t\tif(od[i] - id[i] == -1){\n\t\t\tif(i <= h) T_T();\n\t\t\tE++;\n\t\t}\n\t}\n\tif(S != E) T_T();\n\tO_O();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n\n\n#define N 112345\n#define H 205\nint n;\nvector<int> a[H], b[H], c[H], d[H];\n\n#define V 200410\nstruct edge{int to, cap, rev;};\nvector<edge> G[V];\nbool used[V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, 0, G[from].size()-1});\n\t//G[to].push_back((edge){from, cap, G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n\tif(v==t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif(f==0) return flow;\n\t\tflow += f;\n\t}\n}\n\n\n\nint main(){\n\tint h;\n\tcin>>n>>h;\n\trep(i, n){\n\t\tint aa, bb, cc, dd;\n\t\tcin>>aa>>bb>>cc>>dd;\n\t\tif(cc==0) a[aa].push_back(i);\n\t\telse c[cc].push_back(i);\n\t\tif(dd==0) b[bb].push_back(i);\n\t\telse d[dd].push_back(i);\n\t}\n\tint s = 2*n+2*h, t = s+1, s2 = t+1, t2 = s2+1;\n\tadd_edge(s, s2, n);\n\tadd_edge(t2, t, n);\n\tfor(int i = 0; i < h; i++){\n\t\tadd_edge(s2, 2*n+i, n);\n\t\tadd_edge(2*n+h+i, t2, n);\n\t\tfor(auto x: a[i+1]){\n\t\t\tadd_edge(2*n+i, x, 1);\n\t\t\tadd_edge(s, n+x, 1);\n\t\t}\n\t\tfor(auto x: d[i+1]) add_edge(n+x, 2*n+i, 1);\n\t\tfor(auto x: c[i+1]) add_edge(2*n+h+i, x, 1);\n\t\tfor(auto x: b[i+1]){\n\t\t\tadd_edge(n+x, 2*n+h+i, 1);\n\t\t\tadd_edge(x, t, 1);\n\t\t}\n\t}\n\t//rep(i, n) add_edge(i, n+i, 1);\n\tint f = max_flow(s, t); cerr<<f<<endl;\n\tif(f == n) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\nint ind[500];\nint outd[500];\nbool used[500];\nvector<int> es[500];\n\nint MakeVertex(int a, int c, bool rev=false) {\n  if (c == 0) return a+rev*(H+1);\n  return c+(H+1)*!rev;\n}\n\npii GetIO(int v, pii &cnt) {\n  if (es[v].empty()) {\n    return pii(0, 0);\n  }\n\n  used[v] = true;\n  pii ret(0, 0);\n  for (int u : es[v]) {\n    if (used[u]) continue;\n    auto res = GetIO(u, cnt);\n    ret.X += res.X;\n    ret.Y += res.Y;\n  }\n\n  if (v >= H+1) {\n    assert(ind[v] - outd[v] >= 0);\n    cnt.X += 1;\n    ret.X += ind[v] - outd[v];\n  } else {\n    assert(outd[v] - ind[v] >= 0);\n    cnt.Y += 1;\n    ret.Y += outd[v] - ind[v];\n  }\n\n  return ret;\n}\n\nsigned main(){\n  cin >> N >> H;\n\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    \n    int u = MakeVertex(A[i], C[i], true);\n    int v = MakeVertex(B[i], D[i], false);\n\n    ind[u]++;\n    outd[v]++;\n\n    es[u].eb(v);\n    es[v].eb(u);\n  }\n\n  rep(v, H+1) {\n    if (ind[v] > outd[v]) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n\n  reps(v, H+1, 2*(H+1)) {\n    if (ind[v] < outd[v]) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n\n  rep(v, 2*(H+1)) {\n    if (es[v].empty()) continue;\n    if (used[v]) continue;\n\n    pii cnt(0, 0);\n    auto res = GetIO(v, cnt);\n    //cout << res.X << \", \" << res.Y << endl;\n    //cout << cnt.X << \", \" << cnt.Y << endl;\n    bool fail = false;\n    fail |= res.X != res.Y;\n    fail |= cnt.X > 0 && cnt.Y == 0;\n    fail |= cnt.X == 0 && cnt.Y > 0;\n    fail |= res.X == 0; \n    if (fail) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n\n  cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nvoid fail(int i) {\n    printf(\"NO\\n\", i);\n    exit(0);\n}\n\nint n, h;\nstruct block {\n    int l, r;\n    void scan() {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        if (c == 0) l = a << 1;\n        else l = c << 1 | 1;\n        if (d == 0) r = b << 1 | 1;\n        else r = d << 1;\n    }\n} bs[100000];\n\nint par[402];\nint find(int x) {\n    if (par[x] != x) return par[x] = find(par[x]);\n    return x;\n}\n\nint cnt[402];\nint ex[402];\nint zr[402];\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tfor (int i = 0; i < 402; ++i) par[i] = i;\n    cin >> n >> h;\n    for (int i = 0; i < n; ++i) {\n        bs[i].scan();\n        ++cnt[bs[i].l];\n        --cnt[bs[i].r];\n        ex[bs[i].l] = 1;\n        ex[bs[i].r] = 1;\n        par[find(bs[i].l)] = find(bs[i].r);\n    }\n    for (int i = 0; i < 402; ++i) {\n        if (cnt[i] < 0 && ((i ^ 1) & 1)) fail(0);\n        if (cnt[i] > 0 && ((i ^ 0) & 1)) fail(1);\n        if (cnt[i] != 0) zr[find(i)] = 1;\n    }\n    for (int i = 0; i < 402; ++i) {\n        if (ex[i] == 0) continue;\n        if (find(i) != i) continue;\n        if (zr[i] == 0) fail(2);\n    }\n    printf(\"YES\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint inadj[210][2], outadj[210][2], n, h;\nint inadj2[210][2], outadj2[210][2];\npair<int, int> thing(int a, int b)\n{\n\tpair<int, int> ans;\n\tif (b) ans = { b, 0 };\n\telse ans = { a, 1 };\n\treturn ans;\n}\nvector<pair<int, int> > adj[210][2];\nint seen[210][2], c;\nvector<pair<int, int> > components[500];\nvoid dfs(int a, int b, int d)\n{\n\tif (seen[a][b]) return;\n\tseen[a][b] = 1;\n\tcomponents[d].push_back({ a, b });\n\tfor (auto c : adj[a][b]) dfs(c.first, c.second, d);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tpair<int, int> in, out;\n\t\tin = thing(a, c);\n\t\tout = thing(b, d);\n\t\tout.second = !out.second;\n//\t\tprintf(\"%d %d -> %d %d\\n\", in.first, in.second, out.first, out.second);\n\t\toutadj[in.first][in.second]++;\n\t\tinadj[out.first][out.second]++;\n\t\tadj[in.first][in.second].push_back(out);\n\t\tadj[out.first][out.second].push_back(in);\n\t}\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tif (adj[i][j].size() && !seen[i][j]) dfs(i, j, c++);\n\t\t//\tprintf(\"%d:%d - in %d, out %d\\n\", i, j, inadj[i][j], outadj[i][j]);\n\t\t}\n\t}\n\tbool works = 1;\n\tfor (int i = 0; i < c; i++)\n\t{\n\t\tfor (int i = 0; i <= h; i++) inadj2[i][0] = inadj2[i][1] = outadj2[i][0] = outadj2[i][1] = 0;\n\t\tfor (auto b : components[i])\n\t\t{\n\t\t\tinadj2[b.first][b.second] += inadj[b.first][b.second];\n\t\t\toutadj2[b.first][b.second] += outadj[b.first][b.second];\n\t\t}\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\t//printf(\"%d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\tif (inadj2[i][0] - outadj2[i][0] > 0 && inadj2[i][1] - outadj2[i][1] < 0) \n\t\t\t{\n\t\t\t//\tprintf(\"%d\\n\", i);\n\t\t\t\tinadj2[i][0]--; \n\t\t\t\toutadj2[i][1]--;\n\t\t\t//\tprintf(\" %d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\t}\n\t\t}\n\t\tint extra = 0;\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t{\n\t\t//\t\tprintf(\"  %d\\n\", abs(inadj2[i][j] - outadj2[i][j]));\n\t\t\t\tif (abs(inadj2[i][j] - outadj2[i][j]) == 1) extra++;\n\t\t\t\telse if (abs(inadj2[i][j] - outadj2[i][j])) extra += 10;\n\t\t\t}\n\t\t}\n\t\tif (extra != 2) works = 0;\n\t}\n//\tprintf(\"Components %d\\n\", c);\n\tassert(works);\n\tif (works) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 100000\n#define MX 200\nint d1[MX*2+5],d2[MX*2+5],f[MX*2+5];\nvector<int> v[MX*2+5];\nint gf(int k){return f[k]?f[k]=gf(f[k]):k;}\nint main()\n{\n\tint n,i,j,a,b,c,d;\n\tn=read();read();\n\tfor(i=1;i<=n;++i)\n\t\ta=read(),b=read(),c=read(),d=read(),a=(c?-c:a)+MX,b=(d?d:-b)+MX,\n\t\t++d1[a],++d2[b],gf(a)!=gf(b)?f[gf(a)]=gf(b):0;\n\tfor(i=1;i<=MX<<1;++i)if(d1[i]||d2[i])v[gf(i)].push_back(i);\n\tfor(i=1;i<=MX<<1;++i)if(v[i].size())\n\t{\n\t\tfor(j=a=b=0;j<v[i].size();++j)\n\t\t\tif(v[i][j]>MX)\n\t\t\t{\n\t\t\t\tif(d1[v[i][j]]<d2[v[i][j]])return 0*puts(\"NO\");\n\t\t\t\ta+=d1[v[i][j]]-d2[v[i][j]];\n\t\t\t\tb|=d1[v[i][j]]-d2[v[i][j]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(d2[v[i][j]]<d1[v[i][j]])return 0*puts(\"NO\");\n\t\t\t\ta+=d1[v[i][j]]-d2[v[i][j]];\n\t\t\t}\n\t\tif(!b||a)return 0*puts(\"NO\");\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    int n,h;\n    cin >>n>>h;\n    vector<pair<int,int>> rb{},lb{},rt{},lt{};\n    for (int i=0;i<n;i++){\n        int a,b,c,d;\n        cin>>a>>b>>c>>d;\n        if(c==0){\n            lb.push_back({i,a});\n        }else{\n            lt.push_back({i,c});\n        }\n        if(d==0){\n            rb.push_back({i,b});\n        }else{\n            rt.push_back({i,d});\n        }\n    }\n    sort(lb.begin(),lb.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(rb.begin(),rb.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(lt.begin(),lt.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(rt.begin(),rt.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n\n//    cout<<rb.size()<<\" \"\n//        <<rt.size()<<\" \"\n//        <<lb.size()<<\" \"\n//        <<lt.size()<<endl;\n\n    if(rb.size()-lt.size()<=0 ||\n       lb.size()-rt.size()<=0 ||\n       rb.size()-lt.size()!=lb.size()-rt.size()\n       ) {\n        cout<<\"NO\"<<endl;\n        return 0;\n    }\n    if(rb.size()==lt.size()+1){\n        int k=rb.size()-1,l=lb.size()-1;\n        for(int i=0;i<lt.size();i++){\n            static int offset=0;\n            if(lt.at(i).second!=rb.at(i+offset).second){\n                if(offset==1){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                if(lt.at(i).second!=rb.at(i+1).second){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                offset=1;\n                k=i;\n            }\n        }\n        for(int i=0;i<rt.size();i++){\n            static int offset=0;\n            if(rt.at(i).second!=lb.at(i+offset).second){\n                if(offset==1){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                if(rt.at(i).second!=lb.at(i+1).second){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                offset=1;\n                l=i;\n            }\n        }\n        if(rb.at(k).first==lb.at(l).first){\n            if((k==rb.size()-1 || rb.at(k+1).second!=rb.at(k).second) &&\n               (k==0 || rb.at(k-1).second!=rb.at(k).second) &&\n               (l==lb.size()-1 || lb.at(l+1).second!=lb.at(l).second) &&\n               (l==0 || lb.at(l-1).second!=lb.at(l).second)\n                    ) {\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n        }\n        cout<<\"YES\"<<endl;\n        return 0;\n    }\n    for(int i=0;i<lt.size();i++){\n        static int offset=0;\n        while(lt.at(i).second!=rb.at(i+offset).second){\n            if(offset==rb.size()-lt.size()){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            offset++;\n        }\n    }\n    for(int i=0;i<rt.size();i++){\n        static int offset=0;\n        while(rt.at(i).second!=lb.at(i+offset).second){\n            if(offset==lb.size()-rt.size()){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            offset++;\n        }\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\nint h;\n\n#define MAXX 202\nint lef[MAXX];\nint rig[MAXX];\n\nint deg[MAXX*2];\n\nvector<int> v[MAXX*2];\n\nint main(){\n\tfor (int i = 0; i < MAXX; i++){\n\t\tlef[i] = 2 * i;\n\t\trig[i] = lef[i] + 1;\n\t}\n\tcin >> n >> h;\n\tfor (int i = 0; i < n; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tif (c){\n\t\t\tdeg[lef[c]]++;\n\t\t}\n\t\telse{\n\t\t\tdeg[rig[a]]++;\n\t\t\tv[rig[a]].push_back(i);\n\t\t}\n\t\tif (d){\n\t\t\tdeg[rig[d]]--;\n\t\t}\n\t\telse{\n\t\t\tdeg[lef[b]]--;\n\t\t\tv[lef[b]].push_back(i);\n\t\t}\n\t}\n\tbool ng = false;\n\tint restr = 0;\n\tint restl = 0;\n\tint id = -1;\n\tint id2 = -1;\n\tfor (int i = 0; i < MAXX; i++){\n\t\tif (deg[rig[i]] >= 0 && deg[lef[i]] <= 0){\n\t\t\trestr += deg[rig[i]];\n\t\t\trestl += -deg[lef[i]];\n\t\t\tif (deg[rig[i]]){\n\t\t\t\tid = rig[i];\n\t\t\t}\n\t\t\tif (deg[lef[i]] < 0){\n\t\t\t\tid2 = lef[i];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tng = true;\n\t\t}\n\t}\n\tif (restr == 0 || restl == 0){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tif (ng){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tif (restr == 1 && restl == 1 && v[id].size() == 1 && v[id2].size() == 1 && v[id][0] == v[id2][0]){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:64777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <stdio.h>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <cassert>\n#include <complex>\n#include <time.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long Int;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\n\nconst int MAX = 512;\nconst int CNT = 17;\n\nint n, h, c0, c1, bal, e;\nVI G[MAX];\nVI GG[MAX];\nint D[MAX];\nint U[MAX];\n\nint getNext(int a, int b)\n{\n\treturn (a == 0 ? b : h + a);\n}\n\nint getPrev(int a, int b)\n{\n\treturn (a == 0 ? h + b : a);\n}\n\nvoid nope()\n{\n\tcout << \"NO\" << endl;\n\texit(0);\n}\n\nvoid dfs(int v)\n{\n\tU[v] = 1;\n\tif (v < h)\n\t{\n\t\t++ c0;\n\t\tbal -= D[v];\n\t}\n\tif (v >= h)\n\t\t++ c1;\n\n\tFOR (i,0,SZ(GG[v]))\n\t{\n\t\tint to = GG[v][i];\n\t\tif (U[to] == 0)\n\t\t\tdfs(to);\n\t\t++ e;\n\t}\n}\n\nint main()\n{\n\tfreopen(\"in.txt\", \"r\", stdin);\n\n\tcin >> n >> h;\n\t++ h;\n\n\tFOR (i,0,n)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tint u = getPrev(c, a);\n\t\tint v = getNext(d, b);\n\t\tG[u].PB(v);\n\t\tGG[u].PB(v);\n\t\tGG[v].PB(u);\n\t\t++ D[u];\n\t\t-- D[v];\n\t}\n\n\n\tFOR (i,0,h)\n\t\tif (D[i] > 0)\n\t\t\tnope();\n\n\tFOR (i,h,2*h)\n\t\tif (D[i] < 0)\n\t\t\tnope();\n\n\tint cnt = 0, alone = 0, bal0 = 0;\n\tFOR (i,0,2*h)\n\t{\n\t\tif (U[i]) continue;\n\t\tc0 = 0, c1 = 0, bal = 0, e = 0;\n\t\tdfs(i);\n\t\tif (e == 0) continue;\n\n\t\t++ cnt;\n\t\tif (c0 == 0 || c1 == 0)\n\t\t\t++ alone;\n\t\tif (bal == 0)\n\t\t\t++ bal0;\n\t}\n\n\tif (alone > 0)\n\t\tnope();\n\n\tcout << \"YES\" << endl;\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define LL long long\n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define fd(i,j,k) for(int i=j;i>=k;i--)\n#define fr(i,j) for(int i=beg[j];i;i=nex[i])\nusing namespace std;\nint const mn=1e5+3,mh=203;\nint n,h,gra,beg[mh*2],to[mn],nex[mn],vis[mh*2],ind[mh*2],outd[mh*2];\nvoid ins(int u,int v){\n\tto[++gra]=v;\n\tnex[gra]=beg[u];\n\tbeg[u]=gra;\n}\nvoid dfs(int p){\n\tvis[p]=1;\n\tfr(i,p)if(!vis[to[i]])dfs(to[i]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfo(i,1,n){\n\t\tint a,b,c,d,x,y;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c)x=-c;else x=a;\n\t\tif(d)y=d;else y=-b;\n\t\tx+=h;y+=h;\n\t\tins(x,y);\n\t\tind[y]++;\n\t\toutd[x]++;\n\t}\n\tfo(i,0,h)if(outd[i]>ind[i]){printf(\"NO\");return 0;}\n\tfo(i,h,h*2)if(outd[i]<ind[i]){printf(\"NO\");return 0;}\n\tfo(i,0,h*2)if((ind[i]!=outd[i])&&(!vis[i]))dfs(i);\n\tfo(i,0,h*2)if((ind[i]||outd[i])&&(!vis[i])){printf(\"NO\");return 0;}\n\tprintf(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Azat Ismagilov\n */\n\n/**********.*****.**************************:-******-:*******************\n**********......:*****************+@%@*+#@@@+.****.***********************\n...------........-*+*********+%#####@@@##########*************************\n********:........----------%@#####################@@-...............------\n**********......:********@%#####@###################@#@=+***************::\n*********.:****--******%##@#####@#######################@*+***************\n********.*******:-**+@@####@#@@@#################@#########=**************\n*******-*********:*@@@######@###############################=*************\n*****--**********%%@##@########@#############################=:***********\n****.************+##################@#@@#####################@************\n***.*************%######################@@###################=***********-\n*-:**************=##########@@%%%%=%@=%=%=%@################@@**********.*\n.****************########%++***+++****+++=+===+++***+=%@######%*******:-**\n****************+#######%+*::::::::::::***********:::::**@@###%******.:***\n****************#######@%*:::::::::::::::*:*****:::::::::*@@##@*****.*****\n****************######@%+*:::::::-::::::::::::::::::::::::=@##%****-******\n.......-------:*######=::::::----------:::::::::::::::::::+###:**--*******\n............:==:%####=:::::----:-:::::::::::::::::::::::::=@##:-.:********\n************=@++*%##@::::*=%%%@@###@=***::::::::::::::::::=@#@*..*********\n************=**+@+@#*:::**+++%@#@###%@%%+*::*+=======*::::*##-:**.********\n*************:=%%:%*::::*+=%##%###=@@@%=*::*=%@@@%%@@#@%::+#@:****.*******\n:**************==:=:::--::::*++++=%@@@%*:--*%#@####@#=+***@@%@*****.******\n--**************:-*::--------::**+***:::---*+%%%%%%@@%+*::#*@%******.*****\n*:-************---*::::-----------::--:---::::+++++**:::::%*%********-:***\n**:.************++*:::::--------::**+------::::::::::::::*++**********--**\n****.**************::::::-----::**==:-------+*:::::---:::**************:-*\n*****.***********.*::::::::-:::***:*+@**::**=+*::::::::::****************-\n******.*:*%@######+::::::::::::::::::++++=******::::::::******************\n******:############*::::::::****::::::*+*:*:*:***::::::*******************\n******#############***::*:*:*+==@@##=======:*+***:::*:********************\n******#############:*+**********:*++**+**++=%=***:*::*********************\n.....##############::*++**************+***:*********###+******************\n***:##############@*:**+=***:::**++===++***********#####%.................\n*:*###############******++=+*:::::::*:::::*::***#########=****************\n**:################%*****++==++********::::*+++=##########+***************\n*:%##################******++++==+=++++++++++++@############**************\n######################@******+++++++++++++++++=%#############*************\n########################+++++++++++++++++++++==@#############@***********.\n#########################%+++++++++++++++++===%###############%********:-*\n########################@=#=++++++++++++====%@##################******-**/\n\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define fs first\n#define sc second\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define mp make_pair\n#define len(v) ((int)v.size())\n#define vc vector\n#define pr pair\n#define endd \"\\n\"; return 0;\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\n\nconst int MAXN = 1e5;\nconst int INF = 1e18;\nconst int MOD = 1e9 + 7;\n\n\nmap<int, vector<int>> g[MAXN];\nmap<int, int> color;\n\nclass TaskE {\npublic:\n    void solve(std::istream &in, std::ostream &out) {\n        int n, h;\n        in >> n >> h;\n        pr<pr<int, int>, pr<int, int>> a1[n];\n        map<pr<int, int>, int> gf;\n        map<int, int> nach;\n        map<int, int> nach1;\n        int kol = 0;\n        for (int i = 0; i < n; i++) {\n            in >> a1[i].fs.fs >> a1[i].fs.sc >> a1[i].sc.fs >> a1[i].sc.sc;\n            pr<int, int> a;\n            if (a1[i].fs.sc == 0) {\n                a.fs = a1[i].fs.fs;\n                kol++;\n            } else {\n                a.fs = -a1[i].fs.sc;\n            }\n            if (a1[i].sc.sc == 0) {\n                a.sc = -a1[i].sc.fs;\n                kol++;\n            } else {\n                a.sc = a1[i].sc.sc;\n            }\n            nach[a.fs]++;\n            nach1[a.sc]++;\n        }\n        if (kol < 2) {\n            out << \"NO\";\n            return;\n        }\n        for (auto v : nach) {\n            if (v.fs > 0) {\n                if (v.sc > nach1[v.fs]) {\n                    out << \"NO\";\n                    return;\n                }\n            } else {\n                if (v.sc < nach1[v.fs]) {\n                    out << \"NO\";\n                    return;\n                }\n            }\n        }\n        out << \"YES\";\n    }\n};\n\n\nmain() {\n    TaskE solver;\n    std::istream &in(std::cin);\n    std::ostream &out(std::cout);\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=410;\nint n,h,in[N],out[N];\nint fa[N];\nbool ok[N];\n\nint find(const int &x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\nint main()\n{\n    n=read();h=read();\n    for(int i=1;i<=(h<<1);i++) fa[i]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int A=read(),B=read(),C=read(),D=read();\n        int x=C?C+h:A,y=D?D:B+h;\n        out[x]++;in[y]++;\n        x=find(x);y=find(y);\n        if(x!=y) fa[x]=y;\n    }\n    for(int i=1;i<=h;i++) if(in[i]>out[i]) return !puts(\"NO\");\n    for(int i=h+1;i<=(h<<1);i++) if(in[i]<out[i]) return !puts(\"NO\");\n    for(int i=1;i<=(h<<1);i++) if(in[i]!=out[i]||!in[i]&&!out[i]) ok[find(i)]=1;\n    for(int i=1;i<=(h<<1);i++) if(fa[i]==i&&!ok[i]) return !puts(\"NO\");\n    return !puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,h;\n  cin>>n>>h;\n  vector<Int> a(n),b(n),c(n),d(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i]>>c[i]>>d[i];\n  \n  auto idx=\n    [&](Int k,Int s){\n      if(s==0){\n\tif(c[k]==0) return 300+a[k];\n\treturn c[k];\n      }else{\n\tif(d[k]==0) return b[k];\n\treturn 300+d[k];\n      }\n    };\n\n  vector<vector<queue<Int> > > cnt(2,vector<queue<Int> >(600));\n  for(Int i=0;i<n;i++){\n    cnt[0][idx(i,0)].emplace(i);\n    cnt[1][idx(i,1)].emplace(i);\n  }\n  \n  auto NO=[](){cout<<\"NO\"<<endl;exit(0);};\n\n  vector<Int> used(n),ok(600,0);\n  vector<vector<Int> > lp;\n  for(Int i=0;i<n;i++){\n    if(used[i]) continue;\n    used[i]=1;\n    Int l=idx(i,0),r=idx(i,1);\n    vector<Int> v;        \n    while(1){\n      v.emplace_back(l);\n      v.emplace_back(r);\n      Int flg=0;\n      while(!cnt[1][l].empty()){\n\tInt k=cnt[1][l].front();cnt[1][l].pop();\n\tif(used[k]) continue;\n\tused[k]=1;\n\tassert(idx(k,1)==l);\n\tl=idx(k,0);\n\tflg=1;\n\tbreak;\n      }\n      if(flg) continue;\n      while(!cnt[0][r].empty()){\n\tInt k=cnt[0][r].front();cnt[0][r].pop();\n\tif(used[k]) continue;\n\tused[k]=1;\n\tassert(idx(k,0)==r);\n\tr=idx(k,1);\n\tflg=1;\n\tbreak;\n      }\n      if(!flg) break;\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());    \n    if(l==r){\n      lp.emplace_back(v);\n      continue;\n    }\n    if(l<300||r>=300) NO();\n    for(Int x:v) ok[x]=1;\n  }\n  for(auto v:lp){\n    Int flg=0;\n    for(Int x:v) flg|=ok[x];\n    if(!flg) NO();\n  }\n  cout<<\"YES\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\nusing namespace std;\nconst int maxN = 407;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\ninline void NIE() {puts(\"NO\"); exit(0);}\ninline void TAK() {puts(\"YES\"); exit(0);}\n\nint n, H;\nint in[maxN], out[maxN];\nbool occ[maxN];\n\nint pt(int kd, int x) {return kd * H + x;}\n\nnamespace dsu {\n\tint fa[maxN], hav[maxN];\n\n\tvoid init(int n) {\n\t\trep (i, 1, n) fa[i] = i, hav[i] = 0;\n\t}\n\n\tinline int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}\n\n\tvoid merge(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x != y) fa[x] = y;\n\t}\n\n\tinline int& ok(int x) {return hav[find(x)];}\n}\n\nint main() {\n\tn = ri(); H = ri();\n\tdsu::init(2 * H);\n\trep (i, 1, n) {\n\t\tint a = ri(), b = ri(), c = ri(), d = ri();\n\t\tint lf = (c == 0) ? pt(0, a) : pt(1, c);\n\t\tint rt = (d == 0) ? pt(1, b) : pt(0, d);\n\t\tocc[lf] = occ[rt] = 1;\n\t\t++out[lf], ++in[rt];\n\t\tdsu::merge(lf, rt);\n\t}\n\n\trep (i, 1, H) {\n\t\tint x = pt(0, i);\n\t\tif (occ[x] && in[x] > out[x]) NIE();\n\t\tif (occ[x] && in[x] < out[x]) dsu::ok(x) = 1;\n\t\tx = pt(1, i);\n\t\tif (occ[x] && in[x] < out[x]) NIE();\n\t}\n\n\trep (i, 1, H) {\n\t\tint x = pt(0, i);\n\t\tif (occ[x] && !dsu::ok(x)) NIE();\n\t\tx = pt(1, i);\n\t\tif (occ[x] && !dsu::ok(x)) NIE();\n\t}\n\n\tTAK();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    int n,h;\n    cin >> n >> h;\n    vector<int> p(h+1),q(h+1);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;    \n        if(c==0){\n            p[a]++;\n        }else{\n            q[c]++;\n        }\n        if(d==0){\n            q[b]--;\n        }else{\n            p[d]--;\n        }\n    }\n    int c = 0;\n    int d = 0;\n    rep(i,h+1){\n        if(p[i]<0){\n            cout << \"NO\" << endl;\n            return 0;\n        }else{\n            c += p[i];\n        }\n        if(q[i]>0){\n            cout << \"NO\" << endl;\n            return 0;\n        }else{\n            d -=q[i];\n        }\n    }\n    if((c>0)){\n        cout << \"YES\" << endl;\n    }else{\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define neko 100010\n#define heko 410\n#define qwq return printf(\"YES\"),0; \n#define orz return printf(\"NO\"),0; \n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))\nstatic int n,H;\ntypedef int arr[heko];\narr fa,book,dgi,dgo,out;\nnamespace IO\n{\n\tconst unsigned int bufsize=1<<16,outsize=1<<24;\n\tstatic char ch[bufsize],*S=ch,*T=ch;\n\tinline char getc()\n\t{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\n\tstatic char Out[outsize],*nowp=Out;\n\tinline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\n\t\tvoid read(T &x)\n\t\t{\n\t\t\tchar c=getc();x=0;\n\t\t\tfor(;!isdigit(c);c=getc());\n\t\t\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n\t\t}\n\ttemplate<typename T>\n\t\tvoid write(T x,char c='\\n')\n\t\t{\n\t\t\tif(!x)*nowp++='0';\n\t\t\tstatic unsigned int stk[50],tp=0;\n\t\t\tfor(;x;x/=10)stk[++tp]=x%10;\n\t\t\tfor(;tp;*nowp++=stk[tp--]^'0');*nowp++=c;\n\t\t}\n}\nint find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}\nint main()\n{\n\tusing namespace IO;\n\tint x,y,z,o,X,Y;\n\tread(n),read(H);\n\tf(i,0,400)fa[i]=i;\n\tf(i,1,n)\n\t{\n\t\tread(x),read(y),read(z),read(o);\n\t\tif(z==0)X=200+x;\n\t\telse X=200-z;\n\t\tif(o==0)Y=200-y;\n\t\telse Y=200+o;\n\t\tbook[X]=book[Y]=1;\n\t\t++dgi[Y],++dgo[X];\n\t\tfa[find(Y)]=find(X);\n\n\t}\n\tf(i,0,200)if(dgi[i]<dgo[i])orz;\n\tf(i,201,400)if(dgi[i]>dgo[i])orz;\n\tf(i,0,400)if(dgi[i]^dgo[i])out[find(i)]=1;\n\tf(i,0,400)if(book[i]&&!out[fa[i]])orz;\n\tqwq;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define per(i,n) for ((i)=n;(i)>=(1);(i)--)\nusing namespace std;\nint n,m,i,j,fa[200005],vis[200005];\nint rd[200005],cd[200005];\nint fnd(int x)\n{\n\tif(fa[x]==x) return x;\n\treturn fa[x]=fnd(fa[x]); \n}\nint main()\n{\n\tcin>>n>>m;m++;\n\trep(i,m+m)fa[i]=i;\n\trep(i,n)\n\t{\n\t\tint a,b,c,d,l,r;\n\t\tcin>>a>>b>>c>>d;\n\t\tif(c) l=m+c; else l=m-a;\n\t\tif(d) r=m-d; else r=m+b;\n\t\trd[r]++;cd[l]++;\n\t\tfa[fnd(l)]=fnd(r);\n\t}\n\trep(i,m) if(rd[i]>cd[i]) {puts(\"NO\");return 0;}\n\trep(i,m) if(rd[i+m]<cd[i+m]) {puts(\"NO\");return 0;}\n\trep(i,m+m) if(rd[i]!=cd[i]) vis[fnd(i)]=1;\n\trep(i,m+m) if(cd[i]&&!vis[fnd(i)]) {puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int MAXN=100005,MAXH=405;\n\nint N,H;\nint in[MAXH],out[MAXH];\nint cntS[MAXH],cntT[MAXH];\nbool vis[MAXH];\n\nint fa[MAXH];\nint Root(int x)\n{return fa[x]==0?x:(fa[x]=Root(fa[x]));}\nvoid Union(int x,int y)\n{\n\tint r1=Root(x),r2=Root(y);\n\tif(r1==r2)\n\t\treturn;\n\tfa[r1]=r2;\n}\n\nint ID(int h,int d)\n{return h*2-1+d;}\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint u,v;\n\t\tif(c==0)\n\t\t\tu=ID(a,0);\n\t\telse\n\t\t\tu=ID(c,1);\n\t\tif(d==0)\n\t\t\tv=ID(b,1);\n\t\telse\n\t\t\tv=ID(d,0);\n\t\tout[u]++;\n\t\tin[v]++;\n\t\tvis[u]=vis[v]=true;\n\t\tUnion(u,v);\n\t\t//printf(\"(%d,%d)->(%d,%d)          %d->%d\\n\",(u-1)/2+1,(u&1)^1,(v-1)/2+1,(v&1)^1,u,v);\n\t}\n\t\n\tfor(int i=1;i<=2*H;i++)\n\t{\n\t\tif(in[i]-out[i]>=1)\n\t\t{\n\t\t\tif(i&1)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcntT[Root(i)]+=in[i]-out[i];\n\t\t}\n\t\tif(out[i]-in[i]>=1)\n\t\t{\n\t\t\tif((i&1)^1)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcntS[Root(i)]+=out[i]-in[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=2*H;i++)\n\t\tif(vis[i]&&fa[i]==0&&(cntS[i]!=cntT[i]||(cntS[i]==0&&cntT[i]==0)))\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"YES\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker,\"/STACK:1000000000\")\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<b;++i)\n#define fj(a,b) for(int j=a;j<b;++j)\n#define fo(a,b) for(int o=a;o<b;++o)\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> pii;\n////////////////////\n\nint const N = 1e5 + 41;\nint const H = 241;\n\nint n, h, a[N], b[N], c[N], d[N];\nint d0[H][2], d1[H][2];\n\nvector<pii> e[H][2];\nvector<pii> st;\n\npii getfrom(int a, int c){\n\tif(c > 0) return mp(c, 0);\n\telse return mp(a, 1);\n}\n\npii getto(int b, int d){\n\tif(d > 0) return mp(d, 1);\n\telse return mp(b, 0);\n}\n\nbool dfs(pii x){\n\tst.pb(x);\n\tbool res;\n\tif(sz(e[x.first][x.second])){\n\t\tpii y = e[x.first][x.second].back();\n\t\te[x.first][x.second].pop_back();\n\t\t--d0[x.first][x.second];\n\t\t--d1[y.first][y.second];\n\t\tres = dfs(y);\n\t}else{\n\t\tif(x.second == 0){\n\t\t\tres = (x.second == 0 ? 1 : 0);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid dfs1(pii x){\n\tst.pb(x);\n\twhile(sz(e[x.first][x.second])){\n\t\tpii y = e[x.first][x.second].back();\n\t\t--d0[x.first][x.second];\n\t\t--d1[y.first][y.second];\n\t\te[x.first][x.second].pop_back();\n\t\tdfs1(y);\n\t}\n}\n\nvoid solve(){\n\tfi(0, n){\n\t\tpii x = getfrom(a[i], c[i]);\n\t\tpii y = getto(b[i], d[i]);\n\t\te[x.first][x.second].pb(y);\n\t\t++d0[x.first][x.second];\n\t\t++d1[y.first][y.second];\n\t}\n\tbool ok = true;\n\tfi(1, h+1){\n\t\tint k = d0[i][1] - d1[i][1];\n\t\tif(k < 0) ok = false;\n\t\tfj(0, k){\n\t\t\tok &= dfs(mp(i, 1));\n\t\t}\n\t}\n\tset<pii> t;\n\twhile(sz(st)){\n\t\tt.insert(st.back());\n\t\tst.pop_back();\n\t}\n\tfi(1, h+1) fj(0, 2){\n\t\tok &= (d0[i][j] == d1[i][j]);\n\t}\n\tfi(1, h+1) fj(0, 2){\n\t\tif(d0[i][j] == 0) continue;\n\t\tst.clear();\n\t\tdfs1(mp(1, j));\n\t\tbool f = false;\n\t\tfo(0, sz(st)){\n\t\t\tif(t.find(st[o]) != t.end()) f = true;\n\t\t}\n\t\tok &= f;\n\t}\n\t\n\tif(ok) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\t\n\tscanf(\"%d %d\",&n,&h);\n\tfi(0, n) scanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 10005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n        if(c == '-') f = -1;\n        c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n        res = res * 10 + c - '0';\n        c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n        out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint g[405][405],f[405][405],ind[405],H,col[405],all;\nint N,A[100005],B[100005],C[100005],D[100005];\nbool vis[405];\nvoid dfs(int u) {\n    all += ind[u];\n    vis[u] = 1;\n    for(int i = 1 ; i <= 2 * H ; ++i) {\n        if(f[u][i] && !vis[i]) dfs(i);\n    }\n}\nvoid Solve() {\n    read(N);read(H);\n    for(int i = 1 ; i <= N ; ++i) {\n        read(A[i]);read(B[i]);read(C[i]);read(D[i]);\n        int s,t;\n        if(C[i]) s = C[i];\n        else s = A[i] + H;\n        if(D[i]) t = D[i] + H;\n        else t = B[i];\n        g[s][t]++;ind[t]++;ind[s]--;\n        f[s][t]++;f[t][s]++;\n    }\n    for(int i = 1 ; i <= H ; ++i) {\n        if(ind[i] < 0) {puts(\"NO\");return;}\n    }\n    for(int i = H + 1 ; i <= 2 * H ; ++i) {\n        if(ind[i] > 0) {puts(\"NO\");return;}\n    }\n    for(int i = 1 ; i <= 2 * H ; ++i) {\n        if(!vis[i]) {\n            dfs(i);\n            if(all != 0) {puts(\"NO\");return;}\n        }\n    }\n    puts(\"YES\");\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#define eps 1e-10\n#define inf 1e9\n#define For(i,j,k)\tfor(int i=j;i<=k;++i)\n#define Dow(i,j,k)\tfor(int i=k;i>=j;--i)\n#define ll long long\n#define y1 orz\nusing namespace std;\ninline ll read()\n{\n\tll t=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9')\t{if(c=='-')\tf=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')\tt=t*10+c-48,c=getchar();\n\treturn t*f;\n}\nint n,h,F[1001],deg[1001],hav[1001],is_father[1001];\ninline int get(int x){return x==F[x]?F[x]:F[x]=get(F[x]);}\nint x,y,x1,y1,tx,ty;\nint main()\n{\n\tn=read();h=read();\n\tFor(i,1,1000)\tF[i]=i;\n\tFor(i,1,n)\t\n\t{\n\t\tx=read();y=read();x1=read();y1=read();\n\t\tif(x1==0)\ttx=x;else tx=-x1;\n\t\tif(y1==0)\tty=-y;else ty=y1;\n\t\ttx+=500;ty+=500;\n\t\tdeg[tx]++;deg[ty]--;hav[tx]=1;\n//\t\tcout<<tx<<' '<<ty<<endl;\n\t\tF[get(tx)]=get(ty);\n\t}\n\tFor(i,501,1000)\tif(deg[i]<0)\t{puts(\"NO\");return 0;}\t\t\n\tFor(i,1,500)\tif(deg[i]>0)\t{puts(\"NO\");return 0;}\n\tFor(i,1,1000)\t\n\t\thav[get(i)]|=hav[i];\n\tFor(i,1,1000)\n\t\tif(deg[i])is_father[get(i)]=1;\n\tFor(i,1,1000)\t\n\t\tif(hav[i])\n\t\t\tif(F[i]==i&&!is_father[i])\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL \t\t\t\t\tlong long\n#define ULL \t\t\t\tunsigned long long\n#define pii \t\t\t\tpair<int,int>\n#define fi \t\t\t\t\tfirst\n#define se \t\t\t\t\tsecond\n#define vi \t\t\t\t\tvector<int>\n#define psb \t\t\t\tpush_back\n#define ppb \t\t\t\tpop_back\n#define all(x)\t\t\t \t(x).begin(),(x).end()\n#define sz(x)\t\t\t\t(int)(x).size()\n#define endln \t\t\t\tprintf(\"\\n\")\n#define gc\t\t\t\t\tgetchar_unlocked\n#define setmin(x)\t\t\tmemset((x), -1, sizeof((x)))\n#define setnul(x)\t\t\tmemset((x), 0, sizeof((x)))\n#ifndef getchar_unlocked\n#define getchar_unlocked \tgetchar\n#endif\nconst int inf = 1e9 + 5;\nconst int mod = 1e9 + 7;\n\ntemplate <typename T>\nvoid gi(T &ret) {\n\tret = 0; char inp=gc(); int kl=1;\n\twhile (inp<'0' || inp>'9') {if (inp=='-') kl=-1; inp=gc();}\n\twhile ('0'<=inp && inp<='9') ret=(ret<<3)+(ret<<1)+(inp-'0'), inp=gc();\n\tif (kl<1) ret=-ret;\n}\n\nconst int MAXH = 205;\nint n, h, lst[MAXH+MAXH], lop[MAXH+MAXH], st[MAXH], use = 0;\nvi adj[MAXH+MAXH];\n\nbool solve() {\n\tsetnul(st);\n\tfor (int i=1; i<=h; i++) {\n\t\twhile (lst[i]<lop[i]) {\n\t\t\tint now = i;\n\t\t\twhile (1) {\n\t\t\t\tif (lst[now]>=lop[now]) break;\n\t\t\t\tuse++;\n\t\t\t\tnow = adj[now][lst[now]++];\n\t\t\t}\n\t\t//\tprintf (\"start %d end %d\\n\", i, now);\n\t\t\tif (now<=h) {\n\t\t\t\tif (st[now]) st[now]--;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t\tst[i]++;\n\t\t}\n\t}\n\tif (use==n) return 1;\n\treturn 0;\n}\n\nint main() {\n\tgi(n); gi(h);\n\tfor (int i=0; i<n; i++) {\n\t\tint a, b, c, d, l, r;\n\t\tgi(a); gi(b); gi(c); gi(d);\n\t\tif (c==0) l = a;\n\t\telse l = h+c;\n\t\tif (d==0) r = h+b;\n\t\telse r = d;\n//\t\tprintf (\"%d -> %d\\n\", l, r);\n\t\tadj[l].psb(r);\n\t\t\n\t}\n\tfor (int i=1; i<=(h+h); i++) {\n\t\tlst[i] = 0;\n\t\tlop[i] = sz(adj[i]);\n\t}\n\tif (solve()) puts(\"YES\");\n\telse puts(\"NO\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 505\nusing namespace std;\nint n,m,a[N],b[N],c[N],d[N],deg[M],Max;\nvoid GG(){ printf(\"NO\"); exit(0);}\nint main()\n{\n\tint i,x,y;\n\tscanf(\"%d %d\",&n,&m),m=2*m+1;\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tif(c[i]!=0) x=2*c[i]+1; else x=2*a[i];\n\t\tif(d[i]!=0) y=2*d[i]; else y=2*b[i]+1;\n\t\tdeg[x]++,deg[y]--;\n\t  }\n\tfor(i=1;i<=m;i++)\n\t\tif(deg[i]!=0)\n\t\t\tMax=max(Max,abs(deg[i]));\n\tif(Max==1) printf(\"YES\");\n\telse printf(\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> graph[444];\nint last[401];\nint deg[401][401];\nint deg2[401][401];\n\nint lbottom(int t)\n{\n    return t;\n}\n\nint lup(int t)\n{\n    return 200 + t;\n}\n\nint rbottom(int t)\n{\n    return 400 + t;\n}\n\nint rup(int t)\n{\n    return 600 + t;\n}\n\nint next_blk(int t)\n{\n    if (t > 400 && t <= 600) return lup(t - 400);\n    else return lbottom(t - 600);\n}\n\nvector<int> path;\n\nvoid dfs(int t)\n{\n    for (int &i = last[t]; i < graph[t].size();)\n    {\n        int nxt = graph[t][i++];\n        dfs(nxt);\n    }\n    path.push_back(t);\n}\n\nint main()\n{\n    int n, h;\n    scanf(\"%d%d\",&n,&h);\n    for (int i = 0; i < n; i++)\n    {\n        int a, b, c, d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\n        int lidx, ridx;\n\n        if (c == 0) lidx = lbottom(a);\n        else lidx = lup(c);\n\n        if (d == 0) ridx = rbottom(b);\n        else ridx = rup(d);\n\n        graph[lidx].push_back(next_blk(ridx));\n        deg2[lidx][next_blk(ridx)]++;\n    }\n\n\n    for (int i = 1; i <= 400; i++) sort(graph[i].begin(), graph[i].end());\n\n    for (int i = 1; i <= 200; i++)\n    {\n        if (graph[i].empty()) continue;\n\n        memset(last, 0, sizeof(last));\n        memset(deg, 0, sizeof(deg));\n        path.clear();\n        dfs(i);\n        reverse(path.begin(), path.end());\n        if (path.back() <= 200) continue;\n\n        for (int j = 1; j < path.size(); j++)\n        {\n            deg[path[j - 1]][path[j]]++;\n        }\n\n        if (memcmp(deg, deg2, sizeof(deg))) continue;\n        printf(\"YES\\n\");\n        return 0;\n    }\n\n    printf(\"NO\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nconst int maxnode=2000000+16;\n\nvector<int> g[maxnode];\nbool v[maxnode];\nint d[maxnode];\nint q[maxnode];\n\nvoid bfs(int p)\n{\n\tif (v[p]) return;\n\tv[p]=true;\n\tint sizeq=0;\n\tq[sizeq++]=p;\n\tREP(cl,sizeq)\n\t{\n\t\tint x=q[cl];\n\t\tfor (int y:g[x]) if (!v[y]) v[y]=true,q[sizeq++]=y;\n\t}\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint n,h;\n\twhile (cin>>n>>h)\n\t{\n\t\th+=2;\n\t\tvector<ipair> edges;\n\t\tREP(i,n)\n\t\t{\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tint s=((c==0)?(a+h):c);\n\t\t\tint t=((d==0)?b:(d+h));\n\t\t\tedges.emplace_back(s,t);\n\t\t}\n\t\tbool ok=true;\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.first].push_back(e.second);\n\t\tFOR(i,h,h+h) bfs(i);\n\t\tfor (auto e:edges) if (!v[e.first]) ok=false;\n\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.second].push_back(e.first);\n\t\tREP(i,h) bfs(i);\n\t\tfor (auto e:edges) if (!v[e.second]) ok=false;\n\n\t\tREP(i,h+h) d[i]=0;\n\t\tfor (auto e:edges) ++d[e.first],--d[e.second];\n\t\tREP(i,h) if (d[i]>0) ok=false;\n\t\tFOR(i,h,h+h) if (d[i]<0) ok=false;\n\n\t\tif (ok)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\tfflush(stdout);\n#ifndef _MSC_VER\n\t\tbreak;\n#endif\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(auto &it : (v))\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define sz(x) (int)(x).size()\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nvector<int> inadj[2000];\nvector<int> outadj[2000];\nint OFFSET = 1000;\nbool vis[2000];\n\nvoid dfs(int node){\n\tif(vis[node])\n\t\treturn;\n\tvis[node]=1;\n\tfor(auto i : outadj[node])\n\t\tdfs(i);\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tint N, H;\n\tcin >> N >> H;\n\trep(i,0,N){\n\t\tint A, B, C, D;\n\t\tcin >> A >> B >> C >> D;\n\t\tint from, to;\n\t\tif(C){\n\t\t\tfrom = C;\n\t\t}\n\t\telse{\n\t\t\tfrom = OFFSET+A;\n\t\t}\n\t\tif(D){\n\t\t\tto = OFFSET+D;\n\t\t}\n\t\telse{\n\t\t\tto = B;\n\t\t}\n\t\toutadj[from].push_back(to);\n\t\tinadj[to].push_back(from);\n\t}\n\trep(i,0,1000){\n\t\tif(outadj[i].size() > inadj[i].size()){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(outadj[OFFSET+i].size() < inadj[OFFSET+i].size()){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*vector<int> add1;\n\tvector<int> add2;\n\trep(i,OFFSET,OFFSET*2){\n\t\tif(sz(outadj[i]) < sz(inadj[i])){\n\t\t\trep(j,0,sz(inadj[i])-sz(outadj[i]))\n\t\t\t\tadd1.push_back(i);\n\t\t}\n\t}\n\trep(i,0,OFFSET){\n\t\tif(sz(outadj[i]) > sz(inadj[i])){\n\t\t\trep(j,0,sz(outadj[i])-sz(inadj[i]))\n\t\t\t\tadd2.push_back(i);\n\t\t}\n\t}\n\tif(sz(add1) != sz(add2)){\n\t}*/\n\t/*int starts = 0, stops = 0;\n\tint start = 0;\n\trep(i,0,2000){\n\t\tint x = (int)inadj[i].size();\n\t\tint y = (int)outadj[i].size();\n\t\tif(x == y)\n\t\t\tcontinue;\n\t\tif(abs(x-y) > 1){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(x == y+1){\n\t\t\tif(i >= OFFSET){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t++stops;\n\t\t}\n\t\telse{\n\t\t\tif(i < OFFSET){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstart = i;\n\t\t\t++starts;\n\t\t}\n\t}\n\tif(starts > 0){\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\tdfs(start);*/\n\trep(i,OFFSET,2000){\n\t\tif(sz(inadj[i]) < sz(outadj[i])){\n\t\t\tdfs(i);\n\t\t}\n\t}\n\trep(i,0,2000){\n\t\tif(vis[i])\n\t\t\tcontinue;\n\t\tif(inadj[i].empty())\n\t\t\tcontinue;\n\t\tif(outadj[i].empty())\n\t\t\tcontinue;\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\tcout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\nusing namespace std;\ninline int read(){\n\tint s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=0;c=getchar();}\n\twhile(c>='0'&&c<='9')s=(s<<1)+(s<<3)+c-48,c=getchar();\n\treturn f?s:-s;\n}\nint n,h,ind[410],outd[410];\nint fa[410],vis[410];\nint get_fa(int x){\n\treturn fa[x]==x?x:fa[x]=get_fa(fa[x]);\n}\nint main(){\n//\tfreopen(\"jigsaw.in\",\"r\",stdin);\n//\tfreopen(\"jigsaw.out\",\"w\",stdout);\n\tn=read(); h=read();\n\tfor(rint i=1;i<=h+h;++i) fa[i]=i;\n\tfor(rint i=1;i<=n;++i){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint x=c>0?c:-a,y=d>0?-d:b;\n\t\tx+=h; y+=h;\n\t\tif(get_fa(x)!=get_fa(y)) fa[get_fa(x)]=get_fa(y);\n\t\t++ind[y]; ++outd[x];\n\t}\n\tfor(rint i=-h;i<0;++i)\n\t\tif(ind[i+h]>outd[i+h]){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\tfor(rint i=1;i<=h;++i)\n\t\tif(ind[i+h]<outd[i+h]){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\tfor(rint i=0;i<=h+h;++i)\n\t\tif(ind[i]!=outd[i]) vis[get_fa(i)]=true;\n    for(rint i=0;i<=h+h;++i) \n\t\tif(ind[i]&&outd[i]&&!vis[get_fa(i)]){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint beg[200100],nex[501000],tto[500100],e;\nint cnt1[200100],cnt2[200100];\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nbool vis[200100];\nvoid dfs(int u){\n\tif(vis[u]) return;\n\tvis[u]=1;\n\tfor(int i=beg[u];i;i=nex[i])\n\t\tdfs(tto[i]);\n}\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n\tint n,h;\n\tscanf(\"%d%d\",&n,&h);\n\tint A,B,C,D;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tif(C>0){\n\t\t\tputin(n+C,i);\n\t\t\tputin(i,n+C);\n\t\t\tcnt1[n+C]++;\n\t\t}\n\t\telse{\n\t\t\tputin(n+h+A,i);\n\t\t\tputin(i,n+h+A);\n\t\t\tcnt2[n+A+h]++;\n\t\t}\n\t\tif(D>0){\n\t\t\tputin(n+D+h,i);\n\t\t\tputin(i,n+D+h);\n\t\t\tcnt1[n+D+h]++;\n\t\t}\n\t\telse{\n\t\t\tputin(n+B,i);\n\t\t\tputin(i,n+B);\n\t\t\tcnt2[n+B]++;\n\t\t}\n\t}\n\tfor(int i=1;i<=h+h;i++){\n\t\tif(cnt1[n+i]>cnt2[n+i]){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<=h+h;i++)\n\t\tif(cnt2[n+i]>cnt1[n+i])\n\t\t\tdfs(n+i);\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<20;\nint fa[Q];\nint in[Q],out[Q];\nint gf(int x)\n{return fa[x]==x?x:(fa[x]=gf(fa[x]));}\nvoid ins(int x,int y)\n{\n    out[x]++;\n    in[y]++;\n    int fx=gf(x),fy=gf(y);\n    if(fx!=fy)fa[fx]=fy;\n}\n// int Idiot_Sap(int x,int flow)\n// {\n//     if(x==T)return flow;\n//     int had=0;\n//     for(int t=las[x];t;t=nn[t]){\n//         int y=e[t];\n//         if((!c[t])||dis[x]-1!=dis[y])continue;\n//         int del=Idiot_Sap(y,min(c[t],flow-had));\n//         c[t]-=del;\n//         c[t^1]+=del;\n//         had+=del;\n//         if(dis[S]>=T||had==flow)return had;\n//     }\n//     if(dis[S]>=T)return had;\n//     --cnt[dis[x]];\n//     if(!cnt[dis[x]])dis[S]=T;\n//     cnt[++dis[x]]++;\n//     return had;\n// }\nint had[Q];\nint main()\n{\n    int n,h;\n    cin>>n>>h;\n    h+=5;\n    for(int i=1,a,b,c,d;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        int x,y;\n        if(c==0)x=a+h;\n        else x=c;\n        if(d==0)y=b;\n        else y=d+h;\n        // printf(\"%d %d LINK\\n\",x,y);\n        ins(x,y);\n    }\n    for(int i=1;i<=h;i++)if(out[i]>in[i])return puts(\"NO\")&0;\n    for(int i=h+1;i<=h+h;i++)if(out[i]<in[i])return puts(\"NO\")&0;\n    for(int i=1;i<=h+h;i++)if(in[i]!=out[i])had[gf(i)]=1;\n    for(int i=1;i<=h+h;i++)if(in[i]&&out[i]&&(!had[gf(i)]))return puts(\"NO\")&0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\n#define A(a) ((a)<<1)\n#define B(a) ((a)<<1|1)\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nconst int MAXV = 200007;\nconst int MAXM = 2000007;\n\nstruct eT\n{\n\tvoid setd ( int _u, int _v, int _f, int _l )\n\t{\n\t\tu = _u, v = _v, f = _f, last = _l;\n\t}\n\n\tint u, v, f, last;\n}edge[MAXM];\n\nstruct bT\n{\n\tbT () {}\n\tbT ( int _h, int _l ) : h ( _h ), l ( _l ) {}\n\n\tvoid setd ( int _h, int _l )\n\t{\n\t\th = _h, l = _l;\n\t}\n\n\tbool operator < ( const bT &a ) const\n\t{\n\t\treturn ( h ^ a.h ) ? ( h < a.h ) : ( l < a.l );\n\t}\n\n\tbool operator == ( const bT &a ) const\n\t{\n\t\treturn ( h == a.h && l == a.l );\n\t}\n\n\tint h, l;\n}bl[MAXN], br[MAXN];\n\nint n, h, S, T;\nint ke, la[MAXV];\n\nint q[MAXV], lev[MAXV];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nvoid addedge ( int u, int v, int fu, int fv );\n\nint dinic ();\nbool bfs ();\nint dfs ( int now, int lim );\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\n\tscanf ( \"%d%d\", &n, &h );\n\tint a, b, c, d;\n\tlpi ( i, 1, n ){\n\t\tscanf ( \"%d%d%d%d\", &a, &b, &c, &d );\n\t\tbl[i].setd ( c, a ), br[i].setd ( d, b );\n\t}\n}\n\nvoid work ()\n{\n\t// main work\n\n\tbool flag;\n\tlpi ( i, 1, n ){\n\t\tflag = true;\n\t\tif ( !bl[i].h && br[i].h ){\n\t\t\tflag = false;\n\t\t\tlpi ( j, 1, n ){\n\t\t\t\tif ( !bl[j].h && bl[j].l == br[i].h && ( ! ( ( bl[i] == bl[j] ) || ( br[i] == br[j] ) ) ) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( bl[i].h && !br[i].h ){\n\t\t\tflag = false;\n\t\t\tlpi ( j, 1, n ){\n\t\t\t\tif ( !br[j].h && br[j].l == bl[i].h && ( !( ( bl[i] == bl[j] ) || ( br[i] == br[j] ) ) ) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( !flag ){\n\t\t\tprintf ( \"NO\\n\" );\n\t\t\treturn;\n\t\t}\n\t}\n\n\tS = MAXV - 1, T = MAXV - 2;\n\tint SS = MAXV - 3, TT = MAXV - 4;\n\tke = 0;\n\tINIT ( la, -1 );\n\n\tmap < bT, PII > ml, mr;\n\tmap < bT, PII > ::iterator it;\n\n\tAR( int ) keye;\n\tint ks = 0;\n\n\tlpi ( i, 1, n ){\n\t\t++ml[bl[i]].first;\n\t\t++mr[br[i]].first;\n\t}\n\n\tint kl = 0, kr = 0;\n\tfor ( auto &x : ml ) x.second.second = ++kl;\n\tfor ( auto &x : mr ) x.second.second = ++kr;\n\n//\tint cl = 0, cr = 0;\n\tfor ( auto x : ml ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, A( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( A( x.second.second ), TT, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = mr.find ( bT ( 0, x.first.h ) ) ) != mr.end () ){\n\t\t\t\taddedge ( B( it->second.second ), A( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n//\t\t\tcl += x.second.first;\n\t\t\taddedge ( A( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n\tfor ( auto x : mr ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, B( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( B( x.second.second ), SS, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = ml.find ( bT ( 0, x.first.h ) ) ) != ml.end () ){\n\t\t\t\taddedge ( A ( it->second.second ), B( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n//\t\t\tcr += x.second.first;\n\t\t\taddedge ( B( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n//\taddedge ( SS, T, INF, 0 );\n//\taddedge ( TT, T, INF, 0 );\n\n/*\tif ( cl ^ cr ){\n\t\tprintf ( \"NO\\n\" );\n\t\treturn;\n\t}*/\n\n\tif ( ks >= n ){\n\t\tprintf ( \"NO\\n\" );\n\t\treturn;\n\t}\n\n\tdinic ();\n\n\tflag = true;\n\tfor ( auto x : keye ){\n\t\tif ( edge[x].f ){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf ( flag ? \"YES\\n\" : \"NO\\n\" );\n}\n\n\n\nvoid addedge ( int u, int v, int fu, int fv )\n{\n\tedge[ke].setd ( u, v, fu, la[u] );\n\tla[u] = ke++;\n\tedge[ke].setd ( v, u, fv, la[v] );\n\tla[v] = ke++;\n}\n\nint dinic ()\n{\n\tint ans = 0;\n\twhile ( bfs () ) ans += dfs ( S, INF );\n\treturn ans;\n}\n\nbool bfs ()\n{\n\tint l = 0, r = 0, now, v;\n\tq[r++] = S;\n\tINIT ( lev, -1 );\n\tlev[S] = 1;\n\twhile ( l < r ){\n\t\tnow = q[l++];\n\t\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\t\tif ( edge[i].f && lev[v=edge[i].v] == -1 ){\n\t\t\t\tlev[v] = lev[now] + 1;\n\t\t\t\tq[r++] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ( lev[T] != -1 );\n}\n\nint dfs ( int now, int lim )\n{\n\tif ( now == T ) return lim;\n\n\tint v, nf = 0, tf;\n\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\tif ( edge[i].f && lev[v=edge[i].v] == lev[now] + 1 ){\n\t\t\ttf = dfs ( v, qmin ( lim-nf, edge[i].f ) );\n\t\t\tnf += tf;\n\t\t\tedge[i].f -= tf, edge[i^1].f += tf;\n\n\t\t\tif ( nf == lim ) break;\n\t\t}\n\t}\n\n\tif ( !nf ) lev[now] = -1;\n\treturn nf;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nvector <int> LI[444], LO[444], RI[444], RO[444];\nvector <pii> V;\nbool chk[444];\nmultiset <int> SL, SR;\nint n, h;\n\nvoid dfs(int p, vector <int> *V)\n{\n\tchk[p] = 1;\n\tfor(int t: V[p]){\n\t\tif(!chk[t]) dfs(t, V);\n\t}\n}\n\nvoid die()\n{\n\tprintf(\"NO\\n\");\n\texit(0);\n}\n\nint main()\n{\n\tint i, j, a, b, c, d;\n\t\n\tscanf(\"%d%d\", &n, &h);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\n\t\tif(c == 0 && d == 0){\n\t\t\tLO[0].push_back(a);\n\t\t\tLI[a].push_back(0);\n\t\t\tRO[0].push_back(b);\n\t\t\tRI[b].push_back(0);\n\t\t}\n\t\telse if(c == 0){\n\t\t\tLO[d].push_back(a);\n\t\t\tLI[a].push_back(d);\n\t\t}\n\t\telse if(d == 0){\n\t\t\tRO[c].push_back(b);\n\t\t\tRI[b].push_back(c);\n\t\t}\n\t\telse V.push_back(pii(c, d));\n\t}\n\t\n\tdfs(0, LO);\n\t\n\tfor(i=1;i<h;i++){\n\t\tif((!LO[i].empty() || !LI[i].empty()) && !chk[i]) die();\n\t\tif(LI[i].size() >= LO[i].size()){\n\t\t\tfor(j=0;j<LI[i].size() - LO[i].size();j++) SL.insert(i);\n\t\t}\n\t\telse die();\n\t\tchk[i] = 0;\n\t}\n\t\n\tdfs(0, RO);\n\t\n\tfor(i=1;i<h;i++){\n\t\tif((!RO[i].empty() || !RI[i].empty()) && !chk[i]) die();\n\t\tif(RI[i].size() >= RO[i].size()){\n\t\t\tfor(j=0;j<RI[i].size() - RO[i].size();j++) SR.insert(i);\n\t\t}\n\t\telse die();\n\t\tchk[i] = 0;\n\t}\n\t\n\tfor(pii t: V){\n\t\tauto it = SL.find(t.second);\n\t\tif(it == SL.end()) die();\n\t\tSL.erase(it);\n\t\t\n\t\tit = SR.find(t.first);\n\t\tif(it == SR.end()) die();\n\t\tSR.erase(it);\n\t}\n\t\n\tif(SL.empty() || SR.empty()) die();\n\t\n\tprintf(\"YES\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define neko 100010\n#define heko 410\n#define qwq return printf(\"YES\"),0; \n#define orz return printf(\"NO\"),0; \n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))\nstatic int n,H;\ntypedef int arr[heko];\narr fa,book,dgi,dgo,out;\nnamespace IO\n{\n\tconst unsigned int bufsize=1<<16,outsize=1<<24;\n\tstatic char ch[bufsize],*S=ch,*T=ch;\n\tinline char getc()\n\t{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\n\tstatic char Out[outsize],*nowp=Out;\n\tinline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\n\t\tvoid read(T &x)\n\t\t{\n\t\t\tchar c=getc();x=0;\n\t\t\tfor(;!isdigit(c);c=getc());\n\t\t\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n\t\t}\n\ttemplate<typename T>\n\t\tvoid write(T x,char c='\\n')\n\t\t{\n\t\t\tif(!x)*nowp++='0';\n\t\t\tstatic unsigned int stk[50],tp=0;\n\t\t\tfor(;x;x/=10)stk[++tp]=x%10;\n\t\t\tfor(;tp;*nowp++=stk[tp--]^'0');*nowp++=c;\n\t\t}\n}\nint find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}\nint main()\n{\n\tusing namespace IO;\n\tint x,y,z,o,X,Y;\n\tread(n),read(H);\n\tf(i,0,400)fa[i]=i;\n\tf(i,1,n)\n\t{\n\t\tread(x),read(y),read(z),read(o);\n\t\tif(z==0)X=200+x;\n\t\telse X=200-z;\n\t\tif(o==0)Y=200-y;\n\t\telse Y=200+o;\n\t\tbook[X]=book[Y]=1;\n\t\t++dgi[Y],++dgo[X];\n\t\tfa[find(Y)]=find(X);\n\n\t}\n\tf(i,0,200)if(dgi[i]<dgo[i])orz;\n\tf(i,201,400)if(dgi[i]>dgo[i])orz;\n\tf(i,0,400)out[find(i)]|=(dgi[i]^dgo[i]);\n\tf(i,0,400)if(fa[i]==i&&book[i]&&!out[fa[i]])orz;\n\tqwq;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n//    int dx[8]={0,1,0,-1,1,1,-1,-1};\n  //  int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==0)return b;\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n} \n                                \n                int pr[200010];\n                int inv[200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tinv[ert]=beki(pr[ert],mod-2,mod);\n                \t\n                \tfor(int i=ert-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    //mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\t   \n       \n                               //----------------kokomade tenpure------------\n\nstruct unionfind{\n\tprivate:\n\tpublic:\n\t\nvector<int> par,ranks,kosuu;\n\t\n\tvoid shoki(int N){\n\t\tpar.resize(N+1,0);\n\t\tranks.resize(N+1,0);\n\t\tkosuu.resize(N+1,1);\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t}\n\n\tint root(int x){\n\t\treturn par[x]==x ? x : par[x]=root(par[x]);\n\t}\n\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n\tbool is_root(int x){\n\t\treturn x==root(x);\n\t}\n\tvoid unite(int x,int y){\n \t\tx=root(x);\n\t \ty=root(y);\n\t\tint xx=kosuu[x],yy=kosuu[y];\n\t \tif(x==y) return;\n\t\tif(ranks[x]<ranks[y]){\n\t\t\tpar[x]=y;\n\t\t\tkosuu[y]=yy+xx;\n\t\t}\n\t \telse {\n\t\t\tpar[y]=x;\n\t\t\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n\t \t\tkosuu[x]=yy+xx;\n\t \t}\n\t\treturn;\n\t}\n};\n\nvector<int> G[600];\n\t\nint shu[600]={};\nunionfind uf;\nint nyu[600]={};\n\nint aru[600]={};\n\nvector<int> ve[600];\n\n\n\nvoid ch(int r){\n\tif(ve[r].size()==1){\n\t\tif(aru[ve[r][0]]){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\texit(0);\n\t\t}\n\t\treturn ;\n\t}\n\tint ss=0,gg=0;\n\tfor(auto v:ve[r]){\n\t\tif(v<300)ss++;\n\t\telse gg++;\n\t}\n\tif(ss==0 || gg==0){\n\t\tcout<<\"NO\"<<endl;\n\t\texit(0);\n\t}\n\tss=0;\n\tgg=0;\n\tint we=0;\n\tfor(auto s:ve[r])for(auto g:G[s]){\n\t\tif(s<300 && g<300) continue;\n\t\tif(s>300 && g>300) continue;\n\t\tif(s<300 && g>300) ss++,gg++,we++;\n\t\telse ss--,gg--,we--;\n\t\t\n\t}\n\tif(!ss){\n\t\tcout<<\"NO\"<<endl;\n\t\texit(0);\n\t}\n//\tcout<<ss<<\" \"<<ve[r].size()<<endl;\n}\n\n\nsigned main(){\n\n\t\t  cin.tie(0);\n\tios::sync_with_stdio(false);\n\nint n,h;\n\tuf.shoki(600);\n\tcin>>n>>h;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tint lef,rig;\n\t\tif(c){\n\t\t\tlef=300+c;\n\t\t}\n\t\telse lef=a;\n\t\tif(d){\n\t\t\trig=d;\n\t\t}\n\t\telse rig=b+300;\n\t\tshu[lef]++;\n\t\tnyu[rig]++;\n\t\tuf.unite(lef,rig);\n\t//\tcout<<lef<<\" \"<<rig<<endl;\n\t\tG[lef].pb(rig);\n\t\tif(lef==rig)aru[lef]=1;\n\t}\n\t\n\tfor(int i=0;i<300;i++){\n\t\tif(shu[i]-nyu[i]<0){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor(int i=300;i<600;i++){\n\t\tif(shu[i]-nyu[i]>0){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t\n\tfor(int i=0;i<600;i++)ve[uf.root(i)].pb(i);\n\t\n\tfor(int i=0;i<600;i++)if(ve[i].size())ch(i);\n\t\n\tcout<<\"YES\"<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MX=100010, inf=2e9;\n\nint n, h;\nmap<pii, int> indeg, outdeg;\n\nbool solve(){\n    int cnt1=0, cnt2=0;\n    bool ex1=false, ex2=false;\n    for(int i=1; i<=h; i++){\n        pii a=pii(0,i), b=pii(i,h);\n        if(indeg[a]<outdeg[a]) return false;\n        if(outdeg[b]<indeg[b]) return false;\n        int x=max(0, indeg[a]-outdeg[a]);\n        int y=max(0, outdeg[b]-indeg[b]);\n        cnt1+=x, cnt2+=y;\n        outdeg[a]+=x, indeg[b]+=y;\n        ex1|=(indeg[a]!=0); ex2|=(indeg[b]!=0);\n    }\n    if(cnt1!=cnt2 || !ex1 || !ex2) return false;\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin>>n>>h;\n    for(int i=1; i<=n; i++){\n        int a, b, c, d; cin>>a>>b>>c>>d;\n        if(c>0) a=h;\n        if(d>0) b=h;\n        outdeg[(c==0 ? pii(a,h) : pii(0,c))]++;\n        indeg[pii(d,b)]++;\n    }\n    cout<<(solve() ? \"YES\" : \"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 50;\n\nint n , h , ins[maxn] , outs[maxn] , vis[maxn];\nvector < int > edge[maxn];\nset < int > wr;\n\nvoid dfs( int u ){\n\tfor(auto v : edge[u]){\n\t\tif( vis[v] )\n\t\t\tcontinue;\n\t\tvis[v] = 1;\n\t\tdfs( v );\n\t}\n}\n\nint main( int argc , char * argv[] ){\n\tscanf( \"%d%d\" , & n , & h );\n\tfor(int i = 1 ; i <= n ; ++ i){\n\t\tint a , b , c , d;\n\t\tscanf( \"%d%d%d%d\" , & a , & b , & c , & d );\n\t\tint u , v;\n\t\tif( d == 0 )\n\t\t\tu = b + h + 1;\n\t\telse\n\t\t\tu = d;\n\t\tif( c == 0 )\n\t\t\tv = a;\n\t\telse\n\t\t\tv = c + h + 1;\n\t\touts[u] ++ ;\n\t\tins[v] ++ ;\n\t\tedge[u].emplace_back( v );\n\t\tedge[v].emplace_back( u );\n\t\twr.insert( u );\n\t\twr.insert( v );\n\t}\n\tint base = *wr.begin();\n\tvis[base] = 1;\n\tdfs( base );\n\tfor(auto it : wr)\n\t\tif(!vis[it]){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tint cnt = 0;\n\tfor(auto it : wr){\n\t\tint z = abs( ins[it] - outs[it] );\n\t\tif( z != 0 && z != 1 ){\n\t\t\tputs( \"NO\" );\n\t\t\treturn 0;\n\t\t}\n\t\tif( z == 1 )\n\t\t\t++ cnt;\n\t}\n\tif( cnt == 0 )\n\t\tputs( \"NO\" );\n\telse\n\t\tputs( \"YES\" );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int MAXN=100005,MAXH=405;\n\nint N,H;\nint in[MAXH],out[MAXH];\nint cntS[MAXH],cntT[MAXH];\nbool vis[MAXH];\n\nint fa[MAXH];\nint Root(int x)\n{return fa[x]==0?x:(fa[x]=Root(fa[x]));}\nvoid Union(int x,int y)\n{\n\tint r1=Root(x),r2=Root(y);\n\tif(r1==r2)\n\t\treturn;\n\tfa[r1]=r2;\n}\n\nint ID(int h,int d)\n{return h*2-1+d;}\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint u,v;\n\t\tif(c==0)\n\t\t\tu=ID(a,0);\n\t\telse\n\t\t\tu=ID(c,1);\n\t\tif(d==0)\n\t\t\tv=ID(b,1);\n\t\telse\n\t\t\tv=ID(d,0);\n\t\tout[u]++;\n\t\tin[v]++;\n\t\tvis[u]=vis[v]=true;\n\t\tUnion(u,v);\n\t\t//printf(\"(%d,%d)->(%d,%d)          %d->%d\\n\",(u-1)/2+1,(u&1)^1,(v-1)/2+1,(v&1)^1,u,v);\n\t}\n\t\n\tfor(int i=1;i<=2*H;i++)\n\t{\n\t\tif(in[i]-out[i]>=1)\n\t\t{\n\t\t\tif(i&1)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcntT[Root(i)]+=in[i]-out[i];\n\t\t}\n\t\tif(out[i]-in[i]>=1)\n\t\t{\n\t\t\tif((i&1)^1)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcntS[Root(i)]+=out[i]-in[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=2*H;i++)\n\t\tif(vis[i]&&fa[i]==0&&(cntS[i]!=cntT[i]||(cntS[i]==0&&cntT[i]==0)))\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"YES\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tsrand(clock());\n\tint x = rand()%2;\n\tcout << (x ? \"YES\" : \"NO\") << \"\\n\";\n\treturn 0;\n}\n// -_-"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\nint n,m;\nint fa[2000003],vis[2000003],D[2000003],C[2000003];\ninline int find(int x){\n\tif(fa[x]==x){\n\t\treturn fa[x];\n\t}else{\n\t\treturn fa[x]=find(fa[x]);\n\t}\n}\nint main(){\n\tcin>>n>>m;\n    for(int i=1;i<=1000;i++){\n    \tfa[i]=i;\n\t}\n    for(int i=1;i<=n;i++){\n        int x,y,a,b,c,d;\n        cin>>a>>b>>c>>d;\n        x=!c?a+500:-c+500;\n        y=!d?-b+500:d+500;\n        fa[find(x)]=find(y);\n        D[x]++,D[y]--;\n\t\tvis[x]=1;\n    }\n    int flag=1;\n    for(int i=1;i<500;i++){\n    \tif(D[i]>0){\n\t\t\tputs(\"NO\");\n    \t\treturn 0;\n\t\t}\n\t}\n    for(int i=501;i<=1000;i++){\n    \tif(D[i]<0){\n    \t\tputs(\"NO\");\n    \t\treturn 0;\n\t\t}\n\t}\n    for(int i=1;i<=1000;i++){\n    \tvis[find(i)]|=vis[i];\n\t}\n    for(int i=1;i<=1000;i++){\n\t\tif(D[i]!=0){\n\t\t\tC[find(i)]=1;\n\t\t}\n\t}\n    for(int i=1;i<=1000;i++){\n    \tif(fa[i]==i&&!C[i]&&vis[i]){\n    \t\tputs(\"NO\");\n    \t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"YES\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=410;\nint n,h,in[N],out[N];\nint fa[N];\nbool ok[N];\n\nint find(const int &x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\nint main()\n{\n    n=read();h=read();\n    for(int i=1;i<=(h<<1);i++) fa[i]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int A=read(),B=read(),C=read(),D=read();\n        int x=C?C+h:A,y=D?D:B+h;\n        out[x]++;in[y]++;\n        x=find(x);y=find(y);\n        if(x!=y) fa[x]=y;\n    }\n    for(int i=1;i<=h;i++) if(in[i]>out[i]) return !puts(\"NO\");\n    for(int i=h+1;i<=(h<<1);i++) if(in[i]<out[i]) return !puts(\"NO\");\n    for(int i=1;i<=(h<<1);i++) if(in[i]!=out[i]||!in[i]&&!out[i]) ok[find(i)]=1;\n    for(int i=1;i<=(h<<1);i++) if(fa[i]==i&&!ok[i]) return !puts(\"NO\");\n    return !puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    int n,h;\n    cin >>n>>h;\n    vector<pair<int,int>> rb{},lb{},rt{},lt{};\n    for (int i=0;i<n;i++){\n        int a,b,c,d;\n        cin>>a>>b>>c>>d;\n        if(c==0){\n            lb.push_back({i,a});\n        }else{\n            lt.push_back({i,c});\n        }\n        if(d==0){\n            rb.push_back({i,b});\n        }else{\n            rt.push_back({i,d});\n        }\n    }\n    if(lt.size()==0&&rt.size()==0){\n        cout<<\"YES\"<<endl;\n        return 0;\n    }\n    sort(lb.begin(),lb.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(rb.begin(),rb.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(lt.begin(),lt.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(rt.begin(),rt.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n\n\n    if(rb.size()-lt.size()<=0 ||\n       lb.size()-rt.size()<=0 ||\n       rb.size()-lt.size()!=lb.size()-rt.size()) {\n        cout<<\"NO\"<<endl;\n        return 0;\n    }\n    bool is_all_unique=true;\n    vector<int> lb_remain{},rb_remain{};\n\n    int offset1=0;\n    for(int i=0;i<lt.size();i++){\n        while(lt.at(i).second!=rb.at(i+offset1).second){\n            if(offset1>=rb.size()-lt.size()){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            if((i+offset1==0 || rb.at(i+offset1-1).second==rb.at(i+offset1).second) ||\n               (i+offset1==rb.size()-1 || rb.at(i+offset1).second==rb.at(i+offset1+1).second)){\n                is_all_unique=false;\n            }\n            rb_remain.push_back(rb.at(i+offset1).first);\n            offset1++;\n        }\n    }\n    if(offset1!=rb.size()-lt.size()){\n        if(rb.at(rb.size()-2).second==rb.at(rb.size()-1).second){\n            is_all_unique=false;\n        }\n        rb_remain.push_back(rb.at(rb.size()-1).first);\n    }\n\n    int offset2=0;\n    for(int i=0;i<rt.size();i++){\n        while(rt.at(i).second!=lb.at(i+offset2).second){\n            if(offset2>=lb.size()-rt.size()){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            if((i+offset2==0 || lb.at(i+offset2-1).second==lb.at(i+offset2).second) ||\n               (i+offset2==lb.size()-1 || lb.at(i+offset2).second==lb.at(i+offset2+1).second)){\n                is_all_unique=false;\n            }\n            lb_remain.push_back(lb.at(i+offset2).first);\n            offset2++;\n        }\n    }\n    if(offset2!=lb.size()-rt.size()){\n        if(lb.at(lb.size()-2).second==lb.at(lb.size()-1).second){\n            is_all_unique=false;\n        }\n        lb_remain.push_back(lb.at(lb.size()-1).first);\n    }\n    if(is_all_unique){\n        sort(lb_remain.begin(),lb_remain.end());\n        sort(rb_remain.begin(),rb_remain.end());\n        for(int i=0;i<lb_remain.size();i++){\n            if(lb_remain.at(i)!=rb_remain.at(i)){\n                cout<<\"YES\"<<endl;\n                return 0;\n            }\n        }\n        cout<<\"NO\"<<endl;\n        return 0;\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef UTIL_H\n#define UTIL_H\n\n\n\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0), s(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); ++s; }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { --s; A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { s = B = 0; for (auto &a: A) a = queue<T>(); }\n\tinline ui size() const { return s; }\nprivate:\n\tvector<queue<T>> A; ui B; int s;\n};\n\nstruct\tUnionFind {\n\tUnionFind(size_t N) : P(N, -1), comp(N) {}\n\tint find(int x) { while (P[x]> 0){x = P[x]-1;}return x; }\n\tbool united(int x, int y) { return find(x) == find(y); }\n\tbool unite(int x, int y) { x=find(x);y=find(y);if(x==y){return false;}--comp;if(P[x]>P[y]){swap(x,y);}P[x]+=P[y];P[y]= x+1;return true;}\n\tinline ui size(int u) { return -P[find(u)]; }\n\tvector<int> P;\n\tsize_t comp;\n};\n\n\n\n#endif\n\nclass EJigsaw {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, H; cin >> N >> H;\n//        map<int, set<int>> E;\n        UnionFind UF(2*H+2);\n        vector<int> InDeg(2*H+2, 0), OutDeg(2*H+2, 0);\n        for (int i = 0; i < N; ++i) {\n            int A, B, C, D; cin >> A >> B >> C >> D;\n            int left = C ? C : H+1+A;\n            int right = D ? H+1+D : B;\n            InDeg[right]++;\n            OutDeg[left]++;\n            UF.unite(left, right);\n        }\n\n        for (int i = H+2; i <= 2*H-1; ++i) {\n            if (OutDeg[i] >= InDeg[i]) {\n                int diff = OutDeg[i] - InDeg[i];\n                InDeg[i] += diff;\n                OutDeg[0] += diff;\n                if (diff) UF.unite(0, i);\n            } else {\n                cout << \"NO\\n\";\n                return;\n            }\n        }\n        for (int i = 1; i <= H; ++i) {\n            if (OutDeg[i] <= InDeg[i]) {\n                int diff = InDeg[i] - OutDeg[i];\n                InDeg[0] += diff;\n                OutDeg[i] += diff;\n                if (diff) UF.unite(0, i);\n            } else {\n                cout << \"NO\\n\";\n                return;\n            }\n        }\n\n        int cmp = UF.comp;\n        for (int i = 1; i < 2*H+2; ++i) if (InDeg[i] == 0 && OutDeg[i] == 0) --cmp;\n        if (cmp == 1) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEJigsaw solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, H, A[100009], B[100009], C[100009], D[100009], L[100009], R[100009], deg[100009], col[100009], cnts, cnt; bool used[100009];\nvector<int>x[100009];\n\nvoid dfs1(int pos) {\n\tif (col[pos] >= 1) return;\n\tcol[pos] = cnts;\n\tfor (int i = 0; i < x[pos].size(); i++) dfs1(x[pos][i]);\n}\n\nint main() {\n\tcin >> N >> H; H++;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\t\tif (C[i] == 0) { L[i] = -A[i]; cnt++; }\n\t\telse { L[i] = C[i]; }\n\t\tif (D[i] == 0) { R[i] = -B[i]; cnt++; }\n\t\telse { R[i] = D[i]; }\n\t\tR[i] *= -1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint a1 = 0, a2 = 0;\n\t\tif (L[i] < 0) a1 = H + (-L[i]); else a1 = L[i];\n\t\tif (R[i] < 0) a2 = H + (-R[i]); else a2 = R[i];\n\t\tdeg[a1]++; deg[a2]--; used[a1] = true; used[a2] = true;\n\t\tx[a1].push_back(a2); x[a2].push_back(a1);\n\t}\n\tbool OK = true; int V = 0;\n\tfor (int i = 0; i < H; i++) { if (deg[i] > 0) OK = false; }\n\tfor (int i = H; i < 2 * H; i++) { if (deg[i] < 0) OK = false; else V += deg[i]; }\n\n\tfor (int i = 0; i < 2 * H; i++) {\n\t\tif (col[i] == 0 && used[i] == true) { cnts++; dfs1(i); }\n\t}\n\tif (cnts > (cnt - N - 1) + 1) OK = false;\n\n\tif (OK == true) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,h;\ntuple<int,int,int,int> a[100010];int fa[100010];\nint find(const int &x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint ii[100010],oo[100010],mapp[100010];\nvoid init(){\n\tfor(int i=1;i<=n;i++){\n\t\tint f,t;\n\t\tif(f=get<2>(a[i])) f+=h;\n\t\telse f=get<0>(a[i]);\n\t\tif(t=get<3>(a[i]));\n\t\telse t=get<1>(a[i])+h;\n\t\too[f]++,ii[t]++;f=find(f),t=find(t);\n\t\tif(f^t) fa[f]=t;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=1000;i++) fa[i]=i;\n\tint A,B,C,D;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d%d%d\",&A,&B,&C,&D),a[i]={A,B,C,D};\n\tbool fg=1;\n\tfor(int i=1;i<=h;i++) if(ii[i]>oo[i]) fg=0;\n\tfor(int i=h+1;i<=h+h;i++) if(ii[i]<oo[i]) fg=0;\n\tfor(int i=1;i<=h+h;i++) if(ii[i]!=oo[i]||(ii[i]+oo[i]==0)) mapp[find(i)]++;\n\tfor(int i=1;i<=h+h;i++) if(!mapp[i]&&i==fa[i]) fg=0;\n\tprintf(\"%s\\n\",fg?\"YES\":\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 200500;\nconst int MAXM = 3500005;\n\nnamespace Flow\n{\n\tconst int INF = 0x3f3f3f3f;\n\n\tstruct Edge { int p, v, w; } e[MAXM];\n\tint dis[MAXN], hed[MAXN], cur[MAXN], q[MAXN], ql, qr, e_cnt = 1, tot, S, T;\n\n\tinline void Add(int x, int y, int w) { e[++ e_cnt] = {y, hed[x], w}; hed[x] = e_cnt; }\n\tinline void Addedge(int x, int y, int w) { Add(x, y, w); Add(y, x, 0); }\n\n\tinline bool Bfs()\n\t{\n\t\tfor (int i = 0; i <= tot; i ++)\n\t\t\tdis[i] = 0;\n\t\tdis[q[ql = 0] = S] = qr = 1;\n\t\twhile (ql ^ qr)\n\t\t{\n\t\t\tint x = q[ql ++];\n\t\t\tfor (int i = hed[x]; i; i = e[i].v)\n\t\t\t\tif (e[i].w && !dis[e[i].p])\n\t\t\t\t\tdis[q[qr ++] = e[i].p] = dis[x] + 1;\n\t\t}\n\t\treturn dis[T];\n\t}\n\n\tinline int Dfs(int x, int f)\n\t{\n\t\tif (x == T)\n\t\t\treturn f;\n\t\tint ret = 0, d;\n\t\tfor (int &i = cur[x]; i; i = e[i].v)\n\t\t\tif (e[i].w && dis[e[i].p] == dis[x] + 1)\n\t\t\t{\n\t\t\t\td = Dfs(e[i].p, min(f - ret, e[i].w));\n\t\t\t\te[i].w -= d; e[i ^ 1].w += d; ret += d;\n\t\t\t\tif (ret == f)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\tdis[x] = -1;\n\t\treturn ret;\n\t}\n\n\tinline int Dinic()\n\t{\n\t\tint ret = 0;\n\t\twhile (Bfs())\n\t\t{\n\t\t\tfor (int i = 0; i <= tot; i ++)\n\t\t\t\tcur[i] = hed[i];\n\t\t\tret += Dfs(S, INF);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nusing namespace Flow;\nint n, h, a[MAXN], b[MAXN], c[MAXN], d[MAXN];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), h = Read();\n\tfor (int i = 1; i <= n; i ++)\n\t\ta[i] = Read(), b[i] = Read(), c[i] = Read(), d[i] = Read();\n\tS = 0, T = tot = n << 1 | 1;\n\tint SS = ++ tot, TT = ++ tot;\n\tAddedge(S, SS, 1); Addedge(TT, T, 1);\n\tfor (int i = 1; i <= n; i ++)\n\t\tAddedge(S, i, 1), Addedge(i + n, T, 1);\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tif (!c[i])\n\t\t\tAddedge(i, tot + a[i], 1);\n\t\tAddedge(i, tot + h + c[i], 1);\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tif (!d[i])\n\t\t\tAddedge(tot + h + b[i], i + n, 1);\n\t\tAddedge(tot + d[i], i + n, 1);\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (!c[i])\n\t\t\tAddedge(i, TT, 1);\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (!d[i])\n\t\t\tAddedge(SS, i + n, 1);\n\ttot += h << 1;\n\tif (Dinic() == n + 1)\n\t\tputs(\"YES\");\n\telse\n\t\tputs(\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int base=210;\nint n,H,in[500],out[500];\n\nvoid addedge(int u,int v)\n{\n//\tprintf(\"%d %d\\n\",u,v);\n\tout[base+u]++;\n\tin[base+v]++;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,a,b,c,d;\n\tscanf(\"%d%d\",&n,&H);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\taddedge(c?-c:a,d?d:-b);\n\t}\n\n\tfor (i=-200;i<=200;i++)\n\t\tif (out[base+i]!=in[base+i])\n\t\t{\n//\t\t\tprintf(\"%d : %d\\n\",i,out[base+i]-in[base+i]);\n//\t\t\tprintf(\"%d\\n\",(i<0)^(out[base+i]<in[base+i]));\n\t\t\tif ((i<0)^(out[base+i]<in[base+i]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nbool solve(){\n\tint N,H;\n\tcin>>N>>H;\n\tvector<int> deg(2*H+3);\n\tvector<bool> is(2*H+3,false);\n\tint S = 2*H+2;\n\tint V = 2*H+3;\n\tis[S] = true;\n\n\tbool e[403][403]={};\n\trep(i,V) e[i][i] = 1;\n\n\n\trep(i,N){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tint s = (c==0?a:H+1+c);\n\t\tint t = (d==0?H+1+b:d);\n\t\tdeg[s]++;\n\t\tdeg[t]--;\n\t\te[s][t] = 1;\n\t\tis[s] = 1;\n\t\tis[t] = 1;\n\t}\n\trep(i,H+1){\n\t\tif(deg[i]<0) return 0;\n\t\tif(deg[i]>0) e[S][i] = 1;\n\t\tif(deg[i+H+1]>0) return 0;\n\t\tif(deg[i+H+1]<0) e[i+H+1][S] = 1;\n\t}\n\trep(i,V) rep(j,V) rep(k,V) if(e[j][i]&&e[i][k]) e[j][k] = 1;\n\trep(i,V) if(is[i]){\n\t\tif(!(e[S][i]&&e[i][S])) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n\tif(solve()) puts(\"YES\");\n\telse puts(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <queue>\n#include <limits>\n#include <deque>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#define mp make_pair\n#define fs first\n#define se second\n#define memset(a,t) memset(a,t,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define MN 0LL\n#define Mx 200000005\n#define Mn -Mx\n#define MX 20000000000000005\nusing namespace std;\nint readint(){\n\tchar c;\n\twhile(c=getchar(),(c<'0'||c>'9')&&c!='-');\n\tbool flag=(c=='-');\n\tif(flag)c=getchar();\n\tint x=0;\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn flag?-x:x;\n}\ninline string tos(int x){\n\tstring s;\n\twhile(x) s=(char)(x%10+'0')+s,x/=10;\n\treturn s;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint r;\n\tsrand(time(NULL));\n\tr=rand()%2;\n\tif(r==1) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 100005\n#define M 405\nusing namespace std;\nbool bz[N];\nint cd[M],rd[M],n,num,f[M],h,m;\nint main()\n{\n\tcin>>n>>h;\n\tfo(i,1,n)\n\t{\n\t\tint a,b,c,d,x,y;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=(c>0)?c:(a+200);\n\t\ty=(d>0)?(d+200):b;\n\t\tcd[x]++,rd[y]++;\n\t}\n\t\tbool pd=1;\n\t\tint v1=0,v2=0;\n\t\tfo(i,1,400) \n\t\t{\n\t\t\tif(abs(rd[i]-cd[i])>1) \n\t\t\t{\n\t\t\t\tpd=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(rd[i]-cd[i]==-1) \n\t\t\t{\n\t\t\t\tv1++;\n\t\t\t\tif(i<=200)\n\t\t\t\t{\n\t\t\t\t\tpd=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(rd[i]-cd[i]==1) \n\t\t\t{\n\t\t\t\tv2++;\n\t\t\t\tif(i>200)\n\t\t\t\t{\n\t\t\t\t\tpd=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pd&&v1>0&&v2>0&&v1==v2) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 410;\n\nint deg[N], fa[N], cnte[N];\n\nint find(int x){\n\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nint n, H;\n\nint main(){\n\tscanf(\"%d%d\", &n, &H);\n\n\tFor(i, 1, 2 * H) fa[i] = i;\n\tFor(i, 1, n){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint u = !c ? a : H + c, v = !d ? H + b : d;\n\t\tif(find(u) ^ find(v)){\n\t\t\tcnte[find(v)] += cnte[find(u)];\n\t\t\tfa[find(u)] = fa[v];\n\t\t}\n\t\tif((u > H) ^ (v > H)) ++cnte[find(v)];\n\t\t++deg[u], ++deg[v];\n\t}\n\n\tbool flag = true;\n\tFor(i, 1, 2 * H) if(i == fa[i] && deg[i]){\n\t\tint s = 0, t = 0;\n\t\tFor(j, 1, H) if(find(j) == i && deg[j] % 2) ++s;\n\t\tFor(j, H + 1, 2 * H) if(find(j) == i && deg[j] % 2) ++t;\n\t\tif(cnte[i] < max(s, t) || !cnte[i]){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tputs(flag ? \"YES\" : \"NO\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2e5+7;\nint in[N],out[N],fa[N],sz[N],n,h;\ninline int find(int x){while(x!=fa[x])x=fa[x]=fa[fa[x]];return x;}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=0;i<=2*h;++i)fa[i]=i,sz[i]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tint A,B,C,D;\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tint iL=C==0?A:-C,iR=D==0?-B:D;\n\t\t++in[iL+=h],++out[iR+=h];\n\t\tif(find(iL)!=find(iR))sz[fa[iR]]+=sz[fa[iL]],fa[fa[iL]]=fa[iR];\n\t}\n\tbool ok=1;\n\tfor(int i=0;i<=2*h&&ok;++i)\n\tif(in[i]||out[i]){\n\t\tif(i<=h&&in[i]>out[i])ok=0;\n\t\tif(i>h&&in[i]<out[i])ok=0;\n\t\tif(sz[find(i)]==1)ok=0;\n\t}\n\tputs(ok?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstring>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nint N,H,pal;\tint a,b,c,d;\nstruct line{int in,ch;}lines[100001];bool cam(line a,line b){return a.in>b.in;}\nbool v[100001];\nvoid solve(int no,int t)\n{\n\tint st=0;\n\twhile(lines[st].in!=-lines[no].ch)st++;\n\tif(t==N-1)\n\t{\n\t\tfor(int i=st;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0&&lines[i].ch>=0)\n\t\t\t{pal=1;}\n\t\t\tif(pal)return;\n\t\t}\n\t\tif(lines[no].ch>0)\n\t\t{\n\t\t\tfor(int i=0;i<N&&lines[i].in>=0;i++)\n\t\t\t{\n\t\t\t\tif(v[i]==0&&lines[i].ch>=0)\n\t\t\t\t{pal=1;}\n\t\t\t\tif(pal)return;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\n\t\tfor(int i=st;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0)\n\t\t\t{\tv[i]=1;\n\t\t\t\tsolve(i,t+1);\n\t\t\t\tv[i]=0;}\n\t\t\tif(pal)return;\n\t\t}\n\t\tif(lines[no].ch>0)\n\t\t{\n\t\t\tfor(int i=0;i<N&&lines[i].in>0;i++)\n\t\t\t{\n\t\t\t\tif(v[i]==0)\n\t\t\t\t{\tv[i]=1;\n\t\t\t\t\tsolve(i,t+1);\n\t\t\t\t\tv[i]=0;\n\t\t\t\t}\n\t\t\t\tif(pal)return;\n\t\t\t}\n\t\t}\n\t}\n\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\n\tpal=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta=c==0?a:-c;b=d==0?b:-d;\n\t\tlines[i].in=a;lines[i].ch=b;\n\t}\n\tsort(lines,lines+N,cam);\n\tfor(int i=0;i<N&&lines[i].in>=0;i++)\n\t{\n\t\tv[i]=1;\n\t\tsolve(i,1);\n\t\tv[i]=0;\n\t\tif(pal)break;\n\t}\n\tif(pal)printf(\"YES\");\n\telse printf(\"NO\");\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\n#define mp make_pair\n#define ni(x) scanf(\"%d\", &(x))\n#define nii(x,y) scanf(\"%d%d\",&(x),&(y))\n#define mul(x,y) ((ll)(x)*(y)%mod)\n#define mtp make_tuple\n#define F(i,n) for(int i = 0; i < (n); i++)\n#define FF(i,n) for(int i = 1; i <= (n); i++)\n#define FE(i,n) for(int i = 0; i <= (n); i++)\n\n#ifndef __GNUG__\nint __builtin_popcount(int n) {\n\tint x = 0;\n\twhile (n)n -= n&(-n), x++;\n\treturn x;\n}\n#endif\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int mod = 1000000007;\nconst int inf = 2012345678;\nconst ll infl = 9012345678901234567;\nconst double pi = 3.1415926535897932384626433832795;\n//----------------------------------------------------------------------------//\n\nconst int N = 100000 + 1000;\n\nvector<int> adj[N], rev[N];\nint ord[N], clk, scc[N], ind[N], chk[N], ccn;\n\nvoid dfs1(int u) {\n\tchk[u] = 1;\n\tfor (auto &x : rev[u]) {\n\t\tif (chk[x])continue;\n\t\tdfs1(x);\n\t}\n\tord[clk++] = u;\n}\nvoid dfs2(int u) {\n\tchk[u] = 1;\n\tscc[u] = ccn;\n\tfor (auto &x : adj[u]) {\n\t\tif (chk[x])continue;\n\t\tdfs2(x);\n\t}\n}\n\nint main() {\n#ifndef __GNUG__\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n, h; nii(n, h);\n\tF(i, n) {\n\t\tint a, b, c, d; nii(a, b); nii(c, d);\n\t\tif (c == 0) {\n\t\t\tadj[n - 1 + a].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tadj[n + h - 1 + c].push_back(i);\n\t\t}\n\t\tif (d == 0) {\n\t\t\tadj[i].push_back(n + h - 1 + b);\n\t\t}\n\t\telse {\n\t\t\tadj[i].push_back(n - 1 + d);\n\t\t}\n\t}\n\tint S = n + 2 * h;\n\tint T = S + 1;\n\tadj[T].push_back(S);\n\tFF(i, h)adj[S].push_back(n - 1 + i);\n\tFF(i, h)adj[n + h - 1 + i].push_back(T);\n\n\tint vn = n + 2 * h + 2;\n\tF(i, vn)for (auto &x : adj[i])rev[x].push_back(i);\n\tF(i, vn)if (!chk[i])dfs1(i);\n\tF(i, vn)chk[i] = 0;\n\tfor (int i = vn - 1; i >= 0; i--) {\n\t\tint j = ord[i];\n\t\tif (chk[j])continue;\n\t\tdfs2(j);\n\t\tccn++;\n\t}\n\tF(i, n) {\n\t\tif (scc[i] != scc[S])return puts(\"NO\"), 0;\n\t}\n\tif (scc[T] != scc[S])return puts(\"NO\"), 0;\n\tF(i, vn)for (auto &x : adj[i])ind[x]++;\n\t\n\tFF(i, h) {\n\t\tif (ind[n - 1 + i] - 1 > (int)adj[n - 1 + i].size())return puts(\"NO\"), 0;\n\t\tif (ind[n + h - 1 + i] < (int)adj[n + h - 1 + i].size() - 1)return puts(\"NO\"), 0;\n\t}\n\tputs(\"YES\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nvector <pii> I[101010], O[101010];\nbool chk[222];\nint n, h;\n\nint dfs(int p)\n{\n\tint ret = O[p].size();\n\t\n\tchk[p] = 1;\n\t\n\tfor(pii t: O[p]){\n\t\tif(!chk[t.first]){\n\t\t\tret += dfs(t.first);\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tint i, a, b, c, d, s1, s2, t1, t2, f, f1, f2;\n\tscanf(\"%d%d\", &n, &h);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\n\t\tf = 0;\n\t\tif(c) a = c;\n\t\telse f |= 1;\n\t\tif(d) b = d;\n\t\telse f |= 2;\n\t\t\n\t\tI[b].push_back(pii(a, f));\n\t\tO[a].push_back(pii(b, f));\n\t}\n\t\n\tif(n == 1){\n\t\tif(f == 3) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t\t\n\t\treturn 0;\n\t}\n\t\n\ts1 = s2 = 0;\n\t\n\tfor(i=1;i<h;i++){\n\t\tif(I[i].size() + 1 == O[i].size()) s1 ++, t1 = i;\n\t\telse if(I[i].size() == O[i].size() + 1) s2 ++, t2 = i;\n\t\telse if(I[i].size() != O[i].size()){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<h;i++) chk[i] = 0;\n\t\n\tif(s1 == 0 && s2 == 0 && dfs(1) == n){\n\t\tfor(i=1;i<h;i++){\n\t\t\tf1 = f2 = 0;\n\t\t\tfor(pii j: O[i]) if(j.second & 1) f1 ++;\n\t\t\tfor(pii j: I[i]) if(j.second & 2) f2 ++;\n\t\t\tif(f1 && f2){\n\t\t\t\tif(f1 > 1 || f2 > 1){\n\t\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if(f1 == 1 && f2 == 1){\n\t\t\t\t\tfor(pii j: O[i]){\n\t\t\t\t\t\tif((j.second & 3) && j.first == i){\n\t\t\t\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=1;i<h;i++) chk[i] = 0;\n\t\n\tif(s1 == 1 && s2 == 1 && dfs(t1) == n){\n\t\tf1 = f2 = 0;\n\t\tfor(pii j: O[t1]) if(j.second & 1) f1 ++;\n\t\tfor(pii j: I[t2]) if(j.second & 2) f2 ++;\n\t\tif(f1 && f2){\n\t\t\tif(f1 > 1 || f2 > 1){\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if(f1 == 1 && f2 == 1){\n\t\t\t\tfor(pii j: O[t1]){\n\t\t\t\t\tif((j.second & 3) && j.first == t2){\n\t\t\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"NO\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, e[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += c[i];\n\t}\n\tif (s < e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[30000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t\tif (j = l)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]&&c[j][4]==0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t\tif (j = l)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ninline void read(int &x){\n\tx=0;static char ch;static bool flag;flag = false;\n\twhile(ch=getchar(),ch<'!');if(ch == '-') ch=getchar(),flag = true;\n\twhile(x=10*x+ch-'0',ch=getchar(),ch>'!');if(flag) x=-x;\n}\n#define rg register int\n#define rep(i,a,b) for(rg i=(a);i<=(b);++i)\n#define per(i,a,b) for(rg i=(a);i>=(b);--i)\nconst int maxn = 512;\nconst int zero = 250;\nint fa[maxn],siz[maxn],oud[maxn],ind[maxn];bool h[maxn];\nint find(int x){return fa[x] == x ? x : fa[x] = find(fa[x]);}\ninline void Union(int x,int y){\n\tx = find(x);y = find(y);\n\tif(x == y) {++siz[x];return ;}\n\tfa[x] = y;siz[y] += siz[x] + 1;\n}\nint main(){\n\tint n,H;read(n);read(H);\n\trep(i,1,H)  fa[i+zero] = i+zero,siz[i+zero] = 1;\n\trep(i,-H,-1)fa[i+zero] = i+zero,siz[i+zero] = 1;\n\tint a,b,c,d;\n\trep(i,1,n){\n\t\tint x,y;\n\t\tread(a);read(b);read(c);read(d);\n\t\tif(c == 0) x = a;else x = -c;\n\t\tif(d == 0) y = -b;else y = d;\n\t\t++ oud[x + zero];++ ind[y + zero];\n\t\tUnion(x+zero,y+zero);\n\t}\n\trep(i,1,H)  if(oud[i+zero] < ind[i+zero]) return puts(\"NO\"),0;\n\trep(i,-H,-1)if(ind[i+zero] < oud[i+zero]) return puts(\"NO\"),0;\n\trep(i,1,H)  h[find(i+zero)] |= (ind[i+zero]!=oud[i+zero]);\n\trep(i,-H,-1)h[find(i+zero)] |= (ind[i+zero]!=oud[i+zero]);\n\trep(i,1,H)  if(siz[find(i+zero)] > 1 && (find(i+zero) == i+zero) && (h[i+zero] == false)) return puts(\"NO\"),0;\n\trep(i,-H,-1)if(siz[find(i+zero)] > 1 && (find(i+zero) == i+zero) && (h[i+zero] == false)) return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define y1 yy\n\nusing namespace std;\n\nnamespace SETS {\n\nint fa[405];\n\nvoid init() {\n  for(int i=1;i<=401;i++) fa[i]=i;\n}\n\nint find_father(int x) {\n  return (fa[x]==x)?x:fa[x]=find_father(fa[x]);\n}\n\nbool check(int x,int y) {\n  x=find_father(x);y=find_father(y);\n  return x==y;\n}\n\nvoid merge(int x,int y) {\n  x=find_father(x);y=find_father(y);\n  if (x==y) return;\n  fa[x]=y;\n}\n\n}\n\ninline int id(int x,int y,bool on) {\n  int p=(!y)?x:y+200;\n  if (on) {\n  \tif (p<=200) p+=200; else p-=200;\n  }\n  return p;\n}\n\nint d[405];\nbool vis[405];\n\nint main() {\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  SETS::init();\n  for(int i=1;i<=n;i++) {\n  \tint x1,x2,y1,y2;\n  \tscanf(\"%d%d%d%d\",&x1,&x2,&y1,&y2);\n  \tint p=id(x1,y1,0),q=id(x2,y2,1);\n  \tvis[p]=vis[q]=1;\n  \td[p]++;d[q]--;\n  \tSETS::merge(p,q);\n  }\n  int s1=0;\n  for(int i=1;i<=200;i++)\n    if (d[i]>0) {\n    \ts1+=d[i];\n    \tSETS::merge(i,401);\n\t}\n\telse if (d[i]<0) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n  int s2=0;\n  for(int i=201;i<=400;i++)\n    if (d[i]<0) {\n    \ts2-=d[i];\n    \tSETS::merge(i,401);\n\t}\n\telse if (d[i]>0) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n  for(int i=1;i<=400;i++)\n    if (vis[i]&&!SETS::check(i,401)) {\n    \tputs(\"NO\");\n    \treturn 0;\n\t}\n  puts(\"YES\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=405;\nint fa[N],vis[N],in[N],out[N],n,h;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfp(i,0,h<<1)fa[i]=i;\n\tfor(R int i=1,a,b,c,d,l,r;i<=n;++i){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tl=(c?-c:a)+h,r=(d?d:-b)+h,fa[find(l)]=find(r);\n\t\t++out[l],++in[r];\n\t}\n\tfp(i,-h,-1)if(out[i+h]>in[i+h])return puts(\"NO\"),0;\n\tfp(i,1,h)if(in[i+h]>out[i+h])return puts(\"NO\"),0;\n\tfp(i,0,h<<1)if(in[i]!=out[i])vis[find(i)]=1;\n\tfp(i,0,h<<1)if(in[i]&&out[i]&&!vis[find(i)])return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,h;\n  cin>>n>>h;\n  vector<Int> a(n),b(n),c(n),d(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i]>>c[i]>>d[i];\n  \n  auto idx=\n    [&](Int k,Int s){\n      if(s==0){\n\tif(c[k]==0) return 300+a[k];\n\treturn c[k];\n      }else{\n\tif(d[k]==0) return b[k];\n\treturn 300+d[k];\n      }\n    };\n\n  vector<vector<queue<Int> > > cnt(2,vector<queue<Int> >(600));\n  for(Int i=0;i<n;i++){\n    cnt[0][idx(i,0)].emplace(i);\n    cnt[1][idx(i,1)].emplace(i);\n  }\n  \n  auto NO=[](){cout<<\"NO\"<<endl;exit(0);};\n\n  vector<Int> used(n),ok(600,0);\n  vector<vector<Int> > lp;\n  for(Int i=0;i<n;i++){\n    if(used[i]) continue;\n    Int l=idx(i,0),r=idx(i,1);\n    vector<Int> v;        \n    while(1){\n      v.emplace_back(l);\n      v.emplace_back(r);\n      Int flg=0;\n      while(!cnt[1][l].empty()){\n\tInt k=cnt[1][l].front();cnt[1][l].pop();\n\tif(used[k]) continue;\n\tused[k]=1;\n\tassert(idx(k,1)==l);\n\tl=idx(k,0);\n\tflg=1;\n\tbreak;\n      }\n      if(flg) continue;\n      while(!cnt[0][r].empty()){\n\tInt k=cnt[0][r].front();cnt[0][r].pop();\n\tif(used[k]) continue;\n\tused[k]=1;\n\tassert(idx(k,0)==r);\n\tr=idx(k,1);\n\tflg=1;\n\tbreak;\n      }\n      if(!flg) break;\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());    \n    if(l==r){\n      lp.emplace_back(v);\n      continue;\n    }\n    if(l<300||r>=300) NO();\n    for(Int x:v) ok[x]=1;\n  }\n  for(auto v:lp){\n    Int flg=0;\n    for(Int x:v) flg|=ok[x];\n    if(!flg) NO();\n  }\n  cout<<\"YES\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nvector <int> LI[444], LO[444], RI[444], RO[444];\nvector <pii> V;\nset <int> SL, SR;\nint n, h;\n\nvoid die()\n{\n\tprintf(\"NO\\n\");\n\texit(0);\n}\n\nint main()\n{\n\tint i, j, a, b, c, d;\n\t\n\tscanf(\"%d%d\", &n, &h);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\n\t\tif(c == 0 && d == 0){\n\t\t\tLO[0].push_back(a);\n\t\t\tLI[a].push_back(0);\n\t\t\tRO[0].push_back(b);\n\t\t\tRI[b].push_back(0);\n\t\t}\n\t\telse if(c == 0){\n\t\t\tLO[d].push_back(a);\n\t\t\tLI[a].push_back(d);\n\t\t}\n\t\telse if(d == 0){\n\t\t\tRO[c].push_back(b);\n\t\t\tRI[b].push_back(c);\n\t\t}\n\t\telse V.push_back(pii(c, d));\n\t}\n\t\n\tfor(i=1;i<h;i++){\n\t\tif(LI[i].size() >= LO[i].size()){\n\t\t\tfor(j=0;j<LI[i].size() - LO[i].size();j++) SL.insert(i);\n\t\t}\n\t\telse die();\n\t}\n\t\n\tfor(i=1;i<h;i++){\n\t\tif(RI[i].size() >= RO[i].size()){\n\t\t\tfor(j=0;j<RI[i].size() - RO[i].size();j++) SR.insert(i);\n\t\t}\n\t\telse die();\n\t}\n\t\n\tfor(pii t: V){\n\t\tauto it = SL.find(t.second);\n\t\tif(it == SL.end()) die();\n\t\tSL.erase(it);\n\t\t\n\t\tit = SR.find(t.first);\n\t\tif(it == SR.end()) die();\n\t\tSR.erase(it);\n\t}\n\t\n\tif(SL.empty() || SR.empty()) die();\n\t\n\tprintf(\"YES\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n  //freopen(\"/home/alexandero/ClionProjects/ACM/output.txt\", \"w\", stdout);\n  //freopen(\"out.txt\", \"w\", stdout);\n#else\n  //freopen(\"input.txt\", \"r\", stdin);\n  //freopen(\"output.txt\", \"w\", stdout);\n#endif\n  start = clock();\n  int t = 1;\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n  precalc();\n  cout.precision(10);\n  cout << fixed;\n  //cin >> t;\n  int testNum = 1;\n  while (t--) {\n    //cout << \"Case #\" << testNum++ << \": \";\n    //cerr << testNum << endl;\n    solve(true);\n    //cerr << testNum - 1 << endl;\n  }\n  cout.flush();\n#ifdef AIM1\n  while (true) {\n      solve(false);\n  }\n#endif\n\n#ifdef AIM\n  cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\n//#define int li\n//const int mod = 1000000007;\n\nvoid solve(bool read) {\n  int n, H;\n  cin >> n >> H;\n  map<int, int> first_edges, second_edges;\n  set<int> first_bad, second_bad;\n  bool has_zero1 = false, has_zero2 = false;\n  for (int i = 0; i < n; ++i) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if (d == 0) {\n      has_zero2 = true;\n      ++first_edges[b];\n      if (c == b) {\n        first_bad.insert(b);\n      }\n    } else {\n      ++second_edges[d];\n      if (c == 0 && a == d) {\n        second_bad.insert(d);\n      }\n    }\n    if (c == 0) {\n      has_zero1 = true;\n      --second_edges[a];\n    } else {\n      --first_edges[c];\n    }\n  }\n  if (!has_zero1 || !has_zero2) {\n    cout << \"NO\\n\";\n    return;\n  }\n\n  //cout << \"bad: \" << bad_squares << endl;\n  int cnt = 0;\n  int bad = 0;\n  for (auto item : first_edges) {\n    int cur = -item.second;\n    if (first_bad.count(item.first)) {\n      ++cur;\n    }\n    if (cur == 1) {\n        ++bad;\n    } else if (cur > 1) {\n      cout << \"NO\\n\";\n      return;\n    }\n    cnt += max(0, cur);\n    //cout << \"first \" << item.first << \" \" << item.second << endl;\n  }\n\n  if (bad == first_edges.size() && !second_edges.empty()) {\n    cout << \"NO\\n\";\n    return;\n  }\n\n  for (auto item : second_edges) {\n    int cur = item.second;\n    if (second_bad.count(item.first)) {\n      ++cur;\n    }\n    if (cur > 0) {\n      cout << \"NO\\n\";\n      return;\n    }\n    cnt += max(0, cur);\n    //cout << \"second \" << item.first << \" \" << item.second << endl;\n  }\n\n  if (bad <= 1) {\n    cout << \"YES\\n\";\n  } else {\n    cout << \"NO\\n\";\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define MAX 450\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nint n,H,f[MAX],In[MAX],Ot[MAX];bool vis[MAX];\nint getf(int x){return x==f[x]?x:f[x]=getf(f[x]);}\nint main()\n{\n\tn=read();H=read();\n\tfor(int i=1;i<=H+H;++i)f[i]=i,vis[i]=false;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint l=(c>0?c:-a)+H,r=(d>0?-d:b)+H;\n\t\tif(getf(l)!=getf(r))f[getf(l)]=getf(r);\n\t\tIn[r]+=1;Ot[l]+=1;\n\t}\n\tfor(int i=-H;i<0;++i)if(In[i+H]>Ot[i+H]){puts(\"NO\");return 0;}\n\tfor(int i=1;i<=H;++i)if(In[i+H]<Ot[i+H]){puts(\"NO\");return 0;}\n\tfor(int i=0;i<=H+H;++i)if(In[i]!=Ot[i])vis[getf(i)]=true;\n\tfor(int i=0;i<=H+H;++i)if(In[i]&&Ot[i]&&!vis[getf(i)]){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 405\n#define o 203\nusing namespace std;\n\nint n,H,in[maxn];\nint F[maxn],hd[maxn],sz[maxn];\nint Find(int u){ return !F[u] ? u : F[u] = Find(F[u]); }\n\nint main(){\n\tscanf(\"%d%d\",&n,&H);\n\tfor(int i=1;i<=n;i++){\n\t\tint A,B,C,D;\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tint x , y;\n\t\tif(C == 0) x = A;\n\t\telse x = - C;\n\t\tif(D == 0) y = -B;\n\t\telse y = D;\n\t\tx += o , y += o;\n\t\tin[y] ++ ,in[x] --;\n\t\tif(Find(x) != Find(y))\n\t\t\tF[Find(x)] = Find(y);\n\t\tsz[Find(y)] = 2; \n\t}\n\tbool ER = 0;\n\tfor(int i=1;i<maxn;i++){\n\t\tif(i < o && in[i] < 0) ER = 1;\n\t\tif(i > o && in[i] > 0) ER = 1;\n\t\tif(i > o && in[i] < 0) hd[Find(i)] = 1;\n\t}\n\tfor(int i=1;i<maxn;i++) if(Find(i) == i && sz[i] > 1 && !hd[i])\n\t\tER = 1;\n\tif(ER) puts(\"NO\");\n\telse puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid err() {\n  puts(\"NO\");\n  exit(0);\n}\n\nconst int MAX = 410;\nconst int K = 200;\n\nvector <int> _g[2 * MAX], _gr[2 * MAX], *g = _g + MAX, *gr = _gr + MAX;\nint _x[2 * MAX], _din[2 * MAX], _dout[2 * MAX], *x = _x + MAX, *din = _din + MAX, *dout = _dout + MAX;\nbool _was[2 * MAX], *was = _was + MAX;\n\nint main() {\n  int n, h;\n  scanf(\"%d %d\", &n, &h);\n  for (int i = 0; i < n; i++) {\n    int a, b, c, d;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    int x = (c == 0 ? -a : c);\n    int y = (d == 0 ? b : -d);\n    g[x].push_back(y);\n    gr[y].push_back(x);\n  }\n  for (int i = -K; i <= K; i++) {\n    dout[i] = g[i].size();\n    din[i] = gr[i].size();\n    if (i < 0 && dout[i] < din[i]) {\n      err();\n    }\n    if (i > 0 && dout[i] > din[i]) {\n      err();\n    }\n    was[i] = (din[i] + dout[i] == 0 ? true : false);\n  }\n  for (int i = -K; i <= K; i++) {\n    if (was[i]) {\n      continue;\n    }\n    int b = 0, e = 1;\n    x[0] = i;\n    was[i] = true;\n    while (b < e) {\n      for (int j : g[x[b]]) {\n        if (!was[j]) {\n          was[j] = true;\n          x[e++] = j;\n        }\n      }\n      for (int j : gr[x[b]]) {\n        if (!was[j]) {\n          was[j] = true;\n          x[e++] = j;\n        }\n      }\n      b++;\n    }\n    int sum_pos = 0, sum_neg = 0;\n    for (int j = 0; j < e; j++) {\n      if (x[j] > 0) {\n        sum_pos += din[x[j]] - dout[x[j]];\n      } else {\n        sum_neg += dout[x[j]] - din[x[j]];\n      }\n    }\n    if (sum_pos != sum_neg || sum_pos == 0) {\n      err();\n    }\n  }\n  puts(\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n/*\n * Union-Find tree\n * header requirement: vector\n */\nclass UnionFind {\nprivate:\n  std::vector<int> disj;\n  std::vector<int> rank;\npublic:\n  UnionFind(int n) : disj(n), rank(n) {\n    for (int i = 0; i < n; ++i) {\n      disj[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int root(int x) {\n    if (disj[x] == x) {\n      return x;\n    }\n    return disj[x] = root(disj[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (rank[x] < rank[y]) {\n      disj[x] = y;\n    } else {\n      disj[y] = x;\n      if (rank[x] == rank[y]) {\n\t++rank[x];\n      }\n    }\n  }\n  bool is_same_set(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\n\nconst int H = 210;\n\nint in[H], out[H], inc[H], outc[H];\n\nint main(void){\n  int n, h;\n  cin >> n >> h;\n  set<int> app;\n  UnionFind uf(2 * H);\n  REP(i, 0, n) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    int u, v;\n    if (c == 0) {\n      in[a] += 1;\n      app.insert(u = a);\n    } else {\n      inc[c] += 1;\n      app.insert(u = c + H);\n    }\n    if (d == 0) {\n      out[b] += 1;\n      app.insert(v = b + H);\n    } else {\n      outc[d] += 1;\n      app.insert(v = d);\n    }\n    uf.unite(u, v);\n  }\n  set<int> roots;\n  for (set<int>::iterator it = app.begin(); it != app.end(); ++it) {\n    roots.insert(uf.root(*it));\n  }\n  bool ok = true;\n  int ncc = roots.size();\n  int cnt = 0;\n  REP(i, 0, h + 1) {\n    if (1) {\n      cerr << i << \":\";\n      cerr << \"in=\" << in[i] << \", out=\" << out[i];\n      cerr << \"inc=\" << inc[i] << \", outc=\" << outc[i];\n      cerr << endl;\n    }\n    if (in[i] != outc[i]) {\n      cnt += 1;\n      if (in[i] < outc[i]) {\n\tok = false;\n      }\n    }\n    if (out[i] != inc[i]) {\n      cnt += 1;\n      if (out[i] < inc[i]) {\n\tok = false;\n      }\n    }\n  }\n  ok &= cnt % 2 == 0 && cnt >= 2 * ncc;\n  cout << (ok ? \"YES\" : \"NO\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint read()\n{\n  int x=0,f=1;\n  char ch=getchar();\n  while((ch<'0')||(ch>'9'))\n    {\n      if(ch=='-')\n        {\n          f=-f;\n        }\n      ch=getchar();\n    }\n  while((ch>='0')&&(ch<='9'))\n    {\n      x=x*10+ch-'0';\n      ch=getchar();\n    }\n  return x*f;\n}\n\nconst int maxn=100000;\nconst int maxh=201;\nconst int maxv=401;\n\nnamespace dsu\n{\n  int fa[maxv+10];\n\n  int find(int x)\n  {\n    return fa[x]?(fa[x]=find(fa[x])):x;\n  }\n}\n\nint n,h,pre[maxn+10],now[maxv+10],son[maxn+10],tot,ru[maxv+10],chu[maxv+10],vis[maxn+10];\n\nint ins(int a,int b)\n{\n  pre[++tot]=now[a];\n  now[a]=tot;\n  son[tot]=b;\n  ++ru[b];\n  ++chu[a];\n  return 0;\n}\n\nint main()\n{\n  n=read();\n  h=read();\n  for(int i=1; i<=n; ++i)\n    {\n      int a=read(),b=read(),c=read(),d=read(),x,y;\n      if(c==0)\n        {\n          x=maxh+a;\n        }\n      else\n        {\n          x=maxh-c;\n        }\n      if(d==0)\n        {\n          y=maxh-b;\n        }\n      else\n        {\n          y=maxh+d;\n        }\n      ins(x,y);\n      int fx=dsu::find(x),fy=dsu::find(y);\n      if(fx!=fy)\n        {\n          dsu::fa[fx]=fy;\n        }\n    }\n  for(int i=1; i<=h; ++i)\n    {\n      if(ru[maxh+i]>chu[maxh+i])\n        {\n          puts(\"NO\");\n          return 0;\n        }\n    }\n  for(int i=1; i<=h; ++i)\n    {\n      if(chu[maxh-i]>ru[maxh-i])\n        {\n          puts(\"NO\");\n          return 0;\n        }\n    }\n  for(int i=1; i<=maxv; ++i)\n    {\n      if(((ru[i]==0)&&(chu[i]==0))||(ru[i]!=chu[i]))\n        {\n          vis[dsu::find(i)]=1;\n        }\n    }\n  int flag=0;\n  for(int i=1; i<=maxv; ++i)\n    {\n      if(!vis[dsu::find(i)])\n        {\n          flag=1;\n          break;\n        }\n    }\n  puts(flag?\"NO\":\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\ntypedef long long ll;\nconst int Imx=2147483647;\nconst int mod=1000000007;\nconst ll Lbig=2e18;\n//My own input/output stream\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putsp()\n#define putii(x,y) puti(x),putnum(y),putsp()\n#define putiii(x,y,z) putii(x,y),putnum(z),putsp()\n#define putsi(x) putnum(x),putendl()\n#define putsii(x,y) puti(x),putnum(y),putendl()\n#define putsiii(x,y,z) putii(x,y),putnum(z),putendl()\ninline ll getnum()\n{\n\tregister ll r=0;register bool ng=0;register char c;c=getchar();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tif(c=='-')ng=1,c=getchar();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=getchar();\n\tif(ng)r=-r;return r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline void putsp(){putchar(' ');}\ninline void putendl(){putchar('\\n');}\ninline char mygetchar(){register char c=getchar();while(c==' '||c=='\\n')c=getchar();return c;}\nint n;\nvector<int> con[100111];\nvector<int> vl[211],vr[211],vrs[211],vls[211];\nint vlit[211],vrit[211],vrsit[211],vlsit[211];\nbool vis[100111];\nint A[100111],B[100111],C[100111],D[100111];\nint getvl(int x)\n{\n\twhile(vlit[x]<vl[x].size()&&vis[vl[x][vlit[x]]])\n\t{\n\t\tvlit[x]++;\n\t}\n\tif(vlit[x]==vl[x].size())return -1;else return vl[x][vlit[x]];\n}\nint getvr(int x)\n{\n\twhile(vrit[x]<vr[x].size()&&vis[vr[x][vrit[x]]])\n\t{\n\t\tvrit[x]++;\n\t}\n\tif(vrit[x]==vr[x].size())return -1;else return vr[x][vrit[x]];\n}\nint getvls(int x)\n{\n\twhile(vlsit[x]<vls[x].size()&&vis[vls[x][vlsit[x]]])\n\t{\n\t\tvlsit[x]++;\n\t}\n\tif(vlsit[x]==vls[x].size())return -1;else return vls[x][vlsit[x]];\n}\nint getvrs(int x)\n{\n\twhile(vrsit[x]<vrs[x].size()&&vis[vrs[x][vrsit[x]]])\n\t{\n\t\tvrsit[x]++;\n\t}\n\tif(vrsit[x]==vrs[x].size())return -1;else return vrs[x][vrsit[x]];\n}\nint dfs(int s,int x,int pred=1)\n{\n\tif(vis[s]&&s==x)return 0;\n//\tvis[x]=1;\n\tint a=A[x],b=B[x],c=C[x],d=D[x],u=-1;\n//\tcout<<\"dfs:\"<<x<<\" \"<<pred<<\" \"<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\tif(pred!=1)\n\t{\n\t\tif(c==0)u=getvrs(a);\n\t\telse u=getvr(c);\n\t\tif(u!=-1)\n\t\t{\n\t\t\tvis[u]=1;\n\t\t\treturn dfs(s,u,-1);\n\t\t}\n\t\telse if(c>0)return -1;\n\t}\n\tif(pred!=-1)\n\t{\n\t\tif(d==0)u=getvls(b);\n\t\telse u=getvl(d);\n\t\tif(u!=-1)\n\t\t{\n\t\t\tvis[u]=1;\n\t\t\treturn dfs(s,u,1);\n\t\t}\n\t\telse if(d>0)return -1;\n\t}\n\treturn 1;\n}\nint main()\n{\n\tint tmp;\n\tgetii(n,tmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tgetii(a,b);\n\t\tgetii(c,d);\n\t\tA[i]=a;\n\t\tB[i]=b;\n\t\tC[i]=c;\n\t\tD[i]=d;\n\t\tif(c==0)\n\t\t{\n\t\t\tvl[a].PB(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvls[c].PB(i);\n\t\t}\n\t\tif(d==0)\n\t\t{\n\t\t\tvr[b].PB(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvrs[d].PB(i);\n\t\t}\n\t}\n\tint cnt0=0,cnt1=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(vis[i])continue;\n\t\tint type=dfs(i,i,1);\n\t\tif(type==-1)\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\telse if(type==0)cnt0++;\n\t\telse if(type==1)cnt1++;\n\t}\n\tif(cnt1>0)puts(\"YES\");else puts(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nint read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=405;\nint n,m=401;\nint fa[N],in[N],out[N],cnt[N],f[N];\nint _(int k){\n\tif (k<0)\n\t\treturn 401+k;\n\telse\n\t\treturn k;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nint main(){\n\tfor (int i=1;i<=m;i++)\n\t\tfa[i]=i;\n\tn=read();\n\tread();\n\twhile (n--){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint x=c?-c:a;\n\t\tint y=d?d:-b;\n\t\tx=_(x),y=_(y);\n\t\tfa[getf(x)]=getf(y);\n\t\tin[y]++,out[x]++;\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tif (!in[i]&&!out[i])\n\t\t\tcontinue;\n\t\tcnt[getf(i)]++;\n\t\tif (in[i]!=out[i])\n\t\t\tf[getf(i)]=1;\n\t}\n\tfor (int i=1;i<=200;i++)\n\t\tif (out[i]<in[i]||in[401-i]<out[401-i])\n\t\t\treturn puts(\"NO\"),0;\n\tfor (int i=1;i<=m;i++)\n\t\tif (cnt[i]&&!f[i])\n\t\t\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 405;\nint n, m, f[N], delta[N];\nbool mark[N], ok[N];\n\nint find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> m;\n\tfor (int i = 0; i <= m * 2; ++i) f[i] = i;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a, b, c, d; std::cin >> a >> b >> c >> d;\n\t\tint L = (c ?: -a) + m, R = (d ? -d : b) + m;\n\t\tmark[L] = mark[R] = 1, f[find(L)] = find(R);\n\t\t++delta[L], --delta[R];\n\t}\n\tfor (int i = 0; i <= m * 2; ++i) if (mark[i])\n\t\tif (delta[i] > 0 && i > m || delta[i] < 0 && i < m)\n\t\t\treturn std::cout << \"NO\\n\", 0;\n\tfor (int i = 0; i <= m * 2; ++i) ok[find(i)] |= delta[i] != 0;\n\tfor (int i = 0; i <= m * 2; ++i)\n\t\tif (mark[i] && i == find(i) && !ok[i])\n\t\t\treturn std::cout << \"NO\\n\", 0;\n\tstd::cout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\nint c[201][2];\nint e[201][2];\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\tc[b[i].c][0]++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].a][0]++;\n\t\t}\n\t\tif (b[i].d > 0) {\n\t\t\tc[b[i].d][1]++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].b][1]++;\n\t\t}\n\t}\n\trep(i, 201) {\n\t\trep(j, 2) {\n\t\t\tif (c[i][j] > e[i][j]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntypedef int Weight;\nconst Weight INF=1<<29;\nstruct Edge{\n\tint src,dst;\n\tWeight weight,cap; // weight が辺のコストを表す\n\tint rev; // 逆辺の番号\n\tEdge(int src,int dst,Weight weight=0,Weight cap=0,int rev=-1):\n\tsrc(src),dst(dst),weight(weight),cap(cap),rev(rev)\n\t{}\n};\nstruct Node:public vector<Edge>{};\nbool operator<(const Edge &a,const Edge &b){\n\treturn a.weight<b.weight;\n}\nbool operator>(const Edge &a,const Edge &b){return b<a;}\ntypedef vector<Node> Graph;\ntypedef vector<vector<Weight> > Matrix;\n\n//src から dst へ向かう容量 cap,コストcost の辺をグラフに追加する\nvoid add_edge(Graph &G,int src,int dst,Weight cap,Weight cost){\n\tG[src].push_back(Edge(src,dst,cost,cap,G[dst].size()));\n\tG[dst].push_back(Edge(dst,src,-cost,0,G[src].size()-1));\n}\n\n// O(VE+FElogV)\nWeight min_cost_flow(Graph &G,int s,int t,Weight f){\n\ttypedef pair<Weight,int> P;\n\tWeight res=0;\n\tint V=G.size();\n\tvector<Weight> h(V,0);\n\tvector<int> prevv(V);\n\tvector<int> preve(V);\n\tif(s==t)return 0;\n\tbool start=true;\n\twhile(f>0){\n\t\tvector<Weight> dist(V,INF);\n\t\tif(start){\n\t\t\tbool update=true;\n\t\t\tdist[s]=0;\n\t\t\twhile(update){\n\t\t\t\tupdate=false;\n\t\t\t\trep(v,V){\n\t\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight){\n\t\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight;\n\t\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstart=0;\n\t\t}else{\n\t\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\t\tdist[s]=0;\n\t\t\tque.push(P(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.top();que.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<p.first)continue;\n\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight+h[v]-h[e.dst]){\n\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight+h[v]-h[e.dst];\n\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\tque.push(P(dist[e.dst],e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF){\n\t\t\treturn INF;\n\t\t}\n\t\tfor(int v=0;v<V;v++)h[v]+=dist[v];\n\t\tWeight d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tEdge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\nint cap[500];\n\nint MakeVertex(int a, int c, bool rev=false) {\n  if (c == 0) return a+rev*(H+1);\n  return c+(H+1)*!rev;\n}\n\nsigned main(){\n  cin >> N >> H;\n\n  int S = 0;\n  int l = S+1;\n  int T = l+2*(H+1);\n  int S2 = T+1;\n  int T2 = S2+1;\n  //graph g(T+1);\n  Graph g(T2+1);\n\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    \n    int u = MakeVertex(A[i], C[i]);\n    int v = MakeVertex(B[i], D[i], true);\n\n    cap[u]--;\n    cap[v]++;\n    add_edge(g, l+v, l+u, 1, 1);\n    //cout << l+v << \"->\" << l+u << endl;\n  }\n\n  reps(h, 1, H+1) {\n    int v = MakeVertex(h, 0);\n    add_edge(g, S, l+v, N, 0);\n    //cout << \"S=\" << S << \"->\" << l+v << endl;\n    int u = MakeVertex(0, h);\n    add_edge(g, l+u, T, N, 0);\n    //cout << l+u << \"->T=\" << T << endl;\n  }\n\n  add_edge(g, S2, S, N, 0);\n  add_edge(g, T, T2, N, 0);\n  int f = 1;\n  reps(i, l, T) {\n    int v = i - l;\n    if (cap[v] > 0) {\n      f += cap[v];\n      //cout << \"S2=\" << S2 << \"->\" << i << \": \" << cap[v] << endl;\n      add_edge(g, S2, i, cap[v], 0);\n    } else if (cap[v] < 0) {\n      //cout << i << \"->T2=\" << T2 << \": \" << -cap[v] << endl;\n\n      add_edge(g, i, T2, -cap[v], 0);\n    }\n  }\n  //cout << f << endl;\n\n  //LL a = g.max_flow(S2, T2, true);\n  //LL b = g.max_flow(S, T2);\n  //LL c = g.max_flow(S2, T);\n  LL d = min_cost_flow(g, S2, T2, f)-N;\n  //cout \n  //<< a << \",\" \n  //<< b << \",\"\n  //<< c << \",\"\n  //<< d << endl;\n\n  //if (a+b == a+c && a+b == N*2+2) {\n  if (d <= -N) {\n    //cout << d << \" \" << -N << endl;;\n    assert(d == -N);\n    cout << \"YES\" << endl;\n    return 0;\n  }\n  cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//AtCoder Grand Contest 017 E - Jigsaw\n\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint qr(){int ret = 0,f=1;char ch =getchar();while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();return ret*f;}\n\n#define maxN 100005\n#define maxH 205\n\nint indegree[maxH<<2],outdegree[maxH<<2];\n\nvoid read(int x,int y){\n    indegree[y]++;\n    outdegree[x]++;\n    nxt[++tot] = fir[x];\n    fir[x] = tot;\n    ver[tot] = y;\n}\nint f[maxH<<1];\nvoid init(){\n    for(int i = 1;i<=(maxH<<1);i++)\n        f[i] = i;\n}\nint gf(int x){\n    if(f[x] == x) return x;\n    else return f[x] = gf(f[x]);\n}\nint mer(int x,int y){\n    x = gf(x);y = gf(y);\n    if(x == y) return 0;\n    f[x] = y;\n    return 1;\n}\nint main(){\n    int N = qr(),H = qr();\n    int NN = N;\n    int t1,t2,t3,t4,t5,t6;//上 t + maxN 下 t + maxN + maxH\n    for(int i = 1;i<=N;i++){\n        t1 = qr(),t2 = qr(),t3 = qr(),t4 = qr();\n        if(!t3) t5 = t1;else t5 = t3+H;\n        if(!t4) t6 = t2+H;else t6 = t4;\n        read(t5,t6);\n        N -= mer(t5,t6);\n    }\n    if(NN != 1){\n        cout << \"NO\";\n        return 0;\n    }\n    int in = 0,out = 0;\n    for(int i = 1;i<=(H<<1);i++){\n        if(indegree[i]!=outdegree[i]){\n            if(indegree[i]>outdegree[i])\n                in++;\n            else out++;\n            if(in == 2||out == 2){\n                cout <<\"NO\";\n                return 0;\n            }\n        }\n    }\n    cout << \"YES\";\n    /*\n    int a=0,b=0;\n    for(int i = maxN;i<=maxN + 500;i++){\n        if(indegree[i] == outdegree[i])\n            continue;\n        else {\n            if(abs(indegree[i]-outdegree[i])!=1) {cout << \"NO\";return 0;}\n            else {\n                //if(i<=maxN+maxH) {\n                    if(indegree[i] > outdegree[i])\n                        a++;\n                    else b++;\n                //}else{\n                //    if(indegree[i] > outdegree[i])\n                //        b++;\n                //    else a++;\n                //}\n            }\n            if(a == 2||b == 2){cout << \"NO\";return 0;}\n        }\n    }\n    if(a == b){cout << \"YES\";}\n    else {cout << \"NO\";}\n    */\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=100500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nint a[N];\nint B[2*N][2],A[N],B0;\nint Bv[N][2];\nvoid link(int q,int w)\n{\n\t++Bv[q][0];++Bv[w][1];\n}\nint main()\n{\n\tint q,w;\n\tread(n),read(m);\n\tfo(i,1,n)\n\t{\n\t\tint qa,qb,qc,qd;\n\t\tread(qa),read(qb),read(qc),read(qd);\n\t\tif(qc==0)\n\t\t{\n\t\t\tq=m+qa;\n\t\t}else q=qc;\n\t\tif(qd==0)w=qb;\n\t\telse w=m+qd;\n\t\tlink(q,w);\n\t\t// printf(\"%d %d\\n\",q,w);\n\t}\n\tans=0;q=0;\n\tfo(i,m+1,m*2)\n\t{\n\t\tif(Bv[i][0]<Bv[i][1])++ans;\n\t\tif(Bv[i][0]>Bv[i][1])++q;\n\t}\n\tif(!q){printf(\"NO\\n\");return 0;}\n\tq=0;\n\tfo(i,1,m)\n\t{\n\t\tif(Bv[i][0]>Bv[i][1])++ans;\n\t\tif(Bv[i][0]<Bv[i][1])++q;\n\t}\n\tif(ans||!q)printf(\"NO\\n\");\n\telse printf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define show(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\nstruct Graph {\n    Graph(int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(int from, int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid dfs(int p, const Graph& g, vector<bool>& visited)\n{\n    visited[p] = true;\n    for (const int to : g.edge[p]) {\n        if (not visited[to]) {\n            dfs(to, g, visited);\n        }\n    }\n}\n\nint main()\n{\n    int N, H;\n    cin >> N >> H;\n\n    Graph g(2 * H + 1);\n    vector<int> dim(2 * H + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int l = 0;\n        if (c == 0) {\n            l = a;\n        } else {\n            l = -c;\n        }\n\n        int r = 0;\n        if (d == 0) {\n            r = b;\n        } else {\n            r = -d;\n        }\n\n        //        cout << l << \"->\" << -r << endl;\n        dim[l + H]++;\n        dim[-r + H]--;\n        g.addEdge(l + H, -r + H);\n    }\n\n    int num1 = 0;\n    int num2 = 0;\n    vector<bool> visited(2 * H + 1, false);\n    for (int i = 2 * H; i >= 0; i--) {\n        //        cout << i - H << \": \" << dim[i] << endl;\n        if (i - H > 0) {\n            if (dim[i] > 0) {\n                dfs(i, g, visited);\n                num1++;\n            } else if (dim[i] < 0) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (i - H < 0) {\n            if (dim[i] < 0) {\n                num2++;\n            } else if (dim[i] > 0) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    // if (num1 == num2 and num1 > 0) {\n    for (int i = 0; i < 2 * H + 1; i++) {\n        if ((not g.edge[i].empty()) and (not visited[i])) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n    // } else {\n    //     cout << \"NO\" << endl;\n    // }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing std::vector;\n\n#define MAXN 100005\n#define MAXH 405\nint indeg[MAXH],outdeg[MAXH];\nbool vis[MAXH];\nvector<int> G[MAXH];\n\nvoid add_edge(int u,int v)\n{\n    outdeg[u]++;indeg[v]++;\n    G[u].push_back(v);G[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    bool f=indeg[v]!=outdeg[v];\n    vis[v]=true;\n    for(auto to:G[v])\n    {\n        if(!vis[to]) \n            f|=dfs(to);\n    }\n    return f;\n}\n\nint main()\n{\n    int N,H;\n    int a[MAXN],b[MAXN],c[MAXN],d[MAXN];\n    scanf(\"%d%d\",&N,&H);\n    for(int i=1;i<=N;i++) \n    {\n        scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n        int l,r;\n        l= ( c[i]==0 ? a[i] : -c[i] );\n        r= ( d[i]==0 ? -b[i] : d[i] );\n        add_edge(l+H,r+H);\n    }\n\n    bool flag=true;\n    for(int i=0;flag && i<=H;i++) \n    {\n        if(outdeg[i]>indeg[i]) \n            flag=false;\n    }\n    for(int i=H+1;flag && i<=2*H;i++)\n    {\n        if(indeg[i]>outdeg[i]) \n             flag=false;\n    }\n\n    memset(vis,false,sizeof(vis));\n    for(int i=0;flag && i<=2*H;i++)\n    {\n        if((indeg[i]||outdeg[i])&&!vis[i]) \n            flag &=dfs(i);\n    }\n\n    if(flag) \n    {\n        printf(\"YES\\n\"); \n    }\n    else\n    { \n        printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define vi vector<int>\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define aa first\n#define bb second\n#define xx aa.aa\n#define yy aa.bb\n#define zz bb\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nint n,m,a,b,c,d,w[410],f[410],u[410];\ninline int fa(int i)\n{\n\treturn i==f[i]?i:f[i]=fa(f[i]);\n}\nint main()\n{\n\t//freopen(\"b102.txt\",\"r\",stdin);\n\t//freopen(\"x.out\",\"w\",stdout);\n\tint i,j,k,l;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=2*m;i++)\n\t  f[i]=i;\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t   if(c)\n\t     j=c+m;\n\t   else\n\t     j=a;\n\t   if(d)\n\t     k=d;\n\t   else\n\t     k=b+m;\n\t   w[j]++;\n\t   w[k]--;\n\t   f[fa(j)]=fa(k);\n\t   u[j]=u[k]=1;\n\t  }\n\tfor(l=1;l<=2*m;l++)\n\t{\n\tfor(i=1,j=k=0;i<=2*m;i++)\n\t  if(fa(i)==l)\n\t  if(w[i]>0)\n\t    if(i<=m)\n\t      j+=w[i];\n\t    else\n\t      break;\n\t  else if(w[i]<0)\n\t    if(i>m)\n\t      k+=-w[i];\n\t    else\n\t      break;\n\tif(i<=2*m || j!=k || !j)\n\t  {\n\t   printf(\"NO\\n\");\n\t   return 0;\n\t  }\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing std::vector;\n\n#define MAXN 100005\n#define MAXH 405\n#define INF 1000000000\n#define MOD 1000000007\nint indeg[MAXH],outdeg[MAXH];\nbool vis[MAXH];\nvector<int> G[MAXH];\n\nvoid add_edge(int u,int v)\n{\n    outdeg[u]++;indeg[v]++;\n    G[u].push_back(v);G[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    bool f=indeg[v]!=outdeg[v];\n    vis[v]=true;\n    for(auto to:G[v])\n\t{\n\t\tif(!vis[to]) \n\t\t\tf|=dfs(to);\n\t}\n    return f;\n}\n\nint main()\n{\n\tint N,H;\n\tint a[MAXN],b[MAXN],c[MAXN],d[MAXN];\n    scanf(\"%d%d\",&N,&H);\n    for(int i=1;i<=N;i++) \n    {\n        scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n        int l,r;\n\t\tl= ( c[i]==0 ? a[i] : -c[i] );\n        r= ( d[i]==0 ? -b[i] : d[i] );\n        add_edge(l+H,r+H);\n    }\n\n    bool flag=true;\n    for(int i=0;flag && i<=H;i++) \n\t{\n\t\tif(outdeg[i]>indeg[i]) \n\t\t\tflag=false;\n\t}\n    for(int i=H+1;flag && i<=2*H;i++)\n\t{\n\t\tif(indeg[i]>outdeg[i]) \n\t \t\tflag=false;\n\t}\n\n    memset(vis,false,sizeof(vis));\n    for(int i=0;flag && i<=2*H;i++)\n\t{\n\t\tif((indeg[i]||outdeg[i])&&!vis[i]) \n\t\t\tflag &=dfs(i);\n\t}\n\n    if(flag) \n\t{\n\t\tprintf(\"YES\\n\"); \n\t}\n\telse\n\t{ \n\t\tprintf(\"NO\\n\");\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntypedef int Weight;\nconst Weight INF=1<<29;\nstruct Edge{\n\tint src,dst;\n\tWeight weight,cap; // weight が辺のコストを表す\n\tint rev; // 逆辺の番号\n\tEdge(int src,int dst,Weight weight=0,Weight cap=0,int rev=-1):\n\tsrc(src),dst(dst),weight(weight),cap(cap),rev(rev)\n\t{}\n};\nstruct Node:public vector<Edge>{};\nbool operator<(const Edge &a,const Edge &b){\n\treturn a.weight<b.weight;\n}\nbool operator>(const Edge &a,const Edge &b){return b<a;}\ntypedef vector<Node> Graph;\ntypedef vector<vector<Weight> > Matrix;\n\n//src から dst へ向かう容量 cap,コストcost の辺をグラフに追加する\nvoid add_edge(Graph &G,int src,int dst,Weight cap,Weight cost){\n\tG[src].push_back(Edge(src,dst,cost,cap,G[dst].size()));\n\tG[dst].push_back(Edge(dst,src,-cost,0,G[src].size()-1));\n}\n\n// O(VE+FElogV)\nWeight min_cost_flow(Graph &G,int s,int t,Weight f){\n\ttypedef pair<Weight,int> P;\n\tWeight res=0;\n\tint V=G.size();\n\tvector<Weight> h(V,0);\n\tvector<int> prevv(V);\n\tvector<int> preve(V);\n\tif(s==t)return 0;\n\tbool start=true;\n\twhile(f>0){\n\t\tvector<Weight> dist(V,INF);\n\t\tif(start){\n\t\t\tbool update=true;\n\t\t\tdist[s]=0;\n\t\t\twhile(update){\n\t\t\t\tupdate=false;\n\t\t\t\trep(v,V){\n\t\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight){\n\t\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight;\n\t\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstart=0;\n\t\t}else{\n\t\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\t\tdist[s]=0;\n\t\t\tque.push(P(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.top();que.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<p.first)continue;\n\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight+h[v]-h[e.dst]){\n\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight+h[v]-h[e.dst];\n\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\tque.push(P(dist[e.dst],e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF){\n\t\t\treturn INF;\n\t\t}\n\t\tfor(int v=0;v<V;v++)h[v]+=dist[v];\n\t\tWeight d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tEdge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\nint cap[500];\n\nint MakeVertex(int a, int c, bool rev=false) {\n  if (c == 0) return a+rev*(H+1);\n  return c+(H+1)*!rev;\n}\n\nsigned main(){\n  cin >> N >> H;\n\n  int S = 0;\n  int l = S+1;\n  int T = l+2*(H+1);\n  int S2 = T+1;\n  int T2 = S2+1;\n  int gr = T2+1;\n  //graph g(T+1);\n  Graph g(gr+1);\n\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    \n    int u = MakeVertex(A[i], C[i]);\n    int v = MakeVertex(B[i], D[i], true);\n\n    cap[u]--;\n    cap[v]++;\n    add_edge(g, l+v, l+u, 1, 1);\n    //cout << l+v << \"->\" << l+u << endl;\n  }\n\n  reps(h, 1, H+1) {\n    int v = MakeVertex(h, 0);\n    add_edge(g, S, l+v, N+1, 0);\n    //cout << \"S=\" << S << \"->\" << l+v << endl;\n    int u = MakeVertex(0, h);\n    add_edge(g, l+u, T, N+1, 0);\n    //cout << l+u << \"->T=\" << T << endl;\n  }\n\n  reps(h, 1, H+1) {\n    int u = MakeVertex(0, h);\n    add_edge(g, l+u, gr, N+1, 0);\n    int v = MakeVertex(h, 0);\n    add_edge(g, gr, l+v, N+1, 0);\n  }\n\n  add_edge(g, S2, S, 1, 0);\n  add_edge(g, T, T2, 1, 0);\n  LL f = 1;\n  reps(i, l, T) {\n    int v = i - l;\n    if (cap[v] > 0) {\n      f += cap[v];\n      //cout << \"S2=\" << S2 << \"->\" << i << \": \" << cap[v] << endl;\n      add_edge(g, S2, i, cap[v], 0);\n    } else if (cap[v] < 0) {\n      //cout << i << \"->T2=\" << T2 << \": \" << -cap[v] << endl;\n\n      add_edge(g, i, T2, -cap[v], 0);\n    }\n  }\n  //cout << f << endl;\n\n  //LL a = g.max_flow(S2, T2, true);\n  //LL b = g.max_flow(S, T2);\n  //LL c = g.max_flow(S2, T);\n  LL d = min_cost_flow(g, S2, T2, f)-N;\n  //cout \n  //<< a << \",\" \n  //<< b << \",\"\n  //<< c << \",\"\n  //<< d << endl;\n\n  //if (a+b == a+c && a+b == N*2+2) {\n  if (d <= -N) {\n    //cout << d << \" \" << -N << endl;;\n    assert(d == -N);\n    cout << \"YES\" << endl;\n    return 0;\n  }\n  cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing std::vector;\n\n#define MAXN 100005\n#define MAXH 405\nint indeg[MAXH],outdeg[MAXH];\nbool vis[MAXH];\nvector<int> G[MAXH];\n\nvoid add_edge(int u,int v)\n{\n    outdeg[u]++;indeg[v]++;\n    G[u].push_back(v);G[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    bool f=indeg[v]!=outdeg[v];\n    vis[v]=true;\n    for(auto to:G[v])\n    {\n        if(!vis[to]) \n            f|=dfs(to);\n    }\n    return f;\n}\n\nint main()\n{\n    int N,H;\n    int a[MAXN],b[MAXN],c[MAXN],d[MAXN];\n    scanf(\"%d%d\",&N,&H);\n    for(int i=1;i<=N;i++) \n    {\n        scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n        int l,r;\n        l= ( c[i]==0 ? a[i] : -c[i] );\n        r= ( d[i]==0 ? -b[i] : d[i] );\n        add_edge(l+H,r+H);\n    }\n\n    bool flag=true;\n    for(int i=0;flag && i<=H;i++) \n    {\n        if(outdeg[i]>indeg[i]) \n            flag=false;\n    }\n    for(int i=H+1;flag && i<=2*H;i++)\n    {\n        if(indeg[i]>outdeg[i]) \n             flag=false;\n    }\n\n    memset(vis,false,sizeof(vis));\n    for(int i=0;flag && i<=2*H;i++)\n    {\n        if((indeg[i]||outdeg[i])&&!vis[i]) \n            flag &=dfs(i);\n    }\n\n    if(flag) \n    {\n        printf(\"YES\\n\"); \n    }\n    else\n    { \n        printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\nconst int maxh = 210;\n\nint n, h, e, f;\nint l[maxh<<1], in_deg[maxh<<1], out_deg[maxh<<1], vis[maxh<<1];\n\nstruct Edge {\n\tint v, x;\n} E[(maxn<<1)+(maxh<<2)];\n\ninline void addEdge(int u, int v) {\n\tE[e].v = v, E[e].x = l[u], l[u] = e++;\n}\n\nvoid dfs(int u) {\n\tvis[u] = 1;\n\tif (in_deg[u] != out_deg[u]) f = 1;\n\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\tint v = E[p].v;\n\t\tif (!vis[v]) dfs(v);\n\t}\n}\n\nint main() {\n\tmemset(l, -1, sizeof(l));\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint u, v;\n\t\tif (c) u = c+h;\n\t\telse u = a;\n\t\tif (d) v = d;\n\t\telse v = b+h;\n\t\taddEdge(u, v), addEdge(v, u);\n\t\t++ in_deg[v], ++ out_deg[u];\n\t}\n\tint ok = 1;\n\tfor (int i = 1; i <= h; i++) {\n\t\tif (in_deg[i] > out_deg[i]) ok = 0;\n\t\tif (in_deg[i+h] < out_deg[i+h]) ok = 0;\n\t}\n\tfor (int i = 1; i <= 2*h; i++) {\n\t\tif ((in_deg[i] || out_deg[i]) && !vis[i]) {\n\t\t\tf = 0;\n\t\t\tdfs(i);\n\t\t\tif (!f) ok = 0;\n\t\t}\n\t}\n\tif (ok) puts(\"YES\");\n\telse puts(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n   #define PP pair<int,pair<int,int>>\nconst int MAX = 510000;\nconst int MOD =  998244353;\nconst int INV2 = (MOD+1)/2;\n\n\n     signed main(){\n\n        int n,h;\n        map<int,int> mp[2];\n        cin>>n>>h;\n        int a,b,c,d;\n        for(int i=0;i<n;i++){\n          cin>>a>>b>>c>>d;\n          if(c==0)mp[0][a]++;\n          else mp[1][c]++;\n          if(d==0)mp[1][b]--;\n          else mp[0][d]--;\n        }\n        bool x=false;\n        for(auto i=mp[0].begin();i!=mp[0].end();i++){\n         //// cerr<<(i->second)<<' '<<(i->first)<<endl;\n          if((i->second)>0)x=true;\n          if((i->second)>=0)continue;\n         \n          \n          cout<<\"NO\"<<endl;\n          return 0;\n        }\n        for(auto i=mp[1].begin();i!=mp[1].end();i++){\n         // cerr<<(i->second)<<endl;\n          if((i->second)<0)x=true;\n\n          if((i->second)<=0)continue;\n         \n           \n          cout<<\"NO\"<<endl;\n          return 0;\n        }\n\n       if(x) cout<<\"YES\"<<endl;\n       else cout<<\"NO\"<<endl;\n        return 0;\n\n \n\n\n\n\n}\n\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h+b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\tif (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tRep1(i,h, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\tif (s != e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int> g[505];\nint l_cnt[505], r_cnt[505];\nbool used[505];\n\nint print(bool ok) {\n        if (ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n}\n\nbool dfs(int v) {\n        if (g[v].empty()) return true;\n        used[v] = true;\n        bool res = l_cnt[v] != r_cnt[v]; //端になりうる？\n        for (auto u : g[v]) if (!used[u]) res |= dfs(u); //パーツが足りる？\n        return res;\n}\n\nint main() {\n        int n, h, a, b, c, d;\n        cin >> n >> h;\n        for (int i = 0; i < n; i ++) {\n                cin >> a >> b >> c >> d;\n                int lh = (c == 0 ? a : c + 250);\n                int rh = (d == 0 ? b + 250 : d);\n                l_cnt[lh] ++;\n                r_cnt[rh] ++;\n                g[lh].push_back(rh);\n                g[rh].push_back(lh);\n//cerr << lh << ' ' << rh << endl;\n        }\n        for (int i = 0; i < h + 1; i ++) if (r_cnt[i] > l_cnt[i] || r_cnt[i] + 1 < l_cnt[i]) return print(0);\n        for (int i = 251; i < h + 251; i ++) if (l_cnt[i] > r_cnt[i] || l_cnt[i] + 1 < r_cnt[i]) return print(0);\n        for (int i = 0; i < 501; i ++) if (!used[i]) if (!dfs(i)) return print(0);\n        return print(1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAXN 100010\nusing namespace std;\nint N, H;\nstruct clip\n{\n\tint a;\n\tint b;\n\tint c;\n\tint d;\n\tbool flagA = false;\n\tbool flagB = false;\n\tbool flagC = false;\n\tbool flagD = false;\n}clip[MAXN];\nbool check() {\n\tbool flag = true;\n\tfor (int i = 0; i < N; i++) {\n\t\tif ((clip[i].flagC == false && clip[i].c!=0) || (clip[i].flagD == false && clip[i].d != 0)) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flag;\n}\nvoid process() {\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N ; j++) {\n\t\t\tif (j==i)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (clip[i].a == clip[j].d && clip[i].flagA==false) {\n\t\t\t\tclip[j].flagD = true;\n\t\t\t\tclip[i].flagA == true;\n\t\t\t}\n\t\t\tif (clip[i].b == clip[j].c && clip[i].flagB == false) {\n\t\t\t\tclip[j].flagC = true;\n\t\t\t\tclip[i].flagB == true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false);\n\tcin >> N>>H;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> clip[i].a >> clip[i].b >> clip[i].c >> clip[i].d;\n\t}\n\tprocess();\n\tif (check())\n\t\tcout << \"YES\" << endl;\n\telse\n\t{\n\t\tcout << \"NO\" << endl;\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<20;\nint fa[Q];\nint in[Q],out[Q];\nint gf(int x)\n{return fa[x]==x?x:(fa[x]=gf(fa[x]));}\nvoid ins(int x,int y)\n{\n    out[x]++;\n    in[y]++;\n    int fx=gf(x),fy=gf(y);\n    if(fx!=fy)fa[fx]=fy;\n}\n// int Idiot_Sap(int x,int flow)\n// {\n//     if(x==T)return flow;\n//     int had=0;\n//     for(int t=las[x];t;t=nn[t]){\n//         int y=e[t];\n//         if((!c[t])||dis[x]-1!=dis[y])continue;\n//         int del=Idiot_Sap(y,min(c[t],flow-had));\n//         c[t]-=del;\n//         c[t^1]+=del;\n//         had+=del;\n//         if(dis[S]>=T||had==flow)return had;\n//     }\n//     if(dis[S]>=T)return had;\n//     --cnt[dis[x]];\n//     if(!cnt[dis[x]])dis[S]=T;\n//     cnt[++dis[x]]++;\n//     return had;\n// }\nint had[Q];\nint main()\n{\n    int n,h;\n    cin>>n>>h;\n    for(int i=1,a,b,c,d;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        int x,y;\n        if(c==0)x=a+h;\n        else x=c;\n        if(d==0)y=b;\n        else y=d+h;\n        // printf(\"%d %d LINK\\n\",x,y);\n        ins(x,y);\n    }\n    for(int i=1;i<=h;i++)if(out[i]>in[i])return puts(\"NO\")&0;\n    for(int i=h+1;i<=h+h;i++)if(out[i]<in[i])return puts(\"NO\")&0;\n    for(int i=1;i<=h+h;i++)if((in[i]|out[i])&&in[i]!=out[i])had[gf(i)]=1,printf(\"%d OOOO\\n\",gf(i));\n    for(int i=1;i<=h+h;i++)if((in[i]|out[i])&&(!had[gf(i)]))\n        return puts(\"NO\")&0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nconst int maxnode=2000000+16;\n\nint n,h;\nvector<int> g[maxnode];\nbool v[maxnode];\nint d[maxnode];\nint q[maxnode];\nbool ww;\n\nvoid bfs(int p)\n{\n\tif (v[p]) return;\n\tv[p]=true;\n\tint sizeq=0;\n\tq[sizeq++]=p;\n\tREP(cl,sizeq)\n\t{\n\t\tint x=q[cl];\n\t\tfor (int y:g[x]) if (!v[y]) v[y]=true,q[sizeq++]=y;\n\t}\n}\nvoid dfs2(int p)\n{\n\tif (v[p]) return;\n\tv[p]=true;\n\tif (p>=h && d[p]>0) ww=true;\n\tfor (int x:g[p]) dfs2(x);\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\twhile (cin>>n>>h && n>0)\n\t{\n\t\th+=2;\n\t\tvector<ipair> edges;\n\t\tREP(i,n)\n\t\t{\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tint s=((c==0)?(a+h):c);\n\t\t\tint t=((d==0)?b:(d+h));\n\t\t\tedges.emplace_back(s,t);\n\t\t}\n\t\tbool ok=true;\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.first].push_back(e.second);\n\t\tFOR(i,h,h+h) bfs(i);\n\t\tfor (auto e:edges) if (!v[e.first]) ok=false;\n\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.second].push_back(e.first);\n\t\tREP(i,h) bfs(i);\n\t\tfor (auto e:edges) if (!v[e.second]) ok=false;\n\n\t\tREP(i,h+h) d[i]=0;\n\t\tfor (auto e:edges) ++d[e.first],--d[e.second];\n\t\tREP(i,h) if (d[i]>0) ok=false;\n\t\tFOR(i,h,h+h) if (d[i]<0) ok=false;\n\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.second].push_back(e.first);\n\t\tfor (auto e:edges) g[e.first].push_back(e.second);\n\t\tREP(i,h+h) if (!v[i] && SIZE(g[i])>0)\n\t\t{\n\t\t\tww=false;\n\t\t\tdfs2(i);\n\t\t\tif (!ww) ok=false;\n\t\t}\n\n\t\tif (ok)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\tfflush(stdout);\n#ifndef _MSC_VER\n\t\tbreak;\n#endif\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 500\nusing namespace std;\nint read(){\n    int nm=0,fh=1; int cw=getchar();\n    for(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n    for(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n    return nm*fh;\n}\nint n,m,e1,e2,h1,h2,cnt,in[M],ot[M],f[M]; bool vs[M];\nint fd(int x){return x==f[x]?x:f[x]=fd(f[x]);}\nint main(){\n    n=read(),m=read();\n    for(int i=1;i<=m;i++) f[i]=i,f[i+m]=i+m,vs[i]=vs[i+m]=false;\n    for(int i=1;i<=n;i++){\n        h1=read(),h2=read(),e1=read(),e2=read();\n        int t1=e1>0?e1:-h1,t2=e2>0?-e2:h2; t1+=m,t2+=m;\n        if(fd(t1)!=fd(t2)) f[fd(t1)]=fd(t2); in[t2]++,ot[t1]++;\n    }\n    for(int i=-m;i<0;i++) if(in[i+m]>ot[i+m]){puts(\"NO\");return 0;}\n    for(int i=1;i<=m;i++) if(in[i+m]<ot[i+m]){puts(\"NO\");return 0;}\n    for(int i=0;i<=m+m;i++) if(in[i]!=ot[i]) vs[fd(i)]=true;\n    for(int i=0;i<=m+m;i++) if(in[i]&&ot[i]&&!vs[fd(i)]){puts(\"NO\");return 0;}\n    puts(\"YES\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<20;\nint fa[Q];\nint in[Q],out[Q];\nint gf(int x)\n{return fa[x]==x?x:(fa[x]=gf(fa[x]));}\nvoid ins(int x,int y)\n{\n    out[x]++;\n    in[y]++;\n    int fx=gf(x),fy=gf(y);\n    if(fx!=fy)fa[fx]=fy;\n}\n// int Idiot_Sap(int x,int flow)\n// {\n//     if(x==T)return flow;\n//     int had=0;\n//     for(int t=las[x];t;t=nn[t]){\n//         int y=e[t];\n//         if((!c[t])||dis[x]-1!=dis[y])continue;\n//         int del=Idiot_Sap(y,min(c[t],flow-had));\n//         c[t]-=del;\n//         c[t^1]+=del;\n//         had+=del;\n//         if(dis[S]>=T||had==flow)return had;\n//     }\n//     if(dis[S]>=T)return had;\n//     --cnt[dis[x]];\n//     if(!cnt[dis[x]])dis[S]=T;\n//     cnt[++dis[x]]++;\n//     return had;\n// }\nint had[Q];\nint main()\n{\n    int n,h;\n    cin>>n>>h;\n    for(int i=1,a,b,c,d;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        int x,y;\n        if(c==0)x=a+h;\n        else x=c;\n        if(d==0)y=b;\n        else y=d+h;\n        // printf(\"%d %d LINK\\n\",x,y);\n        ins(x,y);\n    }\n    for(int i=1;i<=h;i++)if(out[i]>in[i])return puts(\"NO\")&0;\n    for(int i=h+1;i<=h+h;i++)if(out[i]<in[i])return puts(\"NO\")&0;\n    for(int i=1;i<=h+h;i++)if(in[i]!=out[i])had[gf(i)]=1;\n    for(int i=1;i<=h+h;i++)if(in[i]&&out[i]&&(!had[gf(i)]))return puts(\"NO\")&0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i, x, y) for (decay<decltype(y)>::type i = (x), _##i = (y); i < _##i; ++i)\n#define FORD(i, x, y) for (decay<decltype(x)>::type i = (x), _##i = (y); i > _##i; --i)\n#ifdef zerol\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\n// -----------------------------------------------------------------------------\n\nconst int N = 500, H = 220, INF = 1E9;\nint in[N], out[N];\n\nstruct E {\n    int to, cp;\n    E(int to, int cp): to(to), cp(cp) {}\n};\n\nstruct Dinic {\n    static const int M = 1E5 * 5;\n    int m, s, t;\n    vector<E> edges;\n    vector<int> G[M];\n    int d[M];\n    int cur[M];\n\n    void init(int n, int s, int t) {\n        this->s = s; this->t = t;\n        for (int i = 0; i <= n; i++) G[i].clear();\n        edges.clear(); m = 0;\n    }\n\n    void addedge(int u, int v, int cap) {\n        edges.emplace_back(v, cap);\n        edges.emplace_back(u, 0);\n        G[u].push_back(m++);\n        G[v].push_back(m++);\n    }\n\n    bool BFS() {\n        memset(d, 0, sizeof d);\n        queue<int> Q;\n        Q.push(s); d[s] = 1;\n        while (!Q.empty()) {\n            int x = Q.front(); Q.pop();\n            for (int& i: G[x]) {\n                E &e = edges[i];\n                if (!d[e.to] && e.cp > 0) {\n                    d[e.to] = d[x] + 1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return d[t];\n    }\n\n    int DFS(int u, int cp) {\n        if (u == t || !cp) return cp;\n        int tmp = cp, f;\n        for (int& i = cur[u]; i < G[u].size(); i++) {\n            E& e = edges[G[u][i]];\n            if (d[u] + 1 == d[e.to]) {\n                f = DFS(e.to, min(cp, e.cp));\n                e.cp -= f;\n                edges[G[u][i] ^ 1].cp += f;\n                cp -= f;\n                if (!cp) break;\n            }\n        }\n        return tmp - cp;\n    }\n\n    int go() {\n        int flow = 0;\n        while (BFS()) {\n            memset(cur, 0, sizeof cur);\n            flow += DFS(s, INF);\n        }\n        return flow;\n    }\n} DC;\n\nvoid add_edge(int u, int v) {\n    dbg(u, v);\n    out[u]++; in[v]++;\n    DC.addedge(u, v, 1);\n}\n\nint fa[N];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nvoid merge(int x, int y) {\n    int fx = find(x), fy = find(y);\n    if (fx != fy) fa[fx] = fy;\n}\n\nconst int S = N - 2, T = N - 1;\nbool check() {\n    int goal = 0;\n    FOR (i, 0, N) {\n        if (i < H && out[i] > in[i]) {\n            goal += out[i] - in[i];\n            DC.addedge(S, i, out[i] - in[i]);\n        }\n        else if (i >= H && in[i] > out[i]) DC.addedge(i, T, in[i] - out[i]);\n        else if (in[i] != out[i]) return false;\n    }\n    if (DC.go() != goal) return false;\n\n    iota(fa, fa + N, 0);\n    FOR (u, 0, N) {\n        for (int id: DC.G[u]) {\n            if (id % 2) continue;\n            int v = DC.edges[id].to;\n            merge(u, v);\n        }\n    }\n    FOR (i, 0, N)\n        if ((in[i] || out[i]) && find(i) != find(S))\n            return false;\n    return true;\n}\n\nint main() {\n    DC.init(N, S, T);\n    int n, h; cin >> n >> h;\n    while (n--) {\n        int a, b, c, d; cin >> a >> b >> c >> d;\n        int u, v;\n        dbg(a, b, c, d);\n        if (c == 0) u = a;\n        else u = c + H;\n        if (d == 0) v = b + H;\n        else v = d;\n        add_edge(u, v);\n    }\n    puts(check() ? \"YES\" : \"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <ctime>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <string>\n#include <climits>\n#include <set>\n#include <vector>\nusing namespace std;\ninline int read(){\n\tint k=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){k=k*10+ch-'0';ch=getchar();}\n\treturn k*f;\n}\nint n,m,fa[200010],du[200010],vis[200010],c[200010];\ninline int getfather(int x){return fa[x]==x?x:fa[x]=getfather(fa[x]);}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=1000;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint x=(c==0)?a:-c,y=(d==0)?-b:d;\n\t\tx+=500;y+=500;int fx=getfather(x),fy=getfather(y);\n\t\tfa[fx]=fy;vis[x]=1;du[x]++;du[y]--;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<500;i++)if(du[i]>0)flag=0;\n\tfor(int i=501;i<=1000;i++)if(du[i]<0)flag=0;\n\tfor(int i=1;i<=1000;i++){\n\t\tint fi=getfather(i);\n\t\tvis[fi]|=vis[i];\n\t\tif(du[i])c[fi]=1;\n\t}\n\tfor(int i=1;i<=1000;i++)if(fa[i]==i&&!c[i]&&vis[i])flag=0;\n\tputs(flag?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint read()\n{\n  int x=0,f=1;\n  char ch=getchar();\n  while((ch<'0')||(ch>'9'))\n    {\n      if(ch=='-')\n        {\n          f=-f;\n        }\n      ch=getchar();\n    }\n  while((ch>='0')&&(ch<='9'))\n    {\n      x=x*10+ch-'0';\n      ch=getchar();\n    }\n  return x*f;\n}\n\nconst int maxn=100000;\nconst int maxh=201;\nconst int maxv=401;\n\nnamespace dsu\n{\n  int fa[maxv+10];\n\n  int find(int x)\n  {\n    return fa[x]?(fa[x]=find(fa[x])):x;\n  }\n}\n\nint n,h,pre[maxn+10],now[maxv+10],son[maxn+10],tot,ru[maxv+10],chu[maxv+10],vis[maxn+10];\n\nint ins(int a,int b)\n{\n  pre[++tot]=now[a];\n  now[a]=tot;\n  son[tot]=b;\n  ++ru[b];\n  ++chu[a];\n  return 0;\n}\n\nint main()\n{\n  n=read();\n  h=read();\n  for(int i=1; i<=n; ++i)\n    {\n      int a=read(),b=read(),c=read(),d=read(),x,y;\n      if(c==0)\n        {\n          x=maxh+a;\n        }\n      else\n        {\n          x=maxh-c;\n        }\n      if(d==0)\n        {\n          y=maxh-b;\n        }\n      else\n        {\n          y=maxh+d;\n        }\n      ins(x,y);\n      int fx=dsu::find(x),fy=dsu::find(y);\n      if(fx!=fy)\n        {\n          dsu::fa[fx]=fy;\n        }\n    }\n  for(int i=1; i<=h; ++i)\n    {\n      if(ru[maxh+i]>chu[maxh+i])\n        {\n          puts(\"NO\");\n          return 0;\n        }\n    }\n  for(int i=1; i<=h; ++i)\n    {\n      if(chu[maxh-i]>ru[maxh-i])\n        {\n          puts(\"NO\");\n          return 0;\n        }\n    }\n  for(int i=1; i<=maxv; ++i)\n    {\n      if(((ru[i]==0)&&(chu[i]==0))||(ru[i]!=chu[i]))\n        {\n          vis[dsu::find(i)]=1;\n        }\n    }\n  int flag=0;\n  for(int i=1; i<=maxv; ++i)\n    {\n      if(!vis[dsu::find(i)])\n        {\n          flag=1;\n          break;\n        }\n    }\n  puts(flag?\"NO\":\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\nint h;\n\n#define MAXX 202\nint lef[MAXX];\nint rig[MAXX];\n\nint deg[MAXX*2];\n\nvector<int> v[MAXX*2];\n\nint belong[MAXX * 2];\ninline int root(int b){\n\tif (belong[b] == -1){\n\t\treturn b;\n\n\t}\n\tbelong[b] = root(belong[b]);\n\treturn belong[b];\n}\nvoid merge(int a, int b){\n\ta = root(a);\n\tb = root(b);\n\tif (a == b){\n\t\treturn;\n\t}\n\tbelong[a] = b;\n}\nmap<int, vector<int> > mp;\n\nbool ava[MAXX*2];\nbool flag[MAXX * 2];\n\nbool check(vector<int> vv){\n\tbool ng = false;\n\tint restr = 0;\n\tint restl = 0;\n\tint id = -1;\n\tint id2 = -1;\n\tbool ok = false;\n\tfor (int ii = 0; ii < vv.size(); ii++){\n\t\tok |= flag[vv[ii]];\n\t}\n\tif (ok == false){\n\t\treturn true;\n\t}\n\tfor (int ii = 0; ii <vv.size();ii++){\n\t\tint ix = vv[ii];\n\t\tif (ix & 1){\n\t\t\tint i = ix / 2;\n\t\t\tif (deg[rig[i]] >= 0){\n\t\t\t\trestr += deg[rig[i]];\n\t\t\t\tif (deg[rig[i]]){\n\t\t\t\t\tid = rig[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tng = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint i = ix / 2;\n\t\t\tif ( deg[lef[i]] <= 0){\n\t\t\t\trestl += -deg[lef[i]];\n\t\t\t\tif (deg[lef[i]] < 0){\n\t\t\t\t\tid2 = lef[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tng = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (restr == 0 || restl == 0){\n\t\treturn false;\n\t}\n\tif (ng){\n\t\treturn false;\n\t}\n\tif (restr == 1 && restl == 1 && v[id].size() == 1 && v[id2].size() == 1 && v[id][0] == v[id2][0]){\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main(){\n\tmemset(belong, -1, sizeof(belong));\n\tfor (int i = 0; i < MAXX; i++){\n\t\tlef[i] = 2 * i;\n\t\trig[i] = lef[i] + 1;\n\t}\n\tcin >> n >> h;\n\tfor (int i = 0; i < n; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint k;\n\t\tif (c){\n\t\t\tdeg[lef[c]]++;\n\t\t\tk = lef[c];\n\t\t\tava[lef[c]] = true;\n\t\t\tflag[lef[c]] = true;\n\t\t}\n\t\telse{\n\t\t\tdeg[rig[a]]++;\n\t\t\tv[rig[a]].push_back(i);\n\t\t\tk = rig[a];\n\t\t\tava[rig[a]] = true;\n\t\t}\n\t\tif (d){\n\t\t\tdeg[rig[d]]--;\n\t\t\tflag[rig[d]] = true;\n\t\t\tmerge(k, rig[d]);\n\t\t\tava[rig[d]] = true;\n\t\t}\n\t\telse{\n\t\t\tdeg[lef[b]]--;\n\t\t\tv[lef[b]].push_back(i);\n\t\t\tmerge(k, lef[b]);\n\t\t\tava[lef[b]] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAXX; i++){\n\t\tif(ava[i])mp[root(i)].push_back(i);\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); it++){\n\t\tif (check((*it).second) == false){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long  int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v])parent[u] = v;\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<vector<int>>uu(201, vector<int>(201));\n\tvector<vector<int>>us(201, vector<int>(201));\n\tvector<vector<int>>su(201, vector<int>(201));\n\tvector<vector<int>>ss(201, vector<int>(201));\n\tfor (int i = 0; i < N; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif (c&&d) {\n\t\t\tuu[c][d]++;\n\t\t}\n\t\telse if (c) {\n\t\t\tus[c][b]++;\n\t\t}\n\t\telse if (d) {\n\t\t\tsu[a][d]++;\n\t\t}\n\t\telse {\n\t\t\tss[a][b]++;\n\t\t}\n\t}\n\t//for (int i = 1; i <= 200; i++) {\n\t//\tus[i][i] = min(us[i][i], 1);\n\t//\tsu[i][i] = min(su[i][i], 1);\n\t//}\n\tvector<int>lu(201);\n\tvector<int>ld(201);\n\tvector<int>ru(201);\n\tvector<int>rd(201);\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tlu[i] += uu[i][j];\n\t\t\tlu[i] += us[i][j];\n\t\t\tld[i] += su[i][j];\n\t\t\tld[i] += ss[i][j];\n\t\t\tru[j] += uu[i][j];\n\t\t\tru[j] += su[i][j];\n\t\t\trd[j] += ss[i][j];\n\t\t\trd[j] += us[i][j];\n\t\t}\n\t\tld[i] -= su[i][i];\n\t\trd[i] -= us[i][i];\n\t}\n\tUnionFind uf(5000);\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tif (uu[i][j])uf.Unite(i, j);\n\t\t\tif (us[i][j])uf.Unite(i, j + 1000);\n\t\t\tif (su[i][j])uf.Unite(i + 1000, j);\n\t\t\tif (ss[i][j])uf.Unite(i + 1000, j + 1000);\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tif (ru[i] > ld[i]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tuf.Unite(2000, i + 1000);\n\t\tif (lu[i] > rd[i]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tuf.Unite(2000, i + 1000);\n\t}\n\tfor (int i = 0; i <= 200; i++) {\n\t\tif ((lu[i] || ru[i]) && !uf.Check_Same(i, 2000)) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif ((ld[i] || rd[i]) && !uf.Check_Same(i+1000, 2000)) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compiles and gets accepted.\n *  ___  __     _______    _______      \n * |\\  \\|\\  \\  |\\  ___ \\  |\\  ___ \\     \n * \\ \\  \\/  /|_\\ \\   __/| \\ \\   __/|    \n *  \\ \\   ___  \\\\ \\  \\_|/__\\ \\  \\_|/__  \n *   \\ \\  \\\\ \\  \\\\ \\  \\_|\\ \\\\ \\  \\_|\\ \\ \n *    \\ \\__\\\\ \\__\\\\ \\_______\\\\ \\_______\\\n *     \\|__| \\|__| \\|_______| \\|_______|\n */\nconst long long mod = 1000000007;\n\nint cntB0D[210];\nint cntD[210];\nint cpyCntD[210];\nint cpyCntB0D[210];\n\nstruct p {\n\tint A,B,C,D;\n\tbool operator<(p & o) {\n\t\treturn make_pair(C,A) < make_pair(o.C,o.A);\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint N,H;\n\tcin>>N>>H;\n\tvector<p> a(N);\n\tfor(int i = 0;i < N;i++) {\n\t\tcin>>a[i].A>>a[i].B>>a[i].C>>a[i].D;\n\t\tif(a[i].D == 0)\n\t\t\tcntB0D[a[i].B]++;\n\t\telse\n\t\t\tcntD[a[i].D]++;\n\t}\n\tfor(int i = 0;i <= 200;i++) cpyCntD[i] = cntD[i],cpyCntB0D[i] = cntB0D[i];\n\tsort(a.begin(),a.end());\n\tbool can = false;\n\tfor(int st = 0;st < N;st++) {\n\t\tif(a[st].C > 0) break;\n\t\tif(st && a[st].A == a[st-1].A) continue;\n\t\tbool cur = true;\n\t\tfor(int i = 0;i < N;i++) {\n\t\t\tif(i == st) continue;\n\t\t\tif(a[i].C == 0) {\n\t\t\t\tcur &= cntD[a[i].A] > 0 && (a[i].D != a[i].A || cntD[a[i].A] > 1);\n\t\t\t} else {\n\t\t\t\tcur &= cntB0D[a[i].C] > 0 && (a[i].B != a[i].C || a[i].D != 0 || cntB0D[a[i].C] > 1);\n\t\t\t}\n\t\t}\n\t\tif(!cur) continue;\n\t\tfor(int i = 0;i <= 200;i++) cntD[i] = cpyCntD[i],cntB0D[i] = cpyCntB0D[i];\n\t\tfor(int i = 0;i < N;) {\n\t\t\tint j = i;\n\t\t\twhile(j < N && !(a[i] < a[j]) && !(a[j] < a[i])) j++;\n\t\t\tif(a[i].C == 0 && a[i].A == a[st].A) i++;\n\t\t\tif(i == j) continue;\n\t\t\tif(a[i].C == 0) {\n\t\t\t\tcntD[a[i].A] -= (j-i);\n\t\t\t\tcur &= cntD[a[i].A] >= 0;\n\t\t\t} else {\n\t\t\t\tcntB0D[a[i].C] -= (j-i);\n\t\t\t\tcur &= cntB0D[a[i].C] >= 0;\n\t\t\t}\n\t\t\ti = j;\n\t\t}\n\t\tbool f = false;\n\t\tfor(int i = 0;i < N;i++) {\n\t\t\tif(i == st) continue;\n\t\t\tif(a[i].C) {\n\t\t\t\tf |= a[st].D == a[i].A;\n\t\t\t} else {\n\t\t\t\tf |= a[st].D == 0 && a[st].B == a[i].C;\n\t\t\t}\n\t\t}\n\t\tcur &= f;\n\t\tf = false;\n\t\tfor(int i = 0;i <= 200;i++) can |= cntB0D[i] > 0;\n\t\tcur &= f;\n\t\tcan |= cur;\n\t}\n\tcout<<(can?\"YES\\n\":\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define iter(i, n) for (int i = 1; i <= n; ++i)\n\n#define PR 510\n\nvector<int> e[PR];\nbool invalid, vis[PR], start;\nint sum, deg[PR], n, h;\n\nvoid dfs(int x) {\n\tvis[x] = true;\n\tsum += deg[x];\n\tif (deg[x] != 0) {\n\t\tstart = true;\n\t\tif ((deg[x] > 0) != (x <= h)) invalid = true;\n\t}\n\tfor (int v : e[x]) if (!vis[v]) dfs(v);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &h);\n\titer(i, 2 * h) vis[i] = true;\n\titer(i, n) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint u = c == 0 ? a : c + h;\n\t\tint v = d == 0 ? b + h : d;\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t\t//printf(\"%d->%d\\n\", u, v);\n\t\t++deg[u], --deg[v]; vis[u] = vis[v] = false;\n\t}\n\n\t//iter(i, 2 * h) printf(\"%d \", deg[i]);\n\n\titer(i, 2 * h) if (!vis[i]) {\n\t\tstart = false; dfs(i);\n\t\tif (sum != 0 || !start) invalid = true;\n\t}\n\n\tputs(invalid ? \"NO\" : \"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 101000\n#define M 510\nusing namespace std;\nint last[M],nxt[N],n,m,to[N],rd[M],cd[M],tot=0,bz[M];\nvoid link(int x,int y)\n{\n\tnxt[++tot]=last[x];last[x]=tot;to[tot]=y;\n\trd[y]++;cd[x]++;\n}\nvoid dg(int x)\n{\n\tif(bz[x]==1) return;bz[x]=1;\n\tfor(int i=last[x];i;i=nxt[i]) dg(to[i]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n)\n\t{\n\t\tint a,b,c,d,x,y;scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0) x=a+m;\n\t\telse x=c;\n\t\tif(d==0) y=b;\n\t\telse y=d+m;\n\t\tlink(x,y);\n\t}\n\tint q=0,w=0;\n\tfo(i,1,m)\n\t{\n\t\tif(rd[i]<cd[i]) q++;\n\t\tif(rd[i]>cd[i]) w++;\n\t}\n\tif(q>0||w==0) return printf(\"NO\\n\"),0;\n\tq=0,w=0;\n\tfo(i,m+1,m+m)\n\t{\n\t\tif(rd[i]>cd[i]) q++;\n\t\tif(rd[i]<cd[i]) w++;\n\t}\n\tif(q>0||w==0) return printf(\"NO\\n\"),0;\n\tq=0,w=0;\n\tfo(i,1,m) if(rd[i]>cd[i]) w++;\n\tfo(i,m+1,m+m) if(rd[i]<cd[i]) q++;\n\tif(q!=w) return printf(\"NO\\n\"),0;\n\tfo(i,m+1,m+m) if(rd[i]<cd[i]&&!bz[i]) dg(i);\n\tfo(i,1,m) if((rd[i]>0||cd[i]>0)&&bz[i]==0) return printf(\"NO\\n\"),0;\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst llint mod=1000000007;\nconst llint big=1e17-10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint main(void){\n\tint n,h,i,j;cin>>n>>h;\n\tint Lsit[210]={0};//左が下にくっついている\n\tint Rsit[210]={0};//右が\n\tfor(i=0;i<n;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tif(c==0){Lsit[a]++;}else{Rsit[c]--;}\n\t\tif(d==0){Rsit[b]++;}else{Lsit[d]--;}\n\t}\n\tint gen=0;\n\tfor(i=1;i<210;i++){gen+=Rsit[i];if(Rsit[i]<0){cout<<\"NO\"<<endl;return 0;}}\n\tif(gen==0){cout<<\"NO\"<<endl;return 0;}\n\tgen=0;\n\tfor(i=1;i<210;i++){gen+=Lsit[i];if(Lsit[i]<0){cout<<\"NO\"<<endl;return 0;}}\n\tif(gen==0){cout<<\"NO\"<<endl;return 0;}\n\tcout<<\"YES\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ldouble;\ntypedef pair<double, double> pdd;\n\nint n, h;\nint X[100010], Y[100010];\n\nint get(int a, int c) {\n\tif(c == 0) return a;\n\telse return h + c;\n}\n\nint flip(int x){return x > h ? x - h : x + h; }\n\nint p[110000], z[440], z2[440];\nint cnt[420];\nint Find(int x){return p[x] == x ? x : p[x] = Find(p[x]); }\n\nvoid add(int x, int y) {\n\tx = Find(x), y = Find(y);\n\tif(x != y) p[x] = y, z2[y] += z2[x] + 1;\n\telse z2[x]++;\n}\n\nvoid solve(){\n\tscanf(\"%d%d\", &n, &h);\n\tfor(int i=1;i<=n+h+h;i++) p[i] = i;\n\tfor(int i=1;i<=n;i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x = get(a, c);\n\t\tint y = get(b, d); y = flip(y);\n\t\tcnt[x]++; cnt[y]--;\n\t\tadd(x, y);\n\t}\n\tfor(int i=1;i<=h+h;i++) z[Find(i)] += abs(cnt[i]);\n\tfor(int i=1;i<=h+h;i++) if(Find(i) == i && z[i] == 0 & z2[i] > 0) { puts(\"NO\"); return; }\n\tfor(int i=1;i<=h;i++) if(cnt[i] < 0) { puts(\"NO\"); return; }\n\tfor(int i=1;i<=h;i++) if(cnt[h+i] > 0) { puts(\"NO\"); return; }\n\tputs(\"YES\");\n}\n\nint main(){\n\tint Tc = 1; // scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\t// printf(\"Case #%d: \", tc);\n\t\tsolve();\n\t}\n\treturn 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=205;\nint fa[N<<1],in[N<<1],out[N<<1];\nint n,h;\nbool ans[N<<1];\nvoid red(int &x){\n\tchar c;\n\tfor(c=getchar();c<'0'|c>'9';c=getchar());\n\tfor(x=0;'0'<=c&c<='9';c=getchar())x=x*10+c-'0';\n}\nint get(int x){\n\treturn fa[x]==x?x:fa[x]=get(fa[x]);\n}\nint main(){\n\tint a,b,c,d,x,y;\n\tred(n);red(h);\n\tfor(int i=1;i<=2*h;++i)fa[i]=i;\n\tfor(int i=1;i<=n;++i){\n\t\tred(a);red(b);red(c);red(d);\n\t\tx=c?c+h:a;y=d?d:b+h;\n\t\t++in[x];++out[y];\n\t\tif(get(x)!=get(y))fa[x]=get(y);\n\t}\n\tfor(int i=1;i<=h;++i)\n\t\tif(in[i]<out[i]){\n\t\t\tprintf(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(int i=h+1;i<=2*h;++i)\n\t\tif(out[i]<in[i]){\n\t\t\tprintf(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(int i=1;i<=2*h;++i)\n\t\tif(in[i]==out[i]&&in[i]&&out[i])\n\t\t\tans[i]=true;\n\tfor(int i=1;i<=2*h;++i)\n\t\tif(fa[i]==i&&ans[i]){\n\t\t\tprintf(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 250005;\nconst int MAXM = 3000005;\n\nnamespace Flow\n{\n\tconst int INF = 0x3f3f3f3f;\n\n\tstruct Edge { int p, v, w; } e[MAXM];\n\tint dis[MAXN], hed[MAXN], cur[MAXN], q[MAXN], ql, qr, e_cnt = 1, tot, S, T;\n\n\tinline void Add(int x, int y, int w) { e[++ e_cnt] = {y, hed[x], w}; hed[x] = e_cnt; }\n\tinline void Addedge(int x, int y, int w) { Add(x, y, w); Add(y, x, 0); }\n\n\tinline bool Bfs()\n\t{\n\t\tfor (int i = 0; i <= tot; i ++)\n\t\t\tdis[i] = 0;\n\t\tdis[q[ql = 0] = S] = qr = 1;\n\t\twhile (ql ^ qr)\n\t\t{\n\t\t\tint x = q[++ ql];\n\t\t\tfor (int i = hed[x]; i; i = e[i].v)\n\t\t\t\tif (e[i].w && !dis[e[i].p])\n\t\t\t\t\tdis[q[++ qr] = e[i].p] = dis[x] + 1;\n\t\t}\n\t\treturn dis[T];\n\t}\n\n\tinline int Dfs(int x, int f)\n\t{\n\t\tif (x == T)\n\t\t\treturn f;\n\t\tint ret = 0, d;\n\t\tfor (int &i = cur[x]; i; i = e[i].v)\n\t\t\tif (e[i].w && dis[e[i].p] == dis[x] + 1)\n\t\t\t{\n\t\t\t\td = Dfs(e[i].p, min(f - ret, e[i].w));\n\t\t\t\te[i].w -= d; e[i ^ 1].w += d; ret += d;\n\t\t\t\tif (ret == f)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\tdis[x] = -1;\n\t\treturn ret;\n\t}\n\n\tinline int Dinic()\n\t{\n\t\tint ret = 0;\n\t\twhile (Bfs())\n\t\t{\n\t\t\tfor (int i = 0; i <= tot; i ++)\n\t\t\t\tcur[i] = hed[i];\n\t\t\tret += Dfs(S, INF);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nusing namespace Flow;\nint n, h, a[MAXN], b[MAXN], c[MAXN], d[MAXN];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), h = Read();\n\tfor (int i = 1; i <= n; i ++)\n\t\ta[i] = Read(), b[i] = Read(), c[i] = Read(), d[i] = Read();\n\tS = 0, T = tot = n << 1 | 1;\n\tint SS = ++ tot, TT = ++ tot;\n\tAddedge(S, SS, 1); Addedge(TT, T, 1);\n\tfor (int i = 1; i <= n; i ++)\n\t\tAddedge(S, i, 1), Addedge(i + n, T, 1);\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tif (!c[i])\n\t\t\tAddedge(i, tot + a[i], 1);\n\t\tAddedge(i, tot + h + c[i], 1);\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tif (!d[i])\n\t\t\tAddedge(tot + h + b[i], i + n, 1);\n\t\tAddedge(tot + d[i], i + n, 1);\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (!c[i])\n\t\t\tAddedge(i, TT, 1);\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (!d[i])\n\t\t\tAddedge(SS, i + n, 1);\n\ttot += h << 1;\n\tif (Dinic() == n + 1)\n\t\tputs(\"YES\");\n\telse\n\t\tputs(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nvector <pii> I[101010], O[101010];\nbool chk[222];\nint n, h;\n\nint dfs(int p)\n{\n\tint ret = O[p].size();\n\t\n\tchk[p] = 1;\n\t\n\tfor(pii t: O[p]){\n\t\tif(!chk[t.first]){\n\t\t\tret += dfs(t.first);\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tint i, a, b, c, d, s1, s2, t1, t2, f, f1, f2;\n\tscanf(\"%d%d\", &n, &h);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\n\t\tf = 0;\n\t\tif(c) a = c;\n\t\telse f |= 1;\n\t\tif(d) b = d;\n\t\telse f |= 2;\n\t\t\n\t\tI[b].push_back(pii(a, f));\n\t\tO[a].push_back(pii(b, f));\n\t}\n\t\n\tif(n == 1){\n\t\tif(f == 3) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t\t\n\t\treturn 0;\n\t}\n\t\n\ts1 = s2 = 0;\n\t\n\tfor(i=1;i<h;i++){\n\t\tif(I[i].size() + 1 == O[i].size()) s1 ++, t1 = i;\n\t\telse if(I[i].size() == O[i].size() + 1) s2 ++, t2 = i;\n\t\telse if(I[i].size() != O[i].size()){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<h;i++) chk[i] = 0;\n\t\n\tif(s1 == 0 && s2 == 0 && dfs(1) == n){\n\t\tfor(i=1;i<h;i++){\n\t\t\tf1 = f2 = 0;\n\t\t\tfor(pii j: O[i]) if(j.second & 1) f1 ++;\n\t\t\tfor(pii j: I[i]) if(j.second & 2) f2 ++;\n\t\t\tif(f1 && f2){\n\t\t\t\tif(f1 > 1 || f2 > 1){\n\t\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if(f1 == 1 && f2 == 1){\n\t\t\t\t\tfor(pii j: O[i]){\n\t\t\t\t\t\tif(j.second == 3 && j.first == i){\n\t\t\t\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=1;i<h;i++) chk[i] = 0;\n\t\n\tif(s1 == 1 && s2 == 1 && dfs(t1) == n){\n\t\tf1 = f2 = 0;\n\t\tfor(pii j: O[t1]) if(j.second & 1) f1 ++;\n\t\tfor(pii j: I[t2]) if(j.second & 2) f2 ++;\n\t\tif(f1 && f2){\n\t\t\tif(f1 > 1 || f2 > 1){\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if(f1 == 1 && f2 == 1){\n\t\t\t\tfor(pii j: O[t1]){\n\t\t\t\t\tif(j.second == 3 && j.first == t2){\n\t\t\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"NO\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 100100;\n\nconst int maxH = 210;\n\nint n, H;\n\nint fa[maxH + 5];\n\nint deg[maxH + 5];\n\nbool vis[maxH + 5];\n\nint get(int x) { return fa[x] == x ? x : fa[x] = get(fa[x]); }\n\ninline void adde(int C, int D)\n{\n\tvis[C] = vis[D] = 1;\n\t++deg[C];\n\t--deg[D];\n\tfa[get(C)] = get(D);\n}\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d%d\", &n, &H);\n\t++H;\n\tREP(i, 0, H << 1) fa[i] = i;\n\tREP(i, 0, n)\n\t{\n\t\tint A, B, C, D;\n\t\tscanf(\"%d%d%d%d\", &A, &B, &C, &D);\n\t\tint x = -1, y = -1;\n\t\tif (!C) x = A << 1;\n\t\telse x = C << 1 | 1;\n\t\tif (!D) y = B << 1 | 1;\n\t\telse y = D << 1; \n\t\tadde(x, y);\n\t}\n\tbool failed = 0;\n\tREP(i, 0, H << 1) if (vis[i])\n\t{\n\t\tbool flag0 = 0, flag1 = 0;\n\t\tint sum = 0;\n\t\tREP(j, 0, H << 1) if (get(j) == get(i))\n\t\t{\n\t\t\tsum += deg[j];\n\t\t\tif (j & 1) flag0 = 1;\n\t\t\telse flag1 = 1;\n\t\t\tif (deg[j] > 0)\n\t\t\t{\n\t\t\t\tif (j & 1) { failed = 1; break; }\n\t\t\t}\n\t\t\tif (deg[j] < 0)\n\t\t\t{\n\t\t\t\tif (!(j & 1)) { failed = 1; break; }\n\t\t\t}\n\t\t}\n\t\tif (!flag0 || !flag1 || sum) { failed = 1; break; }\n\t}\n\tputs(failed ? \"NO\" : \"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint deg[1234];\n\nint edges[1234][1234];\n\nvoid dfs(int v, int n) {\n  int cur = 0;\n  while (true) {\n    while (cur <= n && edges[v][cur] == 0) ++cur;\n    if (cur > n) break;\n    --edges[v][cur];\n    dfs(cur, n);\n  }\n}\n\nint main() {\n  int n, h;\n  scanf(\"%d%d\", &n, &h);\n  for (int i = 0; i < n; i++) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    int from = c == 0 ? a : (c + 2 * h);\n    int to = d == 0 ? (b + 2 * h) : d;\n    deg[from]--;\n    deg[to]++;\n    edges[from][to]++;\n  }\n  for (int i = 0; i < 4 * h; i++) {\n    if (deg[i] != 0) {\n      if ((deg[i] < 0 && i >= 2 * h) || (deg[i] > 0 && i < 2 * h)) {\n        puts(\"NO\");\n        return 0;\n      }\n      if (deg[i] < 0) {\n        edges[4 * h][i] = -deg[i];\n      } else {\n        edges[i][4 * h] = deg[i];\n      }\n    }\n  }\n  dfs(4 * h, 4 * h);\n  for (int i = 0; i <= 4 * h; i++) {\n    for (int j = 0; j <= 4 * h; j++) {\n      if (edges[i][j] != 0) {\n        puts(\"NO\");\n        return 0;\n      }\n    }\n  }\n  puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nint read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=405;\nint n,m=401;\nint fa[N],in[N],out[N],cnt[N],f[N];\nint _(int k){\n\tif (k<0)\n\t\treturn 401+k;\n\telse\n\t\treturn k;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nint main(){\n\tfor (int i=1;i<=m;i++)\n\t\tfa[i]=i;\n\tn=read();\n\tread();\n\twhile (n--){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint x=c>0?-c:a;\n\t\tint y=d>0?d:-b;\n\t\tx=_(x),y=_(y);\n\t\tfa[getf(x)]=getf(y);\n\t\tin[y]++,out[x]++;\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tif (!in[i]&&!out[i])\n\t\t\tcontinue;\n\t\tcnt[getf(i)]++;\n\t\tif (in[i]!=out[i])\n\t\t\tf[getf(i)]=1;\n\t}\n\tfor (int i=1;i<=m;i++)\n\t\tif (cnt[i]&&!f[i])\n\t\t\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ninline int getint()\n{\n\tstatic char c;\n\twhile ((c = getchar()) < '0' || c > '9');\n\n\tint res = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxN = 100000;\nconst int MaxM = 200;\nconst int MaxNV = MaxM * 2;\n\nint n, m;\nint in[MaxNV + 1], out[MaxNV + 1];\n\nint ufs[MaxNV + 1];\n\nint ufs_find(int v)\n{\n\treturn ufs[v] == v ? v : ufs[v] = ufs_find(ufs[v]);\n}\n\nint main()\n{\n\tcin >> n >> m;\n\n\tfor (int u = 1; u <= m + m; ++u)\n\t\tufs[u] = u;\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint a = getint(), b = getint();\n\t\tint c = getint(), d = getint();\n\n\t\tint u = c ? c + m : a;\n\t\tint v = d ? d : m + b;\n\n\t\t++out[u], ++in[v];\n\n\t\tufs[ufs_find(v)] = ufs_find(u);\n\t}\n\n\tbool ok = true;\n\n\tfor (int u = 1; u <= m; ++u)\n\t\tif (out[u] < in[u])\n\t\t\tok = false;\n\n\tfor (int v = 1; v <= m; ++v)\n\t\tif (out[v + m] > in[v + m])\n\t\t\tok = false;\n\n\tfor (int u = 1; u <= m + m; ++u)\n\t\tif (ufs[u] == u && (in[u] || out[u]))\n\t\t{\n\t\t\tbool all = true;\n\t\t\tfor (int v = 1; v <= m + m; ++v)\n\t\t\t\tif (ufs_find(v) == u)\n\t\t\t\t\tall &= in[v] == out[v];\n\n\t\t\tif (all)\n\t\t\t\tok = false;\n\t\t}\n\n\tputs(ok ? \"YES\" : \"NO\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long  int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<vector<int>>uu(201, vector<int>(201));\n\tvector<vector<int>>us(201, vector<int>(201));\n\tvector<vector<int>>su(201, vector<int>(201));\n\tvector<vector<int>>ss(201, vector<int>(201));\n\tfor (int i = 0; i < N; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif (c&&d) {\n\t\t\tuu[c][d]++;\n\t\t}\n\t\telse if (c) {\n\t\t\tus[c][b]++;\n\t\t}\n\t\telse if (d) {\n\t\t\tsu[a][d]++;\n\t\t}\n\t\telse {\n\t\t\tss[a][b]++;\n\t\t}\n\t}\n\t//for (int i = 1; i <= 200; i++) {\n\t//\tus[i][i] = min(us[i][i], 1);\n\t//\tsu[i][i] = min(su[i][i], 1);\n\t//}\n\tvector<int>lu(201);\n\tvector<int>ld(201);\n\tvector<int>ru(201);\n\tvector<int>rd(201);\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tlu[i] += uu[i][j];\n\t\t\tlu[i] += us[i][j];\n\t\t\tld[i] += su[i][j];\n\t\t\tld[i] += ss[i][j];\n\t\t\tru[j] += uu[i][j];\n\t\t\tru[j] += su[i][j];\n\t\t\trd[j] += ss[i][j];\n\t\t\trd[j] += us[i][j];\n\t\t}\n\t\tld[i] -= su[i][i];\n\t\trd[i] -= us[i][i];\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\t//cout << i << \" \" << lu[i] << \" \" << ld[i] << \" \" << ru[i] << \" \" << rd[i] << endl;\n\t\tif (lu[i] > rd[i] || ld[i] < ru[i]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tbool flag = false;\n\t\tfor (int j = 0; j <= 200; j++) {\n\t\t\tif (ss[j][i])flag = true;\n\t\t}\n\t\tif (lu[i] == rd[i]&&lu[i] && !flag) {\n\t\t\t//cout << i << endl;\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tflag = false;\n\t\tfor (int j = 0; j <= 200; j++) {\n\t\t\tif (ss[i][j])flag = true;\n\t\t}\n\t\tif (ru[i] == ld[i] &&ru[i]&& !flag) {\n\t\t//\tcout << i << endl;\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<20;\nint fa[Q];\nint in[Q],out[Q];\nint gf(int x)\n{return fa[x]==x?x:(fa[x]=gf(fa[x]));}\nvoid ins(int x,int y)\n{\n    out[x]++;\n    in[y]++;\n    int fx=gf(x),fy=gf(y);\n    if(fx!=fy)fa[fx]=fy;\n}\n// int Idiot_Sap(int x,int flow)\n// {\n//     if(x==T)return flow;\n//     int had=0;\n//     for(int t=las[x];t;t=nn[t]){\n//         int y=e[t];\n//         if((!c[t])||dis[x]-1!=dis[y])continue;\n//         int del=Idiot_Sap(y,min(c[t],flow-had));\n//         c[t]-=del;\n//         c[t^1]+=del;\n//         had+=del;\n//         if(dis[S]>=T||had==flow)return had;\n//     }\n//     if(dis[S]>=T)return had;\n//     --cnt[dis[x]];\n//     if(!cnt[dis[x]])dis[S]=T;\n//     cnt[++dis[x]]++;\n//     return had;\n// }\nint had[Q];\nint main()\n{\n    int n,h;\n    cin>>n>>h;\n    for(int i=1,a,b,c,d;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        int x,y;\n        if(c==0)x=a+h;\n        else x=c;\n        if(d==0)y=b;\n        else y=d+h;\n        // printf(\"%d %d LINK\\n\",x,y);\n        ins(x,y);\n    }\n    for(int i=1;i<=h;i++)if(out[i]>in[i])return puts(\"NO\")&0;\n    for(int i=h+1;i<=h+h;i++)if(out[i]<in[i])return puts(\"NO\")&0;\n    for(int i=1;i<=h+h;i++)if((in[i]|out[i])&&in[i]!=out[i])had[gf(i)]=1;\n    for(int i=1;i<=h+h;i++)if((in[i]|out[i])&&(!had[gf(i)]))return puts(\"NO\")&0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<map>\n#include<utility>\nusing namespace std;\nconst int MAXN = 1e5+10;\nbool vis[MAXN], ok=false;\nint N, H, A[MAXN], B[MAXN], C[MAXN], D[MAXN];\nvector<int> st;  //可以作为开始块 \nmap<pair<int,int>, vector<int> > Map;\n\nint read() {\n\tint num=0;\n\tchar c=getchar();\n\twhile(c<'0' || c>'9') c=getchar();\n\twhile(c>='0' && c<='9') num=(num<<3)+(num<<1)+(48^c), c=getchar();\n\treturn num;\n}\n\nvoid dfs(int cur, int cnt) {\n\tif(ok) return;\n\t//cout<<\"访问序列:\"<<cnt<<\"  \"<<cur<<endl;\n\tif(cnt==N &&D[cur]==0) {\n\t\tok=true; return;\n\t}\n\tvis[cur]=true;\n\tint i;\n\tif(D[cur]==0) {  //做底 \n\t\tvector<int> V = Map[make_pair(B[cur], D[cur])];\n\t\tfor(i=0;i<V.size();i++) {\n\t\t\tif(vis[V[i]]) continue;\n\t\t\tvis[V[i]] = true;\n\t\t\tdfs(V[i], cnt+1);\n\t\t\tvis[V[i]] = false;\n\t\t}\n\t}\n\telse {\n\t\tvector<int> V = Map[make_pair(-1, D[cur])];\n\t\t//cout<<V.size()<<endl;\n\t\tfor(i=0;i<V.size();i++) {\n\t\t\tif(vis[V[i]]) continue;\n\t\t\tvis[V[i]] = true;\n\t\t\tdfs(V[i], cnt+1);\n\t\t\tvis[V[i]] = false;\n\t\t}\n\t}\n\tvis[cur]=false;\n}\n\nint main()\n{\n\tN=read(), H=read();\n\tint i;\n\tfor(i=1;i<=N;i++) {\n\t\tA[i]=read(),B[i]=read(),C[i]=read(),D[i]=read();\n\t\tif(C[i]==0) st.push_back(i);  //作为起始块 \n\t\tif(C[i]==0) {  //左边可以作为底 \n\t\t\tMap[make_pair(-1, A[i])].push_back(i); //-1代表任何值 \n\t\t}\n\t\telse {  //左边不能做底 \n\t\t\tMap[make_pair(C[i], 0)].push_back(i);\n\t\t}\n\t}\n\tfor(i=0;i<st.size();i++) {\n\t\tif(ok) break;\n\t\tdfs(st[i], 1);\n\t}\n\tif(ok) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, H;\nint A[100000];\nint B[100000];\nint C[100000];\nint D[100000];\nint deg[100000];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> H;\n  const int V = 2*H+1;\n  int g = 0;\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    if (C[i]==0&&D[i]==0) g++;\n    if (C[i]>0&&D[i]>0) g--;\n    int u = ((C[i]==0)? +A[i] : -C[i]);\n    int v = ((D[i]==0)? -B[i] : +D[i]);\n    u += H;\n    v += H;\n    deg[u]++;\n    deg[v]--;\n  }\n  if (g <= 0) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  //rep(i, V) cout<<deg[i]<<\",\";cout<<\"\\n\";\n  int s = 0;\n  rep(i, V) if (deg[i] > 0) {\n    if (i-H <= 0) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    s += deg[i];\n  }\n  if (s <= g) {\n    cout << \"YES\\n\";\n  }\n  else {\n    cout << \"NO\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nint n,h;\nint l[220],r[220],fa[420],siz[420],L,R;\nint find(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=400;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0)l[a]++,L=a;\n\t\telse r[c]--,L=c+200;\n\t\tif(d==0)r[b]++,R=b+200;\n\t\telse l[d]--,R=d;\n\t\tif(find(L)==find(R)){\n\t\t\tsiz[find(L)]++;\n\t\t\tcontinue;\n\t\t}\n\t\tsiz[find(R)]+=siz[find(L)]+1;\n\t\tsiz[find(L)]=0;\n\t\tfa[find(L)]=find(R);\n\t}\n\tint ans=0,cns=0;\n\tfor(int i=1;i<=200;i++){\n\t\tif(l[i]<0||r[i]<0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(l[i])ans+=siz[find(i)],siz[find(i)]=0;\n\t\tif(r[i])ans+=siz[find(i+200)],siz[find(i+200)]=0;\n\t}\n\tif(ans!=n)printf(\"NO\\n\");\n\telse printf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 1000010\n\nint n,h;\nint g[MAXN],nume;\nint p[MAXN][2],nump;\nint d[MAXN],size[MAXN],sd[MAXN][2];\nbool tag[MAXN];\nint f[MAXN];\n\nint getf(int x){\n\tif(f[x]==x) return x;\n\treturn f[x]=getf(f[x]);\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tfor(int i=1;i<MAXN;i++) f[i]=i;\n\tmemset(g,-1,sizeof g);\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=h;i++) p[i][0]=++nump;\n\tfor(int i=1;i<=h;i++) p[i][1]=++nump;\n\tfor(int i=1;i<=n;i++){\n\t\tint t1,t2,t3,t4,u,v;\n\t\tscanf(\"%d%d%d%d\",&t1,&t2,&t3,&t4);\n\t\tif(!t3) u=p[t1][1];\n\t\telse u=p[t3][0];\n\t\tif(!t4) v=p[t2][0];\n\t\telse v=p[t4][1];\n\t\tif(getf(u)^getf(v)) f[f[u]]=f[v];\n\t\td[u]--;\n\t\td[v]++;\n\t\ttag[u]=tag[v]=1;\n\t}\n\tfor(int i=1;i<=n;i++) \n\t\tif(d[p[i][0]]<0 || d[p[i][1]]>0){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(int i=1;i<=nump;i++){\n\t\tsize[getf(i)]++;\n\t\tif(d[i]<0) sd[getf(i)][0]+=-d[i];\n\t\telse sd[getf(i)][1]+=d[i];\n\t\tif(tag[i]) tag[getf(i)]=1;\n\t}\n\tint numc=0;\n\tint s0=0,s1=0;\n\tfor(int i=1;i<=nump;i++)\n\t\tif(getf(i)==i && tag[i]){\n\t\t\tif(!sd[i][0] && !sd[i][1]){\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ts0+=sd[i][0];\n\t\t\ts1+=sd[i][1];\n\t\t\tnumc++;\n\t\t}\n\tif(s0^s1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tif(s0<numc-1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 410;\nconst int H = 201;\n\nbool use[N];\nve<pii> a[N];\nint st[N];\nbool is[100100];\n\nvoid dfs(int v) {\n\tuse[v] = 1;\n\tforn(i, sz(a[v])) {\n\t\tint to = a[v][i].fs;\n\t\tis[a[v][i].sc] = 1;\n\t\tif (!use[to])\n\t\t\tdfs(to);\n\t}\n}\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n#endif\n\tint n, h;\n\tcin >> n >> h;\n\tforn(i, n) {\n\t\tint a1, b1, c1, d1;\n\t\tscanf(\"%d%d%d%d\", &a1, &b1, &c1, &d1);\n\t\t//debug(mt(a1, b1, c1, d1));\n\t\tint u, v;\n\t\tif (c1 == 0) {\n\t\t\tu = a1;\n\t\t} else {\n\t\t\tu = c1 + H;\n\t\t}\n\t\tif (d1 == 0) {\n\t\t\tv = b1 + H;\n\t\t} else {\n\t\t\tv = d1;\n\t\t}\n\t\ta[u].pb(mp(v, i));\n\t\ta[v].pb(mp(u, i));\n\t\tst[u]++;\n\t\tst[v]--;\n\t}\n\tforn(i, H) {\n\t\tif (st[i] > 0 && !use[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tint cnt = 0;\n\tforn(i, n)\n\t\tcnt += is[i];\n\tif (cnt == n) {\n\t\tputs(\"YES\");\n\t\treturn 0;\n \t}\n \tputs(\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint M=0,fst[SZ],vb[SZ],nxt[SZ],in[SZ],ou[SZ];\nint ff[SZ];\nint gf(int x) {return ff[x]?ff[x]=gf(ff[x]):x;}\nvoid uni(int a,int b)\n{\n\tint ga=gf(a),gb=gf(b);\n\tif(ga^gb) ff[ga]=gb;\n}\nvoid ad_de(int a,int b)\n{++in[b]; ++ou[a]; uni(a,b);\n++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}\nint n,h;\nbool bb[SZ];\n#define GG {puts(\"NO\"); exit(0);}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1,a,b,c,d,l,r;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(!c) l=a; else l=-c;\n\t\tif(!d) r=-b; else r=d;\n\t\tad_de(l+n+1,r+n+1);\n\t}\n\tfor(int i=n+1;i<=n+n;++i)\n\t\tif(ou[i]<in[i]) GG\n\tfor(int i=1;i<=n;++i)\n\t\tif(in[i]<ou[i]) GG\n\tfor(int i=1;i<=n+n;++i)\n\t\tif(in[i]!=ou[i]) bb[gf(i)]=1;\n\tfor(int i=1;i<=n+n;++i)\n\t\tif((in[i]||ou[i])&&gf(i)==i&&!bb[i]) GG\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int MAXN=100005,MAXH=405;\n\nint N,H;\nint in[MAXH],out[MAXH];\nint cntS[MAXH],cntT[MAXH];\nbool vis[MAXN];\n\nint fa[MAXH];\nint Root(int x)\n{return fa[x]==0?x:(fa[x]=Root(fa[x]));}\nvoid Union(int x,int y)\n{\n\tint r1=Root(x),r2=Root(y);\n\tif(r1==r2)\n\t\treturn;\n\tfa[r1]=r2;\n}\n\nint ID(int h,int d)\n{return h*2-1+d;}\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint u,v;\n\t\tif(c==0)\n\t\t\tu=ID(a,0);\n\t\telse\n\t\t\tu=ID(c,1);\n\t\tif(d==0)\n\t\t\tv=ID(b,1);\n\t\telse\n\t\t\tv=ID(d,0);\n\t\tout[u]++;\n\t\tin[v]++;\n\t\tvis[u]=vis[v]=true;\n\t\tUnion(u,v);\n\t\t//printf(\"(%d,%d)->(%d,%d)          %d->%d\\n\",(u-1)/2+1,(u&1)^1,(v-1)/2+1,(v&1)^1,u,v);\n\t}\n\t\n\tfor(int i=1;i<=2*H;i++)\n\t{\n\t\tif(in[i]-out[i]>1||out[i]-in[i]>1)\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(in[i]-out[i]==1)\n\t\t{\n\t\t\tif(i&1)\n\t\t\t{\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcntT[Root(i)]++;\n\t\t}\n\t\tif(out[i]-in[i]==1)\n\t\t{\n\t\t\tif((i&1)^1)\n\t\t\t{\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcntS[Root(i)]++;\n\t\t}\n\t}\n\tfor(int i=1;i<=2*H;i++)\n\t\tif(vis[i]&&fa[i]==0&&(cntS[i]!=cntT[i]||(cntS[i]==0&&cntT[i]==0)))\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"Yes\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint fa[MAXN],ind[MAXN],oud[MAXN],v1[MAXN],v2[MAXN];\nint n;\nbool flag[MAXN];\nint get_fa(int x){\n\tif(fa[x]==0)\n\t\treturn x;\n\tfa[x]=get_fa(fa[x]);\n\treturn fa[x];\t\n}\nint main(){\n\tSF(\"%d\",&n);\n\tint x,y,a,b;\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d%d%d%d\",&x,&y,&a,&b);\n\t\tint u,v;\n\t\tif(a==0)\n\t\t\tu=x;\n\t\telse\n\t\t\tu=a+200;\n\t\tif(b==0)\n\t\t\tv=y+200;\n\t\telse\n\t\t\tv=b;\n\t\tflag[u]=flag[v]=1;\n\t\toud[u]++;\n\t\tind[v]++;\n\t\tif(get_fa(u)!=get_fa(v))\n\t\t\tfa[get_fa(u)]=get_fa(v);\n\t}\n\tfor(int i=1;i<=400;i++){\n\t\tif(ind[i]>oud[i]){\n\t\t\tv1[get_fa(i)]++;\n\t\t\tif(i>200){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(ind[i]<oud[i]){\n\t\t\tv2[get_fa(i)]++;\n\t\t\tif(i<=200){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=400;i++)\n\t\tif(fa[i]==0)\n\t\t\tif(v1[i]==0&&v2[i]==0&&flag[i]){\n\t\t\t\tPF(\"NO\");\t\n\t\t\t\treturn 0;\n\t\t\t}\n\tPF(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <queue>\n#include <limits>\n#include <deque>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#define mp make_pair\n#define fs first\n#define se second\n#define memset(a,t) memset(a,t,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define MN 0LL\n#define Mx 200000005\n#define Mn -Mx\n#define MX 20000000000000005\nusing namespace std;\nint readint(){\n\tchar c;\n\twhile(c=getchar(),(c<'0'||c>'9')&&c!='-');\n\tbool flag=(c=='-');\n\tif(flag)c=getchar();\n\tint x=0;\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn flag?-x:x;\n}\ninline string tos(int x){\n\tstring s;\n\twhile(x) s=(char)(x%10+'0')+s,x/=10;\n\treturn s;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint r;\n\tsrand(time(NULL));\n\tr=rand()%2;\n\tif(r==1) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\nmultiset<int>needl,needr;\nconst int N=1e5+5;\nint a[N],b[N],c[N],d[N];\n\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\tint n,h;\n\tcin>>n>>h;\n\trep(i,1,n)\n\t{\n\t\tscanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n\t\tif(c[i])needl.insert(c[i]);\n\t\tif(d[i])needl.insert(d[i]);\n\t}\n\trep(i,1,n)\n\t{\n\t\tif(!c[i])needr.erase(a[i]);\n\t\tif(!d[i])needl.erase(b[i]);\n\t}\n\tif(needl.empty()&&needr.empty())puts(\"YES\");\n\telse puts(\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, cnt[1005], in[1005], out[1005], par[1005], ta, tb, tc, td;\nbool o[1005];\n\nint find(int a) {\n\tif (par[a] == a)\n\t\treturn a;\n\treturn par[a] = find(par[a]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &ta);\n\tfor (int i = 0; i < 1005; i++)\n\t\tpar[i] = i;\n\twhile (n--) {\n\t\tscanf(\"%d%d%d%d\", &ta, &tb, &tc, &td);\n\t\tif (tc == 0)\n\t\t\tta = 500 + ta;\n\t\telse\n\t\t\tta = 500 - tc;\n\t\tif (td == 0)\n\t\t\ttb = 500 - tb;\n\t\telse\n\t\t\ttb = 500 + td;\n\t\tif (find(ta) != find(tb))\n\t\t\tpar[par[ta]] = par[tb];\n\t\tout[ta]++;\n\t\tin[tb]++;\n\t}\n\tfor (int i = 0; i < 1005; i++)\n\t\tif (in[i] * out[i] == 0 || in[i] != out[i])\n\t\t\to[i] = o[find(i)] = 1;\n\tfor (int i = 0; i < 1005; i++)\n\t\tif ((i > 500 && out[i] < in[i]) || (i < 500 && out[i] > in[i]) || !o[find(i)]) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nvector<int>G[405];\nint in[405];\nint a[100005], b[100005], c[100005], d[100005];\nint vst[405];\nvoid dfs(int now) {\n\tfor(int e:G[now]) {\n\t\tif (vst[e])continue;\n\t\tvst[e] = 1;\n\t\tdfs(e);\n\t}\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\trep(i, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tint x, y;\n\t\tif (c[i] == 0)x = a[i];\n\t\telse x = c[i] + h;\n\t\tif (d[i] == 0)y = b[i] + h;\n\t\telse y = d[i];\n\t\tG[x].push_back(y);\n\t\tin[y]++;\n\t}\n\tint cnt = 0;\n\trep(i, h + 1) {\n\t\tif ((G[i].size() + in[i]) & 1) {\n\t\t\tcnt++;\n\t\t\tG[0].push_back(i);\n\t\t}\n\t}\n\tfor (int i = h + 1; i <= 2 * h; i++) {\n\t\tif ((G[i].size() + in[i]) & 1) {\n\t\t\tcnt--;\n\t\t\tG[i].push_back(0);\n\t\t}\n\t}\n\tif (cnt!=0) {\n\t\tputs(\"NO\");\n\t}\n\telse {\n\t\tvst[0] = 1;\n\t\tdfs(0);\n\t\trep(i, 2 * h + 1) {\n\t\t\tif (vst[i] == 0 && (in[i]||G[i].size())) {\n\t\t\t\tputs(\"NO\"); return 0;\n\t\t\t}\n\t\t}\n\t\tputs(\"YES\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=410;\nint n,h,in[N],out[N];\nint fa[N];\nbool ok[N];\n\nint find(const int &x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\nint main()\n{\n    n=read();h=read();\n    for(int i=1;i<=(h<<1);i++) fa[i]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int A=read(),B=read(),C=read(),D=read();\n        int x=C?C+h:A,y=D?D:B+h;\n        out[x]++;in[y]++;\n        x=find(x);y=find(y);\n        if(x!=y) fa[x]=y;\n    }\n    for(int i=1;i<=h;i++) if(in[i]>out[i]) return !puts(\"NO\");\n    for(int i=h+1;i<=(h<<1);i++) if(in[i]<out[i]) return !puts(\"NO\");\n    for(int i=1;i<=(h<<1);i++) if(in[i]!=out[i]||!in[i]&&!out[i]) ok[find(i)]=1;\n    for(int i=1;i<=(h<<1);i++) if(fa[i]==i&&!ok[i]) return !puts(\"NO\");\n    return !puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, H;\nint A[100000];\nint B[100000];\nint C[100000];\nint D[100000];\nset<int> Rtotu[201], Rou[201];\nset<int> Ltotu[201], Lou[201];\nint total_ou = 0;\nvoid addTotu(int i) {\n  assert(C[i] == 0 && D[i] == 0);\n  Ltotu[A[i]].insert(i);\n  Rtotu[B[i]].insert(i);\n}\n\nvoid addOu(int i) {\n  total_ou++;\n  if (C[i] > 0) Lou[C[i]].insert(i);\n  if (D[i] > 0) Rou[D[i]].insert(i);\n}\nvoid add(int i) {\n  if (C[i] == 0 && D[i] == 0) addTotu(i);\n  else addOu(i);\n}\nvoid eraseTotu(int i) {\n  assert(C[i] == 0 && D[i] == 0);\n  Ltotu[A[i]].erase(i);\n  Rtotu[B[i]].erase(i);\n}\n\nvoid eraseOu(int i) {\n  total_ou--;\n  if (C[i] > 0) Lou[C[i]].erase(i);\n  if (D[i] > 0) Rou[D[i]].erase(i);\n}\n\nvoid erase(int i) {\n  if (C[i] == 0 && D[i] == 0) eraseTotu(i);\n  else eraseOu(i);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> H;\n  int g = -N;\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    g += C[i]==0;\n    g += D[i]==0;\n  }\n  if (g <= 0) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  rep(i, N) add(i);\n  while (total_ou > 0) {\n    bool done = false;\n    for (int x=1; x<=H; x++) {\n      if (!Ltotu[x].empty() && !Rou[x].empty()) {\n        int a = *Ltotu[x].begin();\n        int b = *Rou[x].begin();\n        // b(凹)|a(凸)\n        erase(a);\n        erase(b);\n        B[b] = B[a];\n        D[b] = D[a];\n        add(b);\n        done = true;\n        break;\n      }\n      if (!Rtotu[x].empty() && !Lou[x].empty()) {\n        int a = *Rtotu[x].begin();\n        int b = *Lou[x].begin();\n        // a(凸)|b(凹)\n        erase(a);\n        erase(b);\n        B[a] = B[b];\n        D[a] = D[b];\n        add(a);\n        done = true;\n        break;\n      }\n    }\n    if (!done) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n  }\n  cout << \"YES\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct MaxFlowDinic {\n    typedef int flow_t;\n    struct Edge {\n        int next;\n        size_t inv; /* inverse edge index */\n        flow_t res; /* residual */\n    };\n    int n;\n    vector<vector<Edge>> graph;\n    vector<int> q, l, start;\n    void init(int _n) {\n        n = _n;\n        graph.resize(n);\n        for (int i = 0; i < n; i++) graph[i].clear();\n    }\n    void add_edge(int s, int e, flow_t cap, flow_t caprev = 0) {\n        Edge forward{ e, graph[e].size(), cap };\n        Edge reverse{ s, graph[s].size(), caprev };\n        graph[s].push_back(forward);\n        graph[e].push_back(reverse);\n    }\n    bool assign_level(int source, int sink) {\n        int t = 0;\n        memset(&l[0], 0, sizeof(l[0]) * l.size());\n        l[source] = 1;\n        q[t++] = source;\n        for (int h = 0; h < t && !l[sink]; h++) {\n            int cur = q[h];\n            for (const auto& e : graph[cur]) {\n                if (l[e.next] || e.res == 0) continue;\n                l[e.next] = l[cur] + 1;\n                q[t++] = e.next;\n            }\n        }\n        return l[sink] != 0;\n    }\n    flow_t block_flow(int cur, int sink, flow_t current) {\n        if (cur == sink) return current;\n        for (int& i = start[cur]; i < graph[cur].size(); i++) {\n            auto& e = graph[cur][i];\n            if (e.res == 0 || l[e.next] != l[cur] + 1) continue;\n            if (flow_t res = block_flow(e.next, sink, min(e.res, current))) {\n                e.res -= res;\n                graph[e.next][e.inv].res += res;\n                return res;\n            }\n        }\n        return 0;\n    }\n    flow_t solve(int source, int sink) {\n        q.resize(n);\n        l.resize(n);\n        start.resize(n);\n        flow_t ans = 0;\n        while (assign_level(source, sink)) {\n            memset(&start[0], 0, sizeof(start[0]) * n);\n            while (flow_t flow = block_flow(source, sink, numeric_limits <flow_t\n                        >::max()))\n                ans += flow;\n        }\n        return ans;\n    }\n};\n\nstruct MaxFlowEdgeDemands\n{\n    MaxFlowDinic mf;\n    using flow_t = MaxFlowDinic::flow_t;\n    vector<flow_t> ind, outd;\n    flow_t D; int n;\n    void init(int _n) {\n        n = _n; D = 0; mf.init(n + 2);\n        ind.clear(); outd.clear();\n        ind.resize(n, 0); outd.resize(n, 0);\n    }\n    void add_edge(int s, int e, flow_t cap, flow_t demands = 0) {\n        mf.add_edge(s, e, cap - demands);\n        D += demands; ind[e] += demands; outd[s] += demands;\n    }\n    // returns { false, 0 } if infeasible\n    // { true, maxflow } if feasible\n    pair<bool, flow_t> solve(int source, int sink) {\n        mf.add_edge(sink, source, numeric_limits <flow_t >::max());\n        for (int i = 0; i < n; i++) {\n            if (ind[i]) mf.add_edge(n, i, ind[i]);\n            if (outd[i]) mf.add_edge(i, n + 1, outd[i]);\n        }\n        if (mf.solve(n, n + 1) != D) return{ false, 0 };\n        for (int i = 0; i < n; i++) {\n            if (ind[i]) mf.graph[i].pop_back();\n            if (outd[i]) mf.graph[i].pop_back();\n        }\n        return{ true, mf.solve(source, sink) };\n    }\n};\n\nint lbottom(int t)\n{\n    return t;\n}\n\nint lup(int t)\n{\n    return 200 + t;\n}\n\nint rbottom(int t)\n{\n    return 400 + t;\n}\n\nint rup(int t)\n{\n    return 600 + t;\n}\n\nint next_blk(int t)\n{\n    if (t > 400 && t <= 600) return lup(t - 400);\n    else return lbottom(t - 600);\n}\n\nbool loop[444];\nbool edge[444];\n\nint main()\n{\n    int n, h;\n    scanf(\"%d%d\",&n,&h);\n    MaxFlowEdgeDemands mf;\n    mf.init(402);\n    for (int i = 0; i < n; i++)\n    {\n        int a, b, c, d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\n        int lidx, ridx;\n\n        if (c == 0) lidx = lbottom(a);\n        else lidx = lup(c);\n\n        if (d == 0) ridx = rbottom(b);\n        else ridx = rup(d);\n\n        ridx = next_blk(ridx);\n\n        if (lidx == ridx) loop[lidx] = true;\n        else\n        {\n            mf.add_edge(lidx, ridx, 1, 1);\n            edge[lidx] = edge[ridx] = true;\n        }\n    }\n    for (int i = 1; i <= 400; i++) if (loop[i] && !edge[i]) return !printf(\"NO\\n\");\n    for (int i = 1; i <= 200; i++) mf.add_edge(0, i, 1e9);\n    for (int i = 201; i <= 400; i++) mf.add_edge(i, 401, 1e9);\n    if (mf.solve(0, 401).first) printf(\"YES\\n\");\n    else printf(\"NO\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nvvll g, gbi;\nvll see, in, out;\nll N, H;\n\nbool dfs(ll u) {\n\tsee[u] = 1;\n\tif (u > H && in[u] < out[u]) { return true; }\n\tfor (ll v : gbi[u]) {\n\t\tif (see[v] == 1) { continue; }\n\t\tif (dfs(v)) { return true; }\n\t}\n\n\treturn false;\n}\n\nint main() {\n\t\n\tcin >> N >> H;\n\n\tvll A(N + 1), B(N + 1), C(N + 1), D(N + 1);\n\trepn(i, N) cin >> A[i] >> B[i] >> C[i] >> D[i];\n\n\tg.resize(2 * H + 1);\n\trepn(i, N) {\n\t\tif (C[i] == 0 && D[i] == 0) { g[H + A[i]].push_back(H - B[i]); }\n\t\telse if (C[i] == 0) { g[H + A[i]].push_back(H + D[i]); }\n\t\telse if (D[i] == 0) { g[H - C[i]].push_back(H - B[i]); }\n\t\telse { g[H - C[i]].push_back(H + D[i]); }\n\t}\n\n\tgbi.resize(2 * H + 1);\n\trep(v, 2 * H + 1) {\n\t\tfor (ll w : g[v]) {\n\t\t\tgbi[v].push_back(w);\n\t\t\tgbi[w].push_back(v);\n\t\t}\n\t}\n\n\tin.assign(2*H + 1, 0);\n\tout.assign(2*H + 1, 0);\n\n\trep(v, 2 * H + 1) {\n\t\tout[v] = g[v].size();\n\t\tfor (ll w : g[v]) { in[w]++; }\n\t}\n\n\trep(v, 2 * H + 1) {\n\t\tif (v < H && in[v] < out[v]) { cout << \"NO\" << endl; return 0; }\n\t\tif (v > H && in[v] > out[v]) { cout << \"NO\" << endl; return 0; }\n\t}\n\n\tsee.assign(2 * H + 1, 0);\n\n\trep(v, 2 * H + 1) {\n\t\tif (see[v] == 1) { continue; }\n\t\tif (in[v] == 0 && out[v] == 0) { continue; }\n\t\tif (!dfs(v)) { cout << \"NO\" << endl; return 0; }\n\t}\n\n\tcout << \"YES\" << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconst int maxn = 100000+7;\n\nint n, h, a, b, c, d;\nint left[maxn], right[maxn];\n\nint main(int argc, char *argv[]) {  \n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0); \n\tstd::fill(left, left+maxn, 0);\n\tstd::fill(right, right+maxn, 0);\n\tstd::cin >> n >> h;\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> a >> b >> c >> d;\n\t\tif (c == 0) {\n\t\t\tleft[a]++;\n\t\t} else {\n\t\t\tright[c]--;\n\t\t}\n\t\tif (d == 0) {\n\t\t\tright[b]++;\n\t\t} else {\n\t\t\tleft[d]--;\n\t\t}\n\t}\n\tbool yes = 1;\n\tint cnt1 = 0, cnt2 = 0;\n\tfor (int i = 1; i <= h; i++) {\n\t\tif (right[i] < 0 || left[i] < 0) {\n\t\t\tyes = 0;\n\t\t}\n//\t\tstd::cout << left[i] << ' ' << right[i] << '\\n';\n\t\tcnt1 += left[i];\n\t\tcnt2 += right[i];\n\t}\n//\tstd::cout << cnt << '\\n';\n\tif (yes && cnt1+cnt2 >= 2 && cnt1 == cnt2) {\n\t\tstd::cout << \"YES\\n\";\n\t} else {\n\t\tstd::cout << \"NO\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int maxn = 1e5+10;\nint down_l[205], down_r[205], up_l[205], up_r[205];\nint l_l[maxn],l_r[maxn],h_l[maxn],h_r[maxn];\nint main()\n{\n\tint n,h;\n\tint a,b,c,d;\n\tint count_up;\n\twhile(~scanf(\"%d%d\",&n,&h)){\n\t\tcount_up = 0;\n\t\tmemset(down_l,0,sizeof(int)*205);\n\t\tmemset(down_r,0,sizeof(int)*205);\n\t\tmemset(up_l,0,sizeof(int)*205);\n\t\tmemset(up_r,0,sizeof(int)*205);\n\t\tfor(int i = 0; i<n; i++){\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\tl_l[i] = a; l_r[i] = b;\n\t\t\th_l[i] = c; h_r[i] = d;\n\t\t\tif(c == 0) down_l[a]++;\n\t\t\telse {\n\t\t\t\tup_l[a]++;\n\t\t\t\tcount_up ++;\n\t\t\t}\n\t\t\tif(d == 0) down_r[b]++;\n\t\t\telse {\n\t\t\t\tup_r[b]++;\n\t\t\t\tcount_up++;\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int i = 0; i<n; i++){\n\t\t\tint a = l_l[i], b = l_r[i];\n\t\t\tint c = h_l[i], d = h_r[i];\n\t\t\tif(c != 0){\n\t\t\t\tint dis = 0;\n\t\t\t\tif(c == b && d == 0) dis = 1;\n\t\t\t\tif(down_r[c] - dis > 0) down_r[c]--;\n\t\t\t\telse{\n\t\t\t\t\tflag = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( d != 0){\n\t\t\t\tint dis = 0;\n\t\t\t\tif(a == d && c == 0) dis = 1;\n\t\t\t\tif(down_l[d] - dis > 0) down_l[d]--;\n\t\t\t\telse {\n\t\t\t\t\tflag = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count_up >= n) flag = false;\n\t\tif(flag) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nconst int MAX_V = 420;\nconst int Base = MAX_V / 2;\n\nvector<int> es[MAX_V];\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n\n\n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n\n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n\n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n    bool check(int v, int W) {\n    \treturn cmp[W] == cmp[v];\n    }\n};\n\n// #define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\tvi a(n), b(n), c(n), d(n);\n\trep(i, n) cin >> a[i] >> b[i] >> c[i] >> d[i];\n\tvi l(n), r(n);\n\trep(i, n) {\n\t\tl[i] = (c[i] == 0 ? a[i] : -c[i]);\n\t\tr[i] = (d[i] == 0 ? b[i] : -d[i]);\n\t}\n\tset<int> st;\n\trep(i, n) {\n\t\tint frm = (l[i] > 0 ? l[i] : Base - l[i]);\n\t\tint to = (r[i] > 0 ? Base + r[i] : -r[i]);\n\t\tif(frm == to) continue;\n\t\tes[frm].pb(to);\n\t\tst.insert(frm);\n\t\tst.insert(to);\n\t}\n\tint W = MAX_V-1;\n\tst.insert(W);\n\tvector<int> in(MAX_V), out(MAX_V);\n\tSCC g(MAX_V);\n\trep(i, MAX_V) {\n\t\tsort(all(es[i]));\n\t\t//es[i].erase(unique(all(es[i])), es[i].end());\n\t\tint prv = -1;\n\t\tfor(auto& to : es[i]) {\n\t\t\tif(prv != to) g.add_edge(i, to);\n\t\t\tprv = to;\n\t\t\tin[to]++;\n\t\t}\n\t\tout[i] = es[i].size();\n\t}\n\trep(i, MAX_V) {\n\t\tif(i >= Base) {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] < out[i]) {\n\t\t\t\tLINE;dump(i);dump(in[i]);dump(out[i]);dump(es[i][0]);\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse g.add_edge(i, W);\n\t\t}\n\t\telse {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] > out[i]) {\n\t\t\t\tLINE;\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse g.add_edge(W, i);\n\t\t}\n\t}\n\tg.scc();\n\tfor(auto& v : st) {\n\t\tif(!g.check(v, W)) {\n\t\t\tLINE;\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[50000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 10007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,h,i,zz[405],ru[405],chu[405],book[405],a,b,c,d;\nint zzz(int z){\n\tif(zz[z]==z) return z;\n\treturn zz[z]=zzz(zz[z]);\n}\nint main(){\n\tn=read();h=read();\n\tfor(i=1;i<=h*2;i++)\n\t\tzz[i]=i;\n\tfor(i=1;i<=n;i++){\n\t\ta=read();b=read();c=read();d=read();\n\t\tif(c==0)\n\t\t\tc=a;\n\t\telse\n\t\t\tc+=h;\n\t\tif(d==0)\n\t\t\td=b+h;\n\t\tchu[c]++;\n\t\tru[d]++;\n\t\tc=zzz(c);\n\t\td=zzz(d);\n\t\tif(zz[c]!=d)\n\t\t\tzz[c]=d;\n\t}\n\tfor(i=1;i<=h;i++)\n\t\tif(ru[i]>chu[i]||ru[i+h]<chu[i+h]){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=1;i<=h*2;i++)\n\t\tif(ru[i]!=chu[i]||ru[i]==0&&chu[i]==0)\n\t\t\tbook[zzz(i)]=1;\n\tfor(i=1;i<=h*2;i++)\n\t\tif(zz[i]==i&&book[i]==0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\tprintf(\"YES\\n\");\n   \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Jigsaw\n// * frank_c1\n// * 2017 / 11/ 07\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = (int)(1e5) + 5;\nint ai[maxn], bi[maxn], ci[maxn], di[maxn];\nint in[maxn], ou[maxn];\n\nint main() {\n\tint n, H;\n\tscanf(\"%d%d\", &n, &H);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d%d%d%d\", &ai[i], &bi[i], &ci[i], &di[i]);\n\t\tint u = 0, v = 0;\n\t\tif (!ci[i]) u = ai[i]; else u = ci[i] + H;\n\t\tif (!di[i]) v = bi[i] + H; else v = di[i];\n\t\t++ou[u]; ++in[v]; \n\t} int cnt = 0, e = 0;\n\tfor (int i = 1; i <= H; ++i) if (in[i] > ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] < ou[i]) cnt += ou[i] - in[i], e = 1;\n\tfor (int i = H + 1; i <= H + H; ++i) if (in[i] < ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] > ou[i]) cnt -= in[i] - ou[i];\n\treturn ((cnt || !e) ? printf(\"NO\\n\") : printf(\"YES\\n\")), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\nint NOEL(){\n  cout<<\"NO\"<<endl;\n  return 0;\n}\nstring g(char a,string b){\n  string res=\"\";\n  res.push_back(a);\n  res+=b;\n  return res;\n}\n\nunordered_map<string,ll> nz;\n\nunordered_map<string,vector<string> >v;\nunordered_set<string> vis;\nbool done;\nvoid dfs(string x){\n  if(vis.find(x)!=vis.end())return;\n  vis.insert(x);\n  if(nz[x]!=0)done=1;\n  for(auto y:v[x]){\n    dfs(y);\n  }\n}\nint main(){\n    ll n,h;\n    cin>>n>>h;\n    lol(i,n){\n      string a,b,c,d;cin>>a>>b>>c>>d;\n      string s,t;\n      if(c==\"0\")s=g('x',a);\n      else s=g('y',c);\n      nz[s]++;\n      if(d==\"0\")t=g('y',b);\n      else t=g('x',d);\n      nz[t]--;\n      //cout<<s<<\" \"<<t<<endl;\n      v[s].push_back(t);\n      v[t].push_back(s);\n    }\n    for(auto dat:nz){\n      string key=dat.first;\n      ll cnt=dat.second;\n      //cout<<key<<\" \"<<cnt<<endl;\n      //if(cnt>=2||cnt<=-2)return NOEL();\n      if(cnt>0&&key[0]!='x')return NOEL();\n      if(cnt<0&&key[0]!='y')return NOEL();\n      if(vis.find(key)==vis.end()){\n\tdone=0; dfs(key);\n\tif(done==0)return NOEL();\n      }\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tif(rand()%2)puts(\"YES\");\n\telse puts(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define llong long long\n#define sz(v) ((int)v.size())\n#define ii pair<int, int>\n#define xx first\n#define yy second\n#define rep(i,n) for (int i = -1; ++i < n; )\n\n#define maxn 101010\n#define maxh 222\nint n, h;\nint a[maxn], b[maxn], c[maxn], d[maxn];\n\nvector<int> ff[maxh], bb[maxn];\nvector<int> gr[maxn], rgr[maxn];\n\nbool vis[maxn];\nvector<int> st;\nvoid dfs1(int u) {\n  vis[u] = 1;\n  for (auto v: gr[u]) if (!vis[v]) dfs1(v);\n  st.push_back(u);\n}\n\nint counter = 0;\nint comp[maxn];\nvoid dfs2(int u) {\n  vis[u] = 1;\n  for (auto v: rgr[u]) if (!vis[v]) dfs2(v);\n  comp[u] = counter;\n}\n\nvoid ssc() {\n  memset(vis, 0, sizeof(vis));\n  rep(i, n) {\n    if (!vis[i]) dfs1(i);\n  }\n  memset(vis, 0, sizeof(vis));\n  for (; sz(st); st.pop_back()) {\n    int u = st.back();\n    if (!vis[u]) {\n      dfs2(u);\n      ++counter;\n    }\n  }\n}\n\nint incnt[maxn] = {0}, outcnt[maxn] = {0};\n\nint main() {\n  cin.sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  cin >> n >> h;\n  rep(i, n) cin >> a[i] >> b[i] >> c[i] >> d[i];\n  a[n] = b[n] = c[n] = d[n] = 0;\n  ++n;\n  \n  rep(i, n - 1) {\n    if (c[i] == 0) ff[a[i]].push_back(i);\n    if (d[i] == 0) bb[b[i]].push_back(i);\n  }\n\n  ff[0].push_back(n - 1);\n\n  rep(i, n - 1) {\n    for (auto f: bb[c[i]]) {\n      gr[f].push_back(i);\n      rgr[i].push_back(f);\n    }\n    for (auto f: ff[d[i]]) {\n      gr[i].push_back(f);\n      rgr[f].push_back(i);\n    }\n  }\n\n  ssc();\n  //clog << counter << endl;\n  rep(i, counter) gr[i].clear();\n  rep(u, n) {\n    for (auto v: rgr[u]) {\n      if (comp[u] == comp[v]) continue;\n      gr[comp[v]].push_back(comp[u]);\n      //clog << comp[v] << ' ' << comp[u] << endl;\n    }\n  }\n\n  st.clear();\n  memset(vis, 0, sizeof(vis));\n  rep(i, counter)\n    if (!vis[i]) dfs1(i);\n\n  for (int i = sz(st) - 1; i >= 1; --i) {\n    int u = st[i], v = st[i - 1];\n    bool found = 0;\n    for (auto x: gr[u])\n      if (x == v) {\n        found = 1;\n        break;\n      }\n    //clog << u << ' ' << v << endl;\n    if (found) continue;\n    cout << \"NO\";\n    return 0;\n  }\n\n  //clog << comp[n - 1] << endl;\n  if (st[0] == comp[n - 1]) cout << \"YES\";\n  else cout << \"NO\";\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nconst int X=250;\nint size[N],fa[N];\nint in[N],out[N];\nint h[N];\nint n,m;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n\treturn x;\n}\nint gf(int k)\n{\n\tif(fa[k]!=k)fa[k]=gf(fa[k]);\n\treturn fa[k];\n}\nvoid merge(int x,int y)\n{\n\tx=gf(x);y=gf(y);\n\tif(x==y){\n\t\tsize[x]++;\n\t\treturn;\n\t}\n\tfa[x]=y;\n\tsize[y]+=size[x]+1;\n}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=-m;i<=-1;i++)fa[i+X]=i+X,size[i+X]=1;\n\tfor(int i=1;i<=m;i++)fa[i+X]=i+X,size[i+X]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d,x,y;\n\t\ta=read();b=read();c=read();d=read();\n\t\tif(c==0)x=a;else x=-c;\n\t\tif(d==0)y=-b;else y=d;\n\t\tout[x+X]++;in[y+X]++;\n\t\tmerge(x+X,y+X);\n\t}\n\tfor(int i=1;i<=m;i++)\tif(out[i+X]<in[i+X]){puts(\"NO\");return 0;}\n\tfor(int i=-m;i<=-1;i++)\tif(in[i+X]<out[i+X]){puts(\"NO\");return 0;}\n\tfor(int i=1;i<=m;i++)\tif(size[i+X]>1&&(gf(i+X)==i+X)&&(in[i+X]==out[i+X])){puts(\"NO\");return 0;}\n\tfor(int i=-m;i<=-1;i++)\tif(size[i+X]>1&&(gf(i+X)==i+X)&&(in[i+X]==out[i+X])){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// contancer library\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\n\ntemplate <class K, class T>\nostream& operator<<(ostream& os, map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\n\nconst ll MOD = 1000000007;\n// const ll MOD = 998244353;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const ld PI = acos(-1);\n// const ld EPS = 1e-10;\n// mt19937 mt(ll(time(0)));\n\ntemplate <class T>\nvector<T> Vec(size_t l, T v) { return vector<T>(l, v); }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\ntemplate <typename T>\ninline T sq(T a) { return a * a; }\n\ntemplate <typename T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <typename T, typename U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\ntemplate <typename T, typename U>\nT mpow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret = ret * b % MOD;\n        n >>= 1;\n        b = b * b % MOD;\n    }\n    return ret;\n}\n\nvoid fail() {\n    cout << \"NO\" << endl;\n    exit(0);\n}\n\nclass QuickFind {\npublic:\n    QuickFind(int N) : V_NUM(N) {\n        par.resize(V_NUM);\n        iota(par.begin(), par.end(), 0);\n        group.resize(V_NUM);\n        for (int i = 0; i < N; ++i) group[i] = {i};\n    }\n\n    int find(int v) {\n        return par[v] == v ? v : par[v] = find(par[v]);\n    }\n\n    void merge(int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v) return;\n        if (group[u].size() < group[v].size()) swap(u, v);\n\n        par[v] = u;\n        copy(group[v].begin(), group[v].end(), back_inserter(group[u]));\n        group[v].erase(group[v].begin(), group[v].end());\n    }\n\n    int V_NUM;\n    vector<vector<int>> group;\n    vector<int> par;\n};\n\nint main() {\n    int N, H;\n    cin >> N >> H;\n\n    vector<int> in(H * 2, 0), out(H * 2, 0);\n    QuickFind qf(H * 2);\n    for (int i = 0; i < N; ++i) {\n        int A, B, C, D;\n        cin >> A >> B >> C >> D;\n        --A, --B, --C, --D;\n\n        int from, to;\n        if (C < 0) {\n            from = A;\n        } else {\n            from = C + H;\n        }\n\n        if (D < 0) {\n            to = B + H;\n        } else {\n            to = D;\n        }\n\n        ++out[from];\n        ++in[to];\n        qf.merge(from, to);\n    }\n    cerr << in << endl;\n    cerr << out << endl;\n\n    cerr << qf.group << endl;\n    for (auto& g : qf.group) {\n        if (g.empty()) continue;\n        if (g.size() == 1) {\n            if (in[g[0]] != 0) fail();\n        } else {\n            bool judge = false;\n            for (auto i : g) {\n                int d = out[i] - in[i];\n                if ((i < H && d < 0) || (i >= H && d > 0)) fail();\n                if (i < H && d > 0) judge = true;\n            }\n            if (!judge) fail();\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500\nusing namespace std;\nint f[N],sz[N],fl[N],out[N],in[N];\nint n,h,a,b,c,d,x,y;\nint get(int x){\n\treturn f[x]==x?x:f[x]=get(f[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=-h;i<=h;i++)\n\t\tf[i+233]=i+233,sz[i+233]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=(c==0)?a:-c; y=(d==0)?-b:d;\n\t\t++out[x+233]; ++in[y+233];\n\t\tx=get(x+233); y=get(y+233);\n\t\tif (x==y) sz[x]++;\n\t\telse f[x]=y,sz[y]+=sz[x]+1;\n\t}\n\tfor (int i=1;i<=h;i++)\n\t\tif (out[i+233]<in[i+233])\n\t\t\treturn puts(\"NO\"),0;\n\tfor (int i=-h;i<=-1;i++)\n\t\tif (in[i+233]<out[i+233])\n\t\t\treturn puts(\"NO\"),0;\n\tfor (int i=-h;i<=h;i++)\n\t\tfl[get(i+233)]|=(in[i+233]!=out[i+233]);\n\tfor (int i=-h;i<=-1;i++)\n\t\tif (sz[get(i+233)]>1&&!fl[get(i+233)])\n\t\t\treturn puts(\"NO\"),0;\n\tfor (int i=1;i<=h;i++)\n\t\tif (sz[get(i+233)]>1&&!fl[get(i+233)])\n\t\t\treturn puts(\"NO\"),0;\n\tputs(\"YES\"); \n} "
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long  int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<vector<int>>uu(201, vector<int>(201));\n\tvector<vector<int>>us(201, vector<int>(201));\n\tvector<vector<int>>su(201, vector<int>(201));\n\tvector<vector<int>>ss(201, vector<int>(201));\n\tfor (int i = 0; i < N; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif (c&&d) {\n\t\t\tuu[c][d]++;\n\t\t}\n\t\telse if (c) {\n\t\t\tus[c][b]++;\n\t\t}\n\t\telse if (d) {\n\t\t\tsu[a][d]++;\n\t\t}\n\t\telse {\n\t\t\tss[a][b]++;\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tus[i][i] = min(us[i][i], 1);\n\t\tsu[i][i] = min(su[i][i], 1);\n\t}\n\tvector<int>lu(201);\n\tvector<int>ld(201);\n\tvector<int>ru(201);\n\tvector<int>rd(201);\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tlu[i] += uu[i][j];\n\t\t\tlu[i] += us[i][j];\n\t\t\tld[i] += su[i][j];\n\t\t\tld[i] += ss[i][j];\n\t\t\tru[j] += uu[i][j];\n\t\t\tru[j] += su[i][j];\n\t\t\trd[j] += ss[i][j];\n\t\t\trd[j] += us[i][j];\n\t\t}\n\t\tld[i] -= su[i][i];\n\t\trd[i] -= us[i][i];\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\t//cout << i << \" \" << lu[i] << \" \" << ld[i] << \" \" << ru[i] << \" \" << rd[i] << endl;\n\t\tif (lu[i] > rd[i] || ld[i] < ru[i]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N,H;\nint A[111111],B[111111],C[111111],D[111111];\n\n\nint M=500;\nint deg[1111];\nbool used[1111];\n\nsigned main(){\n    cin>>N>>H;\n    UnionFindTree uf(1111);\n    rep(i,N){\n        cin>>A[i]>>B[i]>>C[i]>>D[i];\n\n        int u,v;\n        if(C[i]==0){\n            u=A[i];\n        }\n        else{\n            u=M+C[i];\n        }\n\n        if(D[i]==0){\n            v=M+B[i];\n        }\n        else{\n            v=D[i];\n        }\n\n        uf.unite(u,v);\n        used[u]=used[v]=true;\n        deg[u]++;\n        deg[v]--;\n\n    }\n\n\n\n    used[2*M]=true;\n    int ei=0,uku=0;\n    rep(i,M){\n        if(deg[i]<0){\n            cout<<\"NO\"<<endl;\n            return 0;\n        }\n        if(deg[i]>0){\n            ei+=deg[i];\n            uf.unite(2*M,i);\n        }\n    }\n\n    for(int i=M;i<2*M;i++){\n        if(deg[i]>0){\n            cout<<\"NO\"<<endl;\n            return 0;\n        }\n        if(deg[i]<0){\n            uku+=-deg[i];\n            uf.unite(2*M,i);\n        }\n    }\n\n    if(ei!=uku){\n        cout<<\"NO\"<<endl;\n        return 0;\n    }\n\n\n    rep(i,1111)rep(j,1111){\n        if(!used[i]||!used[j])continue;\n        if(!uf.areSame(i,j)){\n            cout<<\"NO\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\n#define A(a) ((a)<<1)\n#define B(a) ((a)<<1|1)\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nconst int MAXV = 200007;\nconst int MAXM = 2000007;\n\nstruct eT\n{\n\tvoid setd ( int _u, int _v, int _f, int _l )\n\t{\n\t\tu = _u, v = _v, f = _f, last = _l;\n\t}\n\n\tint u, v, f, last;\n}edge[MAXM];\n\nstruct bT\n{\n\tbT () {}\n\tbT ( int _h, int _l ) : h ( _h ), l ( _l ) {}\n\n\tvoid setd ( int _h, int _l )\n\t{\n\t\th = _h, l = _l;\n\t}\n\n\tbool operator < ( const bT &a ) const\n\t{\n\t\treturn ( h ^ a.h ) ? ( h < a.h ) : ( l < a.l );\n\t}\n\n\tint h, l;\n}bl[MAXN], br[MAXN];\n\nint n, h, S, T;\nint ke, la[MAXV];\n\nint q[MAXV], lev[MAXV];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nvoid addedge ( int u, int v, int fu, int fv );\n\nint dinic ();\nbool bfs ();\nint dfs ( int now, int lim );\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\n\tscanf ( \"%d%d\", &n, &h );\n\tint a, b, c, d;\n\tlpi ( i, 1, n ){\n\t\tscanf ( \"%d%d%d%d\", &a, &b, &c, &d );\n\t\tbl[i].setd ( c, a ), br[i].setd ( d, b );\n\t}\n}\n\nvoid work ()\n{\n\t// main work\n\n\tS = MAXV - 1, T = MAXV - 2;\n\tint SS = MAXV - 3, TT = MAXV - 4;\n\tke = 0;\n\tINIT ( la, -1 );\n\n\tmap < bT, PII > ml, mr;\n\tmap < bT, PII > ::iterator it;\n\n\tAR( int ) keye;\n\tint ks = 0;\n\n\tlpi ( i, 1, n ){\n\t\t++ml[bl[i]].first;\n\t\t++mr[br[i]].first;\n\t}\n\n\tint kl = 0, kr = 0;\n\tfor ( auto &x : ml ) x.second.second = ++kl;\n\tfor ( auto &x : mr ) x.second.second = ++kr;\n\n\tfor ( auto x : ml ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, A( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( A( x.second.second ), TT, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = mr.find ( bT ( 0, x.first.h ) ) ) != mr.end () ){\n\t\t\t\taddedge ( B( it->second.second ), A( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n\t\t\taddedge ( A( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n\tfor ( auto x : mr ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, B( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( B( x.second.second ), SS, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = ml.find ( bT ( 0, x.first.h ) ) ) != ml.end () ){\n\t\t\t\taddedge ( A ( it->second.second ), B( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n\t\t\taddedge ( B( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n//\taddedge ( SS, T, INF, 0 );\n//\taddedge ( TT, T, INF, 0 );\n\n\tif ( ks >= n ){\n\t\tprintf ( \"NO\\n\" );\n\t\treturn;\n\t}\n\n\tdinic ();\n\n\tbool flag = true;\n\tfor ( auto x : keye ){\n\t\tif ( edge[x].f ){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf ( flag ? \"YES\\n\" : \"NO\\n\" );\n}\n\n\n\nvoid addedge ( int u, int v, int fu, int fv )\n{\n\tedge[ke].setd ( u, v, fu, la[u] );\n\tla[u] = ke++;\n\tedge[ke].setd ( v, u, fv, la[v] );\n\tla[v] = ke++;\n}\n\nint dinic ()\n{\n\tint ans = 0;\n\twhile ( bfs () ) ans += dfs ( S, INF );\n\treturn ans;\n}\n\nbool bfs ()\n{\n\tint l = 0, r = 0, now, v;\n\tq[r++] = S;\n\tINIT ( lev, -1 );\n\tlev[S] = 1;\n\twhile ( l < r ){\n\t\tnow = q[l++];\n\t\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\t\tif ( edge[i].f && lev[v=edge[i].v] == -1 ){\n\t\t\t\tlev[v] = lev[now] + 1;\n\t\t\t\tq[r++] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ( lev[T] != -1 );\n}\n\nint dfs ( int now, int lim )\n{\n\tif ( now == T ) return lim;\n\n\tint v, nf = 0, tf;\n\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\tif ( edge[i].f && lev[v=edge[i].v] == lev[now] + 1 ){\n\t\t\ttf = dfs ( v, qmin ( lim-nf, edge[i].f ) );\n\t\t\tnf += tf;\n\t\t\tedge[i].f -= tf, edge[i^1].f += tf;\n\n\t\t\tif ( nf == lim ) break;\n\t\t}\n\t}\n\n\tif ( !nf ) lev[now] = -1;\n\treturn nf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\n\tint cntt = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0)cntt++;\n\t\tif (b[i].d > 0)cntt++;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (cntt > n - 1) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tint th = 0;\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, c[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st != e[401]||st>=e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define efo(i,q) for(int i=A[q];i;i=B[i][0])\nusing namespace std;\nconst int N=100500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nint Bv[N][2];\nint B[2*N][2],A[N],B0;\nbool z[N];\nvoid dfs(int q)\n{\n\tz[q]=1;\n\tefo(i,q)if(!z[B[i][1]])dfs(B[i][1]);\n}\nint main()\n{\n\tint q,w;\n\tread(n),read(m);\n\tfo(i,1,n)\n\t{\n\t\tint qa,qb,qc,qd;\n\t\tread(qa),read(qb),read(qc),read(qd);\n\t\tif(qc==0)\n\t\t{\n\t\t\tq=m+qa;\n\t\t}else q=qc;\n\t\tif(qd==0)w=qb;\n\t\telse w=m+qd;\n\t\t++Bv[q][0];++Bv[w][1];\n\t\tB[++B0][0]=A[q],A[q]=B0,B[B0][1]=w;\n\t}\n\tans=0;q=0;\n\tfo(i,1,m)\n\t{\n\t\tif(Bv[i][0]>Bv[i][1])++ans;\n\t\tif(Bv[i][0]<Bv[i][1])++q;\n\t}\n\tif(ans||!q)return printf(\"NO\\n\"),0;\n\tq=0;\n\tfo(i,m+1,m*2)\n\t{\n\t\tif(Bv[i][0]<Bv[i][1])++ans;\n\t\tif(Bv[i][0]>Bv[i][1])++q;\n\t}\n\tif(ans||!q)return printf(\"NO\\n\"),0;\n\tfo(i,m+1,2*m)if(Bv[i][0]>Bv[i][1]&&!z[i])dfs(i);\n\tfo(i,1,m*2)if(A[i]&&!z[i])return printf(\"NO\\n\"),0 ;\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tsrand(clock());\n\tint x = rand()%2;\n\tcout << (x ? \"YES\" : \"NO\") << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\n\nint main() {\n#ifdef HOME\n    freopen(\"in\", \"r\", stdin);\n#endif\n\n    int n, h;\n    while (scanf(\"%d%d\", &n, &h) == 2) {\n        vector<int> a(n), b(n), c(n), d(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%d%d\", &a[i], &b[i], &c[i], &d[i]);\n        }\n\n        vector<int> p(2 * h);\n        iota(p.begin(), p.end(), 0);\n        function<int(int)> get = [&](int x) {\n            return x == p[x] ? x : p[x] = get(p[x]);\n        };\n        auto uni = [&](int u, int v) {\n            p[get(v)] = get(u);\n        };\n        vector<int> deg(2 * h);\n        vector<char> ok(2 * h, 1);\n        for (int i = 0; i < n; i++) {\n            int u = c[i] == 0 ? a[i]-1 : h + c[i]-1;\n            int v = d[i] == 0 ? h+b[i]-1 : d[i]-1;\n            ok[u] = ok[v] = 0;\n            uni(u, v);\n            deg[u]++;\n            deg[v]--;\n        }\n        bool f = 1;\n        for (int i = 0; i < h; i++) {\n            f &= deg[i] >= 0;\n            f &= deg[i + h] <= 0;\n        }\n        for (int i = 0; i < 2 * h; i++) if (deg[i] != 0) ok[get(i)] = 1;\n        for (int i = 0; i < 2 * h; i++) if (p[i] == i && !ok[i]) f = 0;\n        string ans = f ? \"YES\" : \"NO\";\n        cout << ans << endl;\n    }\n\n#ifdef HOME\n    cerr << clock() / (double)CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint inadj[210][2], outadj[210][2], n, h;\nint inadj2[210][2], outadj2[210][2];\npair<int, int> thing(int a, int b)\n{\n\tpair<int, int> ans;\n\tif (b) ans = { b, 0 };\n\telse ans = { a, 1 };\n\treturn ans;\n}\nvector<pair<int, int> > adj[210][2];\nint seen[210][2], c;\nvector<pair<int, int> > components[500];\nvoid dfs(int a, int b, int d)\n{\n\tif (seen[a][b]) return;\n\tseen[a][b] = 1;\n\tcomponents[d].push_back({ a, b });\n\tfor (auto c : adj[a][b]) dfs(c.first, c.second, d);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tpair<int, int> in, out;\n\t\tin = thing(a, c);\n\t\tout = thing(b, d);\n\t\tout.second = !out.second;\n//\t\tprintf(\"%d %d -> %d %d\\n\", in.first, in.second, out.first, out.second);\n\t\toutadj[in.first][in.second]++;\n\t\tinadj[out.first][out.second]++;\n\t\tadj[in.first][in.second].push_back(out);\n\t\tadj[out.first][out.second].push_back(in);\n\t}\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tif (adj[i][j].size() && !seen[i][j]) dfs(i, j, c++);\n\t\t//\tprintf(\"%d:%d - in %d, out %d\\n\", i, j, inadj[i][j], outadj[i][j]);\n\t\t}\n\t}\n\tbool works = 1;\n\tfor (int i = 0; i < c; i++)\n\t{\n\t\tfor (int i = 0; i <= h; i++) inadj2[i][0] = inadj2[i][1] = outadj2[i][0] = outadj2[i][1] = 0;\n\t\tfor (auto b : components[i])\n\t\t{\n\t\t\tinadj2[b.first][b.second] += inadj[b.first][b.second];\n\t\t\toutadj2[b.first][b.second] += outadj[b.first][b.second];\n\t\t}\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\t//printf(\"%d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\tif (inadj2[i][0] - outadj2[i][0] > 0 && inadj2[i][1] - outadj2[i][1] < 0) \n\t\t\t{\n\t\t\t//\tprintf(\"%d\\n\", i);\n\t\t\t\tinadj2[i][0]--; \n\t\t\t\toutadj2[i][1]--;\n\t\t\t//\tprintf(\" %d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\t}\n\t\t}\n\t\tint extra = 0;\n\t\tbool thing = 0;\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t{\n\t\t\t\tif (abs(inadj2[i][j] - outadj2[i][j])) extra += abs(inadj2[i][j] - outadj2[i][j]), thing = 1;\n\t\t\t}\n\t\t}\n\t\tif (extra % 2 || !thing) works = 0;\n\t}\n//\tprintf(\"Components %d\\n\", c);\n\tif (works) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstruct unifnd{\n  VI ht,pr;\n  in fnd(in a){\n    in ta=a;\n    while(a!=pr[a])a=pr[a];\n    in tt=ta;\n    while(ta!=a){\n      tt=pr[ta];\n      pr[ta]=a;\n      ta=tt;\n    }\n    return a;\n  }\n  void uni(in a, in b){\n    a=fnd(a);\n    b=fnd(b);\n    if(a==b)return;\n    if(ht[b]<ht[a])swap(a,b);\n    pr[a]=b;\n    ht[b]+=(ht[a]==ht[b]);\n  }\n  void ini(in n){\n    ht.resize(n);\n    pr.resize(n);\n    forn(i,n){\n      ht[i]=0;\n      pr[i]=i;\n    }\n  }\n};\nset<in> himb;\nVI ap;\nunifnd tfd;\nVI dgl,dgr;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n,h,a,b,c,d;\n  cin>>n>>h;\n  const in ofs=h+9;\n  tfd.ini(ofs*2);\n  dgl.resize(h+3);\n  dgr.resize(h+3);\n  in ta,tb;\n  forn(z,n){\n    cin>>a>>b>>c>>d;\n    if(c==0){\n      ta=a;\n      ++dgl[a];\n    }\n    else{\n      ta=ofs+c;\n      ++dgr[c];\n    }\n    if(d==0){\n      tb=ofs+b;\n      --dgr[b];\n    }\n    else{\n      tb=d;\n      --dgl[d];\n    }\n    tfd.uni(ta,tb);\n    ap.PB(ta);\n    ap.PB(tb);\n  }\n  forv(i,dgl){\n    if(dgl[i]<0){\n      cout<<\"NO\"<<endl;\n      return 0;\n    }\n    if(dgl[i]>0)\n      himb.insert(tfd.fnd(i));\n  }\n  forv(i,dgr){\n    if(dgr[i]>0){\n      cout<<\"NO\"<<endl;\n      return 0;\n    }\n    if(dgr[i]<0)\n      himb.insert(tfd.fnd(ofs+i));\n  }\n  forv(i,ap){\n    if(!himb.count(tfd.fnd(ap[i]))){\n      cout<<\"NO\"<<endl;\n      return 0;\n    }\n  }\n  cout<<\"YES\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define no return cout << \"NO\\n\", 0\nusing namespace std;\nconst int H = 405;\nint f[H], d[H];\nbool b[H], c[H];\nint getf(int x)\n{\n\treturn f[x] == x ? x : f[x] = getf(f[x]);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n, h;\n\tcin >> n >> h;\n\tfor (int i = 0; i <= 2 * h; i++)\n\t\tf[i] = i;\n\twhile (n--)\n\t{\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint x = (c ? -c : a) + h, y = (d ? d : -b) + h;\n\t\tf[getf(x)] = getf(y);\n\t\t::d[x]++;\n\t\t::d[y]--;\n\t\t::b[x] = true;\n\t}\n\tfor (int i = 0; i < h; i++)\n\t\tif (d[i] > 0)\n\t\t\tno;\n\tfor (int i = h + 1; i <= 2 * h; i++)\n\t\tif (d[i] < 0)\n\t\t\tno;\n\tfor (int i = 0; i <= 2 * h; i++)\n\t{\n\t\tb[getf(i)] |= b[i];\n\t\tif (d[i])\n\t\t\tc[f[i]] = true;\n\t}\n\tfor (int i = 0; i <= 2 * h; i++)\n\t\tif (f[i] == i && !c[i] && b[i])\n\t\t\tno;\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst int UnionFindTree_MAX_V = 100000;\nstruct UnionFindTree{\n\tint par[UnionFindTree_MAX_V+10],r[UnionFindTree_MAX_V+10];\n\tvoid init(int n = UnionFindTree_MAX_V){\n\t\tfor(int i = 0 ; i < n+10 ; i ++){\n\t\t\tpar[i] = i;\n\t\t\tr[i] = 0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unit(int x,int y){\n\t\tif(same(x,y))return;\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(r[x] < r[y]){\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(r[x] == r[y]){\n\t\t\t\tr[x] ++;\n\t\t\t}\n\t\t}\n\t}\n}uf;\n\nint main(){\n\tstatic int n,h;\n\tstatic int a[100010],b[100010],c[100010],d[100010];\n\tscanf(\"%d%d\",&n,&h);\n\trep1(i,n)scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t\n\tstatic int e[100010],f[100010];\n\trep1(i,n){\n\t\tif(c[i] == 0)e[i] = h+a[i];\n\t\telse e[i] = h-c[i];\n\t\tif(d[i] == 0)f[i] = h+b[i];\n\t\telse f[i] = h-d[i];\n\t}\n\tuf.init();\n\tstatic int cnt[2][402] = {};\n\trep1(i,n){\n\t\tcnt[0][e[i]] ++;\n\t\tcnt[1][f[i]] --;\n\t\tuf.unit(e[i],f[i]+500);\n\t}\n\trep(i,h){\n\t\tif(cnt[0][i] > 0){\n\t\t\tcnt[1][2*h-i] += cnt[0][i];\n\t\t\tif(cnt[1][2*h-i]>0){\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcnt[0][i] = 0;\n\t\t\tuf.unit(i,2*h-i+500);\n\t\t}\n\t}\n\trep(i,h){\n\t\tif(cnt[1][i] < 0){\n\t\t\tcnt[0][2*h-i] += cnt[1][i];\n\t\t\tif(cnt[0][2*h-i]<0){\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcnt[1][i] = 0;\n\t\t\tuf.unit(2*h-i,i+500);\n\t\t}\n\t}\n\t\n\tstatic int siz[1002] = {},CNT[1002] = {};\n\trep(i,1002){\n\t\tsiz[uf.find(i)] ++;\n\t\tif(h < i && i <= 2*h)CNT[uf.find(i)] += cnt[0][i];\n\t}\n\trep(i,1002){\n\t\tif(siz[i] > 1 && CNT[i] <= 0){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\ntemplate<int SZ> struct DSU {\n    int par[SZ], sz[SZ];\n    DSU() {\n        F0R(i,SZ) par[i] = i, sz[i] = 1;\n    }\n    \n    int get(int x) { // path compression\n    \tif (par[x] != x) par[x] = get(par[x]);\n    \treturn par[x];\n    }\n    \n    bool unite(int x, int y) { // union-by-rank\n    \tx = get(x), y = get(y);\n    \tif (x == y) return 0;\n    \tif (sz[x] < sz[y]) swap(x,y);\n    \tsz[x] += sz[y], par[y] = x;\n    \treturn 1;\n    }\n};\n\nDSU<401> DD;\n\nint N,H, deg[401];\nbool existsNeg[401], involve[401], unbalanced[401];\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N >> H;\n    F0R(i,N) {\n        int A,B,C,D; cin >> A >> B >> C >> D;\n        if (C == 0) C = -A;\n        if (D == 0) D = -B;\n        deg[200+C] ++, deg[200-D] --;\n        involve[200+C] = involve[200-D] = 1;\n        // cout << \"HI \" << 200+C << \" \" << 200-D << \"\\n\";\n        DD.unite(200+C,200-D);\n    }\n    F0R(i,401) if (involve[i]) {\n        if (deg[i] != 0) {\n            if ((deg[i] > 0) ^ (i < 200)) {\n                cout << \"NO\";\n                exit(0);\n            }\n            if (deg[i] != 0) unbalanced[DD.get(i)] = 1;\n        }\n    }\n    F0R(i,401) if (involve[i] && !unbalanced[DD.get(i)]) {\n        cout << \"NO\";\n        exit(0);\n    }\n    cout << \"YES\";\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nL chk[100010];\n\nstruct S1{\n\tL a,b,c,d,ord;\n};\n\nbool operator<(S1 a,S1 b){\n\tif(a.c==b.c) return a.ord<b.ord;\n\treturn a.c<b.c;\n}\n\nbool operator==(S1 a,S1 b){\n\treturn a.c==b.c&&a.a==b.a&&a.b==b.b&&a.d==b.d&&a.ord==b.ord;\n}\nstruct S2{\n\tL a,b,c,d,ord;\n};\n\nbool operator<(S2 a,S2 b){\n\tif(a.d==b.d) return a.ord<b.ord;\n\treturn a.d<b.d;\n}\n\nbool operator==(S2 a,S2 b){\n\treturn a.c==b.c&&a.a==b.a&&a.b==b.b&&a.d==b.d&&a.ord==b.ord;\n}\n\nstruct S3{\n\tL a,b,c,d,ord;\n};\n\nbool operator<(S3 a,S3 b){\n\tif(a.a+a.c==b.a+b.c) return a.ord<b.ord;\n\treturn a.a+a.c<b.a+b.c;\n}\n\nbool operator==(S3 a,S3 b){\n\treturn a.c==b.c&&a.a==b.a&&a.b==b.b&&a.d==b.d&&a.ord==b.ord;\n}\nstruct S4{\n\tL a,b,c,d,ord;\n};\n\nbool operator<(S4 a,S4 b){\n\tif(a.b+a.d==b.b+b.d) return a.ord<b.ord;\n\treturn a.b+a.d<b.b+b.d;\n}\n\nbool operator==(S4 a,S4 b){\n\treturn a.c==b.c&&a.a==b.a&&a.b==b.b&&a.d==b.d&&a.ord==b.ord;\n}\n\nL n,h;\n\nmultiset<S1>s1;\nmultiset<S2>s2;\nmultiset<S3>s3,lef,goodlef;\nmultiset<S4>s4,rig,goodrig;\n\nL aa[100010],bb[100010],cc[100010],dd[100010];\n\nvoid E(){\n\tputs(\"NO\");\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&h);\n\tL i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL a,b,c,d;\n\t\tscanf(\"%lld %lld %lld %lld\",&a,&b,&c,&d);\n\t\taa[i]=a;\n\t\tbb[i]=b;\n\t\tcc[i]=c;\n\t\tdd[i]=d;\n\t\tif(c+d==0)\n\t\t{\n\t\t\tgoodlef.insert((S3){a,b,c,d,i});\n\t\t\tgoodrig.insert((S4){a,b,c,d,i});\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts1.insert((S1){a,b,c,d,i});\n\t\t\ts2.insert((S2){a,b,c,d,i});\n\t\t\ts3.insert((S3){a,b,c,d,i});\n\t\t\ts4.insert((S4){a,b,c,d,i});\n\t\t\tif(c==0)\n\t\t\t{\n\t\t\t\tlef.insert((S3){a,b,c,d,i});\n\t\t\t}\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\trig.insert((S4){a,b,c,d,i});\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"sizes %lld %lld %lld %lld\\n\",s1.size(),s2.size(),s3.size(),s4.size());\n\t\t\t\n\t//printf(\"%lld %lld\\n\",goodlef.size(),goodrig.size());\n\twhile(!goodlef.empty())\n\t{\n\t\tset<S3>::iterator it=goodlef.begin();\n\t\t//printf(\"%lld %lld %lld %lld %lld\\n\",it->a,it->b,it->c,it->d,it->ord);\n\t\tS3 temp=*it;\n\t\tgoodlef.erase(it);\n\t\tgoodrig.erase((S4){it->a,it->b,it->c,it->d,it->ord});\n\t\t//printf(\"%lld %lld\\n\",goodlef.size(),goodrig.size());\n\t\tL a=temp.a;\n\t\tL b=temp.b;\n\t\tL c=temp.c;\n\t\tL d=temp.d;\n\t\twhile(1)\n\t\t{\n\t\t\t//printf(\"%lld %lld %lld %lld\\n\",a,b,c,d);\n\t\t\tL oknext=0;\n\t\t\tif(c==0)\n\t\t\t{\n\t\t\t\tset<S2>::iterator fin=s2.lower_bound((S2){0,0,0,a,0});\n\t\t\t\tif(fin!=s2.end()&&fin->d==a)\n\t\t\t\t{\n\t\t\t\t\toknext=1;\n\t\t\t\t\ta=fin->a;\n\t\t\t\t\tc=fin->c;\n\t\t\t\t\tL era=fin->a;\n\t\t\t\t\tL erb=fin->b;\n\t\t\t\t\tL erc=fin->c;\n\t\t\t\t\tL erd=fin->d;\n\t\t\t\t\tL ero=fin->ord;\n\t\t\t\t\ts1.erase((S1){era,erb,erc,erd,ero});\n\t\t\t\t\ts2.erase((S2){era,erb,erc,erd,ero});\n\t\t\t\t\ts3.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\ts4.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\tlef.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\trig.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tset<S4>::iterator fin=rig.lower_bound((S4){0,c,0,0,0});\n\t\t\t\tif(fin!=rig.end()&&fin->b==c)\n\t\t\t\t{\n\t\t\t\t\toknext=1;\n\t\t\t\t\ta=fin->a;\n\t\t\t\t\tc=fin->c;\n\t\t\t\t\tL era=fin->a;\n\t\t\t\t\tL erb=fin->b;\n\t\t\t\t\tL erc=fin->c;\n\t\t\t\t\tL erd=fin->d;\n\t\t\t\t\tL ero=fin->ord;\n\t\t\t\t\ts1.erase((S1){era,erb,erc,erd,ero});\n\t\t\t\t\ts2.erase((S2){era,erb,erc,erd,ero});\n\t\t\t\t\ts3.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\ts4.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\tlef.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\trig.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!oknext)\n\t\t\t{\n\t\t\t\tif(d==0)\n\t\t\t\t{\n\t\t\t\t\tset<S1>::iterator fin=s1.lower_bound((S1){0,0,b,0,0});\n\t\t\t\t\tif(fin!=s1.end()&&fin->c==b)\n\t\t\t\t\t{\n\t\t\t\t\t\toknext=1;\n\t\t\t\t\t\tb=fin->b;\n\t\t\t\t\t\td=fin->d;\n\t\t\t\t\t\tL era=fin->a;\n\t\t\t\t\t\tL erb=fin->b;\n\t\t\t\t\t\tL erc=fin->c;\n\t\t\t\t\t\tL erd=fin->d;\n\t\t\t\t\t\tL ero=fin->ord;\n\t\t\t\t\t\ts1.erase((S1){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts2.erase((S2){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts3.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts4.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\t\tlef.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\t\trig.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tset<S3>::iterator fin=lef.lower_bound((S3){d,0,0,0,0});\n\t\t\t\t\tif(fin!=lef.end()&&fin->a==d)\n\t\t\t\t\t{\n\t\t\t\t\t\toknext=1;\n\t\t\t\t\t\tb=fin->b;\n\t\t\t\t\t\td=fin->d;\n\t\t\t\t\t\tL era=fin->a;\n\t\t\t\t\t\tL erb=fin->b;\n\t\t\t\t\t\tL erc=fin->c;\n\t\t\t\t\t\tL erd=fin->d;\n\t\t\t\t\t\tL ero=fin->ord;\n\t\t\t\t\t\ts1.erase((S1){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts2.erase((S2){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts3.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts4.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\t\tlef.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\t\trig.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"sizes %lld %lld %lld %lld\\n\",s1.size(),s2.size(),s3.size(),s4.size());\n\t\t\t\n\t\t\t\t\n\t\t\tif(!oknext)\n\t\t\t{\n\t\t\t\t//printf(\"not okay \");\n\t\t\t\tif(c+d==0) break;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(c!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tset<S4>::iterator fin=goodrig.lower_bound((S4){0,c,0,0,0});\n\t\t\t\t\t\tif(fin!=goodrig.end()&&fin->b==c)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta=fin->a;\n\t\t\t\t\t\t\tc=fin->c;\n\t\t\t\t\t\t\tL era=fin->a;\n\t\t\t\t\t\t\tL erb=fin->b;\n\t\t\t\t\t\t\tL erc=fin->c;\n\t\t\t\t\t\t\tL erd=fin->d;\n\t\t\t\t\t\t\tL ero=fin->ord;\n\t\t\t\t\t\t\tgoodlef.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\t\t\tgoodrig.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse E();\n\t\t\t\t\t}\n\t\t\t\t\tif(d!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tset<S3>::iterator fin=goodlef.lower_bound((S3){d,0,0,0,0});\n\t\t\t\t\t\tif(fin!=goodlef.end()&&fin->a==d)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb=fin->b;\n\t\t\t\t\t\t\td=fin->d;\n\t\t\t\t\t\t\tL era=fin->a;\n\t\t\t\t\t\t\tL erb=fin->b;\n\t\t\t\t\t\t\tL erc=fin->c;\n\t\t\t\t\t\t\tL erd=fin->d;\n\t\t\t\t\t\t\tL ero=fin->ord;\n\t\t\t\t\t\t\tgoodlef.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\t\t\tgoodrig.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse E();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(s1.empty()) puts(\"YES\");\n\telse puts(\"NO\");\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N, H;\nvector<int> vertex;\nint degree[1000];\nint v1[105000], v2[105000];\nbool can[1000];\nint main() {\n    cin >> N >> H;\n    UnionFind uni(3 * H);\n    for(int i = 0; i < N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        if(c == 0) v1[i] = a;\n        else v1[i] = H + c;\n        if(d == 0) v2[i] = H + b;\n        else v2[i] = d;\n        degree[v1[i]]--;\n        degree[v2[i]]++;\n        uni.merge(v1[i], v2[i]);\n        vertex.push_back(v1[i]);\n        vertex.push_back(v2[i]);\n        cerr << v1[i] << \" \" << v2[i] << endl;\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            can[v1[i]] = true;\n        }\n    }\n    sort(vertex.begin(), vertex.end());\n    vertex.erase(unique(vertex.begin(), vertex.end()), vertex.end());\n    map<int, vector<int>> mp;\n    for(auto v : vertex) {\n        /*\n        if(!uni.issame(v, vertex[0])) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        */\n        mp[uni.root(v)].push_back(v);\n    }\n    cerr << \"sz: \" << mp.size() << endl;\n    for(auto tmp : mp) {\n        /*\n        for(auto v : tmp.second) {\n            cerr << v << \" \";\n        }\n        cerr << endl;\n        */\n        vector<int> s, t;\n        for(auto v : tmp.second) {\n            if(degree[v] < 0) s.push_back(v);\n            if(degree[v] > 0) t.push_back(v);\n        }\n        if(s.empty()) {\n            assert(t.empty());\n            bool ok = false;\n            for(auto v : tmp.second) {\n                ok |= can[v];\n            }\n            if(!ok) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        } else {\n            //if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n            for(auto v : s) {\n                if(v >= H + 1) {\n                    cout << \"NO\" << endl;\n                    return 0;\n                }\n            }\n            for(auto v : t) {\n                if(v <= H) {\n                    cout << \"NO\" << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n    /*\n    int s = -1, t = -1;\n    for(auto v : vertex) {\n        if(abs(degree[v]) >= 2) {\n            cout << \"NO\" << endl;\n            cerr << \"DEGREE\" << endl;\n            return 0;\n        }\n        if(degree[v] == 1) {\n            if(t != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"T\" << endl;\n                return 0;\n            } else {\n                t = v;\n            }\n        }\n        if(degree[v] == -1) {\n            if(s != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"S\" << endl;\n                cerr << s << \" \" << v << endl;\n                return 0;\n            } else {\n                s = v;\n            }\n        }\n    }\n    if(s != -1) {\n        assert(t != -1);\n        if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n    }\n    for(int i = 0; i < N; i++) {\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    }\n    cout << \"NO\" << endl;\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define rs (x<<1|1)\n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=2e2+5;\nint n,h;\nmultiset<int>dd1[maxn],dd2[maxn],uu1[maxn],uu2[maxn],ud[maxn],du[maxn];\nmultiset<int>nud[maxn],ndu[maxn];\ntypedef multiset<int>::iterator It;\nint main(){\n\tread(n);read(h);\n\trep(i,1,n){\n\t\tint a,b,c,d;read(a);read(b);read(c);read(d);\n\t\tif(!c){\n\t\t\tif(!d)dd1[a].insert(b),dd2[b].insert(a);\n\t\t\telse du[a].insert(d);\n\t\t}else{\n\t\t\tif(!d)ud[b].insert(c);\n\t\t\telse uu1[c].insert(d),uu2[d].insert(c);\n\t\t}\n\t}\t\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(ud[i])){\n\t\t\tflag=1;\n\t\t\tIt it=ud[i].begin();\n\t\t\tud[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(ud[x])){\n\t\t\t\tIt it2=ud[x].begin();\n\t\t\t\tud[x].erase(it2);\n\t\t\t\tud[i].insert(*it2);\n\t\t\t}else nud[i].insert(*it);\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(du[i])){\n\t\t\tflag=1;\n\t\t\tIt it=du[i].begin();\n\t\t\tdu[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(du[x])){\n\t\t\t\tIt it2=du[x].begin();\n\t\t\t\tdu[x].erase(it2);\n\t\t\t\tdu[i].insert(*it2);\n\t\t\t}else ndu[i].insert(*it);\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(nud[i])){\n\t\t\tflag=1;\n\t\t\tIt it=nud[i].begin();\n\t\t\tnud[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(dd2[x])){\n\t\t\t\tIt it2=dd2[x].begin();\n\t\t\t\tdd2[x].erase(it2);\n\t\t\t\tdd1[*it2].erase(dd1[*it2].find(x));\n\t\t\t\tdd1[*it2].insert(i);\n\t\t\t\tdd2[i].insert(*it2);\n\t\t\t}else{\n\t\t\t\treturn puts(\"NO\"),0;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(ndu[i])){\n\t\t\tflag=1;\n\t\t\tIt it=ndu[i].begin();\n\t\t\tndu[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(dd1[x])){\n\t\t\t\tIt it2=dd1[x].begin();\n\t\t\t\tdd1[x].erase(it2);\n\t\t\t\tdd2[*it2].erase(dd2[*it2].find(x));\n\t\t\t\tdd2[*it2].insert(i);\n\t\t\t\tdd1[i].insert(*it2);\n\t\t\t}else{\n\t\t\t\treturn puts(\"NO\"),0;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tint flag=0;\n\t\trep(i,1,h)if(SZ(dd1[i])>SZ(uu2[i])){\n\t\t\tflag=1;\n\t\t\tIt it=dd1[i].begin();\n\t\t\tdd1[i].erase(it);\n\t\t\tdd2[*it].erase(dd2[*it].find(i));\n\t\t\tint x=*it;\n\t\t\tif(SZ(uu1[x])){\n\t\t\t\tIt it2=uu1[x].begin();\n\t\t\t\tuu1[x].erase(it2);\n\t\t\t\tuu2[*it2].erase(uu2[*it2].find(x));\n\t\t\t\tif(SZ(dd1[*it2])){\n\t\t\t\t\tIt it3=dd1[*it2].begin();\n\t\t\t\t\tdd1[*it2].erase(it3);\n\t\t\t\t\tdd2[*it3].erase(dd2[*it3].find(*it2));\n\t\t\t\t\tdd1[i].insert(*it3);\n\t\t\t\t\tdd2[*it3].insert(i);\n\t\t\t\t}else return puts(\"NO\"),0;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\trep(i,1,h)if(SZ(dd1[i]))return puts(\"NO\"),0;\n\trep(i,1,h)if(SZ(uu1[i]))return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nconst int INF=5e8;\n\n//const int INF=5e8;\nint n,H;\npair<pi,pi> ar[100005];\nvoid ng(){\n  puts(\"NO\");\n  exit(0);\n}\nvector<int> g[100005];\n/*\nvector<int> idL[205],idR[205];\n\nbool vis[100005];\n\n\nvoid dfs(int v,int p){\n  dump(v);\n  if(vis[v]) ng();\n  vis[v]=1;\n  for(auto to:g[v]){\n    if(to==p) continue;\n    dfs(to,v);\n  }\n}\n*/\n\nstruct uf{\n\n  static const int MAXN=405;\n  int par[MAXN];\n  int size[MAXN];\n  void init(){\n    memset(par,-1,sizeof(par));\n    REP(i,MAXN) size[i]=1;\n  }\n  int root(int a){\n    if(par[a]==-1) return a;\n    return par[a]=root(par[a]);\n  }\n  void unite(int a,int b){\n    a=root(a);b=root(b);\n    if(a==b) return;\n    if(size[a]<size[b]) swap(a,b);\n\n    par[b]=a;\n    size[a]+=size[b];\n  }\n  bool same(int a,int b){\n    return root(a)==root(b);\n  }\n};\n\nuf u;\nint indeg[100005],outdeg[100005];\n\nint dif[100005];\nint mn[405],mx[405];\nint main(){\n  cin>>n>>H;\n  ++H;\n  u.init();\n  REP(i,n){\n    int a,b,c,d;scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    ar[i]={{a,b},{c,d}};\n    //if(c==0) idL[a].pb(i);\n    //if(d==0) idR[b].pb(i);\n\n    int from,to;\n    if(c==0) from=H+a;\n    else from=c;\n\n    if(d==0) to=b;\n    else to=H+d;\n    ++indeg[to];\n    ++outdeg[from];\n    g[from].pb(to);\n    u.unite(from,to);\n    if(from<H && to>=H) --dif[from];\n    else if(from>=H && to<=H) ++dif[from];\n  }\n  REP(i,H){\n    if(indeg[i]<outdeg[i]) ng();\n    if(indeg[i+H]>outdeg[i+H]) ng();\n  }\n  REP(i,H*2) mn[i]=mx[i]=i;\n  REP(i,H*2) if(u.root(i)!=i){\n    dif[u.root(i)]+=dif[i];\n    chmax(mx[u.root(i)],i);\n    chmin(mn[u.root(i)],i);\n  }\n  REP(i,H*2) if(u.root(i)==i && indeg[i]+outdeg[i]>0){\n    //assert(dif[i]>=0);\n    if(dif[i]<=0) ng();\n  }\n  puts(\"YES\");\n/*\n  REP(i,n){\n    int a=ar[i].fr.fr,b=ar[i].fr.sc,c=ar[i].sc.fr,d=ar[i].sc.sc;\n    if(c>0){\n      if(idR[c].empty()) ng();\n      int to=idR[c].back();\n      idR[c].pop_back();\n      g[i].pb(to);\n      g[to].pb(i);\n    }\n    if(d>0){\n      if(idL[d].empty()) ng();\n      int to=idL[d].back();\n      idL[d].pop_back();\n      g[i].pb(to);\n      g[to].pb(i);\n    }\n  }\n  prl;\n  REP(i,n) assert(g[i].size()<=2);\n  REP(i,n) if(!vis[i]){\n    dfs(i,-1);\n  }\n  */\n\n // puts(\"YES\");\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=512;\nconst int zero=250;\nint fa[maxn],siz[maxn],oud[maxn],ind[maxn];\nbool h[maxn];\nint find(int k)\n{\n\tif(fa[k]!=k)fa[k]=find(fa[k]);\n\treturn fa[k];\n}\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n\treturn x;\n}\ninline void merge(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y){++siz[x];return;}\n    fa[x]=y;siz[y]+=siz[x] + 1;\n}\nint main(){\n    int n,H;n=read();H=read();\n    for(int i=1;i<=H;i++)  fa[i+zero]= i+zero,siz[i+zero]= 1;\n    for(int i=-H;i<=-1;i++)fa[i+zero]= i+zero,siz[i+zero]= 1;\n    int a,b,c,d;\n    for(int i=1;i<=n;i++){\n        int x,y;\n        a=read();b=read();c=read();d=read();\n        if(c==0)x=a;else x=-c;\n        if(d==0)y=-b;else y=d;\n        ++oud[x+ zero];++ ind[y + zero];\n        merge(x+zero,y+zero);\n    }\n    for(int i=1;i<=H;i++)  if(oud[i+zero]<ind[i+zero])return puts(\"NO\"),0;\n    for(int i=-H;i<=-1;i++)if(ind[i+zero]<oud[i+zero])return puts(\"NO\"),0;\n    for(int i=1;i<=H;i++)  h[find(i+zero)]|=(ind[i+zero]!=oud[i+zero]);\n    for(int i=-H;i<=-1;i++)h[find(i+zero)]|=(ind[i+zero]!=oud[i+zero]);\n    for(int i=1;i<=H;i++)  if(siz[find(i+zero)]>1&&(find(i+zero)==i+zero)&&(h[i+zero]==false))return puts(\"NO\"),0;\n    for(int i=-H;i<=-1;i++)if(siz[find(i+zero)]>1&&(find(i+zero)==i+zero)&&(h[i+zero]==false))return puts(\"NO\"),0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, H;\nstruct Jigsaw {\n    int a, b, c, d;\n};\nvector<Jigsaw> jig;\nvector<vector<int> > adj;\nvector<vector<int> > adj2;\nvector<int> ind, outd;\n\nint mn, mx;\nvector<int> vis;\n\nvoid dfs(int u) {\n    vis[u] = 1;\n    mn = min(mn, ind[u] - outd[u]);\n    mx = max(mx, ind[u] - outd[u]);\n    for(int i = 0; i < adj2[u].size(); i++) {\n        int v = adj2[u][i];\n        if(vis[v]) continue;\n        dfs(v);\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &H);\n\n    jig.resize(N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d %d %d\", &jig[i].a, &jig[i].b, &jig[i].c, &jig[i].d);\n    }\n\n    adj.resize(2*H + 1);\n    adj2.resize(2*H + 1);\n\n    for(int i = 0; i < N; i++) {\n        adj[ (jig[i].c? jig[i].c : H + jig[i].a) ].push_back( (jig[i].d? H + jig[i].d : jig[i].b) );\n\n        adj2[ (jig[i].c? jig[i].c : H + jig[i].a) ].push_back( (jig[i].d? H + jig[i].d : jig[i].b) );\n        adj2[ (jig[i].d? H + jig[i].d : jig[i].b) ].push_back( (jig[i].c? jig[i].c : H + jig[i].a) );\n    }\n\n    ind = vector<int>(2*H + 1, 0);\n    outd = vector<int>(2*H + 1, 0);\n\n    for(int i = 0; i < 2*H + 1; i++) {\n        for(int j = 0; j < adj[i].size(); j++) {\n            int k = adj[i][j];\n\n            outd[i]++;\n            ind[k]++;\n        }\n    }\n\n    for(int i = 0; i < H; i++) {\n        if(ind[i] < outd[i]) {\n            printf(\"NO\");\n            return 0;\n        }\n    }\n    for(int i = H + 1; i <= 2*H; i++) {\n        if(ind[i] > outd[i]) {\n            printf(\"NO\");\n            return 0;\n        }\n    }\n\n    vis = vector<int>(2*H + 1, 0);\n    for(int i = 0; i < 2*H + 1; i++) if(!vis[i] && adj[i].size()) {\n        mn = mx = 0;\n        dfs(i);\n        if(mn == 0 && mx == 0) {\n            printf(\"NO\");\n            return 0;\n        }\n    }\n\n    printf(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tsrand(clock());\n\tint x = rand()%2;\n\tcout << (x ? \"YES\" : \"NO\") << \"\\n\";\n\treturn 0;\n}\n// -_______-"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define neko 100010\n#define heko 410\n#define qwq return printf(\"YES\"),0; \n#define orz return printf(\"NO\"),0; \n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))\nstatic int n,H;\ntypedef int arr[heko];\narr fa,book,dgi,dgo,out;\nnamespace IO\n{\n\tconst unsigned int bufsize=1<<16,outsize=1<<24;\n\tstatic char ch[bufsize],*S=ch,*T=ch;\n\tinline char getc()\n\t{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\n\tstatic char Out[outsize],*nowp=Out;\n\tinline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\n\t\tvoid read(T &x)\n\t\t{\n\t\t\tchar c=getc();x=0;\n\t\t\tfor(;!isdigit(c);c=getc());\n\t\t\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n\t\t}\n\ttemplate<typename T>\n\t\tvoid write(T x,char c='\\n')\n\t\t{\n\t\t\tif(!x)*nowp++='0';\n\t\t\tstatic unsigned int stk[50],tp=0;\n\t\t\tfor(;x;x/=10)stk[++tp]=x%10;\n\t\t\tfor(;tp;*nowp++=stk[tp--]^'0');*nowp++=c;\n\t\t}\n}\nint find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}\nint main()\n{\n\tusing namespace IO;\n\tint x,y,z,o,X,Y;\n\tread(n),read(H);\n\tf(i,0,H<<1)fa[i]=i;\n\tf(i,1,n)\n\t{\n\t\tread(x),read(y),read(z),read(o);\n\t\tif(z==0)X=H+x;\n\t\telse X=H-z;\n\t\tif(o==0)Y=H-y;\n\t\telse Y=H+o;\n\t\tbook[X]=book[Y]=1;\n\t\t++dgi[Y],++dgo[X];\n\t\tfa[find(Y)]=find(X);\n\n\t}\n\tf(i,0,H)if(dgi[i]<dgo[i])orz;\n\tf(i,H+1,H<<1)if(dgi[i]>dgo[i])orz;\n\tf(i,0,H<<1)out[fa[i]]|=(dgi[i]^dgo[i]);\n\tf(i,0,H<<1)if(book[i]&&!out[fa[i]])orz;\n\tqwq;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MaxN=100010,MaxH=210;\nint N,H;\nstruct edge{int to;edge*next;}E[MaxN*2],*ne=E,*fir[MaxH*2];\nvoid link(int u,int v){*ne=(edge){v,fir[u]};fir[u]=ne++;}\nint deg[MaxH*2],Q[MaxH*2];\nbool vis[MaxH*2];\nint main(){\n\tscanf(\"%d%d\",&N,&H);\n\tfor(int i=0;i<N;i++){\n\t\tint A,B,C,D;\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tA=C?C+H:A;\n\t\tB=D?D:B+H;\n\t\tlink(A,B);link(B,A);\n\t\tdeg[A]++;deg[B]--;\n\t}\n\tfor(int i=1;i<=H*2;i++)if(!vis[i]&&fir[i]){\n\t\tbool fl=1,ex=0;\n\t\tint*h=Q,*t=Q;\n\t\tvis[*t++=i]=1;\n\t\tfor(;h<t;h++){\n\t\t\tif(*h<=H&&deg[*h])ex=1,deg[*h]<0?fl=0:1;\n\t\t\tif(*h>H&&deg[*h])ex=1,deg[*h]>0?fl=0:1;\n\t\t\tfor(edge*e=fir[*h];e;e=e->next)\n\t\t\t\tif(!vis[e->to])vis[*t++=e->to]=1;\n\t\t}\n\t\tif(!fl||!ex)return puts(\"NO\"),0;\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\nusing pii = pair<int, int>;\nusing tiiii = tuple<int, int, int, int>;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, h;\n\tcin >> n >> h;\n\tvector<tiiii> pieces;\n\tfor(int i = 0; i < n; ++i){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tpieces.emplace_back(c, a, d, b);\n\t}\n\tsort(pieces.begin(), pieces.end());\n\tmap<pii, pii> ranges;\n\tfor(int i = 0; i < n; ){\n\t\tconst int c = get<0>(pieces[i]), a = get<1>(pieces[i]);\n\t\tint j = i;\n\t\tif(c == 0){\n\t\t\twhile(j < n && get<0>(pieces[j]) == 0 && get<1>(pieces[j]) == a){\n\t\t\t\t++j;\n\t\t\t}\n\t\t}else{\n\t\t\twhile(j < n && get<0>(pieces[j]) == c){ ++j; }\n\t\t}\n\t\tranges.emplace(pii(c, c == 0 ? a : 0), pii(i, j));\n\t\ti = j;\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tconst int d = get<2>(pieces[i]), b = get<3>(pieces[i]);\n\t\tif(d == 0){\n\t\t\tranges.emplace(pii(b, 0), pii(0, 0));\n\t\t}else{\n\t\t\tranges.emplace(pii(0, d), pii(0, 0));\n\t\t}\n\t}\n\tvector<pair<pii, pii>> v_ranges(ranges.begin(), ranges.end());\n\tconst int m = v_ranges.size();\n\tvector<int> in_deg(m), out_deg(m);\n\tvector<vector<int>> conn(n + m);\n\tfor(int i = 0; i < m; ++i){\n\t\tconst auto r = v_ranges[i].second;\n\t\tfor(int j = r.first; j < r.second; ++j){\n\t\t\tconn[n + i].push_back(j);\n\t\t\tconn[j].push_back(n + i);\n\t\t\t++out_deg[i];\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tconst int d = get<2>(pieces[i]), b = get<3>(pieces[i]);\n\t\tpii key(0, 0);\n\t\tif(d == 0){\n\t\t\tkey.first = b;\n\t\t}else{\n\t\t\tkey.second = d;\n\t\t}\n\t\tconst auto it = lower_bound(\n\t\t\tv_ranges.begin(), v_ranges.end(), make_pair(key, pii(0, 0)));\n\t\tconst int j = it - v_ranges.begin();\n\t\tconn[i].push_back(n + j);\n\t\tconn[n + j].push_back(i);\n\t\t++in_deg[j];\n\t}\n\tbool answer = true;\n\tvector<bool> done(n + m);\n\tfor(int i = 0; i < n; ++i){\n\t\tif(done[i]){ continue; }\n\t\tint in_over = 0, out_over = 0;\n\t\tqueue<int> q;\n\t\tq.push(i);\n\t\tdone[i] = true;\n\t\twhile(!q.empty()){\n\t\t\tconst int u = q.front();\n\t\t\tq.pop();\n\t\t\tif(u >= n){\n\t\t\t\tconst int k = u - n;\n\t\t\t\tconst auto r = v_ranges[k].first;\n\t\t\t\tif(r.first == 0){\n\t\t\t\t\tif(out_deg[k] < in_deg[k]){\n\t\t\t\t\t\tanswer = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tout_over += out_deg[k] - in_deg[k];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(in_deg[k] < out_deg[k]){\n\t\t\t\t\t\tanswer = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tin_over += in_deg[k] - out_deg[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(const auto& v : conn[u]){\n\t\t\t\tif(done[v]){ continue; }\n\t\t\t\tdone[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\tif(in_over != out_over || in_over == 0){ answer = false; }\n\t}\n\tcout << (answer ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//84104971101048411497 - Can you guess what does this mean?\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> point;\n#define mapii map<int, int>\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define forit(it, var) for(__typeof(var.begin()) it = var.begin(); it != var.end(); it++)\n#define forrit(rit, var) for(__typeof(var.rbegin()) rit = var.rbegin(); rit != var.rend(); rit++)\n#define ii pair<int, int>\n#define iii pair<int, ii>\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define maxN 100005\n#define maxH 205\n#define oo 2000000007\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nint n, H, degIn[2][maxH], degOut[2][maxH], cnt, vtxCnt;\nvector<ii> g[2][maxH];\nbool visited[2][maxN];\n\nbool DFS(int i, int h) {\n//    printf(\"%d %d\\n\", i, h);\n    ++vtxCnt;\n    if (degIn[i][h] != degOut[i][h]) ++cnt;\n    visited[i][h] = true;\n    for(ii p: g[i][h]) {\n        if (!visited[p.ff][p.ss]) DFS(p.ff, p.ss);\n    }\n}\n\nbool Solve() {\n//    fto(i, 0, 1) fto(j, 1, H) printf(\"%d %d %d %d\\n\", i, j, degIn[i][j], degOut[i][j]);\n    fto(h, 1, H) {\n        if (degIn[0][h] > degOut[0][h]) return false;\n        if (degIn[1][h] < degOut[1][h]) return false;\n    }\n    fto(i, 0, 1) {\n        fto(h, 1, H) {\n            if (!visited[i][h]) {\n                vtxCnt = cnt = 0;\n                DFS(i, h);\n                if (vtxCnt > 1 && cnt == 0) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main () {\n    scanf(\"%d%d\", &n, &H);\n    fto(i, 1, n) {\n        int A, B, C, D;\n        scanf(\"%d%d%d%d\", &A, &B, &C, &D);\n\n        ii u, v;\n        if (C == 0) u = mp(0, A);\n        else u = mp(1, C);\n        if (D == 0) v = mp(1, B);\n        else v = mp(0, D);\n\n        ++degOut[u.ff][u.ss]; ++degIn[v.ff][v.ss];\n        g[u.ff][u.ss].pb(mp(v.ff, v.ss));\n        g[v.ff][v.ss].pb(mp(u.ff, u.ss));\n    }\n\n    puts((Solve()) ? \"YES\" : \"NO\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N, H;\nvector<int> vertex;\nint degree[1000];\nint v1[105000], v2[105000];\nbool can[1000];\nint main() {\n    cin >> N >> H;\n    cerr << N << \" \" << H << endl;\n    UnionFind uni(3 * H);\n    for(int i = 0; i < N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        cerr << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        if(c == 0) v1[i] = a;\n        else v1[i] = H + c;\n        if(d == 0) v2[i] = H + b;\n        else v2[i] = d;\n        degree[v1[i]]--;\n        degree[v2[i]]++;\n        uni.merge(v1[i], v2[i]);\n        vertex.push_back(v1[i]);\n        vertex.push_back(v2[i]);\n        //cerr << v1[i] << \" \" << v2[i] << endl;\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            can[v1[i]] = true;\n        }\n    }\n    sort(vertex.begin(), vertex.end());\n    vertex.erase(unique(vertex.begin(), vertex.end()), vertex.end());\n    map<int, vector<int>> mp;\n    for(auto v : vertex) {\n        /*\n        if(!uni.issame(v, vertex[0])) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        */\n        mp[uni.root(v)].push_back(v);\n    }\n    cerr << \"sz: \" << mp.size() << endl;\n    for(auto tmp : mp) {\n        /*\n        for(auto v : tmp.second) {\n            cerr << v << \" \";\n        }\n        cerr << endl;\n        */\n        vector<int> s, t;\n        for(auto v : tmp.second) {\n            if(degree[v] < 0) s.push_back(v);\n            if(degree[v] > 0) t.push_back(v);\n        }\n        if(s.empty()) {\n            assert(t.empty());\n            bool ok = false;\n            for(auto v : tmp.second) {\n                ok |= can[v];\n            }\n            if(!ok) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        } else {\n            //if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n            for(auto v : s) {\n                if(v >= H + 1) {\n                    cout << \"NO\" << endl;\n                    return 0;\n                }\n            }\n            for(auto v : t) {\n                if(v <= H) {\n                    cout << \"NO\" << endl;\n                    assert(0);\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n    /*\n    int s = -1, t = -1;\n    for(auto v : vertex) {\n        if(abs(degree[v]) >= 2) {\n            cout << \"NO\" << endl;\n            cerr << \"DEGREE\" << endl;\n            return 0;\n        }\n        if(degree[v] == 1) {\n            if(t != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"T\" << endl;\n                return 0;\n            } else {\n                t = v;\n            }\n        }\n        if(degree[v] == -1) {\n            if(s != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"S\" << endl;\n                cerr << s << \" \" << v << endl;\n                return 0;\n            } else {\n                s = v;\n            }\n        }\n    }\n    if(s != -1) {\n        assert(t != -1);\n        if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n    }\n    for(int i = 0; i < N; i++) {\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    }\n    cout << \"NO\" << endl;\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define nt(x) (x+h)\nnamespace Hao_Nan_A___Wo_Bu_Hui_A___Wo_Hao_Ruo_A\n{\n\tconst int N=101000,M=510;\n\tint begin[M],next[N],to[N];\n\tint ind[M],outd[M];\n\tint n,h,e;\n\tvoid add(int x,int y)\n\t{\n//\t\tprintf(\"%d -> %d\\n\",x,y);\n\t\tind[y]++;outd[x]++;\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d%d\",&n,&h);e=0;\n\t\tfor(int i=1;i<=h*2;i++)\n\t\t\tind[i]=outd[i]=0;\n\t\tfor(int i=1,A,B,C,D,u,v;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\t\tif(C)u=nt(C);else u=A;\n\t\t\tif(D)v=D;else v=nt(B);\n\t\t\tadd(u,v);\n\t\t}\n\t}\n\tbool check()\n\t{\n\t\tfor(int i=1;i<=h;i++)if(ind[i]>outd[i])return 0;\n\t\tfor(int i=1;i<=h;i++)if(ind[nt(i)]<outd[nt(i)])return 0;\n\t\tfor(int i=1;i<=h;i++)if(ind[i]!=outd[i])return 1;\n\t\treturn 0;\n\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tif(check())printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n}\nint main()\n{\n//\tfreopen(\"in\",\"r\",stdin);\n\tHao_Nan_A___Wo_Bu_Hui_A___Wo_Hao_Ruo_A::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\n\n\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint th = 0;\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, c[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st != e[401]||st>=e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\n\tbool exiroad[402][402] = {};\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tfill(chked, chked + 402, false);\n\t\tq.push(i); chked[i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front(); q.pop();\n\t\t\trep(j, G[x].size()) {\n\t\t\t\tint to = G[x][j];\n\t\t\t\tif (chked[to])continue;\n\t\t\t\tchked[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\trep(j, 402) {\n\t\t\tif (chked[j])exiroad[i][j] = true;\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tRep(j, i + 1, 402) {\n\t\t\tif (!exi[j])continue;\n\t\t\tif (!exiroad[i][j] || !exiroad[j][i]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=1e5+5;\nint n,h,cl[N],cr[N],d[N],fa[N],size[N];\nint getfa(int x){return fa[x]?fa[x]=getfa(fa[x]):x;}\nbool bz[N];\nvoid link(int u,int v)\n{\n\t--d[u],++d[v];\n\tint fu=getfa(u),fv=getfa(v);\n\tif(fu!=fv) fa[fv]=fu,size[fv]+=size[fu],size[fu]=0;\n}\nint main()\n{\n\tn=read(),h=read();\n\tfo(i,1,n)\n\t{\n\t\tint x,y,A=read(),B=read(),C=read(),D=read();\n\t\tif(C) x=-C;else x=A;\n\t\tif(D) y=D;else y=-B;\n\t\tx+=h,y+=h;\n\t\tlink(x,y);\n\t}\n\tfill(size,size+h+h+1,1);\n\tfo(i,0,h) if(d[i]<0) return puts(\"NO\"),0;\n\tfo(i,h+1,h+h) if(d[i]>0) return puts(\"NO\"),0;\n\tfo(i,0,h+h) if(d[i]) bz[i]=1;\n\tfo(i,0,h+h) bz[getfa(i)]|=bz[i];\n\tfo(i,0,h+h) if(size[i]>1 && !bz[i]) return puts(\"NO\"),0;\n\treturn puts(\"YES\"),0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include<iostream>\n    #include<cstring>\n    #include<cstdio>\n    using namespace std;\n    inline int read()\n    {\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n    }\n    int n,H,in[405],out[405],B[405],s[405],tote,size[405];\n    inline int getfa(int x){return s[x]?s[x]=getfa(s[x]):x;}\n    inline void Merge(int f,int t){if(getfa(f)!=getfa(t)) size[getfa(t)]+=size[getfa(f)],s[getfa(f)]=getfa(t);}\n    int main()\n    {\n    n=read();H=read();\n    for(int i=1;i<=n;++i)\n    {\n    int a=read(),b=read(),c=read(),d=read();\n    int f=c?c+H:a,t=d?d:b+H;\n    if(f==t) B[f]=1; else\n    {\n    ++out[f],++in[t];\n    Merge(f,t);++size[getfa(f)];++tote;\n    }\n    // cout<<f<<\" \"<<t<<endl;\n    }\n    int S=0;\n    for(int i=1;i<=H*2;++i)\n    {\n    // cout<<i<<\" \"<<in[i]<<\" \"<<out[i]<<endl;\n    if(B[i]&&!in[i]&&!out[i]) return 0*puts(\"NO\");\n    if(i> H&&out[i]>in[i]) return 0*puts(\"NO\");\n    if(i<=H&&out[i]<in[i]) return 0*puts(\"NO\");\n    if(out[i]!=in[i])\n    if(S) Merge(S,i);\n    else S=i;\n    }\n    if(!S||size[getfa(S)]!=tote) return 0*puts(\"NO\");\n    puts(\"YES\");\n    return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\nconst int N = 2e5L + 11, M = 211;\n\nbool v[N];\nint al[N];\nint ar[N];\n\nbool his[M * 3];\ndeque <int> sl[M * 3], sr[M * 3];\n\nint main() {\n\tios :: sync_with_stdio(0);\n\tint n, h; cin >> n >> h;\n\tfor(int i = 1; i <= n; i ++) {\n\t\tint a, b, c, d; cin >> a >> b >> c >> d;\n\t\tif(c) al[i] = -c; else al[i] = a;\n\t\tif(d) ar[i] = -d; else ar[i] = b;\n\n\t\tsl[al[i] + M].pb(i);\n\t\tsr[ar[i] + M].pb(i);\n\t}\n\twhile(1) {\n\t\tbool ch = 0;\n\t\tfor(int i = -h + M; i <= h + M; i ++) {\n\t\t\twhile(sl[i].size() && v[sl[i][0]]) sl[i].pop_front();\n\t\t\twhile(sr[i].size() && v[sr[i][0]]) sr[i].pop_front();\n\t\t}\n\t\tfor(int i = -h; i <= h; i ++) if(sr[i + M].size() && sl[-i + M].size()) {\n\t\t\tif(sr[i + M][0] == sl[-i + M][0]) {\n\t\t\t\tif(sr[i + M].size() > 1) {\n\t\t\t\t\tsr[i + M].pb(sr[i + M][0]);\n\t\t\t\t\tsr[i + M].pop_front();\n\t\t\t\t} else if(sl[-i + M].size() > 1) {\n\t\t\t\t\tsl[-i + M].pb(sl[-i + M][0]);\n\t\t\t\t\tsl[-i + M].pop_front();\n\t\t\t\t} else continue;\n\t\t\t\tch = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tch = 1;\n\t\t\this[i + M] = 1;\n\t\t\tn ++;\n\t\t\tv[sr[i + M][0]] = v[sl[-i + M][0]] = 1;\n\t\t\tal[n] = al[sr[i + M][0]];\n\t\t\tar[n] = ar[sl[-i + M][0]];\n\n\t\t\tsr[i + M].pop_front();\n\t\t\tsl[-i + M].pop_front();\n\n\t\t\tsl[al[n] + M].pb(n);\n\t\t\tsr[ar[n] + M].pb(n);\n\t\t\tbreak;\n\t\t}\n\n\t\tif(!ch) break;\n\t}\n\n\tbool f = 1, use_his = 0;\n\tint cnt = 0;\n\tfor(int i = 1; i <= n; i ++) if(!v[i]) {\n\t\t//cout << al[i] << ' ' << ar[i] << '\\n';\n\t\tif(al[i] > 0 && ar[i] > 0) {\n\t\t\tcnt ++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(al[i] + ar[i] == 0 && !his[-al[i] + M]) { f = 0; use_his = 1; }\n\t\tif(al[i] + ar[i] != 0) f = 0;\n\t}\n\tif(cnt == 0 && use_his) f = 0;\n\t//f &= (cnt == 1);\n\tcout << (f ? \"YES\" : \"NO\") << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef long long ll;\n#define N 200002\nstruct edge{int to,nxxt;}e[N<<1];\nint n,H,a[N][4],head[N],cnt=1,b[N][2],f[N],rd[N],cd[N],ct[N];\nvector<int>v[N];\ninline void ins(int u,int v){e[cnt].to=v;e[cnt].nxxt=head[u];head[u]=cnt++;}\nint getroot(int t){return f[t]==-1?t:f[t]=getroot(f[t]);}\nint main()\n{\n    scanf(\"%d%d\",&n,&H);\n    memset(f,-1,sizeof(f));\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d%d%d\",&a[i][0],&a[i][1],&a[i][2],&a[i][3]);\n        int x,y;\n        if(a[i][2]==0)x=a[i][0];else x=H+a[i][2];\n        if(a[i][3]==0)y=H+a[i][1];else y=a[i][3];\n        b[i][0]=x,b[i][1]=y;\n        printf(\"(%d %d)\\n\",x,y);\n        if(x==y)ct[x]++;\n        ins(x,y),rd[y]++,cd[x]++;\n        x=getroot(x);y=getroot(y);\n        if(x^y)f[x]=y;\n    }\n    for(int i=1;i<=2*H;i++)v[getroot(i)].push_back(i);\n    //for(int i=1;i<=2*H;i++)printf(\"%d \",getroot(i));puts(\"rt\");\n    //for(int i=1;i<=2*H;i++)printf(\"%d \",cd[i]);puts(\"cd\");\n    //for(int i=1;i<=2*H;i++)printf(\"%d \",rd[i]);puts(\"rd\");\n    for(int i=1;i<=2*H;i++)\n    {\n        bool flag=false;\n        if(v[i].size()==1){if(ct[v[i][0]]){puts(\"NO\");return 0;}}\n        if(v[i].size()<=1)continue;\n        //printf(\"%d:\",i);\n        for(int j=0;j<v[i].size();j++)\n        {\n            int x=v[i][j];\n            if(rd[x]^cd[x]){flag=true;break;}\n        }//puts(\"\");\n        if(!flag){puts(\"NO\");return 0;}\n    }\n    bool flag=true;\n    for(int i=1;i<=H;i++)\n    {\n        if(cd[i]<rd[i]){flag=false;break;}\n    }\n    for(int i=H+1;i<=2*H;i++)\n    {\n        if(rd[i]<cd[i]){flag=false;break;}\n    }\n    if(flag)puts(\"YES\");else puts(\"NO\");\n}\n/*\n3 4\n1 1 0 0\n2 2 0 1\n3 3 1 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b) - 1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\n\nconst int MAX = 1010;\n\nVI g[MAX];\nint IN[MAX];\nint OUT[MAX];\nbool U[MAX];\n\nint L, R;\n\nvoid no()\n{\n\tcout<<\"NO\"<<endl;\n\texit(0);\n}\n\nvoid dfs(int x)\n{\n\tU[x] = true;\n\n\tif (x & 1)\n\t{\n\t\tif (IN[x] > OUT[x]) no();\n\t\tR += IN[x] - OUT[x];\n\t}\n\telse\n\t{\n\t\tif (OUT[x] > IN[x]) no();\n\t\tL += OUT[x] - IN[x];\n\t}\n\n\tFOR (i, 0, SZ(g[x]))\n\t{\n\t\tint to = g[x][i];\n\t\tif (U[to]) continue;\n\t\tdfs(to);\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tFOR (i, 0, n)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\n\t\tint x, y;\n\t\tif (d == 0) y = b * 2;\n\t\telse y = d * 2 + 1;\n\n\t\tif (c == 0) x = a * 2 + 1;\n\t\telse x = c * 2;\n\n\t//\tcout<<x<<' '<<y<<endl;\n\t//\tcout<<a<<' '<<b<<' '<<c<<' '<<d<<endl;\n\n\t\tg[x].PB(y);\n\t\tg[y].PB(x);\n\t\tOUT[x]++;\n\t\tIN[y]++;\n\t}\n\n\tint c1 = 0, c2 = 0;\n\tFOR (i, 0, MAX)\n\t{\n\t\tif (U[i]) continue;\n\t\tif (SZ(g[i]) == 0) continue;\n\t\tL = R = 0;\n\n\t\tdfs(i);\n\n\t\tc1++;\n\t\tif (L == 0) c2++;\n\t}\n\t//cout<<\"*\"<<endl;\n\tif (c2) no();\n\tcout<<\"YES\"<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nset<int> l[201], r[201], opl[201], opr[201], cml[201], cmr[201];\nint H, n;\n\nstruct X{\n\tint a, b, c, d;\n\tX(){}\n}pc[100001];\n\ninline void no() { printf(\"NO\\n\"), exit(0); }\n\nvoid up(int v, int u, bool rr, bool er = false){\n\tif (rr){\n\t\tif (pc[v].d == 0) { opr[pc[v].b].erase(v); if (!er)opr[pc[v].b].insert(u); }\n\t\telse { r[pc[v].d].erase(v); if (!er)r[pc[v].d].insert(u); }\n\t}else {\n\t\tif (pc[v].c == 0) { opl[pc[v].a].erase(v); if (!er)opl[pc[v].a].insert(u); }\n\t\telse { l[pc[v].c].erase(v); if (!er)l[pc[v].c].insert(u); }\n\t}\n\tf(i, 1, H + 1)if (cml[i].find(v) != cml[i].end())cml[i].erase(v), cml[i].insert(u);\n\tf(i, 1, H + 1)if (cmr[i].find(v) != cmr[i].end())cmr[i].erase(v), cmr[i].insert(u);\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &H);\n\tf(i, 1, n + 1){\n\t\tscanf(\"%d%d%d%d\", &pc[i].a, &pc[i].b, &pc[i].c, &pc[i].d);\n\t\tif (pc[i].c == 0)opl[pc[i].a].insert(i); else l[pc[i].c].insert(i);\n\t\tif (pc[i].d == 0)opr[pc[i].b].insert(i); else r[pc[i].d].insert(i);\n\t}\n\t\n\tf(i, 1, H)while (!l[i].empty()){\n\t\tint v = *l[i].begin();\n\t\tl[i].erase(l[i].begin());\n\t\tbool ok = false;\n\t\tif (!opr[i].empty()){\n\t\t\tok = true;\n\t\t\tset<int>::iterator it = opr[i].begin();\n\t\t\tif (*it == v)++it;\n\t\t\tif (it == opr[i].end())ok = false;\n\t\t\tif (ok){\n\t\t\t\tint u = *it;\n\t\t\t\topr[i].erase(it);\n\t\t\t\tpc[u].a = pc[v].a;\n\t\t\t\tpc[u].c = pc[v].c;\n\t\t\t\tup(v, u, true);\n\t\t\t\tcml[i].insert(u);\n\t\t\t}\n\t\t}\n\t\tif (!ok){\n\t\t\tif (i == pc[v].b && pc[v].d == 0 && !cml[i].empty()){\n\t\t\t\tok = true;\n\t\t\t\tset<int>::iterator it = cml[i].begin();\n\t\t\t\tif (*it == v)++it;\n\t\t\t\tif (it == cml[i].end())ok = false;\n\t\t\t\tif (ok){\n\t\t\t\t\tint u = *it;\n\t\t\t\t\tup(v, u, true, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)no();\n\t}\n\t\n\tf(i, 1, H)while (!r[i].empty()){\n\t\tint v = *r[i].begin();\n\t\tr[i].erase(r[i].begin());\n\t\tbool ok = false;\n\t\tif (!opl[i].empty()){\n\t\t\tok = true;\n\t\t\tset<int>::iterator it = opl[i].begin();\n\t\t\tif (*it == v)++it;\n\t\t\tif (it == opl[i].end())ok = false;\n\t\t\tif (ok){\n\t\t\t\tint u = *it;\n\t\t\t\topl[i].erase(it);\n\t\t\t\tpc[u].b = pc[v].b;\n\t\t\t\tpc[u].d = pc[v].d;\n\t\t\t\tup(v, u, false);\n\t\t\t\tcmr[i].insert(u);\n\t\t\t}\n\t\t}\n\t\tif (!ok){\n\t\t\tif (i == pc[v].a && pc[v].c == 0 && !cmr[i].empty()){\n\t\t\t\tok = true;\n\t\t\t\tset<int>::iterator it = cmr[i].begin();\n\t\t\t\tif (*it == v)++it;\n\t\t\t\tif (it == cmr[i].end())ok = false;\n\t\t\t\tif (ok){\n\t\t\t\t\tint u = *it;\n\t\t\t\t\tup(v, u, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)no();\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint n, h;\nint fa[maxn], in[maxn], out[maxn], can[maxn];\ninline int find(int x) {\n\treturn fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> h;\n\trep(i, 1, h + h) fa[i] = i;\n\trep(i, 1, n) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint x0 = c ? c + h : a;\n\t\tint x1 = d ? d : b + h;\n\t\tfa[find(x0)] = find(x1);\n\t\t++ out[x0], ++ in[x1];\n\t}\n\trep(i, 1, h) {\n\t\tif(out[i] < in[i] || out[i + h] > in[i + h]) {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t\treturn 0;\n\t\t}\n\t\tif(out[i] != in[i]) can[find(i)] = 1;\n\t\tif(out[i + h] != in[i + h]) can[find(i + h)] = 1;\n\t}\n\trep(i, 1, h + h) {\n\t\tif(in[i] && out[i] && !can[find(i)]) {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tint n, h; cin>>n>>h;\n  int cnta[220]={}, cntb[220]={}, cntc[220]={}, cntd[220]={};\n  for(int i=0; i<n; i++){\n    int a, b, c, d; cin>>a>>b>>c>>d;\n    if(c==0) cnta[a]++;\n    else cntc[c]++;\n    if(d==0) cntb[b]++;\n    else cntd[d]++;\n  }\n  int da=0, db=0;\n  for(int i=1; i<=h; i++){\n    if(cnta[i]<cntd[i]){\n      cout<<\"NO\"<<endl; return 0;\n    }\n    da+=(cnta[i]-cntd[i]);\n    if(cntb[i]<cntc[i]){\n      cout<<\"NO\"<<endl; return 0;\n    }\n    db+=(cntb[i]-cntc[i]);\n  }\n  if(da==db && da>0){\n    cout<<\"YES\"<<endl;\n  }else{\n    cout<<\"NO\"<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,h;\ntuple<int,int,int,int> a[100010];int fa[100010];\nint find(const int &x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint ii[100010],oo[100010],mapp[100010];\nvoid init(){\n\tfor(int i=1;i<=n;i++){\n\t\tint f,t;\n\t\tif(f=get<2>(a[i])) f+=h;\n\t\telse f=get<0>(a[i]);\n\t\tif(t=get<3>(a[i]));\n\t\telse t=get<1>(a[i])+h;\n\t\too[f]++,ii[t]++;f=find(f),t=find(t);\n\t\tif(f^t) fa[f]=t;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=1000;i++) fa[i]=i;\n\tint A,B,C,D;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d%d%d\",&A,&B,&C,&D),a[i]={A,B,C,D};\n\tbool fg=1;init();\n\tfor(int i=1;i<=h;i++) if(ii[i]>oo[i]) fg=0;\n\tfor(int i=h+1;i<=h+h;i++) if(ii[i]<oo[i]) fg=0;\n\tfor(int i=1;i<=h+h;i++) if(ii[i]!=oo[i]||(ii[i]+oo[i]==0)) mapp[find(i)]++;\n\tfor(int i=1;i<=h+h;i++) if(!mapp[i]&&i==fa[i]) fg=0;\n\tprintf(\"%s\\n\",fg?\"YES\":\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define allv(V) ((V).begin()),((V).end())\n#define befv(V) ((V)[(sz(V)-2)])\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define cb(x) (x)=(!(x))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\nvoid fuk() { puts(\"NO\"); exit(0); }\n\nconst bool debug = 0;\nconst int MAXN = 100055;\nconst int MAXH = 1055;\n\nvector<int> G[MAXH];\nint GI[MAXH];\n\nbitset<MAXH> chk;\n\nint DgI[MAXH], DgO[MAXH];\n\nint A[MAXN], B[MAXN], C[MAXN], D[MAXN];\n\nvector<int> SV, EV;\nint N, H;\n\nvoid f(int i) {\n\tchk[i] = true;\n\tif(sz(G[i]) == GI[i]) return;\n\tint v = G[i][GI[i]];\n\tGI[i]++;\n\tf(v);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> H;\n\tfor(int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\n\t\tint s = -1, e = -1;\n\n\t\tif(C[i]) s = C[i]<<1;\n\t\telse s = A[i]<<1 | 1;\n\n\t\tif(D[i]) e = D[i]<<1 | 1;\n\t\telse e = B[i]<<1;\n\n\t\tG[s].eb(e);\n\t\tDgO[s]++; DgI[e]++;\n\n\t\tif(debug) printf(\"%d : %d -> %d\\n\", i, s, e);\n\t}\n\n\tfor(int i = 0; i < MAXH; i++) {\n\t\tif(DgI[i] == DgO[i]) continue;\n\t\tif(DgI[i] < DgO[i]) {\n\t\t\tfor(int j = DgO[i] - DgI[i]; j--;)\n\t\t\t\tSV.eb(i);\n\t\t} else {\n\t\t\tfor(int j = DgI[i] - DgO[i]; j--;)\n\t\t\t\tEV.eb(i);\n\t\t}\n\t}\n\n\tif(SV.empty() || sz(SV) != sz(EV)) fuk();\n\n\tfor(int v : SV) if(!(v & 1)) fuk();\n\tfor(int v : EV) if(v & 1) fuk();\n\n\tfor(int i = 0; i < MAXH; i++) {\n\t\tsrand(time(0));\n\t\trandom_shuffle(allv(G[i]));\n\t}\n\n\tfor(int v : SV) {\n\t\tf(v);\n\t}\n\n\tfor(int i = 0; i < MAXH; i++) if(chk[i]) {\n\t\tfor(; GI[i] < sz(G[i]);) f(i);\n\t}\n\n\tfor(int i = 0; i < MAXH; i++)\n\t\tif(sz(G[i]) != GI[i]) fuk();\n\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct w {\n\tint a, b, c, d;\n} t;\n\nbool comp(const w &a, const w &b) {\n\treturn a.d < b.d;\n}\n\nint n, h, cnt[2][300], ans;\n\nint main() {\n\tscanf(\"%d%d\", &n , &h);\n\twhile (n--) {\n\t\tscanf(\"%d%d%d%d\", &t.a, &t.b, &t.c, &t.d);\n\t\tif (t.c == 0)\n\t\t\tcnt[0][t.a]++;\n\t\telse\n\t\t\tcnt[1][t.c]--;\n\t\tif (t.d == 0)\n\t\t\tcnt[1][t.b]++;\n\t\telse\n\t\t\tcnt[0][t.d]--;\n\t}\n\tfor (int i = 0; i < 300; i++) {\n\t\tif (cnt[0][i] < 0 || cnt[1][i] < 0) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (cnt[0][i] > 0)\n\t\t\tans |= 1;\n\t\tif (cnt[1][i] > 0)\n\t\t\tans |= 2;\n\t}\n\tprintf(ans == 3 ? \"YES\\n\" : \"NO\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nconst int MAXN = 1000;\n\nvoid findPathU(int n, int mat[][MAXN], int now, int & step, int * path) {\n    int i;\n    for (i = n - 1; i >= 0; i--) {\n        while (mat[now][i]) {\n            mat[now][i]--;\n            mat[i][now]--;\n            findPathU(n, mat, i, step, path);\n        }\n    }\n    path[step++] = now;\n}\n\nvoid findPathD(int n, int mat[][MAXN], int now, int & step, int * path) {\n    int i;\n    for (i = n - 1; i >= 0; i--) {\n        while (mat[now][i]) {\n            mat[now][i]--;\n            findPathD(n, mat, i, step, path);\n        }\n    }\n    path[step++] = now;\n}\n\nint euclidPath(int n, int mat[][MAXN], int start, int * path) {\n    int ret = 0;\n//  findPathU(n, mat, start, ret, path);\n\tfindPathD(n, mat, start, ret, path);\n    return ret;\n}\n\nint h;\nint a[MAXN][MAXN], b[MAXN][MAXN];\nPII l[MAXN], r[MAXN];\nint pt[MAXN << 2];\n\nvoid solve(int casi){\n//\tcout << \"Case #\" << casi << \": \";\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 0; i <= 2 * h + 2; i++)\n\t\tfor (int j = 0; j <= 2 * h + 2; j++)\n\t\t\ta[i][j] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tint A, B, C, D;\n\t\tscanf(\"%d%d%d%d\", &A, &B, &C, &D);\n\t\tif (C == 0){\n\t\t\tl[i] = PII(A, 0);\n\t\t}\n\t\telse\n\t\t\tl[i] = PII(C, 1);\n\t\tif (D == 0)\n\t\t\tr[i] = PII(B, 0);\n\t\telse\n\t\t\tr[i] = PII(D, 1);\n\t\ta[l[i].first * 2 + l[i].second][r[i].first * 2 + 1 - r[i].second]++;\n\t}\n\tfor (int i = 0; i <= 2 * h + 2; i++){\n\t\t/*for (int j = 0; j <= 2 * h + 2; j++)\n\t\t\tfor (int k = 0; k <= 2 * h + 2; k++)\n\t\t\t\tb[j][k] = a[j][k];\n\t\tcout << euclidPath(2 * h + 2, b, i, pt) << endl;*/\n\t\tfor (int j = 0; j <= 2 * h + 2; j++)\n\t\t\tfor (int k = 0; k <= 2 * h + 2; k++)\n\t\t\t\tb[j][k] = a[j][k];\n\t\tif (euclidPath(2 * h + 2, b, i, pt) == n){\n\t\t\tputs(\"YES\");\n\t\t\treturn ;\n\t\t}\n\t}\n\tputs(\"NO\");\n\treturn ;\n}\n\nvoid printans(){\n\n}\n\nint main(){\n//\tstd::ios::sync_with_stdio(false);\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <queue>\n#include <limits>\n#include <deque>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#define mp make_pair\n#define fs first\n#define se second\n#define memset(a,t) memset(a,t,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define MN 0LL\n#define Mx 200000005\n#define Mn -Mx\n#define MX 20000000000000005\nusing namespace std;\nint readint(){\n\tchar c;\n\twhile(c=getchar(),(c<'0'||c>'9')&&c!='-');\n\tbool flag=(c=='-');\n\tif(flag)c=getchar();\n\tint x=0;\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn flag?-x:x;\n}\ninline string tos(int x){\n\tstring s;\n\twhile(x) s=(char)(x%10+'0')+s,x/=10;\n\treturn s;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint r;\n\tsrand(time(NULL));\n\tr=rand()%2;\n\tif(r==1) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 50;\n\nint n , h , ins[maxn] , outs[maxn] , vis[maxn];\nvector < int > edge[maxn];\nset < int > wr;\n\nvoid dfs( int u ){\n\tfor(auto v : edge[u]){\n\t\tif( vis[v] )\n\t\t\tcontinue;\n\t\tvis[v] = 1;\n\t\tdfs( v );\n\t}\n}\n\nint main( int argc , char * argv[] ){\n\tscanf( \"%d%d\" , & n , & h );\n\tfor(int i = 1 ; i <= n ; ++ i){\n\t\tint a , b , c , d;\n\t\tscanf( \"%d%d%d%d\" , & a , & b , & c , & d );\n\t\tint u , v;\n\t\tif( d == 0 )\n\t\t\tu = b + h + 1;\n\t\telse\n\t\t\tu = d;\n\t\tif( c == 0 )\n\t\t\tv = a;\n\t\telse\n\t\t\tv = c + h + 1;\n\t\touts[u] ++ ;\n\t\tins[v] ++ ;\n\t\tedge[u].emplace_back( v );\n\t\tedge[v].emplace_back( u );\n\t\twr.insert( u );\n\t\twr.insert( v );\n\t}\n\tint base = *wr.begin();\n\tvis[base] = 1;\n\tdfs( base );\n\tfor(auto it : wr)\n\t\tif(!vis[it]){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tint cnt = 0;\n\tmultiset < int > fff;\n\tfor(auto it : wr){\n\t\tint z = ins[it] - outs[it];\n\t\tif( abs(z) > 1 ){\n\t\t\tputs( \"NO\" );\n\t\t\treturn 0;\n\t\t}\n\t\tif( z != 0 )\n\t\t\tfff.insert( z );\n\t}\n\tif( fff.size() == 0 )\n\t\tputs( \"NO\" );\n\telse{\n\t\tfor(multiset < int > :: iterator a = fff.begin() , b = --fff.end() ; ; ){\n\t\t\tif( *a != -1 && *b != 1 ){\n\t\t\t\tputs( \"NO\" );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t++ a ;\n\t\t\tif( a == b )\n\t\t\t\tbreak;\n\t\t\t-- b;\n\t\t}\n\t\tputs( \"YES\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::endl;\n\nconst int N = 1e5 + 233;\n\nint n, h, A[N], B[N], C[N], D[N];\nint out[N], in[N], fa[N], vis[N];\n\nint find(int x) {\n  return x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\ninline bool check() {\n  for (int i = 0; i < h; ++i)\n    if (in[i] > out[i]) return 0;\n  for (int i = 1; i <= h; ++i)\n    if (in[i + h] < out[i + h]) return 0;\n  for (int i = -h; i <= h; ++i)\n    if ((!in[i + h] && !out[i + h]) || (in[i + h] != out[i + h]))\n      vis[find(i + h)] = 1;\n  for (int i = -h; i <= h; ++i)\n    if (!vis[find(i + h)]) return 0;\n  return 1;\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &h);\n  for (int i = 0; i <= h * 2 + 5; ++i)\n    fa[i] = i;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d %d %d %d\", A + i, B + i, C + i, D + i);\n    int x = C[i] == 0 ? h - A[i] : h + C[i];\n    int y = D[i] == 0 ? h + B[i] : h - D[i];\n    ++out[x], ++in[y];\n    x = find(x), y = find(y);\n    if (x != y) fa[x] = y;\n  }\n  puts(check() ? \"YES\" : \"NO\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\n#define A(a) ((a)<<1)\n#define B(a) ((a)<<1|1)\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nconst int MAXV = 200007;\nconst int MAXM = 2000007;\n\nstruct eT\n{\n\tvoid setd ( int _u, int _v, int _f, int _l )\n\t{\n\t\tu = _u, v = _v, f = _f, last = _l;\n\t}\n\n\tint u, v, f, last;\n}edge[MAXM];\n\nstruct bT\n{\n\tbT () {}\n\tbT ( int _h, int _l ) : h ( _h ), l ( _l ) {}\n\n\tvoid setd ( int _h, int _l )\n\t{\n\t\th = _h, l = _l;\n\t}\n\n\tbool operator < ( const bT &a ) const\n\t{\n\t\treturn ( h ^ a.h ) ? ( h < a.h ) : ( l < a.l );\n\t}\n\n\tbool operator == ( const bT &a ) const\n\t{\n\t\treturn ( h == a.h && l == a.l );\n\t}\n\n\tint h, l;\n}bl[MAXN], br[MAXN];\n\nint n, h, S, T;\nint ke, la[MAXV];\n\nint q[MAXV], lev[MAXV];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nvoid addedge ( int u, int v, int fu, int fv );\n\nint dinic ();\nbool bfs ();\nint dfs ( int now, int lim );\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\n\tscanf ( \"%d%d\", &n, &h );\n\tint a, b, c, d;\n\tlpi ( i, 1, n ){\n\t\tscanf ( \"%d%d%d%d\", &a, &b, &c, &d );\n\t\tbl[i].setd ( c, a ), br[i].setd ( d, b );\n\t}\n}\n\nvoid work ()\n{\n\t// main work\n\n\tbool flag;\n\tlpi ( i, 1, n ){\n\t\tflag = true;\n\t\tif ( !bl[i].h && br[i].h ){\n\t\t\tflag = false;\n\t\t\tlpi ( j, 1, n ){\n\t\t\t\tif ( !bl[j].h && bl[j].l == br[i].h && ( ! ( ( bl[i] == bl[j] ) && ( br[i].h == br[j].h ) ) ) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( bl[i].h && !br[i].h ){\n\t\t\tflag = false;\n\t\t\tlpi ( j, 1, n ){\n\t\t\t\tif ( !br[j].h && br[j].l == bl[i].h && ( ! ( ( bl[i].h == bl[j].h ) && ( br[i] == br[j] ) ) ) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( !flag ){\n\t\t\tprintf ( \"NO\\n\" );\n\t\t\treturn;\n\t\t}\n\t}\n\n\tS = MAXV - 1, T = MAXV - 2;\n\tint SS = MAXV - 3, TT = MAXV - 4;\n\tke = 0;\n\tINIT ( la, -1 );\n\n\tmap < bT, PII > ml, mr;\n\tmap < bT, PII > ::iterator it;\n\n\tAR( int ) keye;\n\tint ks = 0;\n\n\tlpi ( i, 1, n ){\n\t\t++ml[bl[i]].first;\n\t\t++mr[br[i]].first;\n\t}\n\n\tint kl = 0, kr = 0;\n\tfor ( auto &x : ml ) x.second.second = ++kl;\n\tfor ( auto &x : mr ) x.second.second = ++kr;\n\n//\tint cl = 0, cr = 0;\n\tfor ( auto x : ml ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, A( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( A( x.second.second ), TT, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = mr.find ( bT ( 0, x.first.h ) ) ) != mr.end () ){\n\t\t\t\taddedge ( B( it->second.second ), A( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n//\t\t\tcl += x.second.first;\n\t\t\taddedge ( A( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n\tfor ( auto x : mr ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, B( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( B( x.second.second ), SS, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = ml.find ( bT ( 0, x.first.h ) ) ) != ml.end () ){\n\t\t\t\taddedge ( A ( it->second.second ), B( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n//\t\t\tcr += x.second.first;\n\t\t\taddedge ( B( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n//\taddedge ( SS, T, INF, 0 );\n//\taddedge ( TT, T, INF, 0 );\n\n/*\tif ( cl ^ cr ){\n\t\tprintf ( \"NO\\n\" );\n\t\treturn;\n\t}*/\n\n\tif ( ks >= n ){\n\t\tprintf ( \"NO\\n\" );\n\t\treturn;\n\t}\n\n\tdinic ();\n\n\tflag = true;\n\tfor ( auto x : keye ){\n\t\tif ( edge[x].f ){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf ( flag ? \"YES\\n\" : \"NO\\n\" );\n}\n\n\n\nvoid addedge ( int u, int v, int fu, int fv )\n{\n\tedge[ke].setd ( u, v, fu, la[u] );\n\tla[u] = ke++;\n\tedge[ke].setd ( v, u, fv, la[v] );\n\tla[v] = ke++;\n}\n\nint dinic ()\n{\n\tint ans = 0;\n\twhile ( bfs () ) ans += dfs ( S, INF );\n\treturn ans;\n}\n\nbool bfs ()\n{\n\tint l = 0, r = 0, now, v;\n\tq[r++] = S;\n\tINIT ( lev, -1 );\n\tlev[S] = 1;\n\twhile ( l < r ){\n\t\tnow = q[l++];\n\t\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\t\tif ( edge[i].f && lev[v=edge[i].v] == -1 ){\n\t\t\t\tlev[v] = lev[now] + 1;\n\t\t\t\tq[r++] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ( lev[T] != -1 );\n}\n\nint dfs ( int now, int lim )\n{\n\tif ( now == T ) return lim;\n\n\tint v, nf = 0, tf;\n\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\tif ( edge[i].f && lev[v=edge[i].v] == lev[now] + 1 ){\n\t\t\ttf = dfs ( v, qmin ( lim-nf, edge[i].f ) );\n\t\t\tnf += tf;\n\t\t\tedge[i].f -= tf, edge[i^1].f += tf;\n\n\t\t\tif ( nf == lim ) break;\n\t\t}\n\t}\n\n\tif ( !nf ) lev[now] = -1;\n\treturn nf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[50000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t\tif (j = l)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]&&c[j][4]==0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t\tif (j = l)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, e[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += e[i];\n\t}\n\tif (s < e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank;\n\tUF() {rank=vector<int>(um,0); for(int i=0;i<um;i++) par.push_back(i);}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\nUF<2000> uf;\n\nint in[2000];\nint out[2000];\n\nint N,H;\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>H;\n\tFOR(i,N) {\n\t\tint A,B,C,D,L,R;\n\t\tcin>>A>>B>>C>>D;\n\t\tif(C>0) L=C;\n\t\telse L=-A;\n\t\tif(D==0) R=B;\n\t\telse R=-D;\n\t\t\n\t\tout[L+1000]++;\n\t\tin[R+1000]++;\n\t\tuf(L+1000,R+1000);\n\t}\n\t\n\tfor(i=-200;i<=-1;i++) {\n\t\tif(in[i+1000]>out[i+1000]) return _P(\"NO\\n\");\n\t\tif(in[i+1000]<out[i+1000]) uf(1000,i+1000);\n\t}\n\tfor(i=1;i<=200;i++) {\n\t\tif(in[i+1000]<out[i+1000]) return _P(\"NO\\n\");\n\t\tif(in[i+1000]>out[i+1000]) uf(1000,i+1000);\n\t}\n\t\n\tfor(i=1000-200;i<=1000+200;i++) if((in[i]||out[i]) && uf[i]!=uf[1000]) return _P(\"NO\\n\");\n\t_P(\"YES\\n\");\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst long long INF = (1ll << 50);\nstruct graph {\n  typedef long long flow_type;\n  struct edge {\n    int src, dst;\n    flow_type capacity, flow;\n    size_t rev;\n  };\n  int n;\n  vector<vector<edge>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst, flow_type capacity) {\n    adj[src].push_back({src, dst, capacity, 0, adj[dst].size()});\n    adj[dst].push_back({dst, src, 0, 0, adj[src].size()-1});\n  }\n  flow_type max_flow(int s, int t, bool first=false) {\n    if (first) {\n      for (int u = 0; u < n; ++u) // initialize\n      for (auto &e: adj[u]) e.flow = 0;\n    }\n\n    vector<int> level(n), iter(n);\n    function<int(void)> levelize = [&]() { // foward levelize\n      level.assign(n, -1); level[s] = 0;\n      queue<int> Q; Q.push(s);\n      while (!Q.empty()) {\n        int u = Q.front(); Q.pop();\n        if (u == t) break;\n        for (auto &e: adj[u]) {\n          if (e.capacity > e.flow && level[e.dst] < 0) {\n            Q.push(e.dst);\n            level[e.dst] = level[u] + 1;\n          }\n        }\n      }\n      return level[t];\n    };\n    function<flow_type(int, flow_type)> augment = [&](int u, flow_type cur) {\n      if (u == t) return cur;\n      for (int &i = iter[u]; i < adj[u].size(); ++i) {\n        edge &e = adj[u][i], &r = adj[e.dst][e.rev];\n        if (e.capacity > e.flow && level[u] < level[e.dst]) {\n          flow_type f = augment(e.dst, min(cur, e.capacity - e.flow));\n          if (f > 0) {\n            e.flow += f;\n            r.flow -= f;\n            return f;\n          }\n        }\n      }\n      return flow_type(0);\n    };\n\n    flow_type flow = 0;\n    while (levelize() >= 0) {\n      fill(all(iter), 0);\n      for (flow_type f; (f = augment(s, INF)) > 0; )\n        flow += f;\n    }\n    return flow;\n  }\n};\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\n\nint MakeVertex(int a, int c) {\n  if (c == 0) return a;\n  return c+(H+1);\n}\n\nsigned main(){\n  cin >> N >> H;\n\n  int S = 0;\n  int S2 = S+1;\n  int T2 = S2+1;\n  int l1 = T2+1;\n  int l2 = l1+N;\n  int l3 = l2+2*(H+2);\n  int l4 = l3+2*(H+2);\n  int gr = l4+N;\n  int grL = gr+N;\n  int grR = grL+N;\n  int T = grR+1;\n  graph g(T+1);\n\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    //g.add_edge(S, l1+i, 1);\n    g.add_edge(S2, l1+i, 1);\n    g.add_edge(S, T2, 1);\n    \n    int u = MakeVertex(B[i], D[i]);\n    g.add_edge(l1+i, l2+u, 1);\n    int v = MakeVertex(A[i], C[i]);\n    g.add_edge(l3+v, l4+i, 1);\n\n    //g.add_edge(l4+i, T, 1);\n    g.add_edge(S2, T, 1);\n    g.add_edge(l4+i, T2, 1);\n  }\n\n  reps(i, l2, l3) {\n    int u = i - l2;\n    int v = (u >= H+1) ? u-(H+1) : u+H+1;\n    g.add_edge(l2+u, l3+v, N);\n  }\n\n  //g.add_edge(S, gr, N);\n  //g.add_edge(gr, T, N);\n\n  // g.add_edge(S, grL, 1);\n  g.add_edge(S2, grL, 1);\n  g.add_edge(S, T2, 1);\n\n  // g.add_edge(grR, T, 1);\n  g.add_edge(S2, T, 1);\n  g.add_edge(grR, T2, 1);\n\n  reps(h, 1, H+1) {\n    int v = MakeVertex(h, 0);\n    g.add_edge(l2+v, gr, N);\n    g.add_edge(gr, l3+v, N);\n    g.add_edge(l2+v, grR, 1);\n    g.add_edge(grL, l3+v, 1);\n  }\n\n  LL a = g.max_flow(S2, T2, true);\n  LL b = g.max_flow(S, T2);\n  LL c = g.max_flow(S2, T);\n  LL d = g.max_flow(S, T);\n  //cout \n  //<< a << \",\" \n  //<< b << \",\"\n  //<< c << \",\"\n  //<< d << endl;\n\n  if (a+b == a+c && a+b == N*2+2) {\n    cout << \"YES\" << endl;\n    return 0;\n  }\n  cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXH=200;\ntypedef struct Z { int A,B,C,D,L,R; vector<int> mid; } Z;\n\nint n,h;\nZ z[2*MAXN];\nbool used[2*MAXN];\n\n\nvector<int> havel[2*MAXH];\nvector<int> haver[2*MAXH];\nvector<int> havec[2*MAXH];\nint cnt[2*MAXH];\n\nbool solve() {\n\tREP(i,n) { if(z[i].C==0) z[i].L=z[i].A-1; else z[i].L=h+z[i].C-1; if(z[i].D==0) z[i].R=h+z[i].B-1; else z[i].R=z[i].D-1; }\n\t//REP(i,n) { if(i!=0) printf(\" | \"); printf(\"%02d-%02d\",z[i].L,z[i].R); } puts(\"\");\n\tREP(i,2*h) havel[i].clear(),haver[i].clear(); REP(i,n) havel[z[i].L].PB(i),haver[z[i].R].PB(i),used[i]=false;\n\n\tbool ret=true; int nz=n;\n\tREP(i,n) if(!used[i]) {\n\t\tused[i]=true;\n\t\tint l=z[i].L,r=z[i].R; REP(j,2*h) cnt[j]=0;\n\t\t//printf(\"%02d-%02d\\n\",l,r);\n\t\twhile(true) {\n\t\t\tbool change=false;\n\t\t\twhile(true) {\n\t\t\t\twhile(SZ(havel[r])!=0&&used[havel[r].back()]) havel[r].pop_back();\n\t\t\t\tif(SZ(havel[r])!=0) { int id=havel[r].back(); used[id]=true; ++cnt[r]; r=z[id].R; change=true; /*printf(\"append right %02d-%02d\\n\",z[id].L,z[id].R);*/ } else break;\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\twhile(SZ(haver[l])!=0&&used[haver[l].back()]) haver[l].pop_back();\n\t\t\t\tif(SZ(haver[l])!=0) { int id=haver[l].back(); used[id]=true; ++cnt[l]; l=z[id].L; change=true; /*printf(\"append left  %02d-%02d\\n\",z[id].L,z[id].R);*/ } else break;\n\t\t\t}\n\t\t\tif(!change&&l==r) REP(j,2*h) if(cnt[j]>0||j==l) {\n\t\t\t\twhile(SZ(havel[j])!=0&&used[havel[j].back()]) havel[j].pop_back();\n\t\t\t\twhile(SZ(haver[j])!=0&&used[haver[j].back()]) haver[j].pop_back();\n\t\t\t\twhile(SZ(havec[j])!=0&&used[havec[j].back()]) havec[j].pop_back();\n\t\t\t\tif(SZ(havel[j])!=0) { int id=havel[j].back(); used[id]=true; ++cnt[l]; l=j,r=z[id].R; change=true; /*printf(\"split on %02d and append right %02d-%02d\\n\",j,z[id].L,z[id].R);*/ break; }\n\t\t\t\tif(SZ(haver[j])!=0) { int id=haver[j].back(); used[id]=true; ++cnt[l]; l=z[id].L,r=j; change=true; /*printf(\"split on %02d and append left  %02d-%02d\\n\",j,z[id].L,z[id].R);*/ break; }\n\t\t\t\tif(SZ(havec[j])!=0) { int id=havec[j].back(); used[id]=true; ++cnt[l]; l=z[id].L,r=z[id].R; change=true; REPSZ(k,z[id].mid) ++cnt[z[id].mid[k]]; /*printf(\"split on %02d and append in middle %02d-%02d\\n\",j,z[id].L,z[id].R);*/ break; }\n\t\t\t}\n\t\t\tif(!change) break;\n\t\t}\n\t\t//printf(\"-> %02d-%02d:\",l,r); REP(j,2*h) if(cnt[j]>0) printf(\" %02d\",j); puts(\"\");\n\t\tif(l>=h||r<h) ret=false; else { z[nz].L=l,z[nz].R=r,used[nz]=false; REP(j,2*h) if(cnt[j]>0) z[nz].mid.PB(j),havec[j].PB(nz); ++nz; }\n\t}\n\treturn ret;\n}\n\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&h);\n\tREP(i,n) scanf(\"%d%d%d%d\",&z[i].A,&z[i].B,&z[i].C,&z[i].D);\n\t//REP(i,n) { if(i!=0) printf(\" | \"); if(z[i].C==0) printf(\"0%d\",z[i].A); else printf(\"%d*\",z[i].C); printf(\"-\"); if(z[i].D==0) printf(\"0%d\",z[i].B); else printf(\"%d*\",z[i].D); } puts(\"\");\n\tprintf(\"%s\\n\",solve()?\"YES\":\"NO\");\t\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\nint h;\n\n#define MAXX 202\nint lef[MAXX];\nint rig[MAXX];\n\nint deg[MAXX*2];\n\nvector<int> v[MAXX*2];\n\nint main(){\n\tfor (int i = 0; i < MAXX; i++){\n\t\tlef[i] = 2 * i;\n\t\trig[i] = lef[i] + 1;\n\t}\n\tcin >> n >> h;\n\tfor (int i = 0; i < n; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tif (c){\n\t\t\tdeg[lef[c]]++;\n\t\t}\n\t\telse{\n\t\t\tdeg[rig[a]]++;\n\t\t\tv[rig[a]].push_back(i);\n\t\t}\n\t\tif (d){\n\t\t\tdeg[rig[d]]--;\n\t\t}\n\t\telse{\n\t\t\tdeg[lef[b]]--;\n\t\t\tv[lef[b]].push_back(i);\n\t\t}\n\t}\n\tbool ng = false;\n\tint restr = 0;\n\tint restl = 0;\n\tint id = -1;\n\tint id2 = -1;\n\tfor (int i = 0; i < MAXX; i++){\n\t\tif (deg[rig[i]] >= 0 && deg[lef[i]] <= 0){\n\t\t\trestr += deg[rig[i]];\n\t\t\trestl += -deg[lef[i]];\n\t\t\tif (deg[rig[i]]){\n\t\t\t\tid = rig[i];\n\t\t\t}\n\t\t\tif (deg[lef[i]] < 0){\n\t\t\t\tid2 = lef[i];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tng = true;\n\t\t}\n\t}\n\tif (restr == 0 || restl == 0){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tif (ng){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tif (restr == 1 && restl == 1 && v[id].size() == 1 && v[id2].size() == 1 && v[id][0] == v[id2][0]){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nvector <int> LI[444], LO[444], RI[444], RO[444];\nvector <pii> V;\nbool chk[444];\nmultiset <int> SL, SR;\nint n, h;\n\nvoid dfs(int p, vector <int> *V)\n{\n\tchk[p] = 1;\n\tfor(int t: V[p]){\n\t\tif(!chk[t]) dfs(t, V);\n\t}\n}\n\nvoid die()\n{\n\tprintf(\"NO\\n\");\n\texit(0);\n}\n\nint main()\n{\n\tint i, j, a, b, c, d;\n\t\n\tscanf(\"%d%d\", &n, &h);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\n\t\tif(c == 0 && d == 0){\n\t\t\tif(a != h){\n\t\t\t\tLO[0].push_back(a);\n\t\t\t\tLI[a].push_back(0);\n\t\t\t}\n\t\t\tif(b != h){\n\t\t\t\tRO[0].push_back(b);\n\t\t\t\tRI[b].push_back(0);\n\t\t\t}\n\t\t}\n\t\telse if(c == 0){\n\t\t\tLO[d].push_back(a);\n\t\t\tLI[a].push_back(d);\n\t\t}\n\t\telse if(d == 0){\n\t\t\tRO[c].push_back(b);\n\t\t\tRI[b].push_back(c);\n\t\t}\n\t\telse V.push_back(pii(c, d));\n\t}\n\t\n\tdfs(0, LO);\n\t\n\tfor(i=1;i<h;i++){\n\t\tif((!LO[i].empty() || !LI[i].empty()) && !chk[i]) die();\n\t\tif(LI[i].size() >= LO[i].size()){\n\t\t\tfor(j=0;j<LI[i].size() - LO[i].size();j++) SL.insert(i);\n\t\t}\n\t\telse die();\n\t\tchk[i] = 0;\n\t}\n\t\n\tdfs(0, RO);\n\t\n\tfor(i=1;i<h;i++){\n\t\tif((!RO[i].empty() || !RI[i].empty()) && !chk[i]) die();\n\t\tif(RI[i].size() >= RO[i].size()){\n\t\t\tfor(j=0;j<RI[i].size() - RO[i].size();j++) SR.insert(i);\n\t\t}\n\t\telse die();\n\t\tchk[i] = 0;\n\t}\n\t\n\tfor(pii t: V){\n\t\tauto it = SL.find(t.second);\n\t\tif(it == SL.end()) die();\n\t\tSL.erase(it);\n\t\t\n\t\tit = SR.find(t.first);\n\t\tif(it == SR.end()) die();\n\t\tSR.erase(it);\n\t}\n\t\n\tif(SL.empty() || SR.empty()) die();\n\t\n\tprintf(\"YES\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int H = 210;\n\nint n,h;\nint deg[H*2];\nint cnt[H*2];\nint fa[H*2],siz[H*2];\nbool bz[H*2],sef[H*2];\n\nint getfather(int x){\n\tif (fa[x]==x)return fa[x];\n\treturn fa[x]=getfather(fa[x]);\n}\n\nint main(){\n\tn=get();h=get();\n\tfo(i,0,h*2)fa[i]=i,siz[i]=1;\n\tfo(i,1,n){\n\t\tint a=get(),b=get(),c=get(),d=get();\n\t\tif (c)a=-c;\n\t\tif (d)b=d;else b=-b;\n\t\ta+=h;b+=h;\n\t\tint ta=getfather(a),tb=getfather(b);\n\t\tdeg[a]++;deg[b]--;\n\t\tif (ta!=tb){\n\t\t\tfa[ta]=tb;\n\t\t\tsiz[tb]+=siz[ta];\n\t\t}\n\t\telse sef[ta]=1;\n\t}\n\tbool ans=1;\n\tfo(i,0,h)if (deg[i]>0)ans=0;\n\tfo(i,h,2*h)if (deg[i]<0)ans=0;\n\tfo(i,0,h*2)bz[getfather(i)]|=(deg[i]!=0);\n\tfo(i,0,h*2)\n\tif (siz[i]>1&&getfather(i)==i&&!bz[i])ans=0;\n\tfo(i,0,h*2)\n\tif (siz[i]==1&&sef[i]&&getfather(i)==i)ans=0;\n\tif (ans)printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 805;\n\nint g[MAXN][MAXN];\nint deg_in[MAXN];\nint deg_out[MAXN];\nint mx = 200;\nint offset_val = 200;\nint offset_part = 401;\n\nint used[MAXN];\nvi comp;\n\nvoid dfs(int s) {\n\tused[s] = 1;\n\tcomp.pb(s);\n\tREP(i, 0, MAXN) {\n\t\tif ((g[s][i] || g[i][s]) && !used[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint n, h, a, b, c, d;\n\tscanf(\"%d%d\", &n, &h);\n\tREP(i, 0, n) {\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tif (c) {\n\t\t\ta = -c;\n\t\t}\n\t\tif (d) {\n\t\t\tb = -d;\n\t\t}\n\t\t//printf(\"added: %d %d\\n\", a, b);\n\t\tg[offset_val + a][offset_part + offset_val + b]++;\n\t\tif (a < 0) {\n\t\t\tg[offset_part + offset_val - a][offset_val + a]++;\n\t\t}\n\t\tif (b < 0) {\n\t\t\tg[offset_part + offset_val + b][offset_val - b]++;\n\t\t}\n\t}\n\tREP(i, 0, MAXN) {\n\t\tREP(j, 0, MAXN) {\n\t\t\tdeg_in[j] += g[i][j];\n\t\t\tdeg_out[i] += g[i][j];\n\t\t\t/*if (g[i][j]) {\n\t\t\t\tprintf(\"%d %d: %d\\n\", i, j, g[i][j]);\n\t\t\t}*/\n\t\t}\n\t}\n\tREPN(i, 1, mx) {\n\t\tif (deg_in[offset_val + i] > deg_out[offset_val + i]) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (deg_in[offset_part + offset_val + i] < deg_out[offset_part + offset_val + i]) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tREP(i, 0, MAXN) {\n\t\tif ((deg_in[i] || deg_out[i]) && !used[i]) {\n\t\t\tcomp.clear();\n\t\t\tdfs(i);\n\t\t\tint fl_balance = 0;\n\t\t\tREP(j, 0, SZ(comp)) {\n\t\t\t\tint v = comp[j];\n\t\t\t\tif (deg_in[v] != deg_out[v]) {\n\t\t\t\t\tfl_balance = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!fl_balance) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 100100;\n\nconst int maxH = 510;\n\nint n, H;\n\nint fa[maxH + 5];\n\nint deg[maxH + 5];\n\nbool vis[maxH + 5];\n\nint get(int x) { return fa[x] == x ? x : fa[x] = get(fa[x]); }\n\ninline void adde(int C, int D)\n{\n\tvis[C] = vis[D] = 1;\n\t++deg[C];\n\t--deg[D];\n\tfa[get(C)] = get(D);\n}\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d%d\", &n, &H);\n\t++H;\n\tREP(i, 0, H << 1) fa[i] = i;\n\tREP(i, 0, n)\n\t{\n\t\tint A, B, C, D;\n\t\tscanf(\"%d%d%d%d\", &A, &B, &C, &D);\n\t\tint x = -1, y = -1;\n\t\tif (!C) x = A << 1;\n\t\telse x = C << 1 | 1;\n\t\tif (!D) y = B << 1 | 1;\n\t\telse y = D << 1; \n\t\tadde(x, y);\n\t}\n\tbool failed = 0;\n\tREP(i, 0, H << 1) if (vis[i])\n\t{\n\t\tint sum = 0;\n\t\tint abssum = 0;\n\t\tREP(j, 0, H << 1) if (get(j) == get(i))\n\t\t{\n\t\t\tvis[j] = 0;\n\t\t\tsum += deg[j];\n\t\t\tabssum += abs(deg[j]);\n\t\t\tif (deg[j] > 0)\n\t\t\t{\n\t\t\t\tif (j & 1) { failed = 1; break; }\n\t\t\t}\n\t\t\tif (deg[j] < 0)\n\t\t\t{\n\t\t\t\tif (!(j & 1)) { failed = 1; break; }\n\t\t\t}\n\t\t}\n\t\tif (sum || !abssum) { failed = 1; break; }\n\t}\n\tputs(failed ? \"NO\" : \"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\n\n\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\tG[h + b[i].a].push_back(h+b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[h + b[i].a].push_back(b[i].b);\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint th = 0;\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\texi[i] = true;\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s + st != e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\n\tbool exiroad[402][402] = {};\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tfill(chked, chked + 402, false);\n\t\tq.push(i); chked[i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front(); q.pop();\n\t\t\trep(j, G[x].size()) {\n\t\t\t\tint to = G[x][j];\n\t\t\t\tif (chked[to])continue;\n\t\t\t\tchked[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\trep(j, 402) {\n\t\t\tif (chked[j]) {\n\t\t\t\texiroad[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tRep(j, i + 1, 402) {\n\t\t\tif (!exi[j])continue;\n\t\t\tif (!exiroad[i][j] || !exiroad[j][i]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nconst int M = 1e5 + 10;\nint f[600] , cnt[600] , c[600];\nvector<int>vc[600];\nvoid init() {\n    for(int i = 0 ; i <= 555 ; i++) {\n        cnt[i] = 0;\n        c[i] = 0;\n        f[i] = i;\n    }\n}\nint find(int x) {\n    if(x == f[x]) return x;\n    int tmp = find(f[x]);\n    return f[x] = tmp;\n}\n\nint main() {\n    int n , h;\n    scanf(\"%d%d\" , &n , &h);\n    init();\n    for(int i = 1 ; i <= n ; i++) {\n        int a , b , c , d;\n        scanf(\"%d%d%d%d\" , &a , &b , &c , &d);\n        int x = c , y = -d;\n        if(c == 0) x = -a;\n        if(d == 0) y = b;\n        x += 250 , y += 250;\n        vc[x].push_back(y);\n        cnt[x]++ , cnt[y]--;\n        f[find(x)] = find(y);\n    }\n    int flag = 1;\n    for(int i = 0 ; i <= 500 ; i++) {\n        if(i > 250 && cnt[i] > 0) flag = 0;\n        if(i < 250 && cnt[i] < 0) flag = 0;\n        if(cnt[i] > 0) {\n            c[find(i)] = 1;\n        }\n    }\n    for(int i = 0 ; i <= 500 ; i++) {\n        if(vc[i].size() > 0 && !c[find(i)]) flag = 0;\n    }\n    flag ? puts(\"YES\") : puts(\"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = a; i < (b); ++i)\n#define rrep(i,a,b) for(int i = b; i --> (a);)\n#define all(v) v.begin(),v.end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) (int)(v).size()\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nstruct UF {\n\tvi t;\n\tUF(int n){\n\t\tt.resize(n,-1);\n\t}\n\tint find(int a){\n\t\treturn t[a]<0 ? a : t[a] = find(t[a]);\n\t}\n\tvoid uni(int a, int b){\n\t\ta = find(a), b = find(b);\n\t\tif(a == b) return;\n\t\tif(t[a] < t[b]) swap(a,b);\n\t\tt[b] += t[a];\n\t\tt[a] = b;\n\t}\n};\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint n, h;\n\tcin >> n >> h;\n\t++h;\n\tvi as(n), bs(n), cs(n), ds(n);\n\trep(i,0,n) cin >> as[i] >> bs[i] >> cs[i] >> ds[i];\n\tvi cnt(2*h);\n\n\tUF uf(2*h);\n\tvector<bool> seen(2*h);\n\trep(i,0,n){\n\t\tint x = -1,y = -1;\n\t\tif(cs[i]==0) ++cnt[as[i]], x = as[i];\n\t\telse --cnt[cs[i]+h], x = cs[i]+h;\n\t\tif(ds[i]==0) ++cnt[bs[i]+h], y = bs[i]+h;\n\t\telse --cnt[ds[i]], y = ds[i];\n\t\tuf.uni(x,y);\n\t\tseen[x] = seen[y] = 1;\n\t}\n\trep(i,0,2*h) if(seen[i] && i == uf.find(i)){\n\t\trep(j,0,2*h)\n\t\t\tif(i == uf.find(j) && cnt[j] > 0)\n\t\t\t\tgoto fine;\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t\tfine: ;\n\t}\n\ttrav(x, cnt) if(x < 0){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define maxn 100005\n#define N 200\nusing namespace std;\nint n,h,indeg[N*2+5],outdeg[N*2+5];\nbool vis[N*2+5];\nstruct node { int v; node *nxt; } edge[maxn],*head[N*2+5],*ncnt;\nvoid addedge(int u,int v)\n{\n\tncnt++;\n\tncnt->v=v,ncnt->nxt=head[u];\n\thead[u]=ncnt,indeg[v]++,outdeg[u]++;\n}\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(node *p=head[u];p;p=p->nxt)\n\t\tif(!vis[p->v]) dfs(p->v);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tncnt=&edge[0];\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tint a,b,c,d,l,r;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t//printf(\" * %d %d %d %d\\n\",a,b,c,d);\n\t\tl=c?(-c):a,r=d?d:(-b);\n\t\t//printf(\" - %d %d\\n\",l,r);\n\t\taddedge(l+N,r+N);\n\t}\n\tfor(int i=0;i<N;i++)\n\t\tif(indeg[i]<outdeg[i]) { printf(\"NO\\n\"); return 0; }\n\tfor(int i=N+1;i<=N*2;i++)\n\t\tif(indeg[i]>outdeg[i]) { printf(\"NO\\n\"); return 0; }\n\tfor(int i=0;i<=N*2;i++)\n\t\tif(outdeg[i]>indeg[i]&&!vis[i]) dfs(i);\n\tfor(int i=0;i<=N*2;i++)\n\t\tif((indeg[i]||outdeg[i])&&!vis[i]) { printf(\"NO\\n\"); return 0; }\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nstruct UnionFind {\n    int n, cc, *u;\n    UnionFind() : n(0), cc(0), u(NULL) {}\n    UnionFind(int n_) : n(n_), cc(n_) {\n\tu = new int[n_];\n\tmemset(u, -1, sizeof (int) * n);\n    }\n    UnionFind(const UnionFind &y) : n(y.n), cc(y.cc) {\n\tu = new int[y.n];\n\tmemcpy(u, y.u, sizeof (int) * n);\n    }\n    ~UnionFind() {\n\tdelete[] u; u = NULL;\n\tn = cc = 0;\n    }\n    friend void swap(UnionFind &x, UnionFind &y) {\n\tswap(x.n, y.n); swap(x.cc, y.cc); swap(x.u, y.u);\n    }\n    UnionFind& operator=(UnionFind y) { \n\tswap(*this, y);\n\treturn *this;\n    }\n    int root(int x) {\n\tint y = x, t;\n\twhile (u[y] >= 0) y = u[y];\n\twhile (x != y) { t = u[x]; u[x] = y; x = t; }\n\treturn y;\n    }\n    bool link(int x, int y) {\n\tx = root(x); y = root(y);\n\tif (x == y) return false;\n\tif (u[y] < u[x]) swap(x, y);\n\tu[x] += u[y]; u[y] = x; cc--;\n\treturn true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -u[root(x)]; }\n    int count() { return cc; }\n};\n\nint N;\nconst int SIZE = 411;\nint in[SIZE], out[SIZE];\nVI G[SIZE];\nint deg[SIZE];\n\nvoid MAIN() {\n    scanf(\"%d%*d\", &N);\n    UnionFind U(SIZE);\n    REP (i, N) {\n\tint a, b, c, d;\n\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\n\tint u, v;\n\tif (c == 0) {\n\t    u = a*2;\n\t} else {\n\t    u = c*2+1;\n\t}\n\tif (d == 0) {\n\t    v = b*2+1;\n\t} else {\n\t    v = d*2;\n\t}\n\tout[u]++;\n\tin[v]++;\n\tU.link(u, v);\n\n\t//eprintf(\"%d %d\\n\", u, v);\n\t//REP (j, 4) {\n\t//    if (4-a-c <= j && j < 4-c) putchar('#');\n\t//    else putchar(' ');\n\t//    putchar('#');\n\t//    if (4-b-d <= j && j < 4-d) putchar('#');\n\t//    else putchar(' ');\n\t//    putchar('\\n');\n\t//}\n\t//putchar('\\n');\n    }\n\n    bool yes = true;\n\n    REP (i, SIZE) if (in[i] || out[i]) G[U.root(i)].push_back(i);\n\n    REP (r, SIZE) if (G[r].size()) {\n\tint start = 0, stop = 0;\n\tEACH (e, G[r]) {\n\t    int i = *e;\n\n\t    if (in[i] < out[i]) {\n\t\tif (i % 2) yes = false;\n\t\tstart += out[i] - in[i];\n\t    }\n\t    if (in[i] > out[i]) {\n\t\tif (i % 2 == 0) yes = false;\n\t\tstop += in[i] - out[i];\n\t    }\n\t}\n\tif (start != stop) {\n\t    yes = false;\n\t}\n\tif (start == 0 || stop == 0) {\n\t    yes = false;\n\t}\n    }\n\n    puts(yes? \"YES\": \"NO\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define pf push_front\n#define pb2 pop_back\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define pq priority_queue\n#define rep(k,i,j) for(int k = (int)i;k<(int)j;k++)\n#define repd(k,i,j) for(int k = (int)i;k>=(int)j;k--)\n#define ll long long\n#define ALL(a) a.begin(),a.end()\n#define vi vector<int>\n\nusing namespace std;\n\ndouble EPS = 1e-9;\nint INF = 1e9+7;;\nlong long INFLL = 1e17;\ndouble pi = acos(-1);\nint dirx[8] = {-1,0,0,1,-1,-1,1,1};\nint diry[8] = {0,1,-1,0,-1,1,-1,1};\n\nclock_t first_attempt = clock();\ninline void cek_time(){\n\tclock_t cur = clock()- first_attempt;\n\tcerr<<\"TIME : \"<<(double) cur/CLOCKS_PER_SEC<<endl;\n}\ninline void OPEN (string s) {\n  freopen ((s + \".in\").c_str (), \"r\", stdin);\n  freopen ((s + \".out\").c_str (), \"w\", stdout);\n}\n\n//end of template\n\nint n,H;\n\nconst int maxn=  1e5+4;\nint deg[maxn];\nvi adj[maxn];\nvoid add_edge(int a,int b){\n\tdeg[a]++;\n\tdeg[b]--;\n\tadj[a].pb(b);\n//\tprintf(\"%d -> %d\\n\",a,b);\n}\n\nint bisa = 1;\n\nvoid cycle2(int st){\n\tint a = st;\n\twhile(1){\n\t\tif(adj[a].size()==0){bisa=  0;return;}\n\t\tint b = adj[a].back();\n\t\tadj[a].pb2();\n\t\ta = b;\n\t\tif(a==st)return;\n\t}\n}\nvoid cycle(int st){\n\t\n\tint a = st;\n\twhile(1){\n\t\tif(adj[a].size()==0){bisa=  0;return;}\n\t\tint b = adj[a].back();\n\t\tadj[a].pb2();\n\t\ta = b;\n\t\tif(a<H)return;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&H);\n\t\n\tH+=2;\n\trep(k,0,n){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta+= c;\n\t\tb+= d;\n\t\tswap(a,c);swap(b,d);\n\t\t\n\t\tif(!a && !b){\n\t\t\tadd_edge(c,d);\n\t\t}\n\t\tif(!a && b){\n\t\t\tadd_edge(c,b + H);\n\t\t}\n\t\tif(a && !b){\n\t\t\tadd_edge(a+H,d);\n\t\t}\n\t\tif(a && b){\n\t\t\tadd_edge(a+H,b + H);\n\t\t}\n\t}\n\t\n\trep(k,0,H){\n\t\twhile(adj[k].size())cycle(k);\n\t}\n\t\n\trep(k,H,2*H+1){\n\t\twhile(adj[k].size())cycle2(k);\n\t}\n\t\n\tprintf(\"%s\\n\",bisa?\"YES\":\"NO\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=1000005;\nint n,h,i,j,k,l,ans,A,B,C,D,g[405][405],u[N],p[N],ind[N],outd[N];\nbool vis[N],ok[N];\nint find(int x)\n{\n\treturn p[x]==-1?x:p[x]=find(p[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tif(C)\n\t\t\tA=C+h;\n\t\tif(D)\n\t\t\tB=D+h;\n\t\tg[A][B<h?B+h:B-h]++;\n\t\tvis[A]=vis[B<h?B+h:B-h]=true;\n\t}\n\tfor(i=0;i<2*h;++i)\n\t\tfor(j=0;j<2*h;++j)\n\t\t\tind[j]+=g[i][j],outd[i]+=g[i][j];\n\tfor(i=0;i<h;++i)\n\t\tif(outd[i]<ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=h;i<2*h;++i)\n\t\tif(outd[i]>ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=0;i<2*h;++i)\n\t\tp[i]=-1;\n\tfor(i=0;i<2*h;++i)\n\t\tfor(j=0;j<2*h;++j)\n\t\t\tif(g[i][j]&&find(i)!=find(j))\n\t\t\t\tp[find(i)]=find(j);\n\tfor(i=0;i<2*h;++i)\n\t\tif(outd[i]!=ind[i])\n\t\t\tok[find(i)]=true;\n\tfor(i=0;i<2*h;++i)\n\t\tif(find(i)==i&&!ok[i]&&vis[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nint n,h,a[N],b[N],c[N],d[N];\n//是否存在可行流\nstruct edge{int f,t,g;}w[N];\nint s,t,S,T,head[N],nxt[N],cnt=1,I[N],O[N];\nvoid add(int f,int t,int g){\n\t//printf(\"%d->%d g=%d\\n\",f,t,g);\n\tw[++cnt]=(edge){f,t,g};\n\tnxt[cnt]=head[f];\n\thead[f]=cnt;\n\tw[++cnt]=(edge){t,f,0};\n\tnxt[cnt]=head[t];\n\thead[t]=cnt;\n}\nstruct st{\n\tint x,i,df;\n\tst(int X=0,int DF=0){x=X;i=head[x];df=DF;}\n}z[N];\nint top,flow,l[N];\n#define V z[top].x\n#define E z[top].i\n#define F z[top].df\nvoid change(){\n\tint df=F;flow+=df;\n\tfor (int i=top-1;i;i--){\n\t\tw[z[i].i].g-=df;\n\t\tw[z[i].i^1].g+=df;\n\t\tz[i].df-=df;\n\t\tif (!z[i].df) top=i;\n\t}\n}\nqueue<int> Q;\nvoid bfs(){\n\tfor (int i=s;i<=t;i++) l[i]=0;\n\tl[s]=1;Q.push(s);\n\twhile (!Q.empty()){\n\t\tint v=Q.front();Q.pop();\n\t\tfor (int i=head[v];i;i=nxt[i])\n\t\tif (w[i].g&&!l[w[i].t]) l[w[i].t]=l[v]+1,Q.push(w[i].t);\n\t}\n}\nbool dinic(){\n\tbfs();\n\tif (!l[t]) return 0;\n\tz[top=1]=st(s,1e9);\n\twhile (top){\n\t\tif (V==t) change(),top--,E=nxt[E];else\n\t\tif (!E) l[V]=0,top--,E=nxt[E];else\n\t\tif (w[E].g&&l[w[E].t]==l[V]+1)\n\t\t\tz[top+1]=st(w[E].t,min(F,w[E].g)),top++;\n\t\telse E=nxt[E];\n\t}\n\treturn 1;\n}\nvector<int> e[N];\nbool cir[N],vis[N];\nvoid bfs(int S,bool *vis){\n\tQ.push(S);vis[S]=1;\n\twhile (!Q.empty()){\n\t\tint v=Q.front();Q.pop();\n\t\tfor (int i=0;i<e[v].size();i++){\n\t\t\tint u=e[v][i];\n\t\t\tif (!vis[u]) vis[u]=1,Q.push(u);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tint f=(c[i]?c[i]+h:a[i]),t=(d[i]?d[i]:b[i]+h);\n\t\te[f].push_back(t);\n\t\tI[t]++;O[f]++;\n\t\tif (f==t) cir[f]=1;\n\t}\n\ts=0;S=h*2+1;T=S+1;t=T+1;\n\tadd(T,S,1e9);\n\tfor (int i=1;i<=2*h;i++){\n\t\tif (I[i]) add(s,i,I[i]);\n\t\tif (O[i]) add(i,t,O[i]);\n\t\tif (i>h) add(i,T,1e9);else add(S,i,1e9);\n\t}\n\twhile (dinic());\n\tif (flow!=n) return puts(\"NO\"),0;\n\tfor (int i=2;i<=cnt;i++)\n\t\tif (w[i^1].g) e[w[i].f].push_back(w[i].t);\n\tbfs(S,vis);\n\tfor (int i=1;i<=2*h;i++)\n\t\tif ((I[i]||O[i])&&!vis[i]) return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<tuple>\n#include<utility>\n#include<set>\n#include<queue>\n//#include<chrono>\n//#include<mt19937>\nusing namespace std;\ntypedef long long int llint;\nconst llint big=2e8;\nconst int mod=10000000;\n#define mt make_tuple\n#define mp make_pair\n#define fir first\n#define sec second\n#define pub push_back\n#define res resize\n#define ins insert\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nclass SCC{\n/*\n\t使い方\n\troadに辺を、rroadにその逆を突っ込んでください\n\tメンバ関数のdo_sccしてください\n\tunite_sccでまとめることができます\n\t*/\npublic:\n\tvector<vector<int>>road;\n\tvector<vector<int>>rroad;\n\tvector<int>ban;//帰りがけ順の場所\n\tvector<bool>sir;//調べたらtrue\n\tvector<int>uni;//同じ連結成分かどうか\n\tint n,num,kyonum;\n\tvoid dfs_scc(int town){\n\t\tif(sir[town]){return;}\n\t\tsir[town]=true;//cout<<\"de \"<<town<<endl;\n\t\tfor(int i=0;i<road[town].size();i++){dfs_scc(road[town][i]);}\n\t\tban.pub(town);\n\t\treturn;\n\t}\n\tvoid rdfs_scc(int town){\n\t\tif(uni[town]!=0){return;}\n\t\tuni[town]=kyonum;//cout<<\"rde \"<<town<<endl;\n\t\tfor(int i=0;i<rroad[town].size();i++){rdfs_scc(rroad[town][i]);}\n\t\treturn;\n\t}\n\tvoid do_scc(void){\n\t\t//同じ連結成分を同じ組にしたvectorを返す\n\t\t//chain_sccにそれをかますと頂点をまとめてDAGにしてくれる\n\t\tn=road.size();\n\t\tnum=1;\n\t\tsir.res(n);\n\t\tuni.res(n);\n\t\tint i,j;\n\t\tfor(i=0;i<n;i++){dfs_scc(i);}\n\t\tkyonum=1;\n\t\tfor(i=0;i<n;i++){if(uni[ban[n-i-1]]==0){rdfs_scc(ban[n-i-1]);kyonum++;}}\n\t\treturn;\n\t}//kyonumの数だけ成分がある\n\tvector<vector<int>>Croad;\n\tvector<vector<int>>Crroad;\n\tvoid chain_scc(void){\n\t\t//uni番目の街に対応させる\n\t\t//uniは1-beginに注意\n\t\tint i,j;\n\t\tCroad.res(kyonum);\n\t\tCrroad.res(kyonum);\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<road[i].size();j++){if(uni[i]!=uni[road[i][j]]){Croad[uni[i]].pub(uni[road[i][j]]);}}\n\t\t\tfor(j=0;j<rroad[i].size();j++){if(uni[i]!=uni[rroad[i][j]]){Crroad[uni[i]].pub(uni[rroad[i][j]]);}}\n\t\t}\n\t\tfor(i=1;i<kyonum;i++){\n\t\t\tsort(Croad[i].begin(),Croad[i].end());\n\t\t\tunique(Croad[i].begin(),Croad[i].end());\n\t\t\tsort(Crroad[i].begin(),Crroad[i].end());\n\t\t\tunique(Crroad[i].begin(),Crroad[i].end());\n\t\t}\n\t\treturn;\n\t}\n};\n\nint main(void){\n\tstatic int b_zi[201]={0};//入り次数\n\tstatic int p_zi[201]={0};\n\tstatic int uses[401]={0};\n\tuses[200]++;\n\tclass SCC gla;\n\tgla.road.res(401);\n\tgla.rroad.res(401);\n\tint n,h,i,j,a,b,c,d;cin>>n>>h;\n\tfor(i=0;i<n;i++){\n\t\tcin>>a>>b>>c>>d;\n\t\tint x,y;\n\t\tif(c==0){p_zi[a]--;x=-a;}else{b_zi[c]--;x=c;}\n\t\tif(d==0){b_zi[b]++;y=b;}else{p_zi[d]++;y=-d;}\n\t\tuses[x+200]++;uses[y+200]++;\n\t\tgla.road[200+x].pub(200+y);\n\t\tgla.rroad[200+y].pub(200+x);\n\t}\n\tfor(i=1;i<=200;i++){\n\t\tif(b_zi[i]<0){cout<<\"NO\"<<endl;return 0;}\n\t\tfor(j=0;j<b_zi[i];j++){gla.road[200+i].pub(200);gla.rroad[200].pub(200+i);}\n\t}\n\tfor(i=1;i<=200;i++){\n\t\tif(p_zi[i]>0){cout<<\"NO\"<<endl;return 0;}\n\t\tfor(j=0;j<-p_zi[i];j++){gla.road[200].pub(200-i);gla.rroad[200-i].pub(200);}\n\t}\n\tgla.do_scc();\n\tint it=0;\n\tfor(i=0;i<401;i++){\n\t\tif(uses[i]==0){it++;}\n\t}\n\tif(gla.kyonum<=2+it){cout<<\"YES\"<<endl;}\n\telse{cout<<\"NO\"<<endl;}\n\treturn 0;\n\t//b_zi -> dbTdb P⊥q\n\t//pが少なく、bが多いほどいい\n\t//0を含む路が連結ならよい\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=205,M=N*2;\n\nint fa[M],si[M],so[M];\nstd::vector<int>p[M];\n\ninline int find(int x)\n{\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\n\nint main()\n{\n\tint n,a,b,c,d;\n\tin,n,a;\n\tfo0(i,M)fa[i]=i;\n\tfo0(i,n)\n\t{\n\t\tin,a,b,c,d;\n\t\ta=c?-c:a;\n\t\tb=d?d:-b;\n\t\ta+=N,b+=N;\n\t\tso[a]++;\n\t\tsi[b]++;\n\t\t//out,a,' ',b,' ',a-N,' ',b-N,'\\n';\n\t\tfa[find(a)]=find(b);\n\t}\n\tfo0(i,M)p[find(i)].pb(i);\n\tbool flag=1;\n\tfo0(i,M)\n\t{\n\t\tif(i-N<0)flag&=so[i]<=si[i];\n\t\telse flag&=si[i]<=so[i];\n\t}\n\tfo0(i,M)if(fa[i]==i&&(si[i]||so[i]))\n\t{\n\t\tbool t=0;\n\t\tfoe(j,p[i])t|=si[*j]!=so[*j];\n\t\tflag&=t;\n\t}\n\tout,flag?\"YES\":\"NO\",'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n\nint a,b,c,d;\n\nint n,h;\n\nint need[256];\nint sup[256];\n\nint ends=0;\nbool good=1;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d%d\",&n,&h);\n    for (int i=0; i<n; i++) {\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        if (c==0) sup[a]++;\n        else need[c]++;\n        if (d==0) sup[b]++;\n        else need[d]++;\n    }\n    for (int i=0; i<256; i++) {\n        if (need[i]>sup[i]) good=0;\n        if (need[i]<sup[i]) ends++;\n    }\n    if (good && ends>0) printf(\"YES\");\n    else printf(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\ntypedef struct{\n  int to;\n  int cap;\n  int rev;\n  bool is_rev;\n}edge;\n\n// node v : distance from s => level[v]\nvoid bfs(vector<vector<edge> > &G, vector<int> &level, int s){\n  fill(level.begin(), level.end(), -1);\n  queue<int> q;\n  q.push(s);\n  level[s] = 0;\n  while(!q.empty()){\n    int e=q.front(); q.pop();\n    for(int i=0; i<G[e].size(); i++){\n      if(G[e][i].cap > 0 && level[G[e][i].to] < 0){\n        level[G[e][i].to] = level[e] + 1;\n        q.push(G[e][i].to);\n      }\n    }\n  }\n}\n\nint dfs(vector<vector<edge> > &G, vector<int> &level, vector<bool> &used, vector<int> &iter, int s, int f,  int t){\n  if(s==t) return f;\n  else{\n    //iter[e] : done searching from v[0] to v[ iter[e]-1 ]\n    for(int &i=iter[s]; i<G[s].size(); i++){\n      //distance from s to v[e][i].to must be longer than dist from s to v\n      if(G[s][i].cap > 0 && level[s] < level[ G[s][i].to ]){\n        int d = dfs(G, level, used, iter, G[s][i].to, min(f, G[s][i].cap), t);\n        if(d>0){\n          G[s][i].cap -= d;\n          G[ G[s][i].to ][ G[s][i].rev ].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n}\n\nint dinic_maxflow(vector<vector<edge> > &G, int s, int t){\n  const int INF = 100000000;\n  int flow=0;\n  while(true){\n    vector<int> level(G.size(), -1);\n    vector<int> iter(G.size(), 0);\n    vector<bool> used(G.size(), false);\n    bfs(G, level, s);\n    if(level[t] < 0) return flow; //unable to achieve to t\n    while(true){\n      int f = dfs(G, level, used, iter, s, INF, t);\n      if(f==0) break;\n      else flow += f;\n    }\n  }\n}\n\nvoid add_edge(vector<vector<edge> > &G, int from, int to, int cap){\n  G[from].push_back((edge){to, cap, (int)G[to].size(), false});\n  G[to].push_back((edge){from, 0, (int)G[from].size() - 1, true});\n}\n\nclass SCC{\n  int n;\n  vector<vector<int> > G;\n  vector<vector<int> > rG;\n  \n  void dfs(vector<bool> &visit, int pos, vector<int> &result){\n    visit[pos] = true;\n    for(int i=0; i<G[pos].size(); i++){\n      if(visit[ G[pos][i] ]) continue;\n      dfs(visit, G[pos][i], result);\n    }\n    result.push_back(pos);\n  }\n\n  void rdfs(vector<bool> &visit, int pos, int k){\n    visit[pos] = true;\n    component[pos] = k;\n    for(int i=0; i<rG[pos].size(); i++){\n      if(visit[ rG[pos][i] ]) continue;\n      rdfs(visit, rG[pos][i], k);\n    }\n  }\n\n  void make_rev(vector<vector<int> > &G){\n    for(int i=0; i<n; i++){\n      for(int j=0; j<G[i].size(); j++){\n        rG[ G[i][j] ].push_back(i);\n      }\n    }\n  }\n\n public:\n  int num_components;\n  vector<int> component;\n  vector< vector<int> > scc_graph;\n  \n  SCC(int n){\n    this->n = n;\n    G.resize(n);\n    rG.resize(n);\n  }\n\n  SCC(vector<vector<int> > &G){\n    this->n = G.size();\n    this->G = G;\n    rG.resize(n);\n    make_rev(G);\n  }\n  \n  void strongly_connected_components(){\n    vector<bool> visit(n, false);\n    vector<int> result;\n\n    for(int i=0; i<n; i++){\n      if(visit[i]) continue;\n      dfs(visit, i, result);\n    }\n\n    \n    component.resize(n);\n    fill(visit.begin(), visit.end(), false);\n    int k=0;\n    for(int i=result.size()-1; i>=0; i--){\n      if(visit[ result[i] ]) continue;\n      rdfs(visit, result[i], k);\n      k++;\n    }\n\n    num_components = k;\n    scc_graph.resize( num_components );\n    for(int i=0; i<n; i++){\n      int cmp = component[i];\n      for(int j=0; j<G[i].size(); j++){\n        if(component[ G[i][j] ] == cmp) continue;\n        scc_graph[cmp].push_back( component[ G[i][j] ] );\n      }\n    }\n    \n    for(int i=0; i<scc_graph.size(); i++){\n      sort(scc_graph[i].begin(), scc_graph[i].end());\n      scc_graph[i].erase( unique(scc_graph[i].begin(), scc_graph[i].end()), scc_graph[i].end());\n    }\n    \n  }\n  \n  void add_edge(int from, int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n};\n\n\nint main(){\n  int n,h;\n  cin >> n,h;\n  vector<int> a(n),b(n),c(n),d(n);\n  for(int i=0; i<n; i++){\n    cin >> a[i],b[i],c[i],d[i];\n  }\n\n  map<pair<int,int>, int> in_cnt;\n  map<pair<int,int>, int> out_cnt;\n  int z_in = 0, z_out = 0;\n  for(int i=0; i<n; i++){\n    if( c[i] == 0 ){\n      in_cnt[ {a[i], 0} ]++;\n      z_in++;\n    }else{\n      in_cnt[ {c[i], 1} ]++;\n    }\n    if( d[i] == 0 ){\n      out_cnt[ {b[i], 0} ]++;\n      z_out++;\n    }else{\n      out_cnt[ {d[i], 1} ]++;\n    }\n  }\n\n  map<tuple<int,int,int>, int> dict;\n  int idx = 0;\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n\n\n  int zero_0 = idx++;\n  int zero_1 = idx++;\n  int source = idx++;\n  int sink = idx++;\n\n  int super_source = idx++;\n  int super_sink = idx++;\n\n  vector<vector<edge>> G(idx);\n  SCC scc(idx-4);\n\n\n  scc.add_edge(zero_0, zero_1);\n  add_edge(G, zero_0, zero_1, n+10);\n  add_edge(G, super_source, zero_1, 1);\n  add_edge(G, zero_0, super_sink, 1);\n\n  for(int i=0; i<n; i++){\n    auto t = make_tuple(0, c[i]==0 ? a[i] : c[i], min(1, c[i]));\n    auto r = make_tuple(1, d[i]==0 ? b[i] : d[i], min(1, d[i]));\n    scc.add_edge( dict[t], dict[r] );\n  }\n\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, v, sink, p.second);\n\n    if( p.first.second == 0 ){\n      add_edge(G, zero_1, v, p.second);\n      scc.add_edge(zero_1, v);\n    }\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, source, v, p.second);\n    auto r = make_tuple(0, p.first.first, p.first.second^1);\n    if( dict.count(r) ){\n      add_edge(G, v, dict[r], p.second);\n      scc.add_edge(v, dict[r]);\n    }\n\n    if( p.first.second == 0 ){\n      add_edge(G, v, zero_0, p.second);\n      scc.add_edge(v, zero_0);\n    }\n  }\n\n  scc.strongly_connected_components();\n  int cmp = scc.num_components;\n  eprintln(cmp);\n  if(cmp != 1){\n    println(\"NO\");\n    return 0;\n  }\n\n  int f = 0;\n  // f += dinic_maxflow(G, super_source, sink);\n  // f += dinic_maxflow(G, source, super_sink);\n  // f += dinic_maxflow(G, super_source, super_sink);\n  eprintln(f);\n\n  // if( f != 2 ){\n  //   println(\"NO\");\n  //   return 0;\n  // }\n  // f--;\n  if(!z_in || !z_out){\n    println(\"NO\");\n    return 0;\n  }\n\n  add_edge(G, super_source, source, n+100);\n  add_edge(G, sink, super_sink, n+100);\n\n  f += dinic_maxflow(G, super_source, super_sink) - 1;\n  // f += dinic_maxflow(G, source, sink);\n  eprintln(f);\n\n  if( f!=n ){\n    println(\"NO\");\n    return 0;\n  }\n\n  SCC scc2(G.size()-4);\n  scc2.add_edge(zero_0, zero_1);\n  for(int i=0; i<G.size()-4; i++){\n    for(auto e : G[i]){\n      if( e.is_rev || e.to >= G.size()-4 || G[e.to][e.rev].cap == 0 ) continue;\n      scc2.add_edge(i, e.to);\n    }\n  }\n\n  for(int i=0; i<n; i++){\n    auto t = make_tuple(0, c[i]==0 ? a[i] : c[i], min(1, c[i]));\n    auto r = make_tuple(1, d[i]==0 ? b[i] : d[i], min(1, d[i]));\n    scc2.add_edge( dict[t], dict[r] );\n  }\n\n  scc2.strongly_connected_components();\n\n  int cmp2 = scc2.num_components;\n  if( cmp2 != 1 ){\n    println(\"NO\");\n  }else{\n    println(\"YES\");\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nvector <int> LI[444], LO[444], RI[444], RO[444];\nvector <pii> V;\nbool chk[444];\nmultiset <int> SL, SR;\nint n, h;\n\nvoid dfs(int p, vector <int> *V)\n{\n\tchk[p] = 1;\n\tfor(int t: V[p]){\n\t\tif(!chk[t]) dfs(t, V);\n\t}\n}\n\nvoid die()\n{\n\tprintf(\"NO\\n\");\n\texit(0);\n}\n\nint main()\n{\n\tint i, j, a, b, c, d;\n\t\n\tscanf(\"%d%d\", &n, &h);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\n\t\tif(c == 0 && d == 0){\n\t\t\tLO[0].push_back(a);\n\t\t\tLI[a].push_back(0);\n\t\t\tRO[0].push_back(b);\n\t\t\tRI[b].push_back(0);\n\t\t}\n\t\telse if(c == 0){\n\t\t\tLO[d].push_back(a);\n\t\t\tLI[a].push_back(d);\n\t\t}\n\t\telse if(d == 0){\n\t\t\tRO[c].push_back(b);\n\t\t\tRI[b].push_back(c);\n\t\t}\n\t\telse V.push_back(pii(c, d));\n\t}\n\t\n\tdfs(0, LO);\n\t\n\tfor(i=1;i<h;i++){\n\t\tif(LO[i].size() && !chk[i]) die();\n\t\tif(LI[i].size() >= LO[i].size()){\n\t\t\tfor(j=0;j<LI[i].size() - LO[i].size();j++) SL.insert(i);\n\t\t}\n\t\telse die();\n\t\tchk[i] = 0;\n\t}\n\t\n\tdfs(0, RO);\n\t\n\tfor(i=1;i<h;i++){\n\t\tif(RO[i].size() && !chk[i]) die();\n\t\tif(RI[i].size() >= RO[i].size()){\n\t\t\tfor(j=0;j<RI[i].size() - RO[i].size();j++) SR.insert(i);\n\t\t}\n\t\telse die();\n\t\tchk[i] = 0;\n\t}\n\t\n\tfor(pii t: V){\n\t\tauto it = SL.find(t.second);\n\t\tif(it == SL.end()) die();\n\t\tSL.erase(it);\n\t\t\n\t\tit = SR.find(t.first);\n\t\tif(it == SR.end()) die();\n\t\tSR.erase(it);\n\t}\n\t\n\tif(SL.empty() || SR.empty()) die();\n\t\n\tprintf(\"YES\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int maxn = 1e5+10;\nint down_l[205], down_r[205], up_l[205], up_r[205];\nint l_l[maxn],l_r[maxn],h_l[maxn],h_r[maxn];\nint main()\n{\n\tint n,h;\n\tint a,b,c,d;\n\tint count_up;\n\twhile(~scanf(\"%d%d\",&n,&h)){\n\t\tcount_up = 0;\n\t\tmemset(down_l,0,sizeof(int)*205);\n\t\tmemset(down_r,0,sizeof(int)*205);\n\t\tmemset(up_l,0,sizeof(int)*205);\n\t\tmemset(up_r,0,sizeof(int)*205);\n\t\tfor(int i = 0; i<n; i++){\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\tl_l[i] = a; l_r[i] = b;\n\t\t\th_l[i] = c; h_r[i] = d;\n\t\t\tif(c == 0) down_l[a]++;\n\t\t\telse {\n\t\t\t\tup_l[a]++;\n\t\t\t\tcount_up ++;\n\t\t\t}\n\t\t\tif(d == 0) down_r[b]++;\n\t\t\telse {\n\t\t\t\tup_r[b]++;\n\t\t\t\tcount_up++;\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int i = 0; i<n; i++){\n\t\t\tint a = l_l[i], b = l_r[i];\n\t\t\tint c = h_l[i], d = h_r[i];\n\t\t\tif(c != 0){\n\t\t\t\tint dis = 0;\n\t\t\t\tif(c == b) dis = 1;\n\t\t\t\tif(down_r[c] - dis > 0) down_r[c]--;\n\t\t\t\telse{\n\t\t\t\t\tflag = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( d != 0){\n\t\t\t\tint dis = 0;\n\t\t\t\tif(a == d) dis = 1;\n\t\t\t\tif(down_l[d] - dis > 0) down_l[d]--;\n\t\t\t\telse {\n\t\t\t\t\tflag = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=200000+10;\nint fa[maxn],vis[maxn],du[maxn],bz[maxn];\nint i,j,k,l,t,n,m,a,b,c,d,x,y;\nbool czy;\nint getfa(int x){\n\treturn fa[x]==x?x:fa[x]=getfa(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,1000) fa[i]=i;\n\tfo(i,1,n){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=c?-c:a;\n\t\ty=d?d:-b;\n\t\tx+=500;y+=500;\n\t\tfa[getfa(x)]=getfa(y);\n\t\tdu[x]++;du[y]--;\n\t\tvis[x]=1;\n\t}\n\tczy=1;\n\tfo(i,1,499)\n\t\tif (du[i]>0) czy=0;\n\tfo(i,501,1000)\n\t\tif (du[i]<0) czy=0;\n\tfo(i,1,1000) vis[getfa(i)]|=vis[i];\n\tfo(i,1,1000)\n\t\tif (du[i]) bz[getfa(i)]=1;\n\tfo(i,1,1000)\n\t\tif (fa[i]==i&&!bz[i]&&vis[i]) czy=0;\n\tif (czy) printf(\"Yes\\n\");else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"grader.h\"\n#include <bits/stdc++.h>  \n\nusing namespace std;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define re return\n#define fi first\n#define mp make_pair\n#define se second\n#define sz(a) (int)a.size()\n#define prev previ\n#define tm tmmm\n#define div divv\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\n\nconst ll mod = ll(1e9) + 9LL, pr = 239, mod2 = ll(1e9) + 7;\n\nll n, h, cnt[401], cnt1[401], cntk[401][401];\n\nint main() {\n\tiostream::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> h;\n\tint k1 = 0;\n\tbool ok1 = false, ok2 = false;\n\tforn (i, n) {\n\t\tint a1, b, c, d;\n\t\tcin >> b >> d >> a1 >> c;\n\n\t\tif (a1)\n\t\t\tb = -a1;\n\t\tif (c)\n\t\t\td = -c;\n\t\tif (b > 0) ok1 = true;\n\t\tif (d > 0) ok2 = true;\n\t\tcnt[b + h]++;\n\t\tcnt1[d + h]++;\t\n\t\tcntk[b + h][d + h]++;\n\t}\n\tforn (i, h) {\n\t\tif (cnt[i] > cnt1[2 * h - i] || cnt1[i] > cnt[2 * h - i] || (cnt[i] && cnt[i] == cntk[i][2 * h - i]) || (cnt1[i] && cnt1[i] == cntk[2 * h - i][i])) {\n\t\t\tcout << \"NO\\n\";\n\t\t\tre 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst long long INF = (1ll << 50);\nstruct graph {\n  typedef long long flow_type;\n  struct edge {\n    int src, dst;\n    flow_type capacity, flow;\n    size_t rev;\n  };\n  int n;\n  vector<vector<edge>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst, flow_type capacity) {\n    adj[src].push_back({src, dst, capacity, 0, adj[dst].size()});\n    adj[dst].push_back({dst, src, 0, 0, adj[src].size()-1});\n  }\n  flow_type max_flow(int s, int t, bool first=false) {\n    if (first) {\n      for (int u = 0; u < n; ++u) // initialize\n      for (auto &e: adj[u]) e.flow = 0;\n    }\n\n    vector<int> level(n), iter(n);\n    function<int(void)> levelize = [&]() { // foward levelize\n      level.assign(n, -1); level[s] = 0;\n      queue<int> Q; Q.push(s);\n      while (!Q.empty()) {\n        int u = Q.front(); Q.pop();\n        if (u == t) break;\n        for (auto &e: adj[u]) {\n          if (e.capacity > e.flow && level[e.dst] < 0) {\n            Q.push(e.dst);\n            level[e.dst] = level[u] + 1;\n          }\n        }\n      }\n      return level[t];\n    };\n    function<flow_type(int, flow_type)> augment = [&](int u, flow_type cur) {\n      if (u == t) return cur;\n      for (int &i = iter[u]; i < adj[u].size(); ++i) {\n        edge &e = adj[u][i], &r = adj[e.dst][e.rev];\n        if (e.capacity > e.flow && level[u] < level[e.dst]) {\n          flow_type f = augment(e.dst, min(cur, e.capacity - e.flow));\n          if (f > 0) {\n            e.flow += f;\n            r.flow -= f;\n            return f;\n          }\n        }\n      }\n      return flow_type(0);\n    };\n\n    flow_type flow = 0;\n    while (levelize() >= 0) {\n      fill(all(iter), 0);\n      for (flow_type f; (f = augment(s, INF)) > 0; )\n        flow += f;\n    }\n    return flow;\n  }\n};\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\nint cnt2[500];\nint cnt3[500];\n\nint MakeVertex(int a, int c) {\n  if (c == 0) return a;\n  return c+(H+1);\n}\n\nsigned main(){\n  cin >> N >> H;\n\n  int S = 0;\n  int S2 = S+1;\n  int T2 = S2+1;\n  int l2 = T2+1;\n  int l3 = l2+2*(H+2);\n  int gr = l3+2*(H+2);\n  int grL = gr+1;\n  int grR = grL+1;\n  int T = grR+1;\n  graph g(T+1);\n\n\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    \n    int u = MakeVertex(B[i], D[i]);\n    cnt2[u]++;\n    int v = MakeVertex(A[i], C[i]);\n    cnt3[v]++;\n\n  }\n\n  reps(i, l2, l3) {\n    int u = i - l2;\n    int v = (u >= H+1) ? u-(H+1) : u+H+1;\n    g.add_edge(l2+u, l3+v, N);\n    if (cnt2[u] > 0) {\n      //g.add_edge(S, l2+u, cnt2[u]);\n      g.add_edge(S2, l2+u, cnt2[u]);\n      g.add_edge(S, T2, cnt2[u]);\n    }\n  }\n\n  reps(i, l3, gr) {\n    int u = i - l3;\n    if (cnt3[u] > 0) {\n      //g.add_edge(l3+u, T, cnt3[u]);\n      g.add_edge(S2, T, cnt3[u]);\n      g.add_edge(l3+u, T2, cnt3[u]);\n    }\n  }\n    \n  //g.add_edge(S, gr, N);\n  //g.add_edge(gr, T, N);\n\n  // g.add_edge(S, grL, 1);\n  g.add_edge(S2, grL, 1);\n  g.add_edge(S, T2, 1);\n\n  // g.add_edge(grR, T, 1);\n  g.add_edge(S2, T, 1);\n  g.add_edge(grR, T2, 1);\n\n  reps(h, 1, H+1) {\n    int v = MakeVertex(h, 0);\n    g.add_edge(l2+v, gr, N);\n    g.add_edge(gr, l3+v, N);\n    g.add_edge(l2+v, grR, 1);\n    g.add_edge(grL, l3+v, 1);\n  }\n\n  LL a = g.max_flow(S2, T2, true);\n  LL b = g.max_flow(S, T2);\n  LL c = g.max_flow(S2, T);\n  LL d = g.max_flow(S, T);\n  //cout \n  //<< a << \",\" \n  //<< b << \",\"\n  //<< c << \",\"\n  //<< d << endl;\n\n  if (a+b == a+c && a+b == N*2+2) {\n    cout << \"YES\" << endl;\n    return 0;\n  }\n  cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nconst int N = 4e2 + 100;\nint f[N];\nint ff(int x) {\n\treturn f[x] == x ? x : f[x] = ff(f[x]);\n}\nint n, h;\nint in[N], ou[N], ok[N];\n\nint main() {\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d, l, r;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tl = c == 0 ? a : h + a;\n\t\tr = d == 0 ? h + b : b;\n\t\t++ou[l], ++in[r];\n\t\tf[ff(l)] = ff(r);\n\t}\n\tfor (int i = 1; i <= h; ++i)\n\t\tif (ou[i] < in[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = h + 1; i <= h + h; ++i)\n\t\tif (in[i] < ou[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (in[i] != ou[i])\n\t\t\tok[ff(i)] = true;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (ff(i) == i && !ok[i])\n\t\t\treturn puts(\"NO\"), 0;\n\treturn puts(\"YES\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\n\n\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint th = 0;\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, -dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st != e[401]||st>=e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\n\tbool exiroad[402][402] = {};\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tfill(chked, chked + 402, false);\n\t\tq.push(i); chked[i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front(); q.pop();\n\t\t\trep(j, G[x].size()) {\n\t\t\t\tint to = G[x][j];\n\t\t\t\tif (chked[to])continue;\n\t\t\t\tchked[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\trep(j, 402) {\n\t\t\tif (chked[j]) {\n\t\t\t\texiroad[i][j] = true;\n\t\t\t\texi[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tRep(j, i + 1, 402) {\n\t\t\tif (!exi[j])continue;\n\t\t\tif (!exiroad[i][j] || !exiroad[j][i]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,a,b) for (int i=(int)(a); i<(int)(b); ++i)\n#define repeq(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define rrep(i,a,b) for (int i=(int)(a)-1; i>=(int)(b); --i)\n#define rrepeq(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\ntemplate<> struct is_plural<string> : true_type{};\n\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n\nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<typename T>\nstruct edge {\n  int from, to;\n  T cost;\n\n  edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n\n  edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n\n  bool operator<(const edge<T> &e) const {\n    return cost < e.cost;\n  }\n};\n\ntemplate<typename T> using Edges = vector<edge<T>>;\ntemplate<typename T> using WeightedGraph = vector<vector<edge<T>>>;\n\nvoid finish() {\n  cout << \"NO\\n\";\n  exit(0);\n}\n\nvoid solve() {\n  int n, h; cin >> n >> h;\n  vi cnt(h*2, 0);\n  WeightedGraph<int> g(h*2 + 1);\n  rep(i,0,n) {\n    int a, b, c, d; cin >> a >> b >> c >> d;\n    int u = (c == 0 ? a : c + h) - 1;\n    int v = (d == 0 ? b + h : d) - 1;\n    ++cnt[u], --cnt[v];\n    g[u].emplace_back(v, i);\n  }\n\n  int s = h*2;\n  int tmp = n;\n\n  rep(i,0,h) {\n    if (cnt[i] < 0) finish();\n    rep(_,0,cnt[i]) {\n      g[s].emplace_back(i, tmp++);\n    }\n  }\n  rep(i,h,2*h) {\n    if (cnt[i] > 0) finish();\n    rrep(_,0,cnt[i]) {\n      g[i].emplace_back(s, tmp++);\n    }\n  }\n\n  vb seen(tmp, false);\n\n  auto dfs = [&](auto dfs, int v) -> void {\n    bool p = false;\n    for (auto &nv : g[v]) {\n      if (!seen[nv.cost]) {\n        seen[nv.cost] = true;\n        if (p) s = v;\n        dfs(dfs, nv);\n        p = true;\n      }\n    }\n    if (!p && s != v) finish();\n  };\n\n  dfs(dfs, s);\n\n  rep(i,0,tmp) if (!seen[i]) finish();\n  cout << \"YES\\n\";\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<P>vec;\nint sum[405];\nint par[405],ran[405];\nvoid init(){ for(int i=0;i<405;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nint cnt[405],X;\nset<int>S;\nint main(){\n\tcin>>n>>m;init();\n\trep(i,n){\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\t\tif(c==0) a+=200; else a=c;\n\t\tif(d==0); else b=200+d;\n\t\tvec.pb(mp(a,b));//cout<<a<<\" \"<<b<<endl;\n\t\tsum[a]++; sum[b]--; unite(a,b);S.insert(a);S.insert(b);X=a;\n\t}\n\tint val = 0,val2 = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(sum[i]>0){\n\t\t\tputs(\"NO\");return 0;\n\t\t}\n\t\telse cnt[i] = -1*sum[i];\n\t\tval+=cnt[i];\n\t\tif(sum[200+i]<0){\n\t\t\tputs(\"NO\");return 0;\n\t\t}\n\t\telse cnt[200+i] = sum[200+i];\n\t\tval2 += cnt[200+i];\n\t}\n\tassert(val==val2);\n\tif(!val){puts(\"NO\");return 0;}\n\twhile(1){\n\t\tbool upd = 0;\n\t\t{\n\t\t\trepn(i,m)repn(j,m){\n\t\t\t\tif(cnt[i]>=1&&cnt[j+200]>=1&&!same(i,j+200)){\n\t\t\t\t\tunite(i,j+200);cnt[i]--;cnt[j+200]--;upd=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!upd) break;\n\t}\n\tfor(set<int>::iterator it=S.begin();it!=S.end();++it){\n\t\tif(!same(*it,X)){\n\t\t\tputs(\"NO\");return 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\n\n\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint th = 0;\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\texi[i] = true;\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, c[i]) {\n\t\t\texi[i] = true;\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st != e[401]||st>=e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\n\tbool exiroad[402][402] = {};\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tfill(chked, chked + 402, false);\n\t\tq.push(i); chked[i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front(); q.pop();\n\t\t\trep(j, G[x].size()) {\n\t\t\t\tint to = G[x][j];\n\t\t\t\tif (chked[to])continue;\n\t\t\t\tchked[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\trep(j, 402) {\n\t\t\tif (chked[j]) {\n\t\t\t\texiroad[i][j] = true;\n\t\t\t\texi[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tRep(j, i + 1, 402) {\n\t\t\tif (!exi[j])continue;\n\t\t\tif (!exiroad[i][j] || !exiroad[j][i]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint n, h;\nint fa[maxn], in[maxn], out[maxn], can[maxn];\ninline int find(int x) {\n\treturn fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> h;\n\trep(i, 1, h + h) fa[i] = i;\n\trep(i, 1, n) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint x0 = a ? a : b + h;\n\t\tint x1 = c ? c + h : d;\n\t\tfa[find(x0)] = find(x1);\n\t\t++ out[x0], ++ in[x1];\n\t}\n\trep(i, 1, h) {\n\t\tif(out[i] < in[i] || out[i + h] > in[i + h]) {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t\treturn 0;\n\t\t}\n\t\tif(out[i] != in[i]) can[find(i)] = 1;\n\t\tif(out[i + h] != in[i + h]) can[find(i + h)] = 1;\n\t}\n\trep(i, 1, h + h) {\n\t\tif(in[i] && out[i] && !can[find(i)]) {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nvoid fail(int i) {\n    printf(\"NO %d\\n\", i);\n    exit(0);\n}\n\nint n, h;\nstruct block {\n    int l, r;\n    void scan() {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        if (c == 0) l = a << 1;\n        else l = c << 1 | 1;\n        if (d == 0) r = b << 1 | 1;\n        else r = d << 1;\n    }\n} bs[100000];\n\nint par[402];\nint find(int x) {\n    if (par[x] != x) return par[x] = find(par[x]);\n    return x;\n}\n\nint cnt[402];\nint ex[402];\nint zr[402];\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tfor (int i = 0; i < 402; ++i) par[i] = i;\n    cin >> n >> h;\n    for (int i = 0; i < n; ++i) {\n        bs[i].scan();\n        ++cnt[bs[i].l];\n        --cnt[bs[i].r];\n        ex[bs[i].l] = 1;\n        ex[bs[i].r] = 1;\n        par[find(bs[i].l)] = find(bs[i].r);\n    }\n    for (int i = 0; i < 402; ++i) {\n        if (cnt[i] < 0 && ((i ^ 1) & 1)) fail(0);\n        if (cnt[i] > 0 && ((i ^ 0) & 1)) fail(1);\n        if (cnt[i] != 0) zr[find(i)] = 1;\n    }\n    for (int i = 0; i < 402; ++i) {\n        if (ex[i] == 0) continue;\n        if (find(i) != i) continue;\n        if (zr[i] == 0) fail(2);\n    }\n    printf(\"YES\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct w {\n\tint a, b, c, d;\n} t[100005];\n\nint n, h;\nset< int > x[4][300];\n\nvoid clear() {\n\tx[0][t[h].a].erase(h);\n\tx[1][t[h].b].erase(h);\n\tx[2][t[h].c].erase(h);\n\tx[3][t[h].d].erase(h);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n , &h);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%d%d\", &t[i].a, &t[i].b, &t[i].c, &t[i].d);\n\t\twhile (1) {\n\t\t\tif (t[i].c == 0 && !x[3][t[i].a].empty()) {\n\t\t\t\th = *x[3][t[i].a].begin();\n\t\t\t\tclear();\n\t\t\t\tt[i].a = t[h].a;\n\t\t\t\tt[i].c = t[h].c;\n\t\t\t} else if (t[i].c != 0 && !x[1][t[i].c].empty()) {\n\t\t\t\th = *x[1][t[i].c].begin();\n\t\t\t\tclear();\n\t\t\t\tt[i].a = t[h].a;\n\t\t\t\tt[i].c = t[h].c;\n\t\t\t} else if (t[i].d == 0 && !x[2][t[i].b].empty()) {\n\t\t\t\th = *x[2][t[i].b].begin();\n\t\t\t\tclear();\n\t\t\t\tt[i].b = t[h].b;\n\t\t\t\tt[i].d = t[h].d;\n\t\t\t} else if (t[i].d != 0 && !x[0][t[i].d].empty()) {\n\t\t\t\th = *x[0][t[i].d].begin();\n\t\t\t\tclear();\n\t\t\t\tt[i].b = t[h].b;\n\t\t\t\tt[i].d = t[h].d;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (t[i].c == 0)\n\t\t\tx[0][t[i].a].insert(i);\n\t\telse\n\t\t\tx[2][t[i].c].insert(i);\n\t\tif (t[i].d == 0)\n\t\t\tx[1][t[i].b].insert(i);\n\t\telse\n\t\t\tx[3][t[i].d].insert(i);\n\t}\n\tfor (int i = 0; i < 300; i++) {\n\t\tif (!x[2][i].empty() || !x[3][i].empty()) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n, h;\n\nint f(int d, int u){\n\treturn d?(h+d):u;\n}\n\nint g(int d, int u){\n\treturn d?d:(h+u);\n}\n\nint out[810];\nint in[810];\n\nvoid In(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1; i<=n; ++i){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x = f(c, c+a);\n\t\tint y = g(d, d+b);\n\t\tout[x]++; in[y]++;\n\t}\n}\n\nbool check(){\n\tint bal = 0;\n\tbool e = 0;\n\tfor(int i=1; i<=2*h-1; ++i){\n\t\tif(abs(out[i]-in[i]) > 1) return 0;\n\t\tif(out[i] > in[i]){\n\t\t\tif(i > h) return 0;\n\t\t\te = 1;\n\t\t\t++bal;\n\t\t}\n\t\tif(out[i] < in[i]){\n\t\t\tif(i <= h) return 0;\n\t\t\t--bal;\n\t\t}\n\t}\n\treturn !bal && e;\n}\n\nint main()\n{\n\tIn();\n\tputs(check()?\"YES\":\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<functional>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way,vel &con) {\n\tint n = way.size();\n\tvel dist(n,-1);\n\tdist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front();\n\t\tq.pop();\n\t\tcon.push_back(st);\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nint gr(int now, vvel &chi) {\n\tint ret = 0;\n\tfor(auto to:chi[now]) {\n\t\tret = ret xor (gr(to, chi) + 1);\n\t}\n\treturn ret;\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\th++;\n\tvvel way(2 * h);\n\tvvel inv_way(2 * h);\n\tvvel all_way(2 * h);\n\trep(i, n) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint st, to;\n\t\tif (c == 0) { st = a; }\n\t\telse { st = c + h; }\n\t\tif (d == 0) { to = b + h; }\n\t\telse { to = d; }\n\t\tway[st].push_back(to);\n\t\tinv_way[to].push_back(st);\n\t\tall_way[st].push_back(to);\n\t\tall_way[to].push_back(st);\n\t}\n\trep(i, h) {\n\t\tif (way[i].size() < inv_way[i].size()) { cout << \"NO\" << endl; return 0; }\n\t\tif (way[i + h].size() > inv_way[i + h].size()) { cout << \"NO\" << endl; return 0; }\n\t}\n\trep(i, 2 * h) {\n\t\tvel con = {};\n\t\tdis(i, all_way, con);\n\t\tif (con.size() == 1) {\n\t\t\tif (all_way[i].size() > 0) { cout << \"NO\" << endl; return 0; }\n\t\t}\n\t\telse {\n\t\t\tbool fl = false;\n\t\t\tfor (auto pl : con) {\n\t\t\t\tif ((pl<h) and (way[pl].size() > inv_way[pl].size())) { fl = true; }\n\t\t\t}\n\t\t\tif (!fl) { cout << \"NO\" << endl; }\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\n\nusing namespace std;\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n        cerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\n\nconst int MAXN = 210000;\n\nint n, h;\nvector<int> eds[MAXN];\nvector<int> beds[MAXN];\nint was[MAXN];\n\nvoid dfs1(int v) {\n    was[v] = 1;\n    for (int u: eds[v]) {\n        if (!was[u])\n            dfs1(u);\n    }\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &h);\n    ++h;\n    for (int i = 0; i < n; ++i) {\n        int a, b, c, d;\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        if (c == 0) {\n            eds[a].push_back(i + 2 * h);\n        }\n        else {\n            eds[c + h].push_back(i + 2 * h);\n        }\n        if (d == 0) {\n            eds[i + 2 * h].push_back(b + h);\n        }\n        else {\n            eds[i + 2 * h].push_back(d);\n        }\n    }\n    int g = 2 * h + n;\n    for (int i = 0; i < g; ++i)\n        for (int u: eds[i])\n            beds[u].push_back(i);\n    for (int i = 0; i < h; ++i) {\n        if (eds[i].size() < beds[i].size()) {\n            cout << \"NO\\n\";\n            return 0;\n        }\n        while (eds[i].size() > beds[i].size()) {\n            eds[g].push_back(i);\n            beds[i].push_back(g);\n        }\n    }\n    for (int i = h; i < 2 * h; ++i) {\n        if (eds[i].size() > beds[i].size()) {\n            cout << \"NO\\n\";\n            return 0;\n        }\n        while (eds[i].size() < beds[i].size()) {\n            beds[g].push_back(i);\n            eds[i].push_back(g);\n        }\n    }\n    dfs1(g);\n    for (int i = 2 * h; i < 2 * h + n; ++i) {\n        if (!was[i]) {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define show(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\nint main()\n{\n    int N, H;\n    cin >> N >> H;\n\n    vector<int> dim(2 * H + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int l = 0;\n        if (c == 0) {\n            l = a;\n        } else {\n            l = -c;\n        }\n\n        int r = 0;\n        if (d == 0) {\n            r = b;\n        } else {\n            r = -d;\n        }\n\n        //        cout << l << \"->\" << -r << endl;\n        dim[l + H]++;\n        dim[-r + H]--;\n    }\n\n    int num1 = 0;\n    int num2 = 0;\n    for (int i = 2 * H; i >= 0; i--) {\n        //        cout << i - H << \": \" << dim[i] << endl;\n        if (i - H > 0) {\n            if (dim[i] > 0) {\n                num1++;\n            } else if (dim[i] < 0) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (i - H < 0) {\n            if (dim[i] < 0) {\n                num2++;\n            } else if (dim[i] > 0) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    if (num1 == num2 and num1 > 0) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXH=200;\ntypedef struct Z { int A,B,C,D,L,R; } Z;\n\nint n,h;\nZ z[MAXN];\nbool used[MAXN];\n\n\nvector<int> havel[2*MAXH];\nvector<int> haver[2*MAXH];\nint cnt[2*MAXH];\n\nbool solve() {\n\tREP(i,n) { if(z[i].C==0) z[i].L=z[i].A-1; else z[i].L=h+z[i].C-1; if(z[i].D==0) z[i].R=h+z[i].B-1; else z[i].R=z[i].D-1; }\n\t//REP(i,n) { if(i!=0) printf(\" | \"); printf(\"%02d-%02d\",z[i].L,z[i].R); } puts(\"\");\n\tREP(i,2*h) havel[i].clear(),haver[i].clear(); REP(i,n) havel[z[i].L].PB(i),haver[z[i].R].PB(i),used[i]=false;\n\n\tREP(i,n) if(!used[i]) {\n\t\tused[i]=true;\n\t\tint l=z[i].L,r=z[i].R; REP(j,2*h) cnt[j]=0;\n\t\t//printf(\"%02d-%02d\\n\",l,r);\n\t\twhile(true) {\n\t\t\tbool change=false;\n\t\t\twhile(true) {\n\t\t\t\twhile(SZ(havel[r])!=0&&used[havel[r].back()]) havel[r].pop_back();\n\t\t\t\tif(SZ(havel[r])!=0) { int id=havel[r].back(); used[id]=true; ++cnt[r]; r=z[id].R; change=true; /*printf(\"append right %02d-%02d\\n\",z[id].L,z[id].R);*/ } else break;\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\twhile(SZ(haver[l])!=0&&used[haver[l].back()]) haver[l].pop_back();\n\t\t\t\tif(SZ(haver[l])!=0) { int id=haver[l].back(); used[id]=true; ++cnt[l]; l=z[id].L; change=true; /*printf(\"append left  %02d-%02d\\n\",z[id].L,z[id].R);*/ } else break;\n\t\t\t}\n\t\t\tif(l==r) REP(j,2*h) if(cnt[j]>0) {\n\t\t\t\twhile(SZ(havel[j])!=0&&used[havel[j].back()]) havel[j].pop_back();\n\t\t\t\twhile(SZ(haver[j])!=0&&used[haver[j].back()]) haver[j].pop_back();\n\t\t\t\tif(SZ(havel[j])!=0) { int id=havel[j].back(); used[id]=true; ++cnt[l]; l=j,r=z[id].R; change=true; /*printf(\"split on %02d and append right %02d-%02d\\n\",j,z[id].L,z[id].R);*/ break; }\n\t\t\t\tif(SZ(haver[j])!=0) { int id=haver[j].back(); used[id]=true; ++cnt[l]; l=z[id].L,r=j; change=true; /*printf(\"split on %02d and append left  %02d-%02d\\n\",j,z[id].L,z[id].R);*/ break; }\n\t\t\t}\n\t\t\tif(!change) break;\n\t\t}\n\t\t//printf(\"-> %02d-%02d\\n\",l,r);\n\t\tif(l>=h||r<h) return false;\n\t}\n\treturn true;\n}\n\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&h);\n\tREP(i,n) scanf(\"%d%d%d%d\",&z[i].A,&z[i].B,&z[i].C,&z[i].D);\n\t//REP(i,n) { if(i!=0) printf(\" | \"); if(z[i].C==0) printf(\"0%d\",z[i].A); else printf(\"%d*\",z[i].C); printf(\"-\"); if(z[i].D==0) printf(\"0%d\",z[i].B); else printf(\"%d*\",z[i].D); } puts(\"\");\n\tprintf(\"%s\\n\",solve()?\"YES\":\"NO\");\t\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=1000005;\nint n,h,i,j,k,l,ans,A,B,C,D,g[405][405],u[N],p[N],ind[N],outd[N];\nbool vis[N],ok[N];\nint find(int x)\n{\n\treturn p[x]==-1?x:p[x]=find(p[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tif(C)\n\t\t\tA=C+h;\n\t\tif(D)\n\t\t\tB=D+h;\n\t\tg[A][B<h?B+h:B-h]++;\n\t\tvis[A]=vis[B<h?B+h:B-h]=true;\n\t}\n\tfor(i=1;i<=2*h;++i)\n\t\tfor(j=1;j<=2*h;++j)\n\t\t\tind[j]+=g[i][j],outd[i]+=g[i][j];\n\tfor(i=1;i<=h;++i)\n\t\tif(outd[i]<ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=h+1;i<=2*h;++i)\n\t\tif(outd[i]>ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=1;i<=2*h;++i)\n\t\tp[i]=-1;\n\tfor(i=1;i<=2*h;++i)\n\t\tfor(j=1;j<=2*h;++j)\n\t\t\tif(g[i][j]&&find(i)!=find(j))\n\t\t\t\tp[find(i)]=find(j);\n\tfor(i=1;i<=2*h;++i)\n\t\tif(outd[i]!=ind[i])\n\t\t\tok[find(i)]=true;\n\tfor(i=1;i<=2*h;++i)\n\t\tif(find(i)==i&&!ok[i]&&vis[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct MaxFlowDinic {\n    typedef int flow_t;\n    struct Edge {\n        int next;\n        size_t inv; /* inverse edge index */\n        flow_t res; /* residual */\n    };\n    int n;\n    vector<vector<Edge>> graph;\n    vector<int> q, l, start;\n    void init(int _n) {\n        n = _n;\n        graph.resize(n);\n        for (int i = 0; i < n; i++) graph[i].clear();\n    }\n    void add_edge(int s, int e, flow_t cap, flow_t caprev = 0) {\n        Edge forward{ e, graph[e].size(), cap };\n        Edge reverse{ s, graph[s].size(), caprev };\n        graph[s].push_back(forward);\n        graph[e].push_back(reverse);\n    }\n    bool assign_level(int source, int sink) {\n        int t = 0;\n        memset(&l[0], 0, sizeof(l[0]) * l.size());\n        l[source] = 1;\n        q[t++] = source;\n        for (int h = 0; h < t && !l[sink]; h++) {\n            int cur = q[h];\n            for (const auto& e : graph[cur]) {\n                if (l[e.next] || e.res == 0) continue;\n                l[e.next] = l[cur] + 1;\n                q[t++] = e.next;\n            }\n        }\n        return l[sink] != 0;\n    }\n    flow_t block_flow(int cur, int sink, flow_t current) {\n        if (cur == sink) return current;\n        for (int& i = start[cur]; i < graph[cur].size(); i++) {\n            auto& e = graph[cur][i];\n            if (e.res == 0 || l[e.next] != l[cur] + 1) continue;\n            if (flow_t res = block_flow(e.next, sink, min(e.res, current))) {\n                e.res -= res;\n                graph[e.next][e.inv].res += res;\n                return res;\n            }\n        }\n        return 0;\n    }\n    flow_t solve(int source, int sink) {\n        q.resize(n);\n        l.resize(n);\n        start.resize(n);\n        flow_t ans = 0;\n        while (assign_level(source, sink)) {\n            memset(&start[0], 0, sizeof(start[0]) * n);\n            while (flow_t flow = block_flow(source, sink, numeric_limits <flow_t\n                        >::max()))\n                ans += flow;\n        }\n        return ans;\n    }\n};\n\nstruct MaxFlowEdgeDemands\n{\n    MaxFlowDinic mf;\n    using flow_t = MaxFlowDinic::flow_t;\n    vector<flow_t> ind, outd;\n    flow_t D; int n;\n    void init(int _n) {\n        n = _n; D = 0; mf.init(n + 2);\n        ind.clear(); outd.clear();\n        ind.resize(n, 0); outd.resize(n, 0);\n    }\n    void add_edge(int s, int e, flow_t cap, flow_t demands = 0) {\n        mf.add_edge(s, e, cap - demands);\n        D += demands; ind[e] += demands; outd[s] += demands;\n    }\n    // returns { false, 0 } if infeasible\n    // { true, maxflow } if feasible\n    pair<bool, flow_t> solve(int source, int sink) {\n        mf.add_edge(sink, source, numeric_limits <flow_t >::max());\n        for (int i = 0; i < n; i++) {\n            if (ind[i]) mf.add_edge(n, i, ind[i]);\n            if (outd[i]) mf.add_edge(i, n + 1, outd[i]);\n        }\n        if (mf.solve(n, n + 1) != D) return{ false, 0 };\n        for (int i = 0; i < n; i++) {\n            if (ind[i]) mf.graph[i].pop_back();\n            if (outd[i]) mf.graph[i].pop_back();\n        }\n        return{ true, mf.solve(source, sink) };\n    }\n};\n\nint lbottom(int t)\n{\n    return t;\n}\n\nint lup(int t)\n{\n    return 200 + t;\n}\n\nint rbottom(int t)\n{\n    return 400 + t;\n}\n\nint rup(int t)\n{\n    return 600 + t;\n}\n\nint next_blk(int t)\n{\n    if (t > 400 && t <= 600) return lup(t - 400);\n    else return lbottom(t - 600);\n}\n\nbool loop[444];\nbool edge[444];\nint x[444][444];\n\nint main()\n{\n    int n, h;\n    scanf(\"%d%d\",&n,&h);\n    MaxFlowEdgeDemands mf;\n    mf.init(402);\n    for (int i = 0; i < n; i++)\n    {\n        int a, b, c, d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\n        int lidx, ridx;\n\n        if (c == 0) lidx = lbottom(a);\n        else lidx = lup(c);\n\n        if (d == 0) ridx = rbottom(b);\n        else ridx = rup(d);\n\n        ridx = next_blk(ridx);\n\n        x[lidx][ridx]++;\n    }\n\n    queue<int> que;\n\n    for (int i = 1; i <= 400; i++)\n    {\n        int indeg = 0, outdeg = 0;\n        for (int j = 1; j <= 400; j++)\n        {\n            indeg += x[i][j];\n            outdeg += x[j][i];\n        }\n\n        if (indeg != outdeg)\n        {\n            edge[i] = true;\n            que.push(i);\n        }\n    }\n\n    while (que.empty() == false)\n    {\n        int t = que.front(); que.pop();\n        for (int j = 1; j <= 400; j++)\n        {\n            if ((x[t][j] || x[j][t]) && edge[j] == false)\n            {\n                edge[j] = true;\n                que.push(j);\n            }\n        }\n    }\n\n    for (int i = 1; i <= 400; i++)\n    {\n        if (edge[i]) continue;\n        for (int j = 1; j <= 400; j++)\n        {\n            if (x[i][j] || x[j][i])\n            {\n                printf(\"NO\\n\");\n                return 0;\n            }\n        }\n    }\n\n    for (int i = 1; i <= 400; i++)\n    {\n        for (int j = i + 1; j <= 400; j++)\n        {\n            if (x[i][j] > x[j][i]) mf.add_edge(i, j, x[i][j] - x[j][i], x[i][j] - x[j][i]);\n            else if (x[i][j] < x[j][i]) mf.add_edge(j, i, -x[i][j] + x[j][i], -x[i][j] + x[j][i]);\n        }\n    }\n    for (int i = 1; i <= 200; i++) mf.add_edge(0, i, 1e9);\n    for (int i = 201; i <= 400; i++) mf.add_edge(i, 401, 1e9);\n    if (mf.solve(0, 401).first) printf(\"YES\\n\");\n    else printf(\"NO\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define X first\n#define Y second\n#define fin(name) freopen(name, \"r\", stdin)\n#define fout(name) freopen(name, \"w\", stdout)\n#define files(name) fin(name\".in\"); fout(name\".out\")\n#define endl \"\\n\"\n#define fi(st,n) for (int i = (st); i <= (int)(n); ++i)\n#define fj(st,n) for (int j = (st); j <= (int)(n); ++j)\n#define fk(st,n) for (int k = (st); k <= (int)(n); ++k)\n#define fq(st,n) for (int q = (st); q <= (int)(n); ++q)\n#define fw(st,n) for (int w = (st); w <= (int)(n); ++w)\n#define ff(i, st, n) for (int (i) = (st); (i) <= (int)(n); ++(i))\n#define ei(st,n) for (int i = (st); i >= (int)(n); --i)\n#define ej(st,n) for (int j = (st); j >= (int)(n); --j)\n#define ek(st,n) for (int k = (st); k >= (int)(n); --k)\n#define ef(i, st, n) for (int (i) = (st); (i) >= (int)(n); --(i))\n#define ri(st,n) for (int i = (st); i < (int)(n); ++i)\n#define rj(st,n) for (int j = (st); j < (int)(n); ++j)\n#define rk(st,n) for (int k = (st); k < (int)(n); ++k)\n#define rq(st,n) for (int q = (st); q < (int)(n); ++q)\n#define rf(i, st, n) for (int (i) = (st); (i) < (int)(n); ++(i))\n#define clean(a) memset((a),0,sizeof (a))\n#define sync ios_base::sync_with_stdio(0);cin.tie(0)\n#define y1 dsklmlvmd\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double dbl;\ntypedef long double ldbl;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst dbl eps = (dbl) 1e-8;\nconst int mod = (int) 1e9 + 7;\nconst int maxn = (int) 1e5 + 5;\n//const dbl M_PI = (dbl)2 * (dbl)acos(0);\n\n//cout<<fixed<<setprecision(10);\n//srand(time(0));\n\nint a[maxn], b[maxn], c[maxn], d[maxn];\nint n, h, kl[222], kr[222];\n\nint main()\n{\n//    fin(\"t.in\");\n    sync;\n    cin >> n >> h;\n    fi(1, n)\n    {\n    \tcin >> a[i] >> b[i] >> c[i] >> d[i];\n    \tif (c[i] == 0)\n    \t\t++kl[a[i]];\n    \telse\n    \t\t--kl[c[i]];\n    \tif (d[i] == 0)\n    \t\t++kr[b[i]];\n    \telse\n    \t\t--kr[d[i]];\n    }\n    int isl = 0, isr = 0;\n    fi(1, h)\n    {\n    \tif (kl[i] < 0 || kr[i] < 0)\n    \t{\n    \t\tcout << \"NO\" << endl;\n    \t\treturn 0;\n    \t}\n    \tif (kl[i] > 0)\n    \t\tisl = 1;\n    \tif (kr[i] > 0)\n    \t\tisr = 1;\n    }\n//    cout << isl << \" \" << isr << endl; \n    if (isl || isr)\n    {\n    \tcout << \"YES\" << endl;\n    }\n    else\n    {\n    \tcout << \"NO\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)ull\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"NO\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) vector<vector<T>>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,const vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n// Union find\nstruct uf {\n  vi d;\n  uf(){}\n  uf(int mx):d(mx,-1){}\n  int root(int x) {\n    if(d[x] < 0) return x;\n    return d[x] = root(d[x]);\n  }\n  bool unite(int x, int y) {\n    x = root(x); y = root(y);\n    if(x == y) return false;\n    if(d[x] > d[y]) swap(x,y);\n    d[x] += d[y]; d[y] = x;\n    return true;\n  }\n  int size(int x) { return -d[root(x)];}\n};\n//\n\n\n\nint main() {\n  int n, h;\n  scanf(\"%d\",&n);\n  scanf(\"%d\",&h);\n  h += 3;\n\n  int m = h*2;\n  uf t(m);\n  vi deg(m), used(m);\n  rep(i,n) {\n    int a,b,c,d;\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    int u = 0, v = 0;\n    if (c == 0) u = a;\n    else u = h+c;\n    if (d == 0) v = h+b;\n    else v = d;\n    deg[u]++; deg[v]--;\n    used[u] = used[v] = 1;\n    t.unite(u,v);\n  }\n  rep(i,h) if (deg[i] < 0) dame;\n  rep(i,h) if (deg[h+i] > 0) dame;\n\n  vi ok(m);\n  rep(i,m) if (used[i]) {\n    if (deg[i]) ok[t.root(i)] = INF; else ok[t.root(i)]--;\n  }\n  rep(i,m) if (ok[i] < 0) dame;\n  puts(\"YES\");\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\ntypedef struct{\n  int to;\n  int cap;\n  int rev;\n}edge;\n\n// node v : distance from s => level[v]\nvoid bfs(vector<vector<edge> > &G, vector<int> &level, int s){\n  fill(level.begin(), level.end(), -1);\n  queue<int> q;\n  q.push(s);\n  level[s] = 0;\n  while(!q.empty()){\n    int e=q.front(); q.pop();\n    for(int i=0; i<G[e].size(); i++){\n      if(G[e][i].cap > 0 && level[G[e][i].to] < 0){\n        level[G[e][i].to] = level[e] + 1;\n        q.push(G[e][i].to);\n      }\n    }\n  }\n}\n\nint dfs(vector<vector<edge> > &G, vector<int> &level, vector<bool> &used, vector<int> &iter, int s, int f,  int t){\n  if(s==t) return f;\n  else{\n    //iter[e] : done searching from v[0] to v[ iter[e]-1 ]\n    for(int &i=iter[s]; i<G[s].size(); i++){\n      //distance from s to v[e][i].to must be longer than dist from s to v\n      if(G[s][i].cap > 0 && level[s] < level[ G[s][i].to ]){\n        int d = dfs(G, level, used, iter, G[s][i].to, min(f, G[s][i].cap), t);\n        if(d>0){\n          G[s][i].cap -= d;\n          G[ G[s][i].to ][ G[s][i].rev ].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n}\n\nint dinic_maxflow(vector<vector<edge> > &G, int s, int t){\n  const int INF = 100000000;\n  int flow=0;\n  while(true){\n    vector<int> level(G.size(), -1);\n    vector<int> iter(G.size(), 0);\n    vector<bool> used(G.size(), false);\n    bfs(G, level, s);\n    if(level[t] < 0) return flow; //unable to achieve to t\n    while(true){\n      int f = dfs(G, level, used, iter, s, INF, t);\n      if(f==0) break;\n      else flow += f;\n    }\n  }\n}\n\nvoid add_edge(vector<vector<edge> > &G, int from, int to, int cap){\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint main(){\n  int n,h;\n  cin >> n,h;\n  vector<int> a(n),b(n),c(n),d(n);\n  for(int i=0; i<n; i++){\n    cin >> a[i],b[i],c[i],d[i];\n  }\n\n  map<pair<int,int>, int> in_cnt;\n  map<pair<int,int>, int> out_cnt;\n  for(int i=0; i<n; i++){\n    if( c[i] == 0 ){\n      in_cnt[ {a[i], 0} ]++;\n    }else{\n      in_cnt[ {c[i], 1} ]++;\n    }\n    if( d[i] == 0 ){\n      out_cnt[ {b[i], 0} ]++;\n    }else{\n      out_cnt[ {d[i], 1} ]++;\n    }\n  }\n\n  map<tuple<int,int,int>, int> dict;\n  int idx = 0;\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n\n  int zero_0 = idx++;\n  int zero_1 = idx++;\n  int source = idx++;\n  int sink = idx++;\n\n  int super_source = idx++;\n  int super_sink = idx++;\n\n  vector<vector<edge>> G(idx);\n\n  add_edge(G, zero_0, zero_1, n+10);\n  add_edge(G, super_source, zero_1, 1);\n  add_edge(G, zero_0, super_sink, 1);\n\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, v, sink, p.second);\n    if( p.first.second == 0 ){\n      add_edge(G, zero_1, v, p.second);\n    }\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, source, v, p.second);\n    auto r = make_tuple(0, p.first.first, p.first.second^1);\n    if( dict.count(r) ){\n      add_edge(G, v, dict[r], p.second);\n    }\n\n    if( p.first.second == 0 ){\n      add_edge(G, v, zero_0, p.second);\n    }\n  }\n\n  int f = 0;\n  f += dinic_maxflow(G, super_source, sink);\n  f += dinic_maxflow(G, source, super_sink);\n  if( f != 2 ){\n    println(\"NO\");\n    return 0;\n  }\n  f--;\n\n  add_edge(G, super_source, source, n+100);\n  add_edge(G, sink, super_sink, n+100);\n\n  f += dinic_maxflow(G, super_source, super_sink);\n\n  println( f==n ? \"YES\" : \"NO\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int H = 202 << 1;\nint fa[H] , out[H] , in[H] , n , h;\nvi g[H];\nint F(int x){return fa[x]==x?x:fa[x]=F(fa[x]);}\nint id(int x){\n    return x>0?x-1:h+(-x-1);\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&h);\n    rep(i,0,h+h) fa[i]=i;\n    rep(i,0,n) {\n        int a,b,c,d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        int l=c?-c:a,r=d?d:-b;\n        l=id(l),r=id(r);\n        fa[F(r)]=F(l);\n        out[l]++;\n        in[r]++;\n    }\n    rep(i,0,h+h) g[F(i)].pb(i);\n    rep(i,0,h) if(out[i]<in[i]) return puts(\"NO\") , 0;\n    rep(i,h,h+h) if(out[i]>in[i]) return puts(\"NO\") , 0;\n    rep(i,0,h+h) if(sz(g[i])) {\n        bool end = false , has = false;\n        for(auto e : g[i]) {\n            has |= in[e] | out[e];\n            if(e < h && out[e] > in[e]) end = true;\n            if(e >= h && out[e] < in[e]) end = true;\n        }\n        if(has && !end) return puts(\"NO\") , 0;\n    }\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=405;\n\nint n,h;\nint in[MAXN],out[MAXN],cnt[MAXN],fa[MAXN];\n\nint Find(int x){return fa[x]==0?x:fa[x]=Find(fa[x]);}\n\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;i++){\n        int a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint x=c==0?a:(c+200);\n\t\tint y=d==0?(b+200):d;\n\t\tin[y]++,out[x]++;\n\t\tx=Find(x),y=Find(y);\n\t\tif(x!=y) fa[x]=y;\n\t}\n\tbool f=1;\n\tfor(int i=1;i<=400;i++)\n\t\tif(in[i]!=out[i]){\n\t\t\tif((in[i]<out[i]&&i>200)||(in[i]>out[i]&&i<200)){\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint x=Find(i);\n\t\t\tcnt[x]++;\n\t\t}\n\tif(f){\n\t\tfor(int i=1;i<=400;i++)\n\t\t\tif((in[i]||out[i])&&cnt[Find(i)]==0){\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif(f) puts(\"YES\");\n\telse puts(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=405,maxm=100500;\ninline int read(int x=0,char c=getchar()){for(;c>'9'||c<'0';c=getchar());for(;c>='0'&&c<='9';c=getchar()) x=x*10+c-48;return x;}\nint fa[maxn];\nbool v[maxn];\nint in[maxn],out[maxn],A[maxm],B[maxm],C[maxm],D[maxm];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tint n,h;cin>>n>>h;bool flag=1;\n\tfor(int i=1;i<=n;++i) A[i]=read(),B[i]=read(),C[i]=read(),D[i]=read();//h<<=1;\n\tfor(int i=1;i<=n;++i) {\n\t\tint a,b;\n\t\tif(!C[i]) a=h+A[i];else a=h-C[i];\n\t\tif(!D[i]) b=h-B[i];else b=h+D[i];\n\t\t++out[a],++in[b];\n\t}\n\tfor(int i=0;i<h;++i) if(in[i]<out[i]) flag=0;//cout<<flag<<endl;\n\tfor(int i=h+1;i<=h<<1;++i) if(in[i]>out[i]) flag=0;\n\tfor(int i=0;i<=h<<1;++i) fa[i]=i,v[i]=(in[i]!=out[i]);\n\tfor(int i=1;i<=n;++i){\n\t\tint a,b;\n\t\tif(!C[i]) a=h+A[i];else a=h-C[i];\n\t\tif(!D[i]) b=h-B[i];else b=h+D[i];\n\t\tif(find(a)==find(b)){\n\t\t\tif(!v[find(a)]) flag=0;\n\t\t}else v[find(b)]|=v[find(a)],fa[find(a)]=find(b);\n\t}\n\tputs(flag?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<lint, lint> pi;\nconst int MAXN = 405;\n\nint adj[MAXN][MAXN];\nint deg[MAXN], vis[MAXN];\nvector<int> dfn;\n\nint get(pi v){\n\tif(v.first == 1) return 202 + v.second;\n\telse return v.second;\n}\n\nvoid my_ass(bool p){\n\tif(p ==0){\n\t\tputs(\"NO\");\n\t\texit(0);\n\t}\n}\n\nvoid dfs(int x){\n\tif(vis[x]) return;\n\tvis[x] = 1;\n\tdfn.push_back(x);\n\tfor(int i=0; i<MAXN; i++){\n\t\tif(adj[x][i] || adj[i][x]) dfs(i);\n\t}\n}\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\twhile(n--){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tpi st, ed;\n\t\tif(c == 0) st = pi(0, a);\n\t\telse st = pi(1, c);\n\t\tif(d == 0) ed = pi(1, b);\n\t\telse ed = pi(0, d);\n\t//\tprintf(\"%d %d\\n\", get(st), get(ed));\n\t\tadj[get(st)][get(ed)]++;\n\t\tdeg[get(st)]++;\n\t\tdeg[get(ed)]--;\n\t}\n\tfor(int i=0; i<202; i++){\n\t\tmy_ass(deg[i] >= 0);\n\t\tmy_ass(deg[i + 202] <= 0);\n\t\tadj[404][i] += deg[i];\n\t\tadj[i][404] -= deg[i + 202];\n\t}\n\tdfs(404);\n\tfor(int i=0; i<MAXN; i++){\n\t\tfor(int j=0; j<MAXN; j++){\n\t\t\tif(adj[i][j] && !vis[i]){\n\t\t\t\tdfn.clear();\n\t\t\t\tdfs(i);\n\t\t\t\tint chk = 0;\n\t\t\t\tfor(auto &j : dfn){\n\t\t\t\t\tif(j < 202) chk |= 1;\n\t\t\t\t\telse chk |= 2;\n\t\t\t\t}\n\t\t\t\tif(chk != 3){\n\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 410\nint n,h;\nint in[MAXN],out[MAXN],cnt[MAXN],fa[MAXN];\nint Find(int x)\n{\n\treturn fa[x]==0?x:fa[x]=Find(fa[x]);\n}\nint main()\n{\n\tint a,b,c,d,x,y;\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=c==0?a:(c+200);\n\t\ty=d==0?(b+200):d;\n\t\tin[y]++,out[x]++;\n\t\tx=Find(x),y=Find(y);\n\t\tif(x!=y)\n\t\t\tfa[x]=y;\n\t}\n\tbool f=1;\n\tfor(int i=1;i<=400;i++)\n\t\tif(in[i]!=out[i])\n\t\t{\n\t\t\tif((in[i]<out[i]&&i>200)||(in[i]>out[i]&&i<200))\n\t\t\t{\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint x=Find(i);\n\t\t\tcnt[x]++;\n\t\t}\n\tif(f)\n\t{\n\t\tfor(int i=1;i<=400;i++)\n\t\t\tif((in[i]||out[i])&&cnt[Find(i)]==0)\n\t\t\t{\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif(f) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300050\nusing namespace std;\nint n,h;\nstruct node{\n\tint a,b,c,d;\n}q[N];\nint ld[233],lu[233],rd[233],ru[233],ds;\nint he[N],ne[N<<2],to[N<<2],tag[N],tot=1;\nint ind[N],outd[N];\ninline void addedge(int x,int y){\n\tto[++tot]=y;ne[tot]=he[x];he[x]=tot;\n\t++outd[x];++ind[y];\n\tto[++tot]=x;ne[tot]=he[y];he[y]=tot;\n}\nint pd[N],ans;\ninline void dfs(int g){\n\tans+=outd[g]-ind[g];pd[g]=1;\n\tfor(int i=he[g];i;i=ne[i])if(!pd[to[i]])dfs(to[i]);\n}\nint main(){\n\tcin>>n>>h;\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d%d%d%d\",&q[i].a,&q[i].b,&q[i].c,&q[i].d);\n\tfor(int i=1;i<=h;++i)ld[i]=++ds;\n\tfor(int i=1;i<=h;++i)lu[i]=++ds;\n\tfor(int i=1;i<=h;++i)rd[i]=++ds;\n\tfor(int i=1;i<=h;++i)ru[i]=++ds;\n\tfor(int i=1;i<=n;++i){\n\t\tint pol,por;\n\t\tif(q[i].c){\n\t\t\taddedge(ru[q[i].c],ld[q[i].c]);\n\t\t\tpol=ld[q[i].c];\n\t\t}\n\t\telse pol=lu[q[i].a];\n\t\tif(q[i].d){\n\t\t\taddedge(rd[q[i].d],lu[q[i].d]);\n\t\t\tpor=rd[q[i].d];\n\t\t}\n\t\telse por=ru[q[i].b];\n\t\taddedge(pol,por);\n\t}\n\tint al=0;\n\tfor(int i=lu[1];i<=lu[h];++i)al+=outd[i]-ind[i];\n\tif(al<=0)return puts(\"NO\"),0;\n\tfor(int i=ru[1];i<=ru[h];++i)al+=outd[i]-ind[i];\n\tif(al)return puts(\"NO\"),0;\n\tfor(int i=ld[1];i<=ld[h];++i)if(ind[i]!=outd[i])return puts(\"NO\"),0;\n\tfor(int i=rd[1];i<=rd[h];++i)if(ind[i]!=outd[i])return puts(\"NO\"),0;\n\tfor(int i=1;i<=n;++i)\n\t\tif(!pd[i]){dfs(i);if(ans)return puts(\"NO\"),0;}\n\treturn puts(\"YES\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=100010;\nconst int maxm=410;\nint n,m,u[maxn],v[maxn];\nint pa[maxm],in[maxm],out[maxm],yes[maxm],cnt[maxm];\nint findset(int x) {return x==pa[x]?x:pa[x]=findset(pa[x]);}\nint main() {\n\tn=read();m=read();\n\trep(i,1,n) {\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint p,q;\n\t\tif(!c) p=a;\n\t\telse p=-c;\n\t\tif(!d) q=-b;\n\t\telse q=d;\n\t\tp+=m;q+=m;\n\t\tin[q]++;out[p]++;\n\t\tu[i]=p;v[i]=q;\n\t}\n\tint ok=1;\n\trep(i,0,2*m) {\n\t\tif(i<m&&in[i]<out[i]) ok=0;\n\t\tif(i>m&&in[i]>out[i]) ok=0;\n\t}\n\trep(i,0,2*m) if(i!=m) pa[i]=i;\n\trep(i,1,n) {\n\t\tint x=findset(u[i]),y=findset(v[i]);\n\t\tif(x!=y) pa[x]=y,cnt[y]+=cnt[x];\n\t\tcnt[y]++;\n\t}\n\trep(i,0,2*m) if(i!=m&&in[i]!=out[i]) yes[findset(i)]++;\n\trep(i,0,2*m) if(i==findset(i)&&(!yes[i])&&cnt[i]) ok=0;\n\tputs(ok?\"YES\":\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#define eps 1e-10\n#define inf 1e9\n#define For(i,j,k)\tfor(int i=j;i<=k;++i)\n#define Dow(i,j,k)\tfor(int i=k;i>=j;--i)\n#define ll long long\n#define y1 orz\nusing namespace std;\ninline ll read()\n{\n\tll t=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9')\t{if(c=='-')\tf=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')\tt=t*10+c-48,c=getchar();\n\treturn t*f;\n}\nint n,h,F[1001],deg[1001],hav[1001],is_father[1001];\ninline int get(int x){return x==F[x]?F[x]:F[x]=get(F[x]);}\nint x,y,x1,y1,tx,ty;\nint main()\n{\n\tn=read();h=read();\n\tFor(i,1,1000)\tF[i]=i;\n\tFor(i,1,n)\t\n\t{\n\t\tx=read();y=read();x1=read();y1=read();\n\t\tif(x1==0)\ttx=x;else tx=-x1;\n\t\tif(y1==0)\tty=-y;else ty=y1;\n\t\ttx+=500;ty+=500;\n\t\tdeg[tx]++;deg[ty]--;hav[tx]=1;\n//\t\tcout<<tx<<' '<<ty<<endl;\n\t\tF[get(tx)]=get(ty);\n\t}\n\tFor(i,501,1000)\tif(deg[i]<0)\t{puts(\"NO\");return 0;}\t\t\n\tFor(i,1,500)\tif(deg[i]>0)\t{puts(\"NO\");return 0;}\n\tFor(i,1,1000)\t\n\t\thav[get(i)]|=hav[i];\n\tFor(i,1,1000)\n\t\tif(deg[i])is_father[get(i)]=1;\n\tFor(i,1,1000)\t\n\t\tif(hav[i])\n\t\t\tif(F[i]==i&&!is_father[i])\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n \n \n\n\n#define NO \"NO\"\n#define YES \"YES\"\nint N, H;\nint L[101010], R[101010];\nint in[505], ou[505];\nint used[505];\n//---------------------------------------------------------------------------------------------------\nvector<int> E[505];\nint vis[505];\nvoid dfs(int cu) {\n    vis[cu] = 1;\n    fore(to, E[cu]) if(!vis[to]) {\n        dfs(to);\n    }\n}\n//---------------------------------------------------------------------------------------------------\nstring solve() {\n    cin >> N >> H;\n\n    // make_edge\n    rep(i, 0, N) {\n        int a, b, c, d; cin >> a >> b >> c >> d;\n\n        int l;\n        if (0 < c) l = -c;\n        else l = a;\n\n        int r;\n        if (0 < d) r = d;\n        else r = -b;\n\n        l += 250, r += 250;\n\n        L[i] = l, R[i] = r;\n    }\n\n    // in/out check\n    rep(i, 0, N) {\n        int l = L[i], r = R[i];\n        ou[l]++; in[r]++;\n    }\n    rep(i, 0, 505) {\n        int x = i - 250;\n        if (0 < x) if (ou[i] < in[i]) return NO;\n        if (x < 0) if (in[i] < ou[i]) return NO;\n    }\n\n    // cycle check\n    rep(i, 0, N) {\n        int l = L[i], r = R[i];\n        used[l] = used[r] = 1;\n        E[l].push_back(r);\n    }\n\n    rep(i, 0, 505) {\n        int x = i - 250;\n        if (0 < x) if (ou[i] > in[i]) if (!vis[i]) dfs(i);\n    }\n    rep(i, 0, 505) if (used[i]) if (!vis[i]) return NO;\n\n    return YES;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef UTIL_H\n#define UTIL_H\n\n\n\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0), s(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); ++s; }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { --s; A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { s = B = 0; for (auto &a: A) a = queue<T>(); }\n\tinline ui size() const { return s; }\nprivate:\n\tvector<queue<T>> A; ui B; int s;\n};\n\nstruct\tUnionFind {\n\tUnionFind(size_t N) : P(N, -1), comp(N) {}\n\tint find(int x) { while (P[x]> 0){x = P[x]-1;}return x; }\n\tbool united(int x, int y) { return find(x) == find(y); }\n\tbool unite(int x, int y) { x=find(x);y=find(y);if(x==y){return false;}--comp;if(P[x]>P[y]){swap(x,y);}P[x]+=P[y];P[y]= x+1;return true;}\n\tinline ui size(int u) { return -P[find(u)]; }\n\tvector<int> P;\n\tsize_t comp;\n};\n\n\n\n#endif\n\nclass EJigsaw {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, H; cin >> N >> H;\n        UnionFind UF(2*H+2);\n        vector<int> InDeg(2*H+2, 0), OutDeg(2*H+2, 0);\n        for (int i = 0; i < N; ++i) {\n            int A, B, C, D; cin >> A >> B >> C >> D;\n            int left = C ? C : H+1+A;\n            int right = D ? H+1+D : B;\n            InDeg[right]++;\n            OutDeg[left]++;\n            UF.unite(left, right);\n        }\n\n        for (int i = H+2; i <= 2*H+1; ++i) {\n            if (OutDeg[i] >= InDeg[i]) {\n                int diff = OutDeg[i] - InDeg[i];\n                InDeg[i] += diff;\n                OutDeg[0] += diff;\n                if (diff) UF.unite(0, i);\n            } else {\n                cout << \"NO\\n\";\n                return;\n            }\n        }\n        for (int i = 1; i <= H; ++i) {\n            if (OutDeg[i] <= InDeg[i]) {\n                int diff = InDeg[i] - OutDeg[i];\n                InDeg[0] += diff;\n                OutDeg[i] += diff;\n                if (diff) UF.unite(0, i);\n            } else {\n                cout << \"NO\\n\";\n                return;\n            }\n        }\n\n        int cmp = UF.comp;\n        for (int i = 1; i < 2*H+2; ++i) if (InDeg[i] == 0 && OutDeg[i] == 0) --cmp;\n        if (cmp == 1) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEJigsaw solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\nint n,m;\nint fa[2000003],vis[2000003],D[2000003],C[2000003];\ninline int find(int x){\n\tif(fa[x]==x){\n\t\treturn fa[x];\n\t}else{\n\t\treturn fa[x]=find(fa[x]);\n\t}\n}\nint main(){\n\tcin>>n>>m;\n    for(int i=1;i<=1000;i++){\n    \tfa[i]=i;\n\t}\n    for(int i=1;i<=n;i++){\n        int x,y,a,b,c,d;\n        cin>>a>>b>>c>>d;\n        x=!c?a+500:-c+500;\n        y=!d?-b+500:d+500;\n        fa[find(x)]=find(y);\n        D[x]++,D[y]--;\n\t\tvis[x]=1;\n    }\n    int flag=1;\n    for(int i=1;i<500;i++){\n    \tif(D[i]>0){\n\t\t\tputs(\"NO\");\n    \t\treturn 0;\n\t\t}\n\t}\n    for(int i=501;i<=1000;i++){\n    \tif(D[i]<0){\n    \t\tputs(\"NO\");\n    \t\treturn 0;\n\t\t}\n\t}\n    for(int i=1;i<=1000;i++){\n    \tvis[find(i)]|=vis[i];\n\t}\n    for(int i=1;i<=1000;i++){\n\t\tif(D[i]){\n\t\t\tC[find(i)]=1;\n\t\t}\n\t}\n    for(int i=1;i<=1000;i++){\n    \tif(fa[i]==i&&!C[i]&&vis[i]){\n    \t\tputs(\"NO\");\n    \t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"YES\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define y1 __zzd001\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=100005;\nint n,H,c1=0,c2=0;\nvector <int> aL[N],aR[N],bL[N],bR[N];\nchar s[5][5];\nnamespace Brute{\n\tint a[N],b[N],c[N],d[N],id[N];\n\tbool check(){\n\t\tfor (int i=1;i<n;i++){\n\t\t\tint x=id[i],y=id[i+1];\n\t\t\tif (d[x]){\n\t\t\t\tif (a[y]!=d[x])\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b[x]!=c[y])\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\tvoid brute(){\n\t\tn=read(),H=read();\n\t\tfor (int i=1;i<=n;i++)\n\t\t\ta[i]=read(),b[i]=read(),c[i]=read(),d[i]=read();\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tid[i]=i;\n\t\tdo {\n\t\t\tif (check()){\n\t\t\t\tfor (int i=1;i<=n;i++)\n\t\t\t\t\tprintf(\"%d \",id[i]);\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t} while (next_permutation(id+1,id+n+1));\n\t\tputs(\"brute - end\");\n\t}\n}\nint main(){\n//Brute :: brute();\n\tn=read(),H=read();\n\tfor (int i=1;i<=n;i++){\t\n\t\tint a=read(),b=read(),c=read(),d=read();\n//\t\tfor (int i=1;i<=4;i++)\n//\t\t\tfor (int j=1;j<=3;j++)\n//\t\t\t\ts[i][j]=j==2?'#':' ';\n//\t\tfor (int i=1;i<=a;i++)\n//\t\t\ts[i+c][1]='#';\n//\t\tfor (int i=1;i<=b;i++)\n//\t\t\ts[i+d][3]='#';\n//\t\tfor (int i=4;i>=1;i--,puts(\"\"))\n//\t\t\tfor (int j=1;j<=3;j++)\n//\t\t\t\tputchar(s[i][j]);\n\t\tif (!c)\n\t\t\taR[a].push_back(i);\n\t\telse\n\t\t\tbR[c].push_back(i);\n\t\tif (!d)\n\t\t\tbL[b].push_back(i);\n\t\telse\n\t\t\taL[d].push_back(i);\n\t}\n\tfor (int i=1;i<=200;i++){\n\t\tint s1=aL[i].size();\n\t\tint s2=aR[i].size();\n\t\tif (s1>s2)\n\t\t\treturn puts(\"NO\"),0;\n\t\tif (s1<s2)\n\t\t\tc1+=s2-s1;\n\t\telse {\n\t\t\tif (!s1)\n\t\t\t\tcontinue;\n\t\t\tint f=1;\n\t\t\tfor (int j=0;f&&j<s1;j++)\n\t\t\t\tif (aL[i][j]!=aR[i][j])\n\t\t\t\t\tf=0;\n\t\t\tc1++;\n\t\t\tif (f)\n\t\t\t\treturn puts(\"NO\"),0;\n\t\t}\n\t}\n\tfor (int i=1;i<=200;i++){\n\t\tint s1=bR[i].size();\n\t\tint s2=bL[i].size();\n\t\tif (s1>s2)\n\t\t\treturn puts(\"NO\"),0;\n\t\tif (s1<s2)\n\t\t\tc2+=s2-s1;\n\t\telse {\n\t\t\tif (!s1)\n\t\t\t\tcontinue;\n\t\t\tint f=1;\n\t\t\tfor (int j=0;f&&j<s1;j++)\n\t\t\t\tif (bL[i][j]!=bR[i][j])\n\t\t\t\t\tf=0;\n\t\t\tc2++;\n\t\t\tif (f)\n\t\t\t\treturn puts(\"NO\"),0;\n\t\t}\n\t}\n\tif (c1!=c2)\n\t\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 10005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n        if(c == '-') f = -1;\n        c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n        res = res * 10 + c - '0';\n        c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n        out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint g[405][405],f[405][405],ind[405],H,col[405],all;\nint N,A[100005],B[100005],C[100005],D[100005],cnt;\nbool vis[405],flag;\nvoid dfs(int u) {\n    all += ind[u];\n    ++cnt;\n    if(ind[u]) flag = 1;\n    vis[u] = 1;\n    for(int i = 1 ; i <= 2 * H ; ++i) {\n        if(f[u][i] && !vis[i]) dfs(i);\n    }\n}\nvoid Solve() {\n    read(N);read(H);\n    for(int i = 1 ; i <= N ; ++i) {\n        read(A[i]);read(B[i]);read(C[i]);read(D[i]);\n        int s,t;\n        if(C[i]) s = C[i];\n        else s = A[i] + H;\n        if(D[i]) t = D[i] + H;\n        else t = B[i];\n        g[s][t]++;ind[t]++;ind[s]--;\n        f[s][t]++;f[t][s]++;\n    }\n    for(int i = 1 ; i <= H ; ++i) {\n        if(ind[i] < 0) {puts(\"NO\");return;}\n    }\n    for(int i = H + 1 ; i <= 2 * H ; ++i) {\n        if(ind[i] > 0) {puts(\"NO\");return;}\n    }\n    for(int i = 1 ; i <= 2 * H ; ++i) {\n        if(!vis[i]) {\n            flag = 0;cnt = 0;\n            dfs(i);\n            if(cnt == 1) continue;\n            if(all != 0 || !flag) {puts(\"NO\");return;}\n        }\n    }\n    puts(\"YES\");\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=205,INF=1<<30;\nint cnt[MAX][2];\nbool seen[MAX][2];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,H;cin>>N>>H;\n    \n    for(int i=0;i<N;i++){\n        int a,b,c,d;cin>>a>>b>>c>>d;\n        if(c==0){\n            cnt[a][0]++;\n            seen[a][0]=1;\n        }\n        else{\n            cnt[c][1]++;\n            seen[c][1]=1;\n        }\n        \n        if(d==0){\n            cnt[b][1]--;\n            seen[b][1]=1;\n        }\n        else{\n            cnt[d][0]--;\n            seen[d][0]=1;\n        }\n    }\n    \n    int sum1=0,sum2=0;\n    bool ok=true;\n    \n    for(int i=0;i<=H;i++){\n        sum1+=cnt[i][0];\n        sum2+=cnt[i][1];\n        \n        if(cnt[i][0]<0) ok=false;\n        if(cnt[i][1]>0) ok=false;\n        \n        if(cnt[i][0]==0&&seen[i][0]) ok=false;\n        if(cnt[i][1]==0&&seen[i][1]) ok=false;\n    }\n    \n    if(sum1>sum2&&ok) cout<<\"YES\\n\";\n    else cout<<\"NO\\n\";\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nvector<int> g[401];\nint in[401], out[401];\nbool vis[401];\n\nbool go(int v){\n\tif (g[v].empty())return true;\n\tvis[v] = true;\n\tbool ok = in[v] != out[v];\n\tf(i, 0, g[v].size())if (!vis[g[v][i]])ok |= go(g[v][i]);\n\treturn ok;\n}\n\nint main(){\n\tint n, h;\n\tscanf(\"%d%d\", &n, &h);\n\tf(i, 0, n){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x, y;\n\t\tif (c == 0)x = a; else x = c + 200;\n\t\tif (d == 0)y = b + 200; else y = d;\n\t\t++in[y];\n\t\t++out[x];\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tbool ok = true;\n\tf(i, 0, h + 1)if (in[i] > out[i])ok = false;\n\tf(i, 201, h + 201)if (out[i] > in[i])ok = false;\n\tf(i, 0, 401)if (!vis[i])ok &= go(i);\n\tprintf(\"%s\\n\", ok ? \"YES\" : \"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nconst int MaxN = 505;\n\nint n, h;\nint in[MaxN], out[MaxN], ok[MaxN], fa[MaxN];\n\nint Find(int x) { return x == fa[x] ? x : fa[x] = Find(fa[x]); }\n\nvoid Init()\n{\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 1; i <= (h << 1); ++i)\n\t\tfa[i] = i;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tint a, b, c, d, l, r;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tl = (c == 0) ? h + a : c;\n\t\tr = (d == 0) ? b : h + d;\n\t\t++out[l];\n\t\t++in[r];\n\t\tif (Find(l) != Find(r))\n\t\t\tfa[Find(l)] = Find(r);\n\t}\n}\t\n\nint Main()\n{\n\tfor (int i = 1; i <= h; ++i)\n\t\tif (out[i] > in[i])\n\t\t\treturn puts(\"NO\");\n\tfor (int i = h + 1; i <= (h << 1); ++i)\n\t\tif (in[i] > out[i])\n\t\t\treturn puts(\"NO\");\n\tfor (int i = 1; i <= (h << 1); ++i)\n\t\tif (in[i] != out[i])\n\t\t\tok[Find(i)] = true;\n\tfor (int i = 1; i <= (h << 1); ++i)\n\t\tif (Find(i) == i && !ok[i] && in[i] + out[i] != 0)\n\t\t\treturn puts(\"NO\");\n\treturn puts(\"YES\");\n}\n\nint main()\n{\n\tInit();\n\tMain();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define maxn 100002\n#define FOR(i, l, r) for (int i=l; i<=r; ++i)\n#define FORD(i, r, l) for (int i=r; i>=l; --i)\n#define REP(i, r) for (int i=0; i<(int)r; ++i)\n#define REPD(i, r) for (int i=(int)r-1; i>=0; --i)\n#define fi first\n#define se second\n#define mk make_pair\n#define nil NULL\n#define y0 y902\n#define y1 y232\n#define x0 x92\n#define x1 x899\n#define next asdfa\n#define sz size\n#define Debug(X) {cerr << #X << \" = \" << X << '\\n';}\n#define PR(A, n) {cerr << #A << \" = \"; FOR(i, 1, n) cerr << A[i] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; REP(i, n) cerr << A[i] << ' '; cerr << '\\n';}\ntypedef long long ll;\ntypedef double db;\ntypedef pair<db, db> dd;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\nconst int inf = 1e9;\ntemplate<class T> int getbit(T x, int pos) {return (x>>(pos-1)) & 1;}\ntemplate<class T> void turn_on(T &x, int pos) {x = x | ((T)1<<(pos-1));}\ntemplate<class T> void turn_off(T &x, int pos) {x = x & ~((T)1<<(pos-1));}\ntemplate<class T> T sqr(T a) {return a*a;}\n\nint n, H, a[maxn], b[maxn], c[maxn], d[maxn];\nint cnt1[maxn], cnt2[maxn], cnt3[maxn], cnt4[maxn], tmp1, tmp2, tmp3;\nbool ok = true;\n\nint main() {\n    //freopen(\"jigsaw.inp\", \"r\", stdin);\n    //freopen(\"jigsaw.ans\", \"w\", stdout);\n    //ios::sync_with_stdio(0); cin.tie(0);\n    scanf(\"%d%d\", &n, &H);\n    FOR(i, 1, n) {\n        scanf(\"%d%d%d%d\", &a[i], &b[i], &c[i], &d[i]);\n        if (c[i]==0 && d[i]==0) ++tmp3;\n        if (c[i]==0) cnt1[a[i]]++;\n        else cnt2[c[i]]++;\n        if (d[i]==0) cnt3[b[i]]++;\n        else cnt4[d[i]]++;\n    }\n    FOR(i, 1, H) {\n        if (cnt2[i]>cnt3[i]) ok = false;\n        if (cnt2[i]==cnt3[i]-1) ++tmp1;\n        if (cnt4[i]>cnt1[i]) ok = false;\n        if (cnt4[i]==cnt1[i]-1) ++tmp2;\n    }\n    ok = ok && (tmp1+tmp2-tmp3<=2);\n    if (ok) printf(\"YES\");\n    else printf(\"NO\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint inadj[210][2], outadj[210][2], n, h;\nint inadj2[210][2], outadj2[210][2];\npair<int, int> thing(int a, int b)\n{\n\tpair<int, int> ans;\n\tif (b) ans = { b, 0 };\n\telse ans = { a, 1 };\n\treturn ans;\n}\nvector<pair<int, int> > adj[210][2];\nint seen[210][2], c;\nvector<pair<int, int> > components[500];\nvoid dfs(int a, int b, int d)\n{\n\tif (seen[a][b]) return;\n\tseen[a][b] = 1;\n\tcomponents[d].push_back({ a, b });\n\tfor (auto c : adj[a][b]) dfs(c.first, c.second, d);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tpair<int, int> in, out;\n\t\tin = thing(a, c);\n\t\tout = thing(b, d);\n\t\tout.second = !out.second;\n//\t\tprintf(\"%d %d -> %d %d\\n\", in.first, in.second, out.first, out.second);\n\t\toutadj[in.first][in.second]++;\n\t\tinadj[out.first][out.second]++;\n\t\tadj[in.first][in.second].push_back(out);\n\t\tadj[out.first][out.second].push_back(in);\n\t}\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tif (adj[i][j].size() && !seen[i][j]) dfs(i, j, c++);\n\t\t//\tprintf(\"%d:%d - in %d, out %d\\n\", i, j, inadj[i][j], outadj[i][j]);\n\t\t}\n\t}\n\tbool works = 1;\n\tfor (int i = 0; i < c; i++)\n\t{\n\t\tfor (int i = 0; i <= h; i++) inadj2[i][0] = inadj2[i][1] = outadj2[i][0] = outadj2[i][1] = 0;\n\t\tfor (auto b : components[i])\n\t\t{\n\t\t\tinadj2[b.first][b.second] += inadj[b.first][b.second];\n\t\t\toutadj2[b.first][b.second] += outadj[b.first][b.second];\n\t\t}\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\t//printf(\"%d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\tif (inadj2[i][0] - outadj2[i][0] > 0 && inadj2[i][1] - outadj2[i][1] < 0) \n\t\t\t{\n\t\t\t//\tprintf(\"%d\\n\", i);\n\t\t\t\tinadj2[i][0]--; \n\t\t\t\toutadj2[i][1]--;\n\t\t\t//\tprintf(\" %d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\t}\n\t\t}\n\t\tint extra = 0;\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t{\n\t\t//\t\tprintf(\"  %d\\n\", abs(inadj2[i][j] - outadj2[i][j]));\n\t\t\t\tif (abs(inadj2[i][j] - outadj2[i][j]) == 1) extra++;\n\t\t\t\telse if (abs(inadj2[i][j] - outadj2[i][j])) extra += 10;\n\t\t\t}\n\t\t}\n\t\tif (extra != 2) works = 0;\n\t}\n//\tprintf(\"Components %d\\n\", c);\n\tassert(!works);\n\tif (works) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 101000\n#define M 510\nusing namespace std;\nint last[M],nxt[N],n,m,to[N],rd[M],cd[M],tot=0,bz[M];\nvoid link(int x,int y)\n{\n\tnxt[++tot]=last[x];last[x]=tot;to[tot]=y;\n\trd[y]++;cd[x]++;\n}\nvoid dg(int x)\n{\n\tif(bz[x]==1) return;bz[x]=1;\n\tfor(int i=last[x];i;i=nxt[i]) dg(to[i]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n)\n\t{\n\t\tint a,b,c,d,x,y;scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0) x=a+m;\n\t\telse x=c;\n\t\tif(d==0) y=b;\n\t\telse y=d+m;\n\t\tlink(x,y);\n\t}\n\tint q=0,w=0;\n\tfo(i,1,m)\n\t{\n\t\tif(rd[i]<cd[i]) q++;\n\t\tif(rd[i]>cd[i]) w++;\n\t}\n\tif(q>0||w==0) return printf(\"NO\\n\"),0;\n\tq=0,w=0;\n\tfo(i,m+1,m+m)\n\t{\n\t\tif(rd[i]>cd[i]) q++;\n\t\tif(rd[i]<cd[i]) w++;\n\t}\n\tif(q>0||w==0) return printf(\"NO\\n\"),0;\n\tq=0,w=0;\n\tfo(i,1,m) if(rd[i]>cd[i]) w++;\n\tfo(i,m+1,m+m) if(rd[i]<cd[i]) q++;\n//\tif(q!=w) return printf(\"NO\\n\"),0;\n\tfo(i,m+1,m+m) if(rd[i]<cd[i]) dg(i);\n\tfo(i,1,m) if((rd[i]>0||cd[i]>0)&&bz[i]==0) return printf(\"NO\\n\"),0;\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n\nconst int N = 400 + 10;\n\nint n, deg[N];\n\nint anc[N], cnt[N], mask[N];\n\nint find(int x) { return anc[x] == x ? x : (anc[x] = find(anc[x])); }\n\nvoid init() {\n  int m;\n  scanf(\"%d%d\", &m, &n);\n  std::iota(anc, anc + 2 * n + 1, 0);\n  while (m--) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    int x = c ? (c + n) : a, y = d ? d : (b + n);\n    ++cnt[x], ++cnt[y];\n    --deg[x], ++deg[y];\n    anc[find(x)] = find(y);\n  }\n}\n\nint main() {\n  init();\n  for (int i = 1; i <= n; ++i) if (deg[i] > 0 || deg[i + n] < 0) return puts(\"NO\"), 0;\n  for (int i = 1; i <= 2 * n; ++i) mask[find(i)] |= deg[i];\n  for (int i = 1; i <= n; ++i) if (find(i) == i && cnt[i] && !mask[i]) return puts(\"NO\"), 0;\n  puts(\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nint IN[1100];\nint OUT[1100];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\n\tfor(int i=0;i<a;i++){\n\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tint fr=-r;\n\t\tint to=-s;\n\t\tif(r==0)fr=p;\n\t\tif(s==0)to=q;\n\t\tto*=-1;\n\t\tIN[fr+b]++;\n\t\tOUT[to+b]++;\n\t}\n\tfor(int i=0;i<2*b;i++){\n\t\tif(IN[i]>OUT[i]&&i-b<0){printf(\"NO\\n\");return 0;}\n\t\tif(IN[i]<OUT[i]&&i-b>0){printf(\"NO\\n\");return 0;}\n\t\t\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=200000+10;\nint fa[maxn],vis[maxn],du[maxn],bz[maxn];\nint i,j,k,l,t,n,m,a,b,c,d,x,y;\nbool czy;\nint getfa(int x){\n\treturn fa[x]==x?x:fa[x]=getfa(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,1000) fa[i]=i;\n\tfo(i,1,n){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=c?-c:a;\n\t\ty=d?d:-b;\n\t\tx+=500;y+=500;\n\t\tfa[getfa(x)]=getfa(y);\n\t\tdu[x]++;du[y]--;\n\t\tvis[x]=1;\n\t}\n\tczy=1;\n\tfo(i,1,500)\n\t\tif (du[i]>0) czy=0;\n\tfo(i,501,1000)\n\t\tif (du[i]<0) czy=0;\n\tfo(i,1,1000) vis[getfa(i)]|=vis[i];\n\tfo(i,1,1000)\n\t\tif (du[i]) bz[getfa(i)]=1;\n\tfo(i,1,1000)\n\t\tif (fa[i]==i&&!bz[i]&&vis[i]) czy=0;\n\tif (czy) printf(\"Yes\\n\");else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 410;\n\nint indeg[N], outdeg[N], fa[N];\n\nint find(int x){\n\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nint n, H;\n\nint main(){\n\tscanf(\"%d%d\", &n, &H);\n\n\tFor(i, 1, 2 * H) fa[i] = i;\n\tFor(i, 1, n){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint u = !c ? a : H + c, v = !d ? H + b : d;\n\t\tfa[find(u)] = find(v);\n\t\t++outdeg[u], ++indeg[v];\n\t}\n\n\tbool flag = true;\n\tFor(i, 1, 2 * H) if(i == fa[i] && (indeg[i] || outdeg[i])){\n\t\tbool differ = false;\n\t\tFor(j, 1, H) if(find(j) == i){\n\t\t\tif(outdeg[j] < indeg[j]) flag = false;\n\t\t\tif(outdeg[j] ^ indeg[j]) differ = true;\n\t\t}\n\n\t\tFor(j, H + 1, 2 * H) if(find(j) == i){\n\t\t\tif(indeg[j] < outdeg[j]) flag = false;\n\t\t\tif(indeg[j] ^ outdeg[j]) differ = true;\n\t\t}\n\n\t\tif(!flag || !differ){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tputs(flag ? \"YES\" : \"NO\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> graph[444];\nbool visit[444];\nint last[401];\n\nint lbottom(int t)\n{\n    return t;\n}\n\nint lup(int t)\n{\n    return 200 + t;\n}\n\nint rbottom(int t)\n{\n    return 400 + t;\n}\n\nint rup(int t)\n{\n    return 600 + t;\n}\n\nint next_blk(int t)\n{\n    if (t > 400 && t <= 600) return lup(t - 400);\n    else return lbottom(t - 600);\n}\n\nint main()\n{\n    int n, h;\n    scanf(\"%d%d\",&n,&h);\n    for (int i = 0; i < n; i++)\n    {\n        int a, b, c, d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\n        int lidx, ridx;\n\n        if (c == 0) lidx = lbottom(a);\n        else lidx = lup(c);\n\n        if (d == 0) ridx = rbottom(b);\n        else ridx = rup(d);\n\n        graph[lidx].push_back(next_blk(ridx));\n    }\n\n    for (int i = 1; i <= 400; i++) sort(graph[i].begin(), graph[i].end());\n\n    int single = -1;\n\n    for (int i = 1; i <= 200; i++)\n    {\n        if (graph[i].empty()) continue;\n\n        int t = i;\n        bool visitbefore = visit[t];\n\n        for (;;)\n        {\n            visit[t] = true;\n            if (last[t] == graph[t].size()) break;\n            t = graph[t][last[t]++];\n        }\n\n        if (t <= 200)\n        {\n            if (visitbefore)\n            {\n                if (t == i) continue;\n                printf(\"NO\\n\");\n                return 0;\n            }\n\n            if (t == single)\n            {\n                single = i;\n                continue;\n            }\n\n            printf(\"NO\\n\");\n            return 0;\n        }\n\n        if (single == -1) single = i;\n    }\n\n    for (int i = 201; i <= 400; i++)\n    {\n        if (graph[i].empty()) continue;\n        if (last[i] == graph[i].size()) continue;\n\n        if (visit[i] == false)\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n\n        int t = i;\n        for (;;)\n        {\n            visit[t] = true;\n            if (last[t] == graph[t].size()) break;\n            t = graph[t][last[t]++];\n        }\n\n        if (t != i)\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"YES\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nconst int MAX_V = 420;\nconst int Base = MAX_V / 2;\n\nvector<int> es[MAX_V];\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n\n\n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n\n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n\n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n    bool check(int v) {\n    \treturn res[cmp[v]].size() > 1;\n    }\n};\n\n// #define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\tvi a(n), b(n), c(n), d(n);\n\trep(i, n) cin >> a[i] >> b[i] >> c[i] >> d[i];\n\tvi l(n), r(n);\n\trep(i, n) {\n\t\tl[i] = (c[i] == 0 ? a[i] : -c[i]);\n\t\tr[i] = (d[i] == 0 ? b[i] : -d[i]);\n\t}\n\tset<int> st;\n\trep(i, n) {\n\t\tint frm = (l[i] > 0 ? l[i] : Base - l[i]);\n\t\tint to = (r[i] > 0 ? Base + r[i] : -r[i]);\n\t\tif(frm == to) continue;\n\t\tes[frm].pb(to);\n\t\tst.insert(frm);\n\t\tst.insert(to);\n\t}\n\tint W = MAX_V-1;\n\tst.insert(W);\n\tvector<int> in(MAX_V), out(MAX_V);\n\tSCC g(MAX_V);\n\trep(i, MAX_V) {\n\t\tsort(all(es[i]));\n\t\tes[i].erase(unique(all(es[i])), es[i].end());\n\t\tint prv = -1;\n\t\tfor(auto& to : es[i]) {\n\t\t\tif(prv != to) g.add_edge(i, to);\n\t\t\tprv = to;\n\t\t\tin[to]++;\n\t\t}\n\t\tout[i] = es[i].size();\n\t}\n\trep(i, MAX_V) {\n\t\tif(i >= Base) {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] < out[i]) {\n\t\t\t\tLINE;dump(i);dump(in[i]);dump(out[i]);dump(es[i][0]);\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse g.add_edge(i, W);\n\t\t}\n\t\telse {\n\t\t\tif(in[i] == out[i]);\n\t\t\telse if(in[i] > out[i]) {\n\t\t\t\tLINE;\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse g.add_edge(W, i);\n\t\t}\n\t}\n\tg.scc();\n\tfor(auto& v : st) {\n\t\tif(!g.check(v)) {\n\t\t\tLINE;\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int> g[505];\nint l_cnt[505], r_cnt[505];\nbool used[505];\n\nint print(bool ok) {\n        if (ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n}\n\nbool dfs(int v) {\n        if (g[v].empty()) return true;\n        used[v] = true;\n        if (l_cnt[v] != r_cnt[v]) return true; //端\n        bool enough = false;\n        for (auto u : g[v]) if (!used[u]) enough |= dfs(u); //パーツが足りる？\n        return enough;\n}\n\nint main() {\n        int n, h, a, b, c, d;\n        cin >> n >> h;\n        for (int i = 0; i < n; i ++) {\n                cin >> a >> b >> c >> d;\n                int lh = (c == 0 ? a : c + 250);\n                int rh = (d == 0 ? b + 250 : d);\n                l_cnt[lh] ++;\n                r_cnt[rh] ++;\n                g[lh].push_back(rh);\n                g[rh].push_back(lh);\n//cerr << lh << ' ' << rh << endl;\n        }\n        for (int i = 0; i < h + 1; i ++) if (r_cnt[i] > l_cnt[i]) return print(0);\n        for (int i = 251; i < 501 + h; i ++) if (l_cnt[i] > r_cnt[i]) return print(0);\n        for (int i = 0; i < 501; i ++) if (!used[i]) if (!dfs(i)) return print(0);\n        return print(1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> graph[444];\nint last[444];\nint first_fin;\n\nint lbottom(int t)\n{\n    return t;\n}\n\nint lup(int t)\n{\n    return 200 + t;\n}\n\nint rbottom(int t)\n{\n    return 400 + t;\n}\n\nint rup(int t)\n{\n    return 600 + t;\n}\n\nint next_blk(int t)\n{\n    if (t > 400 && t <= 600) return lup(t - 400);\n    else return lbottom(t - 600);\n}\n\nvoid dfs(int t)\n{\n    for (int &i = last[t]; i < graph[t].size();)\n    {\n        int nxt = graph[t][i++];\n        dfs(nxt);\n    }\n    if (first_fin == -1) first_fin = t;\n}\n\nint main()\n{\n    int n, h;\n    scanf(\"%d%d\",&n,&h);\n    for (int i = 0; i < n; i++)\n    {\n        int a, b, c, d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\n        int lidx, ridx;\n\n        if (c == 0) lidx = lbottom(a);\n        else lidx = lup(c);\n\n        if (d == 0) ridx = rbottom(b);\n        else ridx = rup(d);\n\n        graph[lidx].push_back(next_blk(ridx));\n    }\n\n    for (int i = 1; i <= 200; i++)\n    {\n        if (graph[i].empty()) continue;\n\n        memset(last, 0, sizeof(last));\n        first_fin = -1;\n        dfs(i);\n\n        if (first_fin > 200 && accumulate(last + 1, last + 401, 0) == n)\n        {\n            printf(\"YES\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"NO\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 405;\nint N, H, fa[MAX_N], in[MAX_N], out[MAX_N], ok[MAX_N];\nbool vis[MAX_N];\n\nint find(int x) {\n  return fa[x] == x ? x : fa[x] = find(fa[x]);\n}\n\nint main() {\n  scanf(\"%d%d\", &N, &H);\n  for (int i = 1; i <= H << 1; ++i) fa[i] = i;\n  \n  for (int i = 1; i <= N; ++i) {\n    int A, B, C, D, u, v;\n    scanf(\"%d%d%d%d\", &A, &B, &C, &D);\n    if (C == 0) out[A]++, u = A;\n    else out[C + H]++, u = C + H;\n    \n    if (D == 0) in[B + H]++, v = B + H;\n    else in[D]++, v = D;\n\n    vis[u] = vis[v] = 1;\n    if (find(u) != find(v)) fa[find(u)] = find(v);\n  }\n\n  bool flag = 1;\n  for (int i = 1; i <= H; ++i)  {\n    if (in[i] > out[i]) flag = 0;\n    if (in[i + H] < out[i + H]) flag = 0;\n    if (in[i] != out[i]) ok[find(i)] = 1;\n    if (in[i + H] != out[i + H]) ok[find(i + H)] = 1;\n  }\n  for (int i = 1; i <= H << 1; ++i)\n    if (vis[i] && !ok[find(i)]) flag = 0;\n  \n  if (flag) puts(\"YES\");\n  else puts(\"NO\");\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 100000\n#define MAXH 400\nusing namespace std;\nint N,H;\nint setfa[MAXH+5],cd[MAXH+5],rd[MAXH+5];\nint A[MAXN+5],B[MAXN+5],C[MAXN+5],D[MAXN+5];\nint ok[MAXH+5];\nvoid Init()\n{\n\tfor(int i=1;i<=MAXH;i++)\n\t\tsetfa[i]=i;\n}\nint Findfa(int x)\n{\n\tif(x==setfa[x])\n\t\treturn x;\n\treturn setfa[x]=Findfa(setfa[x]);\n}\nvoid Union(int x,int y)\n{\n\tint fx=Findfa(x),fy=Findfa(y);\n\tif(fx==fy)\n\t\treturn;\n\tsetfa[fx]=fy;\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d %d\",&N,&H);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&A[i],&B[i],&C[i],&D[i]);\n\t\tint x,y;\n\t\tif(C[i]==0)\tx=A[i];\n\t\telse\t\tx=C[i]+H;\n\t\tif(D[i]==0)\ty=B[i]+H;\n\t\telse\t\ty=D[i];\n\t\tcd[x]++,rd[y]++;\n\t\tUnion(x,y);\n\t}\n\tbool legal=true;\n\tfor(int i=1;i<=MAXH;i++)\n\t{\n\t\tint fi=Findfa(i);\n\t\tif(cd[fi]==0&&rd[fi]==0)\n\t\t\tcontinue;\n\t\tif(cd[i]!=rd[i])\n\t\t{\n\t\t\tif(cd[i]>rd[i]&&i>H)\n\t\t\t\tlegal=false;\n\t\t\telse if(cd[i]<rd[i]&&i<=H)\n\t\t\t\tlegal=false;\n\t\t\tok[fi]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=MAXH;i++)\n\t{\n\t\tint fi=Findfa(i);\n\t\tif(cd[fi]!=0||rd[fi]!=0)\n\t\t\tif(ok[fi]==false)\n\t\t\t{\n\t\t\t\tlegal=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif(legal==true)\n\t\tprintf(\"YES\\n\");\n\telse\n\t\tprintf(\"NO\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define no return cout << \"NO\\n\", 0\nusing namespace std;\nconst int H = 405;\nint f[H], d[H];\nbool b[H], c[H];\nint getf(int x)\n{\n\treturn f[x] == x ? x : f[x] = getf(f[x]);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n, h;\n\tcin >> n >> h;\n\tfor (int i = 0; i <= 2 * h; i++)\n\t\tf[i] = i;\n\twhile (n--)\n\t{\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint x = (c ? -c : a) + h, y = (d ? d : -b) + h;\n\t\tf[getf(x)] = getf(y);\n\t\t::d[x]++;\n\t\t::d[y]--;\n\t\t::b[x] = true;\n\t}\n\tfor (int i = 0; i < h; i++)\n\t\tif (d[i] > 0)\n\t\t\tno;\n\tfor (int i = h + 1; i <= 2 * h; i++)\n\t\tif (d[i] < 0)\n\t\t\tno;\n\tfor (int i = 0; i <= 2 * h; i++)\n\t{\n\t\tb[getf(i)] |= b[i];\n\t\tif (d[i])\n\t\t\tc[f[i]] = true;\n\t}\n\tfor (int i = 0; i <= 2 * h; i++)\n\t\tif (f[i] == i && !c[i] && b[i])\n\t\t\tno;\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define inf 20021225\n#define M 510\nusing namespace std;\nint read()\n{\n\tint s=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n\treturn f*s;\n}\nint in[M],out[M],fa[M],n,h,a,b,c,d; bool vis[M];\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);} \nint main()\n{\n\tn=read(),h=read();\n\tfor(int i=0;i<=2*h;i++)\tfa[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta=read(),b=read(),c=read(),d=read();\n\t\tint l=c>0?c:-a,r=d>0?-d:b; l+=h,r+=h;\n\t\tif(find(l)!=find(r))\tfa[find(l)]=find(r);\n\t\tout[l]++; in[r]++;\n\t}\n\tfor(int i=-h;i<0;i++)\tif(in[i+h]>out[i+h])\treturn puts(\"NO\"),0;\n\tfor(int i=1;i<=h;i++)\tif(out[i+h]>in[i+h])\treturn puts(\"NO\"),0;\n\tfor(int i=0;i<=h*2;i++)\tif(in[i]!=out[i])\tvis[find(i)]=1;\n\tfor(int i=0;i<=h*2;i++)\tif((in[i]||out[i])&&!vis[find(i)])\treturn puts(\"NO\"),0;\n\treturn puts(\"YES\"),0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, H, A[100009], B[100009], C[100009], D[100009], L[100009], R[100009], deg[100009], col[100009], cnts, cnt; bool used[100009];\nvector<int>x[100009];\n\nvoid dfs1(int pos) {\n\tif (col[pos] >= 1) return;\n\tcol[pos] = cnts;\n\tfor (int i = 0; i < x[pos].size(); i++) dfs1(x[pos][i]);\n}\n\nint main() {\n\tcin >> N >> H; H++;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\t\tif (C[i] == 0) { L[i] = -A[i]; cnt++; }\n\t\telse { L[i] = C[i]; }\n\t\tif (D[i] == 0) { R[i] = -B[i]; cnt++; }\n\t\telse { R[i] = D[i]; }\n\t\tR[i] *= -1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint a1 = 0, a2 = 0;\n\t\tif (L[i] < 0) a1 = H + (-L[i]); else a1 = L[i];\n\t\tif (R[i] < 0) a2 = H + (-R[i]); else a2 = R[i];\n\t\tdeg[a1]++; deg[a2]--; used[a1] = true; used[a2] = true;\n\t\tx[a1].push_back(a2); x[a2].push_back(a1);\n\t}\n\tbool OK = true; int V = 0;\n\tfor (int i = 0; i < H; i++) { if (deg[i] > 0) OK = false; }\n\tfor (int i = H; i < 2 * H; i++) { if (deg[i] < 0) OK = false; else V += deg[i]; }\n\n\tfor (int i = 0; i < 2 * H; i++) {\n\t\tif (col[i] == 0 && used[i] == true) { cnts++; dfs1(i); }\n\t}\n\tif (cnts > (cnt - N) + 1) OK = false;\n\n\tif (OK == true) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rg register int\n#define rep(i,a,b) for(rg i=(a);i<=(b);++i)\n#define per(i,a,b) for(rg i=(a);i>=(b);--i)\nconst int maxn = 512;\nconst int zero = 250;\nint fa[maxn],siz[maxn],oud[maxn],ind[maxn];bool h[maxn];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\ninline void Union(int x,int y){\n    x=find(x);y=find(y);if(x==y){++siz[x];return;}\n    fa[x]=y;siz[y]+=siz[x]+1;\n}\nint main(){\n\tios::sync_with_stdio(false);\n    int n,H;cin>>n>>H;\n    rep(i,1,H)  fa[i+zero]=i+zero,siz[i+zero]=1;\n    rep(i,-H,-1)fa[i+zero]=i+zero,siz[i+zero]=1;\n    int a,b,c,d;rep(i,1,n){\n        int x,y;cin>>a>>b>>c>>d;\n        if(c == 0)x=a;else x=-c;if(d == 0)y=-b;else y=d;\n        ++oud[x+zero];++ind[y+zero];Union(x+zero,y+zero);\n    }rep(i,1,H)\tif(oud[i+zero]<ind[i+zero])return puts(\"NO\"),0;\n    rep(i,-H,-1)if(ind[i+zero]<oud[i+zero])return puts(\"NO\"),0;\n    rep(i,1,H)  h[find(i+zero)]|=(ind[i+zero]!=oud[i+zero]);\n    rep(i,-H,-1)h[find(i+zero)]|=(ind[i+zero]!=oud[i+zero]);\n    rep(i,1,H)  if(siz[find(i+zero)]>1&&(find(i+zero) == i+zero)&&(h[i+zero]==false))return puts(\"NO\"),0;\n    rep(i,-H,-1)if(siz[find(i+zero)]>1&&(find(i+zero) == i+zero)&&(h[i+zero]==false))return puts(\"NO\"),0;\n    puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint n,h,f[N],deg[N],vis[N];\nint find(int x) { return f[x]==x?x:f[x]=find(f[x]); }\nint a,b,c,d;\nvoid add(int pl,int pr) {\n\tdeg[pl]--; deg[pr]++;\n\tvis[pl]=vis[pr]=1;\n\tf[find(pl)]=find(pr);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&h);\n\trep(i,0,2*h+2) f[i]=i;\n\trep(i,0,n) {\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint pl=(c==0)?a:c+h+1;\n\t\tint pr=(d==0)?b+h+1:d;\n\t\tadd(pl,pr);\n\t}\n\trep(i,0,h+1) if (deg[i]>0) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\trep(i,h+1,2*h+2) if (deg[i]<0) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\trep(i,0,h+1) if (vis[i]) {\n\t\tbool val=0;\n\t\trep(j,0,2*h+2) if (find(i)==find(j)&&(j>h||deg[j]<0)) val=1;\n\t\tif (!val) { puts(\"NO\"); return 0;}\n\t}\n\trep(i,h+1,2*h+2) if (vis[i]) {\n\t\tbool val=0;\n\t\trep(j,0,2*h+2) if (find(i)==find(j)&&(j>h||deg[j]<0)) val=1;\n\t\tif (!val) { puts(\"NO\"); return 0;}\n\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#define C\ntypedef long long readtype;\n\n/* Header {{{ */\n#ifdef C\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#define isdigit(a) ((a) >= '0' && (a) <= '9' ? true : false)\ntemplate<typename type> type abs(type a) { return a < 0 ? -a : a; }\ntemplate<typename type> type min(type a, type b) { return a < b ? a : b; }\ntemplate<typename type> type beMin(type &a, type b) { return a = (a < b ? a : b); }\ntemplate<typename type> type max(type a, type b) { return a > b ? a : b; }\ntemplate<typename type> type beMax(type &a, type b) { return a = (a > b ? a : b); }\ntemplate<typename type> void swap(type &a, type &b) { type c; c = a; a = b; b = c; }\n#endif\n\n#ifdef Cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#endif\n\ntypedef long long var;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n/* }}} */\n\nconst int N = 110005;\n\nint n, h;\nint fa[N];\nint in[N], out[N];\nbool mark[N];\n\nint find(int t);\n\nint main() {\n  /*\n#ifndef ONLINE_JUDGE\n  freopen(\"source.in\", \"r\", stdin);\n  freopen(\"source.out\", \"w\", stdout);\n#endif\n  */\n  n = read(), h = read();\n  for (int i = h << 1; i >= 1; --i) fa[i] = i;\n  for (int i = 1; i <= n; ++i) {\n    int a = read(), b = read(), c = read(), d = read();\n    int x = c ? c + h : a, y = d ? d : b + h;\n    out[x]++, in[y]++;\n    x = find(x), y = find(y);\n    if (x != y) fa[x] = y;\n  }\n  for (int i = 1; i <= h; ++i) {\n    if (in[i] > out[i] || in[i + h] < out[i + h]) {\n      puts(\"NO\");\n      return 0;\n    }\n  }\n  for (int i = h << 1; i >= 1; --i) {\n    if (in[i] != out[i] || (!in[i] && !out[i]))\n      mark[find(i)] = true;\n  }\n  for (int i = h << 1; i >= 1; --i) {\n    if (!mark[i] && fa[i] == i) {\n      puts(\"NO\");\n      return 0;\n    }\n  }\n  puts(\"YES\");\n  return 0;\n}\n\nint find(int t) {\n  if (fa[t] != t) fa[t] = find(fa[t]);\n  return fa[t];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\n\nconst int MAXN = (200 + 10) * 2;\n\nclass no_solution : public std::exception\n{\npublic:\n\tconst char * what(void) const noexcept\n\t{\n\t\treturn \"no solution reachable\";\n\t}\n};\n\nnamespace disjointSet\n{\nint fa[MAXN];\n\nvoid init()\n{\n\tmemset(fa, 0x00, sizeof fa);\n}\n\nint find(int x)\n{\n\tif(fa[x])\n\t\treturn x;\n\treturn fa[x] = find(fa[x]);\n}\n\nvoid merge(int x, int y)\n{\n\tx = fa(x), y = fa(y);\n\tif(x != y)\n\t\tfa[x] = y;\n}\n\n}\n\nbool loop[MAXN];\nint inDeg[MAXN], outDeg[MAXN];\nint N, H;\n\nvoid solve()\n{\n\tfor(int i = 0; i <= 2 * H; i++)\n\t{\n\t\tif(i > H)\n\t\t\tif(inDeg[i] > outDeg[i])\n\t\t\t\tthrow no_solution();\n\t\tif(i < H)\n\t\t\tif(outDeg[i] > inDeg[i])\n\t\t\t\tthrow no_solution();\n\n\t\tbool found = false, isLoop = loop[i];\n\n\t\tfor(int j = 0; j <= 2 * H; j++)\n\t\t\tif(found)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tif(disjointSet::find(i) == disjointSet::find(j))\n\t\t\t\t{\n\t\t\t\t\tif(i != j)\n\t\t\t\t\t\tisLoop = true;\n\t\t\t\t\tif(inDeg[j] != outDeg[j])\n\t\t\t\t\t\tfound = true;\n\t\t\t\t}\n\n\t\tif(!found && isLoop)\n\t\t\tthrow no_solution();\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(nullptr);\n\n\tcin >> N >> H ;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tint a, b, c, d, L, R;\n\t\tcin >> a >> b >> c >> d;\n\t\tL = c ? H - c : H + a;\n\t\tR = d ? H + d : H - b;\n\t\tdisjointSet::merge(L, R);\n\t\tinDeg[R]++, outDeg[L]++;\n\n\t\tif(L == R)\n\t\t\tloop[L] = true;\n\t}\n\n\n\ttry\n\t{\n\t\tsolve();\n\t\tcout << \"YES\" << endl;\n\t}\n\tcatch(std::exception & x)\n\t{\n\t\tcout << \"NO\" << endl ;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvector <int> v[512];\nint in[512], out[512], ap[512], trec[512];\n\n#define v (v + 230)\n#define ap (ap + 230)\n#define trec (trec + 230)\n#define in (in + 230)\n#define out (out + 230)\n\nbool OK;\n\nvoid dfs (int nod)\n{\n    trec[nod] = 1;\n    if (in[nod] != out[nod]) OK = true;\n\n    for (auto &it : v[nod])\n        if (!trec[it]) dfs (it);\n}\n\nint main ()\n{\n  //  freopen (\"file.in\", \"r\", stdin);\n\n    int n, h;\n    scanf (\"%d %d\", &n, &h);\n\n    for (int i = 1; i <= n; ++i)\n    {\n        int a, b, c, d, l, r;\n        scanf (\"%d %d %d %d\", &a, &b, &c, &d);\n\n        if (!c) l = a;\n        else l = -c;\n\n        if (!d) r = -b;\n        else r = d;\n\n        v[l].push_back (r);\n\n        ++out[l];\n        ++in[r];\n\n        if (in[r] == 1) ap[r] = 1;\n    }\n\n    for (int i = -h; i <= h; ++i)\n    {\n        if (i < 0)\n        {\n            if (in[i] < out[i])\n            {\n                printf (\"NO\\n\");\n                return 0;\n            }\n        }\n\n        if (i > 0)\n        {\n            if (in[i] > out[i])\n            {\n                printf (\"NO\\n\");\n                return 0;\n            }\n        }\n    }\n\n    ap[0] = 1;\n    trec[0] = 1;\n    for (int i = -h; i <= h; ++i)\n        if (!ap[i]) dfs (i);\n\n    for (int i = -h; i <= h; ++i)\n        if (!trec[i])\n        {\n            OK = false;\n            dfs (i);\n\n            if (!OK)\n            {\n                printf (\"NO\\n\");\n                return 0;\n            }\n        }\n\n    printf (\"YES\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=410;\nint n,h,in[N],out[N];\nint fa[N];\nbool ok[N];\nint find(const int &x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n    n=read();h=read();\n    for(int i=1;i<=(h<<1);i++) fa[i]=i;\n    for(int i=1;i<=n;i++){\n        int A=read(),B=read(),C=read(),D=read();\n        int x=C?C+h:A,y=D?D:B+h;\n        out[x]++;in[y]++;\n        x=find(x);y=find(y);\n        if(x!=y) fa[x]=y;\n    }\n    for(int i=1;i<=h;i++) if(in[i]>out[i]) return !puts(\"NO\");\n    for(int i=h+1;i<=(h<<1);i++) if(in[i]<out[i]) return !puts(\"NO\");\n    for(int i=1;i<=(h<<1);i++) if(in[i]!=out[i]||!in[i]&&!out[i]) ok[find(i)]=1;\n    for(int i=1;i<=(h<<1);i++) if(fa[i]==i&&!ok[i]) return !puts(\"NO\");\n    return !puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, H, A[100009], B[100009], C[100009], D[100009], L[100009], R[100009], deg[100009], cnt;\n\nint main() {\n\tcin >> N >> H; H++;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\t\tif (C[i] == 0) { L[i] = -A[i]; cnt++; } else { L[i] = C[i]; }\n\t\tif (D[i] == 0) { R[i] = -B[i]; cnt++; } else { R[i] = D[i]; }\n\t\tR[i] *= -1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint a1 = 0, a2 = 0;\n\t\tif (L[i] < 0) a1 = H + (-L[i]); else a1 = L[i];\n\t\tif (R[i] < 0) a2 = H + (-R[i]); else a2 = R[i];\n\t\tif ((L[i] > 0 && R[i] < 0) || (L[i] < 0 && R[i]>0)) { deg[a1]++; deg[a2]--; }\n\t}\n\tbool OK = true; int V = 0;\n\tfor (int i = 0; i < H; i++) { if (deg[i] > 0) OK = false; }\n\tfor (int i = H; i < 2 * H; i++) { if (deg[i] < 0) OK = false; else V += deg[i]; }\n\n\tif (V == 0 || V != (cnt - N)) OK = false;\n\n\tif (OK == true) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e5 + 10;\n\nconst int ZERO = 404;\nconst int SZ = ZERO * 2;\nvi g[N];\nvi rg[N];\nint used[N];\n\nvoid dfs_con(int v) {\n    used[v] = true;\n    for (int to : g[v]) {\n        if (!used[to])\n            dfs_con(to);\n    }\n    for (int to : rg[v]) {\n        if(!used[to])\n            dfs_con(to);\n    }\n}\n\nbool is_connected() {\n    for (int v = 1; v < SZ; ++v) {\n        if (used[v] || (g[v].size() + rg[v].size() == 0))\n            continue;\n        dfs_con(v);\n    }\n}\n\nvoid smain() {\n\n    int n, h;\n    cin >> n >> h;\n    fori (i, n) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int u;\n        if (c > 0) {\n            u = c;\n        } else {\n            u = ZERO + a;\n        }\n        int v;\n        if (d > 0) {\n            v = d + ZERO;\n        } else {\n            v = b;\n        }\n//        cerr << \"(\" << u << \", \" << v << \")\" << endl;\n        g[u].push_back(v);\n        rg[v].push_back(u);\n    }\n\n    if (false && !is_connected()) {\n        cout << \"NO\\n\";\n        return;\n    }\n    int cnt_op = 0, cnt_cl = 0;\n    for (int v = 1; v <= SZ; ++v) {\n        if (g[v].size() != rg[v].size()) {\n            if (g[v].size() > rg[v].size())\n                cnt_op++;\n            else\n                cnt_cl++;\n        }\n    }\n    if (cnt_op == cnt_cl) {\n        cout << \"YES\\n\";\n    } else {\n        cout << \"NO\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, H, A[100009], B[100009], C[100009], D[100009], L[100009], R[100009], deg[100009], U[100009];\nvector<int>X[509], Y[509]; bool used[509];\n\nint dfs(int pos) {\n\tif (pos < H) return 1;\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tint v = dfs(X[pos][i]);\n\t\tif (v == 1) return 1;\n\t}\n\treturn 0;\n}\nint dfs2(int pos) {\n\tif (pos >= H) return 1;\n\tused[pos] = true;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (used[Y[pos][i]] == true) continue;\n\t\tint v = dfs2(Y[pos][i]);\n\t\tif (v == 1) return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tcin >> N >> H; H++;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\t\tif (C[i] == 0) L[i] = -A[i]; else L[i] = C[i];\n\t\tif (D[i] == 0) R[i] = -B[i]; else R[i] = D[i];\n\t\tR[i] *= -1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint a1 = 0, a2 = 0;\n\t\tif (L[i] < 0) a1 = H + (-L[i]); else a1 = L[i];\n\t\tif (R[i] < 0) a2 = H + (-R[i]); else a2 = R[i];\n\t\tdeg[a1]++; deg[a2]--; U[a1]++; U[a2]++;\n\t\tX[a1].push_back(a2);\n\t\tY[a2].push_back(a1);\n\t}\n\tbool OK = true;\n\tfor (int i = H; i < 2 * H; i++) {\n\t\tfor (int j = 0; j < 2 * H; j++) used[j] = false;\n\t\tif (U[i] >= 1 && dfs(i) == 0) {\n\t\t\tOK = false;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < 2 * H; j++) used[j] = false;\n\t\tif (U[i] >= 1 && dfs2(i) == 0) {\n\t\t\tOK = false;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) { if (deg[i] > 0) OK = false; }\n\tfor (int i = H; i < 2 * H; i++) { if (deg[i] < 0) OK = false; }\n\tif (OK == true) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\n\nusing namespace std;\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n        cerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\n\nconst int MAXN = 210000;\n\nint n, h;\nvector<int> eds[MAXN];\nvector<int> beds[MAXN];\nint was[MAXN];\n\nvoid dfs1(int v) {\n    was[v] = 1;\n    for (int u: eds[v]) {\n        if (!was[u])\n            dfs1(u);\n    }\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &h);\n    for (int i = 0; i < n; ++i) {\n        int a, b, c, d;\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        if (c == 0) {\n            eds[a].push_back(i + 2 * h);\n        }\n        else {\n            eds[c + h].push_back(i + 2 * h);\n        }\n        if (d == 0) {\n            eds[i + 2 * h].push_back(b + h);\n        }\n        else {\n            eds[i + 2 * h].push_back(d);\n        }\n    }\n    int g = 2 * h + n;\n    for (int i = 0; i < g; ++i)\n        for (int u: eds[i])\n            beds[u].push_back(i);\n    for (int i = 0; i < h; ++i) {\n        if (eds[i].size() < beds[i].size()) {\n            cout << \"NO\\n\";\n            return 0;\n        }\n        while (eds[i].size() > beds[i].size()) {\n            eds[g].push_back(i);\n            beds[i].push_back(g);\n        }\n    }\n    for (int i = h; i < 2 * h; ++i) {\n        if (eds[i].size() > beds[i].size()) {\n            cout << \"NO\\n\";\n            return 0;\n        }\n        while (eds[i].size() < beds[i].size()) {\n            beds[g].push_back(i);\n            eds[i].push_back(g);\n        }\n    }\n    dfs1(g);\n    for (int i = 2 * h; i < 2 * h + n; ++i) {\n        if (!was[i]) {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 505\nusing namespace std;\nint n,m,a[N],b[N],c[N],d[N],deg[M],f[M],vis[M],fr[M];\nvoid GG(){ printf(\"NO\"); exit(0);}\nint find(int x){ return f[x] ? f[x]=find(f[x]) : x;}\nint main()\n{\n\tint i,x,y;\n\tscanf(\"%d %d\",&n,&m),m=2*m+1;\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tif(c[i]!=0) x=2*c[i]+1; else x=2*a[i];\n\t\tif(d[i]!=0) y=2*d[i]; else y=2*b[i]+1;\n\t\tdeg[x]++,deg[y]--,vis[x]=vis[y]=1;\n\t\tif(find(x)!=find(y)) f[find(x)]=find(y);\n\t  }\n\tfor(i=1;i<=m;i++)\n\t\tif(deg[i]!=0){\n\t\t\tif(deg[i]>0&&(i&1)) GG();\n\t\t\tif(deg[i]<0&&(~i&1)) GG();\n\t\t  }\n\tfor(i=1;i<=m;i++)\n\t\tif(vis[i]&&deg[i]>0) fr[find(i)]++;\n\tfor(i=1;i<=m;i++)\n\t\tif(vis[i]&&find(i)==i&&!fr[i]) GG();\n\tprintf(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<b;++i)\n#define fj(a,b) for(int j=a;j<b;++j)\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> pii;\n///////////////////////\n\nint const N = 1e5 + 41;\nint const H = 241;\n\nint n, h, a[N], b[N], c[N], d[N];\nvector<pii> e[H][2];\nint pe[H][2], q;\npii v;\n\nvoid yes(){\n\tprintf(\"YES\\n\");\n\texit(0);\n}\n\npii getfrom(int a, int c){\n\tif(c == 0){\n\t\treturn mp(a, 1);\n\t}else{\n\t\treturn mp(c, 0);\n\t}\n}\n\npii getto(int a, int c){\n\tif(c == 0){\n\t\treturn mp(a, 0);\n\t}else{\n\t\treturn mp(c, 1);\n\t}\n}\n\nvoid dfs(pii x){\n\tv = x;\n\tint p = pe[x.first][x.second];\n\twhile(pe[x.first][x.second] < sz(e[x.first][x.second])){\n\t\tpii y = e[x.first][x.second][pe[x.first][x.second]];\n\t\t++pe[x.first][x.second];\n\t\t++q;\n\t\tdfs(y);\n\t}\n}\n\nvoid solve(){\n\tfi(0, n){\n\t\tpii x = getfrom(a[i], c[i]);\n\t\tpii y = getto(b[i], d[i]);\n\t\te[x.first][x.second].pb(y);\n\t}\n\tfi(1, h+1){\n\t\tmemset(pe, 0, sizeof(pe));\n\t\tq = 0;\n\t\tdfs(mp(i, 1));\n\t\tif(q == n && v.second == 0) yes();\n\t}\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\t\n\tscanf(\"%d %d\",&n,&h);\n\tfi(0, n){\n\t\tscanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\t}\n\n\tsolve();\n\n\tprintf(\"NO\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 100100;\n\nconst int maxH = 510;\n\nint n, H;\n\nint fa[maxH + 5];\n\nint deg[maxH + 5];\n\nbool vis[maxH + 5];\n\nint get(int x) { return fa[x] == x ? x : fa[x] = get(fa[x]); }\n\ninline void adde(int C, int D)\n{\n\tvis[C] = vis[D] = 1;\n\t++deg[C];\n\t--deg[D];\n\tfa[get(C)] = get(D);\n}\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d%d\", &n, &H);\n\t++H;\n\tREP(i, 0, H << 1) fa[i] = i;\n\tREP(i, 0, n)\n\t{\n\t\tint A, B, C, D;\n\t\tscanf(\"%d%d%d%d\", &A, &B, &C, &D);\n\t\tint x = -1, y = -1;\n\t\tif (!C) x = A << 1;\n\t\telse x = C << 1 | 1;\n\t\tif (!D) y = B << 1 | 1;\n\t\telse y = D << 1; \n\t\tadde(x, y);\n\t}\n\tbool failed = 0;\n\tREP(i, 0, H << 1) if (vis[i])\n\t{\n\t\tbool flag0 = 0, flag1 = 0;\n\t\tint sum = 0;\n\t\tREP(j, 0, H << 1) if (get(j) == get(i))\n\t\t{\n\t\t\tsum += deg[j];\n\t\t\tif (j & 1) flag0 = 1;\n\t\t\telse flag1 = 1;\n\t\t\tif (deg[j] > 0)\n\t\t\t{\n\t\t\t\tif (j & 1) { failed = 1; break; }\n\t\t\t}\n\t\t\tif (deg[j] < 0)\n\t\t\t{\n\t\t\t\tif (!(j & 1)) { failed = 1; break; }\n\t\t\t}\n\t\t}\n\t\tif (!flag0 || !flag1 || sum) { failed = 1; break; }\n\t}\n\tputs(failed ? \"NO\" : \"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=100100,M=440;\nint i,j,k,n,m,h,a,b,c,d,ch,ff;\nint degree[M],f[M],fg[M],z[M];\nstruct cc { int x,y;} A[N];\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nint getf(int x) {\n\tif (f[x]==x) return x;\n\treturn f[x]=getf(f[x]);\n}\nint main() {\n\tR(n);R(h);\n\tm=h+h;\n\tfor (i=1;i<=n;i++) {\n\t\tR(a);R(b);R(c);R(d);\n\t\tint x,y;\n\t\tif (c) x=h+c;\n\t\telse x=a;\n\t\tif (d) y=d;\n\t\telse y=h+b;\n\t\tA[i].x=x;A[i].y=y;\n\t\tdegree[x]++;\n\t\tdegree[y]--;\n\t\tz[x]=z[y]=1;\n\t}\n\tfor (i=1;i<=h;i++) if (degree[i]<0 || degree[h+i]>0) return puts(\"NO\"),0;\n\tfor (i=1;i<=m;i++) {\n\t\tf[i]=i;\n\t\tif (degree[i]) fg[i]=1;\n\t}\n\tfor (i=1;i<=n;i++) {\n\t\tint x=A[i].x,y=A[i].y;\n\t\tif (getf(x)!=getf(y)) {\n\t\t\tfg[f[y]]|=fg[f[x]];\n\t\t\tf[f[x]]=f[y];\n\t\t}\n\t}\n\tfor (i=1;i<=m;i++) if (z[i] && !fg[getf(i)]) return puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint l[205][205],r[205][205];\nint a[N],b[N],c[N],d[N];\nint n,m;\nbool L,R;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tif(c[i]==0)l[0][a[i]]++,L=true;\n\t\telse l[c[i]][201]++;\n\t\tif(d[i]==0)r[0][a[i]]++,R=true;\n\t\telse r[d[i]][201]++;\n\t}\n\tif(!L||!R){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tint k=0;\n\tfor(int i=1;i<=200;i++){\n\t\tif(l[0][i]!=r[i][201])k++;\n\t\tif(r[0][i]!=l[i][201])k++;\n\t}\n\tif(k==0||k==2)puts(\"YES\");\n\telse puts(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\n// clang-format off\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\ntemplate < class T > ostream &operator<<(ostream &o, const stack<T> &a) { o << \"{\"; for(auto tmp = a; tmp.size(); tmp.pop()) o << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top(); o << \"}\"; return o; }\ntemplate <class T, class Container, class Compare > ostream &operator<<(ostream &os, priority_queue<T, Container, Compare> a) { os << \"{ (top) \"; while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\ntemplate <class T, class Container > ostream &operator<<(ostream &os, queue<T, Container> a) { os << \"{ \"; while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n#define DEBUG_OUT cerr\n#endif\n#if !defined(DEBUG_LEFT)\n#define DEBUG_LEFT \"\\e[1;36m\"\n#endif\n#if !defined(DEBUG_RIGHT)\n#define DEBUG_RIGHT \":\\e[m\"\n#endif\n#define dump(...) [&](){auto __debug_tap=make_tuple(__VA_ARGS__);DEBUG_OUT<<DEBUG_LEFT<<__LINE__ << DEBUG_RIGHT << \" \" <<#__VA_ARGS__<<\" = \"<<__debug_tap<<endl;}()\ntemplate < class T > inline void dump2D(T &d, size_t sizey, size_t sizex) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << \"\\t\"; for(size_t j = 0; j < sizex; j++) DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\"); DEBUG_OUT << endl; } }\ntemplate < class T > inline void dump1D(T &d, size_t sizey) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \"); } DEBUG_OUT << endl; }\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { o << \"{\"; for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \", \") << *ite; o << \"}\"; return o; }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \" \") << *ite; return o; }\n#endif\n// clang-format on\n// }}}\n\n\n\nconst int H = 220;\nint in[H * 2];\nint out[H * 2];\nint n, h;\n\n#define POS(x) cout<<((x)?\"POSSIBLE\":\"IMPOSSIBLE\")<<endl;\n#define Pos(x) cout<<((x)?\"Possible\":\"Impossible\")<<endl;\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<endl;\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<endl;\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<endl;\n\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> h;\n  int a, b, c, d;\n  for(int i = 0; i < n; i++) {\n    cin >> a >> b >> c >> d;\n    int from = 0, to = 0;\n    if(c == 0) from = a;\n    else from = H + c;\n    if(d == 0) to = H + b;\n    else to = d;\n    out[from]++;\n    in[to]++;\n    dump(from, to);\n  }\n  int ok = 1;\n  int cnt1 = 0, cnt2 = 0;\n  for(int i = 0; i < H; i++) {\n    if(in[i] + out[i] == 0) continue;\n    dump(i, in[i], out[i]);\n    if(in[i] == out[i]);\n    else if(in[i] + 1 == out[i]) cnt1++;\n    else ok = 0;\n  }\n  for(int i = H; i < H * 2; i++) {\n    if(in[i] + out[i] == 0) continue;\n    dump(i, in[i], out[i]);\n    if(in[i] == out[i]);\n    else if(in[i] == out[i] + 1) cnt2++;\n    else ok = 0;\n  }\n  if(cnt1 != cnt2) ok = 0;\n  if(cnt1 < 1) ok = 0;\n  YES(ok);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline void read(int &x)\n{\n\tchar c=getchar();\n\tx=0;\n\twhile (c>'9'||c<'0')\n\t\tc=getchar();\n\twhile (c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n}\nconst int N=10005;\nint n,m,fa[N],v[N],f[N],g[N],x,y,a,b,c,d,flag;\ninline int gf(int x)\n{\n\treturn fa[x]==x?x:fa[x]=gf(fa[x]);\n}\nint main()\n{\n\tread(n);\n\tread(m);\n\tfor (int i=1;i<=1000;++i)\n\t\tfa[i]=i;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tread(a);\n\t\tread(b);\n\t\tread(c);\n\t\tread(d);\n\t\tif (c)\n\t\t\tx=500-c;\n\t\telse\n\t\t\tx=500+a;\n\t\tif (d)\n\t\t\ty=500+d;\n\t\telse\n\t\t\ty=500-b;\n\t\tfa[gf(x)]=gf(y);\n\t\t++f[x];\n\t\t--f[y];\n\t\tv[x]=1;\n\t}\n\tflag=1;\n\tfor (int i=1;i<500;++i)\n\t\tif (f[i]>0)\n\t\t\tflag=0;\n\tfor (int i=501;i<=1000;++i)\n\t\tif (f[i]<0)\n\t\t\tflag=0;\n\tfor (int i=1;i<=1000;++i)\n\t\tv[gf(i)]|=v[i];\n\tfor (int i=1;i<=1000;++i)\n\t\tif (f[i])\n\t\t\tg[gf(i)]=1;\n\tfor (int i=1;i<=1000;++i)\n\t\tif (fa[i]==i&&!g[i]&&v[i])\n\t\t\tflag=0;\n\tputs(flag?\"YES\":\"NO\");\n\treturn 0;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 101000\n#define M 510\nusing namespace std;\nint n,m,rd[M],cd[M],tot=0;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n)\n\t{\n\t\tint a,b,c,d,x,y;scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0) x=a+m;\n\t\telse x=c;\n\t\tif(d==0) y=b;\n\t\telse y=d+m;\n\t\trd[y]++;cd[x]--;\n\t}\n\tint q=0,w=0;\n\tfo(i,1,m)\n\t{\n\t\tif(rd[i]<cd[i]) q++;\n\t\tif(rd[i]>cd[i]) w++;\n\t}\n\tif(q>0||w==0) return printf(\"NO\\n\"),0;\n\tq=0,w=0;\n\tfo(i,m+1,m+m)\n\t{\n\t\tif(rd[i]>cd[i]) q++;\n\t\tif(rd[i]<cd[i]) w++;\n\t}\n\tif(q>0||w==0) return printf(\"NO\\n\"),0;\n\tq=0,w=0;\n\tfo(i,1,m) if(rd[i]>cd[i]) w++;\n\tfo(i,m+1,m+m) if(rd[i]<cd[i]) q++;\n\tif(q!=w) return printf(\"NO\\n\"),0;\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\nconst int N=405;\n\nint n,h,a,b,c,d,in[N],out[N],f[N];\nbool ok[N],vis[N];\n\nint get(int x) {return f[x]?f[x]=get(f[x]):x;}\n\nvoid merge(int x,int y) {\n\tx=get(x);y=get(y);\n\tif (x==y) return;\n\tf[y]=x;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&h);\n\tfo(i,1,n) {\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint l=c?-c:a;l+=h;\n\t\tint r=d?d:-b;r+=h;\n\t\tin[r]++;out[l]++;\n\t\tvis[l]=vis[r]=1;\n\t\tmerge(l,r);\n\t}\n\tfo(i,h+1,h*2) if (in[i]>out[i]) {puts(\"NO\");return 0;}\n\tfo(i,0,h-1) if (in[i]<out[i]) {puts(\"NO\");return 0;}\n\tfo(i,0,h*2) ok[get(i)]|=(in[i]!=out[i]);\n\tfo(i,0,h*2) if (vis[i]&&get(i)==i&&!ok[i]) {puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=205,INF=1<<30;\nint cnt[MAX][2];\nbool seen[MAX][2],check[MAX][2];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,H;cin>>N>>H;\n    \n    for(int i=0;i<N;i++){\n        int a,b,c,d;cin>>a>>b>>c>>d;\n        if(c==0){\n            cnt[a][0]++;\n            seen[a][0]=1;\n            \n            if(d==0){\n                cnt[b][1]--;\n                seen[b][1]=1;\n                \n                check[a][0]=1;\n                check[b][1]=1;\n            }\n            else{\n                cnt[d][0]--;\n                seen[d][0]=1;\n            }\n        }else{\n            cnt[c][1]++;\n            seen[c][1]=1;\n            \n            if(d==0){\n                cnt[b][1]--;\n                seen[b][1]=1;\n            }\n            else{\n                cnt[d][0]--;\n                seen[d][0]=1;\n                \n                check[c][1]=1;\n                check[d][0]=1;\n            }\n        }\n    }\n    \n    int sum1=0,sum2=0;\n    bool ok=true;\n    \n    for(int i=0;i<=H;i++){\n        sum1+=cnt[i][0];\n        sum2+=cnt[i][1];\n        \n        if(cnt[i][0]<0) ok=false;\n        if(cnt[i][1]>0) ok=false;\n        \n        if(cnt[i][0]==0&&seen[i][0]&&!check[i][0]) ok=false;\n        if(cnt[i][1]==0&&seen[i][1]&&!check[i][1]) ok=false;\n    }\n    \n    if(sum1>sum2&&ok) cout<<\"YES\\n\";\n    else cout<<\"NO\\n\";\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "//此程序使用了qt专属名称，请勿模仿。侵权必究！！！\n//我真是太菜了啊……\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=410;\nint n,m,fa[N],in[N],out[N];\nbool v[N];\ninline int read()\n{\n\tint sum=0,flag=1; char c;\n\tfor(;c<'0'||c>'9';c=getchar()) if(c=='-') flag=-1;\n\tfor(;c>='0'&&c<='9';c=getchar()) sum=(sum<<3)+(sum<<1)+c-'0';\n\treturn sum*flag;\n}\ninline int getfa(int x)\n{\n\tif(fa[x]^x) fa[x]=getfa(fa[x]);\n\treturn fa[x];\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1;i<=m*2;++i) fa[i]=i;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint a=read(),b=read(),c=read(),d=read(),x,y;\n\t\tif(c) x=m-c; else x=m+a;\n\t\tif(d) y=m+d; else y=m-b;\n\t\t++in[y],++out[x];\n\t\tfa[getfa(x)]=getfa(y);\n\t}\n\tfor(int i=1;i<=m;++i) if(in[i]<out[i]) {puts(\"NO\"); return 0;}\n\tfor(int i=m+1;i<=m*2;++i) if(in[i]>out[i]) {puts(\"NO\"); return 0;}\n\tfor(int i=1;i<=m*2;++i) v[getfa(i)]|=(in[i]^out[i])||(in[i]==0&&out[i]==0);\n\tfor(int i=1;i<=m*2;++i) if((fa[i]==i)&&(!v[i])&&(i^m)) {puts(\"NO\"); return 0;}\n\tputs(\"YES\"); return 0; \n}"
  },
  {
    "language": "C++",
    "code": "//AtCoder Grand Contest 017 E - Jigsaw\n\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint qr(){int ret = 0,f=1;char ch =getchar();while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();return ret*f;}\n\n#define maxN 100005\n#define maxH 205\n\nint indegree[maxH<<2],outdegree[maxH<<2];\nint active[maxH<<2];\nvoid read(int x,int y){\n    indegree[y]++;\n    outdegree[x]++;\n}\nint f[maxH<<1],pd[maxH<<1];\nvoid init(){\n    for(int i = 1;i<=(maxH<<1);i++)\n        f[i] = i;\n}\nint gf(int x){\n    if(f[x] == x) return x;\n    else return f[x] = gf(f[x]);\n}\nint mer(int x,int y){\n    x = gf(x);y = gf(y);\n    if(x == y) return 0;\n    f[x] = y;\n    return 1;\n}\nint main(){\n    init();\n    int N = qr(),H = qr();\n    int NN = 0;\n    int t1,t2,t3,t4,t5,t6;//上 t + maxN 下 t + maxN + maxH\n    for(int i = 1;i<=N;i++){\n        t1 = qr(),t2 = qr(),t3 = qr(),t4 = qr();\n        if(!t3) t5 = t1;else t5 = -t3;\n        if(!t4) t6 = -t2;else t6 = t4;\n        t5 += H,t6 += H;\n        indegree[t6]++;outdegree[t5]++;\n        active[t5] = active[t6] = 1;\n        f[gf(t5)] = gf(t6);\n    }\n    int mark=1;\n    for(int i = 0;i<=H;i++){\n        if(indegree[i]<outdegree[i])\n            mark=0;\n    }\n    for(int i = H+1;i<=(H<<1);++i){\n        if(indegree[H+i]>outdegree[H+i])\n            mark=0;\n    }\n    for(int i = 0;i<=(H<<1);i++){\n        pd[gf(i)] |= (indegree[i] != outdegree[i]);\n    }\n    pd[H] = 1;\n    for(int i = 1;i<=(H<<1);i++){\n        if(active[i] && !pd[gf(i)])\n            mark=0;\n    }\n    if(mark)\n        cout << \"YES\";\n    else cout << \"NO\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nconst int maxnode=2000000+16;\n\nvector<int> g[maxnode];\nbool v[maxnode];\nint d[maxnode];\n\nvoid dfs(int p)\n{\n\tif (v[p]) return;\n\tv[p]=true;\n\tfor (int x:g[p]) dfs(x);\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint n,h;\n\twhile (cin>>n>>h && n>0)\n\t{\n\t\t//h+=2;\n\t\th=(maxnode-16)/4;\n\t\tvector<ipair> edges;\n\t\tREP(i,n)\n\t\t{\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tint s=((c==0)?(a+h):c);\n\t\t\tint t=((d==0)?b:(d+h));\n\t\t\tedges.emplace_back(s,t);\n\t\t}\n\t\tbool ok=true;\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.first].push_back(e.second);\n\t\tFOR(i,h,h+h) dfs(i);\n\t\tfor (auto e:edges) if (!v[e.first]) ok=false;\n\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.second].push_back(e.first);\n\t\tREP(i,h) dfs(i);\n\t\tfor (auto e:edges) if (!v[e.second]) ok=false;\n\n\t\tREP(i,h+h) d[i]=0;\n\t\tfor (auto e:edges) ++d[e.first],--d[e.second];\n\t\tREP(i,h) if (d[i]>0) ok=false;\n\t\tFOR(i,h,h+h) if (d[i]<0) ok=false;\n\n\t\tif (ok)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\ninline int read(){\n\tint n=0,f=1;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif (c=='-') c=getchar(),f=-1;\n\tfor(;c>='0'&&c<='9';c=getchar()) n=n*10+c-48;\n\treturn n*f;\n}\nconst int maxn=400+5;\nint n,i,h,A,B,C,D,d[maxn],f[maxn];\nbool b[maxn],bz[maxn];\nint get(int x){return (f[x])?f[x]=get(f[x]):x;}\nvoid hb(int x,int y){\n\tx=get(x),y=get(y);\n\tif (x!=y) f[x]=y;\n}\nint main(){\n\tn=read(),h=read()+1;\t\n\tfor(;n--;){\n\t\tA=read(),B=read(),C=read(),D=read();\n\t\tint l=(C)?-C:A,r=(D)?D:-B;\n\t\tl+=h,r+=h;\n\t\td[l]--,d[r]++; \n\t\tb[l]=b[r]=1,hb(l,r);\n\t}\n\tfo(i,1,h-1) if (d[i]<0) return puts(\"NO\"),0;\n\tfo(i,h+1,h<<1) if (d[i]>0) return puts(\"NO\"),0;\n\tfo(i,1,h<<1) if (d[i]) bz[get(i)]=1;\n\tfo(i,1,h<<1) if (b[i]&&!f[i]&&!bz[i]) return puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nnamespace io\n{\n\tconst int N=1<<20;\n\tchar buf[N],*t1=buf,*t2=buf;\n\t#ifdef cjy\n\t#define getc() getchar()\n\t#else\n\t#define getc() t1==t2&&(t2=(t1=buf)+fread(buf,1,N,stdin),t1==t2)?EOF:*t1++\n\t#endif\n\tinline int read()\n\t{\n\t\tstatic int an,f;an=0,f=1;\n\t\tstatic char ch;ch=getc();\n\t\twhile(ch<48||ch>57)ch=='-'?f=-1:0,ch=getc();\n\t\twhile(ch>=48&&ch<=57)an=(an<<3)+(an<<1)+(ch^48),ch=getc();\n\t\treturn an*f;\n\t}\n\tchar buff[N],*T=buff;\n\tvoid flush(){fwrite(buff,1,T-buff,stdout);T=buff;}\n\tinline void putc(char ch){if(T==buff+N)flush();*T++=ch;}\n\ttemplate<typename o>\n\tinline void print(o x)\n\t{\n\t\tif(x<0)putc('-'),x=-x;\n\t\tif(!x)return putc('0'),void();\n\t\tstatic int st[20],tp;\n\t\twhile(x)st[++tp]=x%10,x/=10;\n\t\twhile(tp)putc(st[tp]^48),--tp;\n\t}\n}\nusing io::read;\nusing io::putc;\nusing io::flush;\nusing io::print;\nstruct edge\n{\n\tint nxt,to;\n}e[100010];\nint n,h,head[500],num,dg[500];\ninline void add(int from,int to){e[++num]=edge{head[from],to};head[from]=num;++dg[from],--dg[to];}\nbool vis[500];\nint main()\n{\n\tn=read(),h=read();\n\tfor(int i=1,a,b,c,d,x,y;i<=n;++i)\n\t{\n\t\ta=read(),b=read(),c=read(),d=read();\n\t\tif(c==0)x=a;\n\t\telse x=c+h;\n\t\tif(d==0)y=b+h;\n\t\telse y=d;\n\t\tadd(x,y);\n\t}\n\tfor(int i=1;i<=h;++i)if(dg[i]<0)return printf(\"NO\"),0;\n\tfor(int i=h+1;i<=2*h;++i)if(dg[i]>0)return printf(\"NO\"),0;\n\tqueue<int>q;\n\tfor(int i=1;i<=h;++i)if(dg[i]>0)q.push(i);\n\tint cnt=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t//\tprintf(\"%d\\n\",x);\n\t\tif(vis[x])continue;\n\t\tvis[x]=1;\n\t\tfor(int i=head[x],y;i;i=e[i].nxt)y=e[i].to,++cnt,q.push(y);\n\t}\n\tif(cnt==n)printf(\"YES\");\n\telse printf(\"NO\");\n\tflush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nint n,h;\nint l[220],r[220],bns,fa[220],siz[220],L,R;\nint find(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=200;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0)l[a]++,bns++,L=a;\n\t\telse r[c]--,bns--,L=a;\n\t\tif(d==0)r[b]++,bns++,R=b;\n\t\telse l[d]--,bns--,R=d;\n\t\tif(find(L)==find(R)){\n\t\t\tsiz[find(L)]++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tsiz[find(R)]+=siz[find(L)]+1;\n\t\tsiz[find(L)]=0;\n\t\tfa[find(L)]=find(R);\n\t}\n\tint ans=0,cns=0;\n\tfor(int i=1;i<=200;i++){\n\t\tans+=l[i];\n\t\tans+=r[i];\n\t\tif(l[i]<0||r[i]<0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(l[i]||r[i])cns+=siz[find(i)],siz[find(i)]=0;\n\t//\tsiz[find(i)]=0;\n\t}\n\tif(bns<=0||ans!=bns||cns!=n){\n\t\tprintf(\"NO\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\nstruct UnionFind {vector<int> par, cnt;\n    UnionFind(int NV) { par.clear(); cnt.resize(NV, 1); rep(i, 0, NV) par.push_back(i); }\n    void reset() { rep(i, 0, cnt.size()) cnt[i] = 1; rep(i, 0, par.size()) par[i] = i; }\n    int operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n    void operator()(int x, int y) {x = operator[](x); y = operator[](y);\n        if (x != y) par[x] = y, cnt[y] += cnt[x];}};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n \n \n\n\n#define NO \"NO\"\n#define YES \"YES\"\nint N, H;\nint L[101010], R[101010];\nint in[505], ou[505];\nint used[505];\nUnionFind uf(505);\n//---------------------------------------------------------------------------------------------------\nstring solve() {\n    cin >> N >> H;\n\n    // make_edge\n    rep(i, 0, N) {\n        int a, b, c, d; cin >> a >> b >> c >> d;\n\n        int l;\n        if (0 < c) l = -c;\n        else l = a;\n\n        int r;\n        if (0 < d) r = d;\n        else r = -b;\n\n        l += 250, r += 250;\n\n        L[i] = l, R[i] = r;\n    }\n\n    // in/out check\n    rep(i, 0, N) {\n        int l = L[i], r = R[i];\n        ou[l]++; in[r]++;\n    }\n    rep(i, 0, 505) {\n        int x = i - 250;\n        if (0 < x) if (ou[i] < in[i]) return NO;\n        if (x < 0) if (in[i] < ou[i]) return NO;\n    }\n\n    // cycle check\n    rep(i, 0, 505) {\n        int x = i - 250;\n        if (0 < x) if (ou[i] > in[i]) uf(500, i);\n        if (x < 0) if (in[i] > ou[i]) uf(500, i);\n    }\n    rep(i, 0, N) {\n        int l = L[i], r = R[i];\n\n        used[l] = used[r] = 1;\n        uf(l, r);\n    }\n    rep(i, 0, 505) if (used[i]) if (uf[i] != uf[500]) return NO;\n\n    return YES;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 409\n#define M 200009\nusing namespace std;\n\nint n,m,sz1,sz2,tot,fst[N],pnt[M],nxt[M],f[M],g[M]; bool vis[N];\nvoid add(int x,int y){\n\tpnt[++tot]=y; nxt[tot]=fst[x]; fst[x]=tot;\n}\nvoid ins(int x,int y){\n\tadd(x,y); add(y,x); f[y]++; g[x]++;\n}\nvoid dfs(int x){\n\tvis[x]=1; if (!f[x] && !g[x]) return;\n\tint i,y;  sz1+=(x<=n); sz2+=(x>n);\n\tif (x>n && f[x]<g[x] || x<=n && f[x]>g[x]){\n\t\tputs(\"NO\"); exit(0);\n\t}\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];\n\t\tif (!vis[y]) dfs(y);\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&m,&n);\n\tint i,x,y,u,v;\n\twhile (m--){\n\t\tscanf(\"%d%d%d%d\",&x,&y,&u,&v);\n\t\tins(u?u+n:x,v?v:y+n);\n\t}\n\tfor (i=1; i<=(n<<1); i++) if (!vis[i] && f[i]+g[i]){\n\t\tsz1=sz2=0; dfs(i);\n\t\tif (!sz1 || !sz2){ puts(\"NO\"); return 0; }\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct MaxFlowDinic {\n    typedef int flow_t;\n    struct Edge {\n        int next;\n        size_t inv; /* inverse edge index */\n        flow_t res; /* residual */\n    };\n    int n;\n    vector<vector<Edge>> graph;\n    vector<int> q, l, start;\n    void init(int _n) {\n        n = _n;\n        graph.resize(n);\n        for (int i = 0; i < n; i++) graph[i].clear();\n    }\n    void add_edge(int s, int e, flow_t cap, flow_t caprev = 0) {\n        Edge forward{ e, graph[e].size(), cap };\n        Edge reverse{ s, graph[s].size(), caprev };\n        graph[s].push_back(forward);\n        graph[e].push_back(reverse);\n    }\n    bool assign_level(int source, int sink) {\n        int t = 0;\n        memset(&l[0], 0, sizeof(l[0]) * l.size());\n        l[source] = 1;\n        q[t++] = source;\n        for (int h = 0; h < t && !l[sink]; h++) {\n            int cur = q[h];\n            for (const auto& e : graph[cur]) {\n                if (l[e.next] || e.res == 0) continue;\n                l[e.next] = l[cur] + 1;\n                q[t++] = e.next;\n            }\n        }\n        return l[sink] != 0;\n    }\n    flow_t block_flow(int cur, int sink, flow_t current) {\n        if (cur == sink) return current;\n        for (int& i = start[cur]; i < graph[cur].size(); i++) {\n            auto& e = graph[cur][i];\n            if (e.res == 0 || l[e.next] != l[cur] + 1) continue;\n            if (flow_t res = block_flow(e.next, sink, min(e.res, current))) {\n                e.res -= res;\n                graph[e.next][e.inv].res += res;\n                return res;\n            }\n        }\n        return 0;\n    }\n    flow_t solve(int source, int sink) {\n        q.resize(n);\n        l.resize(n);\n        start.resize(n);\n        flow_t ans = 0;\n        while (assign_level(source, sink)) {\n            memset(&start[0], 0, sizeof(start[0]) * n);\n            while (flow_t flow = block_flow(source, sink, numeric_limits <flow_t\n                        >::max()))\n                ans += flow;\n        }\n        return ans;\n    }\n};\n\nstruct MaxFlowEdgeDemands\n{\n    MaxFlowDinic mf;\n    using flow_t = MaxFlowDinic::flow_t;\n    vector<flow_t> ind, outd;\n    flow_t D; int n;\n    void init(int _n) {\n        n = _n; D = 0; mf.init(n + 2);\n        ind.clear(); outd.clear();\n        ind.resize(n, 0); outd.resize(n, 0);\n    }\n    void add_edge(int s, int e, flow_t cap, flow_t demands = 0) {\n        mf.add_edge(s, e, cap - demands);\n        D += demands; ind[e] += demands; outd[s] += demands;\n    }\n    // returns { false, 0 } if infeasible\n    // { true, maxflow } if feasible\n    pair<bool, flow_t> solve(int source, int sink) {\n        mf.add_edge(sink, source, numeric_limits <flow_t >::max());\n        for (int i = 0; i < n; i++) {\n            if (ind[i]) mf.add_edge(n, i, ind[i]);\n            if (outd[i]) mf.add_edge(i, n + 1, outd[i]);\n        }\n        if (mf.solve(n, n + 1) != D) return{ false, 0 };\n        for (int i = 0; i < n; i++) {\n            if (ind[i]) mf.graph[i].pop_back();\n            if (outd[i]) mf.graph[i].pop_back();\n        }\n        return{ true, mf.solve(source, sink) };\n    }\n};\n\nint lbottom(int t)\n{\n    return t;\n}\n\nint lup(int t)\n{\n    return 200 + t;\n}\n\nint rbottom(int t)\n{\n    return 400 + t;\n}\n\nint rup(int t)\n{\n    return 600 + t;\n}\n\nint next_blk(int t)\n{\n    if (t > 400 && t <= 600) return lup(t - 400);\n    else return lbottom(t - 600);\n}\n\nbool loop[444];\nbool edge[444];\nint x[444][444];\n\nint main()\n{\n    int n, h;\n    scanf(\"%d%d\",&n,&h);\n    MaxFlowEdgeDemands mf;\n    mf.init(402);\n    for (int i = 0; i < n; i++)\n    {\n        int a, b, c, d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\n        int lidx, ridx;\n\n        if (c == 0) lidx = lbottom(a);\n        else lidx = lup(c);\n\n        if (d == 0) ridx = rbottom(b);\n        else ridx = rup(d);\n\n        ridx = next_blk(ridx);\n\n        if (lidx == ridx) loop[lidx] = true;\n        else\n        {\n            x[lidx][ridx]++;\n            edge[lidx] = edge[ridx] = true;\n        }\n    }\n    for (int i = 1; i <= 400; i++) if (loop[i] && !edge[i]) return !printf(\"NO\\n\");\n    for (int i = 1; i <= 400; i++)\n    {\n        for (int j = 1; j <= 400; j++)\n        {\n            if (x[i][j] > x[j][i]) mf.add_edge(i, j, x[i][j] - x[j][i], x[i][j] - x[j][i]);\n        }\n    }\n    for (int i = 1; i <= 200; i++) mf.add_edge(0, i, 1e9);\n    for (int i = 201; i <= 400; i++) mf.add_edge(i, 401, 1e9);\n    if (mf.solve(0, 401).first) printf(\"YES\\n\");\n    else printf(\"NO\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=410;\nint n,h,in[N],out[N];\nint fa[N];\nbool ok[N];\n\nint find(const int &x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\nint main()\n{\n    n=read();h=read();\n    for(int i=1;i<=(h<<1);i++) fa[i]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int A=read(),B=read(),C=read(),D=read();\n        int x=C?C+h:A,y=D?D:B+h;\n        out[x]++;in[y]++;\n        x=find(x);y=find(y);\n        if(x!=y) fa[x]=y;\n    }\n    for(int i=1;i<=h;i++) if(in[i]>out[i]) return !puts(\"NO\");\n    for(int i=h+1;i<=(h<<1);i++) if(in[i]<out[i]) return !puts(\"NO\");\n    for(int i=1;i<=(h<<1);i++) if(in[i]!=out[i]||!in[i]&&!out[i]) ok[find(i)]=1;\n    for(int i=1;i<=(h<<1);i++) if(fa[i]==i&&!ok[i]) return !puts(\"NO\");\n    return !puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconst int maxn = 100000+7;\n\nint n, h, a, b, c, d;\nint left[maxn], right[maxn];\n\nint main(int argc, char *argv[]) {  \n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0); \n\tstd::fill(left, left+maxn, 0);\n\tstd::fill(right, right+maxn, 0);\n\tstd::cin >> n >> h;\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> a >> b >> c >> d;\n\t\tif (c == 0) {\n\t\t\tleft[a]++;\n\t\t} else {\n\t\t\tright[c]--;\n\t\t}\n\t\tif (d == 0) {\n\t\t\tright[b]++;\n\t\t} else {\n\t\t\tleft[d]--;\n\t\t}\n\t}\n\tbool yes = 1;\n\tint cnt = 0;\n\tfor (int i = 1; i <= h; i++) {\n\t\tif (right[i] < 0 || left[i] < 0) {\n\t\t\tyes = 0;\n\t\t}\n//\t\tstd::cout << left[i] << ' ' << right[i] << '\\n';\n\t\tcnt += left[i];\n\t\tcnt += right[i];\n\t}\n//\tstd::cout << cnt << '\\n';\n\tif (yes && cnt > 0) {\n\t\tstd::cout << \"YES\\n\";\n\t} else {\n\t\tstd::cout << \"NO\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\n\nconst int maxn = 410000;\n\nint n,m=800;\n\nint fa[maxn];\nint findfa(const int x){return fa[x]==x?x:fa[x]=findfa(fa[x]);}\n\nint d[maxn],v[maxn],ok[maxn];\n\nint main()\n{\n\tscanf(\"%d%*d\",&n);\n\tfor(int i=1;i<m;i++) fa[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c,D,l,r; scanf(\"%d%d%d%d\",&a,&b,&c,&D);\n\t\tl=!c?a:-c;\n\t\tr=!D?-b:D;\n\t\tl+=400,r+=400;\n\t\td[l]++,d[r]--; v[l]=v[r]=1;\n\t\tfa[findfa(l)]=findfa(r);\n\t}\n\tfor(int i=1;i<=400;i++) if(d[i]>0) return puts(\"NO\"),0;\n\tfor(int i=400;i<m;i++)  if(d[i]<0) return puts(\"NO\"),0;\n\t\n\tfor(int i=1;i<m;i++) if(d[i]) ok[findfa(i)]=1;\n\tfor(int i=1;i<m;i++) v[findfa(i)]|=v[i];\n\t\n\tfor(int i=1;i<m;i++) if(i==findfa(i)&&v[i]&&!ok[i]) \n\t\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nint IN[1100];\nint OUT[1100];\nint UF[1100];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint oo[1100];\nint ii[1100];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b*2+1;i++)UF[i]=-1;\n\tfor(int i=0;i<a;i++){\n\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tint fr=-r;\n\t\tint to=-s;\n\t\tif(r==0)fr=p;\n\t\tif(s==0)to=q;\n\t\tto*=-1;\n\t\tIN[fr+b]++;\n\t\tOUT[to+b]++;\n\t\tUNION(fr+b,to+b);\n\t}\n\tfor(int i=0;i<2*b;i++){\n\t\tif(IN[i]>OUT[i]&&i-b<0){printf(\"NO\\n\");return 0;}\n\t\tif(IN[i]<OUT[i]&&i-b>0){printf(\"NO\\n\");return 0;}\n\t}\n\tfor(int i=1;i<=b;i++){\n\t\tif(IN[i+b]>OUT[i+b]){\n\t\t\too[FIND(i+b)]++;\n\t\t}\n\t\tif(IN[-i+b]<OUT[-i+b]){\n\t\t\tii[FIND(-i+b)]++;\n\t\t}\n\t}\n\tfor(int i=1;i<=b;i++){\n\t\tif(IN[i+b]+OUT[i+b]&&(oo[FIND(i+b)]==0||ii[FIND(i+b)]==0)){printf(\"NO\\n\");return 0;}\n\t\tif(IN[-i+b]+OUT[-i+b]&&(oo[FIND(-i+b)]==0||ii[FIND(-i+b)]==0)){printf(\"NO\\n\");return 0;}\n\t\t\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\nint h;\n\n#define MAXX 202\nint lef[MAXX];\nint rig[MAXX];\n\nint deg[MAXX*2];\n\nvector<int> v[MAXX*2];\n\nint belong[MAXX * 2];\ninline int root(int b){\n\tif (belong[b] == -1){\n\t\treturn b;\n\n\t}\n\tbelong[b] = root(belong[b]);\n\treturn belong[b];\n}\nvoid merge(int a, int b){\n\ta = root(a);\n\tb = root(b);\n\tif (a == b){\n\t\treturn;\n\t}\n\tbelong[a] = b;\n}\nmap<int, vector<int> > mp;\n\nbool ava[MAXX*2];\n\nbool check(vector<int> vv){\n\tbool ng = false;\n\tint restr = 0;\n\tint restl = 0;\n\tint id = -1;\n\tint id2 = -1;\n\tfor (int ii = 0; ii <vv.size();ii++){\n\t\tint ix = vv[ii];\n\t\tif (ix & 1){\n\t\t\tint i = ix / 2;\n\t\t\tif (deg[rig[i]] >= 0){\n\t\t\t\trestr += deg[rig[i]];\n\t\t\t\tif (deg[rig[i]]){\n\t\t\t\t\tid = rig[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tng = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint i = ix / 2;\n\t\t\tif ( deg[lef[i]] <= 0){\n\t\t\t\trestl += -deg[lef[i]];\n\t\t\t\tif (deg[lef[i]] < 0){\n\t\t\t\t\tid2 = lef[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tng = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (restr == 0 || restl == 0){\n\t\treturn false;\n\t}\n\tif (ng){\n\t\treturn false;\n\t}\n\tif (restr == 1 && restl == 1 && v[id].size() == 1 && v[id2].size() == 1 && v[id][0] == v[id2][0]){\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main(){\n\tmemset(belong, -1, sizeof(belong));\n\tfor (int i = 0; i < MAXX; i++){\n\t\tlef[i] = 2 * i;\n\t\trig[i] = lef[i] + 1;\n\t}\n\tcin >> n >> h;\n\tfor (int i = 0; i < n; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint k;\n\t\tif (c){\n\t\t\tdeg[lef[c]]++;\n\t\t\tk = lef[c];\n\t\t\tava[lef[c]] = true;\n\t\t}\n\t\telse{\n\t\t\tdeg[rig[a]]++;\n\t\t\tv[rig[a]].push_back(i);\n\t\t\tk = rig[a];\n\t\t\tava[rig[a]] = true;\n\t\t}\n\t\tif (d){\n\t\t\tdeg[rig[d]]--;\n\t\t\tmerge(k, rig[d]);\n\t\t\tava[rig[d]] = true;\n\t\t}\n\t\telse{\n\t\t\tdeg[lef[b]]--;\n\t\t\tv[lef[b]].push_back(i);\n\t\t\tmerge(k, lef[b]);\n\t\t\tava[lef[b]] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAXX; i++){\n\t\tif(ava[i])mp[root(i)].push_back(i);\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); it++){\n\t\tif (check((*it).second) == false){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 100003;\nstatic const int MAXH = 209;\n\nstatic const int MAXV = MAXH * 2;\nstatic const int MAXE = 1e6 + 10;\n\nint n, h;\nint head[MAXV], dest[MAXE], next[MAXE];\nbool vis[MAXE] = { false };\n\nint m = 0;\nint in[MAXV] = { 0 }, out[MAXV] = { 0 };\n\ninline void add_edge(int u, int v)\n{\n    dest[m] = v; next[m] = head[u]; head[u] = m++;\n    ++out[u], ++in[v];\n}\n\nint cur[MAXV];\n\nvoid dfs(int u)\n{\n    for (int &w = cur[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs(dest[w]);\n    }\n}\n\nstd::vector<int> as, bs;\nbool marked[MAXV] = { false };\n\nint main()\n{\n    scanf(\"%d%d\", &n, &h);\n\n    int verts = (h + 1) * 2;\n    for (int i = 0; i < verts; ++i) head[i] = -1;\n\n#define node_a(_h) ((_h) * 2)\n#define node_b(_h) ((_h) * 2 + 1)\n    for (int i = 0, a, b, c, d; i < n; ++i) {\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        int u, v;\n        u = (c == 0 ? node_b(a) : node_a(c));\n        v = (d == 0 ? node_a(b) : node_b(d));\n        add_edge(u, v);\n    }\n    for (int i = 0; i <= h; ++i) {\n        if (in[node_a(i)] < out[node_a(i)]) { puts(\"NO\"); return 0; }\n        if (in[node_b(i)] > out[node_b(i)]) { puts(\"NO\"); return 0; }\n        for (int r = 0; r < in[node_a(i)] - out[node_a(i)]; ++r) {\n            as.push_back(node_a(i));\n            marked[node_a(i)] = true;\n        }\n        for (int r = 0; r < out[node_b(i)] - in[node_b(i)]; ++r) {\n            bs.push_back(node_b(i));\n            marked[node_b(i)] = true;\n        }\n    }\n    for (int u : as) {\n        if (bs.empty()) { puts(\"NO\"); return 0; }\n        add_edge(u, bs.back());\n        bs.pop_back();\n    }\n\n    for (int i = 0; i < verts; ++i) cur[i] = head[i];\n    for (int i = 0; i < verts; ++i) if (marked[i]) dfs(i);\n    for (int i = 0; i < m; ++i) if (!vis[i]) { puts(\"NO\"); return 0; }\n    puts(\"YES\"); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nstruct edge{\n\tint k,w,next;\n}e[1000005];\nstruct P{\n\tint a,b,c,d;\n}a[100005];\nint n,h,home[805],cnt=-1,T,IN[805],du[805];\nvoid add(int x,int y,int w){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].w=w;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid insert(int x,int y,int w){\n\tadd(x,y,w);add(y,x,0);\n}\nint q[805],d[805];\nvoid bfs(int S){\n\tmemset(d,-1,sizeof(d));\n\tint tou=0,wei=1,k;\n\tq[0]=S;d[S]=0;\n\twhile(tou<wei){\n\t\tk=q[tou++];\n\t\tfor(int i=home[k];~i;i=e[i].next) if(d[e[i].k]==-1&&e[i].w){\n\t\t\td[e[i].k]=d[k]+1;\n\t\t\tq[wei++]=e[i].k;\n\t\t}\n\t}\n}\nint dfs(int k,int flow,int T){\n\tif(k==T||!flow) return flow;\n\tint w,used=0;\n\tfor(int i=home[k];~i;i=e[i].next)if(d[e[i].k]==d[k]+1){\n\t\tw=flow-used;\n\t\tw=dfs(e[i].k,min(w,e[i].w),T);\n\t\tused+=w;\n\t\te[i].w-=w;\n\t\te[i^1].w+=w;\n\t}\n\tif(used<flow) d[k]=-1;\n\treturn used;\n}\nint dinic(int S,int T){\n\tint flow=0;\n\twhile(1){\n\t\tbfs(S);\n\t\tif(d[T]==-1) return flow;\n\t\tflow+=dfs(S,1e9,T);\n\t}\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d%d\",&n,&h);\n\tT=h*4+2;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a[i].a,&a[i].b,&a[i].c,&a[i].d);\n\t\tint x=(a[i].c?h+a[i].c:a[i].a)+1,y=(a[i].d?h+a[i].d:a[i].b)+h+h+1,z=(a[i].d?a[i].d:h+a[i].b)+1;\n\t\tIN[y]++;IN[x]--;\n\t\tinsert(y,z,1);\n\t\tif(a[i].c==0){\n\t\t\tdu[x]++;\n\t\t}\n\t\tif(a[i].d==0){\n\t\t\tdu[y]++;\n\t\t}\n\t}\n\tfor(int i=2;i<=h+h+1;i++) if(du[i]) insert(1,i,du[i]);\n\tfor(int i=h+h+2;i<T;i++) if(du[i]) insert(i,T,du[i]);\n\tinsert(T,1,1e9);\n\tT++;\n\tfor(int i=1;i<T;i++) if(IN[i]){\n\t\tif(IN[i]>0) insert(0,i,IN[i]);\n\t\telse insert(i,T,-IN[i]);\n\t}\n\tint ans=dinic(0,T);\n\tif(ans<n) puts(\"NO\");\n\telse{\n\t\tfor(int i=home[1];~i;i=e[i].next) if(e[i].k==T-1) ans=e[i].w;\n\t\tif(!ans) puts(\"NO\");\n\t\telse puts(\"YES\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Azat Ismagilov\n */\n\n/**********.*****.**************************:-******-:*******************\n**********......:*****************+@%@*+#@@@+.****.***********************\n...------........-*+*********+%#####@@@##########*************************\n********:........----------%@#####################@@-...............------\n**********......:********@%#####@###################@#@=+***************::\n*********.:****--******%##@#####@#######################@*+***************\n********.*******:-**+@@####@#@@@#################@#########=**************\n*******-*********:*@@@######@###############################=*************\n*****--**********%%@##@########@#############################=:***********\n****.************+##################@#@@#####################@************\n***.*************%######################@@###################=***********-\n*-:**************=##########@@%%%%=%@=%=%=%@################@@**********.*\n.****************########%++***+++****+++=+===+++***+=%@######%*******:-**\n****************+#######%+*::::::::::::***********:::::**@@###%******.:***\n****************#######@%*:::::::::::::::*:*****:::::::::*@@##@*****.*****\n****************######@%+*:::::::-::::::::::::::::::::::::=@##%****-******\n.......-------:*######=::::::----------:::::::::::::::::::+###:**--*******\n............:==:%####=:::::----:-:::::::::::::::::::::::::=@##:-.:********\n************=@++*%##@::::*=%%%@@###@=***::::::::::::::::::=@#@*..*********\n************=**+@+@#*:::**+++%@#@###%@%%+*::*+=======*::::*##-:**.********\n*************:=%%:%*::::*+=%##%###=@@@%=*::*=%@@@%%@@#@%::+#@:****.*******\n:**************==:=:::--::::*++++=%@@@%*:--*%#@####@#=+***@@%@*****.******\n--**************:-*::--------::**+***:::---*+%%%%%%@@%+*::#*@%******.*****\n*:-************---*::::-----------::--:---::::+++++**:::::%*%********-:***\n**:.************++*:::::--------::**+------::::::::::::::*++**********--**\n****.**************::::::-----::**==:-------+*:::::---:::**************:-*\n*****.***********.*::::::::-:::***:*+@**::**=+*::::::::::****************-\n******.*:*%@######+::::::::::::::::::++++=******::::::::******************\n******:############*::::::::****::::::*+*:*:*:***::::::*******************\n******#############***::*:*:*+==@@##=======:*+***:::*:********************\n******#############:*+**********:*++**+**++=%=***:*::*********************\n.....##############::*++**************+***:*********###+******************\n***:##############@*:**+=***:::**++===++***********#####%.................\n*:*###############******++=+*:::::::*:::::*::***#########=****************\n**:################%*****++==++********::::*+++=##########+***************\n*:%##################******++++==+=++++++++++++@############**************\n######################@******+++++++++++++++++=%#############*************\n########################+++++++++++++++++++++==@#############@***********.\n#########################%+++++++++++++++++===%###############%********:-*\n########################@=#=++++++++++++====%@##################******-**/\n\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define fs first\n#define sc second\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define mp make_pair\n#define len(v) ((int)v.size())\n#define vc vector\n#define pr pair\n#define endd \"\\n\"; return 0;\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\n\nconst int MAXN = 1e5;\nconst int INF = 1e18;\nconst int MOD = 1e9 + 7;\n\n\nmap<int, vector<int>> g[MAXN];\nmap<int, int> color;\n\nclass TaskE {\npublic:\n    void solve(std::istream &in, std::ostream &out) {\n        int n, h;\n        in >> n >> h;\n        pr<pr<int, int>, pr<int, int>> a1[n];\n        map<pr<int, int>, int> gf;\n        map<int, int> nach;\n        map<int, int> nach1;\n        int kol = 0;\n        for (int i = 0; i < n; i++) {\n            in >> a1[i].fs.fs >> a1[i].fs.sc >> a1[i].sc.fs >> a1[i].sc.sc;\n            pr<int, int> a;\n            if (a1[i].fs.sc == 0) {\n                a.fs = a1[i].fs.fs;\n                kol++;\n            } else {\n                a.fs = -a1[i].fs.sc;\n            }\n            if (a1[i].sc.sc == 0) {\n                a.sc = -a1[i].sc.fs;\n                kol++;\n            } else {\n                a.sc = a1[i].sc.sc;\n            }\n            nach[a.fs]++;\n            nach1[a.sc]++;\n        }\n        if (kol < 2) {\n            out << \"NO\";\n            return;\n        }\n        for (auto v : nach) {\n            if (v.fs > 0) {\n                if (v.sc > nach1[v.fs]) {\n                    out << \"NO\";\n                    return;\n                }\n            } else {\n                if (v.sc < nach1[v.fs]) {\n                    out << \"NO\";\n                    return;\n                }\n            }\n        }\n        out << \"YES\";\n    }\n};\n\n\nmain() {\n    TaskE solver;\n    std::istream &in(std::cin);\n    std::ostream &out(std::cout);\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Jigsaw\n// * frank_c1\n// * 2017 / 11/ 07\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = (int)(1e5) + 5;\nint ai[maxn], bi[maxn], ci[maxn], di[maxn];\nint in[maxn], ou[maxn];\n\nint main() {\n\tint n, H;\n\tscanf(\"%d%d\", &n, &H);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d%d%d%d\", &ai[i], &bi[i], &ci[i], &di[i]);\n\t\tint u = 0, v = 0;\n\t\tif (!ci[i]) u = ai[i]; else u = ci[i] + H;\n\t\tif (!di[i]) v = bi[i] + H; else v = di[i];\n\t\t++ou[u]; ++in[v]; \n\t} int cnt = 0, e = 0;\n\tfor (int i = 1; i <= H; ++i) if (in[i] > ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] < ou[i]) ++cnt, e = 1;\n\tfor (int i = H + 1; i <= H + H; ++i) if (in[i] < ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] > ou[i]) --cnt;\n\treturn ((cnt || !e) ? printf(\"NO\\n\") : printf(\"YES\\n\")), 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef UTIL_H\n#define UTIL_H\n\n\n\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0), s(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); ++s; }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { --s; A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { s = B = 0; for (auto &a: A) a = queue<T>(); }\n\tinline ui size() const { return s; }\nprivate:\n\tvector<queue<T>> A; ui B; int s;\n};\n\nstruct\tUnionFind {\n\tUnionFind(size_t N) : P(N, -1), comp(N) {}\n\tint find(int x) { while (P[x]> 0){x = P[x]-1;}return x; }\n\tbool united(int x, int y) { return find(x) == find(y); }\n\tbool unite(int x, int y) { x=find(x);y=find(y);if(x==y){return false;}--comp;if(P[x]>P[y]){swap(x,y);}P[x]+=P[y];P[y]= x+1;return true;}\n\tinline ui size(int u) { return -P[find(u)]; }\n\tvector<int> P;\n\tsize_t comp;\n};\n\n\n\n#endif\n\nclass EJigsaw {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, H; cin >> N >> H;\n//        map<int, set<int>> E;\n        UnionFind UF(2*H+2);\n        vector<int> InDeg(2*H+2, 0), OutDeg(2*H+2, 0);\n        for (int i = 0; i < N; ++i) {\n            int A, B, C, D; cin >> A >> B >> C >> D;\n            int left = C ? C : H+1+A;\n            int right = D ? H+1+D : B;\n            InDeg[right]++;\n            OutDeg[left]++;\n            UF.unite(left, right);\n        }\n\n        for (int i = H+2; i <= 2*H-1; ++i) {\n            if (OutDeg[i] >= InDeg[i]) {\n                int diff = OutDeg[i] - InDeg[i];\n                InDeg[i] += diff;\n                OutDeg[0] += diff;\n                if (diff) UF.unite(0, i);\n            } else {\n                cout << \"NO\\n\" << i << endl;\n                return;\n            }\n        }\n        for (int i = 1; i <= H; ++i) {\n            if (OutDeg[i] <= InDeg[i]) {\n                int diff = InDeg[i] - OutDeg[i];\n                InDeg[0] += diff;\n                OutDeg[i] += diff;\n                if (diff) UF.unite(0, i);\n            } else {\n                cout << \"NO\\n\" << i << endl;\n                return;\n            }\n        }\n\n        int cmp = UF.comp;\n        for (int i = 1; i < 2*H+2; ++i) if (InDeg[i] == 0 && OutDeg[i] == 0) --cmp;\n        if (cmp == 1) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEJigsaw solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    int n,h;\n    cin >> n >> h;\n    vector<int> p(h+1),q(h+1);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;    \n        if(c==0){\n            p[a]++;\n        }else{\n            q[c]++;\n        }\n        if(d==0){\n            q[b]--;\n        }else{\n            p[d]--;\n        }\n    }\n    int c = 0;\n    int d = 0;\n    rep(i,h+1){\n        if(abs(p[i])>1){\n            cout << \"NO\" << endl;\n            return 0;\n        }else{\n            if(p[i]==1){\n                c++;\n            }else if(p[i]==-1){\n                cout << \"NO\" << endl;\n                return 0;\n                d++;\n            }\n        }\n        if(abs(q[i])>1){\n            cout << \"NO\" << endl;\n            return 0;\n        }else{\n            if(q[i]==1){\n                cout << \"NO\" << endl;\n                return 0;\n                c++;\n            }else if(q[i]==-1){\n                d++;\n            }\n        }\n    }\n    if((c==d)&&c>0){\n        assert(0);\n        cout << \"YES\" << endl;\n    }else{\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int H = 210;\n\nint n,h;\nint deg[H*2];\nint cnt[H*2];\nint fa[H*2];\nbool bz[H*2];\n\nint getfather(int x){\n\tif (fa[x]==x)return fa[x];\n\treturn fa[x]=getfather(fa[x]);\n}\n\nint main(){\n\tfo(i,0,h*2)fa[i]=i;\n\tn=get();h=get();\n\tfo(i,1,n){\n\t\tint a=get(),b=get(),c=get(),d=get();\n\t\tif (c)a=-c;\n\t\tif (d)b=d;else b=-b;\n\t\ta+=h;b+=h;\n\t\tint ta=getfather(a),tb=getfather(b);\n\t\tdeg[a]++;deg[b]--;\n\t\tfa[ta]=tb;\n\t}\n\tbool ans=1;\n\tfo(i,0,h-1)if (deg[i]>0)ans=0;\n\tfo(i,h+1,2*h)if (deg[i]<0)ans=0;\n\tif (ans){\n\t\tfo(i,0,2*h){\n\t\t\tint t=getfather(i);\n\t\t\tif (t!=i)bz[t]=1;\n\t\t\tif (deg[i]!=0)cnt[t]++;\n\t\t}\n\t\tfo(i,0,2*h)\n\t\tif (bz[i]&&!cnt[i])ans=0;\n\t}\n\tif (ans)printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nint n,h;\nint l[220],r[220],bns;\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0)l[a]++,bns++;\n\t\telse r[c]--,bns--;\n\t\tif(d==0)r[b]++,bns++;\n\t\telse l[d]--,bns--;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=200;i++){\n\t\tans+=l[i];\n\t\tif(l[i]<0||r[i]<0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(bns<=0||ans!=bns){\n\t\tprintf(\"NO\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define e1 first\n#define e2 second\n#define pb push_back\n#define mp make_pair\n#define boost ios_base::sync_with_stdio(false)\n#define eb emplace_back\n#define OUT(x) {cout << x; exit(0); }\n#define FOR(i, a, b) for(int i=(a); i<=(b); ++i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> PII;\ntypedef pair <ll, ll> PLL;\ntypedef pair <PLL, PLL> PP;\ntypedef pair <PII, int> PPI;\ntypedef unsigned int ui;\ntypedef vector <int> vi;\nconst ll mod = 1e9+7;\nconst int inf = 1e9+9;\nconst ll MOD = 1e9+696969;\nconst ll INF = 1e18;\n\nconst int C = 400, maxn = 1000;\nvector <int> v[maxn];\nint in[maxn], out[maxn], n, h, a, b, c, d;\n\ninline void addEdge(int x, int y)\n{\n\tv[x].pb(y);\n\tv[y].pb(x);\n\tin[y]++;\n\tout[x]++;\n}\nbool ans = 0;\nbool odw[maxn];\nvoid dfs(int x)\n{\n\todw[x] = 1;\n\tif (in[x] != out[x]) ans = 1;\n\tfor (auto u : v[x])\n\t\tif (!odw[u]) dfs(u);\n}\nint main()\n{\n\tboost;\n\tcin >> n >> h;\n\tFOR(i, 1, n)\n\t{\n\t\tcin >> a >> b >> c >> d;\n\t\tint l = (c == 0)?a:-c, r = (d == 0)?-b:d;\n\t\taddEdge(l + C, r + C);\n\t}\n\t\n\tFOR(i, 1, h)\n\t\tif (in[i + C] > out[i + C]) OUT(\"NO\");\n\t\n\tFOR(i, -h, -1)\n\t\tif (in[i + C] < out[i + C]) OUT(\"NO\");\n\t\n\tFOR(i, -h, h)\n\t\tif (!odw[i + C] && (int)v[i + C].size() > 0) \n\t\t{\n\t\t\tans = 0;\n\t\t\tdfs(i + C);\n\t\t\tif (!ans) OUT(\"NO\");\n\t\t}\n\tcout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 505\nusing namespace std;\nint n,m,a[N],b[N],c[N],d[N],deg[M],f[M],vis[M],fr[M];\nvoid GG(){ printf(\"NO\"); exit(0);}\nint find(int x){ return f[x] ? f[x]=find(f[x]) : x;}\nint main()\n{\n\tint i,x,y;\n\tscanf(\"%d %d\",&n,&m),m=2*m+1;\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tif(c[i]!=0) x=2*c[i]+1; else x=2*a[i];\n\t\tif(d[i]!=0) y=2*d[i]; else y=2*b[i]+1;\n\t\tdeg[x]++,deg[y]--;\n\t  }\n\tfor(i=1;i<=m;i++)\n\t\tif(deg[i]!=0){\n\t\t\tif(deg[i]>0&&(i&1)) GG();\n\t\t\tif(deg[i]<0&&(~i&1)) GG();\n\t\t  }\n\tprintf(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2e5+7;\nstruct edge{\n\tint to,nxt;\n}e[N<<1];\nint head[N],cnt,n,h,nod,deg[N];\nbool vis[N];\ninline void addedge(int u,int v){e[++cnt]=(edge){v,head[u]},head[u]=cnt,++deg[v],--deg[u];}\nvoid dfs(int u){\n\tfor(int&i=head[u];i;i=e[i].nxt)if(!vis[i])vis[i]=1,dfs(e[i].to);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);h*=2;\n\tfor(int i=1;i<=n;++i){\n\t\tint A,B,C,D;\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tint iL=C==0?n+A:n+h+C,iR=D==0?n+B:n+h+D;\n\t\tint pL=C==0?n+h+A:n+C,pR=D==0?n+h+B:n+D;\n\t\taddedge(iL,iR),addedge(iR,pR);\n\t}\n\tfor(int i=1;i<=h;++i){\n\t\twhile(deg[n+i]<0)addedge(0,n+i);\n\t\twhile(deg[n+h+i]>0)addedge(n+h+i,0);\n\t}\n\tdfs(0);\n\tbool ok=1;\n\tfor(int i=1;i<=cnt&&ok;++i)ok=vis[i];\n\tfor(int i=1;i<=n+2*h&&ok;++i)ok=!deg[i];\n\tputs(ok?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\nint ind[500];\nint outd[500];\nbool used[500];\nvector<int> es[500];\n\nint MakeVertex(int a, int c, bool rev=false) {\n  if (c == 0) return a+rev*(H+1);\n  return c+(H+1)*!rev;\n}\n\npii GetIO(int v, pii &cnt) {\n  if (es[v].empty()) {\n    return pii(0, 0);\n  }\n\n  used[v] = true;\n  pii ret(0, 0);\n  for (int u : es[v]) {\n    if (used[u]) continue;\n    auto res = GetIO(u, cnt);\n    ret.X += res.X;\n    ret.Y += res.Y;\n  }\n\n  if (v >= H+1) {\n    assert(ind[v] - outd[v] >= 0);\n    cnt.X += 1;\n    ret.X += ind[v] - outd[v];\n  } else {\n    assert(outd[v] - ind[v] >= 0);\n    cnt.Y += 1;\n    ret.Y += outd[v] - ind[v];\n  }\n\n  return ret;\n}\n\nsigned main(){\n  cin >> N >> H;\n\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    \n    int u = MakeVertex(A[i], C[i], true);\n    int v = MakeVertex(B[i], D[i], false);\n\n    ind[u]++;\n    outd[v]++;\n\n    es[u].eb(v);\n    es[v].eb(u);\n  }\n\n  rep(v, H+1) {\n    if (ind[v] > outd[v]) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n\n  reps(v, H+1, 2*(H+1)) {\n    if (ind[v] < outd[v]) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n\n  rep(v, 2*(H+1)) {\n    if (used[v]) continue;\n    pii cnt(0, 0);\n    auto res = GetIO(v, cnt);\n    //cout << res.X << \", \" << res.Y << endl;\n    //cout << cnt.X << \", \" << cnt.Y << endl;\n    if ((res.X != res.Y) || (cnt.X > 0 && cnt.Y == 0) || (cnt.X == 0 && cnt.Y > 0)) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n\n  cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nvector <int> LI[444], LO[444], RI[444], RO[444];\nvector <pii> V;\nbool chk[444];\nmultiset <int> SL, SR;\nint n, h;\n\nvoid dfs(int p, vector <int> *V)\n{\n\tchk[p] = 1;\n\tfor(int t: V[p]){\n\t\tif(!chk[t]) dfs(t, V);\n\t}\n}\n\nvoid die()\n{\n\tprintf(\"NO\\n\");\n\texit(0);\n}\n\nint main()\n{\n\tint i, j, a, b, c, d;\n\t\n\tscanf(\"%d%d\", &n, &h);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\n\t\tif(c == 0 && d == 0){\n\t\t\tif(a != h){\n\t\t\t\tLO[0].push_back(a);\n\t\t\t\tLI[a].push_back(0);\n\t\t\t}\n\t\t\tif(b != h){\n\t\t\t\tRO[0].push_back(b);\n\t\t\t\tRI[b].push_back(0);\n\t\t\t}\n\t\t}\n\t\telse if(c == 0){\n\t\t\tif(a != h){\n\t\t\t\tLO[d].push_back(a);\n\t\t\t\tLI[a].push_back(d);\n\t\t\t}\n\t\t}\n\t\telse if(d == 0){\n\t\t\tif(b != h){\n\t\t\t\tRO[c].push_back(b);\n\t\t\t\tRI[b].push_back(c);\n\t\t\t}\n\t\t}\n\t\telse V.push_back(pii(c, d));\n\t}\n\t\n\tdfs(0, LO);\n\t\n\tfor(i=1;i<h;i++){\n\t\tif((!LO[i].empty() || !LI[i].empty()) && !chk[i]) die();\n\t\tif(LI[i].size() >= LO[i].size()){\n\t\t\tfor(j=0;j<LI[i].size() - LO[i].size();j++) SL.insert(i);\n\t\t}\n\t\telse die();\n\t\tchk[i] = 0;\n\t}\n\t\n\tdfs(0, RO);\n\t\n\tfor(i=1;i<h;i++){\n\t\tif((!RO[i].empty() || !RI[i].empty()) && !chk[i]) die();\n\t\tif(RI[i].size() >= RO[i].size()){\n\t\t\tfor(j=0;j<RI[i].size() - RO[i].size();j++) SR.insert(i);\n\t\t}\n\t\telse die();\n\t\tchk[i] = 0;\n\t}\n\t\n\tfor(pii t: V){\n\t\tauto it = SL.find(t.second);\n\t\tif(it == SL.end()) die();\n\t\tSL.erase(it);\n\t\t\n\t\tit = SR.find(t.first);\n\t\tif(it == SR.end()) die();\n\t\tSR.erase(it);\n\t}\n\t\n\tif(SL.empty() || SR.empty()) die();\n\t\n\tprintf(\"YES\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=100010;\nconst int maxm=410;\nint n,m,u[maxn],v[maxn];\nint pa[maxm],in[maxm],out[maxm],yes[maxm];\nint findset(int x) {return x==pa[x]?x:pa[x]=findset(pa[x]);}\nint main() {\n\tn=read();m=read();\n\trep(i,1,n) {\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint p,q;\n\t\tif(!c) p=a;\n\t\telse p=-c;\n\t\tif(!d) q=-b;\n\t\telse q=d;\n\t\tp+=m;q+=m;\n\t\tin[q]++;out[p]++;\n\t\tu[i]=p;v[i]=q;\n\t}\n\tint ok=1;\n\trep(i,0,2*m) {\n\t\tif(i<m&&in[i]<out[i]) ok=0;\n\t\tif(i>m&&in[i]>out[i]) ok=0;\n\t}\n\trep(i,0,2*m) if(i!=m) pa[i]=i;\n\trep(i,1,n) pa[findset(u[i])]=findset(v[i]);\n\trep(i,0,2*m) if(in[i]!=out[i]) yes[findset(i)]++;\n\trep(i,0,2*m) if(i==findset(i)&&(!yes[i])) ok=0;\n\tputs(ok?\"YES\":\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//AtCoder Grand Contest 017 E - Jigsaw\n\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint qr(){int ret = 0,f=1;char ch =getchar();while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();return ret*f;}\n\n#define maxN 100005\n#define maxH 205\n\nint indegree[maxH<<2],outdegree[maxH<<2];\nint active[maxH<<2];\nvoid read(int x,int y){\n    indegree[y]++;\n    outdegree[x]++;\n}\nint f[maxH<<1];\nvoid init(){\n    for(int i = 1;i<=(maxH<<1);i++)\n        f[i] = i;\n}\nint gf(int x){\n    if(f[x] == x) return x;\n    else return f[x] = gf(f[x]);\n}\nint mer(int x,int y){\n    x = gf(x);y = gf(y);\n    if(x == y) return 0;\n    f[x] = y;\n    return 1;\n}\nint main(){\n    init();\n    int N = qr(),H = qr();\n    int NN = 0;\n    int t1,t2,t3,t4,t5,t6;//上 t + maxN 下 t + maxN + maxH\n    for(int i = 1;i<=N;i++){\n        t1 = qr(),t2 = qr(),t3 = qr(),t4 = qr();\n        if(!t3) t5 = t1+H;else t5 = -t3+H;\n        if(!t4) t6 = -t2+H;else t6 = t4+H;\n        indegree[t6]++;\n        outdegree[t5]++;\n        if(!active[t5])\n            NN++;\n        if(!active[t6])\n            NN++;\n        active[t5] = active[t6] = 1;\n        NN -= mer(t5,t6);\n    }\n    if(NN!=1){\n        cout << \"NO\";\n        return 0;\n    }\n    int mark=1;\n    for(int i = 1;i<=H;i++){\n        if(indegree[i]<outdegree[i])\n            mark=0;\n        if(indegree[H+i]>outdegree[H+i])\n            mark=0;\n    }\n    if(mark)\n        cout << \"YES\";\n    else cout << \"NO\";\n    /*\n    int a=0,b=0;\n    for(int i = maxN;i<=maxN + 500;i++){\n        if(indegree[i] == outdegree[i])\n            continue;\n        else {\n            if(abs(indegree[i]-outdegree[i])!=1) {cout << \"NO\";return 0;}\n            else {\n                //if(i<=maxN+maxH) {\n                    if(indegree[i] > outdegree[i])\n                        a++;\n                    else b++;\n                //}else{\n                //    if(indegree[i] > outdegree[i])\n                //        b++;\n                //    else a++;\n                //}\n            }\n            if(a == 2||b == 2){cout << \"NO\";return 0;}\n        }\n    }\n    if(a == b){cout << \"YES\";}\n    else {cout << \"NO\";}\n    */\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[50000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t\tif (j = l+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]&&c[j][4]==0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t\tif (j = l+1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t\tif (n != 0)\n\t\t\tbreak;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long  int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v])parent[u] = v;\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<vector<int>>uu(201, vector<int>(201));\n\tvector<vector<int>>us(201, vector<int>(201));\n\tvector<vector<int>>su(201, vector<int>(201));\n\tvector<vector<int>>ss(201, vector<int>(201));\n\tfor (int i = 0; i < N; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif (c&&d) {\n\t\t\tuu[c][d]++;\n\t\t}\n\t\telse if (c) {\n\t\t\tus[c][b]++;\n\t\t}\n\t\telse if (d) {\n\t\t\tsu[a][d]++;\n\t\t}\n\t\telse {\n\t\t\tss[a][b]++;\n\t\t}\n\t}\n\t//for (int i = 1; i <= 200; i++) {\n\t//\tus[i][i] = min(us[i][i], 1);\n\t//\tsu[i][i] = min(su[i][i], 1);\n\t//}\n\tvector<int>lu(201);\n\tvector<int>ld(201);\n\tvector<int>ru(201);\n\tvector<int>rd(201);\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tlu[i] += uu[i][j];\n\t\t\tlu[i] += us[i][j];\n\t\t\tld[i] += su[i][j];\n\t\t\tld[i] += ss[i][j];\n\t\t\tru[j] += uu[i][j];\n\t\t\tru[j] += su[i][j];\n\t\t\trd[j] += ss[i][j];\n\t\t\trd[j] += us[i][j];\n\t\t}\n\t\tld[i] -= su[i][i];\n\t\trd[i] -= us[i][i];\n\t}\n\tUnionFind uf(5000);\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tif (uu[i][j])uf.Unite(i + 1000, j);\n\t\t\tif (us[i][j])uf.Unite(i + 1000, j + 1000);\n\t\t\tif (su[i][j])uf.Unite(i, j);\n\t\t\tif (ss[i][j])uf.Unite(i, j + 1000);\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tif (ru[i] > ld[i]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif (ru[i] < ld[i])uf.Unite(2000, i);\n\t\tif (lu[i] > rd[i]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif (lu[i] < rd[i])uf.Unite(2000, i + 1000);\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tif ((lu[i] || rd[i]) && !uf.Check_Same(i + 1000, 2000)) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif ((ld[i] || ru[i]) && !uf.Check_Same(i, 2000)) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst long long INF = (1ll << 50);\nstruct graph {\n  typedef long long flow_type;\n  struct edge {\n    int src, dst;\n    flow_type capacity, flow;\n    size_t rev;\n  };\n  int n;\n  vector<vector<edge>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst, flow_type capacity) {\n    adj[src].push_back({src, dst, capacity, 0, adj[dst].size()});\n    adj[dst].push_back({dst, src, 0, 0, adj[src].size()-1});\n  }\n  flow_type max_flow(int s, int t, bool first=false) {\n    if (first) {\n      for (int u = 0; u < n; ++u) // initialize\n      for (auto &e: adj[u]) e.flow = 0;\n    }\n\n    vector<int> level(n), iter(n);\n    function<int(void)> levelize = [&]() { // foward levelize\n      level.assign(n, -1); level[s] = 0;\n      queue<int> Q; Q.push(s);\n      while (!Q.empty()) {\n        int u = Q.front(); Q.pop();\n        if (u == t) break;\n        for (auto &e: adj[u]) {\n          if (e.capacity > e.flow && level[e.dst] < 0) {\n            Q.push(e.dst);\n            level[e.dst] = level[u] + 1;\n          }\n        }\n      }\n      return level[t];\n    };\n    function<flow_type(int, flow_type)> augment = [&](int u, flow_type cur) {\n      if (u == t) return cur;\n      for (int &i = iter[u]; i < adj[u].size(); ++i) {\n        edge &e = adj[u][i], &r = adj[e.dst][e.rev];\n        if (e.capacity > e.flow && level[u] < level[e.dst]) {\n          flow_type f = augment(e.dst, min(cur, e.capacity - e.flow));\n          if (f > 0) {\n            e.flow += f;\n            r.flow -= f;\n            return f;\n          }\n        }\n      }\n      return flow_type(0);\n    };\n\n    flow_type flow = 0;\n    while (levelize() >= 0) {\n      fill(all(iter), 0);\n      for (flow_type f; (f = augment(s, INF)) > 0; )\n        flow += f;\n    }\n    return flow;\n  }\n};\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\nint cnt2[500];\nint cnt3[500];\n\nint MakeVertex(int a, int c) {\n  if (c == 0) return a;\n  return c+(H+1);\n}\n\nsigned main(){\n  cin >> N >> H;\n\n  int S = 0;\n  int S2 = S+1;\n  int T2 = S2+1;\n  int l2 = T2+1;\n  int l3 = l2+2*(H+2);\n  int gr = l3+2*(H+2);\n  int grL = gr+1;\n  int grR = grL+1;\n  int T = grR+1;\n  graph g(T+1);\n\n\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    \n    int u = MakeVertex(B[i], D[i]);\n    cnt2[u]++;\n    int v = MakeVertex(A[i], C[i]);\n    cnt3[v]++;\n\n  }\n\n  reps(i, l2, l3) {\n    int u = i - l2;\n    int v = (u >= H+1) ? u-(H+1) : u+H+1;\n    g.add_edge(l2+u, l3+v, N);\n    if (cnt2[u] > 0) {\n      g.add_edge(S, l2+u, cnt2[u]);\n      //g.add_edge(S2, l2+u, cnt2[u]);\n      //g.add_edge(S, T2, cnt2[u]);\n    }\n  }\n\n  reps(i, l3, gr) {\n    int u = i - l3;\n    if (cnt3[u] > 0) {\n      g.add_edge(l3+u, T, cnt3[u]);\n      //g.add_edge(S2, T, cnt3[u]);\n      //g.add_edge(l3+u, T2, cnt3[u]);\n    }\n  }\n    \n  //g.add_edge(S, gr, N);\n  //g.add_edge(gr, T, N);\n\n  g.add_edge(S, grL, 1);\n  //g.add_edge(S2, grL, 1);\n  //g.add_edge(S, T2, 1);\n\n  g.add_edge(grR, T, 1);\n  //g.add_edge(S2, T, 1);\n  //g.add_edge(grR, T2, 1);\n\n  reps(h, 1, H+1) {\n    int v = MakeVertex(h, 0);\n    g.add_edge(l2+v, gr, N+1);\n    g.add_edge(gr, l3+v, N+1);\n    g.add_edge(l2+v, grR, 1);\n    g.add_edge(grL, l3+v, 1);\n  }\n\n  //LL a = g.max_flow(S2, T2, true);\n  //LL b = g.max_flow(S, T2);\n  //LL c = g.max_flow(S2, T);\n  LL d = g.max_flow(S, T);\n  //cout \n  //<< a << \",\" \n  //<< b << \",\"\n  //<< c << \",\"\n  //<< d << endl;\n\n  //if (a+b == a+c && a+b == N*2+2) {\n  if (d >= N+1) {\n    cout << \"YES\" << endl;\n    return 0;\n  }\n  cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, h;\nconst int N = 2000;\nint fa[N], ok[N], cnt[N], vis[N];\nint get_f(int t) {return fa[t] = (fa[t] == t? t: get_f(fa[t]));}\nint main()\n{\n    cin >> n >> h;\n    for (int i = 1; i <= h * 2; ++ i) fa[i] = i;\n    for (int i = 1; i <= n; ++ i)\n    {\n        int a, b, c, d, l, r;\n        cin >> a >> b >> c >> d;\n        if (c == 0) l = a; else l = c + h;\n        if (d == 0) r = b + h; else r = d;\n        // cerr << l << \" \" << r << endl;\n        cnt[l] ++; cnt[r] --;\n        vis[l] = vis[r] = 1;\n        if (get_f(l) != get_f(r)) fa[get_f(l)] = get_f(r);\n    }\n    for (int i = 1; i <= h; ++ i) if (cnt[i] < 0) return puts(\"NO\"), 0;\n    for (int i = 1; i <= h; ++ i) if (cnt[i + h] > 0) return puts(\"NO\"), 0;\n    for (int i = 1; i <= h * 2; ++ i) if (cnt[i] != 0) ok[get_f(i)] = 1;\n    for (int i = 1; i <= h * 2; ++ i) if (vis[i]) if (!ok[get_f(i)]) return puts(\"NO\"), 0;\n    puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// contancer library\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\n\ntemplate <class K, class T>\nostream& operator<<(ostream& os, map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\n\nconst ll MOD = 1000000007;\n// const ll MOD = 998244353;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const ld PI = acos(-1);\n// const ld EPS = 1e-10;\n// mt19937 mt(ll(time(0)));\n\ntemplate <class T>\nvector<T> Vec(size_t l, T v) { return vector<T>(l, v); }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\ntemplate <typename T>\ninline T sq(T a) { return a * a; }\n\ntemplate <typename T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <typename T, typename U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\ntemplate <typename T, typename U>\nT mpow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret = ret * b % MOD;\n        n >>= 1;\n        b = b * b % MOD;\n    }\n    return ret;\n}\n\nint main() {\n    int N, H;\n    cin >> N >> H;\n    vector<int> dig(H, 0);\n\n    for (int i = 0; i < N; ++i) {\n        int A, B, C, D;\n        cin >> A >> B >> C >> D;\n        if (C == 0) ++dig[A - 1];\n        if (D > 0) --dig[D - 1];\n    }\n    cerr << dig << endl;\n\n    if (any_of(dig.begin(), dig.end(), [](int a) { return a < 0; }) ||\n        all_of(dig.begin(), dig.end(), [](int a) { return a == 0; })) {\n        cout << \"NO\" << endl;\n    } else {\n        cout << \"YES\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define MP make_pair\n#define MT make_tuple\n#define EACH(i,c) for(auto i: c)\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, H;\n\tcin >> N >> H;\n\n\tmap<int, int> lA, lC, rB, rD, lArD, rBlC;\n\tint x = 0, y = 0;\n\tREP(i, N){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif(c == 0){\n\t\t\tlA[a]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\tlC[c]++;\n\t\t\ty++;\n\t\t}\n\t\tif(d == 0){\n\t\t\trB[b]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\trD[d]++;\n\t\t\ty++;\n\t\t}\n\n\t\tif(c == 0 && a == d) lArD[a]++;\n\t\tif(d == 0 && b == c) rBlC[b]++;\n\t}\n\n\tif(y + 2 > x){\n\t\tcerr << x << \" \" << y << endl;\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\n\tbool bad = false;\n\tEACH(pa, lA){\n\t\trD[pa.first] -= pa.second;\n\t\tif(0 < rD[pa.first]){\n\t\t\tif(bad){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbad = true;\n\t\t}\n\t}\n\n\tbad = false;\n\tEACH(pb, rB){\n\t\tlC[pb.first] -= pb.second;\n\t\tif(0 < lC[pb.first]){\n\t\t\tif(bad){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbad = true;\n\t\t}\n\t}\n\n\n\tcout << \"YES\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,h,d[405],f[405],a[405],b[405];\n\nint find(int x){return f[x]==x?x:f[x]=find(f[x]);}\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&h);\n\tfor (int i=1; i<=2*h; i++)  f[i]=i;\n\tfor (int i=1,A,B,C,D; i<=n; i++)\n\t\t{\n\t\t\tscanf(\"%d %d %d %d\",&A,&B,&C,&D);\n\t\t\tA=C?C+h:A,B=D?D:B+h;\n\t\t\td[A]++,d[B]--,f[find(A)]=find(B),b[find(A)]=1;\n\t\t}\n\tfor (int i=1; i<=h; i++)  if (d[i]<0)  puts(\"NO\"),exit(0);\n\tfor (int i=1; i<=h; i++)  if (d[i+h]>0)  puts(\"NO\"),exit(0);\n\tfor (int i=1; i<=h; i++)  if (d[i]>0)  a[find(i)]=1;\n\tfor (int i=1; i<=2*h; i++)  if ((find(i)==i)&&(!a[i])&&(b[i]))  puts(\"NO\"),exit(0);\n\tputs(\"YES\");\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//84104971101048411497 - Can you guess what does this mean?\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> point;\n#define mapii map<int, int>\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define forit(it, var) for(__typeof(var.begin()) it = var.begin(); it != var.end(); it++)\n#define forrit(rit, var) for(__typeof(var.rbegin()) rit = var.rbegin(); rit != var.rend(); rit++)\n#define ii pair<int, int>\n#define iii pair<int, ii>\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define maxN 100005\n#define maxH 205\n#define oo 2000000007\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nint n, H, degIn[2][maxH], degOut[2][maxH], cnt, edgeCnt;\nvector<ii> g[2][maxH];\nbool visited[2][maxN];\n\nbool DFS(int i, int h) {\n//    printf(\"%d %d\\n\", i, h);\n    if (degIn[i][h] != degOut[i][h]) ++cnt;\n    visited[i][h] = true;\n    for(ii p: g[i][h]) {\n        ++edgeCnt;\n        if (!visited[p.ff][p.ss]) DFS(p.ff, p.ss);\n    }\n}\n\nbool Solve() {\n    fto(h, 1, H) {\n        if (degIn[0][h] > degOut[0][h]) return false;\n        if (degIn[1][h] < degOut[1][h]) return false;\n    }\n    fto(i, 0, 1) {\n        fto(h, 1, H) {\n            if (!visited[i][h]) {\n                edgeCnt = cnt = 0;\n                DFS(i, h);\n                if (edgeCnt > 0 && cnt == 0) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main () {\n    scanf(\"%d%d\", &n, &H);\n    fto(i, 1, n) {\n        int A, B, C, D;\n        scanf(\"%d%d%d%d\", &A, &B, &C, &D);\n\n        ii u, v;\n        if (C == 0) u = mp(0, A);\n        else u = mp(1, C);\n        if (D == 0) v = mp(1, B);\n        else v = mp(0, D);\n\n        ++degOut[u.ff][u.ss]; ++degIn[v.ff][v.ss];\n        g[u.ff][u.ss].pb(mp(v.ff, v.ss));\n        g[v.ff][v.ss].pb(mp(u.ff, u.ss));\n    }\n\n    puts((Solve()) ? \"YES\" : \"NO\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define has(c,i) ((c).find(i) != end(c))\n#define DBGDO(X) ({ if(1) cerr << \"DBGDO: \" << (#X) << \" = \" << (X) << endl; })\n\nll n;\nvvl adj;\nvl pos, indeg, path;\n\nvoid rec(ll i) {\n\twhile (pos[i] < sz(adj[i])) rec(adj[i][pos[i]++]);\n\tpath.pb(i);\n}\n\nbool euler() {\n\tpos.resize(n), indeg.resize(n);\n\tFOR(i,0,n) for (ll j: adj[i]) indeg[j]++;\n\n\tll need = accumulate(all(indeg),0);\n\tFOR(i,0,n/2) {\n\t\tif (sz(adj[i]) < indeg[i]) return false;\n\t\t\n\t\tll k = sz(adj[i]) - indeg[i];\n\t\twhile (k--) {\n\t\t\trec(i);\n\t\t\tneed -= sz(path)-1;\n\t\t\tpath.clear();\n\t\t}\n\t}\n\tassert(need >= 0);\n\treturn need == 0;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tll m, h; cin >> m >> h;\n\n\tauto id = [&](ll i, bool is_z) {\n\t\treturn (h+1)*!is_z + i;\n\t};\n\t\n\tn = 2*(h+1);\n\tadj.resize(n);\n\n\tFOR(i,0,m) {\n\t\tll a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\n\t\tll x, y;\n\t\tif (c == 0) x = id(a,true);\n\t\telse x = id(c,false);\n\t\tif (d == 0) y = id(b,false);\n\t\telse y = id(d,true);\n\t\tadj[x].pb(y);\n\t}\n\t\n\tbool res = euler();\n\t\n\tcout << (res ? \"YES\" : \"NO\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=1000005;\nint n,h,i,j,k,l,ans,A,B,C,D,g[405][405],u[N],p[N],ind[N],outd[N];\nbool vis[N],ok[N];\nint find(int x)\n{\n\treturn p[x]==-1?x:p[x]=find(p[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tif(C)\n\t\t\tA=C+h;\n\t\tif(D)\n\t\t\tB=D+h;\n\t\tg[A][B<=h?B+h:B-h]++;\n\t\tvis[A]=vis[B<=h?B+h:B-h]=true;\n\t}\n\tfor(i=1;i<=2*h;++i)\n\t\tfor(j=1;j<=2*h;++j)\n\t\t\tind[j]+=g[i][j],outd[i]+=g[i][j];\n\tfor(i=1;i<=h;++i)\n\t\tif(outd[i]<ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=h+1;i<=2*h;++i)\n\t\tif(outd[i]>ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=1;i<=2*h;++i)\n\t\tp[i]=-1;\n\tfor(i=1;i<=2*h;++i)\n\t\tfor(j=1;j<=2*h;++j)\n\t\t\tif(g[i][j]&&find(i)!=find(j))\n\t\t\t\tp[find(i)]=find(j);\n\tfor(i=1;i<=2*h;++i)\n\t\tif(outd[i]!=ind[i])\n\t\t\tok[find(i)]=true;\n\tfor(i=1;i<=2*h;++i)\n\t\tif(find(i)==i&&!ok[i]&&vis[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\nconst int N=1e6+5,M=2e6+5,mo=998244353;\nint fa[N],n,H,A,B,C,D,i,pp,pd[N],chu[N],ru[N],l,r,act[N];\nint get(int x)\n{\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\nint main()\n{\n\tscanf(\"%d %d\\n\",&n,&H);\n\tfo(i,0,H*2) fa[i]=i;\n\tfo(i,1,n)\n\t{\n\t\tscanf(\"%d %d %d %d\",&A,&B,&C,&D);\n\t\tif (!C) l=A;else l=-C; \n\t\tif (!D) r=-B;else r=D;\n\t\tl+=H;\n\t\tr+=H;\n\t\t//e=(l,r)\n\t\tact[l]=act[r]=1;\n\t\tchu[l]++;\n\t\tru[r]++;\n\t\tfa[get(l)]=get(r);\n\t}\n\tpp=1;\n\t// neg: in>=out\n\tfo(i,0,H) if (ru[i]<chu[i]) pp=0;\n\t// pos: in<=out\n\tfo(i,H+1,2*H) if (ru[i]>chu[i]) pp=0;\n\tfo(i,0,2*H) pd[get(i)]|=(ru[i]!=chu[i]);\n\tpd[H]=1;\n\tfo(i,0,2*H) if (act[i]&&!pd[get(i)]) pp=0;\n\tif (pp) printf(\"YES\");else\n\tprintf(\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct w {\n\tint a, b, c, d;\n} t[100005];\n\nbool comp(const w &a, const w &b) {\n\treturn a.d < b.d;\n}\n\nint n, h, cnt[2][300], ans;\n\nint main() {\n\tscanf(\"%d%d\", &n , &h);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%d%d\", &t[i].a, &t[i].b, &t[i].c, &t[i].d);\n\t\tif (t[i].c == 0)\n\t\t\tcnt[0][t[i].a]++;\n\t\telse\n\t\t\tcnt[1][t[i].c]--;\n\t\tif (t[i].d == 0)\n\t\t\tcnt[1][t[i].b]++;\n\t\telse\n\t\t\tcnt[0][t[i].d]--;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (t[i].c == 0)\n\t\t\tcnt[0][t[i].a]--;\n\t\telse\n\t\t\tcnt[1][t[i].c]++;\n\t\tif (t[i].d == 0)\n\t\t\tcnt[1][t[i].b]--;\n\t\telse\n\t\t\tcnt[0][t[i].d]++;\n\t\tif (t[i].c == 0)\n\t\t\t;//cnt[0][t[i].a]++;\n\t\telse {\n\t\t\tcnt[1][t[i].c]--;\n\t\t\tif (cnt[1][t[i].c] < 0) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (t[i].d == 0)\n\t\t\t;//cnt[1][t[i].b]++;\n\t\telse {\n\t\t\tcnt[0][t[i].d]--;\n\t\t\tif (cnt[0][t[i].d] < 0) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (t[i].c == 0)\n\t\t\tcnt[0][t[i].a]++;\n\t\telse\n\t\t\t;//cnt[1][t[i].c]--;\n\t\tif (t[i].d == 0)\n\t\t\tcnt[1][t[i].b]++;\n\t\telse\n\t\t\t;//cnt[0][t[i].d]--;\n\t}\n\tfor (int i = 0; i < 300; i++) {\n\t\tif (cnt[0][i] < 0 || cnt[1][i] < 0) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (cnt[0][i] > 0)\n\t\t\tans |= 1;\n\t\tif (cnt[1][i] > 0)\n\t\t\tans |= 2;\n\t}\n\tprintf(ans == 3 ? \"YES\\n\" : \"NO\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n// insert #if<tab> by my emacs. #if DEBUG == 1 ... #end\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint N, H;\nint A[100010];\nint B[100010];\nint C[100010];\nint D[100010];\n\nvector<int> V[420];\nint M = 210;\nint input[420];\nint output[420];\n\nconst int UFSIZE = 420;\nint union_find[UFSIZE];\n\nvector<int> S[420];\n\nvoid init() {\n  for (auto i=0; i<UFSIZE; i++) {\n    union_find[i] = i;\n  }\n}\n\nint root(int a) {\n  if (a == union_find[a]) return a;\n  return (union_find[a] = root(union_find[a]));\n}\n\nbool issame(int a, int b) {\n  return root(a) == root(b);\n}\n\nvoid unite(int a, int b) {\n  union_find[root(a)] = root(b);\n}\n\nbool isroot(int a) {\n  return root(a) == a;\n}\n\nvoid add_edge(int i) {\n  int from, to;\n  if (C[i] == 0) {\n    from = A[i];\n  } else {\n    from = -C[i];\n  }\n  if (D[i] == 0) {\n    to = -B[i];\n  } else {\n    to = D[i];\n  }\n  V[from + M].push_back(to + M);\n  output[from + M]++;\n  input[to + M]++;\n}\n\nint main () {\n  init();\n  cin >> N >> H;\n  fill(input, input+420, 0);\n  fill(output, output+420, 0);\n  for (auto i = 0; i < N; ++i) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    add_edge(i);\n  }\n  for (auto i = 1; i <= H; ++i) {\n    if (input[i + M] > output[i + M]) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n  for (auto i = 1; i <= H; ++i) {\n    if (input[-i + M] < output[-i + M]) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n  for (auto i = 0; i < 420; ++i) {\n    for (auto x : V[i]) {\n      unite(i, x);\n    }\n  }\n  for (auto i = 0; i < 420; ++i) {\n    S[root(i)].push_back(i);\n  }\n  for (auto i = 0; i < 420; ++i) {\n    if (!(S[i].empty())) {\n      bool ok = false;\n      for (auto x : S[i]) {\n        if (input[x] > 0 && input[x] == output[x]) {\n          \n        } else {\n          ok = true;\n          break;\n        }\n      }\n      if (!ok) {\n        cout << \"NO\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define vi vector<int>\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define aa first\n#define bb second\n#define xx aa.aa\n#define yy aa.bb\n#define zz bb\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nint n,m,a,b,c,d,w[410],f[410],u[410];\ninline int fa(int i)\n{\n\treturn i==f[i]?i:f[i]=fa(f[i]);\n}\nint main()\n{\n\t//freopen(\"b102.txt\",\"r\",stdin);\n\t//freopen(\"x.out\",\"w\",stdout);\n\tint i,j,k,l;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=2*m;i++)\n\t  f[i]=i;\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t   if(c)\n\t     j=c+m;\n\t   else\n\t     j=a;\n\t   if(d)\n\t     k=d;\n\t   else\n\t     k=b+m;\n\t   w[j]++;\n\t   w[k]--;\n\t   f[fa(j)]=fa(k);\n\t   u[j]=u[k]=1;\n\t  }\n\tfor(l=1;l<=2*m;l++)\n\t{\n\tfor(i=1,j=k=0;i<=2*m;i++)\n\t  if(fa(i)==l)\n\t  if(w[i]>0)\n\t    if(i<=m)\n\t      j+=w[i];\n\t    else\n\t      break;\n\t  else if(w[i]<0)\n\t    if(i>m)\n\t      k+=-w[i];\n\t    else\n\t      break;\n\tif(i<=2*m || j!=k)\n\t  {\n\t   printf(\"NO\\n\");\n\t   return 0;\n\t  }\n\tif(!j && !k)\n\t  {\n\t   for(i=1,j=k=0;i<=2*m;i++)\n\t     if(fa(i)==l)\n\t     if(u[i])\n\t       if(i<=m)\n\t         j++;\n\t       else\n\t         k++;\n\t   if(j+k)\n\t     {\n\t      printf(\"NO\\n\");\n\t      return 0;\n\t\t }\n\t  }\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cctype>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (!isdigit(ch)) f=ch=='-'?-1:f,ch=getchar();\n\twhile (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\n\nconst int MAXH=200;\nconst int V=(MAXH<<1)+5;\n\nint fa[V],deg[V]/*in - out*/,size[V];\nbool sat[V];\nint n,H;\n\nint getfather(int son){return fa[son]==son?son:fa[son]=getfather(fa[son]);}\n\ninline void addedge(int x,int y)\n{\n\t--deg[x],++deg[y];\n\tint fx=getfather(x),fy=getfather(y);\n\tif (!size[fx]) size[fx]=1;\n\tif (!size[fy]) size[fy]=1;\n\tif (fx!=fy) fa[fy]=fx,size[fx]+=size[fy];\n}\n\nint main()\n{\n\t//freopen(\"jigsaw.in\",\"r\",stdin),freopen(\"jigsaw.out\",\"w\",stdout);\n\tn=read(),H=read();\n\tfor (int i=0;i<=H<<1;++i) fa[i]=i;\n\tfor (int i=1,a,b,c,d;i<=n;++i)\n\t{\n\t\ta=read(),b=read(),c=read(),d=read();\n\t\tint l=(c?-c:a)+H,r=(d?d:-b)+H;\n\t\taddedge(l,r);\n\t}\n\tbool judge=1;\n\tfor (int x=0;judge&&x<=H<<1;++x)\n\t\tif (x-H)\n\t\t{\n\t\t\tif (x-H<0) judge&=deg[x]>=0;\n\t\t\telse judge&=deg[x]<=0;\n\t\t\tsat[getfather(x)]|=deg[x];\n\t\t}\n\tfor (int x=0;judge&&x<=H<<1;++x) if (x==getfather(x)&&size[x]) judge&=sat[x];\n\tprintf(judge?\"YES\\n\":\"NO\\n\");\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=100233,MAXH=205;\nint n,h,in[MAXH<<1],out[MAXH<<1];\nint fa[MAXH<<1];\nbool ok[MAXH<<1];\nint get(int x) {\n\treturn x==fa[x]?x:fa[x]=get(fa[x]);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=2*h;i++) fa[i]=i;\n\tfor(int i=1;i<=n;i++) {\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint x=c?h+c:a,y=d?d:h+b;\n\t\t++out[x],++in[y];\n\t\tint fx=get(x),fy=get(y);\n\t\tif(fx!=fy) fa[fx]=fy;\n\t}\n\tfor(int i=1;i<=h;i++)\n\t\tif(in[i]>out[i]) return puts(\"NO\"),0;\n\tfor(int i=h+1;i<=2*h;i++)\n\t\tif(in[i]<out[i]) return puts(\"NO\"),0;\n\tfor(int i=1;i<=2*h;i++)\n\t\tif(in[i]!=out[i]) ok[get(i)]=1;\n\tfor(int i=1;i<=2*h;i++)\n\t\tif(fa[i]==i&&(in[i]||out[i])&&!ok[i])\n\t\t\treturn puts(\"NO\"),0;\n\treturn puts(\"YES\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[50000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tint t,s;\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t\tt = j;\n\t\t\t\t\tif (t = l);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (t = l);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t = l);\n\t\t\tbreak;\n\t\t}\n\t\tif (t = l);\n\t\tbreak;\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]&&c[j][4]==0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t\ts = j;\n\t\t\t\t\tif (s = l)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (s = l)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s = l)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (s = l)\n\t\t\tbreak;\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t\tif (n != 0)\n\t\t\tbreak;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n\nusing namespace std;\n\nint n, h;\nvector<llint> G[405], revG[405];\nconst llint Pos = 202;\nbool used[405];\nint S, T;\n\nbool dfs(llint v, llint &lsum, llint &rsum)\n{\n\tused[v] = true;\n\tint deg = (int)G[v].size() - (int)revG[v].size();\n\tif(v <= 200){\n\t\tif(deg < 0) return false;\n\t\tlsum += deg;\n\t}\n\telse{\n\t\tif(deg > 0) return false;\n\t\trsum -= deg;\n\t}\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tif(!dfs(G[v][i], lsum, rsum)) return false;\n\t}\n\tfor(int i = 0; i < revG[v].size(); i++){\n\t\tif(used[revG[v][i]]) continue;\n\t\tif(!dfs(revG[v][i], lsum, rsum)) return false;\n\t}\n\treturn true;\n}\n\nint main(void)\n{\n\tcin >> n >> h;\n\tllint a, b, c, d, u, v;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a >> b >> c >> d;\n\t\tif(c == 0) u = a;\n\t\telse u = Pos+c;\n\t\tif(d == 0) v = Pos+b;\n\t\telse v = d;\n\t\t\n\t\tG[u].push_back(v);\n\t\trevG[v].push_back(u);\n\t}\n\tfor(int i = 0; i <= 400; i++){\n\t\tif(G[i].size() == 0 && revG[i].size() == 0) used[i] = true;\n\t}\n\t\n\tfor(int i = 0; i <= 400; i++){\n\t\tif(used[i]) continue;\n\t\tllint lsum = 0, rsum = 0;\n\t\tif(!(dfs(i, lsum, rsum) && lsum == rsum && lsum > 0)){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=500;\nint f[N],t[N],p[N],du[N];\nint get(int x)\n{\n\tif (f[x]==x) return x;\n\treturn f[x]=get(f[x]);\n}\nint main()\n{\n\tint n,h;\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=0;i<=400;i++) f[i]=i;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint l=200,r=200;\n\t\tif (c) l=l-c;else l=l+a;\n\t\tif (d) r=r+d;else r=r-b;\n\t\tdu[l]++;\n\t\tdu[r]--;\n\t\tt[l]=t[r]=1;\n\t\tf[get(l)]=get(r);\n\t}\n\tfor (int i=0;i<=200;i++) if (du[i]>0) \n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tfor (int i=201;i<=400;i++) if (du[i]<0)\n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tfor (int i=0;i<=400;i++) \n\t{\n\t\tif (du[i]) p[i]=1;\n\t\tt[get(i)]=t[get(i)]|t[i];\n\t}\n\tfor (int i=0;i<=400;i++) if (i==get(i)&&t[i]&&!p[i]) \n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t puts(\"YES\");\n\t return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n// insert #if<tab> by my emacs. #if DEBUG == 1 ... #end\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint N, H;\nint A[100010];\nint B[100010];\nint C[100010];\nint D[100010];\n\nvector<int> V[420];\nint M = 210;\nint input[420];\nint output[420];\nint from[420];\nint visited[420];\nbool ret = true;\n\nvoid add_edge(int i) {\n  int from, to;\n  if (C[i] == 0) {\n    from = A[i];\n  } else {\n    from = -C[i];\n  }\n  if (D[i] == 0) {\n    to = -B[i];\n  } else {\n    to = D[i];\n  }\n  V[from + M].push_back(to + M);\n  output[from + M]++;\n  input[to + M]++;\n}\n\nvoid visit(int i, int p) {\n  if (visited[i] == -1) {\n    from[i] = p;\n    int now = p;\n    bool ok = false;\n    while (now != i) {\n      if (output[now] == 1 && input[now] == 1) {\n        now = from[now];\n      } else {\n        ok = true;\n        break;\n      }\n    }\n    if (!ok) {\n      ret = false;\n    }\n  } else if (visited[i] == -2) {\n    from[i] = p;\n    visited[i] = -1;\n    for (auto x : V[i]) {\n      visit(x, i);\n    }\n    visited[i] = 0;\n  }\n}\n\nint main () {\n  cin >> N >> H;\n  fill(input, input+420, 0);\n  fill(output, output+420, 0);\n  for (auto i = 0; i < N; ++i) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    add_edge(i);\n  }\n  for (auto i = 1; i <= H; ++i) {\n    if (input[i + M] > output[i + M]) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n  for (auto i = 1; i <= H; ++i) {\n    if (input[-i + M] < output[-i + M]) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n  fill(visited, visited+420, -2);\n  fill(from, from+420, -1);\n  for (auto i = 1; i <= H; ++i) {\n    visit(i + M, -1);\n    visit(-i + M, -1);\n  }\n  cout << (ret ? \"YES\" : \"NO\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank;\n\tUF() {rank=vector<int>(um,0); for(int i=0;i<um;i++) par.push_back(i);}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\nUF<2000> uf;\n\nint in[2000];\nint out[2000];\n\nint N,H;\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>H;\n\tFOR(i,N) {\n\t\tint A,B,C,D,L,R;\n\t\tcin>>A>>B>>C>>D;\n\t\tif(C>0) L=C;\n\t\telse L=-A;\n\t\tif(D==0) R=B;\n\t\telse R=-D;\n\t\t\n\t\tout[L+1000]++;\n\t\tin[R+1000]++;\n\t\tuf(L+1000,R+1000);\n\t}\n\t\n\tfor(i=-200;i<=-1;i++) {\n\t\tif(in[i+1000]>out[i+1000]) return _P(\"NO\\n\");\n\t\tif(in[i+1000]<out[i+1000]) uf(1000,i+1000);\n\t}\n\tfor(i=1;i<=200;i++) {\n\t\tif(in[i+1000]<out[i+1000]) return _P(\"NO\\n\");\n\t\tif(in[i+1000]>out[i+1000]) uf(1000,i+1000);\n\t}\n\t\n\tfor(i=1000-200;i<=1000+200;i++) if((in[i]||out[i]) && uf[i]!=uf[1000]) return _P(\"NO\\n\");\n\t_P(\"YES\\n\");\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint num[403][2]={0}; \nint dou[403]={0};\nint main(){\n\tint n,h,t;\t\n\tcin>>n>>h;\n\tvector<int>pic[4];\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tpic[j].push_back(t);\n\t\t}\t\n\t} \n\tint a,b;\n\tfor(int i=0;i<pic[0].size();i++){\n\t\tif(pic[2][i]==0) \n\t\t\ta=pic[0][i];\n\t\telse \n\t\t\ta=200+pic[2][i];\n\t\tif(pic[3][i]==0) \n\t\t\tb=200+pic[1][i];\n\t\telse\n\t\t\tb=pic[3][i];\n\t\tif(a==b)\n\t\t\tdou[a]++;\n\t\tnum[b][1]++;\n\t\tnum[a][0]++;\n\t}\n\tint flag1=0,flag2=0,flag=0;\n\tfor(int i=0;i<403;i++){\n\t\tif(num[i][0]>num[i][1]) {\n\t\t\tif(i<200){\n\t\t\t\tflag1+=num[i][0]-num[i][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(num[i][0]<num[i][1]) {\n\t\t\tif(i>=200){\n\t\t\t\tflag2+=num[i][1]-num[i][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(dou[i]>0&&num[i][0]<=dou[i]&&num[i][1]<=dou[i]){\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag1==flag2&&flag1>0&&flag==0) cout<<\"YES\";\n\telse cout<<\"NO\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, c[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st < e[401]||st==e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\n#define A(a) ((a)<<1)\n#define B(a) ((a)<<1|1)\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nconst int MAXH = 207;\nconst int MAXV = 1007;\nconst int MAXE = 1000007;\n\nstruct eT\n{\n\tvoid setd ( int _u, int _v, int _l )\n\t{\n\t\tu = _u, v = _v, last = _l;\n\t}\n\t\n\tint u, v, last;\n}edge[MAXE];\n\nint n, H;\nint ke, la[MAXV];\nint va[MAXN], vb[MAXN], vc[MAXN], vd[MAXN];\nint il[MAXN], ir[MAXN];\nint deg[MAXV];\nbool hve[MAXV];\nbool vis[MAXV];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nvoid addedge ( int u, int v )\n{\n\tedge[ke].setd ( u, v, la[u] );\n\tla[u] = ke++;\n\t++deg[u], --deg[v];\n\thve[u] = hve[v] = true;\n}\n\nvoid dfs ( int now )\n{\n\tif ( vis[now] ) return;\n\tvis[now] = true;\n\tfor ( int i = la[now]; ~i; i = edge[i].last ) dfs ( edge[i].v );\n}\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tscanf ( \"%d%d\", &n, &H );\n\tlpi ( i, 1, n ) scanf ( \"%d%d%d%d\", &va[i], &vb[i], &vc[i], &vd[i] );\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tINIT ( la, -1 );\n\t\n\tlpi ( i, 1, n ){\n\t\tif ( vc[i] ) il[i] = A ( vc[i] );\n\t\telse il[i] = B ( va[i] );\n\t\tif ( vd[i] ) ir[i] = A ( vd[i] );\n\t\telse ir[i] = B ( vb[i] );\n\t\t\n\t\taddedge ( A ( il[i] ), B ( ir[i] ) );\n\t}\n\t\n\tint u, v;\n\tlpi ( i, 0, H ){\n\t\tu = A ( A ( i ) );\n\t\tv = B ( B ( i ) );\n\t\tif ( deg[u] < 0 ){\n\t\t\tprintf ( \"NO\\n\" );\n\t\t\treturn;\n\t\t}\n\t\twhile ( deg[u] ) addedge ( v, u );\n\t\t\n\t\tv = B ( A ( i ) );\n\t\tu = A ( B ( i ) );\n\t\tif ( deg[v] > 0 ){\n\t\t\tprintf ( \"NO\\n\" );\n\t\t\treturn;\n\t\t}\n\t\twhile ( deg[v] ) addedge ( v, u );\n\t}\n\t\n\tlpi ( i, 0, H ){\n\t\tif ( deg[A(B(i))] < 0 || deg[B(B(i))] > 0 ){\n\t\t\tprintf ( \"NO\\n\" );\n\t\t\treturn;\n\t\t}\n\t}\n\t\n//\tlp ( i, 0, ke ) cerr << edge[i].u << \" \" << edge[i].v << endl;\n\t\n\tlpi ( i, 0, H ) if ( deg[A(B(i))] > 0 ) dfs ( A ( B ( i ) ) );\n\tlp ( i, 0, MAXV ){\n\t\tif ( hve[i] && !vis[i] ){\n\t\t\tprintf ( \"NO\\n\" );\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tprintf ( \"YES\\n\" );\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nL chk[100010];\n\nstruct S1{\n\tL a,b,c,d,ord;\n};\n\nbool operator<(S1 a,S1 b){\n\treturn a.c<b.c;\n}\n\nbool operator==(S1 a,S1 b){\n\treturn a.c==b.c&&a.a==b.a&&a.b==b.b&&a.d==b.d&&a.ord==b.ord;\n}\nstruct S2{\n\tL a,b,c,d,ord;\n};\n\nbool operator<(S2 a,S2 b){\n\treturn a.d<b.d;\n}\n\nbool operator==(S2 a,S2 b){\n\treturn a.c==b.c&&a.a==b.a&&a.b==b.b&&a.d==b.d&&a.ord==b.ord;\n}\n\nstruct S3{\n\tL a,b,c,d,ord;\n};\n\nbool operator<(S3 a,S3 b){\n\treturn a.a+a.c<b.a+b.c;\n}\n\nbool operator==(S3 a,S3 b){\n\treturn a.c==b.c&&a.a==b.a&&a.b==b.b&&a.d==b.d&&a.ord==b.ord;\n}\nstruct S4{\n\tL a,b,c,d,ord;\n};\n\nbool operator<(S4 a,S4 b){\n\treturn a.b+a.d<b.b+b.d;\n}\n\nbool operator==(S4 a,S4 b){\n\treturn a.c==b.c&&a.a==b.a&&a.b==b.b&&a.d==b.d&&a.ord==b.ord;\n}\n\nL n,h;\n\nmultiset<S1>s1;\nmultiset<S2>s2;\nmultiset<S3>s3,lef;\nmultiset<S4>s4,rig;\nmultiset<S1>good;\n\nL aa[100010],bb[100010],cc[100010],dd[100010];\n\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&h);\n\tL i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL a,b,c,d;\n\t\tscanf(\"%lld %lld %lld %lld\",&a,&b,&c,&d);\n\t\taa[i]=a;\n\t\tbb[i]=b;\n\t\tcc[i]=c;\n\t\tdd[i]=d;\n\t\tif(c+d==0)\n\t\t{\n\t\t\tgood.insert((S1){a,b,c,d,i});\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts1.insert((S1){a,b,c,d,i});\n\t\t\ts2.insert((S2){a,b,c,d,i});\n\t\t\ts3.insert((S3){a,b,c,d,i});\n\t\t\ts4.insert((S4){a,b,c,d,i});\n\t\t\tif(c==0)\n\t\t\t{\n\t\t\t\tlef.insert((S3){a,b,c,d,i});\n\t\t\t}\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\trig.insert((S4){a,b,c,d,i});\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%lld\\n\",good.size());\n\twhile(!good.empty())\n\t{\n\t\tset<S1>::iterator it=good.begin();\n\t\tS1 temp=*it;\n\t\tgood.erase(it);\n\t\tL a=temp.a;\n\t\tL b=temp.b;\n\t\tL c=temp.c;\n\t\tL d=temp.d;\n\t\twhile(1)\n\t\t{\n\t\t\tL oknext=0;\n\t\t\tif(c==0)\n\t\t\t{\n\t\t\t\tset<S2>::iterator fin=s2.lower_bound((S2){0,0,0,a,0});\n\t\t\t\tif(fin!=s2.end()&&fin->d==a)\n\t\t\t\t{\n\t\t\t\t\toknext=1;\n\t\t\t\t\ta=fin->a;\n\t\t\t\t\tc=fin->c;\n\t\t\t\t\tL era=fin->a;\n\t\t\t\t\tL erb=fin->b;\n\t\t\t\t\tL erc=fin->c;\n\t\t\t\t\tL erd=fin->d;\n\t\t\t\t\tL ero=fin->ord;\n\t\t\t\t\ts1.erase((S1){era,erb,erc,erd,ero});\n\t\t\t\t\ts2.erase((S2){era,erb,erc,erd,ero});\n\t\t\t\t\ts3.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\ts4.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\tlef.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\trig.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tset<S4>::iterator fin=rig.lower_bound((S4){0,c,0,0,0});\n\t\t\t\tif(fin!=rig.end()&&fin->b==c)\n\t\t\t\t{\n\t\t\t\t\toknext=1;\n\t\t\t\t\ta=fin->a;\n\t\t\t\t\tc=fin->c;\n\t\t\t\t\tL era=fin->a;\n\t\t\t\t\tL erb=fin->b;\n\t\t\t\t\tL erc=fin->c;\n\t\t\t\t\tL erd=fin->d;\n\t\t\t\t\tL ero=fin->ord;\n\t\t\t\t\ts1.erase((S1){era,erb,erc,erd,ero});\n\t\t\t\t\ts2.erase((S2){era,erb,erc,erd,ero});\n\t\t\t\t\ts3.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\ts4.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\tlef.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\trig.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!oknext)\n\t\t\t{\n\t\t\t\tif(d==0)\n\t\t\t\t{\n\t\t\t\t\tset<S1>::iterator fin=s1.lower_bound((S1){0,0,b,0,0});\n\t\t\t\t\tif(fin!=s1.end()&&fin->c==b)\n\t\t\t\t\t{\n\t\t\t\t\t\toknext=1;\n\t\t\t\t\t\tb=fin->b;\n\t\t\t\t\t\td=fin->d;\n\t\t\t\t\t\tL era=fin->a;\n\t\t\t\t\t\tL erb=fin->b;\n\t\t\t\t\t\tL erc=fin->c;\n\t\t\t\t\t\tL erd=fin->d;\n\t\t\t\t\t\tL ero=fin->ord;\n\t\t\t\t\t\ts1.erase((S1){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts2.erase((S2){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts3.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts4.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\t\tlef.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\t\trig.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tset<S3>::iterator fin=lef.lower_bound((S3){d,0,0,0,0});\n\t\t\t\t\tif(fin!=lef.end()&&fin->a==d)\n\t\t\t\t\t{\n\t\t\t\t\t\toknext=1;\n\t\t\t\t\t\tb=fin->b;\n\t\t\t\t\t\td=fin->d;\n\t\t\t\t\t\tL era=fin->a;\n\t\t\t\t\t\tL erb=fin->b;\n\t\t\t\t\t\tL erc=fin->c;\n\t\t\t\t\t\tL erd=fin->d;\n\t\t\t\t\t\tL ero=fin->ord;\n\t\t\t\t\t\ts1.erase((S1){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts2.erase((S2){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts3.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\t\ts4.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\t\tlef.erase((S3){era,erb,erc,erd,ero});\n\t\t\t\t\t\trig.erase((S4){era,erb,erc,erd,ero});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!oknext) break;\n\t\t}\n\t}\n\tif(s1.empty()) puts(\"YES\");\n\telse puts(\"NO\");\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint n,h,f[N],deg[N],vis[N];\nint find(int x) { return f[x]==x?x:f[x]=find(f[x]); }\nint a,b,c,d;\nvoid add(int pl,int pr) {\n\tdeg[pl]--; deg[pr]++;\n\tvis[pl]=vis[pr]=1;\n\tf[find(pl)]=find(pr);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&h);\n\trep(i,0,2*h+2) f[i]=i;\n\trep(i,0,n) {\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint pl=(c==0)?a:c+h+1;\n\t\tint pr=(d==0)?b+h+1:d;\n\t\tadd(pl,pr);\n\t}\n\trep(i,0,h+1) if (deg[i]>0) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\trep(i,h+1,2*h+2) if (deg[i]<0) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\trep(i,0,h+1) if (vis[i]) {\n\t\tbool val=0;\n\t\trep(j,0,2*h+2) if (find(i)==find(j)&&deg[j]<0) val=1;\n\t\tif (!val) { puts(\"NO\"); return 0;}\n\t}\n\trep(i,h+1,2*h+2) if (vis[i]) {\n\t\tbool val=0;\n\t\trep(j,0,2*h+2) if (find(i)==find(j)&&deg[j]>0) val=1;\n\t\tif (!val) { puts(\"NO\"); return 0;}\n\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b)for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=1e5+5;\nint n,h,b,c,d,e,a[N][2],t[2][405],tt[2][405],bz,gs[2];\nvoid R(int &n){\n\tchar c;for(n=0;(c=getchar())<'0'||c>'9';);\n\tfor(;c>='0'&&c<='9';c=getchar())n=n*10+c-48;\n}\nint pd(int x,int y){return 200+(!y?-x:y);}\nint main(){\n\tR(n);R(h);\n\tfo(i,1,n){\n\t\tR(b);R(c);R(d);R(e);\n\t\ta[i][0]=pd(b,d);a[i][1]=pd(c,e);\n\t\tt[0][a[i][0]]++;\n\t\tt[1][a[i][1]]++;\n\t}\n\tmemcpy(tt,t,sizeof(t));\n\tfo(i,1,n){\n\t\tb=a[i][0];c=a[i][1];\n\t\tgs[0]+=b>200;gs[1]+=c>200;\n\t\tif(b>200&&(!t[1][400-b]--||tt[1][400-b]==1&&c+b==400))bz=1;\n\t\tif(c>200&&(!t[0][400-c]--||tt[0][400-c]==1&&c+b==400))bz=1;\n\t\tif(bz)break;\n\t}\n\tif(gs[0]==n||gs[1]==n)bz=1;\n\tif(bz)printf(\"NO\");else printf(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N,H;\nint A[111111],B[111111],C[111111],D[111111];\n\n\nint M=500;\nint deg[1111];\nbool used[1111];\n\nsigned main(){\n    cin>>N>>H;\n    UnionFindTree uf(1111);\n    rep(i,N){\n        cin>>A[i]>>B[i]>>C[i]>>D[i];\n\n        int u,v;\n        if(C[i]==0){\n            u=A[i];\n        }\n        else{\n            u=M+C[i];\n        }\n\n        if(D[i]==0){\n            v=M+B[i];\n        }\n        else{\n            v=D[i];\n        }\n\n        uf.unite(u,v);\n        used[u]=used[v]=true;\n        deg[u]++;\n        deg[v]--;\n\n    }\n\n\n\n    used[2*M]=true;\n    int ei=0,uku=0;\n    rep(i,M){\n        if(deg[i]<0){\n            cout<<\"NO\"<<endl;\n            return 0;\n        }\n        if(deg[i]>0){\n            ei+=deg[i];\n            uf.unite(2*M,i);\n        }\n    }\n\n    for(int i=M;i<2*M;i++){\n        if(deg[i]>0){\n            cout<<\"NO\"<<endl;\n        }\n        if(deg[i]<0){\n            uku+=-deg[i];\n            uf.unite(2*M,i);\n        }\n    }\n\n    if(ei!=uku){\n        cout<<\"NO\"<<endl;\n        return 0;\n    }\n\n\n    rep(i,1111)rep(j,1111){\n        if(!used[i]||!used[j])continue;\n        if(!uf.areSame(i,j)){\n            cout<<\"NO\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 444;\n\nvector<int> E[MAX];\nbool bio[MAX];\n\nint inDeg[MAX];\nint outDeg[MAX];\nint N, H;\n\nvector<int> v;\n\nvoid dfs(int x) {\n  if (bio[x]) return;\n  bio[x] = true;\n  v.push_back(x);\n  for (int y: E[x]) dfs(y);\n}\n\nbool solve() {\n  REP(i, 2*H) {\n    if (!bio[i] && E[i].size()) {\n      v.clear();\n      dfs(i);\n      \n      bool haveStart = false;\n      bool haveEnd = false;\n      \n      int balance = 0;\n      for (int x: v) {\n        if (x < H) {\n          haveStart |= inDeg[x] < outDeg[x];\n          if (inDeg[x] > outDeg[x]) return false;\n          balance += outDeg[x] - inDeg[x];\n        } else {\n          haveEnd |= inDeg[x] > outDeg[x];\n          if (inDeg[x] < outDeg[x]) return false;\n          balance -= inDeg[x] - outDeg[x];\n        }\n      }\n      if (!haveStart || !haveEnd || balance != 0) return false;\n    }\n  }\n  return true;\n}\n\nint main(void) {\n  scanf(\"%d %d\", &N, &H);\n  REP(i, N) {\n    int A, B, C, D;\n    scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n\n    int u = C == 0 ? A-1 : H+C-1;\n    int v = D == 0 ? H+B-1 : D-1;\n\n    E[u].push_back(v);\n    E[v].push_back(u);\n    outDeg[u]++;\n    inDeg[v]++;\n  }\n\n  puts(solve() ? \"YES\" : \"NO\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)) re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint n,h,in[1010],f[1010],v[1010],vis[1010];\nint find(int x){return ((f[x]==x)?x:(f[x]=find(f[x])));}\nint main(){\n\tn=read();h=read();int i,a,b,c,d,l,r;\n\tfor(i=1;i<=1000;i++) f[i]=i;\n\tfor(i=1;i<=n;i++){\n\t\ta=read();b=read();c=read();d=read();\n\t\tif(c) l=-c;\n\t\telse l=a;\n\t\tif(d) r=d;\n\t\telse r=-b;\n\t\tl+=500;r+=500;\n\t\tf[find(l)]=find(r);\n\t\tin[l]++;in[r]--;vis[l]=vis[r]=1;\n//\t\tcout<<\"addedge \"<<l<<' '<<r<<' '<<in[l]<<' '<<in[r]<<' '<<find(l)<<' '<<find(r)<<'\\n';\n\t}\n\tfor(i=1;i<500;i++) if(in[i]>0){puts(\"NO\");return 0;}\n\tfor(i=501;i<=1000;i++) if(in[i]<0){puts(\"NO\");return 0;}\n\tfor(i=1;i<=1000;i++) v[i]=(in[i]!=0);\n\tfor(i=1;i<=1000;i++) v[find(i)]|=v[i];\n\tfor(i=1;i<=1000;i++) if(i==find(i)&&vis[i]&&(!v[i])){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL \t\t\t\t\tlong long\n#define ULL \t\t\t\tunsigned long long\n#define pii \t\t\t\tpair<int,int>\n#define fi \t\t\t\t\tfirst\n#define se \t\t\t\t\tsecond\n#define vi \t\t\t\t\tvector<int>\n#define psb \t\t\t\tpush_back\n#define ppb \t\t\t\tpop_back\n#define all(x)\t\t\t \t(x).begin(),(x).end()\n#define sz(x)\t\t\t\t(int)(x).size()\n#define endln \t\t\t\tprintf(\"\\n\")\n#define gc\t\t\t\t\tgetchar_unlocked\n#define setmin(x)\t\t\tmemset((x), -1, sizeof((x)))\n#define setnul(x)\t\t\tmemset((x), 0, sizeof((x)))\n#ifndef getchar_unlocked\n#define getchar_unlocked \tgetchar\n#endif\nconst int inf = 1e9 + 5;\nconst int mod = 1e9 + 7;\n\ntemplate <typename T>\nvoid gi(T &ret) {\n\tret = 0; char inp=gc(); int kl=1;\n\twhile (inp<'0' || inp>'9') {if (inp=='-') kl=-1; inp=gc();}\n\twhile ('0'<=inp && inp<='9') ret=(ret<<3)+(ret<<1)+(inp-'0'), inp=gc();\n\tif (kl<1) ret=-ret;\n}\n\nconst int MAXH = 205;\nint n, h, lst[MAXH+MAXH], lop[MAXH+MAXH], st[MAXH], in[MAXH+MAXH], out[MAXH+MAXH], use = 0;\nvi adj[MAXH+MAXH];\n\nbool solve() {\n\tfor (int i=1; i<=h; i++) {\n\t\tif (in[i]>out[i]) return 0;\n\t\tif (in[h+i]<out[h+i]) return 0;\n\t}\n\tsetnul(st);\n\tfor (int i=1; i<=h; i++) {\n\t\twhile (lst[i]<lop[i]) {\n\t\t\tint now = i;\n\t\t\twhile (1) {\n\t\t\t\tif (lst[now]>=lop[now]) break;\n\t\t\t\tuse++;\n\t\t\t\tnow = adj[now][lst[now]++];\n\t\t\t}\n\t\t//\tprintf (\"start %d end %d\\n\", i, now);\n\t\t\tif (now<=h) {\n\t\t\t\tif (st[now]) st[now]--;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t\tst[i]++;\n\t\t}\n\t}\n\tif (use==n) return 1;\n\treturn 0;\n}\n\nint main() {\n\tgi(n); gi(h);\n\tsetnul(in); setnul(out);\n\tfor (int i=0; i<n; i++) {\n\t\tint a, b, c, d, l, r;\n\t\tgi(a); gi(b); gi(c); gi(d);\n\t\tif (c==0) l = a;\n\t\telse l = h+c;\n\t\tif (d==0) r = h+b;\n\t\telse r = d;\n//\t\tprintf (\"%d -> %d\\n\", l, r);\n\t\tadj[l].psb(r);\n\t\tout[l]++; in[r]++;\n\t}\n\tfor (int i=1; i<=(h+h); i++) {\n\t\tlst[i] = 0;\n\t\tlop[i] = sz(adj[i]);\n\t}\n\tif (solve()) puts(\"YES\");\n\telse puts(\"NO\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//AtCoder Grand Contest 017 E - Jigsaw\n\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint qr(){int ret = 0,f=1;char ch =getchar();while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();return ret*f;}\n\n#define maxN 100005\n#define maxH 205\n\nint indegree[maxH<<2],outdegree[maxH<<2];\nint active[maxH<<2];\nvoid read(int x,int y){\n    indegree[y]++;\n    outdegree[x]++;\n}\nint f[maxH<<1],pd[maxH<<1];\nint gf(int x){\n    if(f[x] == x) return x;\n    else return f[x] = gf(f[x]);\n}\nint main(){\n    int N = qr(),H = qr();\n    for(int i = 0;i<=(H<<1);i++)\n        f[i] = i;\n    int t1,t2,t3,t4,t5,t6;//上 t + maxN 下 t + maxN + maxH\n    for(int i = 1;i<=N;i++){\n        t1 = qr(),t2 = qr(),t3 = qr(),t4 = qr();\n        if(!t3) t5 = t1;else t5 = -t3;\n        if(!t4) t6 = -t2;else t6 = t4;\n        t5 += H,t6 += H;\n        active[t5] = active[t6] = 1;\n        indegree[t6]++;outdegree[t5]++;\n        f[gf(t5)] = gf(t6);\n    }\n    int mark=1;\n    for(int i = 0;i<=H;i++){\n        if(indegree[i]<outdegree[i])\n            mark=0;\n    }\n    for(int i = H+1;i<=(H<<1);++i){\n        if(indegree[i]>outdegree[i])\n            mark=0;\n    }\n    for(int i = 0;i<=(H<<1);i++){\n        pd[gf(i)] |= (indegree[i] != outdegree[i]);\n    }\n    pd[H] = 1;\n    for(int i = 1;i<=(H<<1);i++){\n        if(active[i] && !pd[gf(i)])\n            mark=0;\n    }\n    if(mark)\n        cout << \"YES\";\n    else cout << \"NO\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\n// clang-format off\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\ntemplate < class T > ostream &operator<<(ostream &o, const stack<T> &a) { o << \"{\"; for(auto tmp = a; tmp.size(); tmp.pop()) o << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top(); o << \"}\"; return o; }\ntemplate <class T, class Container, class Compare > ostream &operator<<(ostream &os, priority_queue<T, Container, Compare> a) { os << \"{ (top) \"; while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\ntemplate <class T, class Container > ostream &operator<<(ostream &os, queue<T, Container> a) { os << \"{ \"; while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n#define DEBUG_OUT cerr\n#endif\n#if !defined(DEBUG_LEFT)\n#define DEBUG_LEFT \"\\e[1;36m\"\n#endif\n#if !defined(DEBUG_RIGHT)\n#define DEBUG_RIGHT \":\\e[m\"\n#endif\n#define dump(...) [&](){auto __debug_tap=make_tuple(__VA_ARGS__);DEBUG_OUT<<DEBUG_LEFT<<__LINE__ << DEBUG_RIGHT << \" \" <<#__VA_ARGS__<<\" = \"<<__debug_tap<<endl;}()\ntemplate < class T > inline void dump2D(T &d, size_t sizey, size_t sizex) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << \"\\t\"; for(size_t j = 0; j < sizex; j++) DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\"); DEBUG_OUT << endl; } }\ntemplate < class T > inline void dump1D(T &d, size_t sizey) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \"); } DEBUG_OUT << endl; }\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { o << \"{\"; for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \", \") << *ite; o << \"}\"; return o; }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \" \") << *ite; return o; }\n#endif\n// clang-format on\n// }}}\n\n\n\nconst int H = 220;\nint in[H * 2];\nint out[H * 2];\nint n, h;\nint cnt1[H * 2], cnt2[H * 2];\nint f[H * 2];\n\n#define POS(x) cout<<((x)?\"POSSIBLE\":\"IMPOSSIBLE\")<<endl;\n#define Pos(x) cout<<((x)?\"Possible\":\"Impossible\")<<endl;\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<endl;\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<endl;\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<endl;\n\n/// --- Union Find {{{ ///\n#include <vector>\nstruct UF {\n  int n;\n  vector< int > par;\n  UF(int n) : n(n), par(n, -1) {}\n  int find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n  int size(int x) { return -par[find(x)]; }\n  bool same(int a, int b) { return find(a) == find(b); }\n  void unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if(a == b) return;\n    if(par[a] < par[b]) swap(a, b);\n    par[b] += par[a];\n    par[a] = b;\n  }\n};\n/// }}}--- ///\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> h;\n  int a, b, c, d;\n  UF uf(H * 2);\n  for(int i = 0; i < n; i++) {\n    cin >> a >> b >> c >> d;\n    int from = 0, to = 0;\n    if(c == 0) from = a;\n    else from = H + c;\n    if(d == 0) to = H + b;\n    else to = d;\n    out[from]++;\n    in[to]++;\n    dump(from, to);\n    uf.unite(from, to);\n  }\n  int ok = 1;\n  for(int i = 0; i < H; i++) {\n    if(in[i] + out[i] == 0) continue;\n    if(in[i] > out[i]) ok = 0;\n    cnt1[uf.find(i)] += out[i] - in[i];\n    f[uf.find(i)] = 1;\n  }\n  for(int i = H; i < H * 2; i++) {\n    if(in[i] + out[i] == 0) continue;\n    if(in[i] < out[i]) ok = 0;\n    cnt2[uf.find(i)] += in[i] - out[i];\n    f[uf.find(i)] = 1;\n  }\n  for(int i = 0; i < H * 2; i++) {\n    if(!f[i]) continue;\n    if(cnt1[i] != cnt2[i]) ok = 0;\n    if(cnt1[i] == 0) ok = 0;\n  }\n  YES(ok);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n\nconst int N = 400 + 10;\n\nint n, deg[N];\n\nint anc[N], mask[N];\n\nint find(int x) { return anc[x] == x ? x : (anc[x] = find(anc[x])); }\n\nvoid init() {\n  int m;\n  scanf(\"%d%d\", &m, &n);\n  std::iota(anc, anc + 2 * n + 1, 0);\n  for (int i = 1; i <= n; ++i) mask[i] = 1, mask[i + n] = 2;\n  while (m--) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    int x = c ? (c + n) : a, y = d ? d : (b + n);\n    --deg[x], ++deg[y];\n    anc[find(x)] = find(y);\n  }\n}\n\nint main() {\n  init();\n  for (int i = 1; i <= n; ++i) if (deg[i] > 0 || deg[i + n] < 0) return puts(\"NO\"), 0;\n  for (int i = 1; i <= 2 * n; ++i) mask[find(i)] |= deg[i];\n  for (int i = 1; i <= n; ++i) if (find(i) == i && !mask[i]) return puts(\"NO\"), 0;\n  puts(\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\ntypedef struct{\n  int to;\n  int cap;\n  int rev;\n}edge;\n\n// node v : distance from s => level[v]\nvoid bfs(vector<vector<edge> > &G, vector<int> &level, int s){\n  fill(level.begin(), level.end(), -1);\n  queue<int> q;\n  q.push(s);\n  level[s] = 0;\n  while(!q.empty()){\n    int e=q.front(); q.pop();\n    for(int i=0; i<G[e].size(); i++){\n      if(G[e][i].cap > 0 && level[G[e][i].to] < 0){\n        level[G[e][i].to] = level[e] + 1;\n        q.push(G[e][i].to);\n      }\n    }\n  }\n}\n\nint dfs(vector<vector<edge> > &G, vector<int> &level, vector<bool> &used, vector<int> &iter, int s, int f,  int t){\n  if(s==t) return f;\n  else{\n    //iter[e] : done searching from v[0] to v[ iter[e]-1 ]\n    for(int &i=iter[s]; i<G[s].size(); i++){\n      //distance from s to v[e][i].to must be longer than dist from s to v\n      if(G[s][i].cap > 0 && level[s] < level[ G[s][i].to ]){\n        int d = dfs(G, level, used, iter, G[s][i].to, min(f, G[s][i].cap), t);\n        if(d>0){\n          G[s][i].cap -= d;\n          G[ G[s][i].to ][ G[s][i].rev ].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n}\n\nint dinic_maxflow(vector<vector<edge> > &G, int s, int t){\n  const int INF = 100000000;\n  int flow=0;\n  while(true){\n    vector<int> level(G.size(), -1);\n    vector<int> iter(G.size(), 0);\n    vector<bool> used(G.size(), false);\n    bfs(G, level, s);\n    if(level[t] < 0) return flow; //unable to achieve to t\n    while(true){\n      int f = dfs(G, level, used, iter, s, INF, t);\n      if(f==0) break;\n      else flow += f;\n    }\n  }\n}\n\nvoid add_edge(vector<vector<edge> > &G, int from, int to, int cap){\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint main(){\n  int n,h;\n  cin >> n,h;\n  vector<int> a(n),b(n),c(n),d(n);\n  for(int i=0; i<n; i++){\n    cin >> a[i],b[i],c[i],d[i];\n  }\n\n  map<pair<int,int>, int> in_cnt;\n  map<pair<int,int>, int> out_cnt;\n  for(int i=0; i<n; i++){\n    if( c[i] == 0 ){\n      in_cnt[ {a[i], 0} ]++;\n    }else{\n      in_cnt[ {c[i], 1} ]++;\n    }\n    if( d[i] == 0 ){\n      out_cnt[ {b[i], 0} ]++;\n    }else{\n      out_cnt[ {d[i], 1} ]++;\n    }\n  }\n\n  map<tuple<int,int,int>, int> dict;\n  int idx = 0;\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n\n  int zero_0 = idx++;\n  int zero_1 = idx++;\n  int source = idx++;\n  int sink = idx++;\n\n  int super_source = idx++;\n  int super_sink = idx++;\n\n  vector<vector<edge>> G(idx);\n\n  add_edge(G, zero_0, zero_1, n+10);\n  add_edge(G, super_source, zero_1, 1);\n  add_edge(G, zero_0, super_sink, 1);\n\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, v, sink, p.second);\n    if( p.first.second == 0 ){\n      add_edge(G, zero_1, v, p.second);\n    }\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, source, v, p.second);\n    auto r = make_tuple(0, p.first.first, p.first.second^1);\n    if( dict.count(r) ){\n      add_edge(G, v, dict[r], p.second);\n    }\n\n    if( p.first.second == 0 ){\n      add_edge(G, v, zero_0, p.second);\n    }\n  }\n\n  int f = 0;\n  f += dinic_maxflow(G, super_source, sink);\n  f += dinic_maxflow(G, source, super_sink);\n  if( f != 2 ){\n    println(\"NO\");\n    return 0;\n  }\n  f--;\n\n  add_edge(G, super_source, source, n+100);\n  add_edge(G, sink, super_sink, n+100);\n\n  f += dinic_maxflow(G, super_source, super_sink);\n  f += dinic_maxflow(G, source, sink);\n\n  println( f==n ? \"YES\" : \"NO\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n, h;\n\nint f(int d, int u){\n\treturn d?(h+d):u;\n}\n\nint g(int d, int u){\n\treturn d?d:(h+u);\n}\n\nint out[810];\nint in[810];\n\nvoid In(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1; i<=n; ++i){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x = f(c, c+a);\n\t\tint y = g(d, d+b);\n\t\tout[x]++; in[y]++;\n\t}\n}\n\nbool check(){\n\tint bal = 0;\n\tfor(int i=1; i<=2*h-1; ++i){\n\t\tif(abs(out[i]-in[i]) > 1) return 0;\n\t\tif(out[i] > in[i]){\n\t\t\tif(i > h) return 0;\n\t\t\t++bal;\n\t\t}\n\t\tif(out[i] < in[i]){\n\t\t\tif(i <= h) return 0;\n\t\t\t--bal;\n\t\t}\n\t}\n\treturn !bal;\n}\n\nint main()\n{\n\tIn();\n\tputs(check()?\"YES\":\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n很巧妙的一道图论题，难度在于建图&猜结论。\n考虑到有两种连接方式：，对于相邻的两块，左边的在上，记为正高度；右边的在上，记为负高度。\n一般地，我们可以用(l,r)表示一块积木：\n如果ci=0, l=ai, 否则, l=-ci。\n如果di=0, r=-bi, 否则, r=di。\n假设在(l',r')的右边放上(l,r)的积木，当且仅当:\n\tl和r'的符号不同\t\t或\t\tr=l'。\n需要满足最左端的l是正数，最右端的r是负数。\n\t\n考虑构造2H个点(-H,-H+1,...,-1,1,2,3,...,H)，\n对于所有(li,ri)连边，\n题目的要求等价于将图划分为若干不相交的路径。\n且所有路径必须从正点出发，负点结束。\n\n题目的条件等价于:\n对于所有正点，出度>=入度。\n对于所有负点，入度>=出度。\n对于所有弱连通块，一定存在点，入度!=出度。\n\n显然，这个是必要条件。而充分条件可以通过构造得出。\n任意选择一正点出发，直到无法再走。\n我们会得到两种集合：\n满足条件的路径，或者一个环。\n\n如何消去环？\n根据条件3，我们可以将环与环（或路径合并），\n最终一定可以找到一个路径与之合并。\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 409;\nint in[maxn], out[maxn], pa[maxn], flag[maxn];\nint n, H, a, b, c, d;\n\nint getpa(int x) {\n\treturn pa[x] == x ? x : pa[x] = getpa(pa[x]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &H);\n\tfor (int i=1; i<=2*H; i++) pa[i] = i;\n\tfor (int i=1; i<=n; i++) {\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tif (c) a = c + H; \n\t\tif (!d) b = b + H; else b = d;\n\t\tout[a]++; in[b]++;\n\t\tpa[getpa(a)] = getpa(b);\n\t}\n\t//for (int i=1; i<=2*H; i++) printf(\"%d %d %d\\n\", i, in[i], out[i]);\n\tfor (int i=1; i<=H; i++)\n\t\tif (out[i] < in[i]) { puts(\"NO\"); return 0; }\n\tfor (int i=H+1; i<=2*H; i++)\n\t\tif (in[i] < out[i]) { puts(\"NO\"); return 0; }\n\tfor (int i=1; i<=2*H; i++)\n\t\tif (in[i] != out[i]) flag[getpa(i)] = 1;\n\tfor (int i=1; i<=2*H; i++)\n\t\tif (pa[i] == i && !flag[i] && in[i] && out[i]) { puts(\"NO\"); return 0; }\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint fa[1010],num[1010];\nbool go[1010],bo[1010];\nint getf(int s){if (fa[s]==s) return s;return fa[s]=getf(fa[s]);}\nint main()\n{\n\tint n;scanf(\"%d%*d\",&n);\n\tfor (int i=1;i<=1000;i++) fa[i]=i;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c,d;scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif (c==0) c=a+500;else c=c+1;\n\t\tif (d==0) d=b+1;else d=d+500;\n\t\tfa[getf(c)]=getf(d);\n\t\tnum[c]++;num[d]--;bo[c]=true;\n\t}\n\tfor (int i=1;i<500;i++) if (num[i]>0) {puts(\"NO\");return 0;}\n\tfor (int i=500;i<1000;i++) if (num[i]<0) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<1000;i++)\n\t{\n\t\tbo[getf(i)]|=bo[i];\n\t\tgo[getf(i)]|=(num[i]!=0);\n\t}\n\tfor (int i=1;i<1000;i++) if ((fa[i]==i)&&(bo[i])&&(!go[i])) {puts(\"NO\");return 0;}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n,h,a,b,c,d,num1,num2;\nint can[201][201];\nint cnt[201][2][2];\nvector<int>v[401];\nbool have[401];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> h;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> a >> b >> c >> d;\n\t\tif(c==0){\n\t\t\tcnt[a][0][0]++;\n\t\t\tnum1=a*2-1;\n\t\t}\n\t\telse{\n\t\t\tcnt[c][0][1]++;\n\t\t\tnum1=c*2;\n\t\t}\n\t\tif(d==0){\n\t\t\tcnt[b][1][0]++;\n\t\t\tnum2=b*2;\n\t\t}\n\t\telse{\n\t\t\tcnt[d][1][1]++;\n\t\t\tnum2=d*2-1;\n\t\t}\n\t\thave[num1]=true;\n\t\tcan[num1][num2]=true;\n\t}\n\tfor(int i=1; i<=h ;i++){\n\t\tif(cnt[i][0][0]<cnt[i][1][1] || cnt[i][1][0]<cnt[i][0][1]){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//check if every cycle visitable\n\tfor(int i=1; i<=2*h ;i++){\n\t\tfor(int j=1; j<=2*h ;j++){\n\t\t\tfor(int k=1; k<=2*h ;k++){\n\t\t\t\tcan[j][k]|=(can[j][i] && can[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=2; i<=2*h ;i+=2){\n\t\tif(!have[i]) continue;\n\t\tbool ok=false;\n\t\tfor(int j=1; j<=2*h ;j+=2){\n\t\t\tif(have[j] && can[j][i]){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e6;\n\nint n, h;\nint a[N], b[N], c[N], d[N], vis[N], in[N], out[N], fa[N];\n\nint read(void) {\n    int s = 0, w = 0;\n    char c = getchar();\n    while (c < '0' || c > '9') w |= c == '-', c = getchar();\n    while (c >= '0' && c <= '9') s = s * 10 + c - 48, c = getchar();\n    return w ? -s : s;\n}\n\nint get(int x) {\n\tif (fa[x] == x) return x;\n\treturn fa[x] = get(fa[x]); \n}\n\nbool check(void)\n{\n\tfor (int i=-h;i<0;++i) \n\t\tif (in[i+h] > out[i+h]) return 0;\n\tfor (int i=1;i<=h;++i)\n\t    if (in[i+h] < out[i+h]) return 0;\n\tfor (int i=-h;i<=h;++i)\n\t    if (in[i+h] != out[i+h]) vis[i+h] = 1;\n\t    else if (in[i+h] +out[i+h] == 0) vis[i+h] = 1;\n\tfor (int i=-h;i<=h;++i)\n\t\tif (vis[get(i)] == 0) return 0;\n\treturn 1;\n\t\n}\n\nint main(void)\n{\n\tn = read(), h = read();\n\tfor (int i=0;i<=1000;++i) fa[i] = i;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\ta[i] = read(); b[i] = read();\n\t\tc[i] = read(); d[i] = read();\n\t\tint x = c[i] == 0 ? h-a[i] : h+c[i];\n\t\tint y = d[i] == 0 ? h+b[i] : h-d[i];\n\t\tout[x] ++, in[y] ++;\n\t\tfa[get(x)] = get(y);\n\t}\n\tif (check()) cout << \"YES\";\n\telse cout << \"NO\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nint n,h;\nint l[220],r[220],fa[420],siz[420],L,R;\nint find(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=400;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c==0)l[a]++,L=a;\n\t\telse r[c]--,L=a;\n\t\tif(d==0)r[b]++,R=b;\n\t\telse l[d]--,R=d;\n\t\tif(find(L)==find(R)){\n\t\t\tsiz[find(L)]++;\n\t\t\tcontinue;\n\t\t}\n\t\tsiz[find(R)]+=siz[find(L)]+1;\n\t\tsiz[find(L)]=0;\n\t\tfa[find(L)]=find(R);\n\t}\n\tint ans=0,cns=0;\n\tfor(int i=1;i<=200;i++){\n\t\tif(l[i]<0||r[i]<0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(l[i]||r[i])ans+=siz[find(i)],siz[find(i)]=0;\n\t}\n\tif(ans!=n)printf(\"NO\\n\");\n\telse printf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,h;\n  cin>>n>>h;\n  vector<Int> a(n),b(n),c(n),d(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i]>>c[i]>>d[i];\n\n  const Int MAX = 300;\n  vector<vector<Int> > G(MAX*2);\n  vector<Int> od(MAX*2,0),id(MAX*2,0);\n  for(Int i=0;i<n;i++){\n    Int l=c[i]==0? a[i]:-c[i];\n    Int r=d[i]==0?-b[i]: d[i];\n    G[MAX+l].emplace_back(MAX+r);\n    od[MAX+l]++;\n    id[MAX+r]++;\n  }\n  \n  auto NO=[](){cout<<\"NO\"<<endl;exit(0);};\n  \n  Int w=0;\n  for(Int i=1;i<MAX;i++){    \n    while(od[MAX+i]>id[MAX+i]){\n      G[MAX+w].emplace_back(MAX+i);\n      od[MAX+w]++;\n      id[MAX+i]++;\n    }\n    while(od[MAX-i]<id[MAX-i]){\n      G[MAX-i].emplace_back(MAX-w);\n      od[MAX-i]++;\n      id[MAX-w]++;\n    }\n    //cout<<i<<\"+:\"<<od[MAX+i]<<\" \"<<id[MAX+i]<<endl;\n    //cout<<i<<\"-:\"<<od[MAX-i]<<\" \"<<id[MAX-i]<<endl;\n    if(od[MAX+i]!=id[MAX+i]) NO();\n    if(od[MAX-i]!=id[MAX-i]) NO();\n  }\n\n  vector<Int> used(MAX*2);\n  queue<Int> q;\n\n  used[MAX+w]=1;\n  q.emplace(MAX+w);\n  \n  while(!q.empty()){\n    Int v=q.front();q.pop();\n    for(Int u:G[v]){\n      if(used[u]) continue;\n      used[u]=1;\n      q.emplace(u);\n    }\n  }\n  \n  for(Int i=0;i<MAX*2;i++)\n    if((id[i]||od[i])&&!used[i]) NO();\n  \n  cout<<\"YES\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\nint c[201][2];\nint e[201][2];\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\tc[b[i].c][0]++; num++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].a][0]++;\n\t\t}\n\t\tif (b[i].d > 0) {\n\t\t\tc[b[i].d][1]++; num++;\n\t\t}\n\t\telse {\n\t\t\te[b[i].b][1]++;\n\t\t}\n\t}\n\tif (num>=n) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\trep(i, 201) {\n\t\trep(j, 2) {\n\t\t\tif (c[i][j] > e[i][j^1]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 1e6 + 6, mod = (int) 0;\nint n, h, see[N], par[N], deg[N], has0[N], has1[N], mark[N];\nvector<int> adj[N];\nint find(int x) { return x == par[x] ? x : par[x] = find(par[x]); }\nvoid unite(int u, int v) {\n\tu = find(u);\n\tv = find(v);\n\tpar[u] = v;\n}\nvoid add_edge(int x, int y) {\n\tdeg[x]--;\n\tdeg[y]++;\n\tmark[x] = mark[y] = 1;\n\tunite(x, y);\n\tadj[x].push_back(y);\n}\nvoid dfs(int v) {\n\tif (see[v]++) return;\n\tfor (int u : adj[v])\n\t\tdfs(u);\n}\n\nint main() {\n\tfor (int v = 0; v < N; ++v) par[v] = v;\n\tcin >> n >> h;\n\tfor (int j = 0; j < n; ++j) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint x, y;\n\t\tif (c == 0) {\n\t\t\tx = a;\n\t\t} else {\n\t\t\tx = h + 1 + c;\t\n\t\t}\n\t\tif (d == 0) {\n\t\t\ty = h + 1 + b;\n\t\t} else {\n\t\t\ty = d;\n\t\t}\n//\t\tcout << x << ' ' << y << endl;\n\t\tadd_edge(x, y);\n\t}\n\tint m = h + 1 + h + 1;\n\tfor (int x = 0; x < m; ++x) {\n\t\tif (deg[x] < 0) {\n\t\t\tdfs(x);\n\t\t}\n\t}\n\tfor (int x = 0; x < m; ++x)\n\t\tif (mark[x] && !see[x]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n/*\tfor (int x = 0; x < m; ++x) {\n\t\tfor (int y = 0; y < m; ++y) {\n\t\t\tif (deg[x] && deg[y] && find(x) != find(y)) {\n\t\t\t\tcout << \"NO\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} */\n\tint odd0 = 0;\n\tint odd1 = 0;\n\tfor (int x = 0; x <= h; ++x) {\n\t//\todd0 += (deg[x] == -1);\n\t\tif (deg[x] > 0) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int x = h + 1; x < m; ++x)  {\n\t//\todd1 += (deg[x] == 1);\n\t\tif (deg[x] < 0) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (odd0 != odd1) {\n\t\tcout << \"NO\\n\";\n\t\treturn 0;\n\t}\n\tcout << \"YES\\n\";\n\t\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define INF 1000000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct MaxFlow\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[SIZE];\n\tint level[SIZE];\n\tint iter[SIZE];\n\tint N;\n\t\n\tvoid init(int X)\n\t{\n\t\tN=X;\n\t}\n\tvoid add(int s,int t,int c)\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow_dfs(int v,int t,int f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tint d=flow_dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s,int t)\n\t{\n\t\tint flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tfor(int i=0;i<N;i++) iter[i]=0;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tint f=flow_dfs(s,t,INF);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\nMaxFlow MT;\nstruct UF\n{\n\tint par[SIZE],rank[SIZE];\n\t\n\tvoid init(int n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpar[i]=i;\n\t\t\trank[i]=1;\n\t\t}\n\t}\n\tint find(int x)\n\t{\n\t\tif(x==par[x]) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y)\n\t{\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y])\n\t\t{\n\t\t\tpar[x]=y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t}\n\t}\n\tbool same(int x,int y)\n\t{\n\t\treturn find(x)==find(y);\n\t}\n};\nUF uf;\nvector <int> vec[SIZE];\nint A[SIZE],B[SIZE],C[SIZE],D[SIZE];\nint out[SIZE],in[SIZE];\n\nint main()\n{\n\tint n,H;\n\tscanf(\"%d %d\",&n,&H);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&A[i],&B[i],&C[i],&D[i]);\n\t\tif(C[i]==0) C[i]=1;\n\t\telse\n\t\t{\n\t\t\tA[i]=C[i];\n\t\t\tC[i]=0;\n\t\t}\n\t\tif(D[i]==0) D[i]=0;\n\t\telse\n\t\t{\n\t\t\tB[i]=D[i];\n\t\t\tD[i]=1;\n\t\t}\n\t}\n\tvector <P> vx;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tvx.push_back(P(A[i],C[i]));\n\t\tvx.push_back(P(B[i],D[i]));\n\t}\n\tsort(vx.begin(),vx.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tuf.init(vx.size()+2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint L=lower_bound(vx.begin(),vx.end(),P(A[i],C[i]))-vx.begin();\n\t\tint R=lower_bound(vx.begin(),vx.end(),P(B[i],D[i]))-vx.begin();\n\t\tout[L]++,in[R]++;\n\t\tuf.unite(L,R);\n\t}\n\tfor(int i=0;i<vx.size();i++)\n\t{\n\t\tif(uf.find(i)==i)\n\t\t{\n\t\t\tvector <int> nd;\n\t\t\tfor(int j=0;j<vx.size();j++)\n\t\t\t{\n\t\t\t\tif(uf.same(i,j))\n\t\t\t\t{\n\t\t\t\t\tnd.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint a=0,b=0;\n\t\t\tfor(int j=0;j<nd.size();j++)\n\t\t\t{\n\t\t\t\tint v=nd[j];\n\t\t\t\tif(in[v]==out[v]) continue;\n\t\t\t\tif(in[v]<out[v])\n\t\t\t\t{\n\t\t\t\t\tif(in[v]+1<out[v]||vx[v].second==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(out[v]+1<in[v]||vx[v].second==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a!=b)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(a==0)\n\t\t\t{\n\t\t\t\ta=0,b=0;\n\t\t\t\tfor(int j=0;j<nd.size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=nd[j];\n\t\t\t\t\tif(vx[v].second==1) a++;\n\t\t\t\t\telse b++;\n\t\t\t\t}\n\t\t\t\tif(a==0||b==0)\n\t\t\t\t{\n\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tMT.init(vx.size()+5);\n\tint S=vx.size(),T=S+1;\n\tint cnt=0;\n\tfor(int i=0;i<vx.size();i++)\n\t{\n\t\tif(in[i]+1==out[i])\n\t\t{\n\t\t\tMT.add(S,i,1);\n\t\t\tcnt++;\n\t\t}\n\t\telse if(out[i]+1==in[i])\n\t\t{\n\t\t\tMT.add(i,T,1);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint L=lower_bound(vx.begin(),vx.end(),P(A[i],C[i]))-vx.begin();\n\t\tint R=lower_bound(vx.begin(),vx.end(),P(B[i],D[i]))-vx.begin();\n\t\tMT.add(L,R,1);\n\t}\n\tbool up=MT.max_flow(S,T)==cnt;\n\tif(up) puts(\"YES\");\n\telse puts(\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<functional>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way,vel &con) {\n\tint n = way.size();\n\tvel dist(n,-1);\n\tdist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front();\n\t\tq.pop();\n\t\tcon.push_back(st);\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nint gr(int now, vvel &chi) {\n\tint ret = 0;\n\tfor(auto to:chi[now]) {\n\t\tret = ret xor (gr(to, chi) + 1);\n\t}\n\treturn ret;\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\th+=3;\n\tvvel way(2 * h);\n\tvvel inv_way(2 * h);\n\tvvel all_way(2 * h);\n\trep(i, n) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint st, to;\n\t\tif (c == 0) { st = a; }\n\t\telse { st = c + h; }\n\t\tif (d == 0) { to = b + h; }\n\t\telse { to = d; }\n\t\tway[st].push_back(to);\n\t\tinv_way[to].push_back(st);\n\t\tall_way[st].push_back(to);\n\t\tall_way[to].push_back(st);\n\t}\n\trep(i, h) {\n\t\tif (way[i].size() < inv_way[i].size()) { cout << \"NO\" << endl; return 0; }\n\t\tif (way[i + h].size() > inv_way[i + h].size()) { cout << \"NO\" << endl; return 0; }\n\t}\n\trep(i, 2 * h) {\n\t\tvel con = {};\n\t\tdis(i, all_way, con);\n\t\tif (con.size() == 1) {\n\t\t\tif (all_way[i].size() > 0) { cout << \"NO\" << endl; return 0; }\n\t\t}\n\t\telse {\n\t\t\tbool fl = false;\n\t\t\tfor (auto pl : con) {\n\t\t\t\tif ((pl<h) and (way[pl].size() > inv_way[pl].size())) { fl = true; }\n\t\t\t}\n\t\t\tif (!fl) { cout << \"NO\" << endl; }\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=405;\nint n,H;\nint rt[MAXN],in[MAXN],ot[MAXN],ok[MAXN],vis[MAXN];\nint findrt(int x){return rt[x]==x?rt[x]:rt[x]=findrt(rt[x]);}\nint main()\n{\n\tn=read();H=read();\n\tfor(int i=1;i<=2*H;i++)rt[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint l,r;\n\t\tif(!c)l=a;else l=-c;\n\t\tif(!d)r=-b;else r=d;\n\t\tl+=H;r+=H;\n\t\tint p=findrt(l),q=findrt(r);\n\t\tif(p!=q)rt[p]=q;\n\t\t++ot[l];++in[r];vis[l]=vis[r]=1;\n\t}\n\tfor(int i=-H;i<0;i++)if(in[i+H]<ot[i+H])return puts(\"NO\"),0;\n\tfor(int i=1;i<=H;i++)if(in[i+H]>ot[i+H])return puts(\"NO\"),0;\n\tfor(int i=-H;i<0;i++)ok[findrt(i+H)]|=in[i+H]!=ot[i+H];\n\tfor(int i=1;i<=H;i++)ok[findrt(i+H)]|=in[i+H]!=ot[i+H];\n\tfor(int i=1;i<=2*H;i++)if(vis[i]&&!ok[findrt(i)])return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nconst int N=1e5;\nint fa[N];inline int find(int x) { return fa[x]==x?x:fa[x]=find(fa[x]); }\nint in[N],out[N];\nbool vis[N],f[N],g[N];\nint main()\n{\n\tint n=gi(),a,b,c,d,l,r,i;gi();\n\tfor (i=0;i<=400;i++) fa[i]=i;\n\tfor (i=1;i<=n;i++) {\n\t\ta=gi(),b=gi(),c=gi(),d=gi();\n\t\tl=c?-c:a;\n\t\tr=d?d:-b;\n\t\tl+=200,r+=200;\n\t\tout[l]++,in[r]++;\n\t\tvis[l]=vis[r]=true;\n\t\tfa[find(l)]=find(r);\n\t}\n\tfor (i=0;i<200;i++)\n\t\tif (out[i]>in[i]) return puts(\"NO\"),0;\n\t\telse if (out[i]!=in[i]) f[find(i)]=true;\n\tfor (i=201;i<=400;i++)\n\t\tif (in[i]>out[i]) return puts(\"NO\"),0;\n\t\telse if (out[i]!=in[i]) g[find(i)]=true;\n\tfor (i=0;i<=400;i++)\n\t\tif (vis[i]&&fa[i]==i&&(!g[i]||!f[i])) return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nint n,h,a[N],b[N],c[N],d[N];\n//是否存在可行流\nstruct edge{int f,t,g;}w[N];\nint s,t,S,T,head[N],nxt[N],cnt=1,I[N],O[N];\nvoid add(int f,int t,int g){\n\t//printf(\"%d->%d g=%d\\n\",f,t,g);\n\tw[++cnt]=(edge){f,t,g};\n\tnxt[cnt]=head[f];\n\thead[f]=cnt;\n\tw[++cnt]=(edge){t,f,0};\n\tnxt[cnt]=head[t];\n\thead[t]=cnt;\n}\nstruct st{\n\tint x,i,df;\n\tst(int X=0,int DF=0){x=X;i=head[x];df=DF;}\n}z[N];\nint top,flow,l[N];\n#define V z[top].x\n#define E z[top].i\n#define F z[top].df\nvoid change(){\n\tint df=F;flow+=df;\n\tfor (int i=top-1;i;i--){\n\t\tw[z[i].i].g-=df;\n\t\tw[z[i].i^1].g+=df;\n\t\tz[i].df-=df;\n\t\tif (!z[i].df) top=i;\n\t}\n}\nqueue<int> Q;\nvoid bfs(){\n\tfor (int i=s;i<=t;i++) l[i]=0;\n\tl[s]=1;Q.push(s);\n\twhile (!Q.empty()){\n\t\tint v=Q.front();Q.pop();\n\t\tfor (int i=head[v];i;i=nxt[i])\n\t\tif (w[i].g&&!l[w[i].t]) l[w[i].t]=l[v]+1,Q.push(w[i].t);\n\t}\n}\nbool dinic(){\n\tbfs();\n\tif (!l[t]) return 0;\n\tz[top=1]=st(s,1e9);\n\twhile (top){\n\t\tif (V==t) change(),top--,E=nxt[E];else\n\t\tif (!E) l[V]=0,top--,E=nxt[E];else\n\t\tif (w[E].g&&l[w[E].t]==l[V]+1)\n\t\t\tz[top+1]=st(w[E].t,min(F,w[E].g)),top++;\n\t\telse E=nxt[E];\n\t}\n\treturn 1;\n}\nbool cir[N],toS[N],toT[N];\nvoid bfs(int S,bool *vis){\n\tQ.push(S);vis[S]=1;\n\twhile (!Q.empty()){\n\t\tint v=Q.front();Q.pop();\n\t\tfor (int i=head[v];i;i=nxt[i])\n\t\tif (w[i].g&&!vis[w[i].t]) vis[w[i].t]=1,Q.push(w[i].t);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tint f=(c[i]?c[i]+h:a[i]),t=(d[i]?d[i]:b[i]+h);\n\t\tI[t]++;O[f]++;\n\t\tif (f==t) cir[f]=1;\n\t}\n\ts=0;S=h*2+1;T=S+1;t=T+1;\n\tadd(T,S,1e9);\n\tfor (int i=1;i<=2*h;i++){\n\t\tif (I[i]) add(s,i,I[i]);\n\t\tif (O[i]) add(i,t,O[i]);\n\t\tif (i>h) add(i,T,1e9);else add(S,i,1e9);\n\t}\n\twhile (dinic());\n\tif (flow!=n) return puts(\"NO\"),0;\n\tfor (int i=2;i<=cnt;i+=2) w[i].g=w[i^1].g,w[i^1].g=0;\n\tbfs(S,toS);\n\tfor (int i=2;i<=cnt;i+=2) swap(w[i].g,w[i^1].g);\n\tbfs(T,toT);\n\tfor (int i=1;i<=h*2;i++)\n\tif (cir[i]&&!toS[i]&&!toT[i]) return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define REP(i, a, b)  for(int i = (a), i##end = (b); i < i##end; ++i)\n#define DREP(i, a, b) for(int i=(a-1), i##end = (b); i >=i##end; --i)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int N = 100000;\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> T read() {\n    T n(0), f(1);\n    char ch = getchar();\n    for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; \n    return n * f;\n}\n\nint n, h;\nbool vis[N + 5];\nint deg[N + 5][2];\n\nint fa[N + 5];\nint findset(int u) {\n    return fa[u] == u ? u : fa[u] = findset(fa[u]);\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    n = read<int>();\n    h = read<int>();\n\n    for(int i = 0; i <= (h<<1); ++i) fa[i] = i;\n\n    for(int i = 1; i <= n; ++i) {\n        int a, b, c, d, x, y;\n        a = read<int>(); b = read<int>();\n        c = read<int>(); d = read<int>();\n\n        if(c == 0) x = h - a; else x = h + c;\n        if(d == 0) y = h + b; else y = h - d;\n\n        ++ deg[x][0], ++ deg[y][1];\n        fa[findset(x)] = findset(y);\n    }\n\n    vector<int> t0, t1;\n    for(int i = 0; i < h; ++i) {\n        if(deg[i][0] < deg[i][1]) return puts(\"NO\"), 0;\n        if(deg[i][0] > deg[i][1]) {\n            vis[findset(i)] = true;\n        }\n    }\n\n    for(int i = h; i <= (h << 1); ++i) {\n        if(deg[i][0] > deg[i][1]) return puts(\"NO\"), 0;\n        if(deg[i][0] < deg[i][1]) {\n            vis[findset(i)] = true;\n        }\n    }\n\n    for(int i = 0; i <= (h << 1); ++i) {\n        if(i == findset(i) && deg[i][0] + deg[i][1] && !vis[i]) \n            return puts(\"NO\"), 0;\n    }\n    puts(\"YES\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2e5+7;\nint in[N],out[N],fa[N],n,h;\nbool vis[N];\ninline int find(int x){while(x!=fa[x])x=fa[x]=fa[fa[x]];return x;}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=0;i<=2*h;++i)fa[i]=i;\n\tfor(int i=1;i<=n;++i){\n\t\tint A,B,C,D;\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tint iL=C==0?A:-C,iR=D==0?-B:D;\n\t\t++in[iL+=h],++out[iR+=h];\n\t\tif(find(iL)!=find(iR))fa[fa[iL]]=fa[iR];\n\t}\n\tbool ok=1;\n\tfor(int i=0;i<=2*h&&ok;++i)\n\tif(in[i]||out[i]){\n\t\tif(i<=h&&in[i]>out[i])ok=0;\n\t\tif(i>h&&in[i]<out[i])ok=0;\n\t\tif(in[i]!=out[i])vis[find(i)]=1;\n\t}\n\tfor(int i=0;i<=2*h&&ok;++i)\n\tif(in[i]||out[i])if(!vis[find(i)])ok=0;\n\tputs(ok?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define nt(x) (x+h)\nnamespace Hao_Nan_A___Wo_Bu_Hui_A___Wo_Hao_Ruo_A\n{\n\tconst int N=101000,M=510;\n\tint begin[M],next[N],to[N];\n\tint ind[M],outd[M];\n\tbool vis[N],inq[N];\n\tint n,h,e;\n\tvoid add(int x,int y)\n\t{\n//\t\tprintf(\"%d -> %d\\n\",x,y);\n\t\tind[y]++;outd[x]++;\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d%d\",&n,&h);e=0;\n\t\tfor(int i=1;i<=h*2;i++)\n\t\t\tind[i]=outd[i]=0;\n\t\tfor(int i=1,A,B,C,D,u,v;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\t\tif(C)u=nt(C);else u=A;\n\t\t\tif(D)v=D;else v=nt(B);\n\t\t\tadd(u,v);\n\t\t}\n\t}\n\tint cntg[M];\n\tbool dfs(int p)\n\t{\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif(!vis[i] && !inq[i])\n\t\t\t{\n\t\t\t\tinq[i]=1;\n\t\t\t\tif(dfs(q=to[i]))\n\t\t\t\t{\n\t\t\t\t\tind[q]--;outd[p]--;\n\t\t\t\t\treturn vis[i]=1;\n\t\t\t\t}\n\t\t\t\tinq[i]=0;\n\t\t\t}\n\t\tif(p>h)return 1;\n\t\telse if(cntg[p]){cntg[p]--;return 1;}\n\t\treturn 0;\n\t}\n\tbool check()\n\t{\n\t\tfor(int i=1;i<=h;i++)\n\t\t\twhile(outd[i])\n\t\t\t\tif(!dfs(i))return 0;\n\t\t\t\telse cntg[i]++;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!vis[i])return 0;\n\t\treturn 1;\n\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tif(check())printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n}\nint main()\n{\n//\tfreopen(\"in\",\"r\",stdin);\n\tHao_Nan_A___Wo_Bu_Hui_A___Wo_Hao_Ruo_A::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define rep(i,j,k) for (i=j;i<=k;i++)\nusing namespace std;\nconst int N=1e5+5,H=405;\nint n,i,u,v,I[H],O[H],fa[H],ok[H],a[N],b[N],c[N],d[N],h;\nint find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]); }\nvoid link(int u,int v) {\n\tint fx=find(u),fy=find(v);\n\tif (fx==fy) return;\n\tfa[fy]=fx;\n}\nint main()\n{\n//\tfreopen(\"jigsaw.in\",\"r\",stdin);\n//\tfreopen(\"jigsaw.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&h);\n\trep(i,1,n) scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\trep(i,1,h+h) fa[i]=i;\n\trep(i,1,n)\n\t{\n\t\tif (!c[i]) u=a[i];\n\t\telse u=c[i]+h;\n\t\tif (!d[i]) v=b[i]+h;\n\t\telse v=d[i];\n\t\tO[u]++; I[v]++;\n\t\tlink(u,v);\n\t}\n\trep(i,1,h)\n\t\tif (O[i]<I[i]) { printf(\"NO\\n\"); return 0; }\n\trep(i,h+1,h+h)\n\t\tif (O[i]>I[i]) { printf(\"NO\\n\"); return 0; }\n\trep(i,1,h+h) if (O[i]!=I[i]) ok[find(i)]=1;\n\trep(i,1,h+h)\n\t\tif (I[i] && !ok[find(i)]) { printf(\"NO\\n\"); return 0; }\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\nint h;\n\n#define MAXX 202\nint lef[MAXX];\nint rig[MAXX];\n\nint deg[MAXX*2];\n\nvector<int> v[MAXX*2];\n\nint belong[MAXX * 2];\ninline int root(int b){\n\tif (belong[b] == -1){\n\t\treturn b;\n\n\t}\n\tbelong[b] = root(belong[b]);\n\treturn belong[b];\n}\nvoid merge(int a, int b){\n\ta = root(a);\n\tb = root(b);\n\tif (a == b){\n\t\treturn;\n\t}\n\tbelong[a] = b;\n}\nmap<int, vector<int> > mp;\n\nbool ava[MAXX];\n\nbool check(vector<int> vv){\n\tbool ng = false;\n\tint restr = 0;\n\tint restl = 0;\n\tint id = -1;\n\tint id2 = -1;\n\tfor (int ii = 0; ii <vv.size();ii++){\n\t\tint ix = vv[ii];\n\t\tif (ix & 1){\n\t\t\tint i = ix / 2;\n\t\t\tif (deg[rig[i]] >= 0){\n\t\t\t\trestr += deg[rig[i]];\n\t\t\t\tif (deg[rig[i]]){\n\t\t\t\t\tid = rig[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tng = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint i = ix / 2;\n\t\t\tif ( deg[lef[i]] <= 0){\n\t\t\t\trestl += -deg[lef[i]];\n\t\t\t\tif (deg[lef[i]] < 0){\n\t\t\t\t\tid2 = lef[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tng = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (restr == 0 || restl == 0){\n\t\treturn false;\n\t}\n\tif (ng){\n\t\treturn false;\n\t}\n\tif (restr == 1 && restl == 1 && v[id].size() == 1 && v[id2].size() == 1 && v[id][0] == v[id2][0]){\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main(){\n\tmemset(belong, -1, sizeof(belong));\n\tfor (int i = 0; i < MAXX; i++){\n\t\tlef[i] = 2 * i;\n\t\trig[i] = lef[i] + 1;\n\t}\n\tcin >> n >> h;\n\tfor (int i = 0; i < n; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint k;\n\t\tif (c){\n\t\t\tdeg[lef[c]]++;\n\t\t\tk = lef[c];\n\t\t\tava[lef[c]] = true;\n\t\t}\n\t\telse{\n\t\t\tdeg[rig[a]]++;\n\t\t\tv[rig[a]].push_back(i);\n\t\t\tk = rig[a];\n\t\t\tava[rig[a]] = true;\n\t\t}\n\t\tif (d){\n\t\t\tdeg[rig[d]]--;\n\t\t\tmerge(k, rig[d]);\n\t\t\tava[rig[d]] = true;\n\t\t}\n\t\telse{\n\t\t\tdeg[lef[b]]--;\n\t\t\tv[lef[b]].push_back(i);\n\t\t\tmerge(k, lef[b]);\n\t\t\tava[lef[b]] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAXX; i++){\n\t\tif(ava[i])mp[root(i)].push_back(i);\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); it++){\n\t\tif (check((*it).second) == false){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define pf push_front\n#define pb2 pop_back\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define pq priority_queue\n#define rep(k,i,j) for(int k = (int)i;k<(int)j;k++)\n#define repd(k,i,j) for(int k = (int)i;k>=(int)j;k--)\n#define ll long long\n#define ALL(a) a.begin(),a.end()\n#define vi vector<int>\n\nusing namespace std;\n\ndouble EPS = 1e-9;\nint INF = 1e9+7;;\nlong long INFLL = 1e17;\ndouble pi = acos(-1);\nint dirx[8] = {-1,0,0,1,-1,-1,1,1};\nint diry[8] = {0,1,-1,0,-1,1,-1,1};\n\nclock_t first_attempt = clock();\ninline void cek_time(){\n\tclock_t cur = clock()- first_attempt;\n\tcerr<<\"TIME : \"<<(double) cur/CLOCKS_PER_SEC<<endl;\n}\ninline void OPEN (string s) {\n  freopen ((s + \".in\").c_str (), \"r\", stdin);\n  freopen ((s + \".out\").c_str (), \"w\", stdout);\n}\n\n//end of template\n\nint n,H;\n\nconst int maxn=  1e5+4;\nint deg[maxn];\nvi adj[maxn];\nvoid add_edge(int a,int b){\n\tdeg[a]++;\n\tdeg[b]--;\n\tadj[a].pb(b);\n//\tprintf(\"%d -> %d\\n\",a,b);\n}\n\nint bisa = 1;\n\nvoid cycle2(int st){\n\tint a = st;\n\twhile(1){\n\t\tif(adj[a].size()==0){bisa=  0;return;}\n\t\tint b = adj[a].back();\n\t\tadj[a].pb2();\n\t\ta = b;\n\t\tif(a==st)return;\n\t}\n}\n\nint flag[maxn];\nvoid cycle(int st){\n\t\n\tint a = st;\n\twhile(1){\n\t\tif(adj[a].size()==0){bisa=  0;return;}\n\t\tflag[a] = 1;\n\t\tint b = adj[a].back();\n\t\tadj[a].pb2();\n\t\ta = b;\n\t\tif(a<H)return;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&H);\n\t\n\tH+=2;\n\trep(k,0,n){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta+= c;\n\t\tb+= d;\n\t\tswap(a,c);swap(b,d);\n\t\t\n\t\tif(!a && !b){\n\t\t\tadd_edge(c,d);\n\t\t}\n\t\tif(!a && b){\n\t\t\tadd_edge(c,b + H);\n\t\t}\n\t\tif(a && !b){\n\t\t\tadd_edge(a+H,d);\n\t\t}\n\t\tif(a && b){\n\t\t\tadd_edge(a+H,b + H);\n\t\t}\n\t}\n\t\n\trep(k,0,H){\n\t\twhile(adj[k].size())cycle(k);\n\t}\n\t\n\trep(k,H,2*H+1){\n\t\twhile(adj[k].size()){\n\t\t\t\n\t\t\tcycle2(k);\n\t\t\tif(!flag[k])bisa = 0;\n\t\t}\n\t}\n\t\n\tprintf(\"%s\\n\",bisa?\"YES\":\"NO\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct Arc{\n    int to;\n    int next;\n};\n#define MAX_E 100010\nArc arc[MAX_E];\nint arc_size;\n#define MAX_H 200\nint head[MAX_H * 2 + 1];\nvoid addArc(int from, int to);\n\nint deg_in[MAX_H * 2 + 1];\nint deg_out[MAX_H * 2 + 1];\n\nint main()\n{\n    int n, h;\n    cin >> n >> h;\n    int a, b, c, d;\n    int i;\n    for(i = 0; i < n; ++i){\n        cin >> a >> b >> c >> d;\n        int x = c == 0 ? a : -c;\n        int y = d == 0 ? -b : d;\n        addArc(x + h, y + h);\n        ++deg_out[x + h];\n        ++deg_in[y + h];\n    }\n    int counts = 0;\n    bool end_tag = false;\n    while(counts < n){\n        for(i = h + 1; i <= 2 * h; ++i){\n            while(deg_out[i] > deg_in[i]){\n                int p = i;\n                while(head[p] > 0){\n                    int j = head[p];\n                    int q = arc[j].to;\n                    --deg_out[p];\n                    --deg_in[q];\n                    ++counts;\n                    head[p] = arc[j].next;\n                    p = q;\n                }\n                if(p > h){\n                    end_tag = true;\n                    break;\n                }\n            }\n            if(end_tag){\n                break;\n            }\n        }\n        if(i > 2 * h || end_tag){\n            break;\n        }\n    }\n    if(counts == n && !end_tag){\n        cout << \"YES\";\n    }\n    else{\n        cout << \"NO\";\n    }\n    return 0;\n}\n\nvoid addArc(int from, int to){\n    arc[++arc_size] = Arc{to, head[from]};\n    head[from] = arc_size;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nvector<int>G[405];\nint in[405];\nint a[100005], b[100005], c[100005], d[100005];\nint vst[405];\nvoid dfs(int now) {\n\tfor(int e:G[now]) {\n\t\tif (vst[e])continue;\n\t\tvst[e] = 1;\n\t\tdfs(e);\n\t}\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\trep(i, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tint x, y;\n\t\tif (c[i] == 0)x = a[i];\n\t\telse x = c[i] + h;\n\t\tif (d[i] == 0)y = b[i] + h;\n\t\telse y = d[i];\n\t\tG[x].push_back(y);\n\t\tin[y]++;\n\t}\n\tint cnt = 0;\n\trep(i, h + 1) {\n\t\tint z = G[i].size();\n\t\tif (z-in[i]==1) {\n\t\t\tcnt++;\n\t\t\tG[0].push_back(i);\n\t\t\tin[i]++;\n\t\t}\n\t\telse if (z != in[i]) {\n\t\t\tputs(\"NO\"); return 0;\n\t\t}\n\t}\n\tfor (int i = h + 1; i <= 2 * h; i++) {\n\t\tint z = G[i].size();\n\t\tif (in[i]-z==1) {\n\t\t\tcnt--;\n\t\t\tG[i].push_back(0);\n\t\t\tin[0]++;\n\t\t}\n\t\telse if (z != in[i]) {\n\t\t\tputs(\"NO\"); return 0;\n\t\t}\n\t}\n\tassert(0);\n\tif (cnt!=0) {\n\t\tputs(\"NO\");\n\t}\n\telse {\n\t\tvst[0] = 1;\n\t\tdfs(0);\n\t\trep(i, 2 * h + 1) {\n\t\t\tif (vst[i] == 0 && (in[i]||G[i].size())) {\n\t\t\t\tputs(\"NO\"); return 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(\"YES\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct Arc{\n    int to;\n    int next;\n};\n#define MAX_E 100010\nArc arc[MAX_E];;\nint arc_size;\n#define MAX_H 200\nint head[MAX_H * 2 + 1];\nvoid addArc(int from, int to);\n\nint deg_in[MAX_H * 2 + 1];\nint deg_out[MAX_H * 2 + 1];\nint path[MAX_E];\nint path_size;\nint edge_size;\nint circle_size;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n, h;\n    cin >> n >> h;\n    int a, b, c, d;\n    int i;\n    for(i = 0; i < n; ++i){\n        cin >> a >> b >> c >> d;\n        int x = c == 0 ? a : -c;\n        int y = d == 0 ? -b : d;\n        addArc(x + h, y + h);\n        ++deg_out[x + h];\n        ++deg_in[y + h];\n    }\n    bool end_tag = true;\n    while(end_tag){\n        for(i = h + 1; i <= 2 * h; ++i){\n            while(deg_out[i] > deg_in[i]){\n                int p = i;\n                while(head[p] > 0){\n                    path[path_size++] = p;\n                    int j = head[p];\n                    int q = arc[j].to;\n                    --deg_out[p];\n                    --deg_in[q];\n                    head[p] = arc[j].next;\n                    ++edge_size;\n                    p = q;\n                }\n                if(p < h){\n                    path[path_size++] = p;\n                }\n                else{\n                    end_tag = false;\n                }\n            }\n        }\n        if(i > 2 * h){\n            break;\n        }\n    }\n    bool circle = true;\n    if(end_tag && edge_size < n){\n        for(i = 0; i < path_size && circle; ++i){\n            int p = path[i];\n            if(deg_in[p] != deg_out[p]){\n                circle = false;\n                break;\n            }\n            while(deg_out[p] > 0){\n                int j = head[p];\n                int q = arc[j].to;\n                --deg_out[p];\n                --deg_in[q];\n                head[p] = arc[j].next;\n                ++circle_size;\n                p = q;\n            }\n            if(p != path[i]){\n                circle = false;\n                break;\n            }\n        }\n    }\n    if(end_tag && circle && edge_size + circle_size == n){\n        cout << \"YES\";\n    }\n    else{\n        cout << \"NO\";\n    }\n    return 0;\n}\n\nvoid addArc(int from, int to){\n    arc[++arc_size] = Arc{to, head[from]};\n    head[from] = arc_size;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[50000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t\tif (j = l);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]&&c[j][4]==0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t\tif (j = l)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t\tif (n != 0)\n\t\t\tbreak;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 440;\nint n, c, d, l, r, deg[maxn], vis[maxn];\nvector<int> g[maxn];\nvoid add_edge(int l, int r) {\n\tl += maxn/2, r += maxn/2;\n\tdeg[l]++, deg[r]--;\n\tg[l].push_back(r);\n}\nvoid dfs(int v) {\n\tvis[v] = 1;\n\tfor(auto &i : g[v]) if(!vis[i]) dfs(i);\n}\nbool check() {\n\tdfs(0);\n\tfor(int i = 0; i < maxn; i++) if(g[i].size() && (!vis[i] || deg[i])) return false;\n\treturn true;\n}\nint main() {\n\tcin >> n >> r;\n\tmap<int, int> L, R;\n\twhile(n--) {\n\t\tcin >> l >> r >> c >> d;\n\t\tif(c > 0) l = -c;\n\t\tif(d > 0) r = -d;\n\t\tadd_edge(l, -r);\n\t\tif(l < 0) R[-l]--;\n\t\telse L[l]++;\n\t\tif(r < 0) L[-r]--;\n\t\telse R[r]++;\n\t}\n\tfor(auto i : L) {\n\t\tif(i.second < 0) return cout << \"NO\", 0;\n\t\twhile(i.second--) add_edge(-220, i.first);\n\t}\n\tfor(auto i : R) {\n\t\tif(i.second < 0) return cout << \"NO\", 0;\n\t\twhile(i.second--) add_edge(-i.first, -220);\n\t}\n\tcout << (check()?\"YES\":\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,h;\n  int a[20][20];\n  cin>>n;\n  cin>>h;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<4;j++){\n    cin>>a[i][j];\n    }\n  }\n  int flagl=0,flagr=0;\n  for(int k=0;k<n;k++){//对于每一块拼图进行分析\n    for(int l=0;l<n;l++){\n      if(a[k][2]==(a[l][1]+a[l][3])&&(l!=k))\n      {flagl++;a[k][2]=0;a[k][0]=0;a[l][1]=0;a[l][3]=0;}\n      if(a[k][3]==(a[l][0]+a[l][2])&&(l!=k))\n      {flagr++;a[k][1]=0;a[k][3]=0;a[l][0]=0;a[l][2]=0;}\n    }\n    if(k==1&&flagl==0&&flagr==0)\n    {cout<<\"NO\"<<endl;return 0;}\n    if((flagl==0||flagr==0)&&k!=1)\n    {cout<<\"NO\"<<endl;return 0;}\n  }\nif(flagl+flagr==n-1)\n{cout<<\"YES\"<<endl;}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100100;\nint fa[N],f[N],g[N],n,m,vis[N];\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=0;i<=2*m;++i)fa[i]=i;\n\tfor(int i=1;i<=n;++i){\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\t\tint u=c?m+c:m-a,v=d?m-d:m+b;\n\t\tfa[find(u)]=find(v);f[u]++;g[v]++;\n\t}\n\tfor(int i=1;i<=m;++i)\n\t\tif(f[m-i]<g[m-i]||f[m+i]>g[m+i]){cout<<\"NO\\n\";return 0;}\n\tfor(int i=0;i<=2*m;++i)if(f[i]!=g[i])vis[find(i)]=1;\n\tfor(int i=0;i<=2*m;++i)if(f[i]&&g[i]&&!vis[find(i)]){cout<<\"NO\\n\";return 0;}\n\tcout<<\"YES\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <math.h>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 505;\n\nint cnt[maxn],p[maxn],n,m,deg[maxn],usd[maxn];\nint findp(int u) {return p[u]?p[u]=findp(p[u]):u;}\nvoid no() {puts(\"NO\");exit(0);}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"agc017e.in\",\"r\",stdin);\n\t\tfreopen(\"agc017e.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d\",&n,&m);m=m<<1|1;\n\tfor (int x,y,a,b,c,d,i=1;i<=n;i++) {\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tc!=0?x=c<<1|1:x=a<<1;\n\t\td!=0?y=d<<1:y=b<<1|1;\n\t\tdeg[x]++;deg[y]--;usd[x]=usd[y]=1;\n\t\tx=findp(x);y=findp(y);x!=y?p[x]=y:0;\n\t}\n\tfor (int i=1;i<=m;i++)\n\tif (deg[i]) {\n\t\tif (deg[i]>0&&(i&1)) no();\n\t\tif (deg[i]<0&&!(i&1)) no();\n\t}\n\tfor (int i=1;i<=m;i++)\n\t\tif (deg[i]>0) cnt[findp(i)]++;\n\tfor (int i=1;i<=m;i++)\n\t\tif (usd[i]&&!p[i]&&!cnt[i]) no();\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\n#define A(a) ((a)<<1)\n#define B(a) ((a)<<1|1)\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nconst int MAXV = 100007;\nconst int MAXM = 1000007;\n\nstruct eT\n{\n\tvoid setd ( int _u, int _v, int _f, int _l )\n\t{\n\t\tu = _u, v = _v, f = _f, last = _l;\n\t}\n\n\tint u, v, f, last;\n}edge[MAXM];\n\nstruct bT\n{\n\tbT () {}\n\tbT ( int _h, int _l ) : h ( _h ), l ( _l ) {}\n\n\tvoid setd ( int _h, int _l )\n\t{\n\t\th = _h, l = _l;\n\t}\n\n\tbool operator < ( const bT &a ) const\n\t{\n\t\treturn ( h ^ a.h ) ? ( h < a.h ) : ( l < a.l );\n\t}\n\n\tint h, l;\n}bl[MAXN], br[MAXN];\n\nint n, h, S, T;\nint ke, la[MAXV];\n\nint q[MAXV], lev[MAXV];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nvoid addedge ( int u, int v, int fu, int fv );\n\nint dinic ();\nbool bfs ();\nint dfs ( int now, int lim );\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\n\tscanf ( \"%d%d\", &n, &h );\n\tint a, b, c, d;\n\tlpi ( i, 1, n ){\n\t\tscanf ( \"%d%d%d%d\", &a, &b, &c, &d );\n\t\tbl[i].setd ( c, a ), br[i].setd ( d, b );\n\t}\n}\n\nvoid work ()\n{\n\t// main work\n\n\tS = MAXV - 1, T = MAXV - 2;\n\tint SS = MAXV - 3, TT = MAXV - 4;\n\tke = 0;\n\tINIT ( la, -1 );\n\n\tmap < bT, PII > ml, mr;\n\tmap < bT, PII > ::iterator it;\n\n\tAR( int ) keye;\n\tint ks = 0;\n\n\tlpi ( i, 1, n ){\n\t\t++ml[bl[i]].first;\n\t\t++mr[br[i]].first;\n\t}\n\n\tint kl = 0, kr = 0;\n\tfor ( auto &x : ml ) x.second.second = ++kl;\n\tfor ( auto &x : mr ) x.second.second = ++kr;\n\n\tfor ( auto x : ml ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, A( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( A( x.second.second ), TT, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = mr.find ( bT ( 0, x.first.h ) ) ) != mr.end () ){\n\t\t\t\taddedge ( B( it->second.second ), A( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n\t\t\taddedge ( A( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n\tfor ( auto x : mr ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, B( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( B( x.second.second ), SS, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = ml.find ( bT ( 0, x.first.h ) ) ) != ml.end () ){\n\t\t\t\taddedge ( A ( it->second.second ), B( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n\t\t\taddedge ( B( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n//\taddedge ( SS, T, INF, 0 );\n//\taddedge ( TT, T, INF, 0 );\n\n\tif ( ks >= n ){\n\t\tprintf ( \"NO\\n\" );\n\t\treturn;\n\t}\n\n\tdinic ();\n\n\tbool flag = true;\n\tfor ( auto x : keye ){\n\t\tif ( edge[x].f ){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf ( flag ? \"YES\\n\" : \"NO\\n\" );\n}\n\n\n\nvoid addedge ( int u, int v, int fu, int fv )\n{\n\tedge[ke].setd ( u, v, fu, la[u] );\n\tla[u] = ke++;\n\tedge[ke].setd ( v, u, fv, la[v] );\n\tla[v] = ke++;\n}\n\nint dinic ()\n{\n\tint ans = 0;\n\twhile ( bfs () ) ans += dfs ( S, INF );\n\treturn ans;\n}\n\nbool bfs ()\n{\n\tint l = 0, r = 0, now, v;\n\tq[r++] = S;\n\tINIT ( lev, -1 );\n\tlev[S] = 1;\n\twhile ( l < r ){\n\t\tnow = q[l++];\n\t\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\t\tif ( edge[i].f && lev[v=edge[i].v] == -1 ){\n\t\t\t\tlev[v] = lev[now] + 1;\n\t\t\t\tq[r++] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ( lev[T] != -1 );\n}\n\nint dfs ( int now, int lim )\n{\n\tif ( now == T ) return lim;\n\n\tint v, nf = 0, tf;\n\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\tif ( edge[i].f && lev[v=edge[i].v] == lev[now] + 1 ){\n\t\t\ttf = dfs ( v, qmin ( lim-nf, edge[i].f ) );\n\t\t\tnf += tf;\n\t\t\tedge[i].f -= tf, edge[i^1].f += tf;\n\n\t\t\tif ( nf == lim ) break;\n\t\t}\n\t}\n\n\tif ( !nf ) lev[now] = -1;\n\treturn nf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#define eps 1e-10\n#define inf 1e9\n#define For(i,j,k)\tfor(int i=j;i<=k;++i)\n#define Dow(i,j,k)\tfor(int i=k;i>=j;--i)\n#define ll long long\n#define y1 orz\nusing namespace std;\ninline ll read()\n{\n\tll t=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9')\t{if(c=='-')\tf=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')\tt=t*10+c-48,c=getchar();\n\treturn t*f;\n}\nint n,h,F[1001],deg[1001],hav[1001],is_father[1001];\ninline int get(int x){return x==F[x]?F[x]:F[x]=get(F[x]);}\nint x,y,x1,y1,tx,ty;\nint main()\n{\n\tn=read();h=read();\n\tFor(i,1,1000)\tF[i]=i;\n\tFor(i,1,n)\t\n\t{\n\t\tx=read();y=read();x1=read();y1=read();\n\t\tif(x1==0)\ttx=x;else tx=-x1;\n\t\tif(y1==0)\tty=-y;else ty=y1;\n\t\ttx+=500;ty+=500;\n\t\tdeg[tx]++;deg[ty]--;hav[tx]=1;\n//\t\tcout<<tx<<' '<<ty<<endl;\n\t\tF[get(tx)]=get(ty);\n\t}\n\tFor(i,501,1000)\tif(deg[i]<0)\t{puts(\"NO\");return 0;}\t\t\n\tFor(i,1,500)\tif(deg[i]>0)\t{puts(\"NO\");return 0;}\n\tFor(i,1,1000)\t\n\t\thav[get(i)]|=hav[i];\n\tFor(i,1,1000)\n\t\tif(deg[get(i)])is_father[get(i)]=1;\n\tFor(i,1,1000)\t\n\t\tif(hav[i])\n\t\t\tif(F[i]==i&&!is_father[i])\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define cri const register int\n#define re register\n#define END return puts(\"NO\"),0;\nusing namespace std;\nint in[410],out[410],f[410],n,H,c[410],v[410];\nint getf(cri x){ return f[x]==x?x:f[x]=getf(f[x]); }\nint main(){\n\tcin>>n>>H;\n\tfor(int i=1;i<=H+H;i++) f[i]=i;\n\tfor(int i=1,a,b,c,d,L,R;i<=n;i++){\n\t\tcin>>a>>b>>c>>d;\n\t\tif(c) L=-c;else L=a;\n\t\tif(d) R=d;else R=-b;\n\t\tL+=H;R+=H;v[L]=v[R]=1;\n\t\tin[R]++;out[L]++;\n\t\tf[getf(L)]=getf(R);\n\t}\n\tfor(int i=1;i<=H;i++) if(in[i]<out[i]) END;\n\tfor(int i=H+1;i<=H+H;i++) if(in[i]>out[i]) END;\n\tfor(int i=1;i<=H+H;i++) c[getf(i)]|=in[i]!=out[i];\n\tfor(int i=1;i<=H+H;i++) if(v[i]&&!c[getf(i)]) END;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 2123333333\n\nint fa[1010],in[1010],out[1010],n,h;\nbool bo[1010];\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline int find(int x) { return (x==fa[x])?x:fa[x]=find(fa[x]); }\n\nint main()\n{\n\tn=rd();h=rd();\n\tfor (int i=1;i<=h*2;i++) fa[i]=i;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint h1=rd(),h2=rd(),h3=rd(),h4=rd();\n\t\tint x=(!h3)?h1:h3+h,y=(!h4)?h2+h:h4;\n\t\tout[x]++;in[y]++;\n\t\tint f1=find(x),f2=find(y);\n\t\tif (f1!=f2) fa[f1]=f2;\n\t}\n\tfor (int i=1;i<=h;i++) if (in[i]>out[i]) { puts(\"NO\");return 0; }\n\tfor (int i=h+1;i<=h*2;i++) if (in[i]<out[i]) { puts(\"NO\");return 0; }\n\tfor (int i=1;i<=h*2;i++) if (in[i]^out[i]) bo[find(i)]=true;\n\tfor (int i=1;i<=h*2;i++) if (!bo[find(i)]) if (in[i]||out[i]) { puts(\"NO\");return 0; }\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <memory>\n#include <cassert>\n\nusing namespace std;\n\nstruct MaxFlow{\n  typedef long long ll;\n  const ll INF = 1e18;\n  struct Edge{\n    int u,v;\n    ll c,rc;\n    shared_ptr<ll> flow;\n    Edge(int _u, int _v, ll _c, ll _rc = 0):u(_u),v(_v),c(_c),rc(_rc){\n    }\n  };\n  struct FlowTracker{\n    ll cap, rcap;\n    shared_ptr<ll> flow;\n    bool dir;\n    FlowTracker(ll _cap, ll _rcap, shared_ptr<ll> _flow, int _dir):cap(_cap),rcap(_rcap),flow(_flow),dir(_dir){ }\n    ll rem() const {\n      if(dir == 0){\n        return cap-*flow;\n      }\n      else{\n        return rcap+*flow;\n      }\n    }\n    void add_flow(ll f){\n      if(dir == 0)\n        *flow += f;\n      else\n        *flow -= f;\n      assert(*flow <= cap);\n      assert(-*flow <= rcap);\n    }\n    operator ll() const { return rem(); }\n    void operator-=(ll x){ add_flow(x); }\n    void operator+=(ll x){ add_flow(-x); }\n  };\n  int source,sink;\n  vector<vector<int> > adj;\n  vector<vector<FlowTracker> > cap;\n  vector<Edge> edges;\n  MaxFlow(int _source, int _sink):source(_source),sink(_sink){\n    assert(source != sink);\n  }\n  int add_edge(int u, int v, ll c, ll rc = 0){\n    edges.push_back(Edge(u,v,c,rc));\n    return edges.size()-1;\n  }\n  vector<int> now,lvl;\n  void prep(){\n    int max_id = max(source, sink);\n    for(auto edge : edges)\n      max_id = max(max_id, max(edge.u, edge.v));\n    adj.resize(max_id+1);\n    cap.resize(max_id+1);\n    now.resize(max_id+1);\n    lvl.resize(max_id+1);\n    for(auto &edge : edges){\n      auto flow = make_shared<ll>(0);\n      adj[edge.u].push_back(edge.v);\n      cap[edge.u].push_back(FlowTracker(edge.c, edge.rc, flow, 0));\n      if(edge.u != edge.v){\n        adj[edge.v].push_back(edge.u);\n        cap[edge.v].push_back(FlowTracker(edge.c, edge.rc, flow, 1));\n      }\n      assert(cap[edge.u].back() == edge.c);\n      edge.flow = flow;\n    }\n  }\n  bool dinic_bfs(){\n    fill(now.begin(),now.end(),0);\n    fill(lvl.begin(),lvl.end(),0);\n    lvl[source] = 1;\n    vector<int> bfs(1,source);\n    for(int i = 0; i < (int) bfs.size(); ++i){\n      int u = bfs[i];\n      for(int j = 0; j < (int) adj[u].size(); ++j){\n        int v = adj[u][j];\n        if(cap[u][j] > 0 && lvl[v] == 0){\n          lvl[v] = lvl[u]+1;\n          bfs.push_back(v);\n        }\n      }\n    }\n    return lvl[sink] > 0;\n  }\n  ll dinic_dfs(int u, ll flow){\n    if(u == sink)\n      return flow;\n    while(now[u] < (int) adj[u].size()){\n      int v = adj[u][now[u]];\n      if(lvl[v] == lvl[u] + 1 && cap[u][now[u]] != 0){\n        ll res = dinic_dfs(v,min(flow,(ll)cap[u][now[u]]));\n        if(res > 0){\n          cap[u][now[u]] -= res;\n          return res;\n        }\n      }\n      ++now[u];\n    }\n    return 0;\n  }\n  ll calc_max_flow(){\n    prep();\n    ll ans = 0;\n    while(dinic_bfs()){\n      ll cur = 0;\n      do{\n        cur = dinic_dfs(source,INF);\n        ans += cur;\n      }while(cur > 0);\n    }\n    return ans;\n  }\n  ll flow_on_edge(int edge_index){\n    assert(edge_index < (int) edges.size());\n    return *edges[edge_index].flow;\n  }\n};\n\n// auto mf = MaxFlow(1,n);\n// arguments source and sink, memory usage\n// O(largest node index + input size), sink\n// doesn't need to be last index\n// int edge_index;\n// for(int i = 0; i < m; ++i){\n//    int a,b,c;\n//    cin >> a >> b >> c;\n//mf.add\\_edge(a,b,c); // for directed edges\n//      edge_index = mf.add_edge(a,b,c,c); // store edge index if care about flow value\n//   }\n//  cout << mf.calc_max_flow() << '\\n';\n//cout << mf.flow\\_on\\_edge(edge\\_index) << endl; // return flow on this edge\n//}\n\n\nconst int MAX_V = 420;\nconst int INV = 0;\nconst int TERMV = 205;\nconst int SOURCE = 421;\nconst int SINK = 422;\n\nint out [MAX_V];\nint in [MAX_V];\n\nvoid failure () {\n  cout << \"NO\" << endl;\n  exit(0);\n}\n\nvector<int> adj [MAX_V];\nvoid add_edge (int u, int v) {\n  adj[u].push_back(v);\n}\n\nint vis [MAX_V];\nvoid dfs (int u) {\n  vis[u] = 1;\n  for (int nxt : adj[u]) {\n    if (!vis[nxt]) {\n      dfs(nxt);\n    }\n  }\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n  \n  int n, h;\n  cin >> n >> h;\n\n  auto mf = MaxFlow(SOURCE, SINK);\n  vector<pair<pair<int, int>, int>> edges; // <<u, v>, idx>\n  for (int i = 0; i < n; i++) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n\n    int u;\n    if (c == 0) {\n      // left endpoint is an initial node\n      u = INV + a;\n    } else {\n      // left endpoint is a terminal node\n      u = TERMV + c;\n    }\n\n    int v;\n    if (d == 0) {\n      // right endpoint is a terminal node\n      v = TERMV + b;\n    } else {\n      // right endpoint is an initial node\n      v = INV + d;\n    }\n\n    out[u]++;\n    in[v]++;\n\n    int idx = mf.add_edge(u, v, 1);\n    edges.push_back(make_pair(make_pair(u, v), idx));\n  }\n\n  int expf = 0;\n  for (int i = 1; i <= h; i++) {\n    if (in[INV + i] > out[INV + i]) {\n      failure();\n    }\n\n    expf += out[INV + i] - in[INV + i];\n    mf.add_edge(SOURCE, INV + i, out[INV + i] - in[INV + i]);\n  }\n\n  for (int i = 1; i <= h; i++) {\n    if (out[TERMV + i] > in[TERMV + i]) {\n      failure();\n    }\n\n    expf += in[TERMV + i] - out[TERMV + i];\n    mf.add_edge(TERMV + i, SINK, in[TERMV + i] - out[TERMV + i]);\n  }\n\n  int flow = mf.calc_max_flow();\n  expf /= 2;\n\n  if (flow != expf) failure();\n\n  // now we have a bunch of Eulerian cycles left\n  vector<int> tovis;\n  for (auto e : edges) {\n    if (mf.flow_on_edge(e.second) == 0) {\n      add_edge(e.first.first, e.first.second);\n    } else {\n      tovis.push_back(e.first.first);\n      tovis.push_back(e.first.second);\n    }\n  }\n\n  for (int u : tovis) {\n    if (!vis[u]) {\n      dfs(u);\n    }\n  }\n\n  for (int i = 1; i <= h; i++) {\n    if (in[INV + i] != 0) {\n      if (!vis[INV + i]) {\n        failure();\n      }\n    }\n\n    if (in[TERMV + i] != 0) {\n      if (!vis[TERMV + i]) {\n        failure();\n      }\n    }\n  }\n\n  cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int INF=0x7f7f7f7f;\nnamespace G{\n\tconst int N=210*2,E=100000*2+N*2;\n\tint to[E],bro[E],cap[E],head[N],e=0;\n\tint indeg[N],oudeg[N];\n\tint bln[N],dfn[N],low[N],tim=0;\n\tint stk[N],ss=0;\n\tbool instk[N];\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t\tmemset(dfn,0,sizeof(dfn));\n\t\tmemset(instk,0,sizeof(instk));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t\toudeg[u]++,indeg[v]++;\n\t}\n\tvoid tarjan(int x){\n\t\tcout<<\"tarjan(\"<<x<<\")\"<<endl;\n\t\tdfn[x]=low[x]=++tim;\n\t\tstk[ss++]=x,instk[x]=true;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif(dfn[v=to[i]]){\n\t\t\t\tif(instk[v]){\n\t\t\t\t\tapmin(low[x],dfn[v]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttarjan(v);\n\t\t\t\tapmin(low[x],low[v]);\n\t\t\t}\n\t\t}\n\t\tif(dfn[x]==low[x]){\n\t\t\tfor(int v;v=stk[--ss],instk[v]=false,bln[v]=x,v!=x;);\n\t\t}\n\t}\n}\ninline bool Main(){\n\tusing namespace G;\n\tint n=ni,h=ni;\n\tinit();\n\tfor(int i=1,j=h+1;i<=h;i++,j++){\n\t\tae(0,i),ae(j,0);\n\t\tindeg[i]=oudeg[j]=0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint a=ni,b=ni,c=ni,d=ni;\n\t\tae(c?c+h:a,d?d:b+h);\n\t}\n\ttarjan(0);\n\tint cntin=0,cntou=0;\n\tfor(int i=1,j=h+1;i<=h;i++,j++){\n\t\tcout<<\"bln[\"<<i<<\"]=\"<<bln[i]<<\"\\tbln[\"<<j<<\"]=\"<<bln[j]<<endl;\n\t\tif(bln[i]&&(indeg[i]||oudeg[i]))return false;\n\t\tif(bln[j]&&(indeg[j]||oudeg[j]))return false;\n\t\tif(indeg[i]>oudeg[i])return false;\n\t\tif(indeg[j]<oudeg[j])return false;\n\t\tcntin+=oudeg[i]-indeg[i];\n\t\tcntou+=indeg[j]-oudeg[j];\n\t}\n\treturn cntin==cntou;\n}\nint main(){\n\tputs(Main()?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// The previous one should get TLE... My carelessness T^T\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 100003;\nstatic const int MAXH = 209;\n\nstatic const int MAXV = MAXH * 2;\nstatic const int MAXE = 4e6 + 10;\n\nint n, h;\nint head[MAXV], dest[MAXE], next[MAXE];\nbool vis[MAXE] = { false };\n\nint m = 0;\nint in[MAXV] = { 0 }, out[MAXV] = { 0 };\n\ninline void add_edge(int u, int v)\n{\n    dest[m] = v; next[m] = head[u]; head[u] = m++;\n    ++out[u], ++in[v];\n}\n\nint cur[MAXV];\n\nvoid dfs_quq(int u)\n{\n    for (int w = head[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs_quq(dest[w]);\n    }\n}\nvoid dfs(int u)\n{\n    for (int &w = cur[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs(dest[w]);\n    }\n}\n\nstd::vector<int> as, bs;\nbool marked[MAXV] = { false };\n\nint main()\n{\n    scanf(\"%d%d\", &n, &h);\n\n    int verts = (h + 1) * 2;\n    for (int i = 0; i < verts; ++i) head[i] = -1;\n\n#define node_a(_h) ((_h) * 2)\n#define node_b(_h) ((_h) * 2 + 1)\n    for (int i = 0, a, b, c, d; i < n; ++i) {\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        int u, v;\n        u = (c == 0 ? node_b(a) : node_a(c));\n        v = (d == 0 ? node_a(b) : node_b(d));\n        add_edge(u, v);\n    }\n    for (int i = 0; i <= h; ++i) {\n        if (in[node_a(i)] < out[node_a(i)]) { puts(\"NO\"); return 0; }\n        if (in[node_b(i)] > out[node_b(i)]) { puts(\"NO\"); return 0; }\n        for (int r = 0; r < in[node_a(i)] - out[node_a(i)]; ++r) {\n            as.push_back(node_a(i));\n            marked[node_a(i)] = true;\n        }\n        for (int r = 0; r < out[node_b(i)] - in[node_b(i)]; ++r) {\n            bs.push_back(node_b(i));\n            marked[node_b(i)] = true;\n        }\n    }\n    for (int u : as) {\n        if (bs.empty()) { puts(\"NO\"); return 0; }\n        add_edge(u, bs.back());\n        bs.pop_back();\n    }\n\n    for (int i = 0; i < verts; ++i) cur[i] = head[i];\n    if (verts * m <= 2e8)\n        for (int i = 1; i < verts; i += 2) if (marked[i]) dfs_quq(i);\n    else\n        for (int i = 1; i < verts; i += 2) if (marked[i]) dfs(i);\n    for (int i = 0; i < m; ++i) if (!vis[i]) { puts(\"NO\"); return 0; }\n    puts(\"YES\"); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n \n \n\n\n#define NO \"NO\"\n#define YES \"YES\"\nint N, H;\nint L[101010], R[101010];\nint in[505], ou[505];\nint used[505];\n//---------------------------------------------------------------------------------------------------\nvector<int> E[505];\nint vis[505];\nvoid dfs(int cu) {\n    vis[cu] = 1;\n    fore(to, E[cu]) if(!vis[to]) {\n        dfs(to);\n    }\n}\n//---------------------------------------------------------------------------------------------------\nstring solve() {\n    cin >> N >> H;\n\n    // make_edge\n    rep(i, 0, N) {\n        int a, b, c, d; cin >> a >> b >> c >> d;\n\n        int l;\n        if (0 < c) l = -c;\n        else l = a;\n\n        int r;\n        if (0 < d) r = d;\n        else r = -b;\n\n        l += 250, r += 250;\n\n        L[i] = l, R[i] = r;\n    }\n\n    // in/out check\n    rep(i, 0, N) {\n        int l = L[i], r = R[i];\n        ou[l]++; in[r]++;\n    }\n    rep(i, 0, 505) {\n        int x = i - 250;\n        if (0 < x) if (ou[i] < in[i]) return NO;\n        if (x < 0) if (in[i] < ou[i]) return NO;\n    }\n\n    // cycle check\n    rep(i, 0, N) {\n        int l = L[i], r = R[i];\n        E[l].push_back(r);\n    }\n\n    rep(i, 0, 505) {\n        int x = i - 250;\n        if (0 < x) if (ou[i] > in[i]) if (!vis[i]) dfs(i);\n    }\n    rep(i, 0, 505) if (used[i]) if (!vis[i]) return NO;\n\n    return YES;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long  int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<vector<int>>uu(201, vector<int>(201));\n\tvector<vector<int>>us(201, vector<int>(201));\n\tvector<vector<int>>su(201, vector<int>(201));\n\tvector<vector<int>>ss(201, vector<int>(201));\n\tfor (int i = 0; i < N; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif (c&&d) {\n\t\t\tuu[c][d]++;\n\t\t}\n\t\telse if (c) {\n\t\t\tus[c][b]++;\n\t\t}\n\t\telse if (d) {\n\t\t\tsu[a][d]++;\n\t\t}\n\t\telse {\n\t\t\tss[a][b]++;\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tus[i][i] = min(us[i][i], 1);\n\t\tsu[i][i] = min(su[i][i], 1);\n\t}\n\tvector<int>lu(201);\n\tvector<int>ld(201);\n\tvector<int>ru(201);\n\tvector<int>rd(201);\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tlu[i] += uu[i][j];\n\t\t\tlu[i] += us[i][j];\n\t\t\tld[i] += su[i][j];\n\t\t\tld[i] += ss[i][j];\n\t\t\tru[j] += uu[i][j];\n\t\t\tru[j] += su[i][j];\n\t\t\trd[j] += ss[i][j];\n\t\t\trd[j] += us[i][j];\n\t\t}\n\t\tld[i] -= su[i][i];\n\t\trd[i] -= us[i][i];\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\t//cout << i << \" \" << lu[i] << \" \" << ld[i] << \" \" << ru[i] << \" \" << rd[i] << endl;\n\t\tif (lu[i] >= rd[i] || ld[i] <= ru[i]) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstring>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nint N,H,pal;\tint a,b,c,d;\nstruct line{int in,ch;}lines[100000];bool cam(line a,line b){return a.in>b.in;}\nbool v[100000];\nvoid solve(int no,int t)\n{\n\tint st=0;\n\twhile(lines[st].in+lines[no].ch!=0)st++;\n\tif(t==N-1)\n\t{\n\t\tfor(int i=st;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0&&lines[i].ch>=0)\n\t\t\t{pal=1;}\n\t\t\tif(pal)return;\n\t\t}\n\t\tif(lines[no].ch>=0)\n\t\t{\n\t\t\tfor(int i=0;i<N&&lines[i].in>=0;i++)\n\t\t\t{\n\t\t\t\tif(v[i]==0&&lines[i].ch>=0)\n\t\t\t\t{pal=1;}\n\t\t\t\tif(pal)return;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\n\t\tfor(int i=st;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0)\n\t\t\t{\tv[i]=1;\n\t\t\t\tsolve(i,t+1);\n\t\t\t\tv[i]=0;}\n\t\t\tif(pal)return;\n\t\t}\n\t\tif(lines[no].ch>=0)\n\t\t{\n\t\t\tfor(int i=0;i<N&&lines[i].in>=0;i++)\n\t\t\t{\n\t\t\t\tif(v[i]==0)\n\t\t\t\t{\tv[i]=1;\n\t\t\t\t\tsolve(i,t+1);\n\t\t\t\t\tv[i]=0;}\n\t\t\t\tif(pal)return;\n\t\t\t}\n\t\t}\n\t}\n\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\n\tpal=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta=c==0?a:-c;b=d==0?b:-d;\n\t\tlines[i].in=a;lines[i].ch=b;\n\t}\n\tsort(lines,lines+N,cam);\n\tfor(int i=0;i<N&&lines[i].in>=0;i++)\n\t{\n\t\tv[i]=1;\n\t\tsolve(i,1);\n\t\tv[i]=0;\n\t\tif(pal)break;\n\t}\n\tif(pal)printf(\"YES\");\n\telse printf(\"NO\");\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker,\"/STACK:1000000000\")\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<b;++i)\n#define fj(a,b) for(int j=a;j<b;++j)\n#define fo(a,b) for(int o=a;o<b;++o)\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> pii;\n////////////////////\n\nint const N = 1e5 + 41;\nint const H = 241;\n\nint n, h, a[N], b[N], c[N], d[N];\nint deg[H][2], d0[H][2], d1[H][2];\nint w[N][2];\nvector<pii> e[H][2];\n\npii getfrom(int a, int c){\n\tif(c == 0) return mp(a, 1);\n\telse return mp(c, 0);\n}\n\npii getto(int b, int d){\n\tif(d > 0) return mp(d, 1);\n\telse return mp(b, 0);\n}\n\nvoid bad(){\n\tprintf(\"NO\\n\");\n\texit(0);\n}\n\nvoid dfs(pii x){\n\tw[x.first][x.second] = 1;\n\tfi(0, sz(e[x.first][x.second])){\n\t\tpii y = e[x.first][x.second][i];\n\t\tif(!w[y.first][y.second]) dfs(y);\n\t}\n}\n\nvoid solve(){\n\tfi(0, n){\n\t\tpii x = getfrom(a[i], c[i]);\n\t\tpii y = getto(b[i], d[i]);\n\t\te[x.first][x.second].pb(y);\n\t\t++deg[x.first][x.second];\n\t\t--deg[y.first][y.second];\n\t}\n\tfi(1, h+1) fj(0, 2){\n\t\tif(j == 1){\n\t\t\tif(deg[i][j] < 0) bad();\n\t\t}else{\n\t\t\tif(deg[i][j] > 0) bad();\n\t\t}\n\t}\n\tfi(1, h+1) if(deg[i][1] > 0) dfs(mp(i, 1));\n\tfi(1, h+1) fj(0, 2) if(sz(e[i][j]) > 0 && !w[i][j]) bad();\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\t\n\tscanf(\"%d %d\",&n,&h);\n\tfi(0, n) scanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\n\tsolve();\n\n\tprintf(\"YES\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nvector<int>G[405];\nint in[405];\nint a[100005], b[100005], c[100005], d[100005];\nint vst[405];\nvoid dfs(int now) {\n\tfor(int e:G[now]) {\n\t\tif (vst[e])continue;\n\t\tvst[e] = 1;\n\t\tdfs(e);\n\t}\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\trep(i, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tint x, y;\n\t\tif (c[i] == 0)x = a[i];\n\t\telse x = c[i] + h;\n\t\tif (d[i] == 0)y = b[i] + h;\n\t\telse y = d[i];\n\t\tG[x].push_back(y);\n\t\tin[y]++;\n\t}\n\tint cnt = 0;\n\trep(i, h + 1) {\n\t\tint z = G[i].size();\n\t\tif (z-in[i]==1) {\n\t\t\tcnt++;\n\t\t\tG[0].push_back(i);\n\t\t\tin[i]++;\n\t\t}\n\t\telse if (z != in[i]) {\n\t\t\tputs(\"NO\"); return 0;\n\t\t}\n\t}\n\tfor (int i = h + 1; i <= 2 * h; i++) {\n\t\tint z = G[i].size();\n\t\tif (in[i]-z==1) {\n\t\t\tcnt--;\n\t\t\tG[i].push_back(0);\n\t\t\tin[0]++;\n\t\t}\n\t\telse if (z != in[i]) {\n\t\t\tputs(\"NO\"); return 0;\n\t\t}\n\t}\n\tif (cnt!=0) {\n\t\tputs(\"NO\");\n\t}\n\telse {\n\t\tassert(0);\n\t\tvst[0] = 1;\n\t\tdfs(0);\n\t\trep(i, 2 * h + 1) {\n\t\t\tif (vst[i] == 0 && (in[i]||G[i].size())) {\n\t\t\t\tputs(\"NO\"); return 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(\"YES\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, H, A[100009], B[100009], C[100009], D[100009], L[100009], R[100009], deg[100009], cnt;\n\nint main() {\n\tcin >> N >> H; H++;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\t\tif (C[i] == 0) { L[i] = -A[i]; cnt++; } else { L[i] = C[i]; }\n\t\tif (D[i] == 0) { R[i] = -B[i]; cnt++; } else { R[i] = D[i]; }\n\t\tR[i] *= -1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint a1 = 0, a2 = 0;\n\t\tif (L[i] < 0) a1 = H + (-L[i]); else a1 = L[i];\n\t\tif (R[i] < 0) a2 = H + (-R[i]); else a2 = R[i];\n\t\tdeg[a1]++; deg[a2]--;\n\t}\n\tbool OK = true; int V = 0;\n\tfor (int i = 0; i < H; i++) { if (deg[i] > 0) OK = false; }\n\tfor (int i = H; i < 2 * H; i++) { if (deg[i] < 0) OK = false; else V += deg[i]; }\n\n\tif (V == 0 || V != (cnt - N)) OK = false;\n\n\tif (OK == true) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int MAXN=100005,MAXH=405;\n\nint N,H;\nint in[MAXH],out[MAXH];\nint cntS[MAXH],cntT[MAXH];\nbool vis[MAXN];\n\nint fa[MAXH];\nint Root(int x)\n{return fa[x]==0?x:(fa[x]=Root(fa[x]));}\nvoid Union(int x,int y)\n{\n\tint r1=Root(x),r2=Root(y);\n\tif(r1==r2)\n\t\treturn;\n\tfa[r1]=r2;\n}\n\nint ID(int h,int d)\n{return h*2-1+d;}\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint u,v;\n\t\tif(c==0)\n\t\t\tu=ID(a,0);\n\t\telse\n\t\t\tu=ID(c,1);\n\t\tif(d==0)\n\t\t\tv=ID(b,1);\n\t\telse\n\t\t\tv=ID(d,0);\n\t\tout[u]++;\n\t\tin[v]++;\n\t\tvis[u]=vis[v]=true;\n\t\tUnion(u,v);\n\t\t//printf(\"(%d,%d)->(%d,%d)          %d->%d\\n\",(u-1)/2+1,(u&1)^1,(v-1)/2+1,(v&1)^1,u,v);\n\t}\n\t\n\tfor(int i=1;i<=2*H;i++)\n\t{\n\t\tif(in[i]-out[i]>1||out[i]-in[i]>1)\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(in[i]-out[i]==1)\n\t\t{\n\t\t\tif(i&1)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcntT[Root(i)]++;\n\t\t}\n\t\tif(out[i]-in[i]==1)\n\t\t{\n\t\t\tif((i&1)^1)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcntS[Root(i)]++;\n\t\t}\n\t}\n\tfor(int i=1;i<=2*H;i++)\n\t\tif(vis[i]&&fa[i]==0&&(cntS[i]!=cntT[i]||(cntS[i]==0&&cntT[i]==0)))\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"YES\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<20;\nint fa[Q];\nint in[Q],out[Q];\nint gf(int x)\n{return fa[x]==x?x:(fa[x]=gf(fa[x]));}\nvoid ins(int x,int y)\n{\n    out[x]++;\n    in[y]++;\n    int fx=gf(x),fy=gf(y);\n    if(fx!=fy)fa[fx]=fy;\n}\n// int Idiot_Sap(int x,int flow)\n// {\n//     if(x==T)return flow;\n//     int had=0;\n//     for(int t=las[x];t;t=nn[t]){\n//         int y=e[t];\n//         if((!c[t])||dis[x]-1!=dis[y])continue;\n//         int del=Idiot_Sap(y,min(c[t],flow-had));\n//         c[t]-=del;\n//         c[t^1]+=del;\n//         had+=del;\n//         if(dis[S]>=T||had==flow)return had;\n//     }\n//     if(dis[S]>=T)return had;\n//     --cnt[dis[x]];\n//     if(!cnt[dis[x]])dis[S]=T;\n//     cnt[++dis[x]]++;\n//     return had;\n// }\nint had[Q];\nint main()\n{\n    int n,h;\n    cin>>n>>h;\n    for(int i=1,a,b,c,d;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        int x,y;\n        if(c==0)x=a+h;\n        else x=c;\n        if(d==0)y=b;\n        else y=d+h;\n        // printf(\"%d %d LINK\\n\",x,y);\n        ins(x,y);\n    }\n    for(int i=1;i<=h;i++)if(out[i]>in[i])return puts(\"NO\")&0;\n    for(int i=h+1;i<=h+h;i++)if(out[i]<in[i])return puts(\"NO\")&0;\n    for(int i=1;i<=h+h;i++)if(in[i]!=out[i])had[gf(i)]=1;\n    for(int i=1;i<=h+h;i++)if(in[i]&&out[i]&&(!had[gf(i)]))return puts(\"NO\")&0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint inadj[210][2], outadj[210][2], n, h;\nint inadj2[210][2], outadj2[210][2];\npair<int, int> thing(int a, int b)\n{\n\tpair<int, int> ans;\n\tif (b) ans = { b, 0 };\n\telse ans = { a, 1 };\n\treturn ans;\n}\nvector<pair<int, int> > adj[210][2];\nint seen[210][2], c;\nvector<pair<int, int> > components[500];\nvoid dfs(int a, int b, int d)\n{\n\tif (seen[a][b]) return;\n\tseen[a][b] = 1;\n\tcomponents[d].push_back({ a, b });\n\tfor (auto c : adj[a][b]) dfs(c.first, c.second, d);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tpair<int, int> in, out;\n\t\tin = thing(a, c);\n\t\tout = thing(b, d);\n\t\tout.second = !out.second;\n//\t\tprintf(\"%d %d -> %d %d\\n\", in.first, in.second, out.first, out.second);\n\t\toutadj[in.first][in.second]++;\n\t\tinadj[out.first][out.second]++;\n\t\tadj[in.first][in.second].push_back(out);\n\t\tadj[out.first][out.second].push_back(in);\n\t}\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tif (adj[i][j].size() && !seen[i][j]) dfs(i, j, c++);\n\t\t//\tprintf(\"%d:%d - in %d, out %d\\n\", i, j, inadj[i][j], outadj[i][j]);\n\t\t}\n\t}\n\tbool works = 1;\n\tfor (int i = 0; i < c; i++)\n\t{\n\t\tfor (int i = 0; i <= h; i++) inadj2[i][0] = inadj2[i][1] = outadj2[i][0] = outadj2[i][1] = 0;\n\t\tfor (auto b : components[i])\n\t\t{\n\t\t\tinadj2[b.first][b.second] += inadj[b.first][b.second];\n\t\t\toutadj2[b.first][b.second] += outadj[b.first][b.second];\n\t\t}\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\t//printf(\"%d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\tif (inadj2[i][0] - outadj2[i][0] > 0 && inadj2[i][1] - outadj2[i][1] < 0) \n\t\t\t{\n\t\t\t//\tprintf(\"%d\\n\", i);\n\t\t\t\tinadj2[i][0]--; \n\t\t\t\toutadj2[i][1]--;\n\t\t\t//\tprintf(\" %d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\t}\n\t\t}\n\t\tint extra = 0;\n\t\tbool thing = 0;\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t{\n\t\t\t\tif (abs(inadj2[i][j] - outadj2[i][j])) extra += inadj2[i][j] - outadj2[i][j], thing = 1;\n\t\t\t}\n\t\t}\n\t\tif (extra || !thing) works = 0;\n\t}\n//\tprintf(\"Components %d\\n\", c);\n\tif (works) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t5005\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, ind[MAXN], outd[MAXN];\nint tot, cnt, home[MAXN];\nvector <int> A[MAXN];\nbool visited[MAXN];\nvoid work(int pos) {\n\tif (visited[pos]) return;\n\tvisited[pos] = true;\n\thome[++tot] = pos;\n\tcnt += A[pos].size();\n\tfor (unsigned i = 0; i < A[pos].size(); i++)\n\t\twork(A[pos][i]);\n}\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint a, b, c, d, inp, outp;\n\t\tread(a), read(b), read(c), read(d);\n\t\tif (c == 0) inp = a;\n\t\telse inp = m + c;\n\t\tif (d == 0) outp = m + b;\n\t\telse outp = d;\n\t\toutd[inp]++; ind[outp]++;\n\t\tA[inp].push_back(outp);\n\t\tA[outp].push_back(inp);\n\t}\n\tfor (int i = 1; i <= 2 * m; i++) {\n\t\ttot = 0; cnt = 0; work(i);\n\t\tif (tot == 0 || cnt == 0) continue;\n\t\tbool flg = true;\n\t\tfor (int i = 1; i <= tot; i++) {\n\t\t\tif (home[i] <= m && ind[home[i]] > outd[home[i]]) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (home[i] > m && ind[home[i]] < outd[home[i]]) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (ind[home[i]] != outd[home[i]]) flg = false;\n\t\t}\n\t\tif (flg) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 500\nusing namespace std;\nint read(){\n    int nm=0,fh=1; int cw=getchar();\n    for(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n    for(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n    return nm*fh;\n}\nint n,m,e1,e2,h1,h2,cnt,in[M],ot[M],f[M]; bool vs[M];\nint fd(int x){return x==f[x]?x:f[x]=fd(f[x]);}\nint main(){\n    n=read(),m=read();\n    for(int i=1;i<=m;i++) f[i]=i,f[i+m]=i+m,vs[i]=vs[i+m]=false;\n    for(int i=1;i<=n;i++){\n        h1=read(),h2=read(),e1=read(),e2=read();\n        int t1=e1>0?e1:-h1,t2=e2>0?-e2:h2; t1+=m,t2+=m;\n        if(fd(t1)!=fd(t2)) f[fd(t1)]=fd(t2); in[t2]++,ot[t1]++;\n    }\n    for(int i=-m;i<0;i++) if(in[i+m]>ot[i+m]){puts(\"NO\");return 0;}\n    for(int i=1;i<=m;i++) if(in[i+m]<ot[i+m]){puts(\"NO\");return 0;}\n  //  for(int i=0;i<=m+m;i++) if(in[i]!=ot[i]) vs[fd(i)]=true;\n    for(int i=0;i<=m+m;i++) if(in[i]&&ot[i]&&in[i]==ot[i]){puts(\"NO\");return 0;}\n    puts(\"YES\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, H;\nint A[100000];\nint B[100000];\nint C[100000];\nint D[100000];\n\nint deg[401];\nvector<int> G[401];\nbool used[401];\nbool nonzero(int x) {\n  used[x] = true;\n  bool ret = deg[x] != 0;\n  for (int t : G[x]) if (!used[t]) ret |= nonzero(t);\n  return ret;\n}\n\nvoid no() {\n  cout << \"NO\\n\";\n  exit(0);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> H;\n  const int V = 2*H+1;\n  int g = 0;\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    if (C[i]==0&&D[i]==0) g++;\n    if (C[i]>0&&D[i]>0) g--;\n    int u = ((C[i]==0)? +A[i] : -C[i]);\n    int v = ((D[i]==0)? -B[i] : +D[i]);\n    //cout<<u<<\"->\"<<v<<\"\\n\";\n    u += H;\n    v += H;\n    deg[u]++;\n    deg[v]--;\n    G[u].pb(v);\n    G[v].pb(u);\n  }\n  if (g <= 0) no();\n  //rep(i, V) cout<<deg[i]<<\",\";cout<<\"\\n\";\n  int a = 0, b = 0;\n  int s = 0;\n  rep(i, V) {\n    if (i-H > 0) {\n      // -1\n      if (deg[i] >= 0) a += deg[i];\n      else no();\n    }\n    else {\n      // +1\n      if (deg[i] <= 0) b += -deg[i];\n      else no();\n    }\n  }\n  if (a != g || b != g) no();\n  // cycle\n  rep(i, V) if (!used[i] && G[i].size()) {\n    if (!nonzero(i)) no();\n  }\n  cout << \"YES\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nconst int N = 4e2 + 100;\nint f[N];\nint ff(int x) {\n\treturn f[x] == x ? x : f[x] = ff(f[x]);\n}\nint n, h;\nint in[N], ou[N], ok[N];\n\nint main() {\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tf[i] = i;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d, l, r;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tl = c == 0 ? a : h + a;\n\t\tr = d == 0 ? h + b : b;\n\t\t++ou[l], ++in[r];\n\t\tif (ff(l) != ff(r))\n\t\t\tf[ff(l)] = ff(r);\n\t}\n\tfor (int i = 1; i <= h; ++i)\n\t\tif (ou[i] < in[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = h + 1; i <= h + h; ++i)\n\t\tif (in[i] < ou[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (in[i] != ou[i])\n\t\t\tok[ff(i)] = true;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (ff(i) == i && !ok[i] && in[i] + ou[i] != 0)\n\t\t\treturn puts(\"NO\"), 0;\n\treturn puts(\"YES\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 10005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n        if(c == '-') f = -1;\n        c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n        res = res * 10 + c - '0';\n        c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n        out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint g[405][405],f[405][405],ind[405],H,col[405],all;\nint N,A[100005],B[100005],C[100005],D[100005];\nbool vis[405],flag;\nvoid dfs(int u) {\n    all += ind[u];\n    if(ind[u]) flag = 1;\n    vis[u] = 1;\n    for(int i = 1 ; i <= 2 * H ; ++i) {\n        if(f[u][i] && !vis[i]) dfs(i);\n    }\n}\nvoid Solve() {\n    read(N);read(H);\n    for(int i = 1 ; i <= N ; ++i) {\n        read(A[i]);read(B[i]);read(C[i]);read(D[i]);\n        int s,t;\n        if(C[i]) s = C[i];\n        else s = A[i] + H;\n        if(D[i]) t = D[i] + H;\n        else t = B[i];\n        g[s][t]++;ind[t]++;ind[s]--;\n        f[s][t]++;f[t][s]++;\n    }\n    for(int i = 1 ; i <= H ; ++i) {\n        if(ind[i] < 0) {puts(\"NO\");return;}\n    }\n    for(int i = H + 1 ; i <= 2 * H ; ++i) {\n        if(ind[i] > 0) {puts(\"NO\");return;}\n    }\n    for(int i = 1 ; i <= 2 * H ; ++i) {\n        if(!vis[i]) {\n            flag = 0;\n            dfs(i);\n            if(all != 0 || !flag) {puts(\"NO\");return;}\n        }\n    }\n    puts(\"YES\");\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\ntypedef long long ll;\nconst int Imx=2147483647;\nconst int mod=1000000007;\nconst ll Lbig=2e18;\n//My own input/output stream\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putsp()\n#define putii(x,y) puti(x),putnum(y),putsp()\n#define putiii(x,y,z) putii(x,y),putnum(z),putsp()\n#define putsi(x) putnum(x),putendl()\n#define putsii(x,y) puti(x),putnum(y),putendl()\n#define putsiii(x,y,z) putii(x,y),putnum(z),putendl()\ninline ll getnum()\n{\n\tregister ll r=0;register bool ng=0;register char c;c=getchar();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tif(c=='-')ng=1,c=getchar();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=getchar();\n\tif(ng)r=-r;return r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline void putsp(){putchar(' ');}\ninline void putendl(){putchar('\\n');}\ninline char mygetchar(){register char c=getchar();while(c==' '||c=='\\n')c=getchar();return c;}\nint n;\nvector<int> con[100111];\nvector<int> vl[211],vr[211],vrs[211],vls[211];\nint vlit[211],vrit[211],vrsit[211],vlsit[211],tvsz;\nbool vis[100111];\nint A[100111],B[100111],C[100111],D[100111];\nbool fl[211],fr[211];\nint tv[100111];\nint getvl(int x)\n{\n\twhile(vlit[x]<vl[x].size()&&vis[vl[x][vlit[x]]])\n\t{\n\t\tvlit[x]++;\n\t}\n\tif(vlit[x]==vl[x].size())return -1;else return vl[x][vlit[x]];\n}\nint getvr(int x)\n{\n\twhile(vrit[x]<vr[x].size()&&vis[vr[x][vrit[x]]])\n\t{\n\t\tvrit[x]++;\n\t}\n\tif(vrit[x]==vr[x].size())return -1;else return vr[x][vrit[x]];\n}\nint getvls(int x)\n{\n\twhile(vlsit[x]<vls[x].size()&&vis[vls[x][vlsit[x]]])\n\t{\n\t\tvlsit[x]++;\n\t}\n\tif(vlsit[x]==vls[x].size())return -1;else return vls[x][vlsit[x]];\n}\nint getvrs(int x)\n{\n\twhile(vrsit[x]<vrs[x].size()&&vis[vrs[x][vrsit[x]]])\n\t{\n\t\tvrsit[x]++;\n\t}\n\tif(vrsit[x]==vrs[x].size())return -1;else return vrs[x][vrsit[x]];\n}\nint tmpl[100111],tmplsz;\nint tmpr[100111],tmprsz;\nvector<int> rep;\nint FLAG;\nint dfs(int s,int x,int pred=1,bool flag=0)\n{\n//\tcout<<\"dfs:\"<<s<<\" \"<<x<<\" \"<<pred<<\" \"<<flag<<endl;\n\ttv[tvsz++]=x;\n\tif(vis[s]&&s==x)\n\t{\n\t\tif(FLAG)\n\t\t{\n\t\t\treturn flag;\n\t\t}\n\t\treturn 0;\n\t}\n//\tvis[x]=1;\n\tint a=A[x],b=B[x],c=C[x],d=D[x],u=-1;\n//\tcout<<\"dfs:\"<<x<<\" \"<<pred<<\" \"<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\tif(pred!=1)\n\t{\n\t\tif(c==0)u=getvrs(a);\n\t\telse u=getvr(c);\n\t\tif(u!=-1)\n\t\t{\n\t\t\tif(c==0)tmpl[tmplsz++]=a,flag|=fl[a];\n\t\t\telse tmpr[tmprsz++]=c,flag|=fr[c];\n\t\t\tvis[u]=1;\n\t\t\treturn dfs(s,u,-1,flag);\n\t\t}\n\t\telse if(c>0)return -1;\n\t}\n\tif(pred!=-1)\n\t{\n\t\tif(d==0)u=getvls(b);\n\t\telse u=getvl(d);\n\t\tif(u!=-1)\n\t\t{\n\t\t\tif(d==0)tmpr[tmplsz++]=b,flag|=fr[b];\n\t\t\telse tmpl[tmprsz++]=d,flag|=fl[d];\n\t\t\tvis[u]=1;\n\t\t\treturn dfs(s,u,1,flag);\n\t\t}\n\t\telse if(d>0)return -1;\n\t}\n\treturn 1;\n}\nint main()\n{\n\tint tmp;\n\tgetii(n,tmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tgetii(a,b);\n\t\tgetii(c,d);\n\t\tA[i]=a;\n\t\tB[i]=b;\n\t\tC[i]=c;\n\t\tD[i]=d;\n\t\tif(c==0)\n\t\t{\n\t\t\tvl[a].PB(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvls[c].PB(i);\n\t\t}\n\t\tif(d==0)\n\t\t{\n\t\t\tvr[b].PB(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvrs[d].PB(i);\n\t\t}\n\t}\n\tint cnt0=0,cnt1=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(vis[i])continue;\n\t\ttmplsz=0;\n\t\ttmprsz=0;\n\t\ttvsz=0;\n\t\tint type=dfs(i,i,1);\n\t\tif(type==-1)\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\telse if(type==0)\n\t\t{\n\t\t\tfor(int j=0;j<tvsz;j++)\n\t\t\t{\n\t\t\t\trep.PB(tv[j]);\n\t\t\t}\n\t\t}\n\t\telse if(type==1)\n\t\t{\n\t\t\tcnt1++;\n\t\t\tfor(int j=0;j<tmplsz;j++)\n\t\t\t{\n\t\t\t\tfl[tmpl[j]]=1;\n\t\t\t}\n\t\t\tfor(int j=0;j<tmprsz;j++)\n\t\t\t{\n\t\t\t\tfr[tmpr[j]]=1;\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=0;i<5;i++)cout<<chkl[i]<<\" \";cout<<endl;\n//\tfor(int i=0;i<5;i++)cout<<chkr[i]<<\" \";cout<<endl;\n\tfor(int i=0;i<rep.size();i++)\n\t{\n//\t\tcout<<rep[i]<<\" \";\n\t\tvis[rep[i]]=0;\n\t}\n\tFLAG=1;\n\t\n\tmemset(vlit,0,sizeof(vlit));\n\tmemset(vrit,0,sizeof(vrit));\n\tmemset(vlsit,0,sizeof(vlsit));\n\tmemset(vrsit,0,sizeof(vrsit));\n\t\n\tfor(int ii=0;ii<rep.size();ii++)\n\t{\n\t\tint i=rep[ii];\n\t\tif(vis[i])continue;\n\t\tint type=dfs(i,i,1);\n//\t\tcout<<\"type=\"<<type<<endl;\n\t\tif(type<1)\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tbool ok=1;\n//\tfor(int i=0;i<211;i++)ok&=chkl[i]==0||fl[i];\n//\tfor(int i=0;i<211;i++)ok&=chkr[i]==0||fr[i];\n\tif(cnt1>0&&ok)puts(\"YES\");else puts(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\nusing namespace std;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nint n,h;\nint cl[205],cr[205];\nint main(){\n\tn=read(),h=read();\n\tinc(i,1,n){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tif(!c) cl[a]++;\n\t\telse cr[c]--;\n\t\tif(!d) cr[b]++;\n\t\telse cl[d]--;\n\t}\n\tbool fl=0,fr=0;\n\tinc(i,1,h){\n\t\tif(cl[i]>0) fl=1;\n\t\telse if(cl[i]<0) return puts(\"No\"),0;\n\t\tif(cr[i]>0) fr=1;\n\t\telse if(cr[i]<0) return puts(\"No\"),0;\t\n\t}\n\tif(fl&&fr) puts(\"YES\");\n\telse puts(\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxm=2e5+10;\nconst int base=210;\n\nint n,H,in[500],out[500],cnt;\nbool diff[500],vis[500];\nint tote,FIR[500],TO[maxm],NEXT[maxm];\n\nvoid addedge(int u,int v)\n{\n//\tprintf(\"%d %d\\n\",u,v);\n\tu+=base; v+=base;\n\tout[u]++; in[v]++;\n\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tFIR[u]=tote;\n\n\tTO[++tote]=u;\n\tNEXT[tote]=FIR[v];\n\tFIR[v]=tote;\n}\n\nvoid dfs(int u)\n{\n\tif (vis[u]) return;\n\tvis[u]=1;\n\tcnt+=diff[u];\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\tdfs(TO[p]);\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,a,b,c,d;\n\tscanf(\"%d%d\",&n,&H);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\taddedge(c?-c:a,d?d:-b);\n\t}\n\n\tfor (i=-200;i<=200;i++)\n\t\tif (out[base+i]!=in[base+i])\n\t\t{\n\t\t\tdiff[base+i]=1;\n//\t\t\tprintf(\"%d : %d\\n\",i,out[base+i]-in[base+i]);\n//\t\t\tprintf(\"%d\\n\",(i<0)^(out[base+i]<in[base+i]));\n\t\t\tif ((i<0)^(out[base+i]<in[base+i]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\tfor (i=-200;i<=200;i++)\n\t\tif (!vis[base+i]&&FIR[base+i])\n\t\t{\n\t\t\tcnt=0;\n\t\t\tdfs(base+i);\n\t\t\tif (!cnt)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)) re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint n,h,in[1010],f[1010],v[1010],vis[1010];\nint find(int x){return ((f[x]==x)?x:(f[x]=find(f[x])));}\nint main(){\n\tn=read();h=read();int i,a,b,c,d,l,r;\n\tfor(i=1;i<=1000;i++) f[i]=i;\n\tfor(i=1;i<=n;i++){\n\t\ta=read();b=read();c=read();d=read();\n\t\tif(c) l=-c;\n\t\telse l=a;\n\t\tif(d) r=d;\n\t\telse r=-b;\n\t\tl+=500;r+=500;\n\t\tf[find(l)]=find(r);\n\t\tin[l]++;in[r]--;vis[l]=vis[r]=1;\n//\t\tcout<<\"addedge \"<<l<<' '<<r<<' '<<in[l]<<' '<<in[r]<<' '<<find(l)<<' '<<find(r)<<'\\n';\n\t}\n\tfor(i=1;i<500;i++) if(in[i]>0){puts(\"NO\");return 0;}\n\tfor(i=501;i<=1000;i++) if(in[i]<0){puts(\"NO\");return 0;}\n\tfor(i=1;i<=1000;i++) v[i]=(in[i]!=0);\n\tfor(i=1;i<=1000;i++) v[find(i)]|=v[i];\n\tfor(i=1;i<=1000;i++) if(i==find(i)&&vis[i]&&(!v[i])){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nconst int N = 4e2 + 100;\nint f[N];\nint ff(int x) {\n\treturn f[x] == x ? x : f[x] = ff(f[x]);\n}\nint n, h;\nint in[N], ou[N], ok[N];\n\nint main() {\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tf[i] = i;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d, l, r;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tl = c == 0 ? a : h + a;\n\t\tr = d == 0 ? h + b : b;\n\t\t++ou[l], ++in[r];\n\t\tif (ff(l) != ff(r))\n\t\t\tf[ff(l)] = ff(r);\n\t}\n\tfor (int i = 1; i <= h; ++i)\n\t\tif (ou[i] < in[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = h + 1; i <= h + h; ++i)\n\t\tif (in[i] < ou[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (in[i] != ou[i])\n\t\t\tok[ff(i)] = true;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (ff(i) == i && !ok[i])\n\t\t\treturn puts(\"NO\"), 0;\n\treturn puts(\"YES\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define INF 1000000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct MaxFlow\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[SIZE];\n\tint level[SIZE];\n\tint iter[SIZE];\n\tint N;\n\t\n\tvoid init(int X)\n\t{\n\t\tN=X;\n\t}\n\tvoid add(int s,int t,int c)\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow_dfs(int v,int t,int f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tint d=flow_dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s,int t)\n\t{\n\t\tint flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tfor(int i=0;i<N;i++) iter[i]=0;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tint f=flow_dfs(s,t,INF);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\nMaxFlow MT;\nstruct UF\n{\n\tint par[SIZE],rank[SIZE];\n\t\n\tvoid init(int n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpar[i]=i;\n\t\t\trank[i]=1;\n\t\t}\n\t}\n\tint find(int x)\n\t{\n\t\tif(x==par[x]) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y)\n\t{\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y])\n\t\t{\n\t\t\tpar[x]=y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t}\n\t}\n\tbool same(int x,int y)\n\t{\n\t\treturn find(x)==find(y);\n\t}\n};\nUF uf;\nvector <int> vec[SIZE];\nint A[SIZE],B[SIZE],C[SIZE],D[SIZE];\nint out[SIZE],in[SIZE];\n\nint main()\n{\n\tint n,H;\n\tscanf(\"%d %d\",&n,&H);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&A[i],&B[i],&C[i],&D[i]);\n\t\tif(C[i]==0) C[i]=1;\n\t\telse\n\t\t{\n\t\t\tA[i]=C[i];\n\t\t\tC[i]=0;\n\t\t}\n\t\tif(D[i]==0) D[i]=0;\n\t\telse\n\t\t{\n\t\t\tB[i]=D[i];\n\t\t\tD[i]=1;\n\t\t}\n\t}\n\tvector <P> vx;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tvx.push_back(P(A[i],C[i]));\n\t\tvx.push_back(P(B[i],D[i]));\n\t}\n\tsort(vx.begin(),vx.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tuf.init(vx.size()+2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint L=lower_bound(vx.begin(),vx.end(),P(A[i],C[i]))-vx.begin();\n\t\tint R=lower_bound(vx.begin(),vx.end(),P(B[i],D[i]))-vx.begin();\n\t\tout[L]++,in[R]++;\n\t\tuf.unite(L,R);\n\t}\n\tfor(int i=0;i<vx.size();i++)\n\t{\n\t\tif(uf.find(i)==i)\n\t\t{\n\t\t\tvector <int> nd;\n\t\t\tfor(int j=0;j<vx.size();j++)\n\t\t\t{\n\t\t\t\tif(uf.same(i,j))\n\t\t\t\t{\n\t\t\t\t\tnd.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint a=0,b=0;\n\t\t\tfor(int j=0;j<nd.size();j++)\n\t\t\t{\n\t\t\t\tint v=nd[j];\n\t\t\t\tif(in[v]==out[v]) continue;\n\t\t\t\tif(in[v]<out[v])\n\t\t\t\t{\n\t\t\t\t\tif(in[v]+1<out[v]||vx[v].second==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(out[v]+1<in[v]||vx[v].second==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a!=b||a==0)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tMT.init(vx.size()+5);\n\tint S=vx.size(),T=S+1;\n\tint cnt=0;\n\tfor(int i=0;i<vx.size();i++)\n\t{\n\t\tif(in[i]+1==out[i])\n\t\t{\n\t\t\tMT.add(S,i,1);\n\t\t\tcnt++;\n\t\t}\n\t\telse if(out[i]+1==in[i])\n\t\t{\n\t\t\tMT.add(i,T,1);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint L=lower_bound(vx.begin(),vx.end(),P(A[i],C[i]))-vx.begin();\n\t\tint R=lower_bound(vx.begin(),vx.end(),P(B[i],D[i]))-vx.begin();\n\t\tMT.add(L,R,1);\n\t}\n\tbool up=MT.max_flow(S,T)==cnt;\n\tif(up) puts(\"YES\");\n\telse puts(\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=1000005;\nint n,h,i,j,k,l,ans,A,B,C,D,g[405][405],u[N],p[N],ind[N],outd[N];\nbool vis[N],ok[N];\nint find(int x)\n{\n\treturn p[x]==-1?x:p[x]=find(p[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tif(C)\n\t\t\tA=C+h;\n\t\tif(D)\n\t\t\tB=D+h;\n\t\tg[A][B<h?B+h:B-h]++;\n\t\tvis[A]=vis[B<h?B+h:B-h]=true;\n\t}\n\tfor(i=0;i<2*h;++i)\n\t\tfor(j=0;j<2*h;++j)\n\t\t\tind[j]+=g[i][j],outd[i]+=g[i][j];\n\tfor(i=0;i<h;++i)\n\t\tif(outd[i]<ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=h;i<2*h;++i)\n\t\tif(outd[i]>ind[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=0;i<2*h;++i)\n\t\tp[i]=-1;\n\tfor(i=0;i<2*h;++i)\n\t\tfor(j=0;j<2*h;++j)\n\t\t\tif(g[i][j]&&find(i)!=find(j))\n\t\t\t\tp[find(i)]=find(j);\n\tfor(i=0;i<2*h;++i)\n\t\tif(outd[i]!=ind[i])\n\t\t\tok[find(i)]=true;\n\t/*for(i=0;i<2*h;++i)\n\t\tif(find(i)==i&&!ok[i]&&vis[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}*/\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N, H, A, B, C, D;\n    cin >> N >> H;\n    map<int, int> LA, LB, RA, RB, SA, SB;\n    for (int i = 0;i < N;i++) {\n    \tcin >> A >> B >> C >> D;\n    \t// Process Left\n    \tif (C == 0) LA[A]++;\n    \telse LB[C]++;\n    \t// Process Right\n    \tif (D == 0) RA[B]++;\n    \telse RB[D]++;\n\n    \tif (C == 0 && D == A) SA[A] = 1;\n    \tif (D == 0 && C == B) SB[B] = 1;\n    }\n    map<int, int>::iterator it;\n    for (it = LB.begin();it != LB.end();++it) {\n    \tint c = it->first;\n    \tint d = it->second;\n    \tint e = SB[c];\n    \tif (RA[c] < d || (e && RA[c] == d)) {\n    \t\tcout << \"NO\" << endl;\n    \t\treturn 0;\n    \t}\n    \tRA[c] -= d;\n    }\n    for (it = RB.begin();it != RB.end();++it) {\n    \tint c = it->first;\n    \tint d = it->second;\n    \tint e = SA[c];\n    \tif (LA[c] < d || (e && LA[c] == d)) {\n    \t\tcout << \"NO\" << endl;\n    \t\treturn 0;\n    \t}\n    \tLA[c] -= d;\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 50;\n\nint n , h , ins[maxn] , outs[maxn] , vis[maxn];\nvector < int > edge[maxn];\nset < int > wr;\n\nvoid dfs( int u ){\n\tfor(auto v : edge[u]){\n\t\tif( vis[v] )\n\t\t\tcontinue;\n\t\tvis[v] = 1;\n\t\tdfs( v );\n\t}\n}\n\nint main( int argc , char * argv[] ){\n\tscanf( \"%d%d\" , & n , & h );\n\tfor(int i = 1 ; i <= n ; ++ i){\n\t\tint a , b , c , d;\n\t\tscanf( \"%d%d%d%d\" , & a , & b , & c , & d );\n\t\tint u , v;\n\t\tif( d == 0 )\n\t\t\tu = b + h + 1;\n\t\telse\n\t\t\tu = d;\n\t\tif( c == 0 )\n\t\t\tv = a;\n\t\telse\n\t\t\tv = c + h + 1;\n\t\touts[u] ++ ;\n\t\tins[v] ++ ;\n\t\tedge[u].emplace_back( v );\n\t\tedge[v].emplace_back( u );\n\t\twr.insert( u );\n\t\twr.insert( v );\n\t}\n\tint base = *wr.begin();\n\tvis[base] = 1;\n\tdfs( base );\n\tfor(auto it : wr)\n\t\tif(!vis[it]){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tint cnt = 0;\n\tfor(auto it : wr){\n\t\tint z = abs( ins[it] - outs[it] );\n\t\tif( z != 0 && z != 1 ){\n\t\t\tputs( \"NO\" );\n\t\t\treturn 0;\n\t\t}\n\t\tif( z == 1 )\n\t\t\t++ cnt;\n\t}\n\tif( cnt == 0 || cnt == 2 )\n\t\tputs( \"NO\" );\n\telse\n\t\tputs( \"YES\" );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 405\n#define o 203\nusing namespace std;\n\nint n,H,in[maxn];\nint F[maxn],hd[maxn],sz[maxn];\nint Find(int u){ return !F[u] ? u : F[u] = Find(F[u]); }\n\nint main(){\n\tscanf(\"%d%d\",&n,&H);\n\tfor(int i=1;i<=n;i++){\n\t\tint A,B,C,D;\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tint x , y;\n\t\tif(C == 0) x = A;\n\t\telse x = - C;\n\t\tif(D == 0) y = -B;\n\t\telse y = D;\n\t\tx += o , y += o;\n\t\tin[y] ++ ,in[x] --;\n\t\tif(Find(x) != Find(y))\n\t\t\tF[Find(x)] = Find(y);\n\t\tsz[Find(y)] = 2; \n\t}\n\tbool ER = 0;\n\tfor(int i=1;i<maxn;i++){\n\t\tif(i < o && in[i] < 0) ER = 1;\n\t\tif(i > o && in[i] > 0) ER = 1;\n\t\tif(i > o && in[i] < 0) hd[Find(i)] = 1;\n\t}\n\tfor(int i=1;i<maxn;i++) if(Find(i) == i && sz[i] > 1 && !hd[i])\n\t\tER = 1;\n\tif(ER) puts(\"NO\");\n\telse puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 100005\n#define M 405\nusing namespace std;\nbool bz[N];\nint cd[M],rd[M],n,num,f[M],h,m,v1[M],v2[M];\nint getf(int k)\n{\n\tif(f[k]==k||!f[k]) return k;\n\treturn (f[k]=getf(f[k]));\n}\nint main()\n{\n\tcin>>n>>h;\n\tfo(i,1,n)\n\t{\n\t\tint a,b,c,d,x,y;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=(c>0)?c:(a+200);\n\t\ty=(d>0)?(d+200):b;\n\t\tcd[x]++,rd[y]++;\n\t\tint fx=getf(x),fy=getf(y);\n\t\tf[fx]=fy;\n\t}\n\tint w=0;\n\t\tbool pd=1;\n\t\tfo(i,1,400) \n\t\t{\n\t\t\tif(rd[i]>0||cd[i]>0)\n\t\t\t{\n\t\t\t\tint fa=getf(i);\n\t\t\t\tif(rd[i]-cd[i]<0) \n\t\t\t\t{\n\t\t\t\t\tv1[fa]++;\n\t\t\t\t\tif(i<=200)\n\t\t\t\t\t{\n\t\t\t\t\t\tpd=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rd[i]-cd[i]>0) \n\t\t\t\t{\n\t\t\t\t\tv2[fa]++;\n\t\t\t\t\tif(i>200)\n\t\t\t\t\t{\n\t\t\t\t\t\tpd=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pd)\n\t\tfo(i,1,400)\n\t\t{\n\t\t\tif((rd[i]||cd[i])&&v1[getf(i)]==0) \n\t\t\t{\n\t\t\t\tpd=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pd) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1  : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=4e2+50, H=201;\nint n,d[N],vis[N],ok[N];\nvector <int> edge[N];\ninline void add(int x,int y) {\n\tx+=H; y+=H; ok[x]=ok[y]=1;\n\t--d[x]; ++d[y]; \n\tedge[x].push_back(y);\n\tedge[y].push_back(x);\n}\nint tag;\ninline bool dfs(int x) {\n\tif(x<=H && d[x]>0) return false;\n\tif(x>H && d[x]<0) return false;\n\tvis[x]=1; tag|=(d[x]!=0);\n\tfor(auto v:edge[x])\n\t\tif(!vis[v]) if(!dfs(v)) return false;\n\treturn true;\n}\nint main() {\n\tn=rd(); rd();\n\tfor(int i=1;i<=n;i++) {\n\t\tint a=rd(), b=rd(), c=rd(), d=rd();\n\t\tadd(c?c:-a,d?-d:b);\n\t} \n\tfor(int i=1;i<=2*H;i++) if(ok[i] && !vis[i]) {\n\t\ttag=0;\n\t\tif((!dfs(i)) || (!tag)) return puts(\"NO\"),0;\n\t} puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<b;++i)\n#define fj(a,b) for(int j=a;j<b;++j)\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> pii;\n///////////////////////\n\nint const N = 1e5 + 41;\nint const H = 241;\n\nint n, h, a[N], b[N], c[N], d[N];\nvector<pii> e[H][2];\nint pe[H][2], q, qo[H];\npii v;\n\n\nvoid yes(){\n\tprintf(\"YES\\n\");\n\texit(0);\n}\n\npii getfrom(int a, int c){\n\tif(c == 0){\n\t\treturn mp(a, 1);\n\t}else{\n\t\treturn mp(c, 0);\n\t}\n}\n\npii getto(int a, int c){\n\tif(c == 0){\n\t\treturn mp(a, 0);\n\t}else{\n\t\treturn mp(c, 1);\n\t}\n}\n\nbool dfs(pii x){\n\t//fprintf(stderr,\"%d %d\\n\",x.first,x.second);\n\tif(pe[x.first][x.second] == sz(e[x.first][x.second])){\n\t\tif(x.second == 1 && qo[x.first] > 0){\n\t\t\t--qo[x.first];\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn (x.second == 0);\n\t\t}\n\t}\n\tbool res = true;\n\n\tpii y = e[x.first][x.second][pe[x.first][x.second]];\n\t++pe[x.first][x.second];\n\t++q;\n\tres &= dfs(y);\n\n\treturn res;\n}\n\nvoid solve(){\n\tfi(0, n){\n\t\tpii x = getfrom(a[i], c[i]);\n\t\tpii y = getto(b[i], d[i]);\n\t\t//fprintf(stderr,\"%d %d %d %d\\n\",x.first,x.second,y.first,y.second);\n\t\te[x.first][x.second].pb(y);\n\t}\n\tbool ok = true;\n\tfi(1, h+1){\n\t\twhile(pe[i][1] < sz(e[i][1])){\n\t\t\tok &= dfs(mp(i, 1));\n\t\t\t++qo[i];\n\t\t}\n\t}\n\tif(q == n && ok) yes();\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tscanf(\"%d %d\",&n,&h);\n\tfi(0, n){\n\t\tscanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\t}\n\n\tsolve();\n\n\tprintf(\"NO\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 100005\n#define M 405\nusing namespace std;\nbool bz[N];\nint cd[M],rd[M],n,num,f[M],h,m;\nint getf(int k)\n{\n\tif(f[k]==k||!f[k]) return k;\n\treturn (f[k]=getf(f[k]));\n}\nint main()\n{\n\tcin>>n>>h;\n\tfo(i,1,n)\n\t{\n\t\tint a,b,c,d,x,y;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=(c>0)?c:(a+200);\n\t\ty=(d>0)?(d+200):b;\n\t\tcd[x]++,rd[y]++;\n\t}\n\t\tbool pd=1;\n\t\tint v1=0,v2=0;\n\t\tfo(i,1,400) \n\t\t{\n\t\t\tif(abs(rd[i]-cd[i])>1) \n\t\t\t{\n\t\t\t\tpd=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(rd[i]-cd[i]==-1) \n\t\t\t{\n\t\t\t\tv1=i;\n\t\t\t\tif(i<=200)\n\t\t\t\t{\n\t\t\t\t\tpd=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(rd[i]-cd[i]==1) \n\t\t\t{\n\t\t\t\tif(i>200)\n\t\t\t\t{\n\t\t\t\t\tpd=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pd&&v1>0) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=200000+10;\nint fa[maxn],vis[maxn],du[maxn],bz[maxn];\nint i,j,k,l,t,n,m,a,b,c,d,x,y;\nbool czy;\nint getfa(int x){\n\treturn fa[x]==x?x:fa[x]=getfa(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,1000) fa[i]=i;\n\tfo(i,1,n){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tx=c?-c:a;\n\t\ty=d?d:-b;\n\t\tx+=500;y+=500;\n\t\tfa[getfa(x)]=getfa(y);\n\t\tdu[x]++;du[y]--;\n\t\tvis[x]=1;\n\t}\n\tczy=1;\n\tfo(i,1,499)\n\t\tif (du[i]>0) czy=0;\n\tfo(i,501,1000)\n\t\tif (du[i]<0) czy=0;\n\tfo(i,1,1000) vis[getfa(i)]|=vis[i];\n\tfo(i,1,1000)\n\t\tif (du[i]) bz[getfa(i)]=1;\n\tfo(i,1,1000)\n\t\tif (fa[i]==i&&!bz[i]&&vis[i]) czy=0;\n\tif (czy) printf(\"YES\\n\");else printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\nint n,m;\nint fa[2000003],vis[2000003],D[2000003],C[2000003];\ninline int find(int x){\n\tif(fa[x]==x){\n\t\treturn fa[x];\n\t}else{\n\t\treturn fa[x]=find(fa[x]);\n\t}\n}\nint main(){\n\tcin>>n>>m;\n    for(int i=1;i<=1000;i++){\n    \tfa[i]=i;\n\t}\n    for(int i=1;i<=n;i++){\n        int x,y,a,b,c,d;\n        cin>>a>>b>>c>>d;\n        x=!c?a+500:-c+500;\n        y=!d?-b+500:d+500;\n        fa[find(x)]=find(y);\n        D[x]++,D[y]--;\n\t\tvis[x]=1;\n    }\n    int flag=1;\n    for(int i=1;i<500;i++){\n    \tif(D[i]>0){\n\t\t\tputs(\"NO\");\n    \t\treturn 0;\n\t\t}\n\t}\n    for(int i=501;i<=1000;i++){\n    \tif(D[i]<0){\n    \t\tputs(\"NO\");\n    \t\treturn 0;\n\t\t}\n\t}\n    for(int i=1;i<=1000;i++){\n    \tvis[find(i)]|=vis[i];\n\t}\n    for(int i=1;i<=1000;i++){\n\t\tif(D[i]){\n\t\t\tC[find(i)]=1;\n\t\t}\n\t}\n    for(int i=1;i<=1000;i++){\n    \tif(fa[i]==i&&!C[i]&&vis[i]){\n    \t\tputs(\"NO\");\n    \t\treturn 0;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MX=100010, inf=2e9;\n\nint n, h;\nmap<pii, int> indeg, outdeg;\n\nbool solve(){\n    int cnt1=0, cnt2=0;\n    bool ex1=false, ex2=false;\n    for(int i=1; i<=h; i++){\n        pii a=pii(0,i), b=pii(i,h);\n        if(indeg[a]<outdeg[a]) return false;\n        if(outdeg[b]<indeg[b]) return false;\n        if(outdeg[pii(i,h)]==0) return false;\n        if(indeg[pii(0,i)]==0) return false;\n        \n        int x=max(0, indeg[a]-outdeg[a]);\n        int y=max(0, outdeg[b]-indeg[b]);\n        cnt1+=x, cnt2+=y;\n        outdeg[a]+=x, indeg[b]+=y;\n        ex1|=(indeg[a]!=0); ex2|=(indeg[b]!=0);\n    }\n    if(cnt1!=cnt2 || !ex1 || !ex2) return false;\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin>>n>>h; h++;\n    for(int i=1; i<=n; i++){\n        int a, b, c, d; cin>>a>>b>>c>>d;\n        if(c>0) a=h;\n        if(d>0) b=h;\n        // printf(\"L: %d, %d  R: %d, %d\\n\", (c==0 ? a : 0),(c==0 ? h : c), d,b);\n        outdeg[(c==0 ? pii(a,h) : pii(0,c))]++;\n        indeg[pii(d,b)]++;\n    }\n    cout<<(solve() ? \"YES\" : \"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint num[403][2]={0}; \nint main(){\n\tint n,h,t;\t\n\tcin>>n>>h;\n\tvector<int>pic[4];\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tpic[j].push_back(t);\n\t\t}\t\n\t} \n\tfor(int i=0;i<pic[0].size();i++){\n\t\tif(pic[2][i]==0) \n\t\t\tnum[pic[0][i]][0]++;\n\t\telse \n\t\t\tnum[200+pic[2][i]][0]++;\n\t\tif(pic[3][i]==0) \n\t\t\tnum[200+pic[1][i]][1]++;\n\t\telse \n\t\t\tnum[pic[3][i]][1]++;\n\t}\n\tint flag1=0,flag2=0,flag=0;\n\tfor(int i=0;i<403;i++){\n\t\tif(num[i][0]>num[i][1]) {\n\t\t\tif(((num[i][0]-1)==num[i][1])&&(i<200)){\n\t\t\t\tflag1++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t\tif(num[i][0]<num[i][1]) {\n\t\t\tif(((num[i][0]+1)==num[i][1])&&(i>=200)){\n\t\t\t\tflag2++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag1==flag2&&flag==0) cout<<\"YES\";\n\telse cout<<\"NO\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define fo(i,j,k) for(int i=j;i<=k;++i)\n#define fd(i,j,k) for(int i=j;i>=k;--i)\n#define rep(i,x) for(int i=ls[x];i;i=nx[i])\nusing namespace std;\nconst int N=420,M=1e5+10;\nint to[M],nx[M],ls[N],vl[M],num=0;\nint rd[N],cd[N];\nbool cz[N],vis[N];;\nvoid link(int u,int v){\n\tcz[u]=cz[v]=1;\n\tto[++num]=v,nx[num]=ls[u],ls[u]=num;\n}\nvoid dfs(int x){\n\tif(vis[x]) return;\n\tvis[x]=1;\n\trep(i,x) dfs(to[i]);\n}\nint main()\n{\n\tint n,h;\n\tscanf(\"%d %d\",&n,&h);\n\tfo(i,1,n){\n\t\tint a,b,c,d,u,v;\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tu=c?c:a+h,v=d?d+h:b;\n\t\tlink(u,v),cd[u]++,rd[v]++;\n\t}\n\tbool tf=false;\n\tfo(i,1,h) if(cz[i]){\n\t\tif(rd[i]<cd[i]) return printf(\"NO\"),0;\n\t\ttf|=rd[i]>cd[i];\n\t}\n\tif(!tf) return printf(\"NO\"),0;\n\ttf=false;\n\tfo(i,h+1,h<<1) if(cz[i]){\n\t\tif(rd[i]>cd[i]) return printf(\"NO\"),0;\n\t\ttf|=rd[i]<cd[i];\n\t}\n\tif(!tf) return printf(\"NO\"),0;\n\tfo(i,h+1,h<<1) if(cz[i] && rd[i]<cd[i]) dfs(i);\n\tfo(i,1,h) if(cz[i] && !vis[i]) return printf(\"NO\"),0;\n\tprintf(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=200500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nint Bv[N][2];\nint main()\n{\n\tint q,w;\n\tread(n),read(m);\n\tfo(i,1,n)\n\t{\n\t\tint qa,qb,qc,qd;\n\t\tread(qa),read(qb),read(qc),read(qd);\n\t\tif(qc==0)\n\t\t{\n\t\t\tq=m+qa;\n\t\t}else q=qc;\n\t\tif(qd==0)w=qb;\n\t\telse w=m+qd;\n\t\t++Bv[q][0];++Bv[w][1];\n\t}\n\tans=0;q=0;\n\tfo(i,m+1,m*2)\n\t{\n\t\tif(Bv[i][0]<Bv[i][1])++ans;\n\t\tif(Bv[i][0]>Bv[i][1])++q;\n\t}\n\tif(!q||ans){printf(\"NO\\n\");return 0;}\n\tq=0;\n\tfo(i,1,m)\n\t{\n\t\tif(Bv[i][0]>Bv[i][1])++ans;\n\t\tif(Bv[i][0]<Bv[i][1])++q;\n\t}\n\tif(ans||!q)printf(\"NO\\n\");\n\telse printf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define allv(V) ((V).begin()),((V).end())\n#define befv(V) ((V)[(sz(V)-2)])\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define cb(x) (x)=(!(x))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\nvoid fuk() { puts(\"NO\"); exit(0); }\n\nconst bool debug = 0;\nconst int MAXN = 100005;\nconst int MAXH = 555;\n\nvector<int> G[MAXH];\nint GI[MAXH];\n\nint DgI[MAXH], DgO[MAXH];\n\nint A[MAXN], B[MAXN], C[MAXN], D[MAXN];\n\nvector<int> SV, EV;\nint N, H;\n\nvoid f(int i) {\n\tif(sz(G[i]) == GI[i]) return;\n\tint v = G[i][GI[i]++];\n\tf(v);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> H;\n\tfor(int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\n\t\tint s = -1, e = -1;\n\n\t\tif(C[i]) s = C[i]<<1;\n\t\telse s = A[i]<<1 | 1;\n\n\t\tif(D[i]) e = D[i]<<1 | 1;\n\t\telse e = B[i]<<1;\n\n\t\tG[s].eb(e);\n\t\tDgO[s]++; DgI[e]++;\n\n\t\tif(debug) printf(\"%d : %d -> %d\\n\", i, s, e);\n\t}\n\n\tfor(int i = 0; i < MAXH; i++) {\n\t\tif(DgI[i] == DgO[i]) continue;\n\t\tif(DgI[i] < DgO[i]) {\n\t\t\tfor(int j = DgO[i] - DgI[i]; j--;)\n\t\t\t\tSV.eb(i);\n\t\t} else {\n\t\t\tfor(int j = DgI[i] - DgO[i]; j--;)\n\t\t\t\tEV.eb(i);\n\t\t}\n\t}\n\n\tif(SV.empty() || sz(SV) != sz(EV)) fuk();\n\n\tfor(int v : SV) {\n\t\tf(v);\n\t}\n\n\tfor(int i = 0; i < MAXH; i++)\n\t\tif(sz(G[i]) != GI[i]) fuk();\n\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define SIZE 500\n#define INF 1000000\ntypedef pair<int, int>pii;\nclass maxflow\n{\npublic:\n\tvector<int>pat[SIZE];\n\tvector<int>cap[SIZE];\n\tvector<int>rev[SIZE];\n\tbool flag[SIZE];\n\tint dist[SIZE];\n\tint now[SIZE], ind[SIZE];\n\tint idx[SIZE];\n\tint flow;\n\tint gd;\n\tvoid adde(int s, int t, int cp)//多重辺は消してから s->tの容量cpの辺をはる\n\t{\n\t\tpat[s].push_back(t);\n\t\tpat[t].push_back(s);\n\t\tcap[s].push_back(cp);\n\t\tcap[t].push_back(0);\n\t\trev[s].push_back(pat[t].size() - 1);\n\t\trev[t].push_back(pat[s].size() - 1);\n\t}\n\tvoid blockflow(int node, int len, int go, int pt)//ブロックフローを求めて流す\n\t{\n\t\tif (pt == len)\n\t\t{\n\t\t\tif (node != go)return;\n\t\t\tint mini = INF, rr = -1;\n\t\t\tfor (int i = 0; i < pt; i++)if (cap[now[i]][ind[i]] < mini)mini = cap[now[i]][ind[i]], rr = i;\n\t\t\tfor (int i = 0; i < pt; i++)cap[now[i]][ind[i]] -= mini, cap[pat[now[i]][ind[i]]][rev[now[i]][ind[i]]] += mini;\n\t\t\tflow += mini;//mini==INFになったら非有界\n\t\t\tgd = rr;\n\t\t\treturn;\n\t\t}\n\t\tnow[pt] = node;\n\t\tfor (int i = idx[node]; i < pat[node].size(); i++)\n\t\t{\n\t\t\tif (dist[pat[node][i]] == dist[node] + 1 && cap[node][i]>0)\n\t\t\t{\n\t\t\t\tind[pt] = i;\n\t\t\t\tblockflow(pat[node][i], len, go, pt + 1);\n\t\t\t\tif (gd < pt)break;\n\t\t\t\telse gd = INF;\n\t\t\t}\n\t\t\tidx[node]++;\n\t\t}\n\t}\n\tvoid dinic(int st, int go, int num)//dinicのアルゴリズムで最大流を求める 変数flowにmaxflowの値が入る\n\t{\n\t\tflow = 0;\n\t\tfor (;;)\n\t\t{\n\t\t\tqueue<pii>que;\n\t\t\tfill(dist, dist + num, INF);\n\t\t\tfill(flag, flag + num, false);\n\t\t\tque.push(make_pair(st, 0));\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tif (que.empty())break;\n\t\t\t\tpii z = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif (flag[z.first])continue;\n\t\t\t\tflag[z.first] = true;\n\t\t\t\tdist[z.first] = z.second;\n\t\t\t\tfor (int i = 0; i < pat[z.first].size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (dist[pat[z.first][i]]>z.second + 1 && cap[z.first][i] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[pat[z.first][i]] = z.second + 1;\n\t\t\t\t\t\tque.push(make_pair(pat[z.first][i], z.second + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[go] == INF)return;\n\t\t\tgd = INF;\n\t\t\tfill(idx, idx + SIZE, 0);\n\t\t\tblockflow(st, dist[go], go, 0);\n\t\t}\n\t}\n\tvector<int>getcut(int st, int go, int num)//頂点iがmincutのst側なら1 そうでなければ0\n\t{\n\t\tdinic(st, go, num);\n\t\tvector<int>ret;\n\t\tfor (int i = 0; i < num; i++)ret.push_back(flag[i]);\n\t\treturn ret;\n\t}\n};\nmaxflow fl;\nclass unionfind\n{\npublic:\n\tint par[SIZE];\n\tint ran[SIZE];\n\tint ren[SIZE];\n\tvoid init()\n\t{\n\t\tfor (int i = 0; i<SIZE; i++)\n\t\t{\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t\tren[i] = 1;\n\t\t}\n\t}\n\tint find(int a)\n\t{\n\t\tif (a == par[a])return a;\n\t\telse return par[a] = find(par[a]);\n\t}\n\tvoid unite(int a, int b)\n\t{\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b)return;\n\t\tif (ran[a]>ran[b])\n\t\t{\n\t\t\tpar[b] = a;\n\t\t\tren[a] += ren[b];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[a] = b;\n\t\t\tren[b] += ren[a];\n\t\t}\n\t\tif (ran[a] == ran[b])ran[b]++;\n\t}\n};\nunionfind uf;\nint odeg[500], ideg[500];\nbool flag[500];\nvoid no()\n{\n\tprintf(\"NO\\n\");\n\texit(0);\n}\nint main()\n{\n\tint num, hei;\n\tscanf(\"%d%d\", &num, &hei);\n\tuf.init();\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tint za, zb, zc, zd;\n\t\tscanf(\"%d%d%d%d\", &za, &zb, &zc, &zd);\n\t\tint s, t;\n\t\tif (zc == 0)s = za * 2;\n\t\telse s = zc * 2 + 1;\n\t\tif (zd == 0)t = zb * 2 + 1;\n\t\telse t = zd * 2;\n\t\tfl.adde(s, t, 1);\n\t\tuf.unite(s, t);\n\t\todeg[s]++, ideg[t]++;\n\t}\n\tint sum = 0;\n\tfor (int i = 1; i <= hei; i++)\n\t{\n\t\tif (odeg[i * 2] < ideg[i * 2])no();\n\t\telse if (odeg[i * 2] > ideg[i * 2])fl.adde(0, i * 2, odeg[i * 2] - ideg[i * 2]), sum += odeg[i * 2] - ideg[i * 2], flag[uf.find(i * 2)] = true;\n\t\tif (odeg[i * 2 + 1]>ideg[i * 2 + 1])no();\n\t\telse if (odeg[i * 2 + 1] < ideg[i * 2 + 1])fl.adde(i * 2 + 1, 1, ideg[i * 2 + 1] - odeg[i * 2 + 1]);\n\t}\n\tfor (int i = 2; i <= hei * 2 + 1; i++)\n\t{\n\t\tif (i == uf.find(i))\n\t\t{\n\t\t\tif ((!flag[i]) && ideg[i] > 0)no();\n\t\t}\n\t}\n\tfl.dinic(0, 1, hei * 2 + 2);\n\tif (sum != fl.flow)no();\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\n#define mp make_pair\n#define ni(x) scanf(\"%d\", &(x))\n#define nii(x,y) scanf(\"%d%d\",&(x),&(y))\n#define mul(x,y) ((ll)(x)*(y)%mod)\n#define mtp make_tuple\n#define F(i,n) for(int i = 0; i < (n); i++)\n#define FF(i,n) for(int i = 1; i <= (n); i++)\n#define FE(i,n) for(int i = 0; i <= (n); i++)\n\n#ifndef __GNUG__\nint __builtin_popcount(int n) {\n\tint x = 0;\n\twhile (n)n -= n&(-n), x++;\n\treturn x;\n}\n#endif\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int mod = 1000000007;\nconst int inf = 2012345678;\nconst ll infl = 9012345678901234567;\nconst double pi = 3.1415926535897932384626433832795;\n//----------------------------------------------------------------------------//\n\nconst int N = 1000;\n\nvector<int> adj[N], rev[N], cc[N];\nint ord[N], clk, scc[N], ind[N], chk[N], ccn;\n\nvoid dfs1(int u) {\n\tchk[u] = 1;\n\tfor (auto &x : rev[u]) {\n\t\tif (chk[x])continue;\n\t\tdfs1(x);\n\t}\n\tord[clk++] = u;\n}\nvoid dfs2(int u) {\n\tchk[u] = 1;\n\tcc[ccn].push_back(u);\n\tscc[u] = ccn;\n\tfor (auto &x : adj[u]) {\n\t\tif (chk[x])continue;\n\t\tdfs2(x);\n\t}\n}\nint par[N];\nint find(int i) {\n\treturn par[i] < 0 ? i : (par[i] = find(par[i]));\n}\nint chk2[N];\nvoid merge(int i, int j) {\n\ti = par[i]; j = par[j];\n\tif (i == j)return;\n\tpar[j] += par[i]; par[i] = j;\n}\nint main() {\n#ifndef __GNUG__\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n, h; nii(n, h);\n\tF(i, n) {\n\t\tint a, b, c, d; nii(a, b); nii(c, d);\n\t\tint s, t;\n\t\tif (c == 0) {\n\t\t\ts = a;\n\t\t}\n\t\telse {\n\t\t\ts = h - 1 + c;\n\t\t}\n\t\tif (d == 0) {\n\t\t\tt = h - 1 + b;\n\t\t}\n\t\telse {\n\t\t\tt = d;\n\t\t}\n\t\tadj[s].push_back(t);\n\t}\n\tint vn = h + h;\n\tF(i, vn)for (auto &x : adj[i])rev[x].push_back(i);\n\tF(i, vn)par[i] = -1;\n\tF(i, vn)for (auto &x : adj[i])merge(i, x);\n\tF(i, vn) {\n\t\tint j = find(i);\n\t\tif (!chk2[j])chk2[j] = ++ccn;\n\t\tcc[chk2[j]].push_back(i);\n\t}\n\tFF(t, ccn) {\n\t\tbool bad = false;\n\t\tfor (auto &x : cc[t])if (!adj[x].empty())bad = true;\n\t\tif (!bad)continue;\n\t\tbool X = false, Y = false;\n\t\tfor (auto &x : cc[t]) {\n\t\t\tif (x < h) {\n\t\t\t\tif (adj[x].size() < rev[x].size()) return puts(\"NO\"), 0;\n\t\t\t\tif (adj[x].size() > rev[x].size()) X = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (adj[x].size() > rev[x].size()) return puts(\"NO\"), 0;\n\t\t\t\tif (adj[x].size() < rev[x].size()) Y = true;\n\t\t\t}\n\t\t}\n\t\tif (!X || !Y)return puts(\"NO\"), 0;\n\t}\n\tputs(\"YES\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=410;\nint n,h,in[N],out[N];\nint fa[N];\nbool ok[N];\n\nint find(const int &x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\nint main()\n{\n    n=read();h=read();\n    for(int i=1;i<=(h<<1);i++) fa[i]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int A=read(),B=read(),C=read(),D=read();\n        int x=C?C+h:A,y=D?D:B+h;\n        out[x]++;in[y]++;\n        x=find(x);y=find(y);\n        if(x!=y) fa[x]=y;\n    }\n    for(int i=1;i<=h;i++) if(in[i]>out[i]) return !puts(\"NO\");\n    for(int i=h+1;i<=(h<<1);i++) if(in[i]<out[i]) return !puts(\"NO\");\n    for(int i=1;i<=(h<<1);i++) if(in[i]!=out[i]||!in[i]&&!out[i]) ok[find(i)]=1;\n    for(int i=1;i<=(h<<1);i++) if(fa[i]==i&&!ok[i]) return !puts(\"NO\");\n    return !puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,h;\n  cin>>n>>h;\n  vector<Int> a(n),b(n),c(n),d(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i]>>c[i]>>d[i];\n  \n  auto idx=\n    [&](Int k,Int s){\n      if(s==0){\n\tif(c[k]==0) return 300+a[k];\n\treturn c[k];\n      }else{\n\tif(d[k]==0) return b[k];\n\treturn 300+d[k];\n      }\n    };\n\n  vector<vector<queue<Int> > > cnt(2,vector<queue<Int> >(600));\n  for(Int i=0;i<n;i++){\n    cnt[0][idx(i,0)].emplace(i);\n    cnt[1][idx(i,1)].emplace(i);\n  }\n  \n  auto NO=[](){cout<<\"NO\"<<endl;exit(0);};\n\n  vector<Int> used(n),ok(600,0);\n  vector<vector<Int> > lp;\n  for(Int i=0;i<n;i++){\n    if(used[i]) continue;\n    used[i]=1;\n    Int l=idx(i,0),r=idx(i,1);\n    vector<Int> v;        \n    while(1){\n      v.emplace_back(l);\n      v.emplace_back(r);\n      Int flg=0;\n      while(!cnt[1][l].empty()){\n\tInt k=cnt[1][l].front();cnt[1][l].pop();\n\tif(used[k]) continue;\n\tused[k]=1;\n\tassert(idx(k,1)==l);\n\tl=idx(k,0);\n\tflg=1;\n\tbreak;\n      }\n      if(flg) continue;\n      while(!cnt[0][r].empty()){\n\tInt k=cnt[0][r].front();cnt[0][r].pop();\n\tif(used[k]) continue;\n\tused[k]=1;\n\tassert(idx(k,0)==r);\n\tr=idx(k,1);\n\tflg=1;\n\tbreak;\n      }\n      if(flg) continue;\n      break;\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());    \n    if(l==r){\n      lp.emplace_back(v);\n      continue;\n    }\n    if(l<300||r>=300) NO();\n    for(Int x:v) ok[x]=1;\n  }\n  assert(lp.empty());\n  for(auto v:lp){\n    Int flg=0;\n    for(Int x:v) flg|=ok[x];\n    if(!flg) NO();\n  }\n  cout<<\"YES\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100005\n#define For(i,x,y) for(int i=x;i<=y;i++)\n#define Rep(i,x,y) for(int i=x;i>=y;i--)\n#define mp make_pair\n#define pa pair<ll,int>\nusing namespace std;\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=1;\n    for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+ch-48;\n    return f?-x:x;\n}\nint n,h,in[405],ou[405],fa[405];\nbool flag[405];\ninline int find(int x){return (fa[x]==x)?x:fa[x]=find(fa[x]);}\nint main(){\n    n=read();h=read();\n    For(i,1,h*2) fa[i]=i;\n    For(i,1,n){\n        int a=read(),b=read(),c=read(),d=read();\n        int l=(c==0)?h+a:c;\n        int r=(d==0)?b:h+d;\n        in[r]++;ou[l]++;\n        fa[find(l)]=find(r);\n    }\n    For(i,1,h) if(ou[i]>in[i]){puts(\"NO\");return 0;}\n    For(i,h+1,h*2) if(ou[i]<in[i]){puts(\"NO\");return 0;}\n    For(i,1,h*2) if(in[i]!=ou[i]) flag[find(i)]=1;\n    For(i,1,h*2) if(find(i)==i&&!flag[i]&&in[i]+ou[i]!=0){puts(\"NO\");return 0;}\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=405;\nint fa[N],vis[N],in[N],out[N],n,h;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfp(i,0,h<<1)fa[i]=i;\n\tfor(R int i=1,a,b,c,d,l,r;i<=n;++i){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tl=(c?-c:a)+h,r=(d?d:-b)+h,fa[find(l)]=find(r);\n\t\t++out[l],++in[r];\n\t}\n\tfp(i,-h,-1)if(out[i+h]>in[i+h])return puts(\"NO\"),0;\n\tfp(i,1,h)if(in[i+h]>out[i+h])return puts(\"NO\"),0;\n\tfp(i,0,h<<1)if(in[i]!=out[i])vis[find(i)]=1;\n\tfp(i,1,n)if(in[i]&&out[i]&&!vis[find(i)])return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstring>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nint N,H,pal;\tint a,b,c,d,zh,f;\nstruct line{int in,ch;}lines[100001];bool cam(line a,line b){return a.in>b.in;}\nbool v[100001];\nvoid solve(int no,int t)\n{\n\n\tif(t==N-1)\n\t{\n\t\tint st=0;while(v[st]!=0)st++;\n\t\tif((lines[st].in==-lines[no].ch&&lines[st].ch>0))\n\t\t\tpal=1;\n\t\telse if(lines[st].in>0&&lines[st].ch>0&&lines[no].ch>0)\n\t\t\tpal=1;\n\t\tif(pal)return;\n\t}\n\telse\n\t{\n\t\tint st=0;\n\t\twhile(st<N&&lines[st].in!=-lines[no].ch)st++;\n\t\tfor(int i=st;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0)\n\t\t\t{\tv[i]=1;solve(i,t+1);v[i]=0;if(pal)return;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(lines[no].ch>0)\n\t\t{\n\t\t\tfor(int i=0;i<N&&lines[i].in>0;i++)\n\t\t\t{\n\t\t\t\tif(v[i]==0)\n\t\t\t\t{\t\n\t\t\t\t\tv[i]=1;solve(i,t+1);v[i]=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\n\tpal=0;zh=0;f=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta=c==0?a:-c;b=d==0?b:-d;\n\t\tif(a>0)zh++;if(b>0)zh++;if(a<0)f++;if(b<0)f++;\n\t\tlines[i].in=a;lines[i].ch=b;\n\t}\n\tsort(lines,lines+N,cam);\n\tif(zh-f>=2)\n\t{for(int i=0;i<N&&lines[i].in>0;i++)\n\t\t{\n\t\t\tv[i]=1;\n\t\t\tsolve(i,1);\n\t\t\tv[i]=0;\n\t\t\tif(pal)break;\n\t\t}\n\t\tif(pal)printf(\"YES\");\n\t\telse printf(\"NO\");\n\t}\n\telse printf(\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "// Trying again... This will get WA QuQ\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 100003;\nstatic const int MAXH = 209;\n \nstatic const int MAXV = MAXH * 2;\nstatic const int MAXE = 1e6 + 10;\n \nint n, h;\nint head[MAXV], dest[MAXE], next[MAXE];\nbool vis[MAXE] = { false };\n \nint m = 0;\nint in[MAXV] = { 0 }, out[MAXV] = { 0 };\n \ninline void add_edge(int u, int v)\n{\n    dest[m] = v; next[m] = head[u]; head[u] = m++;\n    ++out[u], ++in[v];\n}\n \nvoid dfs(int u)\n{\n    for (int w = head[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs(dest[w]);\n    }\n}\n \nstd::vector<int> as, bs;\nbool marked[MAXV] = { false };\n \nint main()\n{\n    scanf(\"%d%d\", &n, &h);\n \n    int verts = (h + 1) * 2;\n    for (int i = 0; i < verts; ++i) head[i] = -1;\n \n#define node_a(_h) ((_h) * 2)\n#define node_b(_h) ((_h) * 2 + 1)\n    for (int i = 0, a, b, c, d; i < n; ++i) {\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        int u, v;\n        u = (c == 0 ? node_b(a) : node_a(c));\n        v = (d == 0 ? node_a(b) : node_b(d));\n        add_edge(u, v);\n    }\n    for (int i = 0; i <= h; ++i) {\n        if (in[node_a(i)] < out[node_a(i)]) { puts(\"NO\"); return 0; }\n        if (in[node_b(i)] > out[node_b(i)]) { puts(\"NO\"); return 0; }\n        for (int r = 0; r < in[node_a(i)] - out[node_a(i)]; ++r) {\n            as.push_back(node_a(i));\n            marked[node_a(i)] = true;\n        }\n        for (int r = 0; r < out[node_b(i)] - in[node_b(i)]; ++r) {\n            bs.push_back(node_b(i));\n            marked[node_b(i)] = true;\n        }\n    }\n    for (int u : as) {\n        if (bs.empty()) { puts(\"NO\"); return 0; }\n        add_edge(u, bs.back());\n        bs.pop_back();\n    }\n \n    for (int i = 1; i < verts; i += 2) if (marked[i]) dfs(i);\n    for (int i = 0; i < m; ++i) if (!vis[i]) { puts(\"NO\"); return 0; }\n    puts(\"YES\"); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define show(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\nstruct Graph {\n    Graph(int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(int from, int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid dfs(int p, const Graph& g, vector<bool>& visited)\n{\n    visited[p] = true;\n    for (const int to : g.edge[p]) {\n        if (not visited[to]) {\n            dfs(to, g, visited);\n        }\n    }\n}\n\nint main()\n{\n    int N, H;\n    cin >> N >> H;\n\n    Graph g(2 * H + 1);\n    vector<int> dim(2 * H + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int l = 0;\n        if (c == 0) {\n            l = a;\n        } else {\n            l = -c;\n        }\n\n        int r = 0;\n        if (d == 0) {\n            r = b;\n        } else {\n            r = -d;\n        }\n\n        //        cout << l << \"->\" << -r << endl;\n        dim[l + H]++;\n        dim[-r + H]--;\n        g.addEdge(l + H, -r + H);\n    }\n\n    int num1 = 0;\n    int num2 = 0;\n    vector<bool> visited(2 * H + 1, false);\n    for (int i = 2 * H; i >= 0; i--) {\n        //        cout << i - H << \": \" << dim[i] << endl;\n        if (i - H > 0) {\n            if (dim[i] > 0) {\n                dfs(i, g, visited);\n                num1++;\n            } else if (dim[i] < 0) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (i - H < 0) {\n            if (dim[i] < 0) {\n                num2++;\n            } else if (dim[i] > 0) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    if (num1 == num2 and num1 > 0) {\n        for (int i = 0; i < 2 * H + 1; i++) {\n            if ((not g.edge[i].empty()) and (not visited[i])) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstring>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nint N,H,pal;\tint a,b,c,d,zh,f;\nstruct line{int in,ch;}lines[100001];bool cam(line a,line b){return a.in>b.in;}\nbool v[100001];\nvoid solve(int no,int t)\n{\n\n\tif(t==N-1)\n\t{\n\t\tint st=0;while(v[st]!=0)st++;\n\t\tif((lines[st].in==-lines[no].ch&&lines[st].ch>0))\n\t\t\tpal=1;\n\t\telse if(lines[st].in>0&&lines[st].ch>0&&lines[no].ch>0)\n\t\t\tpal=1;\n\t\tif(pal)return;\n\t}\n\telse\n\t{\n\t\tint st=0;\n\t\twhile(st<N&&lines[st].in!=-lines[no].ch)st++;\n\t\tfor(int i=st;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0)\n\t\t\t{\tv[i]=1;solve(i,t+1);v[i]=0;if(pal)return;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(lines[no].ch>0)\n\t\t{\n\t\t\tfor(int i=0;i<N&&lines[i].in>0;i++)\n\t\t\t{\n\t\t\t\tif(v[i]==0)\n\t\t\t\t{\t\n\t\t\t\t\tv[i]=1;solve(i,t+1);v[i]=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\n\tpal=0;zh=0;f=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta=c==0?a:-c;b=d==0?b:-d;\n\t\tlines[i].in=a;lines[i].ch=b;\n\t}\n\tsort(lines,lines+N,cam);\n\tfor(int i=0;i<N&&lines[i].in>0;i++)\n\t{\n\t\tv[i]=1;\n\t\tsolve(i,1);\n\t\tv[i]=0;\n\t\tif(pal)break;\n\t}\n\tif(pal)printf(\"YES\");\n\telse printf(\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nint n,h,a,b,c,d;\nvector<int>g[444];\nint in[444],out[444];\nvoid addedge(int u,int v)\n{\n\tin[v]++;out[u]++;\n\tg[u].pb(v);\n\tg[v].pb(u);\n}\nbool vis[444],ok;\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t\tif(!vis[g[x][i]])\n\t\t\tdfs(g[x][i]);\n\tif(in[x]!=out[x])ok=1;\n}\nint main()\n{\n\tget2(n,h);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tget2(a,b);\n\t\tget2(c,d);\n\t\tint l,r;\n\t\tif(c==0)l=a;else l=-c;\n\t\tif(d==0)r=-b;else r=d;\n\t\taddedge(l+h,r+h);\n\t}\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tif(out[h-i]>in[h-i]||in[h+i]>out[h+i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=0;i<h+h;i++)\n\t{\n\t\tif(g[i].size()&&!vis[i])\n\t\t{\n\t\t\tok=0;\n\t\t\tdfs(i);\n\t\t\tif(!ok)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 100003;\nstatic const int MAXH = 209;\n\nstatic const int MAXV = MAXH * 2;\nstatic const int MAXE = MAXN;\n\nint n, h;\nint head[MAXV], dest[MAXE], next[MAXE];\nbool vis[MAXE] = { false };\n\nint m = 0;\nint in[MAXV] = { 0 }, out[MAXV] = { 0 };\n\ninline void add_edge(int u, int v)\n{\n    dest[m] = v; next[m] = head[u]; head[u] = m++;\n    ++out[u], ++in[v];\n}\n\nvoid dfs(int u)\n{\n    for (int w = head[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs(dest[w]);\n    }\n}\n\nstd::vector<int> as, bs;\nbool marked[MAXV] = { false };\n\nint main()\n{\n    scanf(\"%d%d\", &n, &h);\n\n    int verts = (h + 1) * 2;\n    for (int i = 0; i < verts; ++i) head[i] = -1;\n\n#define node_a(_h) ((_h) * 2)\n#define node_b(_h) ((_h) * 2 + 1)\n    for (int i = 0, a, b, c, d; i < n; ++i) {\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        int u, v;\n        u = (c == 0 ? node_b(a) : node_a(c));\n        v = (d == 0 ? node_a(b) : node_b(d));\n        add_edge(u, v);\n    }\n    for (int i = 0; i <= h; ++i) {\n        if (in[node_a(i)] < out[node_a(i)]) { puts(\"NO\"); return 0; }\n        if (in[node_b(i)] > out[node_b(i)]) { puts(\"NO\"); return 0; }\n        for (int r = 0; r < in[node_a(i)] - out[node_a(i)]; ++r) {\n            as.push_back(node_a(i));\n            marked[node_a(i)] = true;\n        }\n        for (int r = 0; r < out[node_b(i)] - in[node_b(i)]; ++r) {\n            bs.push_back(node_b(i));\n            marked[node_b(i)] = true;\n        }\n    }\n    for (int u : as) {\n        if (bs.empty()) { puts(\"NO\"); return 0; }\n        add_edge(u, bs.back());\n        bs.pop_back();\n    }\n\n    for (int i = 1; i < verts; i += 2) if (marked[i]) dfs(i);\n    for (int i = 0; i < m; ++i) if (!vis[i]) { puts(\"NO\"); return 0; }\n    puts(\"YES\"); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=1e6+5;\nint n,h;\nint in[maxn],out[maxn];\nint fa[maxn],occ[maxn],ok[maxn];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tread(n);read(h);\n\trep(i,0,h+h)fa[i]=i;\n\trep(i,1,n){\n\t\tint a,b,c,d;read(a);read(b);read(c);read(d);\n\t\tint l=!c?a+h:c,r=!d?b:d+h;\n\t\tout[l]++;\n\t\tin[r]++;\n\t\tl=find(l);r=find(r);\n\t\tocc[l]=occ[r]=1;\n\t\tif(l!=r)fa[l]=r;\n\t}\n\tint flag=1;\n\trep(i,h+1,h+h)if(occ[i]&&out[i]<in[i])flag=0;\n\trep(i,0,h)if(occ[i]&&in[i]<out[i])flag=0;\n\trep(i,0,h+h)if(occ[i])ok[find(i)]|=(out[i]!=in[i]);\n\trep(i,0,h+h)if(occ[i]&&!ok[find(i)])flag=0;\n\tif(flag)puts(\"YES\");\n\telse puts(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nint father[510],n,m,pd[510],in[510],ou[510],p[510],len,totpoint,dst[510],x[510],bb[510][510];\nstruct bian{\n\tint next,point,f;\n}b[4100000];\nvoid ade(int k1,int k2,int k3){\n\tb[++len]=(bian){p[k1],k2,k3}; p[k1]=len;\n}\nvoid add(int k1,int k2,int k3){\n//\tcout<<\"add \"<<k1<<\" \"<<k2<<\" \"<<k3<<endl;\n\tade(k1,k2,k3); ade(k2,k1,0);\n}\nbool bfs()\n{\n    int head=1,now=0,i,j; int pd[510];\n    memset(dst,0xff,sizeof dst);\n    memset(pd,0x00,sizeof pd);\n    x[1]=0; pd[0]=1; dst[0]=0;\n    while (head>now)\n    {\n        now++; i=p[x[now]];\n        while (i!=-1)\n        {\n            j=b[i].point;\n            if ((b[i].f)&&(!pd[j]))\n            {\n                pd[j]=1; dst[j]=dst[x[now]]+1;\n                if (j==totpoint)\n                {\n                    return 1;\n                }\n                head++; x[head]=j;\n            }\n            i=b[i].next;\n        }\n    }\n    return pd[totpoint];\n}\nint min(int k1,int k2)\n{\n    if (k1<k2)\n    {\n        return k1;\n    }\n    else\n    {\n        return k2;\n    }\n}\nint change(int k1,int k2)\n{\n    if ((k1==totpoint)||(k2==0))\n    {\n        return k2;\n    }\n    int num=0,k,i,j;\n    i=p[k1];\n    while (i!=-1)\n    {\n        j=b[i].point;\n        if ((b[i].f)&&(dst[k1]+1==dst[j]))\n        {\n            k=change(j,min(k2,b[i].f));\n            k2=k2-k; num+=k;\n            b[i].f=b[i].f-k; b[i^1].f+=k;\n            if (k2==0)\n            {\n                break;\n            }\n        }\n        i=b[i].next;\n    }\n    if (!num)\n    {\n        dst[k1]=-1;\n    }\n    return num;\n}\nconst int inf=1e9;\nint dinic()\n{\n    int num=0;\n    while (bfs())\n    {\n        num+=change(0,inf);\n    }\n    return num;\n}\nvector<int>A,B;\nint findfather(int k1){\n\tif (father[k1]==k1) return k1;\n\tfather[k1]=findfather(father[k1]); return father[k1];\n}\nvoid link(int k1,int k2){\n\tbb[k1][k2]++;\n\tou[k1]++; in[k2]++; pd[k1]=1; pd[k2]=1;\n\tfather[findfather(k1)]=findfather(k2);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m); len=-1; memset(p,0xff,sizeof p);\n\tfor (int i=0;i<=m+m+2;i++) father[i]=i;\n\tfor (int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint u=0,v=0;\n\t\tif (c==0) u=a+m+2; else u=c+1;\n\t\tif (d==0) v=b+1; else v=d+m+2;\n\t\tlink(u,v);\n\t}\n//\tfor (int i=1;i<=m+m+2;i++) cout<<in[i]<<\" \"<<ou[i]<<endl;\n\tfor (int i=1;i<=m+m+2;i++)\n\t\tfor (int j=1;j<=m+m+2;j++)\n\t\t\tif (bb[i][j]) add(i,j,bb[i][j]);\n\tfor (int i=1;i<=m+1;i++) if (ou[i]>in[i]){\n\t\tprintf(\"NO\\n\"); return 0;\n\t}\n\tfor (int i=m+2;i<=m+m+2;i++) if (ou[i]<in[i]){\n\t\tprintf(\"NO\\n\"); return 0;\n\t}\n\tfor (int i=0;i<=m+m+2;i++)\n\t\tif (pd[i]==1){\n\t\t\tint flag1=0,flag2=0;\n\t\t\tfor (int j=0;j<=m+m+2;j++)\n\t\t\t\tif (pd[j]&&findfather(j)==findfather(i)){\n\t\t\t\t\tif (in[j]>ou[j]) flag1=1;\n\t\t\t\t\tif (ou[j]>in[j]) flag2=1;\n\t\t\t\t\tpd[j]=2;\n\t\t\t\t}\n\t\t\tif (flag1==0||flag2==0){\n\t\t\t\tprintf(\"NO\\n\"); return 0;\n\t\t\t}\n\t\t}\n\tint tot=0; totpoint=m+m+3;\n\tfor (int i=0;i<=m+m+2;i++)\n\t\tif (in[i]>ou[i]) add(i,totpoint,in[i]-ou[i]),tot+=in[i]-ou[i];\n\t\telse if (ou[i]>in[i]) add(0,i,ou[i]-in[i]);\n\tif (dinic()!=tot){\n\t\tprintf(\"NO\\n\"); return 0;\n\t} else printf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int n,h;\n  scanf(\"%d%d\",&n,&h);\n  vector<int> A(n),B(n),C(n),D(n);\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d%d\",&(A[i]),&(B[i]),&(C[i]),&(D[i]));\n  }\n  vector<int> D0(h+1),D1(h+1);\n  for(int i=0;i<n;i++){\n    if(C[i]==0){\n      D0[A[i]]++;\n    }\n    else{\n      D1[C[i]]--;\n    }\n    if(D[i]==0){\n      D1[B[i]]++;\n    }\n    else{\n      D0[D[i]]--;\n    }\n  }\n  bool F=0,F0=0,F1=0;\n  for(int i=0;i<=h;i++){\n    if(D0[i]<0||D1[i]<0){\n      F=1;\n    }\n    if(D0[i]>0){\n      F0=1;\n    }\n    if(D1[i]>0){\n      F1=1;\n    }\n  }\n  puts(F||!F0||!F1?\"NO\":\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\nconst int N=410;\nint n,h,in[N],out[N];\nint fa[N];\nbool ok[N];\n\nint find(const int &x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\nint main()\n{\n    n=read();h=read();\n    for(int i=1;i<=(h<<1);i++) fa[i]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int A=read(),B=read(),C=read(),D=read();\n        int x=C?C+h:A,y=D?D:B+h;\n        out[x]++;in[y]++;\n        x=find(x);y=find(y);\n        if(x!=y) fa[x]=y;\n    }\n    for(int i=1;i<=h;i++) if(in[i]>out[i]) return !puts(\"NO\");\n    for(int i=h+1;i<=(h<<1);i++) if(in[i]<out[i]) return !puts(\"NO\");\n    for(int i=1;i<=(h<<1);i++) if(in[i]!=out[i]||!in[i]&&!out[i]) ok[find(i)]=1;\n    for(int i=1;i<=(h<<1);i++) if(fa[i]==i&&!ok[i]) return !puts(\"NO\");\n    return !puts(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define neko 100010\n#define heko 410\n#define qwq return printf(\"YES\"),0; \n#define orz return printf(\"NO\"),0; \n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))\nstatic int n,H;\ntypedef int arr[heko];\narr fa,book,dgi,dgo,out;\nnamespace IO\n{\n\tconst unsigned int bufsize=1<<16,outsize=1<<24;\n\tstatic char ch[bufsize],*S=ch,*T=ch;\n\tinline char getc()\n\t{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\n\tstatic char Out[outsize],*nowp=Out;\n\tinline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\n\t\tvoid read(T &x)\n\t\t{\n\t\t\tchar c=getc();x=0;\n\t\t\tfor(;!isdigit(c);c=getc());\n\t\t\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n\t\t}\n\ttemplate<typename T>\n\t\tvoid write(T x,char c='\\n')\n\t\t{\n\t\t\tif(!x)*nowp++='0';\n\t\t\tstatic unsigned int stk[50],tp=0;\n\t\t\tfor(;x;x/=10)stk[++tp]=x%10;\n\t\t\tfor(;tp;*nowp++=stk[tp--]^'0');*nowp++=c;\n\t\t}\n}\nint find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}\nint main()\n{\n\tusing namespace IO;\n\tint x,y,z,o,X,Y;\n\tread(n),read(H);\n\tf(i,0,H<<1)fa[i]=i;\n\tf(i,1,n)\n\t{\n\t\tread(x),read(y),read(z),read(o);\n\t\tif(z==0)X=H+x;\n\t\telse X=H-z;\n\t\tif(o==0)Y=H-y;\n\t\telse Y=H+o;\n\t\tbook[X]=book[Y]=1;\n\t\t++dgi[Y],++dgo[X];\n\t\tfa[find(Y)]=find(X);\n\n\t}\n\tf(i,0,H)if(dgi[i]<dgo[i])orz;\n\tf(i,H+1,H<<1)if(dgi[i]>dgo[i])orz;\n\tf(i,0,H<<1)if(dgi[i]^dgo[i])out[fa[i]]=1;\n\tf(i,0,H<<1)if(fa[i]==i&&book[i]&&!out[fa[i]])orz;\n\tqwq;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=500;\nint f[N],t[N],p[N],du[N];\nint get(int x)\n{\n\tif (f[x]==x) return x;\n\treturn f[x]=get(f[x]);\n}\nint main()\n{\n\tint n,h;\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=1;i<=400;i++) f[i]=i;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint l=200,r=200;\n\t\tif (c) l=l-c;else l=l+a;\n\t\tif (d) r=r+d;else r=r-b;\n\t\tdu[l]++;\n\t\tdu[r]--;\n\t\tt[l]=t[r]=1;\n\t\tf[get(l)]=get(r);\n\t}\n\tfor (int i=1;i<=200;i++) if (du[i]>0) \n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tfor (int i=201;i<=400;i++) if (du[i]<0)\n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=400;i++) \n\t{\n\t\tif (du[i]) p[get(i)]=1;\n\t\tt[get(i)]=t[get(i)]|t[i];\n\t}\n\tfor (int i=0;i<=400;i++) if (i==get(i)&&t[i]&&!p[i]) \n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t puts(\"YES\");\n\t return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n拼图最终一定被分成了若干个连续的部分，这里连续的定义是相邻的2个拼图拼在一起。对于一个连续的部分1 ~ N，需要满足的条件是：\nC[1] = 0   D[N] = 0   对于相邻的两个拼图i和i + 1，D[i] = A[i + 1]且C[i + 1] = 0 或 B[i] = C[i + 1]且D[i] = 0\n定义一个拼图的两个属性P和Q：\n当C[i] = 0时，P[i] = A[i]；当C[i] > 0时，P[i] = -C[i]\n当D[i] = 0时，Q[i] = -B[i]；当D[i] > 0时，Q[i] = D[i]\n可以观察到这么几个性质：\n(1)因为A[i] > 0且B[i] > 0，所以C[i] != 0且D[i] != 0\n(2)两个拼图i和i + 1能拼接起来的条件等价于Q[i] = P[i + 1]\n(3)C[1] = 0等价于P[1] > 0，D[N] = 0等价于Q[N] < 0\n根据此可以建图，把每个权值当成一个点，一个拼图是一条P[i] -> Q[i]的有向边，所有> 0的点可以作为路径起点，所有< 0的点可以作为路径终点\n一个合法的方案，对应的是若干条合法的路径，满足每条边被覆盖了恰好一次\n可以考虑把所有路径顺次排列成一个环，每条路径的终点往下一条路径的起点连一条边。那么这个方案对应了新图的一条欧拉回路\n只要能构造出存在这样欧拉回路的图，就能构造出合法的方案。直接根据度数判断能否令底图联通且每个点都满足入度 = 出度即可 \n*/\n\n#include <map>\n#include <cstdio>\n\nusing namespace std;\nconst int Max_N(100050);\nconst int Max_H(205);\n\nint N, H, P, Q, Sum1, Sum2, Fa[Max_H << 1], *Father = Fa + Max_H;\nbool Ha[Max_H << 1], *Have = Ha + Max_H;\nmap<int, int> In, Out;\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &H);\n\tfor (int x = -H;x <= +H;++x)\n\t\tFather[x] = x;\n\tfor (int i = 1, A, B, C, D, P, Q;i <= N;++i)\n\t{\n\t\tscanf(\"%d%d%d%d\", &A, &B, &C, &D);\n\t\tif (C == 0)\n\t\t\tP = A;\n\t\telse\n\t\t\tP = -C;\n\t\tif (D == 0)\n\t\t\tQ = -B;\n\t\telse\n\t\t\tQ = D;\n\t\t//P -> Q\n\t\t++In[Q], ++Out[P], Father[Get_Father(P)] = Get_Father(Q);\n\t}\n\tfor (int x = -H;x <= -1;++x)\n\t{\n\t\tif (Out[x] > In[x])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (In[x] - Out[x])\n\t\t\tSum1 += In[x] - Out[x], Have[Get_Father(x)] = true;\n\t}\n\tfor (int x = +1;x <= +H;++x)\n\t{\n\t\tif (In[x] > Out[x])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (Out[x] - In[x])\n\t\t\tSum2 += Out[x] - In[x], Have[Get_Father(x)] = true;\n\t}\n\tif (Sum1 == Sum2)\n\t{\n\t\tfor (int x = -H;x <= +H;++x)\n\t\t\tif ((In[x] || Out[x]) && Have[Get_Father(x)] == false)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tputs(\"YES\");\n\t}\n\telse\n\t\tputs(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H[100010], N[100010], G[100010], R[100010], C[100010], vis[100010], Nw[100010], Cnt = 0, cc = 0, ans = 0;\n\nvoid addedge(int x, int y) {G[++Cnt] = y, N[Cnt] = H[x], H[x] = Cnt, R[y]++, C[x]++;}\n\nvoid DFS(int x)\n{\n\tif(!Nw[x]) return;\n\tans++;\n\tint tmp = Nw[x];\n\tNw[x] = N[Nw[x]];\n\tDFS(G[tmp]);\n}\n\nint main()\n{\n\tint n, h;\n\tscanf(\"%d%d\", &n, &h);\n\tfor(int i = 1; i <= n; i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint pl = !d ? b : d + h + 5;\n\t\tint pr = !c ? a + h + 5 : c;\n\t\taddedge(pl, pr);\n\t}\n\tfor(int i = 1; i <= h * 2 + 5; i++) Nw[i] = H[i];\n\tfor(int i = 1; i <= h; i++) DFS(i);\n\tif(ans != n) return puts(\"NO\"), 0;\n\treturn puts(\"YES\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\ntypedef struct{\n  int to;\n  int cap;\n  int rev;\n}edge;\n\n// node v : distance from s => level[v]\nvoid bfs(vector<vector<edge> > &G, vector<int> &level, int s){\n  fill(level.begin(), level.end(), -1);\n  queue<int> q;\n  q.push(s);\n  level[s] = 0;\n  while(!q.empty()){\n    int e=q.front(); q.pop();\n    for(int i=0; i<G[e].size(); i++){\n      if(G[e][i].cap > 0 && level[G[e][i].to] < 0){\n        level[G[e][i].to] = level[e] + 1;\n        q.push(G[e][i].to);\n      }\n    }\n  }\n}\n\nint dfs(vector<vector<edge> > &G, vector<int> &level, vector<bool> &used, vector<int> &iter, int s, int f,  int t){\n  if(s==t) return f;\n  else{\n    //iter[e] : done searching from v[0] to v[ iter[e]-1 ]\n    for(int &i=iter[s]; i<G[s].size(); i++){\n      //distance from s to v[e][i].to must be longer than dist from s to v\n      if(G[s][i].cap > 0 && level[s] < level[ G[s][i].to ]){\n        int d = dfs(G, level, used, iter, G[s][i].to, min(f, G[s][i].cap), t);\n        if(d>0){\n          G[s][i].cap -= d;\n          G[ G[s][i].to ][ G[s][i].rev ].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n}\n\nint dinic_maxflow(vector<vector<edge> > &G, int s, int t){\n  const int INF = 100000000;\n  int flow=0;\n  while(true){\n    vector<int> level(G.size(), -1);\n    vector<int> iter(G.size(), 0);\n    vector<bool> used(G.size(), false);\n    bfs(G, level, s);\n    if(level[t] < 0) return flow; //unable to achieve to t\n    while(true){\n      int f = dfs(G, level, used, iter, s, INF, t);\n      if(f==0) break;\n      else flow += f;\n    }\n  }\n}\n\nvoid add_edge(vector<vector<edge> > &G, int from, int to, int cap){\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint main(){\n  int n,h;\n  cin >> n,h;\n  vector<int> a(n),b(n),c(n),d(n);\n  for(int i=0; i<n; i++){\n    cin >> a[i],b[i],c[i],d[i];\n  }\n\n  map<pair<int,int>, int> in_cnt;\n  map<pair<int,int>, int> out_cnt;\n  for(int i=0; i<n; i++){\n    if( c[i] == 0 ){\n      in_cnt[ {a[i], 0} ]++;\n    }else{\n      in_cnt[ {c[i], 1} ]++;\n    }\n    if( d[i] == 0 ){\n      out_cnt[ {b[i], 0} ]++;\n    }else{\n      out_cnt[ {d[i], 1} ]++;\n    }\n  }\n\n  map<tuple<int,int,int>, int> dict;\n  int idx = 0;\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n\n  int zero_0 = idx++;\n  int zero_1 = idx++;\n  int source = idx++;\n  int sink = idx++;\n\n  int super_source = idx++;\n  int super_sink = idx++;\n\n  vector<vector<edge>> G(idx);\n\n  add_edge(G, zero_0, zero_1, n+10);\n  add_edge(G, super_source, zero_1, 1);\n  add_edge(G, zero_0, super_sink, 1);\n\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, v, sink, p.second);\n    if( p.first.second == 0 ){\n      add_edge(G, zero_1, v, p.second);\n    }\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, source, v, p.second);\n    auto r = make_tuple(0, p.first.first, p.first.second^1);\n    if( dict.count(r) ){\n      add_edge(G, v, dict[r], p.second);\n    }\n\n    if( p.first.second == 0 ){\n      add_edge(G, v, zero_0, p.second);\n    }\n  }\n\n  int f = 0;\n  f += dinic_maxflow(G, super_source, sink);\n  f += dinic_maxflow(G, source, super_sink);\n  if( f != 2 ){\n    println(\"NO\");\n    return 0;\n  }\n  f--;\n\n  add_edge(G, super_source, source, n+100);\n  add_edge(G, sink, super_sink, n+100);\n\n  f += dinic_maxflow(G, super_source, super_sink);\n  f += dinic_maxflow(G, souce, sink);\n\n  println( f==n ? \"YES\" : \"NO\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint d1[401];\nint d2[401];\nint f[401];\nint g[401][401];\nvector <int> v[401];\n\nvoid dfs(int x) {\n    int i;\n    \n    f[x] = 1;\n    \n    for (i = 0; i < v[x].size(); i++) {\n        if (f[v[x][i]] == 1) continue;\n        \n        dfs(v[x][i]);\n    }\n}\n\nint main() {\n    int n, h, p = 200, i, j;\n    \n    scanf(\"%d %d\", &n, &h);\n    \n    for (i = 0; i < n; i++) {\n        int a, b, c, d, x, y;\n        \n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        \n        if (c == 0) {\n            x = a;\n        } else {\n            x = -c;\n        }\n        \n        if (d == 0) {\n            y = -b;\n        } else {\n            y = d;\n        }\n        \n        g[x + p][y + p]++;\n    }\n    \n    for (i = 0; i <= p * 2; i++) {\n        for (j = 0; j <= p * 2; j++) {\n            if (g[i][j] > 0) {\n                d1[i] += g[i][j];\n                d2[j] += g[i][j];\n                v[i].push_back(j);\n            }\n        }\n    }\n    \n    for (i = 0; i < p; i++) {\n        if (d1[i] > d2[i]) {\n            puts(\"NO\");\n            \n            return 0;\n        } else if (d1[i] < d2[i]) {\n            d1[i] = d2[i];\n            v[i].push_back(p);\n        }\n    }\n    \n    for (i = p + 1; i <= p * 2; i++) {\n        if (d1[i] < d2[i]) {\n            puts(\"NO\");\n            \n            return 0;\n        } else if (d1[i] > d2[i]) {\n            d2[i] = d1[i];\n            v[p].push_back(i);\n        }\n    }\n    \n    dfs(p);\n    \n    for (i = 0; i <= p * 2; i++) {\n        if (f[i] == 0 && d1[i] > 0) {\n            puts(\"NO\");\n            \n            return 0;\n        }\n    }\n    \n    puts(\"YES\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n, h;\n\nint f(int d, int u){\n\treturn d?(h+d):u;\n}\n\nint g(int d, int u){\n\treturn d?d:(h+u);\n}\n\nint out[410];\nint in[410];\nint par[410];\nint chk[410];\n\nint r(int x){return (par[x]==x)?x:(par[x]=r(par[x])); }\nvoid join(int a, int b){ par[r(a)]=r(b); }\n\nvoid In(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1; i<2*h; ++i) par[i]=i;\n\tfor(int i=1; i<=n; ++i){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x = f(c, c+a);\n\t\tint y = g(d, d+b);\n\t\tjoin(x, y);\n\t\tout[x]++; in[y]++;\n\t}\n}\n\nbool check(){\n\tfor(int i=1; i<=2*h-1; ++i){\n\t\tif(out[i] > in[i]){\n\t\t\tif(i > h) return 0;\n\t\t\tchk[r(i)]=1;\n\t\t}\n\t\tif(out[i] < in[i]){\n\t\t\tif(i <= h) return 0;\n\t\t}\n\t}\n\tfor(int i=1; i<=2*h-1; ++i) if((out[i] || in[i]) && !chk[r(i)]) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tIn();\n\tputs(check()?\"YES\":\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, H, A[100009], B[100009], C[100009], D[100009], L[100009], R[100009], deg[100009], col[100009], cnts, cnt; bool used[100009];\nvector<int>x[100009];\n\nvoid dfs1(int pos) {\n\tif (col[pos] >= 1) return;\n\tcol[pos] = cnts;\n\tfor (int i = 0; i < x[pos].size(); i++) dfs1(x[pos][i]);\n}\n\nint main() {\n\tFILE *in = freopen(\"in1.txt\", \"r\", stdin);\n\tcin >> N >> H; H++;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\t\tif (C[i] == 0) { L[i] = -A[i]; cnt++; }\n\t\telse { L[i] = C[i]; }\n\t\tif (D[i] == 0) { R[i] = -B[i]; cnt++; }\n\t\telse { R[i] = D[i]; }\n\t\tR[i] *= -1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint a1 = 0, a2 = 0;\n\t\tif (L[i] < 0) a1 = H + (-L[i]); else a1 = L[i];\n\t\tif (R[i] < 0) a2 = H + (-R[i]); else a2 = R[i];\n\t\tdeg[a1]++; deg[a2]--; used[a1] = true; used[a2] = true;\n\t\tx[a1].push_back(a2); x[a2].push_back(a1);\n\t}\n\tbool OK = true; int V = 0;\n\tfor (int i = 0; i < H; i++) { if (deg[i] > 0) OK = false; }\n\tfor (int i = H; i < 2 * H; i++) { if (deg[i] < 0) OK = false; else V += deg[i]; }\n\n\tfor (int i = 0; i < 2 * H; i++) {\n\t\tif (col[i] == 0 && used[i] == true) { cnts++; dfs1(i); }\n\t}\n\tif (cnts > (cnt - N - 1) + 1) OK = false;\n\n\tif (OK == true) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint num[403][2]={0}; \nint dou[403]={0};\nint main(){\n\tint n,h,t;\t\n\tcin>>n>>h;\n\tvector<int>pic[4];\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tpic[j].push_back(t);\n\t\t}\t\n\t} \n\tint a,b;\n\tfor(int i=0;i<pic[0].size();i++){\n\t\tif(pic[2][i]==0) \n\t\t\ta=pic[0][i];\n\t\telse \n\t\t\ta=200+pic[2][i];\n\t\tif(pic[3][i]==0) \n\t\t\tb=200+pic[1][i];\n\t\telse\n\t\t\tb=pic[3][i];\n\t\tif(a==b)\n\t\t\tdou[a]++;\n\t\tnum[b][1]++;\n\t\tnum[a][0]++;\n\t}\n\tint flag1=0,flag2=0,flag=0;\n\tfor(int i=0;i<403;i++){\n\t\tif(num[i][0]>num[i][1]) {\n\t\t\tif(((num[i][0]-1)==num[i][1])&&(i<200)){\n\t\t\t\tflag1++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(num[i][0]<num[i][1]) {\n\t\t\tif(((num[i][0]+1)==num[i][1])&&(i>=200)){\n\t\t\t\tflag2++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(dou[i]>0&&num[i][0]<=dou[i]&&num[i][1]<=dou[i]){\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag1==flag2&&flag1>0&&flag==0) cout<<\"YES\";\n\telse cout<<\"NO\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<20;\nint fa[Q];\nint in[Q],out[Q];\nint gf(int x)\n{return fa[x]==x?x:(fa[x]=gf(fa[x]));}\nvoid ins(int x,int y)\n{\n    out[x]++;\n    in[y]++;\n    int fx=gf(x),fy=gf(y);\n    if(fx!=fy)fa[fx]=fy;\n}\n// int Idiot_Sap(int x,int flow)\n// {\n//     if(x==T)return flow;\n//     int had=0;\n//     for(int t=las[x];t;t=nn[t]){\n//         int y=e[t];\n//         if((!c[t])||dis[x]-1!=dis[y])continue;\n//         int del=Idiot_Sap(y,min(c[t],flow-had));\n//         c[t]-=del;\n//         c[t^1]+=del;\n//         had+=del;\n//         if(dis[S]>=T||had==flow)return had;\n//     }\n//     if(dis[S]>=T)return had;\n//     --cnt[dis[x]];\n//     if(!cnt[dis[x]])dis[S]=T;\n//     cnt[++dis[x]]++;\n//     return had;\n// }\nint had[Q];\nint main()\n{\n    int n,h;\n    cin>>n>>h;\n    h+=5;\n    for(int i=1;i<=h+h;i++)fa[i]=i;\n    for(int i=1,a,b,c,d;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        ++a,++b,++c,++d;\n        int x,y;\n        if(c==1)x=a+h;\n        else x=c;\n        if(d==1)y=b;\n        else y=d+h;\n        // printf(\"%d %d LINK\\n\",x,y);\n        ins(x,y);\n    }\n    for(int i=1;i<=h;i++)if(out[i]>in[i])return puts(\"NO\")&0;\n    for(int i=h+1;i<=h+h;i++)if(out[i]<in[i])return puts(\"NO\")&0;\n    for(int i=1;i<=h+h;i++)if(in[i]!=out[i])had[gf(i)]=1;\n    for(int i=1;i<=h+h;i++)if(in[i]&&out[i]&&(!had[gf(i)]))return puts(\"NO\")&0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    int n,h;\n    cin >>n>>h;\n    vector<pair<int,int>> rb{},lb{},rt{},lt{};\n    for (int i=0;i<n;i++){\n        int a,b,c,d;\n        cin>>a>>b>>c>>d;\n        if(c==0){\n            lb.push_back({i,a});\n        }else{\n            lt.push_back({i,c});\n        }\n        if(d==0){\n            rb.push_back({i,b});\n        }else{\n            rt.push_back({i,d});\n        }\n    }\n    sort(lb.begin(),lb.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(rb.begin(),rb.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(lt.begin(),lt.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n    sort(rt.begin(),rt.end(),[](pair<int,int>p1,pair<int,int>p2){return p1.second < p2.second;});\n\n//    cout<<rb.size()<<\" \"\n//        <<rt.size()<<\" \"\n//        <<lb.size()<<\" \"\n//        <<lt.size()<<endl;\n\n    if(rb.size()-lt.size()<=0 ||\n       lb.size()-rt.size()<=0 ||\n       rb.size()-lt.size()!=lb.size()-rt.size()\n       ) {\n        cout<<\"NO\"<<endl;\n        return 0;\n    }\n    if(rb.size()==lt.size()+1){\n        int k=rb.size()-1,l=lb.size()-1;\n        for(int i=0;i<lt.size();i++){\n            static int offset=0;\n            if(lt.at(i).second!=rb.at(i+offset).second){\n                if(offset==1){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                if(lt.at(i).second!=rb.at(i+1).second){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                offset=1;\n                k=i;\n            }\n        }\n        for(int i=0;i<rt.size();i++){\n            static int offset=0;\n            if(rt.at(i).second!=lb.at(i+offset).second){\n                if(offset==1){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                if(rt.at(i).second!=lb.at(i+1).second){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                offset=1;\n                l=i;\n            }\n        }\n        if(rb.at(k).first==lb.at(l).first){\n            if((k==rb.size() || rb.at(k+1).second!=rb.at(k).second) &&\n               (k==0 || rb.at(k-1).second!=rb.at(k).second) &&\n               (l==lb.size() || lb.at(l+1).second!=lb.at(l).second) &&\n               (l==0 || lb.at(l-1).second!=lb.at(l).second)\n                    ) {\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n        }\n        cout<<\"YES\"<<endl;\n        return 0;\n    }\n    for(int i=0;i<lt.size();i++){\n        static int offset=0;\n        if(lt.at(i).second!=rb.at(i+offset).second){\n            if(offset==rb.size()-lt.size()){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            offset++;\n            while(lt.at(i).second!=rb.at(i+offset).second){\n                if(offset==rb.size()-lt.size()){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                offset++;\n            }\n        }\n    }\n    for(int i=0;i<rt.size();i++){\n        static int offset=0;\n        if(rt.at(i).second!=lb.at(i+offset).second){\n            if(offset==lb.size()-rt.size()){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            offset++;\n            while(rt.at(i).second!=lb.at(i+offset).second){\n                if(offset==lb.size()-rt.size()){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                offset++;\n            }\n        }\n    }\n                    cout<<\"YES\"<<endl;\n                    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5, MAXM = 200;\n\nint n, m;\n\ninline void input()\n{\n\tn = read<int>(), m = read<int>();\n}\n\nvector<int> adj[MAXN + 5];\nint vis[MAXN + 5], edge_cnt = 0;\n\ninline void dfs(int u)\n{\n\tvis[u] = 1, edge_cnt += SZ(adj[u]);\n\tfor(auto v : adj[u]) if(!vis[v]) dfs(v);\n}\n\ninline void solve()\n{\n\tstatic int indeg[MAXM * 2 + 5], outdeg[MAXM * 2 + 5];\n\tstatic int plg[MAXM + 5], skt[MAXM + 5], type[MAXM * 2 + 5];\n\tint cnt = 0;\n\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\ttype[plg[i] = ++cnt] = 0;\n\t\ttype[skt[i] = ++cnt] = 1;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tint a = read<int>(), b = read<int>(), c = read<int>(), d = read<int>();\n\t\tint u = c == 0 ? plg[a] : skt[c];\n\t\tint v = d == 0 ? skt[b] : plg[d];\n\t\tadj[u].push_back(v);\n\t\t++outdeg[u], ++indeg[v];\n\t}\n\n\tint din = 0, dout = 0;\n\tfor(int i = 1; i <= cnt; ++i) if(indeg[i] != outdeg[i])\n\t{\n\t\tif(outdeg[i] > indeg[i])\n\t\t{\n\t\t\tif(type[i] == 1) { puts(\"NO\"); return; }\n\t\t\tdout += outdeg[i] - indeg[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(type[i] == 0) { puts(\"NO\"); return; }\n\t\t\tdin += indeg[i] - outdeg[i];\n\t\t}\n\t}\n\tif(din != dout) { puts(\"NO\"); return; }\n\n\tfor(int i = 1; i <= n; ++i) if(!vis[i] && outdeg[i] > indeg[i]) dfs(i);\n\tif(edge_cnt < n) { puts(\"NO\"); return; }\n\n\tputs(\"YES\");\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 405\nint n, h, ins[N], out[N], bel[N];\nbool flg[N];\nint Getbel(int x){return bel[x] == x ? x : bel[x] = Getbel(bel[x]);}\nint main()\n{\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 1; i <= (h << 1); i++)\n\t\tbel[i] = i;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x = c ? c + h : a, y = d ? d : b + h;\n\t\tout[x]++, ins[y]++;\n\t\tx = Getbel(x), y = Getbel(y);\n\t\tif (x != y)\n\t\t\tbel[x] = y;\n\t}\n\tfor (int i = 1; i <= h; i++)\n\t\tif (ins[i] > out[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i = h + 1; i <= (h << 1); i++)\n\t\tif (ins[i] < out[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i = 1; i <= (h << 1); i++)\n\t\tif (ins[i] != out[i] || (!ins[i] && !out[i]))\n\t\t\tflg[Getbel(i)] = 1;\n\tfor (int i = 1; i <= (h << 1); i++)\n\t{\n\t\tif (bel[i] == i && !flg[i])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define MP make_pair\n#define MT make_tuple\n#define EACH(i,c) for(auto i: c)\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, H;\n\tcin >> N >> H;\n\n\tmap<int, int> lA, lC, rB, rD, lArD, rBlC;\n\tint x = 0, y = 0;\n\tREP(i, N){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif(c == 0){\n\t\t\tlA[a]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\tlC[c]++;\n\t\t\ty++;\n\t\t}\n\t\tif(d == 0){\n\t\t\trB[b]++;\n\t\t\tx++;\n\t\t}\n\t\telse{\n\t\t\trD[d]++;\n\t\t\ty++;\n\t\t}\n\n\t\tif(c == 0 && a == d) lArD[a]++;\n\t\tif(d == 0 && b == c) rBlC[b]++;\n\t}\n\n\tif(y + 2 > x){\n\t\tcerr << x << \" \" << y << endl;\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\n\tEACH(pc, lC){\n\t\tif(rB[pc.first] < pc.second + rBlC[pc.first]){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEACH(pd, rD){\n\t\tif(lA[pd.first] < pd.second + lArD[pd.first]){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\tcout << \"YES\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 505\nusing namespace std;\nint n,m,a[N],b[N],c[N],d[N],deg[M];\nvoid GG(){ printf(\"NO\"); exit(0);}\nint main()\n{\n\tint i,x,y;\n\tscanf(\"%d %d\",&n,&m),m=2*m+1;\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tif(c[i]!=0) x=2*c[i]+1; else x=2*a[i];\n\t\tif(d[i]!=0) y=2*d[i]; else y=2*b[i]+1;\n\t\tdeg[x]++,deg[y]--;\n\t  }\n\tfor(i=1;i<=m;i++)\n\t\tif(deg[i]!=0){\n\t\t\tif(abs(deg[i])>1) GG();\n\t\t\tif(deg[i]==1&&(i&1)) GG();\n\t\t\tif(deg[i]==-1&&(~i&1)) GG();\n\t\t  }\n\tprintf(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 409\n#define M 200009\nusing namespace std;\n\nint n,m,sz1,sz2,tot,fst[N],pnt[M],nxt[M],f[M],g[M]; bool vis[N];\nvoid add(int x,int y){\n\tpnt[++tot]=y; nxt[tot]=fst[x]; fst[x]=tot;\n}\nvoid ins(int x,int y){\n\tadd(x,y); add(y,x); f[y]++; g[x]++;\n}\nvoid dfs(int x){\n\tvis[x]=1; if (!f[x] && !g[x]) return;\n\tint i,y; \n\tsz1+=(x<=n && f[x]<g[x]); sz2+=(x>n && f[x]>g[x]);\n\tif (x<=n && f[x]>g[x] || x>n && f[x]<g[x]){\n\t\tputs(\"NO\"); exit(0);\n\t}\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];\n\t\tif (!vis[y]) dfs(y);\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&m,&n);\n\tint i,x,y,u,v;\n\twhile (m--){\n\t\tscanf(\"%d%d%d%d\",&x,&y,&u,&v);\n\t\tins(u?u+n:x,v?v:y+n);\n\t}\n\tfor (i=1; i<=(n<<1); i++) if (!vis[i] && f[i]+g[i]){\n\t\tsz1=sz2=0; dfs(i);\n\t\tif (!sz1 || !sz2){ puts(\"NO\"); return 0; }\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define rs (x<<1|1)\n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=2e2+5;\nint n,h;\nmultiset<int>dd1[maxn],dd2[maxn],uu1[maxn],uu2[maxn],ud[maxn],du[maxn];\nmultiset<int>nud[maxn],ndu[maxn];\ntypedef multiset<int>::iterator It;\nint main(){\n\tread(n);read(h);\n\trep(i,1,n){\n\t\tint a,b,c,d;read(a);read(b);read(c);read(d);\n\t\tif(!c){\n\t\t\tif(!d)dd1[a].insert(b),dd2[b].insert(a);\n\t\t\telse du[a].insert(d);\n\t\t}else{\n\t\t\tif(!d)ud[b].insert(c);\n\t\t\telse uu1[c].insert(d),uu2[d].insert(c);\n\t\t}\n\t}\t\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(ud[i])){\n\t\t\tflag=1;\n\t\t\tIt it=ud[i].begin();\n\t\t\tud[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(ud[x])){\n\t\t\t\tIt it2=ud[x].begin();\n\t\t\t\tud[x].erase(it2);\n\t\t\t\tud[i].insert(*it2);\n\t\t\t}else nud[x].insert(*it);\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(du[i])){\n\t\t\tflag=1;\n\t\t\tIt it=du[i].begin();\n\t\t\tdu[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(du[x])){\n\t\t\t\tIt it2=du[x].begin();\n\t\t\t\tdu[x].erase(it2);\n\t\t\t\tdu[i].insert(*it2);\n\t\t\t}else ndu[x].insert(*it);\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(nud[i])){\n\t\t\tflag=1;\n\t\t\tIt it=nud[i].begin();\n\t\t\tnud[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(dd2[x])){\n\t\t\t\tIt it2=dd2[x].begin();\n\t\t\t\tdd2[x].erase(it2);\n\t\t\t\tdd1[*it2].erase(dd1[*it2].find(x));\n\t\t\t\tdd1[*it2].insert(i);\n\t\t\t\tdd2[i].insert(*it2);\n\t\t\t}else{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tbool flag=0;\n\t\trep(i,1,h)if(SZ(ndu[i])){\n\t\t\tflag=1;\n\t\t\tIt it=ndu[i].begin();\n\t\t\tndu[i].erase(it);\n\t\t\tint x=*it;\n\t\t\tif(SZ(dd1[x])){\n\t\t\t\tIt it2=dd1[x].begin();\n\t\t\t\tdd1[x].erase(it2);\n\t\t\t\tdd2[*it2].erase(dd2[*it2].find(x));\n\t\t\t\tdd2[*it2].insert(i);\n\t\t\t\tdd1[i].insert(*it2);\n\t\t\t}else{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(1){\n\t\tint flag=0;\n\t\trep(i,1,h)if(SZ(dd1[i])>SZ(uu2[i])){\n\t\t\tflag=1;\n\t\t\tIt it=dd1[i].begin();\n\t\t\tdd1[i].erase(it);\n\t\t\tdd2[*it].erase(dd2[*it].find(i));\n\t\t\tint x=*it;\n\t\t\tif(SZ(uu1[x])){\n\t\t\t\tIt it2=uu1[x].begin();\n\t\t\t\tuu1[x].erase(it2);\n\t\t\t\tuu2[*it2].erase(uu2[*it2].find(x));\n\t\t\t\tif(SZ(dd1[*it2])){\n\t\t\t\t\tIt it3=dd1[*it2].begin();\n\t\t\t\t\tdd1[*it2].erase(it3);\n\t\t\t\t\tdd2[*it3].erase(dd2[*it3].find(*it2));\n\t\t\t\t\tdd1[i].insert(*it3);\n\t\t\t\t\tdd2[*it3].insert(i);\n\t\t\t\t}else return puts(\"NO\"),0;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\trep(i,1,h)if(SZ(dd1[i]))return puts(\"NO\"),0;\n\trep(i,1,h)if(SZ(uu1[i]))return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define ph push\n#define ptc putchar\n#define enter putchar('\\n')\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef long long lnt;\ninline int read(){\n\t   int x = 0;char c = getchar();\n\t   while (!isdigit(c)) c = getchar();\n\t   while (isdigit(c)) x = (x << 1) + (x << 3) + c - '0' , c = getchar();\n\t   return x;\n}\ninline void write(int x){\n\t   if (!x){\n          ptc('0');\n          return;\n\t   }\n\t   int dg[20] , len = 0;\n\t   while (x) dg[len++] = x % 10 , x /= 10;\n\t   while (len--) ptc(dg[len]+'0');\n}\ninline void writeln(int x){\n\t   write(x);\n\t   ptc('\\n');\n}\nconst int N = 1e5 + 10;\nconst int M = 2e2 + 10;\n\nint par[M << 1] , sz[M << 1];\nint find(int x){\n\tif (par[x] != x){\n\t\treturn par[x] = find(par[x]);\n\t}\n\treturn par[x];\n}\nvoid merge(int x,int y){\n//\tprintf(\"[] %d %d %d %d\\n\",x,y,find(x),find(y));\n\tx = find(x) , y = find(y);\n\tif (x != y){\n\t\tpar[x] = y;\n\t}\t\n\tsz[y]++;\n}\nint ind[M << 1] , outd[M << 1] , okay[M << 1];\nint n , h;\n\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i = 1;i <= h << 1;i++) par[i] = i;\n\tfor (int i = 1;i <= n;i++){\n\t\tint A , B , C , D;\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tint l = C ? C : A + h , r = D ? D + h : B;\n\t\tmerge(l , r);\n\t\t\n//\t\tprintf(\"%d -> %d\\n\",l,r);\n\t\toutd[l]++;\n\t\tind[r]++;\n\t}\n\t\n\tfor (int i = 1;i <= h;i++){\n\t\tif (ind[i] < outd[i]) return puts(\"NO\") , 0;\n\t}\n\t\n\tfor (int i = 1 + h;i <= h << 1;i++){\n\t\tif (ind[i] > outd[i]) return puts(\"NO\") , 0;\n\t}\n//\tprintf(\"%d %d\\n\",ind[2],outd[2]);\n\t\n\tfor (int i = 1;i <= h << 1;i++)\n\tif (ind[i] != outd[i] || !sz[find(i)]) {\n//\t\tprintf(\"__ %d %d\\n\",i,find(i));\n\t\tokay[find(i)] = 1;\n\t}\n\t\n\tfor (int i = 1;i <= h << 1;i++) if (!okay[find(i)]) {\n//\t\tprintf(\"[%d]\\n\",i);\n\t\treturn puts(\"NO\");\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint inadj[210][2], outadj[210][2], n, h;\nint inadj2[210][2], outadj2[210][2];\npair<int, int> thing(int a, int b)\n{\n\tpair<int, int> ans;\n\tif (b) ans = { b, 0 };\n\telse ans = { a, 1 };\n\treturn ans;\n}\nvector<pair<int, int> > adj[210][2];\nint seen[210][2], c;\nvector<pair<int, int> > components[500];\nvoid dfs(int a, int b, int d)\n{\n\tif (seen[a][b]) return;\n\tseen[a][b] = 1;\n\tcomponents[d].push_back({ a, b });\n\tfor (auto c : adj[a][b]) dfs(c.first, c.second, d);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tpair<int, int> in, out;\n\t\tin = thing(a, c);\n\t\tout = thing(b, d);\n\t\tout.second = !out.second;\n\t\toutadj[in.first][in.second]++;\n\t\tinadj[out.first][out.second]++;\n\t\tadj[in.first][in.second].push_back(out);\n\t\tadj[out.first][out.second].push_back(in);\n\t}\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tif (adj[i][j].size() && !seen[i][j]) dfs(i, j, c++);\n\t\t//\tprintf(\"%d:%d - in %d, out %d\\n\", i, j, inadj[i][j], outadj[i][j]);\n\t\t}\n\t}\n\tbool works = 1;\n\tfor (int i = 0; i < c; i++)\n\t{\n\t\tfor (int i = 0; i <= h; i++) inadj2[i][0] = inadj2[i][1] = outadj2[i][0] = outadj2[i][1] = 0;\n\t\tfor (auto b : components[i])\n\t\t{\n\t\t\tinadj2[b.first][b.second] += inadj[b.first][b.second];\n\t\t\toutadj2[b.first][b.second] += outadj[b.first][b.second];\n\t\t}\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t//\tprintf(\"%d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\tif (inadj2[i][0] - outadj2[i][0] > 0 && inadj2[i][1] - outadj2[i][1] < 0 && 0) \n\t\t\t{\n\t\t\t//\tprintf(\"%d\\n\", i);\n\t\t\t\tinadj2[i][0]--; \n\t\t\t\toutadj2[i][1]--;\n\t\t\t//\tprintf(\" %d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\t}\n\t\t}\n\t\tint extra = 0;\n\t\tbool fails = 0;\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t{\n\t\t\t\textra += abs(inadj2[i][j] - outadj2[i][j]);\n\t\t\t\tif (!j && inadj2[i][j] - outadj2[i][j] < 0) fails = 1;\n\t\t\t\tif (j && inadj2[i][j] - outadj2[i][j] > 0) fails = 1;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\", extra);\n\t\tif (extra % 2 || !extra || fails) works = 0;\n\t}\n//\tprintf(\"Components %d\\n\", c);\n\tif (works) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<P>vec;\nint sum[405];\nint par[405],ran[405];\nvoid init(){ for(int i=0;i<405;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nint cnt[405],X;\nset<int>S;\nint main(){\n\tcin>>n>>m;init();\n\trep(i,n){\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\t\tif(c==0) a+=200; else a=c;\n\t\tif(d==0); else b=200+d;\n\t\tvec.pb(mp(a,b));//cout<<a<<\" \"<<b<<endl;\n\t\tsum[a]++; sum[b]--; unite(a,b);S.insert(a);S.insert(b);X=a;\n\t}\n\tint val = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(sum[i]>0){\n\t\t\tputs(\"NO\");return 0;\n\t\t}\n\t\telse cnt[i] = -1*sum[i];\n\t\tval+=cnt[i];\n\t\tif(sum[200+i]<0){\n\t\t\tputs(\"NO\");return 0;\n\t\t}\n\t\telse cnt[200+i] = sum[i];\n\t}\n\tif(!val){puts(\"NO\");return 0;}\n\twhile(1){\n\t\tbool upd = 0;\n\t\t{\n\t\t\trepn(i,m)repn(j,m){\n\t\t\t\tif(cnt[i]>=1&&cnt[j+200]>=1&&!same(i,j+200)){\n\t\t\t\t\tunite(i,j+200);cnt[i]--;cnt[j+200]--;upd=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!upd) break;\n\t}\n\tfor(set<int>::iterator it=S.begin();it!=S.end();++it){\n\t\tif(!same(*it,X)){\n\t\t\tputs(\"NO\");return 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 200011\n#define maxH 555\n\nint n, h, i;\nint a, b, c, d, l, r;\nvector<int> list[maxH];\nint in[maxH], out[maxH];\nbool us[maxN], any;\n\nvoid no_sol() {\n    printf(\"NO\");\n    exit(0);\n}\n\nvoid dfs(int node) {\n    us[node] = true;\n    if (in[node] != out[node]) any = true;\n    if (in[node] == 0 && out[node] == 0) any = true;\n    for (auto to : list[node])\n        if (!us[to])\n            dfs(to);\n}\n\nint main()\n{\n //   freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d%d\", &n, &h);\n    for (i = 1; i <= n; i++) {\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        if (c == 0) l = a;\n        else        l = -c;\n\n        if (d == 0) r = -b;\n        else        r = d;\n\n        l += h;\n        r += h;\n        list[l].pb(r);\n        list[r].pb(l);\n        in[r]++;\n        out[l]++;\n    }\n\n    for (i = 1; i <= h; i++)\n        if (out[i + h] < in[i + h])\n            no_sol();\n\n    for (i = 1; i <= h; i++)\n        if (out[-i + h] > in[-i + h])\n            no_sol();\n\n    for (i = 1; i <= h; i++) {\n        if (!us[i + h]) {\n            any = false;\n            dfs(i + h);\n            if (!any) no_sol();\n        }\n\n        if (!us[-i + h]) {\n            any = false;\n            dfs(-i + h);\n            if (!any) no_sol();\n        }\n    }\n\n\n    printf(\"YES\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nconst int MAX_H = 100;\nint in[1+2*MAX_H], out[1+2*MAX_H];\nint sef[1+2*MAX_H];\n\nint myfind(int x) {\n  if(sef[x] == x)\n    return x;\n  else {\n    sef[x] = myfind(sef[x]);\n    return sef[x];\n  }\n}\n\nvoid myunion(int a, int b) {\n  int ba, bb;\n  ba = myfind(a);\n  bb = myfind(b);\n  if(ba != bb)\n    sef[ba] = bb;\n}\n\nint groundvert(int x) {\n  return x + MAX_H;\n}\n\nint heightvert(int x) {\n  return x;\n}\n\nint main() {\n  int n, h, a, b, c, d, nod1, nod2;\n  bool ok = true, inok, outok;\n  scanf(\"%d%d\", &n, &h);\n\n  for(int i = 1; i <= 2 * MAX_H; ++i)\n    sef[i] = i;\n\n  for(int i = 0; i < n; ++i) {\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    if(c == 0)\n      nod1 = groundvert(a);\n    else\n      nod1 = heightvert(c);\n    out[nod1]++;\n\n    if(d == 0)\n      nod2 = heightvert(b);\n    else\n      nod2 = groundvert(d);\n    in[nod2]++;\n    myunion(nod1, nod2);\n  }\n\n  inok = outok = false;\n  for(int i = 1; i <= 2 * MAX_H; ++i) {\n    if(in[i] + out[i] > 0)\n      printf(\"~%d %d %d\\n\", i, in[i], out[i]);\n    if(abs(in[i] - out[i]) >= 2)\n        ok = false;\n    else if(in[i] - out[i] == 1) {\n      if(i <= MAX_H)\n        ok = false;\n\n      if(inok) {\n        ok = false;\n      } else\n        inok = true;\n    } else if(in[i] - out[i] == -1) {\n      if(i <= MAX_H)\n        ok = false;\n\n      if(outok)\n        ok = false;\n      else\n        outok = true;\n    }\n  }\n\n  for(int i = 1; i <= 2 * MAX_H; ++i)\n    if(in[i] + out[i] > 0)\n      for(int j = 1; j <= 2 * MAX_H; ++j)\n        if(in[j] + out[j] > 0 && myfind(i) != myfind(j))\n          ok = false;\n  if(ok)\n    printf(\"YES\");\n  else\n    printf(\"NO\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define X 250\nnamespace MCF {\n\t#define MAXN 252521\n\t#define MAXM 3641919\n\t#define wint int\n\t#define cint int\n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1001001001;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);toc=0;tof=0;\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t\n\t\tfor (bool cont = 1; cont ;) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i] + cEPS) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint, int> node;\n\t\t\tpriority_queue<node, vector<node>, greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(mp(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(mp(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f = min(f, capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint main()\n{\n\tint n,h,a,b,c,d;\n\tcin>>n>>h;\n\tint ss=2*n+2*X,bs=2*n+2*X+1,sg=bs+1,bg=sg+1,S=bg+1,T=S+1;\n\tMCF::init(T+10);\n\trep(i,n){\n\t\tcin>>a>>b>>c>>d;\n\t\tif(c==0){\n\t\t\tMCF::ae(ss,i,1,0);\n\t\t\tMCF::ae(2*n+X+a,i,1,0);\n\t\t}\n\t\telse{\n\t\t\tMCF::ae(2*n+c,i,1,0);\n\t\t}\n\t\tif(d==0){\n\t\t\tMCF::ae(n+i,sg,1,0);\n\t\t\tMCF::ae(n+i,2*n+b,1,0);\n\t\t\tMCF::ae(n+i,ss,1,0);\n\t\t}\n\t\telse{\n\t\t\tMCF::ae(n+i,2*n+X+d,1,0);\n\t\t}\n\t\tMCF::ae(n+i,i,1,1);\n\t\tMCF::ae(S,n+i,1,0);\n\t\tMCF::ae(i,T,1,0);\n\t}\n\tMCF::ae(bs,ss,1,0);MCF::ae(sg,bg,1,0);MCF::ae(S,bs,1,0);MCF::ae(bg,T,1,0);\n\tMCF::solve(S,T);MCF::solve(S,bg);MCF::solve(bs,T);MCF::solve(bs,bg);\n\t//MCF::solve(bs,bg);MCF::solve(S,bg);MCF::solve(bs,T);MCF::solve(S,T);\n\t//cout<<MCF::toc<<' '<<MCF::tof<<endl;\n\tif(MCF::toc==0 && MCF::tof==1+n) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\n\n\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint th = 0;\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, c[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st != e[401]||st>=e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\n\tbool exiroad[402][402] = {};\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tfill(chked, chked + 402, false);\n\t\tq.push(i); chked[i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front(); q.pop();\n\t\t\trep(j, G[x].size()) {\n\t\t\t\tint to = G[x][j];\n\t\t\t\tif (chked[to])continue;\n\t\t\t\tchked[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\trep(j, 402) {\n\t\t\tif (chked[j]) {\n\t\t\t\texiroad[i][j] = true;\n\t\t\t\texi[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tRep(j, i + 1, 402) {\n\t\t\tif (!exi[j])continue;\n\t\t\tif (!exiroad[i][j] || !exiroad[j][i]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst long long INF = (1ll << 50);\nstruct graph {\n  typedef long long flow_type;\n  struct edge {\n    int src, dst;\n    flow_type capacity, flow;\n    size_t rev;\n  };\n  int n;\n  vector<vector<edge>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst, flow_type capacity) {\n    adj[src].push_back({src, dst, capacity, 0, adj[dst].size()});\n    adj[dst].push_back({dst, src, 0, 0, adj[src].size()-1});\n  }\n  flow_type max_flow(int s, int t, bool first=false) {\n    if (first) {\n      for (int u = 0; u < n; ++u) // initialize\n      for (auto &e: adj[u]) e.flow = 0;\n    }\n\n    vector<int> level(n), iter(n);\n    function<int(void)> levelize = [&]() { // foward levelize\n      level.assign(n, -1); level[s] = 0;\n      queue<int> Q; Q.push(s);\n      while (!Q.empty()) {\n        int u = Q.front(); Q.pop();\n        if (u == t) break;\n        for (auto &e: adj[u]) {\n          if (e.capacity > e.flow && level[e.dst] < 0) {\n            Q.push(e.dst);\n            level[e.dst] = level[u] + 1;\n          }\n        }\n      }\n      return level[t];\n    };\n    function<flow_type(int, flow_type)> augment = [&](int u, flow_type cur) {\n      if (u == t) return cur;\n      for (int &i = iter[u]; i < adj[u].size(); ++i) {\n        edge &e = adj[u][i], &r = adj[e.dst][e.rev];\n        if (e.capacity > e.flow && level[u] < level[e.dst]) {\n          flow_type f = augment(e.dst, min(cur, e.capacity - e.flow));\n          if (f > 0) {\n            e.flow += f;\n            r.flow -= f;\n            return f;\n          }\n        }\n      }\n      return flow_type(0);\n    };\n\n    flow_type flow = 0;\n    while (levelize() >= 0) {\n      fill(all(iter), 0);\n      for (flow_type f; (f = augment(s, INF)) > 0; )\n        flow += f;\n    }\n    return flow;\n  }\n};\n\nint N;\nint H;\nint A[114514];\nint B[114514];\nint C[114514];\nint D[114514];\n\nint MakeVertex(int a, int c) {\n  if (c == 0) return a;\n  return c+(H+1);\n}\n\nsigned main(){\n  cin >> N >> H;\n\n  int S = 0;\n  int S2 = S+1;\n  int T2 = S2+1;\n  int l1 = T2+1;\n  int l2 = l1+N;\n  int l3 = l2+2*(H+2);\n  int l4 = l3+2*(H+2);\n  int gr = l4+N;\n  int grL = gr+N;\n  int grR = grL+N;\n  int T = grR+1;\n  graph g(T+1);\n\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    //g.add_edge(S, l1+i, 1);\n    g.add_edge(S2, l1+i, 1);\n    g.add_edge(S, T2, 1);\n    \n    int u = MakeVertex(B[i], D[i]);\n    g.add_edge(l1+i, l2+u, 1);\n    int v = MakeVertex(A[i], C[i]);\n    g.add_edge(l3+v, l4+i, 1);\n\n    //g.add_edge(l4+i, T, 1);\n    g.add_edge(S2, T, 1);\n    g.add_edge(l4+i, T2, 1);\n  }\n\n  reps(i, l2, l3) {\n    int u = i - l2;\n    int v = (u >= H+1) ? u-(H+1) : u+H+1;\n    g.add_edge(l2+u, l3+v, N);\n  }\n\n  g.add_edge(S, gr, N);\n  g.add_edge(gr, T, N);\n\n  // g.add_edge(S, grL, 1);\n  g.add_edge(S2, grL, 1);\n  g.add_edge(S, T2, 1);\n\n  // g.add_edge(grR, T, 1);\n  g.add_edge(S2, T, 1);\n  g.add_edge(grR, T2, 1);\n\n  reps(h, 1, H+1) {\n    int v = MakeVertex(h, 0);\n    g.add_edge(l2+v, gr, N);\n    g.add_edge(gr, l3+v, N);\n    g.add_edge(l2+v, grR, 1);\n    g.add_edge(grL, l3+v, 1);\n  }\n\n  LL a = g.max_flow(S2, T2, true);\n  LL b = g.max_flow(S, T2);\n  LL c = g.max_flow(S2, T);\n  LL d = g.max_flow(S, T);\n  //cout \n  //<< a << \",\" \n  //<< b << \",\"\n  //<< c << \",\"\n  //<< d << endl;\n\n  if (a+b == a+c && a+b == N*2+2) {\n    cout << \"YES\" << endl;\n    return 0;\n  }\n  cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\nconst int N = 1e5 + 10, H = 205;\nint n, h, deg[H << 1];\nbool ff, tag, vis[H << 1], mark[H << 1];\nvector<int> nxt[H << 1];\n\nvoid add(int x, int y) {\n    x += H, y += H;\n    mark[x] = mark[y] = 1;\n    nxt[x].push_back(y);\n    ++deg[y], --deg[x];\n}\n\nvoid dfs(int x) {\n    if ((x > H && deg[x] > 0) || (x < H && deg[x] < 0)) {\n        ff = 1; return;\n    }\n    if (deg[x]) tag = 1;\n    vis[x] = 1;\n    for (int i = 0; i < nxt[x].size(); i++) {\n        int y = nxt[x][i];\n        if (vis[y]) continue;\n        dfs(y);\n    }\n}\n\nint main() {\n    cin >> n >> h;\n    rep(i, 1, n) {\n        int a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        add(c ? -c : a, d ? d : -b);\n    }\n    rep(i, 1, H << 1) if (mark[i] && !vis[i]) {\n        ff = tag = 0;\n        dfs(i);\n        if (ff || !tag) return puts(\"NO\"), 0;\n    }\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\ntypedef struct{\n  int to;\n  int cap;\n  int rev;\n}edge;\n\n// node v : distance from s => level[v]\nvoid bfs(vector<vector<edge> > &G, vector<int> &level, int s){\n  fill(level.begin(), level.end(), -1);\n  queue<int> q;\n  q.push(s);\n  level[s] = 0;\n  while(!q.empty()){\n    int e=q.front(); q.pop();\n    for(int i=0; i<G[e].size(); i++){\n      if(G[e][i].cap > 0 && level[G[e][i].to] < 0){\n        level[G[e][i].to] = level[e] + 1;\n        q.push(G[e][i].to);\n      }\n    }\n  }\n}\n\nint dfs(vector<vector<edge> > &G, vector<int> &level, vector<bool> &used, vector<int> &iter, int s, int f,  int t){\n  if(s==t) return f;\n  else{\n    //iter[e] : done searching from v[0] to v[ iter[e]-1 ]\n    for(int &i=iter[s]; i<G[s].size(); i++){\n      //distance from s to v[e][i].to must be longer than dist from s to v\n      if(G[s][i].cap > 0 && level[s] < level[ G[s][i].to ]){\n        int d = dfs(G, level, used, iter, G[s][i].to, min(f, G[s][i].cap), t);\n        if(d>0){\n          G[s][i].cap -= d;\n          G[ G[s][i].to ][ G[s][i].rev ].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n}\n\nint dinic_maxflow(vector<vector<edge> > &G, int s, int t){\n  const int INF = 100000000;\n  int flow=0;\n  while(true){\n    vector<int> level(G.size(), -1);\n    vector<int> iter(G.size(), 0);\n    vector<bool> used(G.size(), false);\n    bfs(G, level, s);\n    if(level[t] < 0) return flow; //unable to achieve to t\n    while(true){\n      int f = dfs(G, level, used, iter, s, INF, t);\n      if(f==0) break;\n      else flow += f;\n    }\n  }\n}\n\nvoid add_edge(vector<vector<edge> > &G, int from, int to, int cap){\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint main(){\n  int n,h;\n  cin >> n,h;\n  vector<int> a(n),b(n),c(n),d(n);\n  for(int i=0; i<n; i++){\n    cin >> a[i],b[i],c[i],d[i];\n  }\n\n  map<pair<int,int>, int> in_cnt;\n  map<pair<int,int>, int> out_cnt;\n  for(int i=0; i<n; i++){\n    if( c[i] == 0 ){\n      in_cnt[ {a[i], 0} ]++;\n    }else{\n      in_cnt[ {c[i], 1} ]++;\n    }\n    if( d[i] == 0 ){\n      out_cnt[ {b[i], 0} ]++;\n    }else{\n      out_cnt[ {d[i], 1} ]++;\n    }\n  }\n\n  map<tuple<int,int,int>, int> dict;\n  int idx = 0;\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    dict[t] = idx;\n    idx++;\n  }\n\n  int zero_0 = idx++;\n  int zero_1 = idx++;\n  int source = idx++;\n  int sink = idx++;\n\n  int super_source = idx++;\n  int super_sink = idx++;\n\n  vector<vector<edge>> G(idx);\n\n  add_edge(G, zero_0, zero_1, n+10);\n  add_edge(G, super_source, zero_1, 1);\n  add_edge(G, zero_0, super_sink, 1);\n\n  for(auto p : in_cnt){\n    auto t = make_tuple(0, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, v, sink, p.second);\n    if( p.first.second == 0 ){\n      add_edge(G, zero_1, v, p.second);\n    }\n  }\n  for(auto p : out_cnt){\n    auto t = make_tuple(1, p.first.first, p.first.second);\n    int v = dict[t];\n    add_edge(G, source, v, p.second);\n    auto r = make_tuple(0, p.first.first, p.first.second^1);\n    if( dict.count(r) ){\n      add_edge(G, v, dict[r], p.second);\n    }\n\n    if( p.first.second == 0 ){\n      add_edge(G, v, zero_0, p.second);\n    }\n  }\n\n  int f = 0;\n  f += dinic_maxflow(G, super_source, sink);\n  f += dinic_maxflow(G, source, super_sink);\n  if( f != 2 ){\n    abort();\n    println(\"NO\");\n    return 0;\n  }\n  f--;\n\n  add_edge(G, super_source, source, n+100);\n  add_edge(G, sink, super_sink, n+100);\n\n  f += dinic_maxflow(G, super_source, super_sink);\n\n  println( f>=n ? \"YES\" : \"NO\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n, h;\n\nint f(int d, int u){\n\treturn d?(h+d):u;\n}\n\nint g(int d, int u){\n\treturn d?d:(h+u);\n}\n\nint out[810];\nint in[810];\n\nvoid In(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1; i<=n; ++i){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x = f(c, c+a);\n\t\tint y = g(d, d+b);\n\t\tprintf(\"%d => %d\\n\", x, y);\n\t\tout[x]++; in[y]++;\n\t}\n}\n\nbool check(){\n\tint bal = 0;\n\tbool e = 0;\n\tfor(int i=1; i<=2*h-1; ++i){\n\t\tif(abs(out[i]-in[i]) > 1) return 0;\n\t\tif(out[i] > in[i]){\n\t\t\tif(i > h) return 0;\n\t\t\te = 1;\n\t\t\t++bal;\n\t\t}\n\t\tif(out[i] < in[i]){\n\t\t\tif(i <= h) return 0;\n\t\t\t--bal;\n\t\t}\n\t}\n\treturn !bal && e;\n}\n\nint main()\n{\n\tIn();\n\tputs(check()?\"YES\":\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N, H;\nvector<int> vertex;\nint degree[1000];\nint v1[105000], v2[105000];\nbool can[1000];\nint main() {\n    cin >> N >> H;\n    cerr << N << \" \" << H << endl;\n    UnionFind uni(3 * H);\n    for(int i = 0; i < N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        cerr << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        if(c == 0) v1[i] = a;\n        else v1[i] = H + c;\n        if(d == 0) v2[i] = H + b;\n        else v2[i] = d;\n        degree[v1[i]]--;\n        degree[v2[i]]++;\n        uni.merge(v1[i], v2[i]);\n        vertex.push_back(v1[i]);\n        vertex.push_back(v2[i]);\n        //cerr << v1[i] << \" \" << v2[i] << endl;\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            can[v1[i]] = true;\n        }\n    }\n    sort(vertex.begin(), vertex.end());\n    vertex.erase(unique(vertex.begin(), vertex.end()), vertex.end());\n    map<int, vector<int>> mp;\n    for(auto v : vertex) {\n        /*\n        if(!uni.issame(v, vertex[0])) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        */\n        mp[uni.root(v)].push_back(v);\n    }\n    cerr << \"sz: \" << mp.size() << endl;\n    for(auto tmp : mp) {\n        /*\n        for(auto v : tmp.second) {\n            cerr << v << \" \";\n        }\n        cerr << endl;\n        */\n        vector<int> s, t;\n        for(auto v : tmp.second) {\n            if(degree[v] < 0) s.push_back(v);\n            if(degree[v] > 0) t.push_back(v);\n        }\n        if(s.empty()) {\n            assert(t.empty());\n            cout << \"NO\" << endl;\n            return 0;\n            /*\n            bool ok = false;\n            for(auto v : tmp.second) {\n                ok |= can[v];\n            }\n            if(!ok) {\n                cout << \"NO\" << endl;\n                assert(0);\n                return 0;\n            }\n            */\n        } else {\n            //if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n            for(auto v : s) {\n                if(v >= H + 1) {\n                    cout << \"NO\" << endl;\n                    //assert(0);\n                    return 0;\n                }\n            }\n            for(auto v : t) {\n                if(v <= H) {\n                    cout << \"NO\" << endl;\n                    //assert(0);\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n    /*\n    int s = -1, t = -1;\n    for(auto v : vertex) {\n        if(abs(degree[v]) >= 2) {\n            cout << \"NO\" << endl;\n            cerr << \"DEGREE\" << endl;\n            return 0;\n        }\n        if(degree[v] == 1) {\n            if(t != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"T\" << endl;\n                return 0;\n            } else {\n                t = v;\n            }\n        }\n        if(degree[v] == -1) {\n            if(s != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"S\" << endl;\n                cerr << s << \" \" << v << endl;\n                return 0;\n            } else {\n                s = v;\n            }\n        }\n    }\n    if(s != -1) {\n        assert(t != -1);\n        if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n    }\n    for(int i = 0; i < N; i++) {\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    }\n    cout << \"NO\" << endl;\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nconst int maxnode=2000000+16;\nconst int maxedge=2000000+16;\nconst int oo=100000000;\n\nint node,src,dest,nedge;\nint head[maxnode],point[maxedge],nextp[maxedge],flow[maxedge],capa[maxedge];\nint distp[maxnode],Q[maxnode],work[maxnode];\n\nvoid init(int _node,int _src,int _dest)\n{\n\tnode=_node;\n\tsrc=_src;\n\tdest=_dest;\n\tfor (int i=0;i<node;i++) head[i]=-1;\n\tnedge=0;\n}\nvoid addedge(int u,int v,int c1,int c2)\n{\n\tif (c1==0 && c2==0) return;\n\t//printf(\"%d %d %d %d\\n\",u,v,c1,c2);\n\tpoint[nedge]=v,capa[nedge]=c1,flow[nedge]=0,nextp[nedge]=head[u],head[u]=(nedge++);\n\tpoint[nedge]=u,capa[nedge]=c2,flow[nedge]=0,nextp[nedge]=head[v],head[v]=(nedge++);\n}\nbool dinic_bfs()\n{\n\tfor (int i=0;i<node;i++) distp[i]=-1;\n\tdistp[src]=0;\n\tint sizeQ=0;\n\tQ[sizeQ++]=src;\n\tfor (int cl=0;cl<sizeQ;cl++)\n\t\tfor (int k=Q[cl],i=head[k];i>=0;i=nextp[i])\n\t\t\tif (flow[i]<capa[i] && distp[point[i]]<0)\n\t\t\t{\n\t\t\t\tdistp[point[i]]=distp[k]+1;\n\t\t\t\tQ[sizeQ++]=point[i];\n\t\t\t}\n\treturn distp[dest]>=0;\n}\nint dinic_dfs(int x,int exp)\n{\n\tif (x==dest) return exp;\n\tint res=0;\n\tfor (int &i=work[x];i>=0;i=nextp[i])\n\t{\n\t\tint v=point[i],tmp;\n\t\tif (flow[i]<capa[i] && distp[v]==distp[x]+1 && (tmp=dinic_dfs(v,min(exp,capa[i]-flow[i])))>0)\n\t\t{\n\t\t\tflow[i]+=tmp;\n\t\t\tflow[i^1]-=tmp;\n\t\t\tres+=tmp;\n\t\t\texp-=tmp;\n\t\t\tif (exp==0) break;\n\t\t}\n\t}\n\treturn res;\n}\nint dinic_flow()\n{\n\tint result=0;\n\twhile (dinic_bfs())\n\t{\n\t\tfor (int i=0;i<node;i++) work[i]=head[i];\n\t\tresult+=dinic_dfs(src,oo);\n\t}\n\treturn result;\n}\n\nvoid add2(int s,int t,int c0,int c1)\n{\n\t//printf(\"%d %d %d %d\\n\",s,t,c0,c1);\n\tif (c0>0)\n\t{\n\t\taddedge(src,t,c0,0);\n\t\taddedge(s,dest,c0,0);\n\t}\n\tif (c1>c0)\n\t\taddedge(s,t,c1-c0,0);\n}\n\nvector<int> g[maxnode];\nbool v[maxnode];\n\nvoid dfs(int p)\n{\n\tif (v[p]) return;\n\tv[p]=true;\n\tfor (int x:g[p]) dfs(x);\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint n,h;\n\twhile (cin>>n>>h && n>0)\n\t{\n\t\th+=2;\n\t\tint es=h+h;\n\t\tint et=h+h+1;\n\t\tinit(h+h+4,h+h+2,h+h+3);\n\t\tREP(i,h)\n\t\t{\n\t\t\tadd2(es,i+h,0,10000000);\n\t\t\tadd2(i,et,0,10000000);\n\t\t}\n\t\tvector<ipair> edges;\n\t\tREP(i,n)\n\t\t{\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tint s=((c==0)?(a+h):c);\n\t\t\tint t=((d==0)?b:(d+h));\n\t\t\tadd2(s,t,1,1);\n\t\t\tedges.emplace_back(s,t);\n\t\t}\n\t\tbool ok=true;\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.first].push_back(e.second);\n\t\tFOR(i,h,h+h) dfs(i);\n\t\tfor (auto e:edges) if (!v[e.first]) ok=false;\n\n\t\tREP(i,h+h) g[i].clear();\n\t\tREP(i,h+h) v[i]=false;\n\t\tfor (auto e:edges) g[e.second].push_back(e.first);\n\t\tREP(i,h) dfs(i);\n\t\tfor (auto e:edges) if (!v[e.second]) ok=false;\n\n\t\tif (ok)\n\t\t{\n\t\t\taddedge(et,es,10000000,0);\n\t\t\tdinic_flow();\n\t\t\tfor (int p=head[src];p>=0;p=nextp[p]) \n\t\t\t\tif (flow[p]!=capa[p]) \n\t\t\t\t\tok=false;\n\t\t}\n\t\tif (ok)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int maxn = 1e5+10;\nint down_l[205], down_r[205], up_l[205], up_r[205];\nint l_l[maxn],l_r[maxn],h_l[maxn],h_r[maxn];\nint main()\n{\n\tint n,h;\n\tint a,b,c,d;\n\tint count_up;\n\twhile(~scanf(\"%d%d\",&n,&h)){\n\t\tcount_up = 0;\n\t\tmemset(down_l,0,sizeof(int)*205);\n\t\tmemset(down_r,0,sizeof(int)*205);\n\t\tmemset(up_l,0,sizeof(int)*205);\n\t\tmemset(up_r,0,sizeof(int)*205);\n\t\tfor(int i = 0; i<n; i++){\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\tl_l[i] = a; l_r[i] = b;\n\t\t\th_l[i] = c; h_r[i] = d;\n\t\t\tif(c == 0) down_l[a]++;\n\t\t\telse {\n\t\t\t\tup_l[a]++;\n\t\t\t\tcount_up ++;\n\t\t\t}\n\t\t\tif(d == 0) down_r[b]++;\n\t\t\telse {\n\t\t\t\tup_r[b]++;\n\t\t\t\tcount_up++;\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int i = 0; i<n; i++){\n\t\t\tint a = l_l[i], b = l_r[i];\n\t\t\tint c = h_l[i], d = h_r[i];\n\t\t\tif(c != 0){\n\t\t\t\tint dis = 0;\n\t\t\t\tif(c == b && d == 0) dis = 1;\n\t\t\t\tif(down_r[c] - dis > 0) down_r[c]--;\n\t\t\t\telse{\n\t\t\t\t\tflag = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( d != 0){\n\t\t\t\tint dis = 0;\n\t\t\t\tif(a == d && c == 0) dis = 1;\n\t\t\t\tif(down_l[d] - dis > 0) down_l[d]--;\n\t\t\t\telse {\n\t\t\t\t\tflag = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXH=200;\ntypedef struct Z { int A,B,C,D,L,R; } Z;\n\nint n,h;\nZ z[2*MAXN];\nbool used[2*MAXN];\n\n\nvector<int> havel[2*MAXH];\nvector<int> haver[2*MAXH];\nint cnt[2*MAXH];\n\nbool solve() {\n\tREP(i,n) { if(z[i].C==0) z[i].L=z[i].A-1; else z[i].L=h+z[i].C-1; if(z[i].D==0) z[i].R=h+z[i].B-1; else z[i].R=z[i].D-1; }\n\t//REP(i,n) { if(i!=0) printf(\" | \"); printf(\"%02d-%02d\",z[i].L,z[i].R); } puts(\"\");\n\tREP(i,2*h) havel[i].clear(),haver[i].clear(); REP(i,n) havel[z[i].L].PB(i),haver[z[i].R].PB(i),used[i]=false;\n\n\tbool ret=true; int nz=n;\n\tREP(i,n) if(!used[i]) {\n\t\tused[i]=true;\n\t\tint l=z[i].L,r=z[i].R; REP(j,2*h) cnt[j]=0;\n\t\t//printf(\"%02d-%02d\\n\",l,r);\n\t\twhile(true) {\n\t\t\tbool change=false;\n\t\t\twhile(true) {\n\t\t\t\twhile(SZ(havel[r])!=0&&used[havel[r].back()]) havel[r].pop_back();\n\t\t\t\tif(SZ(havel[r])!=0) { int id=havel[r].back(); used[id]=true; ++cnt[r]; r=z[id].R; change=true; /*printf(\"append right %02d-%02d\\n\",z[id].L,z[id].R);*/ } else break;\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\twhile(SZ(haver[l])!=0&&used[haver[l].back()]) haver[l].pop_back();\n\t\t\t\tif(SZ(haver[l])!=0) { int id=haver[l].back(); used[id]=true; ++cnt[l]; l=z[id].L; change=true; /*printf(\"append left  %02d-%02d\\n\",z[id].L,z[id].R);*/ } else break;\n\t\t\t}\n\t\t\tif(l==r) REP(j,2*h) if(cnt[j]>0) {\n\t\t\t\twhile(SZ(havel[j])!=0&&used[havel[j].back()]) havel[j].pop_back();\n\t\t\t\twhile(SZ(haver[j])!=0&&used[haver[j].back()]) haver[j].pop_back();\n\t\t\t\tif(SZ(havel[j])!=0) { int id=havel[j].back(); used[id]=true; ++cnt[l]; l=j,r=z[id].R; change=true; /*printf(\"split on %02d and append right %02d-%02d\\n\",j,z[id].L,z[id].R);*/ break; }\n\t\t\t\tif(SZ(haver[j])!=0) { int id=haver[j].back(); used[id]=true; ++cnt[l]; l=z[id].L,r=j; change=true; /*printf(\"split on %02d and append left  %02d-%02d\\n\",j,z[id].L,z[id].R);*/ break; }\n\t\t\t}\n\t\t\tif(!change) break;\n\t\t}\n\t\t//printf(\"-> %02d-%02d\\n\",l,r);\n\t\tif(l>=h||r<h) ret=false; else z[nz].L=l,z[nz].R=r,used[nz]=false,havel[l].PB(nz),haver[r].PB(nz),++nz;\n\t}\n\treturn ret;\n}\n\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&h);\n\tREP(i,n) scanf(\"%d%d%d%d\",&z[i].A,&z[i].B,&z[i].C,&z[i].D);\n\t//REP(i,n) { if(i!=0) printf(\" | \"); if(z[i].C==0) printf(\"0%d\",z[i].A); else printf(\"%d*\",z[i].C); printf(\"-\"); if(z[i].D==0) printf(\"0%d\",z[i].B); else printf(\"%d*\",z[i].D); } puts(\"\");\n\tprintf(\"%s\\n\",solve()?\"YES\":\"NO\");\t\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define IN freopen(\"hard1.txt\",\"r\",stdin)\n#define OUT freopen(\"hard1.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG printf(\"Hi\\n\")\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define ln 17\n#define off 1000005\n#define FastIO  ios_base::sync_with_stdio(false); cin.tie(NULL)\n\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<i64, i64> pii ;\n\n#define maxn 1000005\n#define mod 1000000007LL\n#define lim 1000000000\n#define INF 4500000000000000000LL\n\nvector <int> out[805] , in[805] ;\nint par[805] , edge[805] ;\n\nvoid NO(int fl=0)\n{\n    printf(\"%d\\n\",fl) ;\n    printf(\"NO\\n\") ;\n    exit(0) ;\n}\n\nvector <int> cur ;\nint vis[maxn] ;\n\nvoid dfs(int u )\n{\n    vis[u] = 1 ;\n    cur.pb(u) ;\n    for(int v:out[u])\n    {\n        if( !vis[v] ) dfs(v) ;\n    }\n    for(int v : in[u])\n    {\n        if( !vis[v] ) dfs(v) ;\n    }\n}\nint main()\n{\n    int n , h ;\n    scanf(\"%d %d\",&n,&h) ;\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        int a , b , c , d ;\n        scanf(\"%d %d %d %d\",&a,&b,&c,&d) ;\n\n//        A[i] = a; B[i] = b ; C[i] = c ; D[i] = d ;\n\n        int u , v ;\n\n        if( c==0 ) u = a ;\n        else u = h+c ;\n\n        if(d==0) v = h+b ;\n        else v = d ;\n\n //       printf(\"%d %d\\n\",u,v) ;\n\n        out[u].pb(v) ; in[v].pb(u) ;\n    }\n//    backtrack(n) ;\n    int fl = 1 ;\n    for(int i=1; i<=h ; i++)\n    {\n        if( out[i].size() < in[i].size() ) fl = 0 ;\n        if( out[i+h].size() > in[i+h].size() ) fl = 0 ;\n    }\n\n    for(int i=1; i<=2*h ; i++)\n    {\n        if( (in[i].size() > 0 || out[i].size() > 0) && !vis[i] )\n        {\n            int ca =0 ,cb = 0 ;\n            cur.clear() ;\n            dfs(i) ;\n            for(int u:cur)\n            {\n                if( u <= h && out[u].size() > in[u].size() ) ca++ ;\n                if( u > h && out[u].size() < in[u].size() ) cb++ ;\n            }\n            if(ca==0 || cb==0) fl = 0 ;\n        }\n    }\n\n    if(fl) printf(\"YES\\n\") ;\n    else printf(\"NO\\n\") ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 200010;\n\nint N, H;\nvector<int> adj[MN];\nint vis[MN], chk[MN], ideg[MN], odeg[MN];\nint x, y;\n\nvoid dfs(int u) {\n    vis[u] = 1;\n\n    //cout << u <<  ' ' << ideg[u] << ' ' << odeg[u] << endl;\n\n    if(N <= u) {\n        if((u - N) % 2) {\n            if(ideg[u] > odeg[u]) {\n                printf(\"NO\");\n                exit(0);\n            }\n            x += odeg[u] - ideg[u];\n        }\n        else {\n            if(odeg[u] > ideg[u]) {\n                printf(\"NO\");\n                exit(0);\n            }\n            y += ideg[u] - odeg[u];\n        }\n    }\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(!vis[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &H);\n\n    for(int i = 0; i < N; i++) {\n        int a, b, c, d; scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\n        chk[i] = 1;\n        if(c) {\n            adj[N + 2 * c].push_back(i);\n            adj[i].push_back(N + 2 * c);\n            ideg[i]++;\n            odeg[N + 2 * c]++;\n            chk[N + 2 * c] = 1;\n        }\n        else {\n            adj[N + 2 * a + 1].push_back(i);\n            adj[i].push_back(N + 2 * a + 1);\n            ideg[i]++;\n            odeg[N + 2 * a + 1]++;\n            chk[N + 2 * a + 1] = 1;\n        }\n\n        if(d) {\n            adj[i].push_back(N + 2 * d + 1);\n            adj[N + 2 * d + 1].push_back(i);\n            ideg[N + 2 * d + 1]++;\n            odeg[i]++;\n            chk[N + 2 * d + 1] = 1;\n        }\n        else {\n            adj[i].push_back(N + 2 * b);\n            adj[N + 2 * b].push_back(i);\n            ideg[N + 2 * b]++;\n            odeg[i]++;\n            chk[N + 2 * b] = 1;\n        }\n    }\n\n    for(int i = 0; i < N + 2 * H; i++) if(!vis[i] && chk[i]) {\n        x = 0;\n        y = 0;\n        dfs(i);\n\n        //cout << i << ' ' << x << ' ' << y << endl;\n\n        if(!x || x != y) {\n            printf(\"NO\");\n            return 0;\n        }\n    }\n    printf(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N, H;\nvector<int> vertex;\nint degree[1000];\nint v1[105000], v2[105000];\nbool can[1000];\nint main() {\n    cin >> N >> H;\n    cerr << N << \" \" << H << endl;\n    UnionFind uni(3 * H);\n    for(int i = 0; i < N; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        cerr << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        if(c == 0) v1[i] = a;\n        else v1[i] = H + c;\n        if(d == 0) v2[i] = H + b;\n        else v2[i] = d;\n        degree[v1[i]]--;\n        degree[v2[i]]++;\n        uni.merge(v1[i], v2[i]);\n        vertex.push_back(v1[i]);\n        vertex.push_back(v2[i]);\n        //cerr << v1[i] << \" \" << v2[i] << endl;\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            can[v1[i]] = true;\n        }\n    }\n    sort(vertex.begin(), vertex.end());\n    vertex.erase(unique(vertex.begin(), vertex.end()), vertex.end());\n    map<int, vector<int>> mp;\n    for(auto v : vertex) {\n        /*\n        if(!uni.issame(v, vertex[0])) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        */\n        mp[uni.root(v)].push_back(v);\n    }\n    cerr << \"sz: \" << mp.size() << endl;\n    for(auto tmp : mp) {\n        /*\n        for(auto v : tmp.second) {\n            cerr << v << \" \";\n        }\n        cerr << endl;\n        */\n        vector<int> s, t;\n        for(auto v : tmp.second) {\n            if(degree[v] < 0) s.push_back(v);\n            if(degree[v] > 0) t.push_back(v);\n        }\n        if(s.empty()) {\n            assert(t.empty());\n            bool ok = false;\n            for(auto v : tmp.second) {\n                ok |= can[v];\n            }\n            if(!ok) {\n                cout << \"NO\" << endl;\n                assert(0);\n                return 0;\n            }\n        } else {\n            //if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n            for(auto v : s) {\n                if(v >= H + 1) {\n                    cout << \"NO\" << endl;\n                    return 0;\n                }\n            }\n            for(auto v : t) {\n                if(v <= H) {\n                    cout << \"NO\" << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n    /*\n    int s = -1, t = -1;\n    for(auto v : vertex) {\n        if(abs(degree[v]) >= 2) {\n            cout << \"NO\" << endl;\n            cerr << \"DEGREE\" << endl;\n            return 0;\n        }\n        if(degree[v] == 1) {\n            if(t != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"T\" << endl;\n                return 0;\n            } else {\n                t = v;\n            }\n        }\n        if(degree[v] == -1) {\n            if(s != -1) {\n                cout << \"NO\" << endl;\n                cerr << \"S\" << endl;\n                cerr << s << \" \" << v << endl;\n                return 0;\n            } else {\n                s = v;\n            }\n        }\n    }\n    if(s != -1) {\n        assert(t != -1);\n        if(s <= H and t >= H + 1) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return 0;\n    }\n    for(int i = 0; i < N; i++) {\n        if(v1[i] >= H + 1 and v2[i] <= H) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    }\n    cout << \"NO\" << endl;\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"grader.h\"\n#include <bits/stdc++.h>  \n\nusing namespace std;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define re return\n#define fi first\n#define mp make_pair\n#define se second\n#define sz(a) (int)a.size()\n#define prev previ\n#define tm tmmm\n#define div divv\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\n\nconst ll mod = ll(1e9) + 9LL, pr = 239, mod2 = ll(1e9) + 7;\n\nll n, h, a[2][201], mt[201], go[201];\nvector<int> use;\nvector<vector<pair<int, int> > > pq;\n\nbool is_edge(int i, int j) {\n\tif (i == j) re false;\n\tif (a[0][i] > 0 && a[1][j] > 0) re true;\n\tif (a[0][i] == -a[1][j]) re true;\n\tre false;\n}\nbool dfs(int nu) {\n\tif (use[nu]) re false;\n\tuse[nu] = 1;\n\tforn (i, n) {\n\t\tif (is_edge(nu, i) && (mt[i] == -1 || dfs(mt[i]))) {\n\t\t\tmt[i] = nu;\n\t\t\tgo[nu] = i;\n\t\t\tre true;\t\t\n\t\t}\n\t}\n\tre false;\n}\n\nint u[1000];\n\nvoid dfs1(int nu) {\n\tif (u[nu]) re;\n\tu[nu] = 1;\n\tpq[sz(pq) - 1].push_back(mp(a[0][nu], a[1][go[nu]]));\n\tdfs1(mt[nu]);\n}\n\nint main() {\n\tiostream::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> h;\n\tint k1 = 0;\n\tbool ok1 = false, ok2 = false;\n\tforn (i, n) {\n\t\tint a1, b, c, d;\n\t\tcin >> b >> d >> a1 >> c;\n\n\t\tif (a1)\n\t\t\tb = -a1;\n\t\tif (c)\n\t\t\td = -c;\n\t\tif (b > 0) ok1 = true;\n\t\tif (d > 0) ok2 = true;\n\t\ta[0][i] = b;\n\t\ta[1][i] = d;\n\t\tmt[i] = -1;\n\t}\n\t/*if (!ok1 || !ok2) {\n\t\tcout << \"NO\\n\";\n\t\tre 0;\n\t}*/\n\tforn (i, n) {\n\t\tuse.assign(n, 0);\n\t\tif (!dfs(i)) {\n\t\t\tcout << \"NO\\n\";\n\t\t\tre 0;\n\t\t}\n\t}\n\tforn (i, n) {\n\t\tif (u[i]) continue;\n\t\tpq.push_back(vector<pair<int, int> > (0));\n\t\tdfs1(i);\n\t\tsort(pq[sz(pq) - 1].begin(), pq[sz(pq) - 1].end());\n\t}\n\tint k = sz(pq);\n\tforn (i, k - 1) {\n\t\tint a2 = 0, a1 = 0;\n\t\tfor (auto v : pq[sz(pq) - 1]){\n\t\t\tif (v.fi > 0 && v.se > 0) a2 = 1;\n\t\t}\n\t\tbool ok1= false;\n\t\tforn (j, sz(pq) - 1) {\n\t\t\tfor (auto v : pq[j]) {\n\t\t\t\tif (v.fi > 0 && v.se > 0) a1 = 1;\n\t\t\t\tif (binary_search(pq[sz(pq) - 1].begin(), pq[sz(pq) - 1].end(), v))\n\t\t\t\t\tok1 = true;\n\t\t\t}\n\t\t\tif (a2 && a1) ok1 = true;\n\t\t\tif (ok1) {\n\t\t\t\tfor (auto v : pq[sz(pq) - 1])\n\t\t\t\t\tpq[j].push_back(v);\n\t\t\t\tpq.pop_back();\n\t\t\t\tsort(pq[j].begin(), pq[j].end());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok1) {\n\t\t\tcout << \"NO\\n\";\n\t\t\tre 0;\n\t\t}\n\t}\n\tbool ok = false;\n\tfor (auto v : pq[0])\n\t\tif (v.fi > 0 && v.se > 0) ok = true;\n\tif (!ok) {\n\t\tcout << \"NO\\n\";\n\t\tre 0;\n\t}\n\tcout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=405,maxm=100500;\ninline int read(int x=0,char c=getchar()){for(;c>'9'||c<'0';c=getchar());for(;c>='0'&&c<='9';c=getchar()) x=x*10+c-48;return x;}\nint fa[maxn];\nbool v[maxn];\nint in[maxn],out[maxn],A[maxm],B[maxm],C[maxm],D[maxm],pa[maxm];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tint n,h,tot=0;cin>>n>>h;bool flag=1;\n\tfor(int i=1;i<=n;++i) A[i]=read(),B[i]=read(),C[i]=read(),D[i]=read();//h<<=1;\n\tfor(int i=1;i<=n;++i) {\n\t\tint a,b;\n\t\tif(!C[i]) a=h+A[i];else a=h-C[i];\n\t\tif(!D[i]) b=h-B[i];else b=h+D[i];\n\t\t++out[a],++in[b];\n\t}\n\tfor(int i=0;i<h;++i) if(in[i]<out[i]) flag=0;//cout<<flag<<endl;\n\tfor(int i=h+1;i<=h<<1;++i) if(in[i]>out[i]) flag=0;\n\tfor(int i=0;i<=h<<1;++i) fa[i]=i,v[i]=(in[i]!=out[i]);\n\tfor(int i=1;i<=n;++i){\n\t\tint a,b;\n\t\tif(!C[i]) a=h+A[i];else a=h-C[i];\n\t\tif(!D[i]) b=h-B[i];else b=h+D[i];\n\t\tif(find(a)==find(b)) pa[++tot]=a;\n\t\telse v[find(b)]|=v[find(a)],fa[find(a)]=find(b);\n\t}\n\tfor(int i=1;i<=tot;++i) if(!v[find(pa[i])]) flag=0;\n\tputs(flag?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define neko 100010\n#define heko 410\n#define qwq return printf(\"YES\"),0; \n#define orz return printf(\"NO\"),0; \n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))\nstatic int n,H;\ntypedef int arr[heko];\narr fa,book,dgi,dgo,out;\nnamespace IO\n{\n\tconst unsigned int bufsize=1<<16,outsize=1<<24;\n\tstatic char ch[bufsize],*S=ch,*T=ch;\n\tinline char getc()\n\t{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\n\tstatic char Out[outsize],*nowp=Out;\n\tinline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\n\t\tvoid read(T &x)\n\t\t{\n\t\t\tchar c=getc();x=0;\n\t\t\tfor(;!isdigit(c);c=getc());\n\t\t\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n\t\t}\n\ttemplate<typename T>\n\t\tvoid write(T x,char c='\\n')\n\t\t{\n\t\t\tif(!x)*nowp++='0';\n\t\t\tstatic unsigned int stk[50],tp=0;\n\t\t\tfor(;x;x/=10)stk[++tp]=x%10;\n\t\t\tfor(;tp;*nowp++=stk[tp--]^'0');*nowp++=c;\n\t\t}\n}\nint find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}\nint main()\n{\n\tusing namespace IO;\n\tint x,y,z,o,X,Y;\n\tread(n),read(H);\n\tf(i,0,H<<1)fa[i]=i;\n\tf(i,1,n)\n\t{\n\t\tread(x),read(y),read(z),read(o);\n\t\tif(z==0)X=H+x;\n\t\telse X=H-z;\n\t\tif(o==0)Y=H-y;\n\t\telse Y=H+o;\n\t\tbook[X]=book[Y]=1;\n\t\t++dgi[Y],++dgo[X];\n\t\tfa[find(Y)]=find(X);\n\n\t}\n\tf(i,0,H)if(dgi[i]<dgo[i])orz;\n\tf(i,H+1,H<<1)if(dgi[i]>dgo[i])orz;\n\tf(i,0,H<<1)if(dgi[i]^dgo[i])out[fa[i]]=1;\n\tf(i,0,H<<1)if(book[i]&&!out[fa[i]])orz;\n\tqwq;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tputs(\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n#include<queue>\n#include<bitset>\n#include<map>\n#include<set>\n\n#define maxn 200005\n#define MOD 1000000007\n\nusing namespace std;\n\ninline int getint()\n{\n\tint num=0,flag=1;char c;\n\twhile((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;\n\twhile(c>='0'&&c<='9')num=num*10+c-48,c=getchar();\n\treturn num*flag;\n}\n\nint n,H;\nint f[maxn];\nint In[maxn],Ot[maxn];\nint vis[maxn];\n\ninline int find(int x)\n{return f[x]==x?x:f[x]=find(f[x]);}\nint main()\n{\n\tn=getint(),H=getint();\n\tfor(int i=1;i<=2*H;i++)f[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint A=getint(),B=getint(),C=getint(),D=getint();\n\t\tint x=C?C+H:A,y=D?D:B+H;\n\t\tOt[x]++,In[y]++;\n\t\tx=find(x),y=find(y);\n\t\tif(x!=y)f[y]=x;\n\t}\n\tfor(int i=1;i<=H;i++)if(In[i]>Ot[i]){printf(\"NO\\n\");return 0;}\n\tfor(int i=H+1;i<=2*H;i++)if(In[i]<Ot[i]){printf(\"NO\\n\");return 0;}\n\tfor(int i=1;i<=2*H;i++)if((!In[i]&&!Ot[i])||In[i]!=Ot[i])vis[find(i)]=1;\n\tfor(int i=1;i<=2*H;i++)if(find(i)==i&&!vis[i]){printf(\"NO\\n\");return 0;}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n   #define PP pair<int,pair<int,int>>\nconst int MAX = 510000;\nconst int MOD =  998244353;\nconst int INV2 = (MOD+1)/2;\n\n\n     signed main(){\ncout<<\"NO\"<<endl;\n        return 0;\n        int n,h;\n        map<int,int> mp[2];\n        cin>>n>>h;\n        int a,b,c,d;\n        for(int i=0;i<n;i++){\n          cin>>a>>b>>c>>d;\n          if(c==0)mp[0][a]++;\n          else mp[1][c]++;\n          if(d==0)mp[1][b]--;\n          else mp[0][d]--;\n        }\n        bool x=false;\n        for(auto i=mp[0].begin();i!=mp[0].end();i++){\n         //// cerr<<(i->second)<<' '<<(i->first)<<endl;\n          if((i->second)>0)x=true;\n          if((i->second)>=0)continue;\n         \n          \n          cout<<\"NO\"<<endl;\n          return 0;\n        }\n        for(auto i=mp[1].begin();i!=mp[1].end();i++){\n         // cerr<<(i->second)<<endl;\n          if((i->second)<0)x=true;\n\n          if((i->second)<=0)continue;\n         \n           \n          cout<<\"NO\"<<endl;\n          return 0;\n        }\n\n       if(x) cout<<\"YES\"<<endl;\n       else cout<<\"NO\"<<endl;\n        return 0;\n\n \n\n\n\n\n}\n\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 410;\nconst int H = 201;\n\nbool use[N];\nve<pii> a[N];\nint st[N];\nbool is[100100];\n\nvoid dfs(int v) {\n\tuse[v] = 1;\n\tforn(i, sz(a[v])) {\n\t\tint to = a[v][i].fs;\n\t\tis[a[v][i].sc] = 1;\n\t\tif (!use[to])\n\t\t\tdfs(to);\n\t}\n}\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n#endif\n\tint n, h;\n\tcin >> n >> h;\n\tforn(i, n) {\n\t\tint a1, b1, c1, d1;\n\t\tscanf(\"%d%d%d%d\", &a1, &b1, &c1, &d1);\n\t\t//debug(mt(a1, b1, c1, d1));\n\t\tint u, v;\n\t\tif (c1 == 0) {\n\t\t\tu = a1;\n\t\t} else {\n\t\t\tu = c1 + H;\n\t\t}\n\t\tif (d1 == 0) {\n\t\t\tv = b1 + H;\n\t\t} else {\n\t\t\tv = d1;\n\t\t}\n\t\ta[u].pb(mp(v, i));\n\t\tst[u]++;\n\t\tst[v]--;\n\t}\n\tforn(i, H) {\n\t\tif (st[i] > 0 && !use[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tint cnt = 0;\n\tforn(i, n)\n\t\tcnt += is[i];\n\tif (cnt == n) {\n\t\tputs(\"YES\");\n\t\treturn 0;\n \t}\n \tputs(\"NO\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nint par[500];\nint find(int a){\n\tif(par[a] != a){\n\t\tpar[a] = find(par[a]);\n\t}\n\treturn par[a];\n}\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\tvector<int> edges[500];\n\tint deg[500];\n\tfor(int i = 0; i < 500; i++){\n\t\tdeg[i] = 0;\n\t\tpar[i] = i;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint v1 = c;\n\t\tint v2 = -d;\n\t\tif(c == 0) v1 = -a;\n\t\tif(d == 0) v2 = b;\n\t\tv1 += 250;\n\t\tv2 += 250;\n\t\tedges[v1].push_back(v2);\n\t\tdeg[v1]++;\n\t\tdeg[v2]--;\n\t\tpar[find(v1)] = find(v2);\n\t}\n\tint ok = 1;\n\tmap<int,int> c;\n\tfor(int i = 0; i < 500; i++){\n\t\tif(deg[i] < 0 && i < 250) ok = 0;\n\t\tif(deg[i] > 0 && i > 250) ok = 0;\n\t\tif(deg[i] > 0){\n\t\t\tc[find(i)] = 1;\n\t\t}\n\t}\n\tfor(int i = 0; i < 500; i++){\n\t\tif(edges[i].size() > 0 && c[find(i)] != 1) ok = 0;\n\t}\n\tcout << (ok ? \"YES\" : \"NO\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Jigsaw\n// * frank_c1\n// * 2017 / 11/ 07\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = (int)(1e5) + 5;\nint ai[maxn], bi[maxn], ci[maxn], di[maxn];\nint in[maxn], ou[maxn];\n\nint main() {\n\tint n, H;\n\tscanf(\"%d%d\", &n, &H);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d%d%d%d\", &ai[i], &bi[i], &ci[i], &di[i]);\n\t\tint u = 0, v = 0;\n\t\tif (!ci[i]) u = ai[i]; else u = ci[i] + H;\n\t\tif (!di[i]) v = bi[i] + H; else v = di[i];\n\t\t++ou[u]; ++in[v]; \n\t} int cnt = 0, e = 0;\n\tfor (int i = 1; i <= H; ++i) if (in[i] > ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] < ou[i]) cnt += ou[i] - in[i], e = 1;\n\tfor (int i = H + 1; i <= H + H; ++i) if (in[i] < ou[i]) return printf(\"NO\\n\"), 0; else if (in[i] > ou[i]) cnt -= in[i] - ou[i];\n\treturn ((cnt || !e) ? printf(\"NO\\n\") : printf(\"YES\\n\")), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAXN 500\n#define INF 0x3f3f3f3f\ntypedef long long LL;\n\nint n, h, m, s, cnt[MAXN];\nbool vis[MAXN], mark[100010];\nvector<pair<int, int> > adj[MAXN];\n\nvoid Init()\n{\n    int i, a, b, c, d, u, v;\n    scanf(\"%d %d\", &n, &h);\n    for(i = 1; i <= n; ++i){\n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        if(c) u = c + h + 10;\n        else u = a;\n        if(d) v = d;\n        else v = b + h + 10;\n        adj[u].push_back({v, i});\n        adj[v].push_back({u, i});\n        ++cnt[u];\n        --cnt[v];\n        s = u;\n    }\n}\n\nvoid DFS(int u)\n{\n    vis[u] = true;\n    for(auto &v: adj[u]){\n        if(!mark[v.second]){\n            mark[v.second] = true;\n            ++m;\n        }\n        if(vis[v.first]) continue;\n        DFS(v.first);\n    }\n}\n\nbool Check()\n{\n    int i, j = 0, k = 0, x, y;\n//    DFS(s);\n//    if(m != n) return false;\n    for(i = 0; i < 500; ++i){\n        if(cnt[i] > 1) return false;\n        if(cnt[i] < -1) return false;\n        if(cnt[i] == 1) ++j, x = i;\n        if(cnt[i] == -1) ++k, y = j;\n    }\n    if(j == 0 && k == 0) return false;\n    else if(j == k){\n        return true;\n    }\n    return false;\n}\n\nint main()\n{\n    Init();\n    printf(\"%s\\n\", Check() ? \"YES\" : \"NO\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main()\n{\n\tint a, b;\n\tint c[50000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]&&c[j][4]==0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAXN 100010\nusing namespace std;\nint N, H;\nstruct clip\n{\n\tint a;\n\tint b;\n\tint c;\n\tint d;\n\tbool flagA = false;\n\tbool flagB = false;\n\tbool flagC = false;\n\tbool flagD = false;\n}clip[MAXN];\nbool check() {\n\tbool flag = true;\n\tfor (int i = 0; i < N; i++) {\n\t\tif ((clip[i].flagC == false && clip[i].c!=0) || (clip[i].flagD == false && clip[i].d != 0)) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flag;\n}\nvoid process() {\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N ; j++) {\n\t\t\tif (j==i)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (clip[i].a == clip[j].d && clip[i].flagA==false) {\n\t\t\t\tclip[j].flagD = true;\n\t\t\t\tclip[i].flagA == true;\n\t\t\t}\n\t\t\telse if (clip[i].b == clip[j].c && clip[i].flagB == false) {\n\t\t\t\tclip[j].flagC = true;\n\t\t\t\tclip[i].flagB == true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false);\n\tcin >> N>>H;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> clip[i].a >> clip[i].b >> clip[i].c >> clip[i].d;\n\t}\n\tprocess();\n\tif (check())\n\t\tcout << \"YES\" << endl;\n\telse\n\t{\n\t\tcout << \"NO\" << endl;\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nvector <int> LI[444], LO[444], RI[444], RO[444];\nvector <pii> V;\nbool chk[444];\nmultiset <int> SL, SR;\nint n, h;\n\nvoid dfs(int p, vector <int> *V)\n{\n\tchk[p] = 1;\n\tfor(int t: V[p]){\n\t\tif(!chk[t]) dfs(t, V);\n\t}\n}\n\nvoid die()\n{\n\tprintf(\"NO\\n\");\n\texit(0);\n}\n\nint main()\n{\n\tint i, j, a, b, c, d;\n\t\n\tscanf(\"%d%d\", &n, &h);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\n\t\tif(c == 0 && d == 0){\n\t\t\tLO[0].push_back(a);\n\t\t\tLI[a].push_back(0);\n\t\t\tRO[0].push_back(b);\n\t\t\tRI[b].push_back(0);\n\t\t}\n\t\telse if(c == 0){\n\t\t\tLO[d].push_back(a);\n\t\t\tLI[a].push_back(d);\n\t\t}\n\t\telse if(d == 0){\n\t\t\tRO[c].push_back(b);\n\t\t\tRI[b].push_back(c);\n\t\t}\n\t\telse V.push_back(pii(c, d));\n\t}\n\t\n\tdfs(0, LO);\n\t\n\tfor(i=1;i<=h;i++){\n\t\tif((!LO[i].empty() || !LI[i].empty()) && !chk[i]) die();\n\t\tif(LI[i].size() >= LO[i].size()){\n\t\t\tfor(j=0;j<LI[i].size() - LO[i].size();j++) SL.insert(i);\n\t\t}\n\t\telse die();\n\t\tchk[i] = 0;\n\t}\n\t\n\tdfs(0, RO);\n\t\n\tfor(i=1;i<=h;i++){\n\t\tif((!RO[i].empty() || !RI[i].empty()) && !chk[i]) die();\n\t\tif(RI[i].size() >= RO[i].size()){\n\t\t\tfor(j=0;j<RI[i].size() - RO[i].size();j++) SR.insert(i);\n\t\t}\n\t\telse die();\n\t\tchk[i] = 0;\n\t}\n\t\n\tfor(pii t: V){\n\t\tauto it = SL.find(t.second);\n\t\tif(it == SL.end()) die();\n\t\tSL.erase(it);\n\t\t\n\t\tit = SR.find(t.first);\n\t\tif(it == SR.end()) die();\n\t\tSR.erase(it);\n\t}\n\t\n\tif(SL.empty() || SR.empty()) die();\n\t\n\tprintf(\"YES\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing std::vector;\n\n#define MAXN 100005\n#define MAXH 405\nint indeg[MAXH],outdeg[MAXH];\nbool vis[MAXH];\nvector<int> G[MAXH];\n\nvoid add_edge(int u,int v)\n{\n    outdeg[u]++;indeg[v]++;\n    G[u].push_back(v);G[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    bool f=indeg[v]!=outdeg[v];\n    vis[v]=true;\n    for(auto to:G[v])\n    {\n        if(!vis[to]) \n            f|=dfs(to);\n    }\n    return f;\n}\n\nint main()\n{\n    int N,H;\n    int a[MAXN],b[MAXN],c[MAXN],d[MAXN];\n    scanf(\"%d%d\",&N,&H);\n    for(int i=1;i<=N;i++) \n    {\n        scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n        int l,r;\n        l= ( c[i]==0 ? a[i] : -c[i] );\n        r= ( d[i]==0 ? -b[i] : d[i] );\n        add_edge(l+H,r+H);\n    }\n\n    bool flag=true;\n    for(int i=0;flag && i<=H;i++) \n    {\n        if(outdeg[i]>indeg[i]) \n            flag=false;\n    }\n    for(int i=H+1;flag && i<=2*H;i++)\n    {\n        if(indeg[i]>outdeg[i]) \n             flag=false;\n    }\n\n    memset(vis,false,sizeof(vis));\n    for(int i=0;flag && i<=2*H;i++)\n    {\n        if((indeg[i]||outdeg[i])&&!vis[i]) \n            flag &=dfs(i);\n    }\n\n    if(flag) \n    {\n        printf(\"YES\\n\"); \n    }\n    else\n    { \n        printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstring>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nint N,H,pal;\tint a,b,c,d;\nstruct line{int in,ch;}lines[100001];bool cam(line a,line b){return a.in>b.in;}\nbool v[100001];\nvoid solve(int no,int t)\n{\n\n\tif(t==N-1)\n\t{\n\t\tint st=0;while(v[st]!=0)st++;\n\t\tif((lines[st].in==-lines[no].ch&&lines[st].ch>0))\n\t\t\tpal=1;\n\t\telse if(lines[st].in>0&&lines[st].ch>0&&lines[no].ch>0)\n\t\t\tpal=1;\n\t\tif(pal)return;\n\t}\n\telse\n\t{\n\t\tint st=0;\n\t\twhile(lines[st].in!=-lines[no].ch&&st<N)st++;\n\t\tif(st<N)\n\t\t{\n\t\tfor(int i=st;i<N&&lines[i].in==-lines[no].ch;i++)\n\t\t{\n\t\t\tif(v[i]==0)\n\t\t\t{\tv[i]=1;solve(i,t+1);v[i]=0;if(pal)return;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(lines[no].ch>0)\n\t\t{\n\t\t\tfor(int i=0;i<N&&lines[i].in>0;i++)\n\t\t\t{\n\t\t\t\tif(v[i]==0)\n\t\t\t\t{\t\n\t\t\t\t\tv[i]=1;solve(i,t+1);v[i]=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n\n\tpal=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta=c==0?a:-c;b=d==0?b:-d;\n\t\tlines[i].in=a;lines[i].ch=b;\n\t}\n\tsort(lines,lines+N,cam);\n\tfor(int i=0;i<N&&lines[i].in>0;i++)\n\t{\n\t\tv[i]=1;\n\t\tsolve(i,1);\n\t\tv[i]=0;\n\t\tif(pal)break;\n\t}\n\tif(pal)printf(\"YES\");\n\telse printf(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\n\n\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint th = 0;\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, c[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st != e[401]||st>=e[401]||s<2) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\n\tbool exiroad[402][402] = {};\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tfill(chked, chked + 402, false);\n\t\tq.push(i); chked[i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front(); q.pop();\n\t\t\trep(j, G[x].size()) {\n\t\t\t\tint to = G[x][j];\n\t\t\t\tif (chked[to])continue;\n\t\t\t\tchked[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\trep(j, 402) {\n\t\t\tif (chked[j])exiroad[i][j] = true;\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (!exi[i])continue;\n\t\tRep(j, i + 1, 402) {\n\t\t\tif (!exi[j])continue;\n\t\t\tif (!exiroad[i][j] || !exiroad[j][i]) {\n\t\t\t\tcout << \"NO\" << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker,\"/STACK:1000000000\")\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<b;++i)\n#define fj(a,b) for(int j=a;j<b;++j)\n#define fo(a,b) for(int o=a;o<b;++o)\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> pii;\n////////////////////\n\nint const N = 1e5 + 41;\nint const H = 241;\n\nint n, h, a[N], b[N], c[N], d[N];\nint d0[H][2], d1[H][2];\n\nvector<pii> e[H][2];\nvector<pii> st;\n\npii getfrom(int a, int c){\n\tif(c > 0) return mp(c, 0);\n\telse return mp(a, 1);\n}\n\npii getto(int b, int d){\n\tif(d > 0) return mp(d, 1);\n\telse return mp(b, 0);\n}\n\nbool dfs(pii x){\n\tst.pb(x);\n\tbool res;\n\tif(sz(e[x.first][x.second])){\n\t\tpii y = e[x.first][x.second].back();\n\t\te[x.first][x.second].pop_back();\n\t\t--d0[x.first][x.second];\n\t\t--d1[y.first][y.second];\n\t\tres = dfs(y);\n\t}else{\n\t\tif(x.second == 0){\n\t\t\tres = (x.second == 0 ? 1 : 0);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid dfs1(pii x){\n\tst.pb(x);\n\twhile(sz(e[x.first][x.second])){\n\t\tpii y = e[x.first][x.second].back();\n\t\t--d0[x.first][x.second];\n\t\t--d1[y.first][y.second];\n\t\te[x.first][x.second].pop_back();\n\t\tdfs1(y);\n\t}\n}\n\nvoid solve(){\n\tfi(0, n){\n\t\tpii x = getfrom(a[i], c[i]);\n\t\tpii y = getto(b[i], d[i]);\n\t\te[x.first][x.second].pb(y);\n\t\t++d0[x.first][x.second];\n\t\t++d1[y.first][y.second];\n\t}\n\tbool ok = true;\n\tfi(1, h+1){\n\t\tint k = d0[i][1] - d1[i][1];\n\t\tif(k < 0) ok = false;\n\t\tfj(0, k){\n\t\t\tok &= dfs(mp(i, 1));\n\t\t}\n\t}\n\tset<pii> t;\n\twhile(sz(st)){\n\t\tt.insert(st.back());\n\t\tst.pop_back();\n\t}\n\tfi(1, h+1) fj(0, 2){\n\t\tok &= (d0[i][j] == d1[i][j]);\n\t}\n\tfi(1, h+1) fj(0, 2){\n\t\tif(d0[i][j] == 0) continue;\n\t\tst.clear();\n\t\tdfs1(mp(i, j));\n\t\tbool f = false;\n\t\tfo(0, sz(st)){\n\t\t\tif(t.find(st[o]) != t.end()) f = true;\n\t\t}\n\t\tok &= f;\n\t}\n\t\n\tif(ok) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\t\n\tscanf(\"%d %d\",&n,&h);\n\tfi(0, n) scanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct MaxFlowDinic {\n    typedef int flow_t;\n    struct Edge {\n        int next;\n        size_t inv; /* inverse edge index */\n        flow_t res; /* residual */\n    };\n    int n;\n    vector<vector<Edge>> graph;\n    vector<int> q, l, start;\n    void init(int _n) {\n        n = _n;\n        graph.resize(n);\n        for (int i = 0; i < n; i++) graph[i].clear();\n    }\n    void add_edge(int s, int e, flow_t cap, flow_t caprev = 0) {\n        Edge forward{ e, graph[e].size(), cap };\n        Edge reverse{ s, graph[s].size(), caprev };\n        graph[s].push_back(forward);\n        graph[e].push_back(reverse);\n    }\n    bool assign_level(int source, int sink) {\n        int t = 0;\n        memset(&l[0], 0, sizeof(l[0]) * l.size());\n        l[source] = 1;\n        q[t++] = source;\n        for (int h = 0; h < t && !l[sink]; h++) {\n            int cur = q[h];\n            for (const auto& e : graph[cur]) {\n                if (l[e.next] || e.res == 0) continue;\n                l[e.next] = l[cur] + 1;\n                q[t++] = e.next;\n            }\n        }\n        return l[sink] != 0;\n    }\n    flow_t block_flow(int cur, int sink, flow_t current) {\n        if (cur == sink) return current;\n        for (int& i = start[cur]; i < graph[cur].size(); i++) {\n            auto& e = graph[cur][i];\n            if (e.res == 0 || l[e.next] != l[cur] + 1) continue;\n            if (flow_t res = block_flow(e.next, sink, min(e.res, current))) {\n                e.res -= res;\n                graph[e.next][e.inv].res += res;\n                return res;\n            }\n        }\n        return 0;\n    }\n    flow_t solve(int source, int sink) {\n        q.resize(n);\n        l.resize(n);\n        start.resize(n);\n        flow_t ans = 0;\n        while (assign_level(source, sink)) {\n            memset(&start[0], 0, sizeof(start[0]) * n);\n            while (flow_t flow = block_flow(source, sink, numeric_limits <flow_t\n                        >::max()))\n                ans += flow;\n        }\n        return ans;\n    }\n};\n\nstruct MaxFlowEdgeDemands\n{\n    MaxFlowDinic mf;\n    using flow_t = MaxFlowDinic::flow_t;\n    vector<flow_t> ind, outd;\n    flow_t D; int n;\n    void init(int _n) {\n        n = _n; D = 0; mf.init(n + 2);\n        ind.clear(); outd.clear();\n        ind.resize(n, 0); outd.resize(n, 0);\n    }\n    void add_edge(int s, int e, flow_t cap, flow_t demands = 0) {\n        mf.add_edge(s, e, cap - demands);\n        D += demands; ind[e] += demands; outd[s] += demands;\n    }\n    // returns { false, 0 } if infeasible\n    // { true, maxflow } if feasible\n    pair<bool, flow_t> solve(int source, int sink) {\n        mf.add_edge(sink, source, numeric_limits <flow_t >::max());\n        for (int i = 0; i < n; i++) {\n            if (ind[i]) mf.add_edge(n, i, ind[i]);\n            if (outd[i]) mf.add_edge(i, n + 1, outd[i]);\n        }\n        if (mf.solve(n, n + 1) != D) return{ false, 0 };\n        for (int i = 0; i < n; i++) {\n            if (ind[i]) mf.graph[i].pop_back();\n            if (outd[i]) mf.graph[i].pop_back();\n        }\n        return{ true, mf.solve(source, sink) };\n    }\n};\n\nint lbottom(int t)\n{\n    return t;\n}\n\nint lup(int t)\n{\n    return 200 + t;\n}\n\nint rbottom(int t)\n{\n    return 400 + t;\n}\n\nint rup(int t)\n{\n    return 600 + t;\n}\n\nint next_blk(int t)\n{\n    if (t > 400 && t <= 600) return lup(t - 400);\n    else return lbottom(t - 600);\n}\n\nbool loop[444];\nbool edge[444];\nint x[444][444];\n\nint main()\n{\n    int n, h;\n    scanf(\"%d%d\",&n,&h);\n    MaxFlowEdgeDemands mf;\n    mf.init(402);\n    for (int i = 0; i < n; i++)\n    {\n        int a, b, c, d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\n        int lidx, ridx;\n\n        if (c == 0) lidx = lbottom(a);\n        else lidx = lup(c);\n\n        if (d == 0) ridx = rbottom(b);\n        else ridx = rup(d);\n\n        ridx = next_blk(ridx);\n\n        x[lidx][ridx]++;\n    }\n    for (int i = 1; i <= 400; i++)\n    {\n        for (int j = 1; j <= 400; j++)\n        {\n            if (x[i][j] == 0) continue;\n\n            if (x[i][j] == x[j][i]) loop[i] = loop[j] = true;\n            else edge[i] = edge[j] = true;\n        }\n    }\n    for (int i = 1; i <= 400; i++) if (loop[i] && !edge[i]) return !printf(\"NO\\n\");\n\n    for (int i = 1; i <= 400; i++)\n    {\n        for (int j = i + 1; j <= 400; j++)\n        {\n            if (x[i][j] > x[j][i]) mf.add_edge(i, j, x[i][j] - x[j][i], x[i][j] - x[j][i]);\n            else if (x[i][j] < x[j][i]) mf.add_edge(j, i, -x[i][j] + x[j][i], -x[i][j] + x[j][i]);\n        }\n    }\n    for (int i = 1; i <= 200; i++) mf.add_edge(0, i, 1e9);\n    for (int i = 201; i <= 400; i++) mf.add_edge(i, 401, 1e9);\n    if (mf.solve(0, 401).first) printf(\"YES\\n\");\n    else printf(\"NO\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[410], F[410];\nint Deg[410], n, H, m;\nvoid Make_Edge(int a, int b){\n    E[a].push_back(b);\n    F[b].push_back(a);\n    Deg[b]++;\n    Deg[a]--;\n}\nint v[410], cnt, SCC[410], ord[410];\nvoid DFS(int a){\n    int i;\n    v[a]=1;\n    for(i=0;i<E[a].size();i++){\n        if(!v[E[a][i]])DFS(E[a][i]);\n    }\n    ord[++cnt] = a;\n}\nvoid DFS2(int a){\n    int i;\n    SCC[a] = cnt;\n    for(i=0;i<F[a].size();i++){\n        if(!SCC[F[a][i]])DFS2(F[a][i]);\n    }\n}\nint main(){\n    int i, a, b, c, d;\n    scanf(\"%d%d\",&n,&H);\n    for(i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        if(!c && !d) Make_Edge(a, H+1+b);\n        if(!c && d)Make_Edge(a, d);\n        if(c && !d)Make_Edge(H+1+c, H+1+b);\n        if(c && d)Make_Edge(H+1+c, d);\n    }\n    for(i=0;i<=(H+1)*2;i++){\n        while(Deg[i]!=0){\n            if(Deg[i] < 0)Make_Edge(0, i);\n            else Make_Edge(i, 0);\n        }\n    }\n    m = (H+1)*2;\n    for(i=0;i<=m;i++){\n        if(!v[i])DFS(i);\n    }\n    cnt = 0;\n    for(i=m+1;i>=1;i--){\n        if(!SCC[ord[i]]){\n            cnt++;\n            DFS2(ord[i]);\n        }\n    }\n    for(i=0;i<=m;i++){\n        if(!E[i].empty() && SCC[i] != SCC[0]){\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n    printf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 200005 ;\nusing namespace std ;\n\nint n, H, e, d[2][N], fa[N], sz[N] ;\nbool vis[N] ;\n\nint getfa(int x) {\n\treturn (fa[x] == x ? x : fa[x] = getfa(fa[x])) ;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &H) ;\n\tint x1, y1, x2, y2, x, y ;\n\trep(i, - H + 1, H) fa[H + i] = H + i ;\n\trep(i, 1, n) {\n\t\tscanf(\"%d%d%d%d\", &x1, &x2, &y1, &y2) ;\n\t\tx = y1 ? H - y1 : H + x1 ;\n\t\ty = y2 ? H + y2 : H - x2 ;\n\t\t++ d[0][y], ++ d[1][x] ;\n\t\tx = getfa(x), y = getfa(y) ;\n\t\tif (x != y) fa[x] = y, sz[y] += sz[x] ;\n\t\t++ sz[y] ;\n\t}\n\trep(i, 1, H) if (d[0][H + i] > d[1][H + i]) {\n\t\tprintf(\"NO\\n\") ;\n\t\treturn 0 ;\n\t}\n\trep(i, - H + 1, - 1) if (d[0][H + i] < d[1][H + i]) {\n\t\tprintf(\"NO\\n\") ;\n\t\treturn 0 ;\n\t}\n\trep(i, - H + 1, H) if (d[0][H + i] != d[1][H + i]) {\n\t\tvis[getfa(H + i)] = true ;\n\t}\n\trep(i, - H + 1, H) if (getfa(H + i) == H + i && !vis[H + i] && sz[H + i] > 0) {\n\t\tprintf(\"NO\\n\") ;\n\t\treturn 0 ;\n\t}\n\tprintf(\"YES\\n\") ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\nint F() {\n\tregister int a, b, c;\n\twhile(c=getchar(), c<'-');\n\tb=(c=='-');\n\tfor(a=b?0:c-'0'; c=getchar(),c>'-'; a=a*10+c-'0');\n\treturn b?-a:a;\n}\nconst int N=2e5+10;\nint fa[N];\nint find(register int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}\nint deg[N];\nbool mark[N], appear[N];\nbool work() {\n\tregister int n=F(), h=F(), i, a, b, c, d, cnt=0, ans=0;\n\tfor(i=1; i<=2*h; ++i) fa[i]=i, deg[i]=0, appear[i]=mark[i]=0;\n\tfor(i=1; i<=n; ++i) {\n\t\ta=F(), b=F(), c=F(), d=F();\n\t\t++deg[c=c?c:a+h];\n\t\t--deg[d=d?d+h:b];\n\t\tfa[find(c)]=find(d);\n\t\tappear[c]=appear[d]=1;\n\t}\n\tfor(i=1; i<=2*h; ++i) if(appear[i]) {\n\t\tif(i<=h&&deg[i]>0 || i>h&&deg[i]<0) return 0;\n\t\tmark[i] = deg[i]!=0;\n\t}\n\tfor(i=1; i<=2*h; ++i) mark[find(i)]|=mark[i];\n\tfor(i=1; i<=2*h; ++i) if(appear[i] && find(i)==i && !mark[i]) return 0;\n\treturn 1;\n}\nint main() {\n\tregister int t=1;\n\twhile(t--) puts(work()?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\nint in[402],fa[402];\nbool vis[402],qwq[402];\nint h;\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nvoid add(int l,int r){\n\tl+=h;\n\tr+=h;\n\tin[r]++;\n\tin[l]--;\n\tqwq[l]=qwq[r]=1;\n\tint x=getf(l),y=getf(r);\n\tfa[x]=y;\n}\nint main(){\n\tint n;\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=0;i<=2*h;i++)\n\t\tfa[i]=i;\n\twhile(n--){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tadd(c?-c:a,d?d:-b);\n\t}\n\tfor(int i=0;i<h;i++)\n\t\tif (in[i]<0)\n\t\t\treturn puts(\"NO\"),0;\n\tfor(int i=h+1;i<=2*h;i++)\n\t\tif (in[i]>0)\n\t\t\treturn puts(\"NO\"),0;\n\t//puts(\"WTF\");\n\tfor(int i=0;i<=2*h;i++)\n\t\tif (in[i])\n\t\t\tvis[getf(i)]=1;\n\t//puts(\"WTF\");\n\tfor(int i=0;i<=2*h;i++)\n\t\tif (qwq[i] && !vis[getf(i)])\n\t\t\treturn puts(\"NO\"),0;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2e5+7;\nint in[N],out[N],fa[N],sz[N],n,h;\ninline int find(int x){while(x!=fa[x])x=fa[x]=fa[fa[x]];return x;}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=0;i<=2*h;++i)fa[i]=i,sz[i]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tint A,B,C,D;\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tint iL=C==0?A:-C,iR=D==0?-B:D;\n\t\t++in[iL+=h],++out[iR+=h];\n\t\tif(find(iL)!=find(iR))sz[fa[iR]]+=sz[fa[iL]],fa[fa[iL]]=fa[iR];\n\t}\n\tbool ok=1;\n\tfor(int i=0;i<=2*h&&ok;++i)\n\tif(in[i]||out[i]){\n\t\tif(i<=h&&in[i]>out[i])ok=0;\n\t\tif(i>=h&&in[i]<out[i])ok=0;\n\t\tif(sz[find(i)]==1)ok=0;\n\t}\n\tputs(ok?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint id[405],od[405];bool v[405];vector <int>G[405];int N,H;int a,b,c,d;\n\nbool dfs(int tt)\n{\n    bool f=id[tt]!=od[tt];\n    v[tt]=true;\n\tfor(int i=0;i<G[tt].size();i++)\n    {\n        if(!v[G[tt][i]]) \n            f|=dfs(G[tt][i]);\n    }\n    return f;\n}\n\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&H);\n    for(int i=1;i<=N;i++) \n    {\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        int l,r;l= ( c==0 ? a : -c );r= ( d==0 ? -b : d );\n\t\tod[l+H]++;id[r+H]++;G[l+H].push_back(r+H);G[r+H].push_back(l+H);\n    }\n\tbool flag=1;\n\tfor(int i=0;flag&&i<=H;i++)if(od[i]>id[i])flag=0;\n\tfor(int i=H+1;flag&&i<=2*H+1;i++)if(od[i]<id[i])flag=0;\n\tmemset(v,false,sizeof(v));\n    for(int i=0;flag && i<=2*H;i++)\n    {if((id[i]||od[i])&&!v[i]) flag &=dfs(i); }\n    if(flag)  printf(\"YES\\n\"); \n    else  printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint fa[MAXN],ind[MAXN],oud[MAXN],v1[MAXN],v2[MAXN];\nint n,h;\nbool flag[MAXN];\nint get_fa(int x){\n\tif(fa[x]==0)\n\t\treturn x;\n\tfa[x]=get_fa(fa[x]);\n\treturn fa[x];\t\n}\nint main(){\n\tSF(\"%d%d\",&n,&h);\n\tint x,y,a,b;\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d%d%d%d\",&x,&y,&a,&b);\n\t\tint u,v;\n\t\tif(a==0)\n\t\t\tu=x+200;\n\t\telse\n\t\t\tu=a;\n\t\tif(b==0)\n\t\t\tv=y;\n\t\telse\n\t\t\tv=b+200;\n\t\tflag[u]=flag[v]=1;\n\t\toud[u]++;\n\t\tind[v]++;\n\t\tif(get_fa(u)!=get_fa(v))\n\t\t\tfa[get_fa(u)]=get_fa(v);\n\t}\n\tfor(int i=1;i<=400;i++){\n\t\tif(ind[i]>oud[i]){\n\t\t\tv1[get_fa(i)]++;\n\t\t\tif(i>200){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(ind[i]<oud[i]){\n\t\t\tv2[get_fa(i)]++;\n\t\t\tif(i<=200){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=400;i++)\n\t\tif(fa[i]==0)\n\t\t\tif(v1[i]==0&&v2[i]==0&&flag[i]){\n\t\t\t\tPF(\"NO\");\t\n\t\t\t\treturn 0;\n\t\t\t}\n\tPF(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint inadj[210][2], outadj[210][2], n, h;\nint inadj2[210][2], outadj2[210][2];\npair<int, int> thing(int a, int b)\n{\n\tpair<int, int> ans;\n\tif (b) ans = { b, 0 };\n\telse ans = { a, 1 };\n\treturn ans;\n}\nvector<pair<int, int> > adj[210][2];\nint seen[210][2], c;\nvector<pair<int, int> > components[500];\nvoid dfs(int a, int b, int d)\n{\n\tif (seen[a][b]) return;\n\tseen[a][b] = 1;\n\tcomponents[d].push_back({ a, b });\n\tfor (auto c : adj[a][b]) dfs(c.first, c.second, d);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tpair<int, int> in, out;\n\t\tin = thing(a, c);\n\t\tout = thing(b, d);\n\t\tout.second = !out.second;\n\t\toutadj[in.first][in.second]++;\n\t\tinadj[out.first][out.second]++;\n\t\tadj[in.first][in.second].push_back(out);\n\t\tadj[out.first][out.second].push_back(in);\n\t}\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tif (adj[i][j].size() && !seen[i][j]) dfs(i, j, c++);\n\t\t//\tprintf(\"%d:%d - in %d, out %d\\n\", i, j, inadj[i][j], outadj[i][j]);\n\t\t}\n\t}\n\tbool works = 1;\n\tfor (int i = 0; i < c; i++)\n\t{\n\t\tfor (int i = 0; i <= h; i++) inadj2[i][0] = inadj2[i][1] = outadj2[i][0] = outadj2[i][1] = 0;\n\t\tfor (auto b : components[i])\n\t\t{\n\t\t\tinadj2[b.first][b.second] += inadj[b.first][b.second];\n\t\t\toutadj2[b.first][b.second] += outadj[b.first][b.second];\n\t\t}\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t//\tprintf(\"%d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\tif (inadj2[i][0] - outadj2[i][0] > 0 && inadj2[i][1] - outadj2[i][1] < 0 && 0) \n\t\t\t{\n\t\t\t//\tprintf(\"%d\\n\", i);\n\t\t\t\tinadj2[i][0]--; \n\t\t\t\toutadj2[i][1]--;\n\t\t\t//\tprintf(\" %d %d - %d %d\\n\", inadj2[i][0], outadj2[i][0], inadj2[i][1], outadj2[i][1]);\n\t\t\t}\n\t\t}\n\t\tint extra = 0;\n\t\tfor (int i = 0; i <= h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t{\n\t\t//\t\tprintf(\"  %d\\n\", abs(inadj2[i][j] - outadj2[i][j]));\n\t\t\t\textra += abs(inadj2[i][j] - outadj2[i][j]);\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\", extra);\n\t\tif (extra % 2 ) works = 0;\n\t}\n//\tprintf(\"Components %d\\n\", c);\n\tif (works) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\n#define M 205\nvector<int> g[N];\nbool vis[N],chk[N];\nint du[N];//outd - ind\nvoid addedge(int f,int t){\n    f+=M,t+=M;\n    chk[f]=chk[t]=true;\n    g[f].push_back(t);\n    g[t].push_back(f);\n    du[f]++,du[t]--;\n}\nbool DFS(int u){\n    bool ret= du[u]!=0 ;vis[u]=true;\n    for(int i:g[u])  \n        if(!vis[i]) ret|=DFS(i);\n    return ret;\n}\nint n,h;\nint main(){\n    scanf(\"%d%d\",&n,&h);\n    for(int i=1,a,b,c,d;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        addedge((c==0? a:-c),(d==0? -b:d) );\n    }\n    for(int i=-h;i<=h;i++)\n        if(i!=0&&i*du[i+M]<0)\n            return puts(\"NO\"),0;\n    for(int i=-h;i<=h;i++)\n        if(chk[i+M]&&i!=0&&!vis[i+M]&&!DFS(i+M))\n            return puts(\"NO\"),0;\n    return puts(\"YES\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvector <int> v[512];\nint in[512], out[512], trec[512];\n\n#define v (v + 230)\n#define trec (trec + 230)\n#define in (in + 230)\n#define out (out + 230)\n\nbool OK;\n\nvoid dfs (int nod)\n{\n    trec[nod] = 1;\n    if (in[nod] != out[nod]) OK = true;\n\n    for (auto &it : v[nod])\n        if (!trec[it]) dfs (it);\n}\n\nint main ()\n{\n   // freopen (\"file.in\", \"r\", stdin);\n\n    int n, h;\n    scanf (\"%d %d\", &n, &h);\n\n    for (int i = 1; i <= n; ++i)\n    {\n        int a, b, c, d, l, r;\n        scanf (\"%d %d %d %d\", &a, &b, &c, &d);\n\n        if (!c) l = a;\n        else l = -c;\n\n        if (!d) r = -b;\n        else r = d;\n\n        v[l].push_back (r);\n        v[r].push_back (l);\n\n        ++out[l];\n        ++in[r];\n    }\n\n    for (int i = -h; i <= h; ++i)\n    {\n        if (i < 0)\n        {\n            if (in[i] < out[i])\n            {\n                printf (\"NO\\n\");\n                return 0;\n            }\n        }\n\n        if (i > 0)\n        {\n            if (in[i] > out[i])\n            {\n                printf (\"NO\\n\");\n                return 0;\n            }\n        }\n    }\n\n    trec[0] = 1;\n\n    for (int i = -h; i <= h; ++i)\n        if (!trec[i] && (in[i] || out[i]))\n        {\n            OK = false;\n            dfs (i);\n\n            if (!OK)\n            {\n                printf (\"NO\\n\");\n                return 0;\n            }\n        }\n\n    printf (\"YES\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint th = 0;\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t\tth += c[i];\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, c[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st < e[401]||st>=e[401]||th+st!=e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<P>vec;\nint sum[405];\nint par[405],ran[405];\nvoid init(){ for(int i=0;i<405;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nint cnt[405],X;\nset<int>S;\nint main(){\n\tcin>>n>>m;init();\n\trep(i,n){\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\t\tif(c==0) a+=200; else a=c;\n\t\tif(d==0); else b=200+d;\n\t\tvec.pb(mp(a,b));//cout<<a<<\" \"<<b<<endl;\n\t\tsum[a]++; sum[b]--; unite(a,b);S.insert(a);S.insert(b);X=a;\n\t}\n\tint val = 0,val2 = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(sum[i]>0){\n\t\t\tputs(\"NO\");return 0;\n\t\t}\n\t\telse cnt[i] = -1*sum[i];\n\t\tval+=cnt[i];\n\t\tif(sum[200+i]<0){\n\t\t\tputs(\"NO\");return 0;\n\t\t}\n\t\telse cnt[200+i] = sum[i];\n\t\tval2 += cnt[200+i];\n\t}\n\tassert(val==val2);\n\tif(!val){puts(\"NO\");return 0;}\n\twhile(1){\n\t\tbool upd = 0;\n\t\t{\n\t\t\trepn(i,m)repn(j,m){\n\t\t\t\tif(cnt[i]>=1&&cnt[j+200]>=1&&!same(i,j+200)){\n\t\t\t\t\tunite(i,j+200);cnt[i]--;cnt[j+200]--;upd=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!upd) break;\n\t}\n\tfor(set<int>::iterator it=S.begin();it!=S.end();++it){\n\t\tif(!same(*it,X)){\n\t\t\tputs(\"NO\");return 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxm=2e5+10;\nconst int base=210;\n\nint n,H,in[500],out[500],cnt;\nbool diff[500],vis[500];\nint tote,FIR[500],TO[maxm],NEXT[maxm];\n\nvoid addedge(int u,int v)\n{\n//\tprintf(\"%d %d\\n\",u,v);\n\tout[base+u]++;\n\tin[base+v]++;\n\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tFIR[u]=tote;\n\n\tTO[++tote]=u;\n\tNEXT[tote]=FIR[v];\n\tFIR[v]=tote;\n}\n\nvoid dfs(int u)\n{\n\tif (vis[u]) return;\n\tvis[u]=1;\n\tcnt+=diff[u];\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\tdfs(TO[p]);\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,a,b,c,d;\n\tscanf(\"%d%d\",&n,&H);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\taddedge(c?-c:a,d?d:-b);\n\t}\n\n\tfor (i=-200;i<=200;i++)\n\t\tif (out[base+i]!=in[base+i])\n\t\t{\n\t\t\tdiff[base+i]=1;\n//\t\t\tprintf(\"%d : %d\\n\",i,out[base+i]-in[base+i]);\n//\t\t\tprintf(\"%d\\n\",(i<0)^(out[base+i]<in[base+i]));\n\t\t\tif ((i<0)^(out[base+i]<in[base+i]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\tfor (i=-200;i<=200;i++)\n\t\tif (!vis[base+i])\n\t\t{\n\t\t\tcnt=0;\n\t\t\tdfs(base+i);\n\t\t\tif (!cnt)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define neko 100010\n#define heko 410\n#define qwq return printf(\"YES\"),0; \n#define orz return printf(\"NO\"),0; \n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))\nstatic int n,H;\ntypedef int arr[heko];\narr fa,book,dgi,dgo,out;\nnamespace IO\n{\n\tconst unsigned int bufsize=1<<16,outsize=1<<24;\n\tstatic char ch[bufsize],*S=ch,*T=ch;\n\tinline char getc()\n\t{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\n\tstatic char Out[outsize],*nowp=Out;\n\tinline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\n\t\tvoid read(T &x)\n\t\t{\n\t\t\tchar c=getc();x=0;\n\t\t\tfor(;!isdigit(c);c=getc());\n\t\t\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n\t\t}\n\ttemplate<typename T>\n\t\tvoid write(T x,char c='\\n')\n\t\t{\n\t\t\tif(!x)*nowp++='0';\n\t\t\tstatic unsigned int stk[50],tp=0;\n\t\t\tfor(;x;x/=10)stk[++tp]=x%10;\n\t\t\tfor(;tp;*nowp++=stk[tp--]^'0');*nowp++=c;\n\t\t}\n}\nint find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}\nint main()\n{\n\tusing namespace IO;\n\tint x,y,z,o,X,Y;\n\tread(n),read(H);\n\tf(i,0,H<<1)fa[i]=i;\n\tf(i,1,n)\n\t{\n\t\tread(x),read(y),read(z),read(o);\n\t\tif(z==0)X=H+x;\n\t\telse X=H-z;\n\t\tif(o==0)Y=H-y;\n\t\telse Y=H+o;\n\t\tbook[X]=book[Y]=1;\n\t\t++dgi[Y],++dgo[X];\n\t\tfa[find(Y)]=find(X);\n\n\t}\n\tf(i,0,H)if(dgi[i]<dgo[i])orz;\n\tf(i,H+1,H<<1)if(dgi[i]>dgo[i])orz;\n\tf(i,0,H<<1)out[fa[i]]|=(dgi[i]^dgo[i]);\n\tf(i,0,H<<1)if(fa[i]==i&&book[i]&&!out[fa[i]])orz;\n\tqwq;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int Z = 210;\nconst int N = 500;\nvector<int> g[N];\nint deg[N];\nbool used[N];\n\nvoid dfs(int v)\n{\n    used[v] = 1;\n    for (int u : g[v])\n        if (!used[u])\n            dfs(u);\n}\n\nint main()\n{\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    while(n--) {\n        int a, b, c, d;\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        a += c;\n        b += d;\n        int v, u;\n        if (c == 0) {\n            v = Z + a;   \n        } else {\n            v = Z - c;\n        }\n        if (d == 0) {\n            u = Z - b;\n        } else {\n            u = Z + d;\n        }\n        g[v].push_back(u);\n        deg[v]++;\n        deg[u]--;\n    }\n    for (int v = 0; v < N; v++) {\n        if (deg[v] == 0) continue;\n        /*\n        if (abs(deg[v]) != 1) {\n            printf(\"NO\\n\");\n            return 0;\n        }\n        */\n        if (deg[v] < 0) {\n            if (v >= Z) {\n                printf(\"NO\\n\");\n                return 0;\n            }\n        } else {\n            if (v <= Z) {\n                printf(\"NO\\n\");\n                return 0;\n            }\n            if (!used[v]) dfs(v);\n        }\n    }\n    for (int v = 0; v < N; v++) {\n        if (!used[v] && !g[v].empty()) {\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n    printf(\"YES\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nbool vis[10010];\nvector<int> g[10010];\nint ind[10010], outd[10010], fa[10010], p[10010];\n\nint Ask(int x) {\n\treturn x == fa[x] ? x : fa[x] = Ask(fa[x]);\n}\n\nint main() {\n\tint n, h;\n\tscanf(\"%d%d\", &n, &h);\n\tfor(int i = 0; i <= h + h; i++)\n\t\tfa[i] = i;\n\tfor(int i = 1; i <= n; i++) {\n\t\tint a, b, c, d, p, q;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tp = !c ? a : -c;\n\t\tq = !d ? -b : d;\n\t\tint fp = Ask(p + h), fq = Ask(q + h);\n\t\tif(fp != fq) \n\t\t\tfa[fp] = fq;\n\t\tind[q + h]++;\n\t\toutd[p + h]++;\n\t}\n\tfor(int i = 0; i <= h + h; i++) {\n\t\tif(i < h && outd[i] > ind[i]) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(i > h && outd[i] < ind[i]) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i <= h + h; i++) {\n\t\tif(!ind[i] && !outd[i]) continue;\n\t\tint fx = Ask(i);\n\t\tp[fx] |= (ind[i] != outd[i]);\n\t}\n\tfor(int i = 0; i <= h + h; i++) {\n\t\tif(!ind[i] && !outd[i]) continue;\n\t\tif(Ask(i) != i) continue;\n\t\tif(!p[i]) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\nll degin[200005], degout[200005];\nvll adj[200005];\nbool occ[200005], diff[200005], vis[200005];\nll col[200005];\nvoid dfs(ll u, ll c){\n\tif (vis[u]) return; vis[u] = 1; col[u] = c;\n\tfor (ll i = 0; i < adj[u].size(); i++) dfs(adj[u][i], c);\n}\nint main(){\n\tfastio;\n\tll n, h; cin >> n >> h;\n\tfor (ll i = 0; i < n; i++){\n\t\tll a, b, c, d, l, r; cin >> a >> b >> c >> d;\n\t\tif (c == 0) l = a; else l = -c;\n\t\tif (d == 0) r = -b; else r = d;\n\t\tl += h; r += h;\n\t\tadj[l].pb(r); adj[r].pb(l);\n\t\tdegin[r]++; degout[l]++;\n\t\tocc[l] = 1; occ[r] = 1;\n\t}\n\tll cur = 0;\n\tfor (ll i = 0; i <= 2 * h; i++){\n\t\tif (occ[i] && !vis[i]){\n\t\t\tdfs(i, cur); cur++;\n\t\t}\n\t}\n\tfor (ll i = 0; i <= 2 * h; i++){\n\t\tif (!occ[i]) continue;\n\t\tif (i >= h){\n\t\t\tif (degout[i] < degin[i]){\n\t\t\t\tcout << \"NO\\n\"; return 0;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif (degout[i] > degin[i]){\n\t\t\t\tcout << \"NO\\n\"; return 0;\n\t\t\t}\n\t\t}\n\t\tif (degin[i] != degout[i]) diff[col[i]] = 1;\n\t}\n\tfor (ll i = 0; i < cur; i++){\n\t\tif (!diff[i]){\n\t\t\tcout << \"NO\\n\"; return 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\"; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f(a, n) for (int a=0; a<n; a++)\n#define F(a, n) for (int a=1; a<=n; a++)\nusing namespace std;\n\nstruct node{\n\tvector<int> out;\n\tint in=0;\n\tint id;\n\tbool vis = 0;\n};\nnode A[401];\nint w, x, y, z;\nint h, n;\nbool fail = 0;\nvoid visit(int x){\n\tif (A[x].vis) return;\n\tA[x].vis = 1;\n\tfor (auto y: A[x].out) visit(y);\n}\nint main() {\n\tcin>>n>>h;\n\tf(i, 401) A[i].id = i;\n\tf(i, n){\n\t\tcin>>w>>x>>y>>z;\n\t\tint a, b;\n\t\tif (y==0) a=200+w; else a = y;\n\t\tif (z==0) b=x; else b=200+z; \n\t\tA[a].out.push_back(b);\n\t\tA[b].in++;\n\t}\n\tf(i, 200){\n\t\tif (A[i].out.size()>A[i].in) fail = 1;\n\t\tf(j, A[i].in-int(A[i].out.size())) A[i].out.push_back(200);\n\t}\n\tF(i, 200){\n\t\tif (A[i+200].out.size()<A[i+200].in) fail = 1;\n\t\tf(j, int(A[i+200].out.size())-A[i+200].in) A[200].out.push_back(i+200);\n\t}\n\t\n\tvisit(200);\n\tf(i, 401) if (A[i].out.size()>0 && !A[i].vis) fail = 1;\n\tcout<<(fail? \"NO\" : \"YES\")<<endl;\n\t\n\t/*Printing edges, debug\n\tf(i, 401){\n\t\tfor (auto x:A[i].out){\n\t\t\tcout<<i<<\" \"<<A[x].id<<endl;\n\t\t}\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int N=1e5+10;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint n,h,in[500],out[500];\nvector<int> E[500];\nbool vis[500],fl=0;\nvoid dfs(int u) {\n    vis[u]=1;\n    if(in[u]!=out[u]) fl=1;\n    for(int v:E[u])\n        if(!vis[v]) dfs(v);\n}\nint main() {\n    n=gi(),h=gi();\n    for(int i=1;i<=n;i++) {\n        int a=gi(),b=gi(),c=gi(),d=gi(),l,r;\n        if(c==0) l=a; else l=-c;\n        if(d==0) r=-b; else r=d;\n        l+=h,r+=h;\n        E[l].pb(r),E[r].pb(l),++out[l],++in[r];\n    }\n    for(int i=0;i<=2*h;i++) {\n        if(i<h&&in[i]<out[i]) return puts(\"NO\"),0;\n        if(i>h&&in[i]>out[i]) return puts(\"NO\"),0;\n    }\n    for(int i=0;i<=2*h;i++)\n        if(i!=h&&!vis[i]&&in[i]+out[i]) {\n            fl=0,dfs(i);\n            if(!fl) return puts(\"NO\"),0;\n        }\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nconst int MaxN = 505;\n\nint n, h;\nint in[MaxN], out[MaxN], ok[MaxN], fa[MaxN];\n\nint Find(int x) { return x == fa[x] ? x : fa[x] = Find(fa[x]); }\n\nvoid Init()\n{\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 1; i <= (h << 1); ++i)\n\t\tfa[i] = i;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tint a, b, c, d, l, r;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tl = (c == 0) ? h + a : c;\n\t\tr = (d == 0) ? b : h + d;\n\t\t++out[l];\n\t\t++in[r];\n\t\tif (Find(l) != Find(r))\n\t\t\tfa[Find(l)] = Find(r);\n\t}\n}\t\n\nint Main()\n{\n\tfor (int i = 1; i <= h; ++i)\n\t\tif (out[i] > in[i])\n\t\t\treturn puts(\"NO\");\n\tfor (int i = h + 1; i <= (h << 1); ++i)\n\t\tif (in[i] > out[i])\n\t\t\treturn puts(\"NO\");\n\tfor (int i = 1; i <= (h << 1); ++i)\n\t\tif (in[i] != out[i])\n\t\t\tok[Find(i)] = true;\n\tfor (int i = 1; i <= (h << 1); ++i)\n\t\tif (Find(i) == i && !ok[i] && in[i] + out[i] != 0)\n\t\t\treturn puts(\"NO\");\n\treturn puts(\"YES\");\n}\n\nint main()\n{\n\tInit();\n\tMain();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\n#define A(a) ((a)<<1)\n#define B(a) ((a)<<1|1)\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nconst int MAXV = 200007;\nconst int MAXM = 2000007;\n\nstruct eT\n{\n\tvoid setd ( int _u, int _v, int _f, int _l )\n\t{\n\t\tu = _u, v = _v, f = _f, last = _l;\n\t}\n\n\tint u, v, f, last;\n}edge[MAXM];\n\nstruct bT\n{\n\tbT () {}\n\tbT ( int _h, int _l ) : h ( _h ), l ( _l ) {}\n\n\tvoid setd ( int _h, int _l )\n\t{\n\t\th = _h, l = _l;\n\t}\n\n\tbool operator < ( const bT &a ) const\n\t{\n\t\treturn ( h ^ a.h ) ? ( h < a.h ) : ( l < a.l );\n\t}\n\n\tbool operator == ( const bT &a ) const\n\t{\n\t\treturn ( h == a.h && l == a.l );\n\t}\n\n\tint h, l;\n}bl[MAXN], br[MAXN];\n\nint n, h, S, T;\nint ke, la[MAXV];\n\nint q[MAXV], lev[MAXV];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nvoid addedge ( int u, int v, int fu, int fv );\n\nint dinic ();\nbool bfs ();\nint dfs ( int now, int lim );\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\n\tscanf ( \"%d%d\", &n, &h );\n\tint a, b, c, d;\n\tlpi ( i, 1, n ){\n\t\tscanf ( \"%d%d%d%d\", &a, &b, &c, &d );\n\t\tbl[i].setd ( c, a ), br[i].setd ( d, b );\n\t}\n}\n\nvoid work ()\n{\n\t// main work\n\n\tbool flag;\n\tlpi ( i, 1, n ){\n\t\tflag = true;\n\t\tif ( !bl[i].h && br[i].h ){\n\t\t\tflag = false;\n\t\t\tlpi ( j, 1, n ){\n\t\t\t\tif ( !bl[j].h && bl[j].l == br[i].h && ( ! ( ( bl[i] == bl[j] ) && ( br[i].h == br[j].h ) ) ) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( bl[i].h && !br[i].h ){\n\t\t\tflag = false;\n\t\t\tlpi ( j, 1, n ){\n\t\t\t\tif ( !br[j].h && br[j].l == bl[i].h && ( ! ( ( bl[i].h == bl[j].h ) && ( br[i] == br[j] ) ) ) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( !flag ){\n\t\t\tprintf ( \"NO\\n\" );\n\t\t\treturn;\n\t\t}\n\t}\n\n\tS = MAXV - 1, T = MAXV - 2;\n\tint SS = MAXV - 3, TT = MAXV - 4;\n\tke = 0;\n\tINIT ( la, -1 );\n\n\tmap < bT, PII > ml, mr;\n\tmap < bT, PII > ::iterator it;\n\n\tAR( int ) keye;\n\tint ks = 0;\n\n\tlpi ( i, 1, n ){\n\t\t++ml[bl[i]].first;\n\t\t++mr[br[i]].first;\n\t}\n\n\tint kl = 0, kr = 0;\n\tfor ( auto &x : ml ) x.second.second = ++kl;\n\tfor ( auto &x : mr ) x.second.second = ++kr;\n\n//\tint cl = 0, cr = 0;\n\tfor ( auto x : ml ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, A( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( A( x.second.second ), TT, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = mr.find ( bT ( 0, x.first.h ) ) ) != mr.end () ){\n\t\t\t\taddedge ( B( it->second.second ), A( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n//\t\t\tcl += x.second.first;\n\t\t\taddedge ( A( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n\tfor ( auto x : mr ){\n\t\tif ( !x.first.h ){\n\t\t\taddedge ( S, B( x.second.second ), x.second.first, 0 );\n//\t\t\taddedge ( B( x.second.second ), SS, INF, 0 );\n\t\t} else{\n\t\t\tif ( ( it = ml.find ( bT ( 0, x.first.h ) ) ) != ml.end () ){\n\t\t\t\taddedge ( A ( it->second.second ), B( x.second.second ), INF, 0 );\n\t\t\t} else{\n\t\t\t\tprintf ( \"NO\\n\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkeye.push_back ( ke );\n\t\t\tks += x.second.first;\n//\t\t\tcr += x.second.first;\n\t\t\taddedge ( B( x.second.second ), T, x.second.first, 0 );\n\t\t}\n\t}\n\n//\taddedge ( SS, T, INF, 0 );\n//\taddedge ( TT, T, INF, 0 );\n\n/*\tif ( cl ^ cr ){\n\t\tprintf ( \"NO\\n\" );\n\t\treturn;\n\t}*/\n\n\tdinic ();\n\n\tflag = true;\n\tfor ( auto x : keye ){\n\t\tif ( edge[x].f ){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf ( flag ? \"YES\\n\" : \"NO\\n\" );\n}\n\n\n\nvoid addedge ( int u, int v, int fu, int fv )\n{\n\tedge[ke].setd ( u, v, fu, la[u] );\n\tla[u] = ke++;\n\tedge[ke].setd ( v, u, fv, la[v] );\n\tla[v] = ke++;\n}\n\nint dinic ()\n{\n\tint ans = 0;\n\twhile ( bfs () ) ans += dfs ( S, INF );\n\treturn ans;\n}\n\nbool bfs ()\n{\n\tint l = 0, r = 0, now, v;\n\tq[r++] = S;\n\tINIT ( lev, -1 );\n\tlev[S] = 1;\n\twhile ( l < r ){\n\t\tnow = q[l++];\n\t\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\t\tif ( edge[i].f && lev[v=edge[i].v] == -1 ){\n\t\t\t\tlev[v] = lev[now] + 1;\n\t\t\t\tq[r++] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ( lev[T] != -1 );\n}\n\nint dfs ( int now, int lim )\n{\n\tif ( now == T ) return lim;\n\n\tint v, nf = 0, tf;\n\tfor ( int i = la[now]; i ^ -1; i = edge[i].last ){\n\t\tif ( edge[i].f && lev[v=edge[i].v] == lev[now] + 1 ){\n\t\t\ttf = dfs ( v, qmin ( lim-nf, edge[i].f ) );\n\t\t\tnf += tf;\n\t\t\tedge[i].f -= tf, edge[i^1].f += tf;\n\n\t\t\tif ( nf == lim ) break;\n\t\t}\n\t}\n\n\tif ( !nf ) lev[now] = -1;\n\treturn nf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 409;\nint in[maxn], out[maxn], pa[maxn], flag[maxn];\nint n, H, a, b, c, d;\n\nint getpa(int x) {\n\treturn pa[x] == x ? x : pa[x] = getpa(pa[x]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &H);\n\tfor (int i=1; i<=2*H; i++) pa[i] = i;\n\tfor (int i=1; i<=n; i++) {\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tif (c) a = c + n; \n\t\tif (!d) b = b + n; else b = d;\n\t\tout[a]++; in[b]++;\n\t\tpa[getpa(a)] = getpa(b);\n\t}\n\t//for (int i=1; i<=2*H; i++) printf(\"%d %d %d\\n\", i, in[i], out[i]);\n\tfor (int i=1; i<=H; i++)\n\t\tif (out[i] < in[i]) { puts(\"NO\"); return 0; }\n\tfor (int i=H+1; i<=2*H; i++)\n\t\tif (in[i] < out[i]) { puts(\"NO\"); return 0; }\n\tfor (int i=1; i<=2*H; i++)\n\t\tif (in[i] != out[i]) flag[getpa(i)] = 1;\n\tfor (int i=1; i<=2*H; i++)\n\t\tif (pa[i] == i && !flag[i] && in[i] && out[i]) { puts(\"NO\"); return 0; }\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing std::vector;\n\n#define MAXN 100005\n#define MAXH 405\nint indeg[MAXH],outdeg[MAXH];\nbool vis[MAXH];\nvector<int> G[MAXH];\n\nvoid add_edge(int u,int v)\n{\n    outdeg[u]++;indeg[v]++;\n    G[u].push_back(v);G[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    bool f=indeg[v]!=outdeg[v];\n    vis[v]=true;\n    for(auto to:G[v])\n    {\n        if(!vis[to]) \n            f|=dfs(to);\n    }\n    return f;\n}\n\nint main()\n{\n    int N,H;\n    int a[MAXN],b[MAXN],c[MAXN],d[MAXN];\n    scanf(\"%d%d\",&N,&H);\n    for(int i=1;i<=N;i++) \n    {\n        scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n        int l,r;\n        l= ( c[i]==0 ? a[i] : -c[i] );\n        r= ( d[i]==0 ? -b[i] : d[i] );\n        add_edge(l+H,r+H);\n    }\n\n    bool flag=true;\n    for(int i=0;flag && i<=H;i++) \n    {\n        if(outdeg[i]>indeg[i]) \n            flag=false;\n    }\n    for(int i=H+1;flag && i<=2*H;i++)\n    {\n        if(indeg[i]>outdeg[i]) \n             flag=false;\n    }\n\n    memset(vis,false,sizeof(vis));\n    for(int i=0;flag && i<=2*H;i++)\n    {\n        if((indeg[i]||outdeg[i])&&!vis[i]) \n            flag &=dfs(i);\n    }\n\n    if(flag) \n    {\n        printf(\"YES\\n\"); \n    }\n    else\n    { \n        printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=400005;\nint fa[maxn],rd[maxn],n,h,m=400,active[maxn],get[maxn];\ninline int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tread(n);read(h);\n\trep(i,1,m)fa[i]=i;\n\trep(i,1,n){\n\t\tint a,b,c,d,p,q;read(a);read(b);read(c);read(d);\n\t\tp=c?-c:a;\n\t\tq=d?d:-b;\n\t\tp+=200;q+=200;\n\t\t// printf(\"%d %d\\n\",p,q);\n\t\trd[p]++;rd[q]--;\n\t\tfa[find(p)]=find(q);\n\t\tactive[p]=active[q]=1;\n\t}\n\trep(i,1,200)if(rd[i]>0){\n\t\tputs(\"NO\");return 0;\n\t}\n\trep(i,200,m)if(rd[i]<0){\n\t\tputs(\"NO\");return 0;\n\t}\n\trep(i,1,m)if(rd[i])get[find(i)]=1;\n\trep(i,1,m)if(i==find(i)&&active[i]&&!get[i]){\n\t\tputs(\"NO\");return 0;\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint main()\n{\nputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nvector<int>G[405];\nint in[405];\nint a[100005], b[100005], c[100005], d[100005];\nint vst[405];\nvoid dfs(int now) {\n\tfor(int e:G[now]) {\n\t\tif (vst[e])continue;\n\t\tvst[e] = 1;\n\t\tdfs(e);\n\t}\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\trep(i, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tint x, y;\n\t\tif (c[i] == 0)x = a[i];\n\t\telse x = c[i] + h;\n\t\tif (d[i] == 0)y = b[i] + h;\n\t\telse y = d[i];\n\t\tG[x].push_back(y);\n\t\tin[y]++;\n\t}\n\tint cnt = 0;\n\trep(i, h + 1) {\n\t\tint z = G[i].size();\n\t\tif (z-in[i]==1) {\n\t\t\tcnt++;\n\t\t\tG[0].push_back(i);\n\t\t\tin[i]++;\n\t\t}\n\t\telse if (z != in[i]) {\n\t\t\tputs(\"NO\"); return 0;\n\t\t}\n\t}\n\tfor (int i = h + 1; i <= 2 * h; i++) {\n\t\tint z = G[i].size();\n\t\tif (in[i]-z==1) {\n\t\t\tcnt--;\n\t\t\tG[i].push_back(0);\n\t\t\tin[0]++;\n\t\t}\n\t\telse if (z != in[i]) {\n\t\t\tputs(\"NO\"); return 0;\n\t\t}\n\t}\n\tif (cnt!=0) {\n\t\tputs(\"NO\");\n\t}\n\telse {\n\t\tvst[0] = 1;\n\t\tdfs(0);\n\t\trep(i, 2 * h + 1) {\n\t\t\tif (vst[i] == 0 && (in[i]||G[i].size())) {\n\t\t\t\tputs(\"NO\"); return 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(\"YES\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int INF=0x7f7f7f7f;\nnamespace G{\n\tconst int N=210*2,E=100000*2+N*2;\n\tint to[E],bro[E],cap[E],head[N],e=0;\n\tint indeg[N],oudeg[N];\n\tint bln[N],dfn[N],low[N],tim=0;\n\tint stk[N],ss=0;\n\tbool instk[N];\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t\tmemset(bln,-1,sizeof(bln));\n\t\tmemset(dfn,0,sizeof(dfn));\n\t\tmemset(instk,0,sizeof(instk));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t\toudeg[u]++,indeg[v]++;\n\t}\n\tvoid tarjan(int x){\n\t\tdfn[x]=low[x]=++tim;\n\t\tstk[ss++]=x,instk[x]=true;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif(dfn[v=to[i]]){\n\t\t\t\tif(instk[v]){\n\t\t\t\t\tapmin(low[x],dfn[v]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttarjan(v);\n\t\t\t\tapmin(low[x],low[v]);\n\t\t\t}\n\t\t}\n\t\tif(dfn[x]==low[x]){\n\t\t\tfor(int v;v=stk[--ss],instk[v]=false,bln[v]=x,v!=x;);\n\t\t}\n\t}\n}\ninline bool Main(){\n\tusing namespace G;\n\tint n=ni,h=ni;\n\tinit();\n\tfor(int i=1,j=h+1;i<=h;i++,j++){\n\t\tae(0,i),ae(j,0);\n\t\tindeg[i]=oudeg[j]=0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint a=ni,b=ni,c=ni,d=ni;\n\t\tae(c?c+h:a,d?d:b+h);\n\t}\n\ttarjan(0);\n\tint cntin=0,cntou=0;\n\tfor(int i=1,j=h+1;i<=h;i++,j++){\n\t\tif(bln[i]&&(indeg[i]||oudeg[i]))return false;\n\t\tif(bln[j]&&(indeg[j]||oudeg[j]))return false;\n\t\tif(indeg[i]>oudeg[i])return false;\n\t\tif(indeg[j]<oudeg[j])return false;\n\t\tcntin+=oudeg[i]-indeg[i];\n\t\tcntou+=indeg[j]-oudeg[j];\n\t}\n\treturn cntin==cntou;\n}\nint main(){\n\tputs(Main()?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <typename T> inline void rd(T& x) {\n\tint si = 1; char c = getchar(); x = 0;\n\twhile(!isdigit(c)) si = c == '-' ? -1 : si, c = getchar();\n\twhile(isdigit(c)) x = x * 10 + c - 48, c = getchar();\n\tx *= si;\n}\ntemplate <typename T, typename... Args>\ninline void rd(T& x, Args&... args) { rd(x); rd(args...); }\n#define fi first\n#define se second\n#define mkp std::make_pair\ntypedef long long ll;\ntypedef double ff;\ntypedef std::pair <int, int> pii;\nconst int kN = 4e5 + 5, kInf = 0x3f3f3f3f;\nconst ll kMod = 998244353, kInfLL = 0x3f3f3f3f3f3f3f3fLL;\n\nint n, H, cnt1, cntn1, dg[kN]; bool flag = true;\nvoid Add(int u, int v) { ++dg[u]; --dg[v]; }\n\nint main() {\n\tint T = 1; //rd(T);\n\twhile(T--) {\n\t\trd(n, H);\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tint A, B, C, D, d1, d2, d3; rd(A, B, C, D);\n\t\t\td1 = C ? H + C : A; d2 = D ? 3 * H + D : 2 * H + B;\n\t\t\td3 = D ? D : H + B;\n\t\t//\tprintf(\"A: (%d %d)\\n\", d1, d2);\n\t\t//\tprintf(\"B: (%d %d)\\n\", d2, d3);\n\t\t\tAdd(d1, d2); Add(d2, d3);\n\t\t}\n\t\tfor(int i = 1; i <= 4 * H; ++i) {\n\t\t//\tprintf(\"%d \", dg[i]);\n\t\t\tif(dg[i] > 1 || dg[i] < -1) {\n\t\t\t\tflag = false; break;\n\t\t\t} else if(dg[i] == 1) ++cnt1;\n\t\t\telse if(dg[i] == -1) ++cntn1;\n\t\t}\n\t\t//printf(\"\\n\");\n\t\tif(!flag || cnt1 > 1 || cntn1 > 1) printf(\"NO\\n\");\n\t\telse printf(\"YES\\n\");\n\t} return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\nconst int N = 2e5 + 10, H = 505;\nint n, h, deg[N];\nbool ff, tag, vis[N], mark[N];\nvector<int> nxt[N];\n\nvoid add(int x, int y) {\n    x += H, y += H;\n    mark[x] = mark[y] = 1;\n    nxt[x].push_back(y);\n    ++deg[y], --deg[x];\n}\n\nvoid dfs(int x) {\n    if ((x > H && deg[x] > 0) || (x < H && deg[x] < 0)) {\n        ff = 1; return;\n    }\n    if (deg[x]) tag = 1;\n    vis[x] = 1;\n    for (int i = 0; i < nxt[x].size(); i++) {\n        int y = nxt[x][i];\n        if (vis[y]) continue;\n        dfs(y);\n    }\n}\n\nint main() {\n    cin >> n >> h;\n    rep(i, 1, n) {\n        int a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        add(c ? -c : a, d ? d : -b);\n    }\n    rep(i, 1, H << 1) if (mark[i] && !vis[i]) {\n        ff = tag = 0;\n        dfs(i);\n        if (ff || !tag) return puts(\"NO\"), 0;\n    }\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst llint mod=1000000007;\nconst llint big=1e17-10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint main(void){\n\tint n,h,i,j;cin>>n>>h;\n\tint Lsit[201]={0};//左が下にくっついている\n\tint Rsit[201]={0};//右が\n\tfor(i=0;i<n;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tif(c==0){Lsit[a]++;}else{Rsit[c]--;}\n\t\tif(d==0){Rsit[b]++;}else{Lsit[d]--;}\n\t}\n\tint gen=0;\n\tfor(i=1;i<201;i++){gen+=Rsit[i];if(Rsit[i]<0){cout<<\"NO\"<<endl;return 0;}}\n\tif(gen==0){cout<<\"NO\"<<endl;return 0;}\n\tgen=0;\n\tfor(i=1;i<201;i++){gen+=Lsit[i];if(Lsit[i]<0){cout<<\"NO\"<<endl;return 0;}}\n\tif(gen==0){cout<<\"NO\"<<endl;return 0;}\n\tcout<<\"YES\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nconst int N = 4e2 + 100;\nint f[N];\nint ff(int x) {\n\treturn f[x] == x ? x : f[x] = ff(f[x]);\n}\nint n, h;\nint in[N], ou[N], ok[N];\n\nint main() {\n\tscanf(\"%d%d\", &n, &h);\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tf[i] = i;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d, l, r;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tl = c == 0 ? h + a : c;\n\t\tr = d == 0 ? b : h + d;\n\t\t++ou[l], ++in[r];\n\t\tif (ff(l) != ff(r))\n\t\t\tf[ff(l)] = ff(r);\n\t}\n\tfor (int i = 1; i <= h; ++i)\n\t\tif (ou[i] < in[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = h + 1; i <= h + h; ++i)\n\t\tif (in[i] < ou[i])\n\t\t\treturn puts(\"NO\"), 0;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (in[i] != ou[i])\n\t\t\tok[ff(i)] = true;\n\tfor (int i = 1; i <= h + h; ++i)\n\t\tif (ff(i) == i && !ok[i] && in[i] + ou[i] != 0)\n\t\t\treturn puts(\"NO\"), 0;\n\treturn puts(\"YES\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<b;++i)\n#define fj(a,b) for(int j=a;j<b;++j)\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> pii;\n////////////////////\n\nint const N = 1e5 + 41;\nint const H = 241;\n\nint n, h, a[N], b[N], c[N], d[N];\nint d0[H][2], d1[H][2];\n\nvector<pii> e[H][2];\n\npii getfrom(int a, int c){\n\tif(c > 0) return mp(c, 0);\n\telse return mp(a, 1);\n}\n\npii getto(int b, int d){\n\tif(d > 0) return mp(d, 1);\n\telse return mp(b, 0);\n}\n\nbool dfs(pii x){\n\tbool res;\n\tif(sz(e[x.first][x.second])){\n\t\tpii y = e[x.first][x.second].back();\n\t\te[x.first][x.second].pop_back();\n\t\tres = dfs(y);\n\t}else{\n\t\tres = (x.second == 0 ? 1 : 0);\n\t}\n\treturn res;\n}\n\nvoid solve(){\n\tfi(0, n){\n\t\tpii x = getfrom(a[i], c[i]);\n\t\tpii y = getto(b[i], d[i]);\n\t\te[x.first][x.second].pb(y);\n\t\t++d0[x.first][x.second];\n\t\t++d1[y.first][y.second];\n\t}\n\tbool ok = true;\n\tfi(1, h+1){\n\t\tint k = d0[i][1] - d1[i][1];\n\t\tif(k < 0) ok = false;\n\t\tfj(0, k){\n\t\t\tok &= dfs(mp(i, 1));\n\t\t}\n\t}\n\tfi(1, h+1) fj(0, 2){\n\t\tok &= (sz(e[i][j]) == 0);\n\t}\n\tif(ok) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\t\n\tscanf(\"%d %d\",&n,&h);\n\tfi(0, n) scanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<20;\nint fa[Q];\nint in[Q],out[Q];\nint gf(int x)\n{return fa[x]==x?x:(fa[x]=gf(fa[x]));}\nvoid ins(int x,int y)\n{\n    out[x]++;\n    in[y]++;\n    int fx=gf(x),fy=gf(y);\n    if(fx!=fy)fa[fx]=fy;\n}\n// int Idiot_Sap(int x,int flow)\n// {\n//     if(x==T)return flow;\n//     int had=0;\n//     for(int t=las[x];t;t=nn[t]){\n//         int y=e[t];\n//         if((!c[t])||dis[x]-1!=dis[y])continue;\n//         int del=Idiot_Sap(y,min(c[t],flow-had));\n//         c[t]-=del;\n//         c[t^1]+=del;\n//         had+=del;\n//         if(dis[S]>=T||had==flow)return had;\n//     }\n//     if(dis[S]>=T)return had;\n//     --cnt[dis[x]];\n//     if(!cnt[dis[x]])dis[S]=T;\n//     cnt[++dis[x]]++;\n//     return had;\n// }\nint had[Q];\nint main()\n{\n    int n,h;\n    cin>>n>>h;\n    h+=5;\n    for(int i=1,a,b,c,d;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        int x,y;\n        if(c==0)x=a+h;\n        else x=c;\n        if(d==0)y=b;\n        else y=d+h;\n        // printf(\"%d %d LINK\\n\",x,y);\n        ins(x,y);\n    }\n    for(int i=1;i<=h;i++)if(out[i]>in[i])return puts(\"NO\")&0;\n    for(int i=h+1;i<=h+h;i++)if(out[i]<in[i])return puts(\"NO\")&0;\n    for(int i=1;i<=h+h;i++)if(in[i]!=out[i])had[gf(i)]=1;\n    for(int i=1;i<=h+h;i++)if(in[i]&&out[i]&&(!had[gf(i)]))return puts(\"NO\")&0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\nconst int N = 4e5 + 10, H = 505;\nint n, h, deg[N];\nbool tag, vis[N], mark[N];\nvector<int> nxt[N];\n\nvoid add(int x, int y) {\n    x += H, y += H;\n    mark[x] = mark[y] = 1;\n    nxt[x].push_back(y);\n    nxt[y].push_back(x);\n    ++deg[y], --deg[x];\n}\n\nbool dfs(int x) {\n    if ((x >= H && deg[x] > 0) || (x < H && deg[x] < 0)) return 0;\n    vis[x] = 1;\n    if (deg[x]) tag = 1;\n    for (int i = 0; i < nxt[x].size(); i++) {\n        int y = nxt[x][i];\n        if (!vis[y]) if (!dfs(y)) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    cin >> n >> h;\n    rep(i, 1, n) {\n        int a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        add(c ? -c : a, d ? d : -b);\n    }\n    rep(i, 1, H << 1) if (mark[i] && !vis[i]) {\n        tag = 0;\n        if (!dfs(i) || !tag) return puts(\"NO\"), 0;\n    }\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<20;\nint fa[Q];\nint in[Q],out[Q];\nint gf(int x)\n{return fa[x]==x?x:(fa[x]=gf(fa[x]));}\nvoid ins(int x,int y)\n{\n    out[x]++;\n    in[y]++;\n    int fx=gf(x),fy=gf(y);\n    if(fx!=fy)fa[fx]=fy;\n}\n// int Idiot_Sap(int x,int flow)\n// {\n//     if(x==T)return flow;\n//     int had=0;\n//     for(int t=las[x];t;t=nn[t]){\n//         int y=e[t];\n//         if((!c[t])||dis[x]-1!=dis[y])continue;\n//         int del=Idiot_Sap(y,min(c[t],flow-had));\n//         c[t]-=del;\n//         c[t^1]+=del;\n//         had+=del;\n//         if(dis[S]>=T||had==flow)return had;\n//     }\n//     if(dis[S]>=T)return had;\n//     --cnt[dis[x]];\n//     if(!cnt[dis[x]])dis[S]=T;\n//     cnt[++dis[x]]++;\n//     return had;\n// }\nint had[Q];\nint main()\n{\n    int n,h;\n    cin>>n>>h;\n    h+=5;\n    for(int i=1,a,b,c,d;i<=n;i++){\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        ++a,++b,++c,++d;\n        int x,y;\n        if(c==1)x=a+h;\n        else x=c;\n        if(d==1)y=b;\n        else y=d+h;\n        // printf(\"%d %d LINK\\n\",x,y);\n        ins(x,y);\n    }\n    for(int i=1;i<=h;i++)if(out[i]>in[i])return puts(\"NO\")&0;\n    for(int i=h+1;i<=h+h;i++)if(out[i]<in[i])return puts(\"NO\")&0;\n    for(int i=1;i<=h+h;i++)if(in[i]!=out[i])had[gf(i)]=1;\n    for(int i=1;i<=h+h;i++)if(in[i]&&out[i]&&(!had[gf(i)]))return puts(\"NO\")&0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n// #include <bits/extc++.h>\nusing namespace std;\n\n#define debug(s) cout << #s << \" = \" << s << endl\n#define all(v) (v).begin(), (v).end()\n#define KeepUnique(v) (v).erase( unique(all(v)), v.end() )\n#define MEMSET(a, val) memset(a, val, sizeof (a))\n#define PB push_back\n#define endl '\\n'\ntypedef long long ll;\n\ninline int myrand(int l, int r) {\n\tint ret = rand(); ret <<= 15; ret ^= rand();\n\tif(ret < 0) ret = -ret; ret %= (r-l+1); ret += l;\n\treturn ret;\n}\n\ntemplate <typename F, typename S>\nostream& operator << (ostream& os, const pair< F, S>& p) {\n\treturn os<<\"(\" <<p.first<<\", \"<<p.second<<\")\"; }\n\ntypedef pair<int, int> ii;\n\ntemplate<typename T> using min_pq =\n\tstd::priority_queue<T, vector<T>, greater<T> >;\n\n//int dx[] = {-1, +0, +1, +0};\n//int dy[] = {+0, +1, +0, -1};\n\nconst int maxn = 100005;\n\nint n;\nvector<int> g[maxn];\nint grundy[maxn], ok[maxn];\n\nvoid dfs(int u, int par) {\n\tfor(int v : g[u]) {\n\t\tif(v - par) {\n\t\t\tdfs(v, u);\n\t\t}\n\t}\n\tfor(int v : g[u])\n\t\tif(v - par) ok[grundy[v]] = 1;\n\tfor(int i = 0; ; i++) {\n\t\tif(!ok[i]) {\n\t\t\tgrundy[u] = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int v : g[u])\n\t\tif(v - par) ok[grundy[v]] = 0;\n}\n\nint32_t main () {\n    srand(time(NULL));\n    puts(rand() % 2 == 0 ? \"YES\" : \"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=500;\n\nint n,h,F;\nint fa[N],ok[N],ou[N],into[N];\n\ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+ch-48;\n\treturn o;\n}\n\ninline int gf(int o)\n{return fa[o]==o?o:fa[o]=gf(fa[o]);}\n\nint main()\n{\n\tcin>>n>>h;\n\tint a,b,c,d,F=h;\n\tfo(i,1,n){\n\t\ta=read(),b=read(),c=read(),d=read();\n\t\tint zb=0,yb=0; \n\t\tif(c)zb=c+F;else zb=a;\n\t\tif(d)yb=d;else yb=b+F;\n\t\t++ou[zb]; ++into[yb];\n\t\tfa[gf(yb)]=gf(zb);\n\t}\n\tfo(i,1,(h<<1))if(into[i]!=ou[i])ok[i]=1;\n\tfo(i,1,h)if(into[i]>ou[i]){\n\t\tputs(\"NO\"); return 0;\n\t}\n\tfo(i,h+1,h<<1)if(into[i]<ou[i]){\n\t\tputs(\"NO\"); return 0;\n\t}\n\tfo(i,1,h<<1)ok[gf(i)]|=ok[i];\n\tfo(i,1,h<<1)if((into[i]||ou[i])&&!ok[i]&&fa[i]==i){\n\t\tputs(\"NO\"); return 0;\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint f[810];\nint v[810];\nint e[810];\nint deg[810];\nint find(int x)\n{\n\treturn f[x]==x?x:f[x]=find(f[x]);\n}\nint main()\n{\n\tint n,h;\n\tscanf(\"%d%d\",&n,&h);\n\tint i;\n\tfor(i=1;i<=800;i++)\n\t\tf[i]=i;\n\tint a,b,c,d,l,r;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(c)\n\t\t\tl=-c;\n\t\telse\n\t\t\tl=a;\n\t\tif(d)\n\t\t\tr=d;\n\t\telse\n\t\t\tr=-b;\n\t\tl+=400;\n\t\tr+=400;\n\t\tdeg[l]++;\n\t\tdeg[r]--;\n\t\tv[l]=v[r]=1;\n\t\tf[find(r)]=find(l);\n\t}\n\tfor(i=1;i<=400;i++)\n\t\tif(deg[i]>0)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=401;i<=800;i++)\n\t\tif(deg[i]<0)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=1;i<=800;i++)\n\t\tif(deg[i])\n\t\t\te[find(i)]=1;\n\tfor(i=1;i<=800;i++)\n\t\tv[find(i)]|=v[i];\n\tfor(i=1;i<=800;i++)\n\t\tif(i==find(i)&&v[i]&&!e[i])\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, H;\nint A[100000];\nint B[100000];\nint C[100000];\nint D[100000];\nint deg[100000];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> H;\n  const int V = 2*H+1;\n  int g = 0;\n  rep(i, N) {\n    cin >> A[i] >> B[i] >> C[i] >> D[i];\n    if (C[i]==0&&D[i]==0) g++;\n    if (C[i]>0&&D[i]>0) g--;\n    int u = ((C[i]==0)? +A[i] : -C[i]);\n    int v = ((D[i]==0)? -B[i] : +D[i]);\n    u += H;\n    v += H;\n    deg[u]++;\n    deg[v]--;\n  }\n  if (g <= 0) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  //rep(i, V) cout<<deg[i]<<\",\";cout<<\"\\n\";\n  int s = 0;\n  rep(i, V) if (deg[i] > 0) s += deg[i];\n  if (s <= g) {\n    cout << \"YES\\n\";\n  }\n  else {\n    cout << \"NO\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=500;\n\nint n,h;\nint fa[N],ok[N],ou[N],into[N];\n\ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+ch-48;\n\treturn o;\n}\n\ninline int gf(int o)\n{return fa[o]==o?o:fa[o]=gf(fa[o]);}\n\nint main()\n{\n\tcin>>n>>h;\n\tint a,b,c,d;\n\tfo(i,1,h<<1)fa[i]=i;\n\tfo(i,1,n){\n\t\ta=read(),b=read(),c=read(),d=read();\n\t\tint zb=0,yb=0; \n\t\tif(c)zb=c+h;else zb=a;\n\t\tif(d)yb=d;else yb=b+h;\n\t\t++ou[zb]; ++into[yb];\n\t\tfa[gf(yb)]=gf(zb);\n\t}\n\tfo(i,1,(h<<1))if(into[i]!=ou[i])ok[i]=1;\n\tfo(i,1,h)if(into[i]>ou[i]){\n\t\tputs(\"NO\"); return 0;\n\t}\n\tfo(i,h+1,h<<1)if(into[i]<ou[i]){\n\t\tputs(\"NO\"); return 0;\n\t}\n\tfo(i,1,h<<1)ok[gf(i)]|=ok[i];\n\tfo(i,1,h<<1)if((into[i]||ou[i])&&!ok[i]&&fa[i]==i){\n\t\tputs(\"NO\"); return 0;\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef long long ll;\n#define N 200002\nstruct edge{int to,nxxt;}e[N<<1];\nint n,H,a[N][4],head[N],cnt=1,b[N][2],f[N],rd[N],cd[N],ct[N];\nvector<int>v[N];\ninline void ins(int u,int v){e[cnt].to=v;e[cnt].nxxt=head[u];head[u]=cnt++;}\nint getroot(int t){return f[t]==-1?t:f[t]=getroot(f[t]);}\nint main()\n{\n    scanf(\"%d%d\",&n,&H);\n    memset(f,-1,sizeof(f));\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d%d%d\",&a[i][0],&a[i][1],&a[i][2],&a[i][3]);\n        int x,y;\n        if(a[i][2]==0)x=a[i][0];else x=H+a[i][2];\n        if(a[i][3]==0)y=H+a[i][1];else y=a[i][3];\n        b[i][0]=x,b[i][1]=y;\n        if(x==y)ct[x]++;\n        ins(x,y),rd[y]++,cd[x]++;\n        x=getroot(x);y=getroot(y);\n        if(x^y)f[x]=y;\n    }\n    for(int i=1;i<=2*H;i++)v[getroot(i)].push_back(i);\n    //for(int i=1;i<=2*H;i++)printf(\"%d \",getroot(i));puts(\"rt\");\n    //for(int i=1;i<=2*H;i++)printf(\"%d \",cd[i]);puts(\"cd\");\n    //for(int i=1;i<=2*H;i++)printf(\"%d \",rd[i]);puts(\"rd\");\n    for(int i=1;i<=2*H;i++)\n    {\n        bool flag=false;\n        if(v[i].size()==1){if(ct[v[i][0]]){puts(\"NO\");return 0;}}\n        if(v[i].size()<=1)continue;\n        //printf(\"%d:\",i);\n        for(int j=0;j<v[i].size();j++)\n        {\n            int x=v[i][j];\n            if(rd[x]^cd[x]){flag=true;break;}\n        }//puts(\"\");\n        if(!flag){puts(\"NO\");return 0;}\n    }\n    bool flag=true;\n    for(int i=1;i<=H;i++)\n    {\n        if(cd[i]<rd[i]){flag=false;break;}\n    }\n    for(int i=H+1;i<=2*H;i++)\n    {\n        if(rd[i]<cd[i]){flag=false;break;}\n    }\n    if(flag)puts(\"YES\");else puts(\"NO\");\n}\n/*\n3 4\n1 1 0 0\n2 2 0 1\n3 3 1 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UF {\n  vector<int> ps;\npublic:\n  void init(int n) {\n    ps.resize(n);\n    for (int i = 0; i < n; ++i) {\n      ps[i] = i;\n    }\n  }\n  int root(int i) {\n    if (ps[i] == i) return i;\n    return ps[i] = root(ps[i]);\n  }\n  bool same(int i, int j) {\n    return root(i) == root(j);\n  }\n  void unite(int i, int j) {\n    if (i == j) return;\n    int ri = root(i);\n    int rj = root(j);\n    ps[ri] = rj;\n  }\n};\n\nint n, h;\nint deg[403];\nbool iso[403];\nUF uf;\nbool sub() {\n  for (int i = 0; i < 2 * h; ++i) {\n    if (i < h && deg[i] < 0) return false;\n    if (i >= h && deg[i] > 0) return false;\n  }\n  \n  vector<vector<int>> gs(2 * h);\n  for (int i = 0; i < 2 * h; ++i) {\n    gs[uf.root(i)].push_back(i);\n  }\n  \n  for (auto&& g : gs) {\n    if (g.empty() || iso[g[0]]) continue;\n    int sum = 0;\n    bool ok = false;\n    for (int i : g) {\n      sum += deg[i];\n      if (deg[i] != 0) ok = true;\n    }\n    if (!ok || sum != 0) return false;\n  }\n  return true;\n}\n\nint main() {\n  cin >> n >> h;\n  ++h;\n  uf.init(2 * h);\n  \n  for (int i = 0; i < 2 * h; ++i) {\n    iso[i] = true;\n  }\n  \n  for (int i = 0; i < n; ++i) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    \n    int x = c == 0 ? a : c + h;\n    int y = d == 0 ? b + h : d;\n    ++deg[x];\n    --deg[y];\n    iso[x] = false;\n    iso[y] = false;\n    uf.unite(x, y);\n  }\n  \n  cout << (sub() ? \"YES\" : \"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconst int maxn = 200+7;\n\nint n, h, a, b, c, d;\nint left[maxn], right[maxn];\n\nint main(int argc, char *argv[]) {  \n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0); \n\tstd::fill(left, left+maxn, 0);\n\tstd::fill(right, right+maxn, 0);\n\tstd::cin >> n >> h;\n\tint tot1 = 0, tot2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> a >> b >> c >> d;\n\t\tif (c == 0) {\n\t\t\tleft[a]++;\n\t\t\ttot1++;\n\t\t} else {\n\t\t\tright[c]--;\n\t\t\ttot2++;\n\t\t}\n\t\tif (d == 0) {\n\t\t\tright[b]++;\n\t\t\ttot1++;\n\t\t} else {\n\t\t\tleft[d]--;\n\t\t\ttot2++;\n\t\t}\n\t}\n\tint block = tot1-tot2;\n\tbool yes = 1;\n\tint cnt1 = 0, cnt2 = 0;\n\tfor (int i = 1; i <= h; i++) {\n\t\tif (right[i] < 0 || left[i] < 0) {\n\t\t\tyes = 0;\n\t\t}\n//\t\tstd::cout << left[i] << ' ' << right[i] << '\\n';\n\t\tcnt1 += left[i];\n\t\tcnt2 += right[i];\n\t}\n//\tstd::cout << cnt << '\\n';\n\tif (yes && block > 0 && cnt1+cnt2 == block && cnt1 == cnt2) {\n\t\tstd::cout << \"YES\\n\";\n\t} else {\n\t\tstd::cout << \"NO\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing db = double;\n#define pb push_back\n\n#define ass(x) ({if(!(x)) return false;})\n\nconst int mxn = 206;\n\nint n, h;\nunordered_map<int,int> deg;\nunordered_map<int,bool> v;\n\nstruct DSU {\n\tunordered_map<int,int> p;\n\tvoid clear() {\n\t\tfor (int i = -200; i <= 200; ++i)\n\t\t\tp[i] = i;\n\t}\n\tint root(int x) {\n\t\treturn p[x] == x ? x : p[x] = root(p[x]);\n\t}\n\tvoid merge(int x, int y) {\n\t\tp[root(x)] = root(y);\n\t}\n\tint operator[](int x) { return root(x); }\n} U;\n\nunordered_map<int,int> f;\n\nbool connected() {\n\tfor (int i = -200; i <= 200; ++i)\n\t\tf[U[i]] |= i < 0 ? 1 : i > 0 ? 2 : 0;\n\tfor (int i = -200; i <= 200; ++i) if (v[i])\n\t\tass(f[U[i]] == 3);\n\treturn true;\n}\n\nbool check() {\n\tfor (int i = -200; i <= 200; ++i)\n\t\tass(deg[i] * i >= 0);\n\treturn true;\n}\n\nint main() {\n\tcin >> n >> h;\n\t\n\tU.clear();\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x, y;\n\t\tx = c ? -c : a;\n\t\ty = d ? -d : b;\n\t\ty = -y;\n\t\t++deg[x];\n\t\t--deg[y];\n\t\tv[x] = v[y] = true;\n\t\tU.merge(x, y);\n\t}\n\t\n\tputs(check() && connected() ? \"YES\" : \"NO\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<ctime>\n#include<vector>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<memory.h>\n#include<map>\n#include<ctime>\n#include<algorithm>\n#include<ctime>\n#define ll int\n#define For(i,j,k)  for(ll i=j;i<=k;++i)\n#define FOr(i,j,k)  for(ll i=j;i>=k;--i)\n#define ld double\nusing namespace std;\ninline ll read(){   ll x=0,f=1;char ch=getchar();   while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}  while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}  return x*f; }\ninline void wrote(ll x){    if (x<0) putchar('-'),x=-x; if (x>=10) wrote(x/10);   putchar(x%10+'0');  }\ninline void writeln(ll x){ wrote(x);   puts(\"\");   }\nconst ll N=1010;\nll n,h,ans,fa[N],C[N],D[N],vis[N];\nll find(ll x){\treturn x==fa[x]?x:fa[x]=find(fa[x]);\t}\nint main(){\n\tn=read();\tread();\n\tFor(i,1,1000)\tfa[i]=i;\n\tFor(i,1,n){\n\t\tll a=read(),b=read(),c=read(),d=read();\n\t\ta=c?-c:a;\tb=d?d:-b;\ta+=500;\tb+=500;\n\t\tfa[find(a)]=find(b);\n\t\tD[a]++;\tD[b]--;\tvis[a]=1;\n\t}\n\tbool fl=1;\n\tFor(i,1,499)\tfl&=D[i]<=0;\n\tFor(i,501,1000)\tfl&=D[i]>=0;\n\tFor(i,1,1000)\tvis[find(i)]|=vis[i];\n\tFor(i,1,1000)\tif (D[i])\tC[find(i)]=1;\n\tFor(i,1,1000)\tfl&=(fa[i]!=i)||C[i]||!vis[i];\n\tputs(fl?\"YES\":\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define neko 100010\n#define heko 410\n#define qwq return printf(\"YES\"),0; \n#define orz return printf(\"NO\"),0; \n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))\nstatic int n,H;\ntypedef int arr[heko];\narr fa,book,dgi,dgo,out;\nnamespace IO\n{\n\tconst unsigned int bufsize=1<<16,outsize=1<<24;\n\tstatic char ch[bufsize],*S=ch,*T=ch;\n\tinline char getc()\n\t{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\n\tstatic char Out[outsize],*nowp=Out;\n\tinline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\n\t\tvoid read(T &x)\n\t\t{\n\t\t\tchar c=getc();x=0;\n\t\t\tfor(;!isdigit(c);c=getc());\n\t\t\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n\t\t}\n\ttemplate<typename T>\n\t\tvoid write(T x,char c='\\n')\n\t\t{\n\t\t\tif(!x)*nowp++='0';\n\t\t\tstatic unsigned int stk[50],tp=0;\n\t\t\tfor(;x;x/=10)stk[++tp]=x%10;\n\t\t\tfor(;tp;*nowp++=stk[tp--]^'0');*nowp++=c;\n\t\t}\n}\nint find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}\nint main()\n{\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n\tusing namespace IO;\n\tint x,y,z,o,X,Y;\n\tread(n),read(H);\n\tf(i,0,400)fa[i]=i;\n\tf(i,1,n)\n\t{\n\t\tread(x),read(y),read(z),read(o);\n\t\tif(z==0)X=200+x;\n\t\telse X=200-z;\n\t\tif(o==0)Y=200-y;\n\t\telse Y=200+o;\n\t\tbook[X]=book[Y]=1;\n\t\t++dgi[Y],++dgo[X];\n\t\tfa[find(Y)]=find(X);\n\n\t}\n\tf(i,0,200)if(dgi[i]<dgo[i])orz;\n\tf(i,201,400)if(dgi[i]>dgo[i])orz;\n\tf(i,0,400)if(dgi[i]^dgo[i])out[fa[i]]=1;\n\tf(i,0,400)if(book[i]&&!out[fa[i]])orz;\n\tqwq;\n}"
  },
  {
    "language": "C++",
    "code": "// The previous one should get TLE... My carelessness T^T\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 100003;\nstatic const int MAXH = 209;\n\nstatic const int MAXV = MAXH * 2;\nstatic const int MAXE = 4e6 + 10;\n\nint n, h;\nint head[MAXV], dest[MAXE], next[MAXE];\nbool vis[MAXE] = { false };\n\nint m = 0;\nint in[MAXV] = { 0 }, out[MAXV] = { 0 };\n\ninline void add_edge(int u, int v)\n{\n    dest[m] = v; next[m] = head[u]; head[u] = m++;\n    ++out[u], ++in[v];\n}\n\nint cur[MAXV];\n\nvoid dfs_quq(int u)\n{\n    for (int w = head[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs_quq(dest[w]);\n    }\n}\nvoid dfs(int u)\n{\n    for (int &w = cur[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs(dest[w]);\n    }\n}\n\nstd::vector<int> as, bs;\nbool marked[MAXV] = { false };\n\nint main()\n{\n    scanf(\"%d%d\", &n, &h);\n\n    int verts = (h + 1) * 2;\n    for (int i = 0; i < verts; ++i) head[i] = -1;\n\n#define node_a(_h) ((_h) * 2)\n#define node_b(_h) ((_h) * 2 + 1)\n    for (int i = 0, a, b, c, d; i < n; ++i) {\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        int u, v;\n        u = (c == 0 ? node_b(a) : node_a(c));\n        v = (d == 0 ? node_a(b) : node_b(d));\n        add_edge(u, v);\n    }\n    for (int i = 0; i <= h; ++i) {\n        if (in[node_a(i)] < out[node_a(i)]) { puts(\"NO\"); return 0; }\n        if (in[node_b(i)] > out[node_b(i)]) { puts(\"NO\"); return 0; }\n        for (int r = 0; r < in[node_a(i)] - out[node_a(i)]; ++r) {\n            as.push_back(node_a(i));\n            marked[node_a(i)] = true;\n        }\n        for (int r = 0; r < out[node_b(i)] - in[node_b(i)]; ++r) {\n            bs.push_back(node_b(i));\n            marked[node_b(i)] = true;\n        }\n    }\n    for (int u : as) {\n        if (bs.empty()) { puts(\"NO\"); return 0; }\n        add_edge(u, bs.back());\n        bs.pop_back();\n    }\n\n    for (int i = 0; i < verts; ++i) cur[i] = head[i];\n    if (verts * m <= 4e8)\n        for (int i = 1; i < verts; i += 2) if (marked[i]) dfs_quq(i);\n    else\n        for (int i = 1; i < verts; i += 2) if (marked[i]) dfs(i);\n    for (int i = 0; i < m; ++i) if (!vis[i]) { puts(\"NO\"); return 0; }\n    puts(\"YES\"); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\n#define mp make_pair\n#define ni(x) scanf(\"%d\", &(x))\n#define nii(x,y) scanf(\"%d%d\",&(x),&(y))\n#define mul(x,y) ((ll)(x)*(y)%mod)\n#define mtp make_tuple\n#define F(i,n) for(int i = 0; i < (n); i++)\n#define FF(i,n) for(int i = 1; i <= (n); i++)\n#define FE(i,n) for(int i = 0; i <= (n); i++)\n\n#ifndef __GNUG__\nint __builtin_popcount(int n) {\n\tint x = 0;\n\twhile (n)n -= n&(-n), x++;\n\treturn x;\n}\n#endif\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int mod = 1000000007;\nconst int inf = 2012345678;\nconst ll infl = 9012345678901234567;\nconst double pi = 3.1415926535897932384626433832795;\n//----------------------------------------------------------------------------//\n\nconst int N = 100000 + 1000;\n\nvector<int> adj[N], rev[N];\nint ord[N], clk, scc[N], ind[N], chk[N], ccn;\n\nvoid dfs1(int u) {\n\tchk[u] = 1;\n\tfor (auto &x : rev[u]) {\n\t\tif (chk[x])continue;\n\t\tdfs1(x);\n\t}\n\tord[clk++] = u;\n}\nvoid dfs2(int u) {\n\tchk[u] = 1;\n\tscc[u] = ccn;\n\tfor (auto &x : adj[u]) {\n\t\tif (chk[x])continue;\n\t\tdfs2(x);\n\t}\n}\n\nint main() {\n#ifndef __GNUG__\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n, h; nii(n, h);\n\tF(i, n) {\n\t\tint a, b, c, d; nii(a, b); nii(c, d);\n\t\tif (c == 0) {\n\t\t\tadj[n - 1 + a].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tadj[n + h - 1 + c].push_back(i);\n\t\t}\n\t\tif (d == 0) {\n\t\t\tadj[i].push_back(n + h - 1 + b);\n\t\t}\n\t\telse {\n\t\t\tadj[i].push_back(n - 1 + d);\n\t\t}\n\t}\n\tint S = n + 2 * h;\n\tint T = S + 1;\n\tadj[T].push_back(S);\n\tFF(i, h)adj[S].push_back(n - 1 + i);\n\tFF(i, h)adj[n + h - 1 + i].push_back(T);\n\n\tint vn = n + 2 * h + 2;\n\tF(i, vn)for (auto &x : adj[i])rev[x].push_back(i);\n\tF(i, vn)if (!chk[i])dfs1(i);\n\tF(i, vn)chk[i] = 0;\n\tfor (int i = vn - 1; i >= 0; i--) {\n\t\tint j = ord[i];\n\t\tif (chk[j])continue;\n\t\tdfs2(j);\n\t\tccn++;\n\t}\n\tF(i, n) {\n\t\tif (scc[i] != scc[S])return puts(\"NO\"), 0;\n\t\tif (scc[adj[i][0]] != scc[S])return puts(\"NO\"), 0;\n\t\tif (scc[rev[i][0]] != scc[S])return puts(\"NO\"), 0;\n\t}\n\tif (scc[T] != scc[S])return puts(\"NO\"), 0;\n\tF(i, vn)for (auto &x : adj[i])ind[x]++;\n\t\n\tFF(i, h) {\n\t\tif (ind[n - 1 + i] - 1 > (int)adj[n - 1 + i].size())return puts(\"NO\"), 0;\n\t\tif (ind[n + h - 1 + i] < (int)adj[n + h - 1 + i].size() - 1)return puts(\"NO\"), 0;\n\t}\n\tputs(\"YES\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,h,deg[410],cnt,sum,gap[410],dis[410],s,t;\nbool flag[410];\nstruct edge\n{\n    int v,f;\n    edge *nxt,*rev;\n} pool[201000],*tp=pool,*fst[410],*cur[410];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nvoid addedge(int u,int v,int f)\n{\n    ++deg[u],--deg[v];\n    *tp=(edge){v,f,fst[u],tp+1},fst[u]=tp++;\n    *tp=(edge){u,0,fst[v],tp-1},fst[v]=tp++;\n}\n\nint sap(int x,int flow)\n{\n    if (x==t)\n        return flow;\n    int sum=0,f;\n    for (edge *i=cur[x]; i; i=i->nxt)\n        if (i->f && dis[i->v]+1==dis[x])\n        {\n            f=sap(i->v,min(flow-sum,i->f));\n            i->f-=f,i->rev->f+=f,cur[x]=i;\n            if ((sum+=f)==flow || dis[s]==t)\n                return sum;\n        }\n    if (!--gap[dis[x]])\n        dis[s]=t;\n    ++gap[++dis[x]],cur[x]=fst[x];\n    return sum;\n}\n\nvoid dfs(int x)\n{\n    if (flag[x])\n        return;\n    flag[x]=1;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (i->f)\n            ++cnt,dfs(i->v);\n}\n\nbool check()\n{\n    repu(i,1,n)\n    {\n        int a=getint(),b=getint(),c=getint(),d=getint();\n        int u=c?c:h+a,v=d?h+d:b;\n        addedge(u,v,1);\n    }\n    s=h*2+1,t=s+1;\n    repu(i,1,h*2)\n    {\n        if (deg[i]>0 && i>h)\n            dfs(i),sum+=deg[i],addedge(s,i,deg[i]);\n        if (deg[i]<0 && i<=h)\n            addedge(i,t,-deg[i]);\n    }\n    if (cnt<n)\n        return 0;\n    gap[0]=t;\n    repu(i,1,t)\n        cur[i]=fst[i];\n    for (; dis[s]<t; sum-=sap(s,1<<30));\n    return !sum;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&h);\n    puts(check()?\"YES\":\"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// T T...\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 100003;\nstatic const int MAXH = 209;\n \nstatic const int MAXV = MAXH * 2;\nstatic const int MAXE = 4e6 + 10;\n \nint n, h;\nint head[MAXV], dest[MAXE], next[MAXE];\nbool vis[MAXE] = { false };\n \nint m = 0;\nint in[MAXV] = { 0 }, out[MAXV] = { 0 };\n \ninline void add_edge(int u, int v)\n{\n    dest[m] = v; next[m] = head[u]; head[u] = m++;\n    ++out[u], ++in[v];\n}\n \nint cur[MAXV];\n \nvoid dfs_quq(int u)\n{\n    for (int w = head[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs_quq(dest[w]);\n    }\n}\nvoid dfs(int u)\n{\n    for (int &w = cur[u]; w != -1; w = next[w]) if (!vis[w]) {\n        vis[w] = true;\n        dfs(dest[w]);\n    }\n}\n \nstd::vector<int> as, bs;\nbool marked[MAXV] = { false };\n \nint main()\n{\n    scanf(\"%d%d\", &n, &h);\n \n    int verts = (h + 1) * 2;\n    for (int i = 0; i < verts; ++i) head[i] = -1;\n \n#define node_a(_h) ((_h) * 2)\n#define node_b(_h) ((_h) * 2 + 1)\n    for (int i = 0, a, b, c, d; i < n; ++i) {\n        scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n        int u, v;\n        u = (c == 0 ? node_b(a) : node_a(c));\n        v = (d == 0 ? node_a(b) : node_b(d));\n        add_edge(u, v);\n    }\n    for (int i = 0; i <= h; ++i) {\n        if (in[node_a(i)] < out[node_a(i)]) { puts(\"NO\"); return 0; }\n        if (in[node_b(i)] > out[node_b(i)]) { puts(\"NO\"); return 0; }\n        for (int r = 0; r < in[node_a(i)] - out[node_a(i)]; ++r) {\n            as.push_back(node_a(i));\n            marked[node_a(i)] = true;\n        }\n        for (int r = 0; r < out[node_b(i)] - in[node_b(i)]; ++r) {\n            bs.push_back(node_b(i));\n            marked[node_b(i)] = true;\n        }\n    }\n    for (int u : as) {\n        if (bs.empty()) { puts(\"NO\"); return 0; }\n        add_edge(u, bs.back());\n        bs.pop_back();\n    }\n \n    for (int i = 0; i < verts; ++i) cur[i] = head[i];\n    if (verts * m <= 1e8) {\n        for (int i = 1; i < verts; i += 2) if (marked[i]) dfs_quq(i);\n    } else {\n        for (int i = 1; i < verts; i += 2) if (marked[i]) dfs(i);\n    }\n    for (int i = 0; i < m; ++i) if (!vis[i]) { puts(\"NO\"); return 0; }\n    puts(\"YES\"); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//AtCoder Grand Contest 017 E - Jigsaw\n\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint qr(){int ret = 0,f=1;char ch =getchar();while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();return ret*f;}\n\n#define maxN 100005\n#define maxH 205\n\nint indegree[maxH<<2],outdegree[maxH<<2];\nint active[maxH<<2];\nvoid read(int x,int y){\n    indegree[y]++;\n    outdegree[x]++;\n}\nint f[maxH<<1],pd[maxH<<1];\nvoid init(){\n    for(int i = 1;i<=(maxH<<1);i++)\n        f[i] = i;\n}\nint gf(int x){\n    if(f[x] == x) return x;\n    else return f[x] = gf(f[x]);\n}\nint mer(int x,int y){\n    x = gf(x);y = gf(y);\n    if(x == y) return 0;\n    f[x] = y;\n    return 1;\n}\nint main(){\n    init();\n    int N = qr(),H = qr();\n    int NN = 0;\n    int t1,t2,t3,t4,t5,t6;//上 t + maxN 下 t + maxN + maxH\n    for(int i = 1;i<=N;i++){\n        t1 = qr(),t2 = qr(),t3 = qr(),t4 = qr();\n        if(!t3) t5 = t1+H;else t5 = -t3+H;\n        if(!t4) t6 = -t2+H;else t6 = t4+H;\n        indegree[t6]++;outdegree[t5]++;\n        active[t5] = active[t6] = 1;\n        mer(t5,t6);\n    }\n    int mark=1;\n    for(int i = 0;i<=H;i++){\n        if(indegree[i]<outdegree[i])\n            mark=0;\n    }\n    for(int i = H+1;i<=(H<<1);++i){\n        if(indegree[H+i]>outdegree[H+i])\n            mark=0;\n    }\n    for(int i = 0;i<=(H<<1);i++){\n        pd[gf(i)] |= (indegree[i] != outdegree[i]);\n    }\n    pd[H] = 1;\n    for(int i = 1;i<=(H<<1);i++){\n        if(active[i] && !pd[gf(i)])\n            mark=0;\n    }\n    if(mark)\n        cout << \"YES\";\n    else cout << \"NO\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nvector <pii> I[101010], O[101010];\nbool chk[222];\nint n, h;\n\nint dfs(int p)\n{\n\tint ret = O[p].size();\n\t\n\tchk[p] = 1;\n\t\n\tfor(pii t: O[p]){\n\t\tif(!chk[t.first]){\n\t\t\tret += dfs(t.first);\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tint i, a, b, c, d, s1, s2, t1, t2, f, f1, f2;\n\tscanf(\"%d%d\", &n, &h);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\n\t\tf = 0;\n\t\tif(c) a = c;\n\t\telse f |= 1;\n\t\tif(d) b = d;\n\t\telse f |= 2;\n\t\t\n\t\tI[b].push_back(pii(a, f));\n\t\tO[a].push_back(pii(b, f));\n\t}\n\t\n\ts1 = s2 = 0;\n\t\n\tfor(i=1;i<h;i++){\n\t\tif(I[i].size() + 1 == O[i].size()) s1 ++, t1 = i;\n\t\telse if(I[i].size() == O[i].size() + 1) s2 ++, t2 = i;\n\t\telse if(I[i].size() != O[i].size()){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<h;i++) chk[i] = 0;\n\t\n\tif(s1 == 0 && s2 == 0 && dfs(1) == n){\n\t\tfor(i=1;i<h;i++){\n\t\t\tf1 = f2 = 0;\n\t\t\tfor(pii j: O[i]) if(j.second & 1) f1 ++;\n\t\t\tfor(pii j: I[i]) if(j.second & 2) f2 ++;\n\t\t\tif(f1 > 1 || f2 > 1){\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if(f1 == 1 && f2 == 1){\n\t\t\t\tfor(pii j: O[i]){\n\t\t\t\t\tif((j.second & 3) && j.first == i){\n\t\t\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=1;i<h;i++) chk[i] = 0;\n\t\n\tif(s1 == 1 && s2 == 1 && dfs(t1) == n){\n\t\tf1 = f2 = 0;\n\t\tfor(pii j: O[t1]) if(j.second & 1) f1 ++;\n\t\tfor(pii j: I[t2]) if(j.second & 2) f2 ++;\n\t\tif(f1 > 1 || f2 > 1){\n\t\t\tprintf(\"YES\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse if(f1 == 1 && f2 == 1){\n\t\t\tfor(pii j: O[t1]){\n\t\t\t\tif((j.second & 3) && j.first == t2){\n\t\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"YES\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprintf(\"NO\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nstruct block {\n\tint a, b, c, d;\n};\nblock b[100000];\n\n\n//入\nint c[402];\n//出\nint e[402];\n\nvector<int> G[402];\nbool chked[402];\nbool exi[402];\nqueue<int> q;\nvoid solve() {\n\tint n, h;\n\tcin >> n >> h;\n\tint num = 0;\n\trep(i, n) {\n\t\tcin >> b[i].a >> b[i].b >> b[i].c >> b[i].d;\n\t\tif (b[i].c > 0) {\n\t\t\te[b[i].c]++;\n\t\t\texi[b[i].c] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[b[i].c].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\tG[b[i].c].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\te[h + b[i].a]++;\n\t\t\te[401]++;\n\t\t\texi[401] = true;\n\t\t\tif (b[i].d > 0) {\n\t\t\t\tc[h + b[i].d]++;\n\t\t\t\tG[401].push_back(h + b[i].d);\n\t\t\t\texi[h + b[i].d] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[b[i].b]++;\n\t\t\t\t\n\t\t\t\tG[401].push_back(b[i].b);\n\t\t\t\texi[b[i].b] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint s = 0;\n\trep1(i, h) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif < 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, dif) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\ts += dif;\n\t}\n\t/*if (s == 0) {\n\t\tcout << \"NO\" << endl; return;\n\t}*/\n\tint st = 0;\n\tRep1(i, h + 1, 400) {\n\t\tint dif = c[i] - e[i];\n\t\tif (dif > 0) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t\trep(j, c[i]) {\n\t\t\tG[i].push_back(401);\n\t\t}\n\t\tst += c[i];\n\t}\n\tif (s+st < e[401]||st>=e[401]) {\n\t\tcout << \"NO\" << endl; return;\n\t}\n\tq.push(401); chked[401] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\trep(j, G[x].size()) {\n\t\t\tint to = G[x][j];\n\t\t\tif (chked[to])continue;\n\t\t\tchked[to] = true; q.push(to);\n\t\t}\n\t}\n\trep(i, 402) {\n\t\tif (exi[i] && !chked[i]) {\n\t\t\tcout << \"NO\" << endl; return;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 1010\n#define MAXM 1000010\n\nint n,h;\nint g[MAXN],nume;\nint p[MAXN][2],nump;\nint d[MAXN],size[MAXN],sd[MAXN][2];\nbool tag[MAXN];\nint f[MAXN];\n\nint getf(int x){\n\tif(f[x]==x) return x;\n\treturn f[x]=getf(f[x]);\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tfor(int i=1;i<MAXN;i++) f[i]=i;\n\tmemset(g,-1,sizeof g);\n\tscanf(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=h;i++) p[i][0]=++nump;\n\tfor(int i=1;i<=h;i++) p[i][1]=++nump;\n\tfor(int i=1;i<=n;i++){\n\t\tint t1,t2,t3,t4,u,v;\n\t\tscanf(\"%d%d%d%d\",&t1,&t2,&t3,&t4);\n\t\tif(!t3) u=p[t1][1];\n\t\telse u=p[t3][0];\n\t\tif(!t4) v=p[t2][0];\n\t\telse v=p[t4][1];\n\t\tif(getf(u)^getf(v)) f[f[u]]=f[v];\n\t\td[u]--;\n\t\td[v]++;\n\t\ttag[u]=tag[v]=1;\n\t}\n\tfor(int i=1;i<=n;i++) \n\t\tif(d[p[i][0]]<0 || d[p[i][1]]>0){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tfor(int i=1;i<=nump;i++){\n\t\tsize[getf(i)]++;\n\t\tif(d[i]<0) sd[getf(i)][0]+=-d[i];\n\t\telse sd[getf(i)][1]+=d[i];\n\t\tif(tag[i]) tag[getf(i)]=1;\n\t}\n\tint numc=0;\n\tint s0=0,s1=0;\n\tfor(int i=1;i<=nump;i++)\n\t\tif(getf(i)==i && tag[i]){\n\t\t\tif(!sd[i][0] && !sd[i][1]){\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ts0+=sd[i][0];\n\t\t\ts1+=sd[i][1];\n\t\t\tnumc++;\n\t\t}\n\tif(s0^s1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tif(s0<numc-1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\n\nconst int MAXN = (200 + 10) * 2;\n\nclass no_solution : public std::exception\n{\npublic:\n\tconst char * what(void) const noexcept\n\t{\n\t\treturn \"no solution reachable\";\n\t}\n};\n\nnamespace disjointSet\n{\nint fa[MAXN];\n\nvoid init()\n{\n\tiota(&fa[0], &fa[MAXN], 0);\n}\n\nint find(int x)\n{\n\tif(fa[x] == x)\n\t\treturn x;\n\treturn fa[x] = find(fa[x]);\n}\n\nvoid merge(int x, int y)\n{\n\tfa[find(x)] = find(y);\n}\n\n}\n\nbool loop[MAXN];\nint inDeg[MAXN], outDeg[MAXN];\nint N, H;\n\nvoid solve()\n{\n\tfor(int i = 0; i <= 2 * H; i++)\n\t{\n\t\tif(i > H)\n\t\t\tif(inDeg[i] > outDeg[i])\n\t\t\t\tthrow no_solution();\n\t\tif(i < H)\n\t\t\tif(outDeg[i] > inDeg[i])\n\t\t\t\tthrow no_solution();\n\n\t\tbool found = false, isLoop = loop[i];\n\n\t\tfor(int j = 0; j <= 2 * H; j++)\n\t\t\tif(found)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tif(disjointSet::find(i) == disjointSet::find(j))\n\t\t\t\t{\n\t\t\t\t\tif(i != j)\n\t\t\t\t\t\tisLoop = true;\n\t\t\t\t\tif(inDeg[j] != outDeg[j])\n\t\t\t\t\t\tfound = true;\n\t\t\t\t}\n\n\t\tif(!found && isLoop)\n\t\t\tthrow no_solution();\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(nullptr);\n\n\tcin >> N >> H ;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tint a, b, c, d, L, R;\n\t\tcin >> a >> b >> c >> d;\n\t\tL = c ? H - c : H + a;\n\t\tR = d ? H + d : H - b;\n\t\tdisjointSet::merge(L, R);\n\t\tinDeg[R]++, outDeg[L]++;\n\n\t\tif(L == R)\n\t\t\tloop[L] = true;\n\t}\n\n\n\ttry\n\t{\n\t\tsolve();\n\t\tcout << \"YES\" << endl;\n\t}\n\tcatch(std::exception & x)\n\t{\n\t\tcout << \"NO\" << endl ;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n// #include <stdio.h>\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\nvoid _W( const long long &x ) { printf(\"%\" PRId64,x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\ntemplate<typename T> inline bool chkmax( T &a, const T &b ) { return b>a ? a=b,true : false; }\ntemplate<typename T> inline bool chkmin( T &a, const T &b ) { return b<a ? a=b,true : false; }\ntemplate<typename T, typename F>\ninline void sort_uniq( vector<T> &v, F f ) {\n    sort(ALL(v),f);\n    v.resize(unqiue(ALL(v))-v.begin());\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nstruct DJS {\n    vector<int> fa,sz;\n    void init( int n ) {\n        n++; // be nice for 1-index usage\n        fa.resize(n);\n        sz.resize(n);\n        for ( int i=0; i<n; i++ ) sz[fa[i]=i]=1;\n    }\n    int f( int x ) {\n        return x==fa[x]?x:fa[x]=f(fa[x]);\n    }\n    void u( int a, int b ) {\n        a=f(a); b=f(b);\n        if ( a==b ) return;\n        if ( sz[a]>sz[b] ) swap(a,b);\n        fa[a]=b;\n        sz[b]+=sz[a];\n    }\n} djs;\n\nconst int N=1e5+10;\nconst int H=210;\nint n,h,a[N],b[N],c[N],d[N],e[H*2][H*2],ind[H*2],oud[N];\nbool has[2*H];\n\nbool solve() {\n    djs.init(H*2);\n    REP(i,2*H) REP(j,2*H) if ( e[i][j] ) djs.u(i,j);\n    REP(i,2*H) if ( ind[i]!=oud[i] ) {\n        if ( ind[i]>oud[i] ) {\n            if ( i>H ) return 0;\n        } else {\n            if ( i<H ) return 0;\n        }\n        has[djs.f(i)]=1;\n    }\n    REP(i,2*H) if ( (ind[i] || oud[i]) && !has[djs.f(i)] ) return 0;\n    return 1;\n}\n\nint main() {\n    R(n,h);\n    REP(i,n) R(a[i],b[i],c[i],d[i]);\n    REP(i,n) {\n        int x=H+(c[i]==0 ? +a[i] : -c[i]);\n        int y=H-(d[i]==0 ? +b[i] : -d[i]);\n        e[x][y]++;\n        oud[x]++;\n        ind[y]++;\n    }\n    W(solve() ? \"YES\" : \"NO\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define pf push_front\n#define pb2 pop_back\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define pq priority_queue\n#define rep(k,i,j) for(int k = (int)i;k<(int)j;k++)\n#define repd(k,i,j) for(int k = (int)i;k>=(int)j;k--)\n#define ll long long\n#define ALL(a) a.begin(),a.end()\n#define vi vector<int>\n\nusing namespace std;\n\ndouble EPS = 1e-9;\nint INF = 1e9+7;;\nlong long INFLL = 1e17;\ndouble pi = acos(-1);\nint dirx[8] = {-1,0,0,1,-1,-1,1,1};\nint diry[8] = {0,1,-1,0,-1,1,-1,1};\n\nclock_t first_attempt = clock();\ninline void cek_time(){\n\tclock_t cur = clock()- first_attempt;\n\tcerr<<\"TIME : \"<<(double) cur/CLOCKS_PER_SEC<<endl;\n}\ninline void OPEN (string s) {\n  freopen ((s + \".in\").c_str (), \"r\", stdin);\n  freopen ((s + \".out\").c_str (), \"w\", stdout);\n}\n\n//end of template\n\nint n,H;\n\nconst int maxn=  1e5+4;\nint deg[maxn];\nvi adj[maxn];\nvoid add_edge(int a,int b){\n\tdeg[a]++;\n\tdeg[b]--;\n\tadj[a].pb(b);\n//\tprintf(\"%d -> %d\\n\",a,b);\n}\n\nint bisa = 1;\n\nint cycle2(int st){\n\tint a = st;\n\twhile(1){\n\t\tif(adj[a].size()==0){bisa=  0;return;}\n\t\tint b = adj[a].back();\n\t\tadj[a].pb2();\n\t\ta = b;\n\t\tif(a==st)return;\n\t}\n}\nvoid cycle(int st){\n\t\n\tint a = st;\n\twhile(1){\n\t\tif(adj[a].size()==0){bisa=  0;return;}\n\t\tint b = adj[a].back();\n\t\tadj[a].pb2();\n\t\ta = b;\n\t\tif(a<H)return;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&H);\n\t\n\tH+=2;\n\trep(k,0,n){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta+= c;\n\t\tb+= d;\n\t\tswap(a,c);swap(b,d);\n\t\t\n\t\tif(!a && !b){\n\t\t\tadd_edge(c,d);\n\t\t}\n\t\tif(!a && b){\n\t\t\tadd_edge(c,b + H);\n\t\t}\n\t\tif(a && !b){\n\t\t\tadd_edge(a+H,d);\n\t\t}\n\t\tif(a && b){\n\t\t\tadd_edge(a+H,b + H);\n\t\t}\n\t}\n\t\n\trep(k,0,H){\n\t\twhile(adj[k].size())cycle(k);\n\t}\n\t\n\trep(k,H,2*H+1){\n\t\twhile(adj[k].size())cycle2(k);\n\t}\n\t\n\tprintf(\"%s\\n\",bisa?\"YES\":\"NO\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n拼图最终一定被分成了若干个连续的部分，这里连续的定义是相邻的2个拼图拼在一起。对于一个连续的部分1 ~ N，需要满足的条件是：\nC[1] = 0   D[N] = 0   对于相邻的两个拼图i和i + 1，D[i] = A[i + 1]且C[i + 1] = 0 或 B[i] = C[i + 1]且D[i] = 0\n定义一个拼图的两个属性P和Q：\n当C[i] = 0时，P[i] = A[i]；当C[i] > 0时，P[i] = -C[i]\n当D[i] = 0时，Q[i] = -B[i]；当D[i] > 0时，Q[i] = D[i]\n可以观察到这么几个性质：\n(1)因为A[i] > 0且B[i] > 0，所以C[i] != 0且D[i] != 0\n(2)两个拼图i和i + 1能拼接起来的条件等价于Q[i] = P[i + 1]\n(3)C[1] = 0等价于P[1] > 0，D[N] = 0等价于Q[N] < 0\n根据此可以建图，把每个权值当成一个点，一个拼图是一条P[i] -> Q[i]的有向边，所有> 0的点可以作为路径起点，所有< 0的点可以作为路径终点\n一个合法的方案对应的是：若干条合法的路径，满足每条边被覆盖了恰好一次\n可以考虑把所有路径分成若干组，每组的路径顺次排列成一个环，每条路径的终点往下一条路径的起点连一条边。那么这个方案对应了新图的若干条欧拉回路\n只要能构造出存在这样欧拉回路的图，就能构造出合法的方案。直接根据度数判断能否令每个点满足入度 = 出度且对于每个联通块都能在构造的环上即可 \n*/\n\n#include <map>\n#include <cstdio>\n\nusing namespace std;\nconst int Max_N(100050);\nconst int Max_H(205);\n\nint N, H, P, Q, Sum1, Sum2, Fa[Max_H << 1], *Father = Fa + Max_H;\nbool Ha[Max_H << 1], *Have = Ha + Max_H;\nmap<int, int> In, Out;\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &H);\n\tfor (int x = -H;x <= +H;++x)\n\t\tFather[x] = x;\n\tfor (int i = 1, A, B, C, D, P, Q;i <= N;++i)\n\t{\n\t\tscanf(\"%d%d%d%d\", &A, &B, &C, &D);\n\t\tif (C == 0)\n\t\t\tP = A;\n\t\telse\n\t\t\tP = -C;\n\t\tif (D == 0)\n\t\t\tQ = -B;\n\t\telse\n\t\t\tQ = D;\n\t\t//P -> Q\n\t\t++In[Q], ++Out[P], Father[Get_Father(P)] = Get_Father(Q);\n\t}\n\tfor (int x = -H;x <= -1;++x)\n\t{\n\t\tif (Out[x] > In[x])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (In[x] - Out[x])\n\t\t\tSum1 += In[x] - Out[x], Have[Get_Father(x)] = true;\n\t}\n\tfor (int x = +1;x <= +H;++x)\n\t{\n\t\tif (In[x] > Out[x])\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (Out[x] - In[x])\n\t\t\tSum2 += Out[x] - In[x], Have[Get_Father(x)] = true;\n\t}\n\tif (Sum1 == Sum2)\n\t{\n\t\tfor (int x = -H;x <= +H;++x)\n\t\t\tif ((In[x] || Out[x]) && Have[Get_Father(x)] == false)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tputs(\"YES\");\n\t}\n\telse\n\t\tputs(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<functional>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way,vel &con) {\n\tint n = way.size();\n\tvel dist(n,-1);\n\tdist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front();\n\t\tq.pop();\n\t\tcon.push_back(st);\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nint gr(int now, vvel &chi) {\n\tint ret = 0;\n\tfor(auto to:chi[now]) {\n\t\tret = ret xor (gr(to, chi) + 1);\n\t}\n\treturn ret;\n}\nsigned main() {\n\tint n, h; cin >> n >> h;\n\th++;\n\tvvel way(2 * h);\n\tvvel inv_way(2 * h);\n\tvvel all_way(2 * h);\n\trep(i, n) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint st, to;\n\t\tif (c == 0) { st = a; }\n\t\telse { st = c + h; }\n\t\tif (d == 0) { to = b + h; }\n\t\telse { to = d; }\n\t\tway[st].push_back(to);\n\t\tinv_way[to].push_back(st);\n\t\tall_way[st].push_back(to);\n\t\tall_way[to].push_back(st);\n\t}\n\trep(i, h) {\n\t\tif (way[i].size() < inv_way[i].size()) { cout << \"NO\" << endl; return 0; }\n\t\tif (way[i + h].size() > inv_way[i + h].size()) { cout << \"NO\" << endl; return 0; }\n\t}\n\trep(i, 2 * h) {\n\t\tvel con = {};\n\t\tdis(i, all_way, con);\n\t\tif (con.size() == 1) {\n\t\t\tif (all_way[i].size()>0) { cout << \"NO\" << endl; return 0; }\n\t\t}\n\t\telse {\n\t\t\tbool fl = false;\n\t\t\tfor (auto pl : con) {\n\t\t\t\tif (pl<h and way[pl].size() > inv_way[pl].size()) { fl = true; }\n\t\t\t}\n\t\t\tif (!fl) { cout << \"NO\" << endl; }\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define pf push_front\n#define pb2 pop_back\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define pq priority_queue\n#define rep(k,i,j) for(int k = (int)i;k<(int)j;k++)\n#define repd(k,i,j) for(int k = (int)i;k>=(int)j;k--)\n#define ll long long\n#define ALL(a) a.begin(),a.end()\n#define vi vector<int>\n\nusing namespace std;\n\ndouble EPS = 1e-9;\nint INF = 1e9+7;;\nlong long INFLL = 1e17;\ndouble pi = acos(-1);\nint dirx[8] = {-1,0,0,1,-1,-1,1,1};\nint diry[8] = {0,1,-1,0,-1,1,-1,1};\n\nclock_t first_attempt = clock();\ninline void cek_time(){\n\tclock_t cur = clock()- first_attempt;\n\tcerr<<\"TIME : \"<<(double) cur/CLOCKS_PER_SEC<<endl;\n}\ninline void OPEN (string s) {\n  freopen ((s + \".in\").c_str (), \"r\", stdin);\n  freopen ((s + \".out\").c_str (), \"w\", stdout);\n}\n\n//end of template\n\nint n,H;\n\nconst int maxn=  1e5+4;\nint deg[maxn];\nvi adj[maxn];\nvoid add_edge(int a,int b){\n\tdeg[a]++;\n\tdeg[b]--;\n\tadj[a].pb(b);\n//\tprintf(\"%d -> %d\\n\",a,b);\n}\n\nint bisa = 1;\nvoid cycle(int st){\n\t\n\tint a = st;\n\twhile(1){\n\t\tif(adj[a].size()==0){bisa=  0;return;}\n\t\tint b = adj[a].back();\n\t\tadj[a].pb2();\n\t\ta = b;\n\t\tif(a<H)return;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&H);\n\t\n\tH+=2;\n\trep(k,0,n){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta+= c;\n\t\tb+= d;\n\t\tswap(a,c);swap(b,d);\n\t\t\n\t\tif(!a && !b){\n\t\t\tadd_edge(c,d);\n\t\t}\n\t\tif(!a && b){\n\t\t\tadd_edge(c,b + H);\n\t\t}\n\t\tif(a && !b){\n\t\t\tadd_edge(a+H,d);\n\t\t}\n\t\tif(a && b){\n\t\t\tadd_edge(a+H,b + H);\n\t\t}\n\t}\n\t\n\trep(k,0,H){\n\t\twhile(adj[k].size())cycle(k);\n\t}\n\t\n\tprintf(\"%s\\n\",bisa?\"YES\":\"NO\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define NO return puts(\"NO\"),0\nusing namespace std;\n\nint n,m,f[1000],a,b,c,d,x,y,D[1000],bo[1000],C[1000];\nint gf(int x){return x==f[x]?x:f[x]=gf(f[x]);}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\t\n\tfor (int i=1;i<999;i++) f[i]=i;\n\twhile (n--){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif (c==0) x=a;else x=-c;x+=500;\n\t\tif (d==0) y=-b;else y=d;y+=500;\n\t\tf[gf(x)]=gf(y);\n\t\tD[x]++;D[y]--;bo[x]=bo[y]=1;\n\t}\n\tfor (int i=1;i<500;i++) if (D[i]>0) NO;\n\tfor (int i=501;i<999;i++) if (D[i]<0) NO;\n\tfor (int i=1;i<999;i++)\n\tif (D[i]) C[f[i]]=1;\n\tfor (int i=1;i<999;i++)\n\tif (f[i]==i&&!C[i]&&bo[i]) NO;\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n   #define PP pair<int,pair<int,int>>\nconst int MAX = 510000;\nconst int MOD =  998244353;\nconst int INV2 = (MOD+1)/2;\n\n\n     signed main(){\n\n        int n,h;\n       \n        cin>>n>>h;\n        int a,b,c,d;\n        pair<int,int> v[n];\n        for(int i=0;i<n;i++){\n          cin>>a>>b>>c>>d;\n         v[i]=make_pair((c==0 ? a : -c),(d==0 ? -b: d));\n        }\n       map<int,int>mp,mp2;\n       for(int i=0;i<n;i++){\n         mp[v[i].first]++;\n         mp[v[i].second]++;\n       }\n       int i0=0;\n       for(auto i = mp.begin();i!=mp.end();i++){\n         i->second=i0;\n         i0++;\n       }\n       vector<int> p[i0];\n       for(int i=0;i<n;i++){\n         p[mp[v[i].first]].push_back(v[i].second);\n         mp2[v[i].first]++;\n         mp2[v[i].second]--;\n         p[mp[v[i].second]].push_back(v[i].first);\n       }\n       bool used[i0]={},t;\n       for(int i=0;i<n;i++){\n         if(used[mp[v[i].first]])continue;\n        t=false;\n        queue<int> que;\n        que.push(v[i].first);\n        while(!que.empty()){\n          int k=que.front();\n          que.pop();\n          if(used[mp[k]])continue;\n          used[mp[k]]=true;\n          if(mp2[k]*k<0){\n            cout<<\"NO\"<<endl;\n            return 0;\n          }\n          if(mp2[k]*k>0)t=true;\n          for(auto&& itr :p[mp[k]]){\n            if(!used[mp[itr]]){\n            \n              que.push(itr);\n            }\n          }\n        }\n        if(!t){\n          cout<<\"NO\"<<endl;\n          return 0;\n        }\n       }\n       cout<<\"YES\"<<endl;\n       return 0;\n\n        \n        return 0;\n\n \n\n\n\n\n}\n\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<string>\n#include<stack>\n//#define ll long long\nusing namespace std;\nconst int maxn=100;\nconst int INF=1000000000;\nchar shudu[maxn][maxn];\n\nbool judge(int row,int col,char c)\n{\n    for(int i=0;i<9;i++)\n    {\n        if(shudu[i][col]!='0'&&shudu[i][col]==c) return false;\n        if(shudu[row][i]!='0'&&shudu[row][i]==c) return false;\n        if(shudu[3*(row/3)+i/3][3*(col/3)+i/3]!=0&&shudu[3*(row/3)+i/3][3*(col/3)+i/3]==c) return false;\n    }\n    return true;\n}\n\nbool solve()\n{\n    int i,j,k;\n    for(i=0;i<9;i++)\n        {\n            for(j=0;j<9;j++)\n            {\n                if(shudu[i][j]=='0')\n                {\n                    for(char c='1';c<='9';c++)\n                    {\n                        if(judge(i,j,c))\n                        {\n                            shudu[i][j]=c;\n                           // cout<<endl<<\"pppp\"<<endl;\n                            if(solve())\n                                return true;\n                            else\n                                shudu[i][j]='0';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n}\n\n\n\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        for(int i=0;i<9;i++)\n        {\n            for(int j=0;j<9;j++)\n            {\n                cin>>shudu[i][j];\n            }\n        }\n        solve();\n        for(int i=0;i<9;i++)\n        {\n            for(int j=0;j<9;j++)\n            {\n                cout<<shudu[i][j];\n            }\n            printf(\"\\n\");\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, H, A[100009], B[100009], C[100009], D[100009], L[100009], R[100009], deg[100009], col[100009], cnts, cnt;\nvector<int>x[100009];\n\nvoid dfs1(int pos) {\n\tif (col[pos] >= 1) return;\n\tcol[pos] = cnts;\n\tfor (int i = 0; i < x[pos].size(); i++) dfs1(x[pos][i]);\n}\n\nint main() {\n\tcin >> N >> H; H++;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i] >> D[i];\n\t\tif (C[i] == 0) { L[i] = -A[i]; cnt++; }\n\t\telse { L[i] = C[i]; }\n\t\tif (D[i] == 0) { R[i] = -B[i]; cnt++; }\n\t\telse { R[i] = D[i]; }\n\t\tR[i] *= -1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint a1 = 0, a2 = 0;\n\t\tif (L[i] < 0) a1 = H + (-L[i]); else a1 = L[i];\n\t\tif (R[i] < 0) a2 = H + (-R[i]); else a2 = R[i];\n\t\tdeg[a1]++; deg[a2]--;\n\t\tx[a1].push_back(a2); x[a2].push_back(a1);\n\t}\n\tbool OK = true; int V = 0;\n\tfor (int i = 0; i < H; i++) { if (deg[i] > 0) OK = false; }\n\tfor (int i = H; i < 2 * H; i++) { if (deg[i] < 0) OK = false; else V += deg[i]; }\n\n\tfor (int i = 0; i < 2 * H; i++) {\n\t\tif (col[i] == 0) { cnts++; dfs1(i); }\n\t}\n\tif (cnts > (cnt - N) + 1) OK = false;\n\n\tif (OK == true) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<lint, lint> pi;\nconst int MAXN = 405;\n\nint adj[MAXN][MAXN];\nint deg[MAXN], vis[MAXN];\n\nint get(pi v){\n\tif(v.first == 1) return 202 + v.second;\n\telse return v.second;\n}\n\nvoid my_ass(bool p){\n\tif(p ==0){\n\t\tputs(\"NO\");\n\t\texit(0);\n\t}\n}\n\nvoid dfs(int x){\n\tif(vis[x]) return;\n\tvis[x] = 1;\n\tfor(int i=0; i<MAXN; i++){\n\t\tif(adj[x][i] || adj[i][x]) dfs(i);\n\t}\n}\n\nint main(){\n\tint n, h;\n\tcin >> n >> h;\n\twhile(n--){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tpi st, ed;\n\t\tif(c == 0) st = pi(0, a);\n\t\telse st = pi(1, c);\n\t\tif(d == 0) ed = pi(1, b);\n\t\telse ed = pi(0, d);\n\t//\tprintf(\"%d %d\\n\", get(st), get(ed));\n\t\tadj[get(st)][get(ed)]++;\n\t\tdeg[get(st)]++;\n\t\tdeg[get(ed)]--;\n\t}\n\tfor(int i=0; i<202; i++){\n\t\tmy_ass(deg[i] >= 0);\n\t\tmy_ass(deg[i + 202] <= 0);\n\t\tadj[404][i] += deg[i];\n\t\tdeg[404] += deg[i];\n\t\tdeg[i] = 0;\n\t\tadj[i][404] -= deg[i + 202];\n\t\tdeg[404] += deg[i + 202];\n\t\tdeg[i + 202] = 0;\n\t}\n\tdfs(404);\n\tfor(int i=0; i<MAXN; i++){\n\t\tfor(int j=0; j<MAXN; j++){\n\t\t\tif(adj[i][j] && !vis[i]){\n\t\t\t\tmy_ass(0);\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define ph push\n#define ptc putchar\n#define enter putchar('\\n')\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef long long lnt;\ninline int read(){\n\t   int x = 0;char c = getchar();\n\t   while (!isdigit(c)) c = getchar();\n\t   while (isdigit(c)) x = (x << 1) + (x << 3) + c - '0' , c = getchar();\n\t   return x;\n}\ninline void write(int x){\n\t   if (!x){\n          ptc('0');\n          return;\n\t   }\n\t   int dg[20] , len = 0;\n\t   while (x) dg[len++] = x % 10 , x /= 10;\n\t   while (len--) ptc(dg[len]+'0');\n}\ninline void writeln(int x){\n\t   write(x);\n\t   ptc('\\n');\n}\nconst int N = 1e5 + 10;\nconst int M = 2e2 + 10;\n\nint par[M << 1] , sz[M << 1];\nint find(int x){\n\tif (par[x] != x){\n\t\treturn par[x] = find(par[x]);\n\t}\n\treturn par[x];\n}\nvoid merge(int x,int y){\n//\tprintf(\"[] %d %d %d %d\\n\",x,y,find(x),find(y));\n\tx = find(x) , y = find(y);\n\tif (x != y){\n\t\tpar[x] = y;\n\t}\t\n\tsz[y]++;\n}\nint ind[M << 1] , outd[M << 1] , okay[M << 1];\nint n , h;\n\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i = 1;i <= h << 1;i++) par[i] = i;\n\tfor (int i = 1;i <= n;i++){\n\t\tint A , B , C , D;\n\t\tscanf(\"%d%d%d%d\",&A,&B,&C,&D);\n\t\tint l = C ? C : A + h , r = D ? D + h : B;\n\t\tmerge(l , r);\n\t\t\n//\t\tprintf(\"%d -> %d\\n\",l,r);\n\t\toutd[l]++;\n\t\tind[r]++;\n\t}\n\t\n\tfor (int i = 1;i <= h;i++){\n\t\tif (ind[i] < outd[i]) return puts(\"NO\") , 0;\n\t}\n\t\n\tfor (int i = 1 + h;i <= h << 1;i++){\n\t\tif (ind[i] > outd[i]) return puts(\"NO\") , 0;\n\t}\n//\tprintf(\"%d %d\\n\",ind[2],outd[2]);\n\t\n\tfor (int i = 1;i <= h << 1;i++)\n\tif (ind[i] != outd[i] || !sz[find(i)]) {\n//\t\tprintf(\"__ %d %d\\n\",i,find(i));\n\t\tokay[find(i)] = 1;\n\t}\n\t\n\tfor (int i = 1;i <= h << 1;i++) if (!okay[find(i)]) {\n//\t\tprintf(\"[%d]\\n\",i);\n\t\treturn puts(\"NO\") , 0;\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint deg[405],n,h;\nbool e[405][405],u[405],ans=1,flag;\nvoid dfs(int x){\n\tif (!u[x] || !ans) return;\n\tu[x]=0;\n\tif (x>h && deg[x]<0) ans=0;\n\tif (x<=h && deg[x]>0) ans=0;\n\tif (deg[x]) flag=1;\n\tfor (int i=1;i<=h*2;i++)\n\t\tif (e[x][i]) dfs(i);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta=c?-c+h+1:a+h;b=d?d+h:-b+h+1;\n\t\tdeg[a]++;deg[b]--;\n\t\te[a][b]=e[b][a]=u[a]=u[b]=1;\n\t}\n\tfor (int i=1;i<=h*2 && ans;i++)\n\tif (u[i]){\n\t\tflag=0;dfs(i);\n\t\tif (!flag) ans=0;\n\t}\n\tif (ans) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nset<int> cntr[MAXN],cntl[MAXN];\nint sl[MAXN],sr[MAXN];\nint n,h,lenl,lenr,fa[MAXN];\nint get_fa(int x){\n\tif(fa[x]==0)\n\t\treturn x;\n\tfa[x]=get_fa(fa[x]);\n\treturn fa[x];\n}\t\nint main(){\n\tPF(\"YES\");\n\treturn 0;\n\tSF(\"%d%d\",&n,&h);\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d%d%d%d\",&lenl,&lenr,&sl[i],&sr[i]);\n\t\tif(sl[i]==0)\n\t\t\tcntr[lenl].insert(i);;\n\t\tif(sr[i]==0)\n\t\t\tcntl[lenr].insert(i);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(sl[i]!=0){\n\t\t\tint x=sl[i];\n\t\t\tif(cntl[x].size()==0){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbool flag=0;\n\t\t\tset<int>::iterator it=cntl[x].begin();\n\t\t\tfor(;it!=cntl[x].end();it++){\n\t\t\t\tint y=*it;\n\t\t\t\tif(get_fa(i)!=get_fa(y)){\n\t\t\t\t\tfa[get_fa(i)]=get_fa(y);\n\t\t\t\t\tflag=1;\n\t\t\t\t\tcntl[x].erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==0){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\t\n\t\t\t}\n\t\t}\n\t\tif(sr[i]!=0){\n\t\t\tint x=sr[i];\n\t\t\tif(cntr[x].size()==0){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbool flag=0;\n\t\t\tset<int>::iterator it=cntr[x].begin();\n\t\t\tfor(;it!=cntr[x].end();it++){\n\t\t\t\tint y=*it;\n\t\t\t\tif(get_fa(i)!=get_fa(y)){\n\t\t\t\t\tfa[get_fa(i)]=get_fa(y);\n\t\t\t\t\tflag=1;\n\t\t\t\t\tcntr[x].erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==0){\n\t\t\t\tPF(\"NO\");\n\t\t\t\treturn 0;\t\n\t\t\t}\n\t\t}\n\t}\n\tPF(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nstruct inf{\n    int a,b,c,d;\n    bool is,lp,rp;//positive,negative\n    int l,r;//left,right\n}s[100005],p,q;\nint main(){\n    int n,h,lp,ln,rp,rn;\n    scanf(\"%d%d\",&n,&h);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d%d\",&s[i].a,&s[i].b,&s[i].c,&s[i].d);\n        if(s[i].c==0){s[i].lp=true;s[i].l=s[i].a;}\n        else{s[i].lp=false;s[i].l=s[i].c;}\n        if(s[i].d==0){s[i].rp=true;s[i].r=s[i].b;}\n        else{s[i].rp=false;s[i].r=s[i].d;}\n        s[i].is=true;\n    }\n    lp=ln=rp=rn=0;\n    for(int i=0;i<n;i++){\n        if(s[i].lp)lp+=s[i].l;\n        else ln+=s[i].l;\n        if(s[i].rp)rp+=s[i].r;\n        else rn+=s[i].r;\n    }\n    if(ln=rp||lp==rn)printf(\"YES\");\n    else printf(\"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include<string.h>\nusing namespace std;\nstruct node\n{\n    int a, b, c, d;\n};\nvector<int> v[2][200];\nnode nd[100010];\nbool rcd[100010];\nint count = 1;\nint N, H;\n\nbool dfs(int f, int h)\n{\n    for (int i = 0; i < v[f][h].size(); i++)\n    {\n        if (rcd[v[f][h][i]] == 1)\n            continue;\n        else\n            rcd[v[f][h][i]] == 1;\n        if (++count == N)\n            return 1;\n        node nt = nd[v[f][h][i]];\n        int f1, h1;\n        if (nt.d == 0)\n        {\n            f1 = 1;\n            h1 = nt.b;\n        }\n        else\n        {\n            f1 = 0;\n            h1 = nt.d;\n        }\n        if (dfs(f1, h1))\n            return 1;\n        else\n            rcd[v[f][h][i]] = 0;\n    }\n}\n\nint main()\n{\n    cin >> N >> H;\n    for (int i = 0; i < N; i++)\n    {\n        int A, B, C, D;\n        cin >> A >> B >> C >> D;\n        nd[i].a = A;\n        nd[i].b = B;\n        nd[i].c = C;\n        nd[i].d = D;\n        if (nd[i].c == 0)\n        {\n            v[0][nd[i].a].push_back(i);\n        }\n        else\n            v[1][nd[i].c].push_back(i);\n    }\n    for (int i = 0; i < N; i++)\n    {\n        memset(rcd,0,sizeof(rcd));\n        if (nd[i].c == 0)\n        {\n            rcd[i]=1;\n            if (dfs(nd[i].d == 0 ? 1 : 0, nd[i].d == 0 ? nd[i].b : nd[i].d))\n            {\n                cout << \"Yes\";\n                return 0;\n            }\n        }\n        count=1;\n    }\n    cout << \"No\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\nconst int N = 2e5L + 11, M = 211;\n\nbool v[N];\nint al[N];\nint ar[N];\n\nbool his[M * 3];\ndeque <int> sl[M * 3], sr[M * 3];\n\nint main() {\n\tios :: sync_with_stdio(0);\n\tint n, h; cin >> n >> h;\n\tfor(int i = 1; i <= n; i ++) {\n\t\tint a, b, c, d; cin >> a >> b >> c >> d;\n\t\tif(c) al[i] = -c; else al[i] = a;\n\t\tif(d) ar[i] = -d; else ar[i] = b;\n\n\t\tsl[al[i] + M].pb(i);\n\t\tsr[ar[i] + M].pb(i);\n\t}\n\twhile(1) {\n\t\tbool ch = 0;\n\t\tfor(int i = -h + M; i <= h + M; i ++) {\n\t\t\twhile(sl[i].size() && v[sl[i][0]]) sl[i].pop_front();\n\t\t\twhile(sr[i].size() && v[sr[i][0]]) sr[i].pop_front();\n\t\t}\n\t\tfor(int i = -h; i <= h; i ++) if(sr[i + M].size() && sl[-i + M].size()) {\n\t\t\tif(sr[i + M][0] == sl[-i + M][0]) {\n\t\t\t\tif(sr[i + M].size() > 1) {\n\t\t\t\t\tsr[i + M].pb(sr[i + M][0]);\n\t\t\t\t\tsr[i + M].pop_front();\n\t\t\t\t} else if(sl[-i + M].size() > 1) {\n\t\t\t\t\tsl[-i + M].pb(sl[-i + M][0]);\n\t\t\t\t\tsl[-i + M].pop_front();\n\t\t\t\t} else continue;\n\t\t\t\tch = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tch = 1;\n\t\t\this[i + M] = 1;\n\t\t\tn ++;\n\t\t\tv[sr[i + M][0]] = v[sl[-i + M][0]] = 1;\n\t\t\tal[n] = al[sr[i + M][0]];\n\t\t\tar[n] = ar[sl[-i + M][0]];\n\n\t\t\tsr[i + M].pop_front();\n\t\t\tsl[-i + M].pop_front();\n\n\t\t\tsl[al[n] + M].pb(n);\n\t\t\tsr[ar[n] + M].pb(n);\n\t\t\tbreak;\n\t\t}\n\n\t\tif(!ch) break;\n\t}\n\n\tbool f = 1;\n\tfor(int i = 1; i <= n; i ++) if(!v[i]) {\n\t\t//cout << al[i] << ' ' << ar[i] << '\\n';\n\t\tif(al[i] > 0 && ar[i] > 0) continue;\n\t\tif(al[i] + ar[i] == 0 && !his[al[i] + M]) f = 0;\n\t\tif(al[i] + ar[i] != 0) f = 0;\n\t}\n\tcout << (f ? \"YES\" : \"NO\") << '\\n';\n}"
  },
  {
    "language": "Text",
    "code": "YES\n"
  },
  {
    "language": "Text",
    "code": "YES"
  },
  {
    "language": "C",
    "code": "N,H,a,b,c,d;\nA[201],B[201],C[201],D[201];\ni,x;\nmain(){\n\tscanf(\"%d%d\",&N,&H);\n\tfor(;~scanf(\"%d%d%d%d\",&a,&b,&c,&d);){\n\t\tc?++C[c]:++A[a];\n\t\td?++D[d]:++B[b];\n\t}\n\tfor(i=1;i<=H;++i){\n\t\tif((A[i]-=C[i])<0){x=1;}\n\t\tif((B[i]-=D[i])<0){x=1;}\n\t}\n\tputs(x?\"NO\":\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\n// char s[N_MAX + 1];\nchar s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null din[N_MAX], dout[N_MAX];\n\null parent[N_MAX], size[N_MAX];\nvoid init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t}\n}\null find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = find(parent[x]);\n}\nbool unite (ull a, ull b) {\n\ta = find(a);\n\tb = find(b);\n\tif (a == b) return false;\n\n\tif (size[a] < size[b]) {\n\t\ta ^= b;\n\t\tb ^= a;\n\t\ta ^= b;\n\t}\n\tsize[a] += size[b];\n\tparent[b] = a;\n\treturn true;\n}\n\nconst ull sep = 1000;\n\nbool f (ull v) {\n\tsll i, j;\n\t// sll vs = -1, vg = -1;\n\tsll starts = 0, goals = 0;\n\tfor (i = 0; i <= k; i++) {\n\t\t// if (din[i] || dout[i]) printf(\"%lld: %lld %lld\\n\", i, din[i], dout[i]);\n\t\t// if (din[sep + i] || dout[sep + i]) printf(\"%lld: %lld %lld\\n\", sep + i, din[sep + i], dout[sep + i]);\n\t\tif (find(i) == v) {\n\n\t\t\tif (dout[i] > din[i]) {\n\t\t\t\t// if (vs >= 0) {\n\t\t\t\t// \tgoto fail;\n\t\t\t\t// }\n\t\t\t\t// vs = i;\n\t\t\t\tstarts += (dout[i] - din[i]);\n\t\t\t}\n\t\t\tif (din[i] > dout[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (find(sep + i) == v) {\n\t\t\tif (dout[sep + i] > din[sep + i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (din[sep + i] > dout[sep + i]) {\n\t\t\t\t// if (vg >= 0) {\n\t\t\t\t// \tgoto fail;\n\t\t\t\t// }\n\t\t\t\t// vg = sep + i;\n\t\t\t\tgoals += (din[sep + i] - dout[sep + i]);\n\t\t\t}\n\t\t}\n\t}\n\t// printf(\"%lld %lld\\n\", vs, vg);\n\t// if (vs < 0 || vg < 0) goto fail;\n\tif (!starts) return false;\n\tif (starts != goals) return false;\n\n\treturn true;\n\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tinit(2000);\n\tfor (i = 0; i < n; i++) {\n\t\tull x, y;\n\t\tif (c[i]) {\n\t\t\tx = sep + c[i];\n\t\t} else {\n\t\t\tx = a[i];\n\t\t}\n\n\t\tif (d[i]) {\n\t\t\ty = d[i];\n\t\t} else {\n\t\t\ty = sep + b[i];\n\t\t}\n\t\txy[i] = (hwll){x, y};\n\n\t\t// printf(\"%llu, %llu\\n\", x, y);\n\n\t\t// if (x == y) continue;\n\n\t\tdout[x]++;\n\t\tdin[y]++;\n\n\t\tunite(x, y);\n\t}\n\n\tfor (i = 0; i <= k; i++) {\n\t\tif ((din[i] || dout[i]) && find(i) == i) {\n\t\t\tif (!f(i)) goto fail;\n\t\t}\n\t\tif ((din[sep + i] || dout[sep + i]) && find(sep + i) == sep + i) {\n\t\t\tif (!f(sep + i)) goto fail;\n\t\t}\n\t}\n\n\tgoto success;\n\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\tputs(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\tputs(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\tscanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\tscanf(\"%lld\", &c[i]);\n\t\tscanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// for (i = 0; i < k; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \tscanf(\"%lld\", &d[i]);\n\t// \td[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n\tint a, b;\n\tint c[50000][5] = { 0 };\n\tscanf(\"%d%d\", &a, &b);\n\tint l;\n\tfor (int i = 1; i <= a; i++) {\n\t\tfor (int j = 1; j <= 4; j++)\n\t\t\tscanf(\"%d\", &c[i][j]);\n\t\tl = i ;\n\t}\n\tfor (int i = 1; i <= l; i++) {\n\t\tif (c[i][3] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][2] == c[i][3]&&c[j][3]==0) {\n\t\t\t\t\tc[j][2] = 0;\n\t\t\t\t\tc[i][3] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c[i][4] != 0) {\n\t\t\tfor (int j = 1; j <= l; j++) {\n\t\t\t\tif (c[j][1] == c[i][4]&&c[j][4]==0) {\n\t\t\t\t\tc[j][1] = 0;\n\t\t\t\t\tc[i][4] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tfor (int i = 1; i <= l; i++) {\n\t\tfor (int j = 3; j <= 4; j++)\n\t\t\tif (c[i][j] != 0)\n\t\t\t\tn++;\n\t}\n\tif (n == 0)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tint[] deg;\n\t\n\tvoid addEdge(int v, int u) {\n//\t\tSystem.err.println(v + \" \" + u);\n\t\tdeg[v]--;\n\t\tdeg[u]++;\n\t}\n\t\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint h = nextInt();\n\t\t\n\t\tdeg = new int[2 * (h + 1)];\n\t\t\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = nextInt();\n\t\t\tint b = nextInt();\n\t\t\tint c = nextInt();\n\t\t\tint d = nextInt();\n\t\t\t\n\t\t\tint from;\n\t\t\tif (c == 0) {\n\t\t\t\tfrom = h + 1 + a;\n\t\t\t} else {\n\t\t\t\tfrom = c;\n\t\t\t}\n\t\t\t\n\t\t\tint to;\n\t\t\tif (d == 0) {\n\t\t\t\tto = b;\n\t\t\t} else {\n\t\t\t\tto = h + 1 + d;\n\t\t\t}\n\t\t\t\n\t\t\taddEdge(from, to);\n\t\t}\n\t\t\n\t\tboolean allZero = false;\n\t\tfor (int x : deg) {\n\t\t\tallZero &= x == 0;\n\t\t}\n\t\t\n\t\tif (allZero) {\n\t\t\tout.println(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= h; i++) {\n\t\t\tif (deg[i] < 0) {\n\t\t\t\tout.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = h + 1; i <= 2 * h + 1; i++) {\n\t\t\tif (deg[i] > 0) {\n\t\t\t\tout.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(\"YES\");\n\t\t\n\t}\n\t\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t//stress();\n\t\t//test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int h = in.nextInt();\n            int[][] g = new int[2 * h + 1][2 * h + 1];\n            for (int i = 0; i < n; ++i) {\n                int a = in.nextInt();\n                int b = in.nextInt();\n                int c = in.nextInt();\n                int d = in.nextInt();\n                int left;\n                if (c == 0) {\n                    left = h - a;\n                } else {\n                    left = h + c;\n                }\n                int right;\n                if (d == 0) {\n                    right = h + b;\n                } else {\n                    right = h - d;\n                }\n                ++g[left][right];\n            }\n            int[] outdeg = new int[g.length];\n            int[] indeg = new int[g.length];\n            for (int i = 0; i < g.length; ++i) {\n                for (int j = 0; j < g.length; ++j) {\n                    outdeg[i] += g[i][j];\n                    indeg[j] += g[i][j];\n                }\n            }\n            for (int i = 0; i < h; ++i) {\n                int delta = outdeg[i] - indeg[i];\n                if (delta < 0) {\n                    out.println(\"NO\");\n                    return;\n                }\n                g[0][i] += delta;\n            }\n            for (int i = h + 1; i < g.length; ++i) {\n                int delta = indeg[i] - outdeg[i];\n                if (delta < 0) {\n                    out.println(\"NO\");\n                    return;\n                }\n                g[i][0] += delta;\n            }\n            boolean[] mark = new boolean[g.length];\n            dfs(0, g, mark);\n            for (int i = 0; i < g.length; ++i)\n                if (!mark[i] && outdeg[i] + indeg[i] > 0) {\n                    out.println(\"NO\");\n                    return;\n                }\n            out.println(\"YES\");\n        }\n\n        private void dfs(int i, int[][] g, boolean[] mark) {\n            if (mark[i]) return;\n            mark[i] = true;\n            for (int j = 0; j < g.length; ++j)\n                if (g[i][j] != 0 || g[j][i] != 0) {\n                    dfs(j, g, mark);\n                }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskE {\n\n    ArrayList<Integer>[] g;\n    int h;\n    boolean[] u;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      h = in.nextInt();\n      g = new ArrayList[2 * h + 2];\n      for (int i = 0; i < g.length; ++i) {\n        g[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n; ++i) {\n        int a = in.nextInt();\n        int b = in.nextInt();\n        int c = in.nextInt();\n        int d = in.nextInt();\n        int from = getFrom(c, a);\n        int to = getTo(d, b);\n        g[from].add(to);\n      }\n\n      int cntPlus = 0, cntMinus = 0, vPlus = -1, vMinus = -1;\n      int[] degIn = new int[g.length];\n      for (int i = 0; i < g.length; ++i) {\n        for (int j : g[i]) {\n          degIn[j]++;\n        }\n      }\n      MaxFlowDinic G = new MaxFlowDinic();\n      int S = g.length, T = g.length + 1;\n      G.init(g.length + 2);\n      int need = 0;\n      for (int i = 0; i < g.length; ++i) {\n        int cur = g[i].size() - degIn[i];\n        if (cur == 0) {\n          continue;\n        }\n        if (cur < 0 && i > h) {\n          out.printLine(\"NO\");\n          return;\n        }\n        if (cur > 0 && i <= h) {\n          out.printLine(\"NO\");\n          return;\n        }\n        if (cur > 0) {\n          G.addEdge(S, i, cur);\n          need += cur;\n        } else {\n          G.addEdge(i, T, -cur);\n        }\n      }\n      for (int i = 0; i < g.length; ++i) {\n        for (int j : g[i]) {\n          G.addEdge(i, j, 1);\n        }\n      }\n      int fl = G.maxFlow(S, T);\n      if (fl < need) {\n        out.printLine(\"NO\");\n        return;\n      }\n\n      u = new boolean[g.length];\n      for (int i = 0; i < g.length; ++i) {\n        int cur = g[i].size() - degIn[i];\n        if (cur == 0) {\n          continue;\n        }\n        if (u[i]) {\n          continue;\n        }\n        dfs(i);\n      }\n      for (int i = 0; i < g.length; ++i) {\n        if (g[i].size() > 0 || degIn[i] > 0) {\n          if (!u[i]) {\n            out.printLine(\"NO\");\n            return;\n          }\n        }\n      }\n\n      out.printLine(\"YES\");\n//        for (int i = 0; i < g.length; ++i) {\n//            int cur = g[i].size() - degIn[i];\n//            if (cur == 0) continue;\n//            if (cur < -1 || cur > 1) {\n//                out.printLine(\"NO\");\n//                return;\n//            }\n//            if (cur == -1) {\n//                ++cntMinus;\n//                vMinus = i;\n//            }\n//            else {\n//                vPlus = i;\n//                ++cntPlus;\n//            }\n//        }\n//        if (cntMinus > 1 || cntPlus > 1 || cntMinus != cntPlus) {\n//            out.printLine(\"NO\");\n//            return;\n//        }\n//        if (cntMinus == 0) {\n//            // Cycles don't work?\n//            out.printLine(\"NO\");\n//            return;\n//        }\n//        if (cntMinus == 1) {\n//            if (vPlus <= h || vMinus > h) {\n//                out.printLine(\"NO\");\n//                return;\n//            }\n//\n//            g[vMinus].add(vPlus);\n//        }\n//\n//        boolean[][] d = new boolean[g.length][g.length];\n//        for (int i = 0; i < g.length; ++i) {\n//            d[i][i] = true;\n//            for (int j : g[i]) d[i][j] = true;\n//        }\n//        for (int i = 0; i < g.length; ++i)\n//            for (int j = 0; j < g.length; ++j)\n//                for (int k = 0;k < g.length; ++k)\n//                    if (d[j][i] && d[i][k]) d[j][k] = true;\n//        for (int i = 0; i < g.length; ++i) if (g[i].size() != 0 || degIn[i] != 0)\n//            for (int j = 0; j < g.length; ++j) if (g[j].size() != 0 || degIn[j] != 0)\n//                if (!d[i][j] || !d[j][i]) {\n//                    out.printLine(\"NO\");\n//                    return;\n//                }\n//        out.printLine(\"YES\");\n    }\n\n    private void dfs(int x) {\n      u[x] = true;\n      for (int y : g[x]) {\n        if (!u[y]) {\n          dfs(y);\n        }\n      }\n    }\n\n    private int getTo(int height, int size) {\n      if (height == 0) {\n        return size;\n      }\n      return h + height;\n    }\n\n    private int getFrom(int height, int size) {\n      if (height == 0) {\n        return h + size;\n      }\n      return height;\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n\n  static class MaxFlowDinic {\n\n    public ArrayList<MaxFlowDinic.Edge>[] graph;\n    int src;\n    int dest;\n    int[] ptr;\n    int[] Q;\n    int[] dist;\n\n    public void init(int nodes) {\n      graph = new ArrayList[nodes];\n      for (int i = 0; i < nodes; i++) {\n        graph[i] = new ArrayList<MaxFlowDinic.Edge>();\n      }\n      ptr = new int[nodes];\n      Q = new int[nodes];\n      dist = new int[nodes];\n    }\n\n    public void addEdge(int s, int t, int cap) {\n      graph[s].add(new MaxFlowDinic.Edge(s, t, graph[t].size(), cap));\n      graph[t].add(new MaxFlowDinic.Edge(t, s, graph[s].size() - 1, 0));\n    }\n\n    boolean dinic_bfs() {\n      Arrays.fill(dist, -1);\n      dist[src] = 0;\n      int sizeQ = 0;\n      Q[sizeQ++] = src;\n      for (int i = 0; i < sizeQ; i++) {\n        int u = Q[i];\n        for (MaxFlowDinic.Edge e : graph[u]) {\n          if (dist[e.t] < 0 && e.f < e.cap) {\n            dist[e.t] = dist[u] + 1;\n            Q[sizeQ++] = e.t;\n          }\n        }\n      }\n      return dist[dest] >= 0;\n    }\n\n    int dinic_dfs(int u, int f) {\n      if (u == dest) {\n        return f;\n      }\n      for (; ptr[u] < graph[u].size(); ++ptr[u]) {\n        MaxFlowDinic.Edge e = graph[u].get(ptr[u]);\n        if (dist[e.t] == dist[u] + 1 && e.f < e.cap) {\n          int df = dinic_dfs(e.t, Math.min(f, e.cap - e.f));\n          if (df > 0) {\n            e.f += df;\n            graph[e.t].get(e.rev).f -= df;\n            return df;\n          }\n        }\n      }\n      return 0;\n    }\n\n    public int maxFlow(int src, int dest) {\n      this.src = src;\n      this.dest = dest;\n      int flow = 0;\n      while (dinic_bfs()) {\n        Arrays.fill(ptr, 0);\n        while (true) {\n          int df = dinic_dfs(src, Integer.MAX_VALUE);\n          if (df == 0) {\n            break;\n          }\n          flow += df;\n        }\n      }\n      return flow;\n    }\n\n    static public class Edge {\n\n      public int s;\n      public int t;\n      public int rev;\n      public int cap;\n      public int f;\n\n      public Edge(int s, int t, int rev, int cap) {\n        this.s = s;\n        this.t = t;\n        this.rev = rev;\n        this.cap = cap;\n      }\n\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    int N = sc.nextInt();\n    int H = sc.nextInt();\n    int[][] p = sc.nextIntTable(N, 4);\n    \n    UnionFind uf = new UnionFind(H * 2 + 1);\n    int[] left = new int[H * 2 + 1];\n    int[] right = new int[H * 2 + 1];\n\n    boolean[] node = new boolean[H * 2 + 1];\n    for (int i = 0; i < N; i ++) {\n      int A = p[i][0];\n      int B = p[i][1];\n      int C = p[i][2];\n      int D = p[i][3];\n\n      int X = C == 0 ? A + H : C;\n      int Y = D == 0 ? B : D + H;\n      \n      uf.union(X, Y);\n      left[X] ++;\n      right[Y] ++;\n      node[X] = node[Y] = true;\n    }\n    \n    for (int i = 1; i <= H; i ++) {\n      // C > 0, D == 0\n      if (left[i] > right[i]) { \n        System.out.println(\"NO\");\n        return;\n      } else if (left[i] < right[i]) {\n        uf.union(0, i);\n      }\n    }\n    \n    for (int i = H + 1; i <= H * 2; i ++) {\n      // C == 0, D > 0\n      if (left[i] < right[i]) {\n        System.out.println(\"NO\");\n      } else if (left[i] > right[i]) {\n        uf.union(0, i);\n      }\n    }\n    \n    int root = uf.find(0);\n    for (int i = 0; i <= H * 2; i ++) {\n      if (node[i] && root != uf.find(i)) {\n        System.out.println(\"NO\");\n        return;\n      }\n    }\n    System.out.println(\"YES\");\n  }\n  \n\n}\n\nclass UnionFind {\n  private int[] table;\n  private int[] rank;\n  \n  public UnionFind(int size) {\n      this.table = new int[size];\n      this.rank = new int[size];\n      for (int i = 0; i < size; i ++) {\n          this.table[i] = i;\n          this.rank[i] = 1;\n      }\n  }\n\n  public boolean isSame(int node1, int node2) {\n      return find(node1) == find(node2);\n  }\n\n  public int find(int node) {\n      if (table[node] == node) {\n          return node;\n      } else {\n          return table[node] = find(table[node]);\n      }\n  }\n\n  public void union(int node1, int node2) {\n      int root1 = find(node1);\n      int root2 = find(node2);\n      \n      if (rank[root1] < rank[root2]) {\n          table[root1] = root2;\n      } else if (rank[root1] > rank[root2]) {\n          table[root2] = root1;\n      } else if (root1 != root2) {\n          table[root2] = root1;\n          rank[root1] ++;\n      }\n  }\n}\n\nclass FastScanner {\n  public static String debug = null;\n\n  private final InputStream in = System.in;\n  private int ptr = 0;\n  private int buflen = 0;\n  private byte[] buffer = new byte[1024];\n  private boolean eos = false;\n\n  private boolean hasNextByte() {\n    if (ptr < buflen) {\n      return true;\n    } else {\n      ptr = 0;\n      try {\n        if (debug != null) {\n          buflen = debug.length();\n          buffer = debug.getBytes();\n          debug = \"\";\n          eos = true;\n        } else {\n          buflen = in.read(buffer);\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      if (buflen < 0) {\n        eos = true;\n        return false;\n      } else if (buflen == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private int readByte() {\n    if (hasNextByte())\n      return buffer[ptr++];\n    else\n      return -1;\n  }\n\n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n\n  private void skipUnprintable() {\n    while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n      ptr++;\n  }\n\n  public boolean isEOS() {\n    return this.eos;\n  }\n\n  public boolean hasNext() {\n    skipUnprintable();\n    return hasNextByte();\n  }\n\n  public String next() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    StringBuilder sb = new StringBuilder();\n    int b = readByte();\n    while (isPrintableChar(b)) {\n      sb.appendCodePoint(b);\n      b = readByte();\n    }\n    return sb.toString();\n  }\n\n  public long nextLong() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    long n = 0;\n    boolean minus = false;\n    int b = readByte();\n    if (b == '-') {\n      minus = true;\n      b = readByte();\n    }\n    if (b < '0' || '9' < b) {\n      throw new NumberFormatException();\n    }\n    while (true) {\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n      b = readByte();\n    }\n  }\n\n  public int nextInt() {\n    return (int) nextLong();\n  }\n\n  public long[] nextLongList(int n) {\n    return nextLongTable(1, n)[0];\n  }\n\n  public int[] nextIntList(int n) {\n    return nextIntTable(1, n)[0];\n  }\n\n  public long[][] nextLongTable(int n, int m) {\n    long[][] ret = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextLong();\n      }\n    }\n    return ret;\n  }\n\n  public int[][] nextIntTable(int n, int m) {\n    int[][] ret = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextInt();\n      }\n    }\n    return ret;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    int N = sc.nextInt();\n    int H = sc.nextInt();\n    int[][] p = sc.nextIntTable(N, 4);\n    \n    UnionFind uf = new UnionFind(H * 2 + 1);\n    int[] left = new int[H * 2 + 1];\n    int[] right = new int[H * 2 + 1];\n\n    boolean[] node = new boolean[H * 2 + 1];\n    for (int i = 0; i < N; i ++) {\n      int A = p[i][0];\n      int B = p[i][1];\n      int C = p[i][2];\n      int D = p[i][3];\n\n      int X = C == 0 ? A + H : C;\n      int Y = D == 0 ? B : D + H;\n      \n      uf.union(X, Y);\n      left[X] ++;\n      right[Y] ++;\n      node[X] = node[Y] = true;\n    }\n    \n    for (int i = 1; i <= H; i ++) {\n      // C > 0, D == 0\n      if (left[i] > right[i]) { \n        System.out.println(\"NO\");\n        return;\n      } else if (left[i] < right[i]) {\n        uf.union(0, i);\n      }\n    }\n    \n    for (int i = H; i <= H * 2; i ++) {\n      // C == 0, D > 0\n      if (left[i] < right[i]) {\n        System.out.println(\"NO\");\n      } else if (left[i] > right[i]) {\n        uf.union(0, i);\n      }\n    }\n    \n    int root = uf.find(0);\n    for (int i = 0; i <= H * 2; i ++) {\n      if (node[i] && root != uf.find(i)) {\n        System.out.println(\"NO\");\n        return;\n      }\n    }\n    System.out.println(\"YES\");\n  }\n  \n\n}\n\nclass UnionFind {\n  private int[] table;\n  private int[] rank;\n  \n  public UnionFind(int size) {\n      this.table = new int[size];\n      this.rank = new int[size];\n      for (int i = 0; i < size; i ++) {\n          this.table[i] = i;\n          this.rank[i] = 1;\n      }\n  }\n\n  public boolean isSame(int node1, int node2) {\n      return find(node1) == find(node2);\n  }\n\n  public int find(int node) {\n      if (table[node] == node) {\n          return node;\n      } else {\n          return table[node] = find(table[node]);\n      }\n  }\n\n  public void union(int node1, int node2) {\n      int root1 = find(node1);\n      int root2 = find(node2);\n      \n      if (rank[root1] < rank[root2]) {\n          table[root1] = root2;\n      } else if (rank[root1] > rank[root2]) {\n          table[root2] = root1;\n      } else if (root1 != root2) {\n          table[root2] = root1;\n          rank[root1] ++;\n      }\n  }\n}\n\nclass FastScanner {\n  public static String debug = null;\n\n  private final InputStream in = System.in;\n  private int ptr = 0;\n  private int buflen = 0;\n  private byte[] buffer = new byte[1024];\n  private boolean eos = false;\n\n  private boolean hasNextByte() {\n    if (ptr < buflen) {\n      return true;\n    } else {\n      ptr = 0;\n      try {\n        if (debug != null) {\n          buflen = debug.length();\n          buffer = debug.getBytes();\n          debug = \"\";\n          eos = true;\n        } else {\n          buflen = in.read(buffer);\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      if (buflen < 0) {\n        eos = true;\n        return false;\n      } else if (buflen == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private int readByte() {\n    if (hasNextByte())\n      return buffer[ptr++];\n    else\n      return -1;\n  }\n\n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n\n  private void skipUnprintable() {\n    while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n      ptr++;\n  }\n\n  public boolean isEOS() {\n    return this.eos;\n  }\n\n  public boolean hasNext() {\n    skipUnprintable();\n    return hasNextByte();\n  }\n\n  public String next() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    StringBuilder sb = new StringBuilder();\n    int b = readByte();\n    while (isPrintableChar(b)) {\n      sb.appendCodePoint(b);\n      b = readByte();\n    }\n    return sb.toString();\n  }\n\n  public long nextLong() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    long n = 0;\n    boolean minus = false;\n    int b = readByte();\n    if (b == '-') {\n      minus = true;\n      b = readByte();\n    }\n    if (b < '0' || '9' < b) {\n      throw new NumberFormatException();\n    }\n    while (true) {\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n      b = readByte();\n    }\n  }\n\n  public int nextInt() {\n    return (int) nextLong();\n  }\n\n  public long[] nextLongList(int n) {\n    return nextLongTable(1, n)[0];\n  }\n\n  public int[] nextIntList(int n) {\n    return nextIntTable(1, n)[0];\n  }\n\n  public long[][] nextLongTable(int n, int m) {\n    long[][] ret = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextLong();\n      }\n    }\n    return ret;\n  }\n\n  public int[][] nextIntTable(int n, int m) {\n    int[][] ret = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextInt();\n      }\n    }\n    return ret;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tvoid addEdge(int v, int u, int[] deg) {\n//\t\t System.err.println(v + \" \" + u);\n\t\tdeg[v]--;\n\t\tdeg[u]++;\n\t}\n\t\n\tint[] p;\n\tboolean[] hadEdge;\n\t\n\tint get(int v) {\n\t\treturn p[v] == v ? v : (p[v] = get(p[v]));\n\t}\n\t\n\tvoid unite(int a, int b) {\n\t\ta = get(a);\n\t\tb = get(b);\n\t\thadEdge[a] = hadEdge[b] = true;\n\t\tif (a != b) {\n\t\t\tp[b] = a;\n\t\t}\n\t}\n\n\tboolean fast(int n, int h, int[] as, int[] bs, int[] cs, int[] ds) {\n\t\tint[] deg = new int[2 * (h + 1)];\n\n\t\tp = new int[2 * h + 2];\n\t\thadEdge = new boolean[2 * h + 2];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = i;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = as[i];\n\t\t\tint b = bs[i];\n\t\t\tint c = cs[i];\n\t\t\tint d = ds[i];\n\n\t\t\tint from;\n\t\t\tif (c == 0) {\n\t\t\t\tfrom = h + 1 + a;\n\t\t\t} else {\n\t\t\t\tfrom = c;\n\t\t\t}\n\n\t\t\tint to;\n\t\t\tif (d == 0) {\n\t\t\t\tto = b;\n\t\t\t} else {\n\t\t\t\tto = h + 1 + d;\n\t\t\t}\n\n\t\t\taddEdge(from, to, deg);\n\t\t\tunite(from, to);\n\t\t}\n\n//\t\tSystem.err.println(Arrays.toString(deg));\n//\t\t\n//\t\tboolean allZero = false;\n//\t\tfor (int x : deg) {\n//\t\t\tallZero &= x == 0;\n//\t\t}\n\n//\t\tif (allZero) {\n//\t\t\treturn false;\n//\t\t}\n\t\t\n\t\tHashSet<Integer> setEdges = new HashSet<>();\n\t\t\n\t\tfor (int i = 0; i < 2 * h + 2; i++) {\n\t\t\tif (deg[i] > 0) {\n\t\t\t\tsetEdges.add(get(i));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint shouldBe = 0;\n\t\tfor (int i = 0; i < 2 * h + 2; i++) {\n\t\t\tif (get(i) == i && hadEdge[i]) {\n\t\t\t\tshouldBe++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (shouldBe != setEdges.size()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (int i = 0; i <= h; i++) {\n\t\t\tif (deg[i] < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = h + 1; i <= 2 * h + 1; i++) {\n\t\t\tif (deg[i] > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint h = nextInt();\n\n\t\tint[] as = new int[n];\n\n\t\tint[] bs = new int[n];\n\t\tint[] cs = new int[n];\n\t\tint[] ds = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = nextInt();\n\t\t\tbs[i] = nextInt();\n\t\t\tcs[i] = nextInt();\n\t\t\tds[i] = nextInt();\n\t\t}\n\n\t\tout.println(fast(n, h, as, bs, cs, ds) ? \"YES\" : \"NO\");\n//\t\tout.println(slow(n, h, as, bs, cs, ds) ? \"YES\" : \"NO\");\n\t}\n\t\n\tboolean slow(int n, int h, int[] as, int[] bs, int[] cs, int[] ds) {\n\t\tint[] p = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[i] = i;\n\t\t}\n\t\t\n\t\touter: do {\n\t\t\tif (cs[p[0]] != 0) {\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint l = p[i];\n\t\t\t\tint r = p[i + 1];\n\t\t\t\t\n\t\t\t\tif (ds[l] != 0 && cs[r] != 0) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ds[l] != 0 && as[r] != ds[l]) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (cs[r] != 0 && bs[l] != cs[r]) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif (ds[p[n - 1]] != 0) {\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t} while (nextPermutation(p));\n\t\t\n\t\t\n\t\treturn false;\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tint n = a.length;\n\t\tint ptr = n - 1;\n\t\twhile (ptr > 0 && a[ptr - 1] >= a[ptr]) {\n\t\t\tptr--;\n\t\t}\n\n\t\tfor (int i = ptr, j = n - 1; i < j; i++, j--) {\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = tmp;\n\t\t}\n\t\t\n\t\tif (ptr == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (int i = ptr;; i++) {\n\t\t\tif (a[ptr - 1] < a[i]) {\n\t\t\t\tint tmp = a[ptr - 1];\n\t\t\t\ta[ptr - 1] = a[i];\n\t\t\t\ta[i] = tmp;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvoid preCalc() {\n\n\t}\n\n\tstatic final int B = 4;\n\t\n\tvoid stress() {\n\t\tfor (int tst = 0;;tst++) {\n\t\t\tint n = rand(1, B);\n\t\t\tint h = rand(1, B);\n\t\t\t\n\t\t\tint[] as = new int[n];\n\t\t\tint[] bs = new int[n];\n\t\t\tint[] cs = new int[n];\n\t\t\tint[] ds = new int[n];\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tas[i] = rand(1, h);\n\t\t\t\tbs[i] = rand(1, h);\n\t\t\t\tcs[i] = rand(0, h - as[i]);\n\t\t\t\tds[i] = rand(0, h - bs[i]);\n\t\t\t}\n\t\t\t\n\t\t\tboolean fast = fast(n, h, as, bs, cs, ds);\n\t\t\tboolean slow = slow(n, h, as, bs, cs, ds);\n\t\t\tif (fast != slow) {\n\t\t\t\tSystem.err.println(n + \" \" + h);\n\t\t\t\tSystem.err.println(Arrays.toString(as));\n\t\t\t\tSystem.err.println(Arrays.toString(bs));\n\t\t\t\tSystem.err.println(Arrays.toString(cs));\n\t\t\t\tSystem.err.println(Arrays.toString(ds));\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\t\n\t\t\tSystem.err.println(\"test \" + tst);\n\t\t}\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n//\t\t stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author Pavel Mavrin\n */\npublic class Main {\n\n    private int h;\n    private boolean ok;\n    private int[] dd;\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        h = nextInt();\n        int[] a = new int[n];\n        int[] b = new int[n];\n        int[] c = new int[n];\n        int[] d = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n            b[i] = nextInt();\n            c[i] = nextInt();\n            d[i] = nextInt();\n        }\n\n        int[] l = new int[n];\n        int[] r = new int[n];\n        for (int i = 0; i < n; i++) {\n            l[i] = c[i] == 0 ? h + a[i] : h - c[i];\n            r[i] = d[i] == 0 ? h - b[i] : h + d[i];\n        }\n        dd = new int[2 * h + 1];\n        for (int i = 0; i < n; i++) {\n            dd[l[i]]++;\n            dd[r[i]]--;\n        }\n//        System.out.println(Arrays.toString(l));\n//        System.out.println(Arrays.toString(r));\n//        System.out.println(Arrays.toString(dd));\n\n        for (int i = 0; i < h; i++) {\n            if (dd[i] > 0) {\n                out.println(\"NO\");\n                return;\n            }\n        }\n        for (int i = h + 1; i < 2 * h + 1; i++) {\n            if (dd[i] < 0) {\n                out.println(\"NO\");\n                return;\n            }\n        }\n        init(2 * h + 1, n);\n        for (int i = 0; i < n; i++) {\n            addEdge(l[i], r[i]);\n        }\n        for (int i = 0; i < 2 * h + 1; i++) {\n            if (!z[i] && head[i] != -1) {\n                ok = false;\n                dfs(i);\n                if (!ok) {\n                    out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        out.println(\"YES\");\n    }\n\n    void init(int n, int m) {\n        m *= 2;\n        this.n = n;\n        this.m = m;\n        last = 0;\n        head = new int[n];\n        nx = new int[m];\n        dst = new int[m];\n        src = new int[m];\n        Arrays.fill(head, -1);\n        z = new boolean[n];\n    }\n\n    void addEdge(int x, int y) {\n        nx[last] = head[x];\n        src[last] = x;\n        dst[last] = y;\n        head[x] = last;\n        last++;\n        nx[last] = head[y];\n        src[last] = y;\n        dst[last] = x;\n        head[y] = last;\n        last++;\n    }\n\n    private void dfs(int x) {\n        if (z[x]) return;\n        z[x] = true;\n        if (dd[x] != 0) {\n            ok = true;\n        }\n        int j = head[x];\n        while (j >= 0) {\n            int y = dst[j];\n            dfs(y);\n            j = nx[j];\n        }\n    }\n\n    int n, m;\n    int[] head;\n    int[] nx;\n    int[] src;\n    int[] dst;\n    boolean[] z;\n    int last;\n\n    // ------------------\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st;\n    PrintWriter out = new PrintWriter(System.out);\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private void run() throws IOException {\n        solve();\n        out.close();\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.agc.agc017;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int h = in.nextInt();\n        int[][] abcd = in.nextIntTable(n, 4);\n\n        if (solve(h, abcd)) {\n            out.println(\"YES\");\n        } else {\n            out.println(\"NO\");\n        }\n        out.flush();\n    }\n\n    static boolean solve(int h, int[][] abcd) {\n        int n = abcd.length;\n\n        int[][] graph = new int[410][410];\n        int[] gin = new int[410];\n        int[] gout = new int[410];\n        for (int i = 0 ; i < n ; i++) {\n            int l = abcd[i][2] == 0 ? h - abcd[i][0] : h + abcd[i][2];\n            int r = abcd[i][3] == 0 ? h + abcd[i][1] : h - abcd[i][3];\n            graph[l][r]++;\n            gin[l]++;\n            gout[r]++;\n        }\n\n        for (int i = 0 ; i < h ; i++) {\n            if (gin[i] < gout[i]) {\n                return false;\n            }\n            if (gin[i] > gout[i]) {\n                graph[409][i] = 1;\n            }\n        }\n        for (int i = h+1 ; i < 2*h+1 ; i++) {\n            if (gin[i] > gout[i]) {\n                return false;\n            }\n            if (gin[i] < gout[i]) {\n                graph[i][409] = 1;\n            }\n        }\n\n        boolean[] v = new boolean[graph.length];\n        dfs(409, graph, v);\n\n        for (int i = 0; i < graph.length ; i++) {\n            if (!v[i] && gin[i] + gout[i] >= 1) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    static void dfs(int now, int[][] graph, boolean[] v) {\n        if (v[now]) {\n            return;\n        }\n        v[now] = true;\n        for (int i = 0; i < graph.length ; i++) {\n            if (graph[now][i] >= 1) {\n                dfs(i, graph, v);\n            }\n        }\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author Pavel Mavrin\n */\npublic class Main {\n\n    private int h;\n    private boolean ok;\n    private int[] dd;\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        h = nextInt();\n        int[] a = new int[n];\n        int[] b = new int[n];\n        int[] c = new int[n];\n        int[] d = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n            b[i] = nextInt();\n            c[i] = nextInt();\n            d[i] = nextInt();\n        }\n\n        int[] l = new int[n];\n        int[] r = new int[n];\n        for (int i = 0; i < n; i++) {\n            l[i] = c[i] == 0 ? h + a[i] : h - c[i];\n            r[i] = d[i] == 0 ? h - b[i] : h + d[i];\n        }\n        dd = new int[2 * h];\n        for (int i = 0; i < n; i++) {\n            dd[l[i]]++;\n            dd[r[i]]--;\n        }\n\n        for (int i = 0; i < h; i++) {\n            if (dd[i] > 0) {\n                out.println(\"NO\");\n                return;\n            }\n        }\n        for (int i = h + 1; i < 2 * h; i++) {\n            if (dd[i] < 0) {\n                out.println(\"NO\");\n                return;\n            }\n        }\n        init(2 * h, n);\n        for (int i = 0; i < n; i++) {\n            addEdge(l[i], r[i]);\n        }\n        for (int i = 0; i < 2 * h; i++) {\n            if (!z[i] && head[i] != -1) {\n                ok = false;\n                dfs(i);\n                if (!ok) {\n                    out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        out.println(\"YES\");\n    }\n\n    void init(int n, int m) {\n        m *= 2;\n        this.n = n;\n        this.m = m;\n        last = 0;\n        head = new int[n];\n        nx = new int[m];\n        dst = new int[m];\n        src = new int[m];\n        Arrays.fill(head, -1);\n        z = new boolean[n];\n    }\n\n    void addEdge(int x, int y) {\n        nx[last] = head[x];\n        src[last] = x;\n        dst[last] = y;\n        head[x] = last;\n        last++;\n        nx[last] = head[y];\n        src[last] = y;\n        dst[last] = x;\n        head[y] = last;\n        last++;\n    }\n\n    private void dfs(int x) {\n        if (z[x]) return;\n        z[x] = true;\n        if (dd[x] != 0) {\n            ok = true;\n        }\n        int j = head[x];\n        while (j >= 0) {\n            int y = dst[j];\n            dfs(y);\n            j = nx[j];\n        }\n    }\n\n    int n, m;\n    int[] head;\n    int[] nx;\n    int[] src;\n    int[] dst;\n    boolean[] z;\n    int last;\n\n    // ------------------\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st;\n    PrintWriter out = new PrintWriter(System.out);\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private void run() throws IOException {\n        solve();\n        out.close();\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint m = ni(), h = ni();\n\t\t// 0-1~h\n\t\t// 1~h-\n\t\t\n\t\tint[] from = new int[m];\n\t\tint[] to = new int[m];\n\t\tint p = 0;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a = ni(), b = ni(), c = ni(), d = ni();\n\t\t\tif(c == 0){\n\t\t\t\tfrom[p] = a;\n\t\t\t}else{\n\t\t\t\tfrom[p] = c+h+1;\n\t\t\t}\n\t\t\tif(d == 0){\n\t\t\t\tto[p] = b+h+1;\n\t\t\t}else{\n\t\t\t\tto[p] = d;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tint[][] g = packD(2*h+2, from, to);\n\t\tint[][] ig = packD(2*h+2, to, from);\n\t\tDJSet ds = new DJSet(2*h+2);\n\t\tboolean[] touched = new boolean[2*h+2];\n\t\tfor(int i = 0;i < from.length;i++){\n\t\t\tds.union(from[i], to[i]);\n\t\t\ttouched[from[i]] = true;\n\t\t\ttouched[to[i]] = true;\n\t\t}\n\t\t\n\t\tboolean[] ok = new boolean[2*h+2];\n\t\tfor(int i = 1;i <= 2*h;i++){\n\t\t\tif(g[i].length != ig[i].length){\n\t\t\t\tif(i <= h && g[i].length - ig[i].length > 0){\n\t\t\t\t\tok[ds.root(i)] = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i > h && g[i].length - ig[i].length < 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tout.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < 2*h+2;i++){\n\t\t\tif(ds.upper[i] < 0 && touched[i]){\n\t\t\t\tif(!ok[i]){\n\t\t\t\t\tout.println(\"NO\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(\"YES\");\n\t}\n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\t\n\tstatic int[][] packD(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    int N = sc.nextInt();\n    int H = sc.nextInt();\n    int[][] p = sc.nextIntTable(N, 4);\n    \n    UnionFind uf = new UnionFind(2000);\n    int[] left = new int[2000];\n    int[] right = new int[2000];\n\n    boolean[] node = new boolean[2000];\n    for (int i = 0; i < N; i ++) {\n      int A = p[i][0];\n      int B = p[i][1];\n      int C = p[i][2];\n      int D = p[i][3];\n\n      int X = C == 0 ? A + 1000 : C;\n      int Y = D == 0 ? B : D + 1000;\n      \n      uf.union(X, Y);\n      left[X] ++;\n      right[Y] ++;\n      node[X] = node[Y] = true;\n    }\n    \n    for (int i = 1; i < 1000; i ++) {\n      // C > 0, D == 0\n      if (left[i] > right[i]) { \n        System.out.println(\"NO\");\n        return;\n      } else if (left[i] < right[i]) {\n        uf.union(0, i);\n      }\n    }\n    \n    for (int i = 1000; i < 2000; i ++) {\n      // C == 0, D > 0\n      if (left[i] < right[i]) {\n        System.out.println(\"NO\");\n      } else if (left[i] > right[i]) {\n        uf.union(0, i);\n      }\n    }\n    \n    int root = uf.find(0);\n    for (int i = 0; i < 2000; i ++) {\n      if (node[i] && root != uf.find(i)) {\n        System.out.println(\"NO\");\n        return;\n      }\n    }\n    System.out.println(\"YES\");\n  }\n  \n\n}\n\nclass UnionFind {\n  private int[] table;\n  private int[] rank;\n  \n  public UnionFind(int size) {\n      this.table = new int[size];\n      this.rank = new int[size];\n      for (int i = 0; i < size; i ++) {\n          this.table[i] = i;\n          this.rank[i] = 1;\n      }\n  }\n\n  public boolean isSame(int node1, int node2) {\n      return find(node1) == find(node2);\n  }\n\n  public int find(int node) {\n      if (table[node] == node) {\n          return node;\n      } else {\n          return table[node] = find(table[node]);\n      }\n  }\n\n  public void union(int node1, int node2) {\n      int root1 = find(node1);\n      int root2 = find(node2);\n      \n      if (rank[root1] < rank[root2]) {\n          table[root1] = root2;\n      } else if (rank[root1] > rank[root2]) {\n          table[root2] = root1;\n      } else if (root1 != root2) {\n          table[root2] = root1;\n          rank[root1] ++;\n      }\n  }\n}\n\nclass FastScanner {\n  public static String debug = null;\n\n  private final InputStream in = System.in;\n  private int ptr = 0;\n  private int buflen = 0;\n  private byte[] buffer = new byte[1024];\n  private boolean eos = false;\n\n  private boolean hasNextByte() {\n    if (ptr < buflen) {\n      return true;\n    } else {\n      ptr = 0;\n      try {\n        if (debug != null) {\n          buflen = debug.length();\n          buffer = debug.getBytes();\n          debug = \"\";\n          eos = true;\n        } else {\n          buflen = in.read(buffer);\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      if (buflen < 0) {\n        eos = true;\n        return false;\n      } else if (buflen == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private int readByte() {\n    if (hasNextByte())\n      return buffer[ptr++];\n    else\n      return -1;\n  }\n\n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n\n  private void skipUnprintable() {\n    while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n      ptr++;\n  }\n\n  public boolean isEOS() {\n    return this.eos;\n  }\n\n  public boolean hasNext() {\n    skipUnprintable();\n    return hasNextByte();\n  }\n\n  public String next() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    StringBuilder sb = new StringBuilder();\n    int b = readByte();\n    while (isPrintableChar(b)) {\n      sb.appendCodePoint(b);\n      b = readByte();\n    }\n    return sb.toString();\n  }\n\n  public long nextLong() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    long n = 0;\n    boolean minus = false;\n    int b = readByte();\n    if (b == '-') {\n      minus = true;\n      b = readByte();\n    }\n    if (b < '0' || '9' < b) {\n      throw new NumberFormatException();\n    }\n    while (true) {\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n      b = readByte();\n    }\n  }\n\n  public int nextInt() {\n    return (int) nextLong();\n  }\n\n  public long[] nextLongList(int n) {\n    return nextLongTable(1, n)[0];\n  }\n\n  public int[] nextIntList(int n) {\n    return nextIntTable(1, n)[0];\n  }\n\n  public long[][] nextLongTable(int n, int m) {\n    long[][] ret = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextLong();\n      }\n    }\n    return ret;\n  }\n\n  public int[][] nextIntTable(int n, int m) {\n    int[][] ret = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextInt();\n      }\n    }\n    return ret;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.agc.agc017;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int h = in.nextInt();\n        int[][] abcd = in.nextIntTable(n, 4);\n\n        if (solve(h, abcd)) {\n            out.println(\"YES\");\n        } else {\n            out.println(\"NO\");\n        }\n        out.flush();\n    }\n\n    static boolean solve(int h, int[][] abcd) {\n        int n = abcd.length;\n\n        // pl,mi\n        int[][] gin = new int[h+1][2];\n        int[][] gout = new int[h+1][2];\n        for (int i = 0 ; i < n ; i++) {\n            if (abcd[i][2] == 0 && abcd[i][3] > 0) {\n                gin[abcd[i][0]][1]++;\n                gout[abcd[i][3]][1]++;\n            } else if (abcd[i][2] > 0 && abcd[i][3] == 0) {\n                gin[abcd[i][2]][0]++;\n                gout[abcd[i][1]][0]++;\n            } else if (abcd[i][2] == 0 && abcd[i][3] == 0) {\n                gin[abcd[i][0]][1]++;\n                gout[abcd[i][1]][0]++;\n            } else {\n                gin[abcd[i][2]][0]++;\n                gout[abcd[i][3]][1]++;\n            }\n        }\n\n        boolean possible = false;\n        for (int i = 0 ; i < n ; i++) {\n            if (abcd[i][2] == 0) {\n                boolean isOK = true;\n                gin[abcd[i][0]][1]--;\n                for (int x = 1 ; x <= h ; x++) {\n                    if (gin[x][1] < gout[x][1]) {\n                        isOK = false;\n                    }\n                    if (gin[x][0] > gout[x][0]) {\n                        isOK = false;\n                    }\n                }\n                gin[abcd[i][0]][1]++;\n                possible |= isOK;\n            }\n        }\n        return possible;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    int N = sc.nextInt();\n    int H = sc.nextInt();\n    int[][] p = sc.nextIntTable(N, 4);\n    \n    UnionFind uf = new UnionFind(2000);\n    int[] left = new int[2000];\n    int[] right = new int[2000];\n\n    boolean[] node = new boolean[2000];\n    for (int i = 0; i < N; i ++) {\n      int A = p[i][0];\n      int B = p[i][1];\n      int C = p[i][2];\n      int D = p[i][3];\n\n      int X = C == 0 ? A + 1000 : C;\n      int Y = D == 0 ? B : D + 1000;\n      \n      uf.union(X, Y);\n      left[X] ++;\n      right[Y] ++;\n      node[X] = node[Y] = true;\n    }\n    \n    for (int i = 1; i < 1000; i ++) {\n      // C > 0, D == 0\n      if (left[i] > right[i]) { \n        System.out.println(\"NO\");\n        return;\n      } else if (left[i] < right[i]) {\n        uf.union(0, i);\n      }\n    }\n    \n    for (int i = 1000; i < 2000; i ++) {\n      // C == 0, D > 0\n      if (left[i] < right[i]) {\n        System.out.println(\"NO\");\n        return;\n      } else if (left[i] > right[i]) {\n        uf.union(0, i);\n      }\n    }\n    \n    int root = uf.find(0);\n    for (int i = 0; i < 2000; i ++) {\n      if (node[i] && root != uf.find(i)) {\n        System.out.println(\"NO\");\n        return;\n      }\n    }\n    System.out.println(\"YES\");\n  }\n  \n\n}\n\nclass UnionFind {\n  private int[] table;\n  private int[] rank;\n  \n  public UnionFind(int size) {\n      this.table = new int[size];\n      this.rank = new int[size];\n      for (int i = 0; i < size; i ++) {\n          this.table[i] = i;\n          this.rank[i] = 1;\n      }\n  }\n\n  public boolean isSame(int node1, int node2) {\n      return find(node1) == find(node2);\n  }\n\n  public int find(int node) {\n      if (table[node] == node) {\n          return node;\n      } else {\n          return table[node] = find(table[node]);\n      }\n  }\n\n  public void union(int node1, int node2) {\n      int root1 = find(node1);\n      int root2 = find(node2);\n      \n      if (rank[root1] < rank[root2]) {\n          table[root1] = root2;\n      } else if (rank[root1] > rank[root2]) {\n          table[root2] = root1;\n      } else if (root1 != root2) {\n          table[root2] = root1;\n          rank[root1] ++;\n      }\n  }\n}\n\nclass FastScanner {\n  public static String debug = null;\n\n  private final InputStream in = System.in;\n  private int ptr = 0;\n  private int buflen = 0;\n  private byte[] buffer = new byte[1024];\n  private boolean eos = false;\n\n  private boolean hasNextByte() {\n    if (ptr < buflen) {\n      return true;\n    } else {\n      ptr = 0;\n      try {\n        if (debug != null) {\n          buflen = debug.length();\n          buffer = debug.getBytes();\n          debug = \"\";\n          eos = true;\n        } else {\n          buflen = in.read(buffer);\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      if (buflen < 0) {\n        eos = true;\n        return false;\n      } else if (buflen == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private int readByte() {\n    if (hasNextByte())\n      return buffer[ptr++];\n    else\n      return -1;\n  }\n\n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n\n  private void skipUnprintable() {\n    while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n      ptr++;\n  }\n\n  public boolean isEOS() {\n    return this.eos;\n  }\n\n  public boolean hasNext() {\n    skipUnprintable();\n    return hasNextByte();\n  }\n\n  public String next() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    StringBuilder sb = new StringBuilder();\n    int b = readByte();\n    while (isPrintableChar(b)) {\n      sb.appendCodePoint(b);\n      b = readByte();\n    }\n    return sb.toString();\n  }\n\n  public long nextLong() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    long n = 0;\n    boolean minus = false;\n    int b = readByte();\n    if (b == '-') {\n      minus = true;\n      b = readByte();\n    }\n    if (b < '0' || '9' < b) {\n      throw new NumberFormatException();\n    }\n    while (true) {\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n      b = readByte();\n    }\n  }\n\n  public int nextInt() {\n    return (int) nextLong();\n  }\n\n  public long[] nextLongList(int n) {\n    return nextLongTable(1, n)[0];\n  }\n\n  public int[] nextIntList(int n) {\n    return nextIntTable(1, n)[0];\n  }\n\n  public long[][] nextLongTable(int n, int m) {\n    long[][] ret = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextLong();\n      }\n    }\n    return ret;\n  }\n\n  public int[][] nextIntTable(int n, int m) {\n    int[][] ret = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextInt();\n      }\n    }\n    return ret;\n  }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing static System.Math;\nusing Number = System.Int32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            var n = ri;\n            var h = sc.Integer() + 1;\n            var deg = new int[2 * h];\n            var set = new DisjointSet(2 * h);\n            for (int i = 0; i < n; i++)\n            {\n                var a = ri; var b = ri; var c = ri; var d = ri;\n                if (c == 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{a} {b + h}\");\n                    deg[a]++; deg[b + h]--; set.Unite(a, b + h);\n                }\n                else if (c != 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{c + h} {b + h}\");\n                    deg[c + h]++; deg[b + h]--; set.Unite(c + h, b + h);\n                }\n                else if (c == 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{a} {d}\");\n                    deg[a]++; deg[d]--; set.Unite(a, d);\n                }\n                else if (c != 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{c + h} {d}\");\n                    deg[c + h]++; deg[d]--; set.Unite(c + h, d);\n                }\n                else throw new Exception();\n            }\n            Debug.WriteLine(deg.AsJoinedString());\n            var fail = false;\n            fail |= deg.All(x => x == 0);\n            fail |= deg.Take(h).Min() < 0;\n            fail |= deg.Skip(h).Max() > 0;\n\n            for (int i = 0; i < h; i++)\n            {\n                var k = -deg[i + h];\n                if (k == 0) continue;\n                for (int j = 0; j < h; j++)\n                {\n                    var mi = Math.Min(deg[j], k);\n                    deg[j] -= mi;\n                    k -= mi;\n                }\n                fail |= k != 0;\n                deg[i + h] = k;\n            }\n            Debug.WriteLine(deg.AsJoinedString());\n            fail |= deg.Any(x => x != 0);\n            var cnt = 0;\n            for (int i = 0; i < h; i++)\n                if (set[i] == i && set.Size(i) != 1) cnt++;\n            fail |= cnt > 1;\n            if (fail)\n                Console.WriteLine(\"NO\");\n            else Console.WriteLine(\"YES\");\n\n        }\n\n        const long INF = 5L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing static System.Math;\nusing Number = System.Int32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            var n = ri;\n            var h = sc.Integer() + 1;\n            var deg = new int[2 * h];\n            var set = new DisjointSet(2 * h);\n            for (int i = 0; i < n; i++)\n            {\n                var a = ri; var b = ri; var c = ri; var d = ri;\n                if (c == 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{a} {b + h}\");\n                    deg[a]++; deg[b + h]--; set.Unite(a, b + h);\n                }\n                else if (c != 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{c + h} {b + h}\");\n                    deg[c + h]++; deg[b + h]--; set.Unite(c + h, b + h);\n                }\n                else if (c == 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{a} {d}\");\n                    deg[a]++; deg[d]--; set.Unite(a, d);\n                }\n                else if (c != 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{c + h} {d}\");\n                    deg[c + h]++; deg[d]--; set.Unite(c + h, d);\n                }\n                else throw new Exception();\n            }\n            Debug.WriteLine(deg.AsJoinedString());\n            var fail = false;\n            fail |= deg.All(x => x == 0);\n            fail |= deg.Take(h).Min() < 0;\n            fail |= deg.Skip(h).Max() > 0;\n\n            for (int i = 0; i < h; i++)\n            {\n                var k = -deg[i + h];\n                if (k == 0) continue;\n                for (int j = 0; j < h; j++)\n                {\n                    var mi = Math.Min(deg[j], k);\n                    deg[j] -= mi;\n                    k -= mi;\n                    set.Unite(i + h, j);\n                }\n                fail |= k != 0;\n                deg[i + h] = k;\n            }\n            Debug.WriteLine(deg.AsJoinedString());\n            fail |= deg.Any(x => x != 0);\n            var cnt = 0;\n            for (int i = 0; i < 2 * h; i++)\n                if (set[i] == i && set.Size(i) != 1) cnt++;\n            fail |= cnt > 1;\n            if (fail)\n                Console.WriteLine(\"NO\");\n            else Console.WriteLine(\"YES\");\n\n        }\n\n        const long INF = 5L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing static System.Math;\nusing Number = System.Int32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            var n = ri;\n            var h = sc.Integer() + 1;\n            var deg = new int[2 * h];\n            var set = new DisjointSet(2 * h);\n            for (int i = 0; i < n; i++)\n            {\n                var a = ri; var b = ri; var c = ri; var d = ri;\n                if (c == 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{a} {b + h}\");\n                    deg[a]++; deg[b + h]--; set.Unite(a, b + h);\n                }\n                else if (c != 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{c + h} {b + h}\");\n                    deg[c + h]++; deg[b + h]--; set.Unite(c + h, b + h);\n                }\n                else if (c == 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{a} {d}\");\n                    deg[a]++; deg[d]--; set.Unite(a, d);\n                }\n                else if (c != 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{c + h} {d}\");\n                    deg[c + h]++; deg[d]--; set.Unite(c + h, d);\n                }\n                else throw new Exception();\n            }\n            var fail = false;\n            fail |= deg.All(x => x == 0);\n            fail |= deg.Take(h).Min() < 0;\n            fail |= deg.Skip(h).Max() > 0;\n\n            var cnt = 0;\n            for (int i = 0; i < h; i++)\n                if (set[i] == i && set.Size(i) != 1) cnt++;\n            fail |= cnt > 1;\n            if (fail)\n                Console.WriteLine(\"NO\");\n            else Console.WriteLine(\"YES\");\n\n        }\n\n        const long INF = 5L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing static System.Math;\nusing Number = System.Int32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            var n = ri;\n            var h = sc.Integer() + 1;\n            var deg = new int[2 * h];\n            var set = new DisjointSet(2 * h + 1);\n            for (int i = 0; i < n; i++)\n            {\n                var a = ri; var b = ri; var c = ri; var d = ri;\n                if (c == 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{a} {b + h}\");\n                    deg[a]++; deg[b + h]--; set.Unite(a, b + h);\n                }\n                else if (c != 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{c + h} {b + h}\");\n                    deg[c + h]++; deg[b + h]--; set.Unite(c + h, b + h);\n                }\n                else if (c == 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{a} {d}\");\n                    deg[a]++; deg[d]--; set.Unite(a, d);\n                }\n                else if (c != 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{c + h} {d}\");\n                    deg[c + h]++; deg[d]--; set.Unite(c + h, d);\n                }\n                else throw new Exception();\n            }\n            Debug.WriteLine(deg.AsJoinedString());\n            var fail = false;\n            fail |= deg.All(x => x == 0);\n            fail |= deg.Take(h).Min() < 0;\n            fail |= deg.Skip(h).Max() > 0;\n\n            for (int i = 0; i < h; i++)\n            {\n                var k = -deg[i + h];\n                if (k == 0) continue;\n                for (int j = 0; j < h; j++)\n                {\n                    var mi = Math.Min(deg[j], k);\n                    if (mi == 0) continue;\n                    deg[j] -= mi;\n                    k -= mi;\n                    set.Unite(i + h, 2 * h);\n                    set.Unite(j, 2 * h);\n                }\n                fail |= k != 0;\n                deg[i + h] = k;\n            }\n            Debug.WriteLine(deg.AsJoinedString());\n            fail |= deg.Any(x => x != 0);\n            var cnt = 0;\n            for (int i = 0; i <= 2 * h; i++)\n            {\n                if (set[i] == i && set.Size(i) != 1) cnt++;\n                //if (set[i] == i) { Console.WriteLine($\"{i} {set.Size(i)}\"); }\n            }\n\n            fail |= cnt > 1;\n            if (fail)\n                Console.WriteLine(\"NO\");\n            else Console.WriteLine(\"YES\");\n\n        }\n\n        const long INF = 5L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion\t\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    bool[] us;\n    List<int>[] G;\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int N = int.Parse(str[0]);\n        int H = int.Parse(str[1]);\n        G = new List<int>[N+2*H];\n        for(int i=0;i<G.Length;i++){\n            G[i] = new List<int>();\n        }\n        int[] I = new int[2*H];\n        int[] O = new int[2*H];\n        for(int i=0;i<N;i++){\n            str = Console.ReadLine().Split(' ');\n            int a = int.Parse(str[0]);\n            int b = int.Parse(str[1]);\n            int c = int.Parse(str[2]);\n            int d = int.Parse(str[3]);\n            if(c == 0){\n                G[a-1].Add(i+2*H);\n                O[a-1]++;\n            }\n            else{\n                G[c-1+H].Add(i+2*H);\n                O[c-1+H]++;\n            }\n            if(d == 0){\n                G[i+2*H].Add(b-1+H);\n                I[b-1+H]++;\n            }\n            else{\n                G[i+2*H].Add(d-1);\n                I[d-1]++;\n            }\n        }\n        bool ans = true;\n        for(int i=0;i<H;i++){\n            ans &= O[i] >= I[i];\n        }\n        for(int i=H;i<2*H;i++){\n            ans &= O[i] <= I[i];\n        }\n        us = new bool[N+2*H];\n        for(int i=0;i<H;i++){\n            if(O[i] > I[i]){\n                dfs(i);\n            }\n        }\n        for(int i=2*H;i<2*H+N;i++){\n            ans &= us[i];\n        }\n        if(ans){\n            sb.Append(\"YES\\n\");\n        }\n        else{\n            sb.Append(\"NO\\n\");\n        }\n    }\n    void dfs(int v){\n        if(us[v]){\n            return;\n        }\n        us[v] = true;\n        for(int i=0;i<G[v].Count;i++){\n            int t = G[v][i];\n            if(!us[t]){\n                dfs(t);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing static System.Math;\nusing Number = System.Int32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            var n = ri;\n            var h = sc.Integer() + 1;\n            var deg = new int[2 * h];\n            var set = new DisjointSet(2 * h + 1);\n            for (int i = 0; i < n; i++)\n            {\n                var a = ri; var b = ri; var c = ri; var d = ri;\n                if (c == 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{a} {b + h}\");\n                    deg[a]++; deg[b + h]--; set.Unite(a, b + h);\n                }\n                else if (c != 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{c + h} {b + h}\");\n                    deg[c + h]++; deg[b + h]--; set.Unite(c + h, b + h);\n                }\n                else if (c == 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{a} {d}\");\n                    deg[a]++; deg[d]--; set.Unite(a, d);\n                }\n                else if (c != 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{c + h} {d}\");\n                    deg[c + h]++; deg[d]--; set.Unite(c + h, d);\n                }\n                else throw new Exception();\n            }\n            Debug.WriteLine(deg.AsJoinedString());\n            var fail = false;\n            fail |= deg.All(x => x == 0);\n            fail |= deg.Take(h).Min() < 0;\n            fail |= deg.Skip(h).Max() > 0;\n\n            for (int i = 0; i < h; i++)\n            {\n                var k = -deg[i + h];\n                if (k == 0) continue;\n                for (int j = 0; j < h; j++)\n                {\n                    var mi = Math.Min(deg[j], k);\n                    if (mi == 0) continue;\n                    deg[j] -= mi;\n                    k -= mi;\n                    set.Unite(i + h, 2 * h);\n                    set.Unite(j, 2 * h);\n                }\n                fail |= k != 0;\n                deg[i + h] = k;\n            }\n            Debug.WriteLine(deg.AsJoinedString());\n            fail |= deg.Any(x => x != 0);\n            var cnt = 0;\n            for (int i = 0; i <= 2 * h; i++)\n            {\n                if (set[i] == i && set.Size(i) != 1) cnt++;\n                if (set[i] == i) { Console.WriteLine($\"{i} {set.Size(i)}\"); }\n            }\n\n            fail |= cnt > 1;\n            if (fail)\n                Console.WriteLine(\"NO\");\n            else Console.WriteLine(\"YES\");\n\n        }\n\n        const long INF = 5L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing static System.Math;\nusing Number = System.Int32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            var n = ri; var h = ri + 1;\n            var deg = new int[2 * h];\n            var s = new DisjointSet(2 * h + 1);\n            for (int i = 0; i < n; i++)\n            {\n                var a = ri; var b = ri; var c = ri; var d = ri;\n                var f = c == 0 ? a : c + h;\n                var t = d == 0 ? b + h : d;\n                deg[f]++; deg[t]--;\n                s.Unite(f, t);\n            }\n            var fail = false;\n            fail |= deg.All(x => x == 0);\n            for (int i = 0; i < h; i++)\n            {\n                var k = -deg[i + h];\n                if (k > 0)\n                {\n                    for (int j = 0; j < h; j++)\n                    {\n                        if (deg[j] > 0 && k > 0)\n                        {\n                            var mi = Math.Min(deg[j], k);\n                            deg[j] -= mi;\n                            k -= mi;\n                            s.Unite(j, 2 * h); s.Unite(i + h, 2 * h);\n                        }\n                    }\n                    deg[i + h] = -k;\n                }\n\n            }\n            fail |= deg.Any(x => x != 0);\n            fail |= Enumerate(2 * h + 1, x => x).Count(x => s[x] == x && s.Size(x) > 1) > 1;\n            Debug.WriteLine(deg.AsJoinedString());\n            if (fail) Console.WriteLine(\"NO\");\n            else Console.WriteLine(\"YES\");\n        }\n\n        const long INF = 5L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing static System.Math;\nusing Number = System.Int32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            var n = ri;\n            var h = sc.Integer() + 1;\n            var deg = new int[2 * h];\n            var set = new DisjointSet(2 * h + 1);\n            for (int i = 0; i < n; i++)\n            {\n                var a = ri; var b = ri; var c = ri; var d = ri;\n                if (c == 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{a} {b + h}\");\n                    deg[a]++; deg[b + h]--; set.Unite(a, b + h);\n                }\n                else if (c != 0 && d == 0)\n                {\n                    //Console.WriteLine($\"{c + h} {b + h}\");\n                    deg[c + h]++; deg[b + h]--; set.Unite(c + h, b + h);\n                }\n                else if (c == 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{a} {d}\");\n                    deg[a]++; deg[d]--; set.Unite(a, d);\n                }\n                else if (c != 0 && d != 0)\n                {\n                    //Console.WriteLine($\"{c + h} {d}\");\n                    deg[c + h]++; deg[d]--; set.Unite(c + h, d);\n                }\n                else throw new Exception();\n            }\n            Debug.WriteLine(deg.AsJoinedString());\n            var fail = false;\n            fail |= deg.All(x => x == 0);\n            fail |= deg.Take(h).Min() < 0;\n            fail |= deg.Skip(h).Max() > 0;\n\n            for (int i = 0; i < h; i++)\n            {\n                var k = -deg[i + h];\n                if (k == 0) continue;\n                for (int j = 0; j < h; j++)\n                {\n                    var mi = Math.Min(deg[j], k);\n                    deg[j] -= mi;\n                    k -= mi;\n                    set.Unite(i + h, 2 * h);\n                    set.Unite(j, 2 * h);\n                }\n                fail |= k != 0;\n                deg[i + h] = k;\n            }\n            Debug.WriteLine(deg.AsJoinedString());\n            fail |= deg.Any(x => x != 0);\n            var cnt = 0;\n            for (int i = 0; i <= 2 * h; i++)\n                if (set[i] == i && set.Size(i) != 1) cnt++;\n            fail |= cnt > 1;\n            if (fail)\n                Console.WriteLine(\"NO\");\n            else Console.WriteLine(\"YES\");\n\n        }\n\n        const long INF = 5L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion\t\n"
  },
  {
    "language": "PHP",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii; \n\nint main(int argc, char const *argv[]) {\n    puts(\"YES\"); \n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n// import dcomp.datastructure.unionfind;\nint main() {\n    auto sc = new Scanner(stdin);\n    int m, h;\n    sc.read(m, h);\n    int n = 2*h+2;\n    int[][] g = new int[][](n, n);\n    int id(int x, int y) {\n        if (y == 0) return (x-1) * 2; //(o, x-1)\n        return (y-1)*2 + 1; //(□, y-1)\n    }\n    foreach (i; 0..m) {\n        int a, b, c, d;\n        sc.read(a, b, c, d);\n        int l = id(a, c);\n        int r = id(b, d) ^ 1;\n        debug writeln(l, \" \", r);\n        g[l][r]++;\n    }\n\n    debug foreach (i; 0..n) {\n        write(i, \" \");\n        write(iota(n).map!(x => g[i][x]).sum);\n        write(\" \");\n        write(iota(n).map!(x => g[x][i]).sum);\n        writeln();\n    }\n\n    foreach (i; 0..n-2) {\n        int ic = iota(n).map!(x => g[i][x]).sum;\n        int jc = iota(n).map!(x => g[x][i]).sum;\n        if (i % 2 == 0) {\n            //left\n            if (ic < jc) {\n                writeln(\"NO\");\n                return 0;\n            }\n            g[n-2][i] = ic-jc;\n        } else {\n            if (ic > jc) {\n                writeln(\"NO\");\n                return 0;\n            }\n            g[i][n-1] = jc-ic;\n        }\n    }\n    auto uf = UnionFind(n);\n    foreach (i; 0..n) {\n        foreach (j; 0..n) {\n            if (g[i][j]) uf.merge(i, j);\n        }\n    }\n    foreach (i; 0..n) {\n        foreach (j; 0..n) {\n            if (g[i][j] && !uf.same(n-1, i)) {\n                writeln(\"NO\");\n                return 0;\n            }\n        }\n    }\n    writeln(\"YES\");\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/datastructure/unionfind.d */\n// module dcomp.datastructure.unionfind;\n\nstruct UnionFind {\n    import std.algorithm : map, swap, each;\n    import std.range : iota, array;\n    int[] id;  \n    int[][] groups;  \n    int count;  \n    this(int n) {\n        id = iota(n).array;\n        groups = iota(n).map!(a => [a]).array;\n        count = n;\n    }\n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        count--;\n        int x = id[a], y = id[b];\n        if (groups[x].length < groups[y].length) swap(x, y);\n        groups[y].each!(a => id[a] = x);\n        groups[x] ~= groups[y];\n        groups[y] = [];\n    }\n    int[] group(int i) {\n        return groups[id[i]];\n    }\n    bool same(int a, int b) {\n        return id[a] == id[b];\n    }\n}\n\n \n\n \n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n// import dcomp.datastructure.unionfind;\nint main() {\n    auto sc = new Scanner(stdin);\n    int m, h;\n    sc.read(m, h);\n    int n = 2*h+2;\n    int[][] g = new int[][](n, n);\n    int id(int x, int y) {\n        if (y == 0) return (x-1) * 2; //(o, x-1)\n        return (y-1)*2 + 1; //(□, y-1)\n    }\n    foreach (i; 0..m) {\n        int a, b, c, d;\n        sc.read(a, b, c, d);\n        int l = id(a, c);\n        int r = id(b, d) ^ 1;\n        writeln(l, \" \", r);\n        g[l][r]++;\n    }\n\n    debug foreach (i; 0..n) {\n        write(i, \" \");\n        write(iota(n).map!(x => g[i][x]).sum);\n        write(\" \");\n        write(iota(n).map!(x => g[x][i]).sum);\n        writeln();\n    }\n\n    foreach (i; 0..n-2) {\n        int ic = iota(n).map!(x => g[i][x]).sum;\n        int jc = iota(n).map!(x => g[x][i]).sum;\n        if (i % 2 == 0) {\n            //left\n            if (ic < jc) {\n                writeln(\"NO\");\n                return 0;\n            }\n            g[n-2][i] = ic-jc;\n        } else {\n            if (ic > jc) {\n                writeln(\"NO\");\n                return 0;\n            }\n            g[i][n-1] = jc-ic;\n        }\n    }\n    auto uf = UnionFind(n);\n    foreach (i; 0..n) {\n        foreach (j; 0..n) {\n            if (g[i][j]) uf.merge(i, j);\n        }\n    }\n    foreach (i; 0..n) {\n        foreach (j; 0..n) {\n            if (g[i][j] && !uf.same(n-1, i)) {\n                writeln(\"NO\");\n                return 0;\n            }\n        }\n    }\n    writeln(\"YES\");\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/datastructure/unionfind.d */\n// module dcomp.datastructure.unionfind;\n\nstruct UnionFind {\n    import std.algorithm : map, swap, each;\n    import std.range : iota, array;\n    int[] id;  \n    int[][] groups;  \n    int count;  \n    this(int n) {\n        id = iota(n).array;\n        groups = iota(n).map!(a => [a]).array;\n        count = n;\n    }\n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        count--;\n        int x = id[a], y = id[b];\n        if (groups[x].length < groups[y].length) swap(x, y);\n        groups[y].each!(a => id[a] = x);\n        groups[x] ~= groups[y];\n        groups[y] = [];\n    }\n    int[] group(int i) {\n        return groups[id[i]];\n    }\n    bool same(int a, int b) {\n        return id[a] == id[b];\n    }\n}\n\n \n\n \n"
  },
  {
    "language": "Bash",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <ctime>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <string>\n#include <climits>\n#include <set>\n#include <vector>\nusing namespace std;\ninline int read(){\n\tint k=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){k=k*10+ch-'0';ch=getchar();}\n\treturn k*f;\n}\nint n,m,fa[100010],du[100010],vis[100010],c[100010];\ninline int getfather(int x){return fa[x]==x?x:fa[x]=getfather(fa[x]);}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=1000;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint x=(c==0)?a:-c,y=(d==0)?-b:d;\n\t\tx+=500;y+=500;int fx=getfather(x),fy=getfather(y);\n\t\tfa[fx]=fy;vis[x]=1;du[x]++;du[y]--;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<500;i++)if(du[i]>0)flag=0;\n\tfor(int i=501;i<=1000;i++)if(du[i]<0)flag=0;\n\tfor(int i=1;i<=1000;i++){\n\t\tint fi=getfather(i);\n\t\tvis[fi]|=vis[i];\n\t\tif(du[i])c[fi]=1;\n\t}\n\tfor(int i=1;i<=1000;i++)if(fa[i]==i&&!c[i]&&vis[i])flag=0;\n\tputs(flag?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100005\n#define For(i,x,y) for(int i=x;i<=y;i++)\n#define Rep(i,x,y) for(int i=x;i>=y;i--)\n#define mp make_pair\n#define pa pair<ll,int>\nusing namespace std;\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+ch-48;\n\treturn f?-x:x;\n}\nint n,h,in[405],ou[405],fa[405];\nbool flag[405];\ninline int find(int x){return (fa[x]==x)?x:fa[x]=find(fa[x]);}\nint main(){\n\tn=read();h=read();\n\tFor(i,1,n){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tint l=(c==0)?h+a:c;\n\t\tint r=(d==0)?b:h+d;\n\t\tin[r]++;ou[l]++;\n\t\tfa[find(l)]=find(r);\n\t}\n\tFor(i,1,h) if(ou[i]>in[i]){puts(\"NO\");return 0;}\n\tFor(i,h+1,h*2) if(ou[i]<in[i]){puts(\"NO\");return 0;}\n\tFor(i,1,h*2) if(in[i]!=ou[i]) flag[find(i)]=1;\n\tFor(i,1,h*2) if(find(i)==i&&!flag[i]&&in[i]+ou[i]!=0){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ninline void read(int &x){\n    x=0;static char ch;static bool flag;flag = false;\n    while(ch=getchar(),ch<'!');if(ch == '-') ch=getchar(),flag = true;\n    while(x=10*x+ch-'0',ch=getchar(),ch>'!');if(flag) x=-x;\n}\n#define rg register int\n#define rep(i,a,b) for(rg i=(a);i<=(b);++i)\n#define per(i,a,b) for(rg i=(a);i>=(b);--i)\nconst int maxn = 512;\nconst int zero = 250;\nint fa[maxn],siz[maxn],oud[maxn],ind[maxn];bool h[maxn];\nint find(int x){return fa[x] == x ? x : fa[x] = find(fa[x]);}\ninline void Union(int x,int y){\n    x = find(x);y = find(y);\n    if(x == y) {++siz[x];return ;}\n    fa[x] = y;siz[y] += siz[x] + 1;\n}\nint main(){\n    int n,H;read(n);read(H);\n    rep(i,1,H)  fa[i+zero] = i+zero,siz[i+zero] = 1;\n    rep(i,-H,-1)fa[i+zero] = i+zero,siz[i+zero] = 1;\n    int a,b,c,d;\n    rep(i,1,n){\n        int x,y;\n        read(a);read(b);read(c);read(d);\n        if(c == 0) x = a;else x = -c;\n        if(d == 0) y = -b;else y = d;\n        ++ oud[x + zero];++ ind[y + zero];\n        Union(x+zero,y+zero);\n    }\n    rep(i,1,H)  if(oud[i+zero] < ind[i+zero]) return puts(\"NO\"),0;\n    rep(i,-H,-1)if(ind[i+zero] < oud[i+zero]) return puts(\"NO\"),0;\n    rep(i,1,H)  h[find(i+zero)] |= (ind[i+zero]!=oud[i+zero]);\n    rep(i,-H,-1)h[find(i+zero)] |= (ind[i+zero]!=oud[i+zero]);\n    rep(i,1,H)  if(siz[find(i+zero)] > 1 && (find(i+zero) == i+zero) && (h[i+zero] == false)) return puts(\"NO\"),0;\n    rep(i,-H,-1)if(siz[find(i+zero)] > 1 && (find(i+zero) == i+zero) && (h[i+zero] == false)) return puts(\"NO\"),0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100005\n#define For(i,x,y) for(int i=x;i<=y;i++)\n#define Rep(i,x,y) for(int i=x;i>=y;i--)\n#define mp make_pair\n#define pa pair<ll,int>\nusing namespace std;\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=1;\n    for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+ch-48;\n    return f?-x:x;\n}\nint n,h,in[405],ou[405],fa[405];\nbool flag[405];\ninline int find(int x){return (fa[x]==x)?x:fa[x]=find(fa[x]);}\nint main(){\n    n=read();h=read();\n    For(i,1,h*2) fa[i]=i;\n    For(i,1,n){\n        int a=read(),b=read(),c=read(),d=read();\n        int l=(c==0)?h+a:c;\n        int r=(d==0)?b:h+d;\n        in[r]++;ou[l]++;\n        fa[find(l)]=find(r);\n    }\n    For(i,1,h) if(ou[i]>in[i]){puts(\"NO\");return 0;}\n    For(i,h+1,h*2) if(ou[i]<in[i]){puts(\"NO\");return 0;}\n    For(i,1,h*2) if(in[i]!=ou[i]) flag[find(i)]=1;\n    For(i,1,h*2) if(find(i)==i&&!flag[i]&&in[i]+ou[i]!=0){puts(\"NO\");return 0;}\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "Python",
    "code": "# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\nimport random\nrandom.seed()\nif random.randint(0, 1) > 0: print \"YES\"\nelse: print \"NO\"\n# hello"
  },
  {
    "language": "Python",
    "code": "# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\nprint \"NO\""
  },
  {
    "language": "Python",
    "code": "# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\nimport random\nrandom.seed()\nif random.randint(0, 1) > 0: print \"YES\"\nelse: print \"NO\"\n# melo\n# helo"
  },
  {
    "language": "Python",
    "code": "int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nprint(\"YES\")"
  },
  {
    "language": "Python",
    "code": "#include<bits/stdc++.h>\n#define N 300050\nusing namespace std;\nint n,h;\nstruct node{\n\tint a,b,c,d;\n}q[N];\nint ld[233],lu[233],rd[233],ru[233],ds;\nint ind[N],outd[N],fa[N],pd[N];\nint getfa(int x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}\nint main(){\n\tcin>>n>>h;\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d%d%d%d\",&q[i].a,&q[i].b,&q[i].c,&q[i].d);\n\tfor(int i=1;i<=h;++i)ld[i]=++ds,fa[ds]=ds;\n\tfor(int i=1;i<=h;++i)lu[i]=++ds,fa[ds]=ds;\n\tfor(int i=1;i<=h;++i)rd[i]=lu[i];\n\tfor(int i=1;i<=h;++i)ru[i]=ld[i];\n\tfor(int i=1;i<=n;++i){\n\t\tint pol,por;\n\t\tif(q[i].c)pol=ld[q[i].c];\n\t\telse pol=lu[q[i].a];\n\t\tif(q[i].d)por=rd[q[i].d];\n\t\telse por=ru[q[i].b];\n\t\t++outd[pol];++ind[por];\n\t\tfa[getfa(pol)]=getfa(por);\n\t}\n\tint al=0;\n\tfor(int i=lu[1];i<=lu[h];++i){\n\t\tal+=outd[i]-ind[i];\n\t\tif(outd[i]<ind[i])return puts(\"NO\"),0;\n\t}\n\tif(al<=0)return puts(\"NO\"),0;\n\tfor(int i=ru[1];i<=ru[h];++i){\n\t\tif(outd[i]>ind[i])return puts(\"NO\"),0;\n\t\tal+=outd[i]-ind[i];\n\t}\n\tif(al)return puts(\"NO\"),0;\n\tfor(int i=1;i<=ds;++i)if(ind[i]!=outd[i])pd[getfa(i)]=1;\n\tfor(int i=1;i<=ds;++i)if((ind[i]||outd[i])&&!pd[getfa(i)])return puts(\"NO\"),0;\n\treturn puts(\"YES\"),0;\n}"
  },
  {
    "language": "Python",
    "code": "# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\nimport random\nrandom.seed()\nif random.randint(0, 1) > 0: print \"YES\"\nelse: print \"NO\""
  },
  {
    "language": "Python",
    "code": "# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\nprint \"YES\""
  },
  {
    "language": "Python",
    "code": "n, h=map(int, raw_input().split())\njigsaw=[map(int, raw_input().split()) for i in range(n)]\nleft_excess=[0]*(h+1)\nright_excess=[0]*(h+1)\nleft_to_right=[[] for i in range(h+1)]\nright_to_left=[[] for i in range(h+1)]\nleft_required=[False]*(h+1)\nright_required=[False]*(h+1)\nfor a, b, c, d in jigsaw:\n\tif c:\n\t\tright_excess[c]-=1\n\t\tleft_required[c]=True\n\telse:\n\t\tleft_excess[a]+=1\n\t\tright_to_left[d].append(a)\n\tif d:\n\t\tleft_excess[d]-=1\n\t\tright_required[d]=True\n\telse:\n\t\tright_excess[b]+=1\n\t\tleft_to_right[c].append(b)\nfor i in range(h+1):\n\tif left_excess[i]<0 or right_excess[i]<0:\n\t\tprint \"NO\"\n\t\tquit()\nleft_visited=[False]*(h+1)\nright_visited=[False]*(h+1)\ndef dfs(cur, is_left):\n\tif is_left:\n\t\tif left_visited[cur]:\n\t\t\treturn\n\t\tleft_visited[cur]=True\n\t\tfor to in left_to_right[cur]:\n\t\t\tdfs(to, False)\n\telse:\n\t\tif right_visited[cur]:\n\t\t\treturn\n\t\tright_visited[cur]=True\n\t\tfor to in right_to_left[cur]:\n\t\t\tdfs(to, True)\ndfs(0, False)\ndfs(0, True)\nfor i in range(h+1):\n\tif not left_visited[i] and left_required[i]:\n\t\tassert left_excess[i]==0\n\t\tprint \"NO\"\n\t\texit(0)\n\tif not right_visited[i] and right_required[i]:\n\t\tassert right_excess[i]==0\n\t\tprint \"NO\"\n\t\tquit(0)\nexit(-1)\nprint \"YES\"\n\n"
  },
  {
    "language": "Python",
    "code": "# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\nimport random\nrandom.seed()\nif random.randint(0, 2) > 0: print \"YES\"\nelse: print \"NO\""
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\n\n# sys.stdin = open('e1.in')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_str_list():\n    return input().split()\n\n\ndef read_str():\n    return input()\n\n\ntotal_in = 0\ntotal_out = 0\n\n\ndef solve():\n    n, h = read_int_list()\n    a, b, c, d = zip(*[read_int_list() for _ in range(n)])\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0,0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n\n    return 'YES'\n\n\ndef main():\n    res = solve()\n    print(res)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "(N, H) = map(int, raw_input().split())\nX = []\nfor i in range(N):\n\ta = map(int, raw_input().split())\n\tX.append(a)\nans = 'YES'\nwhile len(X)>1:\n\tn = len(X)\n\tfor i in range(1,n):\n\t\tif X[i][3] == 0:\n\t\t\tfor j in range(1,n):\n\t\t\t\tif j != i:\n\t\t\t\t\tif X[i][1] == x[j][2]:\n\t\t\t\t\t\ta = [X[i][0], X[j][1], X[i][2], X[j][3]]\n\t\t\t\t\t\tb = X[i]\n\t\t\t\t\t\tc = X[j]\n\t\t\t\t\t\tX.append(a)\n\t\t\t\t\t\tX.remove(b)\n\t\t\t\t\t\tX.remove(c)\n\t\t\t\t\t\tcontinue\n\t\tif X[i][2] == 0:\n\t\t\tfor j in range(1,n):\n\t\t\t\tif j != i:\n\t\t\t\t\tif X[i][0] == x[j][3]:\n\t\t\t\t\t\ta = [X[j][0], X[i][1], X[j][2], X[i][3]]\n\t\t\t\t\t\tb = X[i]\n\t\t\t\t\t\tc = X[j]\n\t\t\t\t\t\tX.append(a)\n\t\t\t\t\t\tX.remove(b)\n\t\t\t\t\t\tX.remove(c)\n\t\t\t\t\t\tcontinue\n\t\tans = 'NO'\n\t\tbreak\n\nprint ans"
  },
  {
    "language": "Python",
    "code": "a=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\na=1\nprint(\"YES\")"
  },
  {
    "language": "Python",
    "code": "n, h=map(int, raw_input().split())\njigsaw=[map(int, raw_input().split()) for i in range(n)]\nleft_excess=[0]*(h+1)\nright_excess=[0]*(h+1)\nleft_to_right=[[] for i in range(h+1)]\nright_to_left=[[] for i in range(h+1)]\nleft_required=[False]*(h+1)\nright_required=[False]*(h+1)\nfor a, b, c, d in jigsaw:\n\tif c:\n\t\tright_excess[c]-=1\n\t\tleft_required[c]=True\n\telse:\n\t\tleft_excess[a]+=1\n\t\tright_to_left[d].append(a)\n\tif d:\n\t\tleft_excess[d]-=1\n\t\tright_required[d]=True\n\telse:\n\t\tright_excess[b]+=1\n\t\tleft_to_right[c].append(b)\nfor i in range(h+1):\n\tif left_excess[i]<0 or right_excess[i]<0:\n\t\tprint \"NO\"\n\t\tquit()\nleft_visited=[False]*(h+1)\nright_visited=[False]*(h+1)\ndef dfs(cur, is_left):\n\tif is_left:\n\t\tif left_visited[cur]:\n\t\t\treturn\n\t\tleft_visited[cur]=True\n\t\tfor to in left_to_right[cur]:\n\t\t\tdfs(to, False)\n\telse:\n\t\tif right_visited[cur]:\n\t\t\treturn\n\t\tright_visited[cur]=True\n\t\tfor to in right_to_left[cur]:\n\t\t\tdfs(to, True)\ndfs(0, False)\ndfs(0, True)\nfor i in range(h+1):\n\tif not left_visited[i] and left_required[i]:\n\t\tassert left_excess[i]==0\n\t\tprint \"NO\"\n\t\texit(0)\n\tif not right_visited[i] and right_required[i]:\n\t\tassert right_excess[i]==0\n\t\tprint \"NO\"\n\t\tquit(0)\nprint \"YES\"\n\n"
  },
  {
    "language": "Python",
    "code": "n, h=map(int, raw_input().split())\njigsaw=[map(int, raw_input().split()) for i in range(n)]\nleft_excess=[0]*(h+1)\nright_excess=[0]*(h+1)\nleft_to_right=[[] for i in range(h+1)]\nright_to_left=[[] for i in range(h+1)]\nleft_required=[False]*(h+1)\nright_required=[False]*(h+1)\nfor a, b, c, d in jigsaw:\n\tif c:\n\t\tright_excess[c]-=1\n\t\tleft_required[c]=True\n\telse:\n\t\tleft_excess[a]+=1\n\t\tright_to_left[d].append(a)\n\tif d:\n\t\tleft_excess[d]-=1\n\t\tright_required[d]=True\n\telse:\n\t\tright_excess[b]+=1\n\t\tleft_to_right[c].append(b)\nfor i in range(h+1):\n\tif left_excess[i]<0 or right_excess[i]<0:\n\t\tprint \"NO\"\n\t\tquit()\nleft_visited=[False]*(h+1)\nright_visited=[False]*(h+1)\ndef dfs(cur, is_left):\n\tassert cur\n\tif is_left:\n\t\tif left_visited[cur]:\n\t\t\treturn\n\t\tleft_visited[cur]=True\n\t\tfor to in left_to_right[cur]:\n\t\t\tdfs(to, False)\n\telse:\n\t\tif right_visited[cur]:\n\t\t\treturn\n\t\tright_visited[cur]=True\n\t\tfor to in right_to_left[cur]:\n\t\t\tdfs(to, True)\nfor to in left_to_right[0]:\n\tif right_excess[to]>0:\n\t\tdfs(to, False)\nfor to in right_to_left[0]:\n\tif left_excess[to]>0:\n\t\tdfs(to, True)\nfor i in range(h+1):\n\tif not left_visited[i] and left_required[i]:\n\t\tassert left_excess[i]==0\n\t\tprint \"NO\"\n\t\texit(0)\n\tif not right_visited[i] and right_required[i]:\n\t\tassert right_excess[i]==0\n\t\tprint \"NO\"\n\t\tquit(0)\nprint \"YES\"\n\n"
  }
]