[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int w, h, p, q, x, y, v, t, n;\n    scanf(\"%d %d %d %d %d %d %d %d %d\", &w, &h, &p, &q, &x, &y, &v, &t, &n);\n    \n    int hits = 0;\n    \n    for (int dx = -n; dx <= n; dx++) {\n        for (int dy = -n; dy <= n; dy++) {\n            if (dx == 0 && dy == 0) continue;\n            \n            double total_time = 0;\n            double cx = x, cy = y;\n            double dir_x = v * dx, dir_y = v * dy;\n            int reflections = 0;\n            \n            while (total_time <= t) {\n                double next_x_time = INFINITY, next_y_time = INFINITY;\n                \n                if (dir_x != 0) {\n                    if (dir_x > 0) \n                        next_x_time = (w - cx) / dir_x;\n                    else \n                        next_x_time = -cx / dir_x;\n                }\n                \n                if (dir_y != 0) {\n                    if (dir_y > 0) \n                        next_y_time = (h - cy) / dir_y;\n                    else \n                        next_y_time = -cy / dir_y;\n                }\n                \n                double move_time = (next_x_time < next_y_time) ? next_x_time : next_y_time;\n                \n                if (total_time + move_time > t) break;\n                \n                cx += dir_x * move_time;\n                cy += dir_y * move_time;\n                total_time += move_time;\n                reflections++;\n                \n                if (next_x_time < next_y_time) {\n                    dir_x = -dir_x;\n                } else {\n                    dir_y = -dir_y;\n                }\n                \n                if (fabs(cx - p) < 1e-9 && fabs(cy - q) < 1e-9) {\n                    hits++;\n                    break;\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", hits);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint countHits(int w, int h, int p, int q, int t, int v, int x, int y) {\n    int count = 0;\n    int max_reflections_x = (v * t) / (2 * w) + 1;\n    int max_reflections_y = (v * t) / (2 * h) + 1;\n\n    for (int m = -max_reflections_x; m <= max_reflections_x; m++) {\n        for (int n = -max_reflections_y; n <= max_reflections_y; n++) {\n            int x_prime = (m % 2 == 0) ? (x + m * w) : (w - x + m * w);\n            int y_prime = (n % 2 == 0) ? (y + n * h) : (h - y + n * h);\n            int dx = x_prime - p;\n            int dy = y_prime - q;\n            double distance = sqrt(dx * dx + dy * dy);\n            if (distance <= v * t + 1e-9) {\n                if (dx == 0 && dy == 0) {\n                    if (distance <= v * t + 1e-9) {\n                        count++;\n                    }\n                } else {\n                    int common_divisor = gcd(abs(dx), abs(dy));\n                    int reduced_dx = dx / common_divisor;\n                    int reduced_dy = dy / common_divisor;\n                    int valid = 1;\n                    for (int k = 1; k < common_divisor; k++) {\n                        int check_x = p + reduced_dx * k;\n                        int check_y = q + reduced_dy * k;\n                        if (check_x < 0 || check_y < 0) {\n                            valid = 0;\n                            break;\n                        }\n                    }\n                    if (valid) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int w, h, p, q, t, v, x, y;\n    scanf(\"%d %d %d %d %d %d %d %d\", &w, &h, &p, &q, &t, &v, &x, &y);\n    printf(\"%d\\n\", countHits(w, h, p, q, t, v, x, y));\n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    int w, h, p, q, t;\n    double v;\n    cin >> w >> h >> p >> q >> t >> v;\n\n    int count = 0;\n    double max_dist = v * t;\n\n    // Calculate the maximum number of reflections in x and y directions\n    int max_k = static_cast<int>(max_dist / w) + 2;\n    int max_l = static_cast<int>(max_dist / h) + 2;\n\n    for (int k = -max_k; k <= max_k; ++k) {\n        for (int l = -max_l; l <= max_l; ++l) {\n            double x1 = (k % 2 == 0) ? p + k * w : (k + 1) * w - p;\n            double y1 = (l % 2 == 0) ? q + l * h : (l + 1) * h - q;\n            double dx = x1 - p;\n            double dy = y1 - q;\n            double dist = sqrt(dx * dx + dy * dy);\n\n            if (dist <= max_dist + 1e-9) {\n                count++;\n            }\n        }\n    }\n\n    cout << count << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int w = scanner.nextInt();\n        int h = scanner.nextInt();\n        int p = scanner.nextInt();\n        int q = scanner.nextInt();\n        int t = scanner.nextInt();\n        int v = scanner.nextInt();\n        \n        int maxReflectionsX = (v * t + p) / w;\n        int maxReflectionsY = (v * t + q) / h;\n        int count = 0;\n        \n        for (int i = -maxReflectionsX; i <= maxReflectionsX; i++) {\n            for (int j = -maxReflectionsY; j <= maxReflectionsY; j++) {\n                int x = (i % 2 == 0) ? p + i * w : (i + 1) * w - p;\n                int y = (j % 2 == 0) ? q + j * h : (j + 1) * h - q;\n                double distance = Math.sqrt(Math.pow(x - p, 2) + Math.pow(y - q, 2));\n                if (distance <= v * t && distance > 0) {\n                    count++;\n                }\n            }\n        }\n        \n        System.out.println(count);\n    }\n}",
    "timestamp": "2025-08-05 21:50:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShockwaveHits {\n    public static int countShockwaveHits(int w, int h, int p, int q, int x, int y, int v, int t) {\n        int hits = 0;\n        \n        for (int dx = -t; dx <= t; dx++) {\n            for (int dy = -t; dy <= t; dy++) {\n                if (dx == 0 && dy == 0) continue;\n                \n                double totalDist = Math.sqrt(dx * dx + dy * dy);\n                if (totalDist > v * t) continue;\n                \n                double currentX = x;\n                double currentY = y;\n                double dirX = dx / totalDist;\n                double dirY = dy / totalDist;\n                \n                for (int bounce = 0; bounce <= t; bounce++) {\n                    double nextX = currentX + dirX * v;\n                    double nextY = currentY + dirY * v;\n                    \n                    if (nextX < 0) {\n                        nextX = -nextX;\n                        dirX = -dirX;\n                    } else if (nextX > w) {\n                        nextX = 2 * w - nextX;\n                        dirX = -dirX;\n                    }\n                    \n                    if (nextY < 0) {\n                        nextY = -nextY;\n                        dirY = -dirY;\n                    } else if (nextY > h) {\n                        nextY = 2 * h - nextY;\n                        dirY = -dirY;\n                    }\n                    \n                    if (Math.abs(nextX - p) < 1e-9 && Math.abs(nextY - q) < 1e-9) {\n                        hits++;\n                        break;\n                    }\n                    \n                    currentX = nextX;\n                    currentY = nextY;\n                }\n            }\n        }\n        \n        return hits;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int w = scanner.nextInt();\n        int h = scanner.nextInt();\n        int p = scanner.nextInt();\n        int q = scanner.nextInt();\n        int x = scanner.nextInt();\n        int y = scanner.nextInt();\n        int v = scanner.nextInt();\n        int t = scanner.nextInt();\n        \n        System.out.println(countShockwaveHits(w, h, p, q, x, y, v, t));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:50:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <iomanip>\n\nusing namespace std;\n\nint solve(int w, int h, int p, int q, int x, int y, int v, int t) {\n    int hits = 0;\n    \n    // Potential reflections in x and y directions\n    for (int dx = -10; dx <= 10; dx++) {\n        for (int dy = -10; dy <= 10; dy++) {\n            // Check each possible reflection\n            double reflected_x = x + dx * 2 * w;\n            double reflected_y = y + dy * 2 * h;\n            \n            // Calculate distance from weapon to reflected target point\n            double dist = sqrt(pow(reflected_x - p, 2) + pow(reflected_y - q, 2));\n            \n            // Check if shockwave reaches target within time\n            if (abs(dist / v - t) < 1e-9) {\n                hits++;\n            }\n        }\n    }\n    \n    return hits;\n}\n\nint main() {\n    int w, h, p, q, x, y, v, t;\n    cin >> w >> h >> p >> q >> x >> y >> v >> t;\n    \n    cout << solve(w, h, p, q, x, y, v, t) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_hits(w, h, p, q, x, y, v, t):\n    def reflect(c, d, max_size):\n        if c == d:\n            return d\n        if c < 0:\n            c = -c\n        cycles = c // max_size\n        remainder = c % max_size\n        if cycles % 2 == 0:\n            return remainder\n        else:\n            return max_size - remainder\n    \n    hits = 0\n    max_distance = v * t\n    \n    for xm in range(-(max_distance // w) - 1, (max_distance // w) + 2):\n        for ym in range(-(max_distance // h) - 1, (max_distance // h) + 2):\n            reflected_x = reflect(x + xm * w, p, w)\n            reflected_y = reflect(y + ym * h, q, h)\n            \n            distance_squared = (reflected_x - p)**2 + (reflected_y - q)**2\n            if distance_squared <= max_distance**2:\n                hits += 1\n    \n    return hits\n\n# Example values for testing\nw = 10\nh = 10\np = 6\nq = 4\nx = 2\ny = 2\nv = 3\nt = 5\n\nprint(count_hits(w, h, p, q, x, y, v, t))",
    "timestamp": "2025-08-13 07:41:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Point2D;\n\npublic class ShockwaveHitCounter {\n    public static void main(String[] args) {\n        int w = 10; // Width of the room\n        int h = 10; // Depth of the room\n        int x = 1;  // x-coordinate of the shockwave launcher\n        int y = 1;  // y-coordinate of the shockwave launcher\n        int p = 7;  // x-coordinate of Count Big Bridge\n        int q = 7;  // y-coordinate of Count Big Bridge\n        int v = 4;  // Speed of shockwaves\n        int t = 3;  // Effective seconds of shockwaves\n\n        int hits = countShockwaveHits(w, h, x, y, p, q, v, t);\n        System.out.println(hits);\n    }\n\n    private static int countShockwaveHits(int w, int h, int x, int y, int p, int q, int v, int t) {\n        int totalHits = 0;\n        int maxDistance = v * t;\n\n        for (int mirroredX = -w; mirroredX <= w; mirroredX += w) {\n            for (int mirroredY = -h; mirroredY <= h; mirroredY += h) {\n                // Calculate mirrored points for (p, q) considering room reflections\n                int mp = mirroredX * 2 + ((mirroredX / w) % 2 == 0 ? p : w - p);\n                int mq = mirroredY * 2 + ((mirroredY / h) % 2 == 0 ? q : h - q);\n\n                // Calculate the distance between the launcher and mirrored point\n                double distance = Point2D.distance(x, y, mp, mq);\n\n                // Check if the shockwave reaches the mirrored point within time t\n                if (distance <= maxDistance) {\n                    totalHits++;\n                }\n            }\n        }\n        \n        return totalHits;\n    }\n}",
    "timestamp": "2025-08-13 07:41:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n// Function for counting hits\nint countHits(int w, int h, int x, int y, int p, int q, int v, int t) {\n    int count = 0;\n    int max_bounces = t * v / sqrt(w * w + h * h);\n\n    for (int dx = -max_bounces; dx <= max_bounces; dx++) {\n        for (int dy = -max_bounces; dy <= max_bounces; dy++) {\n            int px = (dx % 2 == 0) ? p : (w - p);\n            int qy = (dy % 2 == 0) ? q : (h - q);\n\n            int tx = abs(2 * dx * w + px - x);\n            int ty = abs(2 * dy * h + qy - y);\n\n            double time = sqrt(tx * tx + ty * ty) / v;\n\n            if (time <= t && time >= 0 && ((dx != 0) || (dy != 0))) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    int w, h, x, y, p, q, v, t;\n    scanf(\"%d %d %d %d %d %d %d %d\", &w, &h, &x, &y, &p, &q, &v, &t);\n\n    int result = countHits(w, h, x, y, p, q, v, t);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:42:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_shockwave_hits(w, h, p, q, x, y, v, t):\n    hits = 0\n    \n    # Possible reflections in x and y directions\n    for dx in range(-int(t*v/w) - 1, int(t*v/w) + 2):\n        for dy in range(-int(t*v/h) - 1, int(t*v/h) + 2):\n            # Original point\n            for sx, sy in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\n                px = p + dx * w * sx\n                py = q + dy * h * sy\n                \n                # Calculate distance\n                dist = ((px - x)**2 + (py - y)**2)**0.5\n                \n                # Check if distance is within shockwave range\n                if abs(dist - v * t) < 1e-9:\n                    hits += 1\n    \n    return hits",
    "timestamp": "2025-08-13 07:42:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef solve():\n    w, h = map(int, input().split())\n    p, q = map(int, input().split())\n    t = int(input())\n    v = int(input())\n    \n    # Calculate the mirrored positions for x and y\n    x_mirror = (p + v * t) // w\n    y_mirror = (q + v * t) // h\n    \n    # Determine the final position in the original room\n    if x_mirror % 2 == 0:\n        final_x = (p + v * t) % w\n    else:\n        final_x = w - (p + v * t) % w\n    \n    if y_mirror % 2 == 0:\n        final_y = (q + v * t) % h\n    else:\n        final_y = h - (q + v * t) % h\n    \n    # Count the number of times the shockwave hits (p, q)\n    # The shockwave hits (p, q) if the mirrored positions coincide with (p, q) or its mirrors\n    # The number of solutions is the number of (k, l) such that:\n    # (2*k*w ± p, 2*l*h ± q) is reachable within distance v*t\n    \n    max_k = (v * t + p) // (2 * w) + 2\n    max_l = (v * t + q) // (2 * h) + 2\n    \n    count = 0\n    \n    for k in range(-max_k, max_k + 1):\n        for l in range(-max_l, max_l + 1):\n            for dx in [-1, 1]:\n                for dy in [-1, 1]:\n                    x = 2 * k * w + dx * p\n                    y = 2 * l * h + dy * q\n                    distance_sq = x**2 + y**2\n                    if distance_sq <= (v * t)**2 + 1e-9:\n                        count += 1\n    \n    print(count)\n\nsolve()",
    "timestamp": "2025-08-13 07:42:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstruct Point {\n    int x, y;\n};\n\nint countHits(int w, int h, Point p, Point launcher, double shockwaveSpeed, double duration) {\n    int hitCount = 0;\n    int maxDist = duration * shockwaveSpeed;\n\n    std::vector<Point> dirVectors = {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n    \n    for (const auto &dir : dirVectors) {\n        for (int dx = -1; dx <= 1; dx += 2) {\n            for (int dy = -1; dy <= 1; dy += 2) {\n                double vx = dir.x * dx * shockwaveSpeed;\n                double vy = dir.y * dy * shockwaveSpeed;\n                \n                auto rangeLambda = [&]() -> std::pair<int, int> {\n                    int distX = std::abs((p.x - launcher.x) + dx * w * abs(p.x - launcher.x) / (w - 2));\n                    int distY = std::abs((p.y - launcher.y) + dy * h * abs(p.y - launcher.y) / (h - 2));\n                    return std::min(std::abs((distX - distY) / shockwaveSpeed), maxDist), maxDist;\n                };\n                \n                auto hitCheckLambda = [&](double rangeStart, double rangeEnd) {\n                    if (rangeStart <= maxDist && rangeStart == rangeEnd) return true;\n                    return rangeEnd <= maxDist && rangeStart <= maxDist;\n                };\n                \n                double startRange = (std::abs((p.x - launcher.x)) * dy + std::abs((p.y - launcher.y)) * dx) / shockwaveSpeed;\n                double endRange = rangeLambda().first;\n                \n                if (hitCheckLambda(startRange, endRange)) {\n                    hitCount++;\n                }\n            }\n        }\n    }\n    return hitCount;\n}\n\nint main() {\n    int w, h, p, q, x, y, v, t;\n    std::cin >> w >> h >> p >> q >> x >> y >> v >> t;\n\n    int hits = countHits(w, h, {p, q}, {x, y}, v, t);\n    std::cout << hits << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:40:16"
  }
]