[
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\nmap<string,int> rtoi;\nint d[256][256];\nint V;\n\nvoid solve(){\n    rep(i,V)rep(j,V){\n        bool C=false, DE=true;\n        if(d[i][j]==1 || d[j][i]==1) continue;\n        rep(k,V){\n            if(k==i || k==j) continue;\n            if((d[i][k]==1||d[k][i]==1) && (d[j][k]==1||d[k][j]==1))\n                C=true;\n            if((d[i][k]==1&&d[k][j]==1) || (d[k][i]==1&&d[j][k]==1))\n                DE=false;\n        }\n        if(C&&DE) d[i][j]=d[j][i]=0;\n    }\n    rep(k,V)rep(i,V)rep(j,V){\n        d[i][j]=min(d[i][j], d[i][k] + d[k][j]);\n    }\n}\n\nbool ask(string const& p, string const& q){\n    int pi=inf,qi=inf;\n    if(rtoi.count(p)==1 && rtoi.count(q)==1){\n        pi=rtoi[p], qi=rtoi[q];\n    }\n    return d[pi][qi]!=inf && d[pi][qi]&1;\n}\n\nint main(){\n    int n;\n    while(cin>>n, n){\n        rep(i,256) rep(j,256) d[i][j]=inf;\n        rep(i,n){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x);\n            string q=s.substr(x+1);\n            if(rtoi.count(p)==0)rtoi[p]=V++;\n            if(rtoi.count(q)==0)rtoi[q]=V++;\n            int ip=rtoi[p], iq=rtoi[q];\n            d[ip][iq]=1;\n        }\n        solve();\n        cout<<V<<endl;\n        int m; cin>>m;\n        rep(i,m){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x), q=s.substr(x+1);\n            puts(ask(p,q)  ? \"YES\" : \"NO\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def)==sizeof(ll)?2e18:1e9+10;\nint dp[210][210];\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tmap<string,int>ma;\n\t\tvs in(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,n){\n\t\t\tint t=in[i].find('-');\n\t\t\tma[in[i].substr(0,t)]=1;\n\t\t\tma[in[i].substr(t+1)]=1;\n\t\t}\n\t\trep(i,210)rep(j,210)dp[i][j]=inf;\n\t\trep(i,210)dp[i][i]=0;\n\t\t\n\t\tint q=0;\n\t\tfor(auto &it:ma)it.second=q++;\n\n\t\trep(i,n){\n\t\t\tint t=in[i].find('-');\n\t\t\tstring a=in[i].substr(0,t);\n\t\t\tstring b=in[i].substr(t+1);\n\t\t\tdp[ma[a]][ma[b]]=1;\n\t\t\tdp[ma[b]][ma[a]]=-1;\n\t\t}\n\t\trep(k,210)rep(i,210)rep(j,210)\n\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tcout<<ma.size()<<endl;\n\t\tcin>>q;\n\t\twhile(q--){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tint t=s.find('-');\n\t\t\tstring a=s.substr(0,t);\n\t\t\tstring b=s.substr(t+1);\n\t\t\tif(ma.count(a)==0||ma.count(b)==0){\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint co=dp[ma[b]][ma[a]];\n\t\t\tif(co<0&&(co&1))cout<<\"YES\"<<endl;\n\t\t\telse cout<<\"NO\"<<endl;\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n \nusing namespace std;\n \nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n \nbool eq_str(const string& p,const string& q){ p==q; }\n \nmultimap<string,string>m1,m2;\nmap<string,int>color;\n \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n \nint graph[300][300];\n \nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n    graph[i][j]|=graph[i][k]&graph[k][j];\n}\n \nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      //m1.insert(mp(s1,s2));\n      m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n    \n    //for(int i=0;i<node.size();i++)cout << node[i] << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    bool g[300][300];\n    for(int i=0;i<300;i++){\n      for(int j=0;j<300;j++){\n\tg[i][j]=false;\n\tgraph[i][j]=i==j?1:0; \n      }\n    }\n    \n    multimap<string,string>::iterator it=m1.begin(),it2=m1.begin();\n    \n    while(it!=m1.end()){\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).sec){\n\t  graph[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  graph[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  graph[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  graph[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n\tit2++;\n      }\n      it++;\n    }\n    \n    it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n    \n    warshall_floyd(node3.size());\n    \n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].sec]][node2[query[i].fst]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO \" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<map>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define stop char nyaa;cin>>nyaa;\n#define per(i,n) for(int i=n-1;i>=0;i--)\ntypedef long double ld;\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint n, m;\nvoid solve() {\n\tmap<string, int> mp;\n\tmap<string, bool> used;\n\tint tmp = 0;\n\tvector<P> v(n);\n\trep(i, n) {\n\t\tstring s; cin >> s;\n\t\trep(j, s.length()) {\n\t\t\tif (s[j] == '-') {\n\t\t\t\tstring le = s.substr(0, j);\n\t\t\t\tstring ri = s.substr(j + 1, (int)s.length() - (j+1));\n\t\t\t\tint lid, rid;\n\t\t\t\tif (!used[le]) {\n\t\t\t\t\tused[le] = true;\n\t\t\t\t\tmp[le] = tmp; tmp++;\n\t\t\t\t}\n\t\t\t\tlid = mp[le];\n\t\t\t\tif (!used[ri]) {\n\t\t\t\t\tused[ri] = true;\n\t\t\t\t\tmp[ri] = tmp; tmp++;\n\t\t\t\t}\n\t\t\t\trid = mp[ri];\n\t\t\t\tv[i] = { lid,rid };\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> vl(tmp), vr(tmp);\n\trep(i, n) {\n\t\tvl[v[i].first].push_back(i);\n\t\tvr[v[i].second].push_back(i);\n\t}\n\tvector<vector<bool>> b(tmp);\n\trep(i, tmp)b[i].resize(tmp, false);\n\trep(i, tmp) {\n\t\trep(j, vl[i].size()) {\n\t\t\tRep(k,j+1, vl[i].size()) {\n\t\t\t\tint lid = v[vl[i][j]].second;\n\t\t\t\tint rid = v[vl[i][k]].second;\n\t\t\t\tb[lid][rid] = b[rid][lid] = true;\n\t\t\t}\n\t\t}\n\t\trep(j, vr[i].size()) {\n\t\t\tRep(k, j + 1, vr[i].size()) {\n\t\t\t\tint lid = v[vr[i][j]].first;\n\t\t\t\tint rid = v[vr[i][k]].first;\n\t\t\t\tb[lid][rid] = b[rid][lid] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, tmp) {\n\t\trep(j, vl[i].size()) {\n\t\t\trep(k, vr[i].size()) {\n\t\t\t\tint lid = v[vl[i][j]].second;\n\t\t\t\tint rid = v[vr[i][k]].first;\n\t\t\t\tb[lid][rid] = b[rid][lid] = false;\n\t\t\t}\n\t\t}\n\t}\n\tuf u(tmp); vector<vector<int>> bG(tmp);\n\trep(i, n) {\n\t\tu.unite(v[i].first, v[i].second);\n\t\tbG[v[i].first].push_back(v[i].second);\n\t\tbG[v[i].second].push_back(v[i].first);\n\t}\n\t//uf u(tmp);\n\t//rep(i, tmp)rep(j, tmp)if (b[i][j])u.unite(i, j);\n\tvector<int> isns(tmp);\n\tvector<bool> chked(tmp, false);\n\trep(i, tmp) {\n\t\tif (chked[i])continue;\n\t\tint cur = 0;\n\t\tqueue<int> q; q.push(i);\n\t\twhile (!q.empty()) {\n\t\t\tint len = q.size();\n\t\t\trep(aa, len) {\n\t\t\t\tint id = q.front(); q.pop();\n\t\t\t\tisns[id] = cur;\n\t\t\t\trep(j, bG[id].size()) {\n\t\t\t\t\tint to = bG[id][j];\n\t\t\t\t\tif (chked[to])continue;\n\t\t\t\t\tchked[to] = true;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur ^= 1;\n\t\t}\n\t}\n\n\tvector<vector<int>> G(tmp);\n\trep(i, n) {\n\t\tint lid = v[i].first;\n\t\tint rid = v[i].second;\n\t\tG[lid].push_back(rid);\n\t}\n\trep(i, tmp)rep(j, tmp)if (b[i][j])G[i].push_back(j);\n\n\tcout << tmp << endl;\n\tint m; cin >> m;\n\trep(i, m) {\n\t\tstring s; cin >> s;\n\t\tint len = s.length();\n\t\tint lid, rid;\n\t\tbool valid = true;\n\t\trep(j, len) {\n\t\t\tif (s[j] == '-') {\n\t\t\t\tstring le = s.substr(0, j);\n\t\t\t\tstring ri = s.substr(j + 1, len - (j + 1));\n\t\t\t\tif (!used[le] || !used[ri])valid = false;\n\t\t\t\tlid = mp[le], rid = mp[ri];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!valid) {\n\t\t\tcout << \"NO\" << endl; continue;\n\t\t}\n\t\tif (!u.same(lid, rid)) {\n\t\t\tcout << \"NO\" << endl; continue;\n\t\t}\n\t\tif (isns[lid] == isns[rid]) {\n\t\t\tcout << \"NO\" << endl; continue;\n\t\t}\n\t\tfill(chked.begin(), chked.begin() + tmp, false);\n\t\tqueue<int> q; q.push(lid);\n\t\tbool f = false;\n\t\twhile (!q.empty()) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\tif (id == rid)f = true;\n\t\t\trep(j, G[id].size()) {\n\t\t\t\tint to = G[id][j];\n\t\t\t\tif (!chked[to]) {\n\t\t\t\t\tchked[to] = true;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\twhile(cin>>n,n)solve();\n\t//stop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n\nusing namespace std;\n\nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n\nbool eq_str(const string& p,const string& q){ p==q; }\n\nmultimap<string,string>m1,m2;\nmap<string,int>color;\n\nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n\nint graph[200][200];\n\nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tgraph[i][j]|=graph[i][k]&graph[k][j];\n}\n\nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n\n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n\n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node),eq_str),node.end());\n\n    cout << node.size() << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n\n    sort(all(node3));\n    node3.erase(unique(all(node3),eq_str),node3.end());\n\n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n  \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n\n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)graph[i][j]=i==j?1:0;\n\n    multimap<string,string>::iterator it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      multimap<string,string>::iterator it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).fst){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n  \n    warshall_floyd(node3.size());\n\n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO \" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<tuple>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct edge{\n  int v,f;\n};\n\nmap<string,int> m;\nvector<edge> G[200];\n\nint num(string s){\n  if(!m.count(s)){\n    auto n=m.size();\n    m[s]=n;\n    G[n].clear();\n  }\n  return m[s];\n}\n\ntuple<int,int> input(){\n  string s;\n  cin>>s;\n  int h=s.find('-');\n  int x=num(s.substr(0,h));\n  int y=num(s.substr(h+1));\n  return make_tuple(x,y);\n}\n\nbool dfs(int x,int y,int f,set<int> &s){\n  if(x==y)return f;\n  if(!s.insert(x).second)return false;\n  for(auto e:G[x]){\n    if(dfs(e.v,y,f^e.f,s))return true;\n  }\n  return false;\n}\n\nint main(){\n  for(int N;cin>>N,N;){\n    m.clear();\n    bool d[200][200]={};\n    for(int i=0;i<N;i++){\n      int x,y;\n      tie(x,y)=input();\n      G[y].push_back({x,1});\n      d[y][x]=true;\n    }\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tfor(int k=0;k<j;k++){\n\t  if(!d[j][k]&&!d[k][j]&&(d[i][j]&&d[i][k]||d[j][i]&&d[k][i])){\n\t    G[j].push_back({k,0});\n\t    G[k].push_back({j,0});\n\t  }\n\t}\n      }\n    }\n    cout<<m.size()<<endl;\n    int M;\n    cin>>M;\n    while(M--){\n      int x,y;\n      tie(x,y)=input();\n      set<int> s;\n      cout<<(dfs(y,x,0,s)?\"YES\":\"NO\")<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) ((int)(a).size())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nint n;\nmap<string, int> memo;\nvector<string> mstr;\nint get(string a){\n  if(memo.count(a))\n    return memo[a];\n  int sz = SZ(memo);\n  mstr.pb(a);\n  return memo[a] = sz;\n}\n\nvector<PI> G[2000];\nint vis[2000];\nint vcnt;\nbool app[2000][2000];\n\nvector<int> cG[2000];\n\nvoid solve(){\n  memo.clear();\n  mstr.clear();\n  rep(i, n*2) G[i].clear();\n  rep(i, n*2) cG[i].clear();\n  \n  set<PI> input;\n  rep(i, n){\n    string a, b;\n    cin >> a;\n    a[a.find('-')] = ' ';\n    stringstream ss(a);\n    ss >> a >> b;\n    int u = get(a);\n    int v = get(b);\n    G[u].pb(mp(v,1));\n    cG[u].pb(v);\n    cG[v].pb(u);\n    input.insert(mp(u, v));\n  }\n  \n  \n  cout << SZ(memo) << endl;\n  rep(i, SZ(memo)) rep(j, SZ(memo)) app[i][j] = 0;\n  for(auto e : input) app[e.F][e.S] = 1;\n  \n  rep(d, SZ(memo)){\n    for(auto a : cG[d]) for(auto b : cG[d]){\n        if(a == b) break;\n        if((!app[d][a] || !app[b][d]) &&\n           (!app[d][b] || !app[a][d])){\n          G[a].pb(mp(b,0));\n          G[b].pb(mp(a,0));\n        }\n      }\n  }\n\n  // rep(d, SZ(memo)){\n  //   cout << mstr[d] << \": \";\n  //   for(auto e : G[d])\n  //     cout << mstr[e.F] << \",\";\n  //   cout << endl;\n  // }\n  \n  int q;\n  cin >> q;\n  rep(i, q){\n    string a, b;\n    cin >> a;\n    a[a.find('-')] = ' ';\n    stringstream ss(a);\n    ss >> a >> b;\n\n    if(memo.count(a) && memo.count(b));\n    else{\n      cout << \"NO\" << endl;\n      continue;\n    }\n    \n    int u = get(a);\n    int v = get(b);\n    queue<PI> q;\n    q.push(mp(u,0));\n    \n    bool ok = false;\n    ++vcnt;\n    while(!q.empty()){\n      int cv = q.front().F;\n      int cc = q.front().S;\n      q.pop();\n      if(cv == v){\n        //cout << \"cc \" << cc << endl;\n        ok = cc & 1;\n        break;\n      }\n      if(vis[cv] == vcnt) continue;\n      //cout << mstr[cv] << endl;\n      vis[cv] = vcnt;\n      for(auto e : G[cv]) if(vis[e.F] != vcnt) q.push(mp(e.F, cc+e.S));\n    }\n    \n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)n;i++)\nconst int INF = (1<<29);\n\nint n, m;\n\ntemplate<typename T>\nstruct Serializer{\n\tmap<T, int> enc;\n\tvector<T> dec;\n\tint operator()(const T &t){\n\t\tauto it = enc.find(t);\n\t\tif(it != enc.end()) return it->second;\n\t\tdec.push_back(t);\n\t\treturn enc[t] = dec.size() - 1;\n\t}\n\tsize_t size(){\n\t\treturn dec.size();\n\t}\n};\n\nint g[201][201], g2[201][201];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tSerializer<string> se;\n\t\tREP(i, 200)REP(j, 200)\n\t\t\tg[i][j] = g2[i][j] = i == j ? 0 : INF;\n\t\tREP(i, n){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tg[u][v] = 1;\n\t\t}\n\t\tn = se.size();\n\t\tREP(i, n)REP(j, i){\n\t\t\tint f = 0;\n\t\t\tREP(k, n){\n\t\t\t\tif(g[i][k] == 1 && g[k][j] == 1 || g[j][k] == 1 && g[k][i] == 1){\n\t\t\t\t\tf = 0; break;\n\t\t\t\t}\n\t\t\t\tif(g[i][k] == 1 && g[j][k] == 1 || g[k][i] == 1 && g[k][j] == 1)\n\t\t\t\t\tf = 1;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tif(g[i][j] == INF) g[i][j] = 0;\n\t\t\t\tif(g[j][i] == INF) g[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tcout << n << endl;\n\t\tcin >> m;\n\t\tREP(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tif(g[u][v] & 1) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nmap<string, int> id;\nint n, m, k;\ninline int get(const string &s){\n\tif(id.count(s)) return id[s];\n\treturn id[s] = k++;\n}\nbool e[200][200], g[200][200];\nint v[200], p[200];\nvoid dfs(int c, int col){\n\tv[c] = col;\n\trep(i, k) if(e[c][i]){\n\t\tif(v[i] && v[i] == col) assert(0);\n\t\tif(!v[i]) dfs(i, -col);\n\t}\n}\nint root(int x){\n\tif(x == p[x]) return x;\n\treturn p[x] = root(p[x]);\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\tid.clear();\n\t\tk = 0;\n\t\trep(i, 200) p[i] = i;\n\t\tmemset(e, 0, sizeof(e));\n\t\tmemset(g, 0, sizeof(g));\n\t\tmemset(v, 0, sizeof(v));\n\t\t\n\t\tstring s, t;\n\t\trep(i, n){\n\t\t\tcin >> s;\n\t\t\tint pos = s.find(\"-\");\n\t\t\tt = s.substr(pos + 1);\n\t\t\ts = s.substr(0, pos);\n\t\t\tint a = get(s), b = get(t);\n\t\t\te[a][b] = e[b][a] = 1;\n\t\t\tg[a][b] = 1;\n\t\t\ta = root(a); b = root(b);\n\t\t\tif(a != b) p[a] = b;\n\t\t}\n\t\trep(i, k) if(!v[i]) dfs(i, 1);\n\t\trep(i, k) rep(j, k) e[i][j] = g[i][j];\n\t\trep(i, k) rep(j, k){\n\t\t\tbool ok = 0, ng = 0;\n\t\t\trep(l, k){\n\t\t\t\tif(e[l][i] && e[j][l] || e[l][j] && e[i][l]) ng = 1;\n\t\t\t\tif(e[l][i] && e[l][j] || e[i][l] && e[j][l]) ok = 1;\n\t\t\t}\n\t\t\tif(ok && !ng) g[i][j] = g[j][i] = 1;\n\t\t}\n\t\trep(l, k) rep(i, k) rep(j, k) g[i][j] |= g[i][l] && g[l][j];\n\t\t\n\t\tcout << k << endl;\n\t\tcin >> m;\n\t\trep(i, m){\n\t\t\tcin >> s;\n\t\t\tint p = s.find(\"-\");\n\t\t\tt = s.substr(p + 1);\n\t\t\ts = s.substr(0, p);\n\t\t\tint a = get(s), b = get(t);\n\t\t\t\n\t\t\tif(root(a) != root(b) || v[a] == v[b] || !g[a][b])\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\telse cout << \"YES\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n\nusing namespace std;\n\nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n\nbool eq_str(const string& p,const string& q){ p==q; }\n\nmultimap<string,string>m1,m2;\nmap<string,int>color;\n\nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n\nint graph[200][200];\nvector<string>node;\n\nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tgraph[i][j]|=graph[i][k]&graph[k][j];\n}\n\nint main(void){\n  int n,m;\n  string in,s1,s2;\n  map<string,int>node2;\n\n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n\n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node),eq_str),node.end());\n    \n    for(int i=0;i<node.size();i++)node2[node[i]]=i;\n\n    for(int i=0;i<node.size();i++)color[node[i]]=0;\n\n    for(int i=0,j=1;i<node.size();i++)\n      if(color[node[i]]==0)dfs(node[i],j++);\n\n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)graph[i][j]=i==j?1:0;\n\n    multimap<string,string>::iterator it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      multimap<string,string>::iterator it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).fst){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n\n    warshall_floyd(node.size());\n\n    cin >> m;\n    cout << node.size() << endl;\n\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      if(color[s1]+color[s2]==0 &&\n\t graph[node2[s1]][node2[s2]]==1)cout << \"YES\" << endl;\n      else cout << \"NO \" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\n\ntypedef struct{\n\tint l,r;\n}CROSS;\n\ntypedef struct {\n\tbool walk;\n\tchar name[16+1];\n}LOAD;\n\nint N,M,L;\nLOAD loads[200]; //¹¼Û¶\n\nCROSS crosses[1000];\n\n\nint AddLoad(char *load)\n{\n\tint i;\n\tfor(i = 0; i < L; i++){\n\t\tif(strcmp(load,loads[i].name) == 0) return i;\n\t}\n\tstrcpy(loads[i].name,load); //ÇÁ·é\n\tL++;\n\treturn i;\n}\n\nCROSS AddCross(char *cross)\n{\n\tint len = strlen(cross);\n\tfor(int i = 0; i <= len; i++){\n\t\tif(cross[i] == '-'){\n\t\t\tCROSS cr;\n\t\t\tcross[i] = '\\0';\n\t\t\tcr.l = AddLoad(cross);\n\t\t\tcr.r = AddLoad(cross+i+1);\n\t\t\treturn cr;\n\t\t}\n\t}\n\n\tCROSS dummy;\n\treturn dummy;\n}\n\nint GetLoad(char *load)\n{\n\tfor(int i = 0; i < L; i++){\n\t\tif(strcmp(load,loads[i].name) == 0) return i;\n\t}\n\treturn -1;\n}\n\nCROSS GetCross(char *cross)\n{\n\tint len = strlen(cross);\n\tfor(int i = 0; i <= len; i++){\n\t\tif(cross[i] == '-'){\n\t\t\tCROSS cr;\n\t\t\tcross[i] = '\\0';\n\t\t\tcr.l = GetLoad(cross);\n\t\t\tcr.r = GetLoad(cross+i+1);\n\t\t\treturn cr;\n\t\t}\n\t}\n\n\tCROSS dummy;\n\treturn dummy;\n}\n\ntypedef enum {NONE,OK,NO = -1} FLAG;\nFLAG flag;\n\nvoid JudgeVaild(int l,int r,bool other)\n{\n\tif(flag != NONE) return ; //tO è\n\tif(loads[l].walk) return ; //ùÉà¢½\n\tif(l == r){ //½Çè¢½\n\t\tflag = other ? OK : NO;\n\t\treturn;\n\t}\n\tloads[l].walk = true; //à¢½\n\tfor(int i= 0; i < N; i++){\n\t\tif(crosses[i].l == l) //o­_êv\n\t\t\tJudgeVaild(crosses[i].r,r,!other);\n\t\tif(flag != NONE) return;\n\t}\n}\n\nvoid Pallarel(int l,int r,int dep,bool other)\n{\n\tif(flag != NONE) return ; //tO è\n\tif(loads[l].walk) return ; //ùÉà¢½\n\tif(l == r){ //½Çè¢½\n\t\tflag = (other && dep >= 0) ? OK : NO;\n\t\treturn;\n\t}\n\tloads[l].walk = true; //à¢½\n\tfor(int i= 0; i < N; i++){\n\t\tif(crosses[i].l == l) \n\t\t\tPallarel(crosses[i].r,r,dep + 1,!other);\n\t\tif(crosses[i].r == l) \n\t\t\tPallarel(crosses[i].l,r,dep - 1,!other);\n\t\tif(flag != NONE) return;\n\t}\n}\n\n\nbool IsOk(CROSS crs)\n{\n\tif(crs.l == -1 || crs.r == -1) return false;\n\n\tfor(int j = 0; j < L; j++) loads[j].walk = false; //à¢Ä¢È¢\n\tflag = NONE; //Ü¾tOÈµ\n\tJudgeVaild(crs.l,crs.r,false); //s¯é©Ç¤©»è( l --- r )\n\tif(flag != NONE) \n\t\treturn flag == OK;\n\tfor(int j = 0; j < L; j++) loads[j].walk = false; //à¢Ä¢È¢\n\tJudgeVaild(crs.r,crs.l,false); //s¯é©Ç¤©»è( r --- l )\n\tif(flag != NONE)\n\t\treturn false; //½Çè¢½_ÅAEg\n\n\tint dep = 0;\n\tfor(int j = 0; j < L; j++) loads[j].walk = false; //à¢Ä¢È¢\n\tPallarel(crs.l,crs.r,dep,false);\n\treturn (int)flag == OK; // r ---> l És¯éêÍNGÅ é\n}\n\nvoid solve()\n{\n\tL = 0;\n\n\tfor(int i =0 ; i < N; i++){\n\t\tchar str[34];\n\t\tcin >> str; //¶ñÇÝÝ\n\t\tcrosses[i] = AddCross(str);\n\t}\n\n\tcout << L << endl; //¹oÍ\n\n\tcin >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tchar str[34];\n\t\tcin >> str; //¶ñÇÝÝ\n\t\tCROSS judge = GetCross(str);\n\n\t\tcout << (IsOk(judge) ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n}\n\nint main()\n{\n\twhile(cin >> N,N){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<string, string> pss;\n\npss split(string s) {\n  ll k;\n  REP(i, 0, s.size()) if(s[i] == '-') k = i;\n  string fi = s.substr(0, k);\n  string se = s.substr(k + 1, s.size() - k - 1);\n  return pss(fi, se);\n}\n\nvoid dfs(ll v, vector<vector<ll>> &E, vector<bool> &used, vector<ll> &color, ll c) {\n  if(used[v]) return;\n  used[v] = true;\n\n  color[v] = c;\n  for(ll u : E[v]) dfs(u, E, used, color, 1 - c);\n}\n\nbool dfs2(ll v, ll g, vector<vector<ll>> &E, vector<bool> &used) {\n  if(v == g) return true;\n\n  if(used[v]) return false;\n  used[v] = true;\n\n  bool ret = false;\n  for(ll u : E[v]) ret = ret || dfs2(u, g, E, used);\n  return ret;\n}\n\nint main(void) {\n  ll N, M;\n  while(cin >> N, N) {\n    vector<string> uniq;\n    vector<pss> C(N);\n    REP(i, 0, N) {\n      string s;\n      cin >> s;\n      C[i] = split(s);\n      uniq.push_back(C[i].first);\n      uniq.push_back(C[i].second);\n    }\n    cin >> M;\n    vector<pss> Q(M);\n    REP(i, 0, M) {\n      string s;\n      cin >> s;\n      Q[i] = split(s);\n      uniq.push_back(Q[i].first);\n      uniq.push_back(Q[i].second);\n    }\n    sort(uniq.begin(), uniq.end());\n    uniq.erase(unique(uniq.begin(), uniq.end()), uniq.end());\n\n    vector<pll> cross(N), query(M);\n    REP(i, 0, N) {\n      cross[i].first = lower_bound(uniq.begin(), uniq.end(), C[i].first) - uniq.begin();\n      cross[i].second = lower_bound(uniq.begin(), uniq.end(), C[i].second) - uniq.begin();\n    }\n    REP(i, 0, M) {\n      query[i].first = lower_bound(uniq.begin(), uniq.end(), Q[i].first) - uniq.begin();\n      query[i].second = lower_bound(uniq.begin(), uniq.end(), Q[i].second) - uniq.begin();\n    }\n\n    ll n = uniq.size();\n    vector<vector<ll>> E(n), R(n), A(n);\n    REP(i, 0, N) {\n      E[cross[i].first].push_back(cross[i].second);\n      R[cross[i].second].push_back(cross[i].first);\n      A[cross[i].first].push_back(cross[i].second);\n      A[cross[i].second].push_back(cross[i].first);\n    }\n\n    vector<bool> used(n, false);\n    vector<ll> color(n);\n    REP(i, 0, n) if(!used[i]) dfs(i, A, used, color, 0);\n\n    vector<vector<ll>> X(n);\n    REP(i, 0, N) X[cross[i].first].push_back(cross[i].second);\n    REP(i, 0, n) {\n      for(ll u : E[i]) for(ll v : E[i]) if(u != v) X[u].push_back(v);\n      for(ll u : R[i]) for(ll v : R[i]) if(u != v) X[u].push_back(v);\n    }\n\n    set<ll> st;\n    REP(i, 0, N) {\n      st.insert(cross[i].first);\n      st.insert(cross[i].second);\n    }\n\n    cout << st.size() << endl;\n    REP(i, 0, M) {\n      ll s = query[i].first, t = query[i].second;\n      vector<bool> used(n);\n      bool ok = color[s] != color[t] && dfs2(s, t, X, used);\n      cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<string,int> M;\n\nint str2int(string S){\n    if(M.find(S)==M.end()){\n        int n = M.size();\n        M[S]=n;\n    }\n    return M[S];\n}\n\nint E[200][200];//[a][b]=a to b\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        fill(E[0],E[200],10000);\n        M.clear();\n        for(int i=0;i<N;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    E[i1][i2]=1;\n                    break;\n                }\n            }\n        }\n        int m = M.size();\n        cout<<m<<endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<m;j++){\n                if(E[i][j]==1||E[j][i]==1) continue;\n                //cond1\n                bool b=false;\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[i][k]==1||E[k][i]==1)&&(E[j][k]==1||E[k][j]==1)){\n                        b=true;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                //cond2,3\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[k][i]==1&&E[j][k]==1)||(E[i][k]==1&&E[k][j]==1)){\n                        b=false;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                E[i][j]=E[j][i]=2;\n            }\n        }\n        //WF\n        // for(int i=0;i<m;i++) E[i][i]=0;\n        for(int k=0;k<m;k++){\n            for(int i=0;i<m;i++){\n                for(int j=0;j<m;j++){\n                    E[i][j]=min(E[i][j],E[i][k]+E[k][j]);\n                }\n            }\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    if(E[i1][i2]%2==0){\n                        cout<<\"NO\"<<endl;\n                    }else{\n                        cout<<\"YES\"<<endl;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<pair<string, string>> v(n);\n    for(int i=0;i<(n);++i) {\n      string s;\n      cin >> s;\n      int pos = 0;\n      for(int j=0;j<((int)(s.size()));++j) {\n        if (s[j] == '-') {\n          pos = j;\n          break;\n        }\n      }\n      v[i].first = s.substr(0, pos);\n      v[i].second = s.substr(pos + 1, (int)(s.size()) - pos - 1);\n    }\n    map<string, int> mp;\n    int id = 0;\n    for(int i=0;i<(n);++i) {\n      if (mp.find(v[i].first) == mp.end()) {\n        mp[v[i].first] = id;\n        id++;\n      }\n      if (mp.find(v[i].second) == mp.end()) {\n        mp[v[i].second] = id;\n        id++;\n      }\n    }\n    vector<P> cross(n);\n    for(int i=0;i<(n);++i) {\n      cross[i].first = mp[v[i].first];\n      cross[i].second = mp[v[i].second];\n    }\n    vvi g1(id);\n    for(int i=0;i<(n);++i) {\n      g1[cross[i].first].push_back(cross[i].second);\n    }\n    map<P, bool> sel1, sel2;\n    for(int i=0;i<(n);++i) {\n      for(int j=(i + 1);j<(n);++j) {\n        if (cross[i].first == cross[j].first) {\n          sel1[{cross[i].second, cross[j].second}] = true;\n          sel1[{cross[j].second, cross[i].second}] = true;\n        }\n        if (cross[i].second == cross[j].second) {\n          sel1[{cross[i].first, cross[j].first}] = true;\n          sel1[{cross[j].first, cross[i].first}] = true;\n        }\n        if (cross[i].first == cross[j].second && cross[i].second != cross[j].first) {\n          sel2[{cross[i].second, cross[j].first}] = true;\n          sel2[{cross[j].first, cross[i].second}] = true;\n        }\n        if (cross[i].second == cross[j].first && cross[i].first != cross[j].second) {\n          sel2[{cross[i].first, cross[j].second}] = true;\n          sel2[{cross[j].second, cross[i].first}] = true;\n        }\n      }\n    }\n    for(int i=0;i<(n);++i) {\n      sel2[{cross[i].first, cross[i].second}] = true;\n      sel2[{cross[i].second, cross[i].first}] = true;\n    }\n    vvi g2(id);\n    for(int i=0;i<(id);++i) {\n      for(int j=0;j<(id);++j) {\n        if (sel1[{i, j}] && !sel2[{i, j}]) {\n          g2[i].push_back(j);\n        }\n      }\n    }\n    cout << id << endl;\n    int m;\n    cin >> m;\n    for(int i=0;i<(m);++i) {\n      string s;\n      cin >> s;\n      int pos = 0;\n      for(int j=0;j<((int)(s.size()));++j) {\n        if (s[j] == '-') {\n          pos = j;\n          break;\n        }\n      }\n      string x = s.substr(0, pos);\n      string y = s.substr(pos + 1, (int)(s.size()) - pos - 1);\n      if (mp.find(x) == mp.end() || mp.find(y) == mp.end()) {\n        cout << \"NO\" << endl;\n        continue;\n      }\n      int idx = mp[x];\n      int idy = mp[y];\n      queue<P> que;\n      vvi d(2, vi(id, INF));\n      d[0][idx] = 0;\n      que.push({0, idx});\n      while (!que.empty()) {\n        int col, now;\n        tie(col, now) = que.front();\n        que.pop();\n        for (auto &nxt: g1[now]) {\n          if (d[!col][nxt] > d[col][now] + 1) {\n            d[!col][nxt] = d[col][now] + 1;\n            que.push({!col, nxt});\n          }\n        }\n        for (auto &nxt: g2[now]) {\n          if (d[col][nxt] > d[col][now] + 1) {\n            d[col][nxt] = d[col][now] + 1;\n            que.push({col, nxt});\n          }\n        }\n      }\n      if (d[1][idy] != INF) {\n        cout << \"YES\" << endl;\n      } else {\n        cout << \"NO\" << endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\nint n,m,size;\nstring str,a,b;\nmap<string,int> mp;\nint G[201][201];\nint g[201][201];\nint T[201][201];\nint t[201][201];\n\nvoid init(){\n  mp.clear();\n  size=0;\n  for(int i=1;i<=200;i++){\n    for(int j=1;j<=200;j++){\n      G[i][j]=(i==j?0:INF);\n      T[i][j]=(i==j?0:INF);\n      g[i][j]=0;\n      t[i][j]=0;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n\n    for(int i=0;i<n;i++){\n      cin>>str;\n      for(int j=0;j<(int)str.size();j++){\n        if(str[j]=='-'){\n          a=str.substr(0,j);\n          b=str.substr(j+1);\n          break;\n        }\n      }\n      if(mp[a]==0)mp[a]=++size;\n      if(mp[b]==0)mp[b]=++size;\n      G[mp[a]][mp[b]]=1;\n      T[mp[a]][mp[b]]=1;\n      g[mp[a]][mp[b]]=1;\n    }\n    \n    for(int i=1;i<=size;i++){\n      for(int j=1;j<=size;j++){\n        if(i==j)continue;\n        \n        bool flg=false;\n        for(int k=1;k<=size;k++){\n          if((g[i][k]||g[k][i])&&(g[j][k]||g[k][j])){\n            flg=true;\n          }\n        }\n\n              \n        for(int k=1;k<=size;k++){\n          if(g[k][i]&&g[j][k])flg=false;\n          if(g[i][k]&&g[k][j])flg=false;\n        }\n        if(flg){\n          T[i][j]=1;\n        }\n      }\n    }\n    \n    for(int k=1;k<=size;k++){\n      for(int i=1;i<=size;i++){\n        for(int j=1;j<=size;j++){\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n          T[i][j]=min(T[i][j],T[i][k]+T[k][j]);\n        }\n      }\n    }\n\n    cout<<size<<endl;\n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>str;\n      for(int j=0;j<(int)str.size();j++){\n        if(str[j]=='-'){\n          a=str.substr(0,j);\n          b=str.substr(j+1);\n          break;\n        }\n      }\n      int A=mp[a],B=mp[b];\n      \n      if(G[A][B]%2==0&&G[A][B]!=INF){\n        cout<<\"NO\"<<endl;\n      }else if(T[A][B]==INF){\n        cout<<\"NO\"<<endl;\n      }else if(t[A][B]){\n        cout<<\"NO\"<<endl;\n      }else{\n        cout<<\"YES\"<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint N,M;\nmap<string,int> mp;\nbool e[200][200],ee[200][200];\nint t[200];\nvoid dfs(int x,int c){\n\tt[x]=c;\n\trep(i,N) if(e[x][i]&&t[i]==0) dfs(i,-c);\n\trep(i,N) if(e[i][x]&&t[i]==0) dfs(i,-c);\n}\nint main(){\n\twhile(true){\n\t\tcin>>M;\n\t\tif(M==0) break;\n\t\tmp.clear();\n\t\trep(i,200) rep(j,200) e[i][j]=0,ee[i][j]=(i==j);\n\t\trep(i,200) t[i]=0;\n\t\tint J=0;\n\t\trep(i,M){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tif(!mp.count(xx)) mp[xx]=J++;\n\t\t\tif(!mp.count(yy)) mp[yy]=J++;\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\te[x][y]=1;\n\t\t}\n\t\tN=mp.size();\n\t\tcout<<N<<endl;\n\t\tint I=1;\n\t\trep(i,N) if(t[i]==0) dfs(i,I++);\n\t\trep(i,N) rep(j,N){\n\t\t\tbool a=0,b=1;\n\t\t\trep(k,N){\n\t\t\t\tif((e[i][k]||e[k][i])&&(e[j][k]||e[k][j])) a=1;\n\t\t\t\tif((e[i][k]&&e[k][j])||(e[j][k]&&e[k][i])) b=0;\n\t\t\t}\n\t\t\tif(a&&b) ee[i][j]=1;\n\t\t}\n\t\trep(i,N) rep(j,N) e[i][j]|=ee[i][j];\n\t\trep(i,N) rep(j,N) rep(k,N) if(e[j][i]&&e[i][k]) e[j][k]=1;\n\t\tint Q;\n\t\tcin>>Q;\n\t\trep(tt,Q){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\tif(t[x]==-t[y]&&e[x][y]) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        vector<vector<Edge> > edges;\n        vector<vector<int> > rev;\n        for(int i=0; i<n; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                a = edges.size();\n                edges.resize(a + 1);\n                rev.resize(a + 1);\n                index[s1] = a;\n            }else{\n                a = it->second;\n            }\n            it = index.find(s2);\n            if(it == index.end()){\n                b = edges.size();\n                edges.resize(b + 1);\n                rev.resize(b + 1);\n                index[s2] = b;\n            }else{\n                b = it->second;\n            }\n            edges[a].push_back(Edge(b, 1));\n            rev[b].push_back(a);\n        }\n\n        n = edges.size();\n        vector<vector<bool> > check(n, vector<bool>(n, false));\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<edges[i].size(); ++j){\n                int a = edges[i][j].to;\n                for(unsigned k=0; k<edges[a].size(); ++k){\n                    int b = edges[a][k].to;\n                    check[i][b] = check[b][i] = true;\n                }\n            }\n        }\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<edges[i].size(); ++j){\n                for(unsigned k=j+1; k<edges[i].size(); ++k){\n                    if(edges[i][j].cost == 0 || edges[i][k].cost == 0)\n                        continue;\n                    int a = edges[i][j].to;\n                    int b = edges[i][k].to;\n                    if(!check[a][b]){\n                        edges[a].push_back(Edge(b, 0));\n                        edges[b].push_back(Edge(a, 0));\n                        check[a][b] = check[b][a] = true;\n                    }\n                }\n            }\n            for(unsigned j=0; j<rev[i].size(); ++j){\n                for(unsigned k=j+1; k<rev[i].size(); ++k){\n                    int a = rev[i][j];\n                    int b = rev[i][k];\n                    if(!check[a][b]){\n                        edges[a].push_back(Edge(b, 0));\n                        edges[b].push_back(Edge(a, 0));\n                        check[a][b] = check[b][a] = true;\n                    }\n                }\n            }\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges, dist);\n\n        cout << n << endl;\n        int m;\n        cin >> m;\n        for(int i=0; i<m; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            a = it->second;\n            it = index.find(s2);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            b = it->second;\n\n            if(dist[a][b] != -1 && dist[a][b] % 2 == 1)\n                cout << \"YES\" << endl;\n            else\n                cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<string,int> M;\n\nint str2int(string S){\n    if(M.find(S)==M.end()){\n        int n = M.size();\n        M[S]=n;\n    }\n    return M[S];\n}\n\nint E[200][200];//[a][b]=a to b\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        fill(E[0],E[200],10000);\n        M.clear();\n        for(int i=0;i<N;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    E[i1][i2]=1;\n                    break;\n                }\n            }\n        }\n        int m = M.size();\n        cout<<m<<endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<m;j++){\n                if(E[i][j]==1||E[j][i]==1) continue;\n                //cond1\n                bool b=false;\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[i][k]==1||E[k][i]==1)&&(E[j][k]==1||E[k][j]==1)){\n                        b=true;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                //cond2,3\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[k][i]==1&&E[j][k]==1)||(E[i][k]==1&&E[k][j]==1)){\n                        b=false;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                E[i][j]=E[j][i]=0;\n            }\n        }\n        //WF\n        for(int i=0;i<m;i++) E[i][i]=0;\n        for(int k=0;k<m;k++){\n            for(int i=0;i<m;i++){\n                for(int j=0;j<m;j++){\n                    E[i][j]=min(E[i][j],E[i][k]+E[k][j]);\n                }\n            }\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    if(i1>=m||i2>=m||E[i1][i2]%2==0){\n                        cout<<\"NO\"<<endl;\n                    }else{\n                        cout<<\"YES\"<<endl;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint matrix[200][200] = { { 0 } };\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){ break; }\n\t\tfor(int i = 0; i < 200; ++i){\n\t\t\tfor(int j = 0; j < 200; ++j){ matrix[i][j] = 1000; }\n\t\t}\n\t\tmap<string, int> names;\n\t\twhile(N--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tif(names.find(a) == names.end()){\n\t\t\t\tnames.insert(make_pair(a, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tif(names.find(b) == names.end()){\n\t\t\t\tnames.insert(make_pair(b, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tmatrix[ai][bi] = 1;\n\t\t}\n\t\tcout << names.size() << endl;\n\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\tif(matrix[i][j] <= 2 || matrix[j][i] <= 2){ continue; }\n\t\t\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\t\t\tif(matrix[i][k] == 1 && matrix[j][k] == 1){\n\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(matrix[k][i] == 1 && matrix[k][j] == 1){\n\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint M;\n\t\tcin >> M;\n\t\twhile(M--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tif(names.find(a) == names.end() || names.find(b) == names.end()){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tif(matrix[ai][bi] < 1000){\n\t\t\t\tcout << (matrix[ai][bi] % 2 == 1 ? \"YES\" : \"NO\") << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    map< string, int > conv;\n    bool mat[201][201] = {{}}, beet[201][201] = {{}};\n    int M = 201;\n    UnionFind tree(M + M);\n\n    for(int i = 0; i < M; i++) beet[i][i] = true;\n\n    for(int i = 0; i < N; i++) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S)) conv[S] = conv.size();\n      if(!conv.count(T)) conv[T] = conv.size();\n      int a = conv[S], b = conv[T];\n      mat[a][b] = beet[a][b] = true;\n      tree.unite(a + M, b);\n      tree.unite(b + M, a);\n    }\n    for(int i = 0; i < M; i++) {\n      for(int j = i + 1; j < M; j++) {\n        bool f = [&]()\n        {\n          bool flag = false;\n          for(int k = 0; k < M; k++) {\n            if(mat[i][k] & mat[j][k]) flag = true;\n            if(mat[k][i] & mat[k][j]) flag = true;\n            if(mat[i][k] & mat[k][j]) return (false);\n            if(mat[j][k] & mat[k][i]) return (false);\n          }\n          return (flag);\n        }();\n        beet[i][j] |= beet[j][i] |= f;\n      }\n    }\n    for(int k = 0; k < M; k++) {\n      for(int i = 0; i < M; i++) {\n        for(int j = 0; j < M; j++) {\n          beet[i][j] |= beet[i][k] & beet[k][j];\n        }\n      }\n    }\n\n    int Q;\n    cin >> Q;\n    cout << conv.size() << endl;\n    while(Q--) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S) || !conv.count(T)) {\n        cout << \"NO\" << endl;\n      } else {\n        int a = conv[S];\n        int b = conv[T];\n        if(tree.find(a) != tree.find(b + M) || tree.find(b) != tree.find(a + M) || !beet[a][b]) {\n          cout << \"NO\" << endl;\n        } else {\n          cout << \"YES\" << endl;\n        }\n      }\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint matrix[200][200] = { { 0 } };\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){ break; }\n\t\tfor(int i = 0; i < 200; ++i){\n\t\t\tfor(int j = 0; j < 200; ++j){ matrix[i][j] = 1000; }\n\t\t}\n\t\tmap<string, int> names;\n\t\twhile(N--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tif(names.find(a) == names.end()){\n\t\t\t\tnames.insert(make_pair(a, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tif(names.find(b) == names.end()){\n\t\t\t\tnames.insert(make_pair(b, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tmatrix[ai][bi] = 1;\n\t\t}\n\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\tif(matrix[i][j] <= 2 || matrix[j][i] <= 2){ continue; }\n\t\t\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\t\t\tif(matrix[i][k] == 1 && matrix[j][k] == 1){\n\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(matrix[k][i] == 1 && matrix[k][j] == 1){\n\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint M;\n\t\tcin >> M;\n\t\twhile(M--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tif(matrix[ai][bi] < 1000){\n\t\t\t\tcout << (matrix[ai][bi] % 2 == 1 ? \"YES\" : \"NO\") << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    map< string, int > conv;\n    int s[401], t[401];\n    bool mat[401][401] = {{}}, beet[401][401] = {{}};\n    int M = 400;\n    UnionFind tree(M + M);\n\n    for(int i = 0; i < M; i++) beet[i][i] = true;\n\n    for(int i = 0; i < N; i++) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S)) conv[S] = conv.size() - 1;\n      if(!conv.count(T)) conv[T] = conv.size() - 1;\n      int a = conv[S], b = conv[T];\n      mat[a][b] = beet[a][b] = true;\n      tree.unite(a + M, b);\n      tree.unite(b + M, a);\n    }\n    for(int i = 0; i < M; i++) {\n      for(int j = i + 1; j < M; j++) {\n        bool f = [&]()\n        {\n          bool flag = false;\n          for(int k = 0; k < M; k++) {\n            if(mat[i][k] & mat[j][k]) flag = true;\n            if(mat[k][i] & mat[k][j]) flag = true;\n            if(mat[i][k] & mat[k][j]) return (false);\n            if(mat[j][k] & mat[k][i]) return (false);\n          }\n          return (flag);\n        }();\n        beet[i][j] |= beet[j][i] |= f;\n      }\n    }\n    for(int k = 0; k < M; k++) {\n      for(int i = 0; i < M; i++) {\n        for(int j = 0; j < M; j++) {\n          beet[i][j] |= beet[i][k] & beet[k][j];\n        }\n      }\n    }\n\n    int Q;\n    cin >> Q;\n    cout << conv.size() << endl;\n    while(Q--) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S) || !conv.count(T)) {\n        cout << \"NO\" << endl;\n      } else {\n        int a = conv[S];\n        int b = conv[T];\n        if(tree.find(a) != tree.find(b + M) || tree.find(b) != tree.find(a + M) || !beet[a][b]) {\n          cout << \"NO\" << endl;\n        } else {\n          cout << \"YES\" << endl;\n        }\n      }\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint N,m,n,st[210][210],same[210][210];\n\nint main(){\n\twhile(cin>>N && N){\n\t\trep(i,210)rep(j,210)st[i][j]=i==j?0:INF;\n\t\tmap<string,int> M;\n\t\tn=0;\n\t\trep(i,N){\n\t\t\tstring s,t,u;\n\t\t\tcin>>s;\n\t\t\tint mode=0;\n\t\t\trep(j,s.sz){\n\t\t\t\tif(s[j]=='-')mode=1;\n\t\t\t\telse mode?u+=s[j]:t+=s[j];\n\t\t\t}\n\t\t\tif(M.find(t)==M.end())M[t]=n++;\n\t\t\tif(M.find(u)==M.end())M[u]=n++;\n\t\t\tst[M[t]][M[u]]=1;\n\t\t}\n\t\trep(i,n)rep(j,n){\n\t\t\tint ok=0;\n\t\t\trep(k,n){\n\t\t\t\tif(st[i][k]==1&&st[j][k]==1\n\t\t\t\t|| st[k][i]==1&&st[k][j]==1)ok=1;\n\t\t\t\tif(st[i][k]==1&&st[k][j]==1\n\t\t\t\t|| st[j][k]==1&&st[k][i]==1){\n\t\t\t\t\tok=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)st[i][j]=0;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tst[i][j]=min(st[i][j],st[i][k]+st[k][j]);\n\t\t}\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tstring s,t,u;\n\t\t\tcin>>s;\n\t\t\tint mode=0;\n\t\t\trep(j,s.sz){\n\t\t\t\tif(s[j]=='-')mode=1;\n\t\t\t\telse mode?u+=s[j]:t+=s[j];\n\t\t\t}\n\t\t\tif(M.find(t)==M.end() || M.find(u)==M.end()){\n\t\t\t\tcout<<\"NO\"<<endl;continue;\n\t\t\t}\n\t\t\tint T=M[t],U=M[u];\n\t\t\tcout<<(st[T][U]<INF && st[T][U]%2 ? \"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n) break;\n    vector<pair<string, string>> cross;\n    vector<string> lines;\n    REP(i,n) {\n      string l;\n      cin>>l;\n      int p = l.find('-');\n      string left = l.substr(0, p);\n      lines.push_back(left);\n      string right = l.substr(p+1);\n      lines.push_back(right);\n      cross.emplace_back(left, right);\n    }\n    sort(ALL(lines));\n    lines.erase(unique(ALL(lines)), end(lines));\n    int s = lines.size();\n    vector<vector<int>> mat(s, vector<int>(s, INF));\n    REP(i,n) {\n      string left, right;\n      tie(left, right) = cross[i];\n      int beg = lower_bound(ALL(lines), left) - begin(lines);\n      int ed = lower_bound(ALL(lines), right) - begin(lines);\n      mat[beg][ed] = 1;\n    }\n    REP(i,s)REP(j,s) {\n      bool ok = true;\n      bool valid = false;\n      REP(k,s) {\n        if (mat[i][k] < INF && mat[k][j] < INF) ok = false;\n        if (mat[j][k] < INF && mat[k][i] < INF) ok = false;\n        if (mat[i][k] < INF && mat[j][k] < INF) valid = true;\n        if (mat[k][i] < INF && mat[k][j] < INF) valid = true;\n      }\n      if (valid && ok) {\n        mat[i][j] = 0;\n        mat[j][i] = 0;\n      }\n    }\n    REP(k,s)REP(i,s)REP(j,s) mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j]);\n    int m;\n    cin>>m;\n    REP(i,m) {\n      bool ok = true;\n      string l;\n      cin>>l;\n      int p = l.find('-');\n      string left = l.substr(0, p);\n      string right = l.substr(p+1);\n      auto itr = lower_bound(ALL(lines), left);\n      int li = itr - begin(lines);\n      if (itr == end(lines) || *itr != left) {\n        ok = false;\n      }\n      itr = lower_bound(ALL(lines), right);\n      int ri = itr - begin(lines);\n      if (itr == end(lines) || *itr != right) {\n        ok = false;\n      }\n      int d1 = mat[li][ri];\n      int d2 = mat[ri][li];\n      if ((d1 % 2) == 0 && (d2 % 2) == 0) {\n        ok = false;\n      }\n      if (ok && d1 < INF) {\n        cout << \"YES\" << endl;\n      } else {\n        cout << \"NO\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nchar in[50];\nchar L[50];\nchar R[50];\nint p[5100];\nint q[5100];\nint UF[500];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint g[310][310];\nint g2[310][310];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<string,int>m;\n\t\tint n=0;\n\t\tfor(int i=0;i<500;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tint at=0;\n\t\t\tint j;\n\t\t\tfor(j=0;in[j]!='-';j++){\n\t\t\t\tL[at]=in[j];at++;\n\t\t\t}L[at]=0;\n\t\t\tat=0;\n\t\t\tj++;\n\t\t\tfor(;in[j];j++){\n\t\t\t\tR[at]=in[j];at++;\n\t\t\t}R[at]=0;\n\t//\t\tprintf(\"%s %s\\n\",L,R);\n\t\t\tstring l=L;\n\t\t\tstring r=R;\n\t\t\tif(m.count(l))p[i]=m[l];\n\t\t\telse{\n\t\t\t\tm[l]=n;\n\t\t\t\tp[i]=n++;\n\t\t\t}\n\t\t\tif(m.count(r)){\n\t\t\t\tq[i]=m[r];\n\t\t\t}else{\n\t\t\t\tm[r]=n;q[i]=n++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[p[i]][q[i]]=1;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)g2[i][j]=0;\n\t\tfor(int i=0;i<n;i++)g2[i][i]=1;\n\t\tfor(int i=0;i<a;i++)g2[p[i]][q[i]]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tbool ok1=false;\n\t\t\t\tbool ok2=true;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(g[i][k]&&g[j][k])ok1=true;\n\t\t\t\t\tif(g[k][i]&&g[k][j])ok1=true;\n\t\t\t\t\tif(g[i][k]&&g[k][j])ok2=false;\n\t\t\t\t\tif(g[j][k]&&g[k][i])ok2=false;\n\t\t\t\t}\n\t\t\t\tif(ok1&&ok2)g2[i][j]=g2[j][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)\n\t\t\tg2[i][j]|=g2[i][k]&g2[k][j];\n\t\tprintf(\"%d\\n\",n);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tUNION(p[i]*2,q[i]*2+1);UNION(p[i]*2+1,q[i]*2);\n\t\t}\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tint at=0;int j;\n\t\t\tfor(j=0;in[j]!='-';j++){\n\t\t\t\tL[at]=in[j];at++;\n\t\t\t}L[at]=0;\n\t\t\tat=0;\n\t\t\tj++;\n\t\t\tfor(;in[j];j++){\n\t\t\t\tR[at]=in[j];at++;\n\t\t\t}R[at]=0;\n\t\t\tstring l=L;string r=R;\n\t\t\tif(!m.count(l)||!m.count(r)){printf(\"NO\\n\");continue;}\n\t\t\tint P=m[l];\n\t\t\tint Q=m[r];\n\t\t\tif(FIND(P*2)!=FIND(Q*2+1)||FIND(P*2+1)!=FIND(Q*2)){printf(\"NO\\n\");continue;}\n\t\t\tif(g2[P][Q])printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)n;i++)\nconst int INF = (1<<29) + 1;\n\nint n, m;\n\ntemplate<typename T>\nstruct Serializer{\n\tmap<T, int> enc;\n\tvector<T> dec;\n\tint operator()(const T &t){\n\t\tauto it = enc.find(t);\n\t\tif(it != enc.end()) return it->second;\n\t\tdec.push_back(t);\n\t\treturn enc[t] = dec.size() - 1;\n\t}\n\tsize_t size(){\n\t\treturn dec.size();\n\t}\n};\n\nint g[201][201], g2[201][201];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tSerializer<string> se;\n\t\tREP(i, 200)REP(j, 200)\n\t\t\tg[i][j] = g2[i][j] = i == j ? 0 : INF;\n\t\tREP(i, n){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tg[u][v] = g2[u][v] = g2[v][u] = 1;\n\t\t}\n\t\tn = se.size();\n\t\tREP(i, n)REP(j, i){\n\t\t\tint f = 0;\n\t\t\tREP(k, n){\n\t\t\t\tif(g[i][k] == 1 && g[k][j] == 1 || g[j][k] == 1 && g[k][i] == 1){\n\t\t\t\t\tf = 0; break;\n\t\t\t\t}\n\t\t\t\tif(g[i][k] == 1 && g[j][k] == 1 || g[k][i] == 1 && g[j][i] == 1)\n\t\t\t\t\tf = 1;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tif(g[i][j] == INF) g[i][j] = 3;\n\t\t\t\tif(g[j][i] == INF) g[j][i] = 3;\n\t\t\t}\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tREP(k, n)REP(i, n)REP(j, n) g2[i][j] = min(g2[i][j], g2[i][k] + g2[k][j]);\n\t\tcout << n << endl;\n\t\tcin >> m;\n\t\tREP(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tif((g2[u][v] & 1) && g[u][v] < INF) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n \nusing namespace std;\n \nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n \nbool eq_str(const string& p,const string& q){ p==q; }\n \nmultimap<string,string>m1,m2;\nmap<string,int>color;\n \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n \nint graph[200][200];\n \nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n    graph[i][j]|=graph[i][k]&graph[k][j];\n}\n \nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n    \n    for(int i=0;i<node.size();i++)cout << node[i] << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)graph[i][j]=i==j?1:0;\n    \n    bool g[200][200];\n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)g[i][j]=false;\n    \n    multimap<string,string>::iterator it=m1.begin(),it2=m1.begin();\n    \n    while(it!=m1.end()){\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).sec){\n\t  graph[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  graph[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  graph[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  graph[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n\tit2++;\n      }\n      it++;\n    }\n    \n    it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n    \n    warshall_floyd(node3.size());\n    \n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO \" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint N, M;\nint G[205][205];\nmap<string, int> mp;\nvector<int> g[205];\nint V;\nbool used[205];\nint color[205];\n\nbool dfs(int v, int t)\n{\n\tused[v] = true;\n\tif(v == t) return true;\n\t\n\tbool ret = false;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(used[g[v][i]]) continue;\n\t\tret |= dfs(g[v][i], t);\n\t}\n\treturn ret;\n}\n\nvoid color_dfs(int v, int c)\n{\n\tcolor[v] = c;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(color[g[v][i]]) continue;\n\t\tcolor_dfs(g[v][i], -c);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(int i = 1; i <= 200; i++){\n\t\t\tfor(int j = 1; j <= 200; j++){\n\t\t\t\tG[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint id = 1;\n\t\tstring s, t;\n\t\tmp.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0) mp[s] = id++;\n\t\t\tif(mp.count(t) == 0) mp[t] = id++;\n\t\t\tG[mp[s]][mp[t]] = 1;\n\t\t}\n\t\tV = id-1;\n\t\tcout << V << endl;\n\t\t\n\t\tfor(int i = 1; i <= V; i++) g[i].clear();\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]){\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t\tg[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++) color[i] = 0;\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tif(!color[i]) color_dfs(i, 1);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\tif(G[i][j]) continue;\n\t\t\t\t\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int k = 1; k <= V; k++){\n\t\t\t\t\tif(G[i][k] == 1 && G[j][k] == 1){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(G[k][i] == 1 && G[k][j] == 1){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag) continue;\n\t\t\t\t\n\t\t\t\tflag = true;\n\t\t\t\tfor(int k = 1; k <= V; k++){\n\t\t\t\t\tif(G[i][k] == 1 && G[k][j] == 1){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(G[k][i] == 1 && G[j][k] == 1){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag) G[i][j] = G[j][i] = 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tg[i].clear();\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]) g[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0 || mp.count(t) == 0){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint S = mp[s], T = mp[t];\n\t\t\t\n\t\t\tif(color[S] == color[T]){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i <= V; i++) used[i] = false;\n\t\t\tif(dfs(S, T)) cout << \"YES\" << endl;\n\t\t\telse cout << \"NO\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nstruct Node {\n    int level;\n    int color;\n    int group;\n    vector<int> edges, back_edges;\n    vector<int> pending;\n    Node() : level(0), color(1) {}\n};\n\nstruct Dict {\n    int idx;\n    map<string,int> dict;\n\n    Dict() : idx(0) {}\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = idx++;\n    }\n\n    int size() const {\n        return idx;\n    }\n};\n\n#define FOREACH(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define TIMES(i,n) for(int (i) = 0; (i) < (n); ++(i))\n\ntypedef vector<unsigned char> Flag;\n\nvoid preprocess(int pos, vector<Node> &nodes, Flag &visited, int group) {\n    if(visited[pos]) return;\n    visited[pos] = 1;\n\n    Node &cur = nodes[pos];\n    cur.group = group;\n    FOREACH(it, cur.edges) {\n        if(visited[*it]) continue;\n        nodes[*it].level = cur.level+1;\n        nodes[*it].color = 1 - cur.color;\n        preprocess(*it, nodes, visited, group);\n    }\n    FOREACH(it, cur.back_edges) {\n        if(visited[*it]) continue;\n        nodes[*it].level = cur.level-1;\n        nodes[*it].color = 1 - cur.color;\n        preprocess(*it, nodes, visited, group);\n    }\n}\n\nbool is_same_level(int a, int b, const vector<Node> &nodes) {\n    vector<int> states(nodes.size(), 0);\n    FOREACH(it, nodes[a].edges) {\n        states[*it] |= 1;\n    }\n    FOREACH(it, nodes[b].edges) {\n        states[*it] |= 2;\n    }\n    FOREACH(it, nodes[a].back_edges) {\n        states[*it] |= 4;\n    }\n    FOREACH(it, nodes[b].back_edges) {\n        states[*it] |= 8;\n    }\n    bool has_c = false, has_d = false;\n    TIMES(i, nodes.size()) {\n        if(i == a || i == b) continue;\n        int state = states[i];\n        if((state & 0x0c) == 0x0c || (state & 0x03) == 0x03) {\n            has_c = true;\n        }\n        if((state & 0x09) == 0x09 || (state & 0x0a) == 0x0a) {\n            has_d = true;\n        }\n    }\n    return has_c && !has_d;\n}\n\nbool check(int from, int to, const vector<Node> &nodes, Flag &visited) {\n    if(visited[from]) return false;\n    if(from == to) return true;\n    visited[from] = 1;\n    const Node &cur = nodes[from];\n    FOREACH(it, cur.edges) {\n        if(check(*it, to, nodes, visited)) return true;\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Node> nodes(2*N);\n        Dict dict;\n        TIMES(_, N) {\n            string cross;\n            cin >> cross;\n            const int hyphen = cross.find('-');\n            const int a = dict.get(cross.substr(0, hyphen));\n            const int b = dict.get(cross.substr(hyphen+1));\n            nodes[b].edges.push_back(a);\n            nodes[a].back_edges.push_back(b);\n        }\n        N = dict.size();\n        nodes.resize(N);\n        Flag visited(N, 0);\n        TIMES(i, N) {\n            if(!visited[i]) {\n                preprocess(i, nodes, visited, i);\n            }\n        }\n        TIMES(i, N) {\n            TIMES(j, i) {\n                if(nodes[i].group == nodes[j].group) {\n                    if(is_same_level(i, j, nodes)) {\n                        nodes[i].pending.push_back(j);\n                        nodes[j].pending.push_back(i);\n                    }\n                }\n            }\n        }\n        TIMES(i, N) {\n            nodes[i].edges.insert(nodes[i].edges.end(), nodes[i].pending.begin(), nodes[i].pending.end());\n        }\n        cout << N << endl;\n\n        int M;\n        cin >> M;\n        TIMES(_, M) {\n            string cross;\n            cin >> cross;\n            const int hyphen = cross.find('-');\n            const int a = dict.get(cross.substr(0, hyphen));\n            const int b = dict.get(cross.substr(hyphen+1));\n            bool ans = true;\n            if(a >= N || b >= N) {\n                ans = false;\n            } else if(nodes[a].group != nodes[b].group) {\n                ans = false;\n            } else if(nodes[a].color == nodes[b].color) {\n                ans = false;\n            } else {\n                fill(visited.begin(), visited.end(), 0);\n                ans = check(b, a, nodes, visited);\n            }\n            cout << (ans?\"YES\":\"NO\") << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <string.h>\n#define pb push_back\nusing namespace std;\n\nint n,m;\nvector<string> snum;\nvector<vector<int> >g1,g2;\nint g[2000][2000];\nbool vis[2000];\nvector<int> iro;\n\nint find1(string st){\n  int i;\n  for(i=0;i<snum.size();i++){\n    if(snum[i]==st) return i;\n  }\n  return -1;\n}\n\nbool sol1(int t1,int t2,int x){\n  if(t1==t2){\n    if(x%2==1)return true;\n    else return false;\n  }  \n  int i;\n  for(i=0;i<g1[t1].size();i++){\n    if(vis[g1[t1][i]]==false){\n      vis[g1[t1][i]]=true;\n      if(g[t1][g1[t1][i]]==1){\n        if(sol1(g1[t1][i],t2,x)) return true;\n      }\n      else{\n        if(sol1(g1[t1][i],t2,x+1)) return true;\n      }\n      vis[g1[t1][i]]=false;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int i,j,k;\n  string s;\n  string st1,st2;\n  while(cin>>n,n){\n    memset(g,0,sizeof(g));\n    snum.clear();g1.clear();g2.clear();iro.clear();\n    for(i=0;i<n;i++){\n      vector<int> b1,b2;\n      g1.pb(b1);\n      g2.pb(b2);\n    }\n    k=0;\n    for(i=0;i<n;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      if(find1(st1)==-1) snum.pb(st1);\n      if(find1(st2)==-1) snum.pb(st2);\n      g1[find1(st1)].pb(find1(st2));\n      g2[find1(st2)].pb(find1(st1));\n    }\n  \n    for(i=0;i<g2.size();i++){\n      \n      for(j=0;j<g2[i].size();j++){\n        int t=g2[i][j];\n        for(k=j;k<g2[i].size();k++){\n          g1[t].pb(g2[i][k]);\n          g1[g2[i][k]].pb(t);\n          g[t][g2[i][k]]=1;\n          g[g2[i][k]][t]=1;\n        }\n      }      \n    }\n  \n    cin>>m;\n    for(i=0;i<m;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      memset(vis,0,sizeof(vis));\n      if(sol1(find1(st1),find1(st2),0)) cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <string.h>\n#define pb push_back\nusing namespace std;\n\nint n,m;\nvector<string> snum;\nvector<vector<int> >g1,g2;\nint g[2000][2000];\nvector<bool> vis;\nvector<int> iro;\n\nint find1(string st){\n  int i;\n  for(i=0;i<snum.size();i++){\n    if(snum[i]==st) return i;\n  }\n  return -1;\n}\n\nbool sol1(int t1,int t2,int x){\n  if(t1==t2){\n    if(x%2==1)return true;\n    else return false;\n  }  \n  int i;\n  for(i=0;i<g1[t1].size();i++){\n    if(vis[g1[t1][i]]==false){\n      vis[g1[t1][i]]=true;\n      if(g[t1][g1[t1][i]]==1){\n        if(sol1(g1[t1][i],t2,x)) return true;\n      }\n      else{\n        if(sol1(g1[t1][i],t2,x+1)) return true;\n      }\n      vis[g1[t1][i]]=false;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int i,j,k;\n  string s;\n  string st1,st2;\n  while(cin>>n,n){\n    memset(g,0,sizeof(g));\n    snum.clear();g1.clear();g2.clear();vis.clear();iro.clear();\n    for(i=0;i<n;i++){\n      vector<int> b1,b2;\n      g1.pb(b1);\n      g2.pb(b2);\n      vis.pb(false);\n    }\n    k=0;\n    for(i=0;i<n;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      if(find1(st1)==-1) snum.pb(st1);\n      if(find1(st2)==-1) snum.pb(st2);\n      g1[find1(st1)].pb(find1(st2));\n      g2[find1(st2)].pb(find1(st1));\n    }\n  \n    for(i=0;i<g2.size();i++){\n      for(j=0;j<g2[i].size();j++){\n        int t=g2[i][j];\n        for(k=j;k<g2[i].size();k++){\n          g1[t].pb(g2[i][k]);\n          g1[g2[i][k]].pb(t);\n          g[t][g2[i][k]]=1;\n          g[g2[i][k]][t]=1;\n        }\n      }      \n    }\n  \n    cin>>m;\n    for(i=0;i<m;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      for(j=0;j<g1.size();j++){vis[j]=false;}\n      if(sol1(find1(st1),find1(st2),0)) cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n  bool used[201];\n  map<string,int>m;\n  char qq;\n  vector<int>mg[201],yg[201];\n  int o,a[201];\n  int c=1;\n  scanf(\"%c\",&qq);\n  for(int i=0;i<n;i++){\n    string s1,s2;\n    int ccc=0;\n    while(1){\n      char cc;\n      scanf(\"%c\",&cc);\n      if(cc=='\\n')break;\n      if(cc=='-'){ccc++;continue;}\n      if(!ccc)s1+=cc;\n      else s2+=cc;\n    }//cout<<s1<<endl<<s2<<endl;\n    if(!m[s1])m[s1]=c++;\n    if(!m[s2])m[s2]=c++;\n    yg[m[s1]].push_back(m[s2]);\n    mg[m[s1]].push_back(m[s2]);\n    mg[m[s2]].push_back(m[s1]);\n  }\n  r(i,201)used[i]=0;\n  queue<pair<int,int> >q;\n  q.push(mk(1,0));\n  while(!q.empty()){\n      pair<int,int>p=q.front();q.pop();\n      a[p.f]=p.s%2;\n      r(i,mg[p.f].size())\n\tif(!used[mg[p.f][i]]){\n\t  q.push(mk(mg[p.f][i],p.s+1));\n\t  used[mg[p.f][i]]=1;\n\t}\n  }\n    cout<<c-1<<endl;\n    cin>>o;\n    char kl;\n    scanf(\"%c\",&kl);\n    while(o--){//cout<<1;\n      string s1,s2;\n      int ccc=0,u=0;\n      while(1){\n        char cc;\n        scanf(\"%c\",&cc);\n        if(cc=='\\n')break;\n        if(cc=='-'){ccc++;continue;}\n        if(!ccc)s1+=cc;\n        else s2+=cc;\n      }\n      if(a[m[s1]]==a[m[s2]])cout<<\"No\"<<endl;\n      else if(!m[s1])cout<<\"No\"<<endl;\n      else if(!m[s2])cout<<\"No\"<<endl;\n      else{//cout<<1;\n\tr(i,201)used[i]=0;\n\tqueue<int>p;\n\tp.push(m[s1]);\n\tused[m[s1]]=1;\n\twhile(!p.empty()){\n\t  int t=p.front();p.pop();\n\t  r(i,yg[t].size())\n\t    if(!used[yg[t][i]]){\n\t      if(yg[t][i]==m[s2]){cout<<\"Yes\"<<endl;u++;goto KKK;}\n\t      p.push(yg[t][i]);\n\t      used[yg[t][i]]=1;\n\t    }\n\t}//cout<<1;\n\tKKK:;\n\tif(!u){r(i,201)used[i]=0;\n\tqueue<int> w;\n\tw.push(m[s2]);\n\tused[m[s2]]=1;\n\twhile(!w.empty()){\n\t  int t=w.front();w.pop();\n\t  r(i,yg[t].size())\n\t    if(!used[yg[t][i]]){\n\t      if(yg[t][i]==m[s1]){cout<<\"No\"<<endl;goto LLL;}\n\t      w.push(yg[t][i]);\n\t      used[yg[t][i]]=1;\n\t    }\n\t}\n\tcout<<\"Yes\"<<endl;}\n\tif(0)LLL:;\n      }\n    }\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<vector>\n#include<tuple>\nusing namespace std;\n\nconst int INF = 10000;\n\nint main() {\n    int n, m;\n    while(cin >> n, n) {\n        map<string, int> id;\n        vector<tuple<int, int>> cross;\n        int size = 0;\n        for(int i = 0; i < n; ++i) {\n            string x, y, input;\n            int index;\n            cin >> input;\n            index = input.find(\"-\");\n            x = input.substr(0, index);\n            y = input.substr(index + 1, input.size() - index - 1);\n            if(!id.count(x)) id[x] = size++;\n            if(!id.count(y)) id[y] = size++;\n            cross.push_back(tuple<int, int>(id[x], id[y]));\n        }\n\n        // adjacent matrix\n        vector<vector<int>> distance(size, vector<int>(size, INF));\n        for(auto& c: cross) distance[get<0>(c)][get<1>(c)] = 1;\n        for(int a = 0; a < size; ++a) for(int b  = a + 1; b < size; ++b) {\n            set<int> ac, ca, bc, cb;\n            for(auto c: cross) {\n                if(get<0>(c) == a) ac.insert(get<1>(c));\n                if(get<1>(c) == a) ca.insert(get<0>(c));\n                if(get<0>(c) == b) bc.insert(get<1>(c));\n                if(get<1>(c) == b) cb.insert(get<0>(c));\n            }\n            bool condition1 = false;\n            bool condition2 = true;\n            bool condition3 = true;\n            for(auto v: ca) {\n                if(bc.count(v)) condition2 = false;\n                if(cb.count(v)) condition1 = true;\n            }\n            for(auto v: ac) {\n                if(cb.count(v)) condition3 = false;\n                if(bc.count(v)) condition1 = true;\n            }\n            if(condition1 && condition2 && condition3) {\n                distance[a][b] = distance[b][a] = 0;\n            }\n        }\n\n        // Warshal-Floyd\n        for(int k = 0; k < size; ++k) for(int i = 0; i < size; ++i) for(int j = 0; j < size; ++j)\n            distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]);\n\n        // output\n        cout << size << endl;\n        for(cin >> m; m > 0; --m) {\n            string x, y, input;\n            int index;\n            cin >> input;\n            index = input.find(\"-\");\n            x = input.substr(0, index);\n            y = input.substr(index + 1, input.size() - index - 1);\n            if(!id.count(x) || !id.count(y)) cout << \"NO\" << endl;\n            else cout << (distance[id[x]][id[y]] & 1 ? \"YES\" : \"NO\") << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n \nusing namespace std;\n \nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n \nbool eq_str(const string& p,const string& q){ p==q; }\n \nmultimap<string,string>m1,m2;\nmap<string,int>color;\n \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n \nint graph[300][300];\n \nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n    graph[i][j]|=graph[i][k]&graph[k][j];\n}\n \nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n    \n    //for(int i=0;i<node.size();i++)cout << node[i] << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    bool g[300][300];\n    for(int i=0;i<300;i++){\n      for(int j=0;j<300;j++){\n\tg[i][j]=false;\n\tgraph[i][j]=i==j?1:0; \n      }\n    }\n    \n    multimap<string,string>::iterator it=m1.begin(),it2=m1.begin();\n    \n    while(it!=m1.end()){\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).sec){\n\t  graph[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  graph[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  graph[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  graph[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n\tit2++;\n      }\n      it++;\n    }\n    \n    it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n    \n    warshall_floyd(node3.size());\n    \n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO \" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef string Vertex;\ntypedef pair<Vertex, Vertex> PVV;\ntypedef map <Vertex, int> Index;\n\nconst int inf = 1<<24;\nconst int size = 201;\nIndex ID;\nint N;\n\nbool F[size][size];\nbool D[size][size];\nbool W[size][size];\nint  T[size][size];\n\nvoid init() {\n    ID.clear();\n    N = 0;\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            F[i][j] = false;\n            D[i][j] = false;\n            W[i][j] = false;\n            T[i][j] = inf;\n        }\n    }\n}\n\nbool exist( Vertex v ) {\n    return ID.find(v) != ID.end();\n}\n\nvoid addVertex( Vertex v ) {\n    if ( exist( v ) ) return;\n    ID[v] = N++;\n}\n\nint getIndex( Vertex v ) {\n    return ID[v];\n}\n\nPVV input() {\n    string line;\n    cin >> line;\n    replace( line.begin(), line.end(), '-', ' ' );\n    istringstream is( line );\n    PVV answer;\n    is >> answer.first >> answer.second;\n    return answer;\n}\n\nbool solve( PVV e ) {\n    if ( !exist(e.first) || !exist(e.second) ) return false;\n    int a = getIndex( e.first );\n    int b = getIndex( e.second );\n    return W[a][b] && ( T[a][b] == inf || T[a][b]%2 );\n}\n\nbool check1( int a, int b, int c ) {\n    if ( a == b || b == c || c == a ) return false;\n    return ( F[a][c] && !F[c][a] && F[b][c] && !F[c][b] )\n        || ( F[c][a] && !F[a][c] && F[c][b] && !F[b][c] );\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        init();\n        for ( int i = 0; i < n; i++ ) {\n            PVV in = input();\n            addVertex(in.first);\n            addVertex(in.second);\n            int a = getIndex(in.first);\n            int b = getIndex(in.second);\n            F[a][b] = true;\n            T[a][b] = 1;\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                for ( int k = 0; k < N; k++ ) {\n                    if ( check1( i, j, k ) ) {\n                        D[i][j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                W[i][j] = F[i][j] || D[i][j];\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    W[i][j] = W[i][j] || ( W[i][k] && W[k][j] );\n                }\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    T[i][j] = min( T[i][j], T[i][k] + T[k][j] );\n                }\n            }\n        }\n        int m;\n        cin >> m;\n        cout << N << endl;\n        for ( int i = 0; i < m; i++ ) {\n            PVV in = input();\n            cout << ( solve( in ) ? \"YES\" : \"NO\" ) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing ps = pair<string,string>;\n\nps split(string s){\n    int n = s.size();\n    int idx = 0;\n    while(idx<n && s[idx]!='-') ++idx;\n\n    return {s.substr(0,idx), s.substr(idx+1)};\n}\n\nconst int N = 300;\nconst int INF = 191919;\n\n// 入力から分かる強さ関係\nvector<int> G[N];\nbool arr[N][N];\n\nint d[N][N];\n\n// 水準関係\nint C[N][N];\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        rep(i,N) G[i].clear();\n        rep(i,N)rep(j,N) arr[i][j] = false;\n\n        rep(i,N)rep(j,N) d[i][j]=INF;\n        rep(i,N) d[i][i]=0;\n\n        rep(i,N)rep(j,N) C[i][j]=INF;\n        rep(i,N) C[i][i]=0;\n\n\n        map<string,int> c2id;\n        vector<string> names;\n        rep(i,n){\n            string s;\n            cin >>s;\n            ps cross = split(s);\n\n            if(!c2id.count(cross.fi)){\n                c2id[cross.fi] = c2id.size();\n                names.pb(cross.fi);\n            }\n            if(!c2id.count(cross.se)){\n                c2id[cross.se] = c2id.size();\n                names.pb(cross.se);\n            }\n            int u = c2id[cross.fi], v = c2id[cross.se];\n            G[u].pb(v);\n            C[u][v]=1;\n            d[u][v] = d[v][u] = 1;\n            arr[u][v] = true;\n        }\n\n        int V = c2id.size();\n\n        rep(k,V)rep(i,V)rep(j,V) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        auto same_degree = [&](int a, int b){\n            bool same = false;\n            rep(i,V){\n                if( (arr[a][i]||arr[i][a]) && (arr[b][i]||arr[i][b]) ) same = true;\n            }\n            if(!same) return false;\n\n            rep(i,V){\n                if(arr[i][a]&&arr[b][i]) return false;\n                if(arr[a][i]&&arr[i][b]) return false;\n            }\n            return true;\n        };\n\n        rep(i,V)rep(j,i){\n            if(same_degree(i,j)){\n                // cout << \"DEG :: \" << names[i] << \" \" << names[j] << endl;\n                C[i][j] = C[j][i] = 1;\n            }\n        }\n        rep(k,V)rep(i,V)rep(j,V) C[i][j] = min(C[i][j], C[i][k]+C[k][j]);\n\n        cout << V << endl;\n\n        int Q;\n        cin >>Q;\n        while(Q--){\n            string q;\n            cin >>q;\n\n            ps qc = split(q);\n\n            bool ok = false;\n            if(c2id.count(qc.fi) && c2id.count(qc.se)){\n                int u = c2id[qc.fi], v = c2id[qc.se];\n                // dbg(C[u][v]);\n\n                if(d[u][v]<INF && d[u][v]%2==1 && C[u][v]<INF) ok = true;\n            }\n            cout << (ok?\"YES\":\"NO\") << endl;\n        }\n\n        dbg(names);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nmap<string,int> ms;\nint e[222][222];\nint g[222][222];\nint used[222];\nint v;\nvoid dfs(int u,int d){\n  if(~used[u]) return;\n  //cout<<u<<\" \"<<d<<endl;\n  used[u]=d;\n  for(int i=0;i<v;i++){\n    if(used[i]<0){\n      if(e[u][i]) dfs(i,!d);\n      if(g[u][i]) dfs(i,d);\n    }\n  }\n} \nsigned main(){\n  int n,m;\n  while(cin>>n,n){\n    ms.clear();\n    string s[n];\n    for(int i=0;i<n;i++) cin>>s[i];\n    cin>>m;\n    string t[m];\n    for(int i=0;i<m;i++) cin>>t[i];\n    memset(e,0,sizeof(e));\n    v=0;\n    for(int i=0;i<n;i++){\n      int k=s[i].find('-');\n      string x=s[i].substr(0,k);\n      string y=s[i].substr(k+1,s[i].size()-(k+1));\n      if(!ms.count(x)) ms[x]=v++;\n      if(!ms.count(y)) ms[y]=v++;\n      //cout<<x<<\" \"<<y<<\" \"<<ms[x]<<\" \"<<ms[y]<<endl;\n      e[ms[x]][ms[y]]=1;\n    }\n    for(int i=0;i<v;i++){\n      for(int j=i+1;j<v;j++){\n\tbool f1=0,f2=0;\n\tfor(int k=0;k<v;k++){\n\t  if(i==k||j==k) continue;\n\t  f1|=(e[i][k]||e[k][i])&&(e[j][k]||e[k][j]);\n\t  f2|=(e[k][i]&&e[j][k]);\n\t  f2|=(e[i][k]&&e[k][j]);\n\t}\n\tif(f1&&!f2) g[i][j]=g[j][i]=1;\n      }\n    }\n    cout<<v<<endl;\n    for(int i=0;i<m;i++){\n      int k=t[i].find('-');\n      string x=t[i].substr(0,k);\n      string y=t[i].substr(k+1,t[i].size()-(k+1));\n      if(!ms.count(x)||!ms.count(y)){\n\tcout<<\"NO\"<<endl;\n\tcontinue;\n      }\n      memset(used,-1,sizeof(used));\n      dfs(ms[x],0);\n      //cout<<used[ms[y]]<<endl;\n      cout<<(used[ms[y]]==1?\"YES\":\"NO\")<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n\n#define REP(i,n) for(int i=0; i<(n); i++)\n#define MAX (100000)\n\nusing namespace std;\n\nint g[200][200];\n\nint main(){\n  int n;\n  while(cin>>n, n){\n    map<string,int> p;\n    REP(i,200) REP(j,200) g[i][j] = MAX;\n    int cnt = 0;\n\n    REP(i,n){\n      string str;\n      string l,r;\n      int ll,rr;\n      cin>>str;\n\n      int pos = str.find('-');\n      l = str.substr(0,pos);\n      r = str.substr(pos+1);\n      \n      if(p.count(l)) ll = p[l];\n      else ll = p[l] = cnt++;\n      if(p.count(r)) rr = p[r];\n      else rr = p[r] = cnt++;\n\n      //printf(\"%s => %d  %s => %d\\n\",l.c_str(),ll,r.c_str(),rr);\n      g[ll][rr] = 1;\n    }\n\n    int num = p.size();\n    REP(i,num) for(int j=i+1; j<num; j++){\n      bool a = false;\n      bool b = false;\n\n      if(g[i][j] == 1 || g[j][i] == 1) continue;\n\n      REP(k,num){\n\tif(k == i || k == j) continue;\n\tif((g[i][k] == 1 || g[k][i] == 1) &&\n\t   (g[j][k] == 1 || g[k][j] == 1))\n\t  a = true;\n\n\tif((g[i][k] == 1 && g[k][j] == 1) ||\n\t   (g[k][i] == 1 && g[j][k] == 1))\n\t  b = true;\n      }\n\n      if(a && !b) g[i][j] = g[j][i] = 0;\n    }\n\n    REP(k,num) REP(i,num) REP(j,num)\n      g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\n    //REP(i,num) { REP(j,num) printf(\"%6d \",g[i][j]); puts(\"\"); }\n\n    int m; cin>>m;\n    printf(\"%d\\n\",num);\n    REP(i,m){\n      string str;\n      string l,r;\n      int ll,rr;\n      cin>>str;\n\n      int pos = str.find('-');\n      l = str.substr(0,pos);\n      r = str.substr(pos+1);\n      \n      if(p.count(l)) ll = p[l];\n      else goto bad;\n      if(p.count(r)) rr = p[r];\n      else goto bad;\n\n      if(g[ll][rr] != MAX && g[ll][rr] % 2 == 1)\n\tputs(\"YES\");\n      else\n\tputs(\"NO\");\n\n      continue;\n    bad:\n      puts(\"NO\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct Node{\n    string name;\n    vector<int> edge,rev;\n    int col;\n};\n\nstd::vector<string> splitAll(string s,string t){\n  std::vector<string> v;\n  for(int p=0; (p = s.find(t)) != s.npos; ){\n    v.push_back(s.substr(0,p));\n    s=s.substr(p+t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\nvoid dfs(vector<Node> &g,int v,int use,bool col) {\n    if(g[v].col != -1) return;\n    g[v].col = use - (col?1:0);\n    for(int i=0; i<g[v].edge.size(); ++i)\n        dfs(g,g[v].edge[i], use, !col);\n\n    for(int i=0; i<g[v].rev.size(); ++i)\n        dfs(g,g[v].rev[i], use, !col);\n\n    return;\n}\n\nvoid make_graph(vector<Node> &g) {\n    for(int i=0; i<g.size(); ++i)\n        for(int j=i+1; j<g.size(); ++j) {\n            bool ok = false;\n            for(int k=0; k<g.size(); ++k) {\n                int c1 = count(g[i].edge.begin(), g[i].edge.end(), k);\n                int c2 = count(g[i].rev.begin(), g[i].rev.end(), k);\n                int d1 = count(g[j].edge.begin(), g[j].edge.end(), k);\n                int d2 = count(g[j].rev.begin(), g[j].rev.end(), k);\n                if((c1 > 0 && d2 > 0) || (c2 > 0 && d1 > 0)) goto NEXT;\n                if((c1 > 0 && d1 > 0) || (c2 > 0 && d2 > 0)) ok = true;\n            }\n            if(ok) g[i].edge.push_back(j),g[j].edge.push_back(i);\n        NEXT:;\n        }\n}\n\nvoid coloring(vector<Node> &g) {\n    int use = -1;\n    for(int i=0; i<g.size(); ++i) {\n        if(g[i].col != -1) continue;\n        use += 2;\n        dfs(g, i, use, true);\n    }\n}\n\nbool seen[205];\n\nbool dfs2(vector<Node> &g,int v,int target) {\n    if(v == target) return true;\n    seen[v] = true;\n    for(int i=0; i<g[v].edge.size(); ++i) {\n        if(seen[g[v].edge[i]]) continue;\n        if(dfs2(g, g[v].edge[i], target)) return true;\n    }\n    return false;\n}\n\nint main() {\n    int n,m;\n    string in;\n    while(cin>>n) {\n        if(n == 0) break;\n        map<string, int> idx;\n        vector<Node> g;\n        for(int i=0; i<n; ++i) {\n            cin>>in;\n            vector<string> vs = splitAll(in, \"-\");\n            string name1 = vs[0],name2 = vs[1];\n            if(idx.find(name1) == idx.end()) {\n                idx[name1] = g.size();\n                Node no; no.name = name1; no.col = -1;\n                g.push_back(no);\n            }\n            if(idx.find(name2) == idx.end()) {\n                idx[name2] = g.size();\n                Node no; no.name = name2; no.col = -1;\n                g.push_back(no);\n            }\n            g[idx[name1]].edge.push_back(idx[name2]);\n            g[idx[name2]].rev.push_back(idx[name1]);\n        }\n\n        coloring(g);\n        make_graph(g);\n        cout<<g.size()<<endl;\n        // for(int i=0; i<g.size(); ++i)\n        //     cout<<i<<\" : \"<<g[i].name<<endl;\n\n        cin>>m;\n        for(int i=0; i<m; ++i) {\n            cin>>in;\n            vector<string> vs = splitAll(in, \"-\");\n            string name1 = vs[0], name2 = vs[1];\n            if(idx.find(name1) == idx.end() || idx.find(name2) == idx.end()\n               || g[idx[name1]].col == g[idx[name2]].col) {\n                cout<<\"NO\"<<endl;\n                continue;\n            }\n\n            memset(seen, false, sizeof(seen));\n            if(dfs2(g,idx[name1],idx[name2])) {\n                cout<<\"YES\"<<endl;\n            }else{\n                cout<<\"NO\"<<endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\nvoid chmin(int &a, int b) {\n    a = min(a, b);\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N;\nunordered_map<string, int> mp;\nset<string> st;\nstring intersection[1005];\nstring before[1005], after[1005];\nstring name[205];\nint dist[205][205];\nbool beforei[205][205], afteri[205][205];\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    UnionFind uni;\n    int timer = 0;\n    while(true) {\n        timer++;\n        //cerr << timer << endl;\n        uni.init(500);\n        st.clear();\n        mp.clear();\n        cin >> N;\n        if(N == 0) break;\n        for(int i = 1; i <= N; i++) {\n            cin >> intersection[i];\n            int moji = 0;\n            while(intersection[i][moji] != '-') moji++;\n            before[i] = intersection[i].substr(0, moji);\n            after[i] = intersection[i].substr(moji + 1);\n            st.insert(before[i]);\n            st.insert(after[i]);\n            //cerr << before[i] << \" \" << after[i] << endl;\n        }\n        int num = 0;\n        for(auto itr = st.begin(); itr != st.end(); itr++) {\n            num++;\n            mp[*itr] = num;\n            name[num] = *itr;\n        }\n        for(int i = 1; i <= num; i++) {\n            for(int j = 1; j <= num; j++) beforei[i][j] = false, afteri[i][j] = false;\n            for(int k = 1; k <= N; k++) {\n                if(mp[before[k]] == i) afteri[i][mp[after[k]]] = true;\n                if(mp[after[k]] == i) beforei[i][mp[before[k]]] = true;\n            }\n        }\n        for(int i = 1; i <= num; i++) {\n            for(int j = i + 1; j <= num; j++) {\n                /*\n                cerr << \"----\" << i << \"----\" << endl;\n                for(int k = 1; k <= num; k++) {\n                    cerr << k << \" \" << beforei[k] << \" \" << afteri[k] << endl;\n                }\n                */\n                bool isok = false;\n                for(int k = 1; k <= num; k++) {\n                    if(beforei[i][k] && beforei[j][k]) isok = true;\n                    if(afteri[i][k] && afteri[j][k]) isok = true;\n                }\n                if(!isok) continue;\n                for(int k = 1; k <= num; k++) {\n                    if(beforei[i][k] && afteri[j][k]) isok = false;\n                    if(beforei[j][k] && afteri[i][k]) isok = false;\n                }\n                if(isok) uni.merge(i, j);\n            }\n        }\n        /*\n        for(int i = 1; i <= num; i++) {\n            cerr << i << \" \" << name[i] << \" \" << uni.root(i) << endl;\n        }\n        */\n        for(int i = 1; i <= num; i++) {\n            for(int j = 1; j <= num; j++) {\n                dist[i][j] = INF;\n            }\n            dist[i][i] = 0;\n        }\n        /*\n        UnionFind uni2(1000);\n        for(int i = 1; i <= N; i++) {\n            uni2.merge(mp[before[i]], mp[after[i]] + 200);\n            uni2.merge(mp[before[i]] + 200, mp[after[i]]);\n            dist[mp[before[i]]][mp[after[i]]] = 1;\n        }\n        */\n       for(int i = 1; i <= N; i++) {\n           dist[uni.root(mp[before[i]])][uni.root(mp[after[i]])] = 1;\n       }\n        for(int i = 1; i <= num; i++) {\n            for(int j = 1; j <= num; j++) {\n                for(int k = 1; k <= num; k++) {\n                    chmin(dist[j][k], dist[j][i] + dist[i][k]);\n                }\n            }\n        }\n        /*\n        for(int i = 1; i <= num; i++) {\n            for(int j = 1; j <= num; j++) cerr << dist[i][j] << \" \";\n            cerr << endl;\n        }\n        */\n        int M;\n        cin >> M;\n        cout  << st.size() << endl;\n        while(M--) {\n            string in;\n            cin >> in;\n            string a, b;\n            int moji = 0;\n            while(in[moji] != '-') moji++;\n            a = in.substr(0, moji);\n            b = in.substr(moji + 1);\n            if(st.find(a) == st.end() || st.find(b) == st.end()) {\n                cout << \"NO\" << endl;\n                continue;\n            }\n            a = name[uni.root(mp[a])];\n            b = name[uni.root(mp[b])];\n            //cerr << a << \" \" << mp[a] << \" \" << b << \" \" << mp[b] << endl;\n            /*\n            if(!uni2.issame(mp[a], mp[b] + 200)) {\n                //cerr << \"NOT CONNECTED\" << endl;\n                cout << \"NO\" << endl;\n                continue;\n            }\n            */\n            //cerr << dist[mp[a]][mp[b]] << endl;\n            if(dist[mp[a]][mp[b]] == INF) cout << \"NO\" << endl;\n            else if(dist[mp[a]][mp[b]] % 2 == 0) cout << \"NO\" << endl;\n            else cout << \"YES\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int INF = 1e8;\n\nint bfs(int s, int t, vector< vector<pii> > &g){\n  int n = g.size();\n  vector<int> d(n,INF);\n  d[s] = 0;\n  deque<int> q;\n  q.push_back(s);\n\n  while(q.size()){\n    int v = q.front(); q.pop_front();\n    if(v==t)break;\n    \n    for(pii p : g[v]){\n      int u = p.second;\n      if(p.first == 0 && d[u]==INF){\n\td[u] = d[v];\n\tq.push_front(u);\n      }else if(p.first == 1 && d[u]==INF){\n\td[u] = d[v]+1;\n\tq.push_back(u);\n      }\n    }\n  }\n  return d[t];\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int n;\n  while(cin >> n, n){\n    int ns = 0;\n    map<string,int> id;\n    vector<pii> edges;\n\n    rep(i,n){\n      string s; cin >> s;\n      int p = s.find(\"-\");\n      string a = s.substr(0,p), b = s.substr(p+1);\n      if(id.count(a)==0)id[a] = ns++;\n      if(id.count(b)==0)id[b] = ns++;\n      edges.push_back(pii(id[a],id[b]));\n    }\n\n    vector<vi> adj(ns,vi(ns,0));\n    vector< vector<pii> > g(ns);\n    for(pii e : edges){\n      int u = e.first, v = e.second;\n      adj[u][v] = 1;\n      g[u].push_back(pii(1,v));\n    }\n\n    rep(i,ns)rep(j,ns){\n      int a = 0, b = 0, c = 0;\n      rep(k,ns){\n\tif((adj[i][k] && adj[j][k]) || (adj[k][i] && adj[k][j]))a++;\n\tif(adj[i][k] && adj[k][j])b++;\n\tif(adj[j][k] && adj[k][i])c++;\n\tif(a && !b && !c){\n\t  g[i].push_back(pii(0,j));\n\t  g[j].push_back(pii(0,i));\n\t}\n      }\n    }\n    cout << ns << endl;\n\n    int m;\n    cin >> m;\n    rep(i,m){\n      string s; cin >> s;\n      int p = s.find(\"-\");\n      string a = s.substr(0,p), b = s.substr(p+1);\n      if(id.count(a)==0 || id.count(b)==0){\n\tcout << \"NO\" << endl; continue;\n      }\n\n      int d = bfs(id[a],id[b],g);\n      if(d==INF || d%2==0)cout << \"NO\" << endl;\n      else cout << \"YES\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing ps = pair<string,string>;\n\nps split(string s){\n    int n = s.size();\n    int idx = 0;\n    while(idx<n && s[idx]!='-') ++idx;\n\n    return {s.substr(0,idx), s.substr(idx+1)};\n}\n\nconst int N = 200;\nconst int INF = 191919;\n\n// 入力から分かる強さ関係\nvector<int> G[N];\nbool arr[N][N];\n\nint d[N][N];\n\n// 水準関係\nint C[N][N];\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        rep(i,N) G[i].clear();\n        rep(i,N)rep(j,N) C[i][j]=INF;\n        rep(i,N) C[i][i]=0;\n        rep(i,N)rep(j,N) d[i][j]=INF;\n        rep(i,N) d[i][i]=0;\n        rep(i,N)rep(j,N) arr[i][j] = false;\n\n\n        map<string,int> c2id;\n        vector<string> names;\n        rep(i,n){\n            string s;\n            cin >>s;\n            ps cross = split(s);\n\n            if(!c2id.count(cross.fi)){\n                c2id[cross.fi] = c2id.size();\n                names.pb(cross.fi);\n            }\n            if(!c2id.count(cross.se)){\n                c2id[cross.se] = c2id.size();\n                names.pb(cross.se);\n            }\n            int u = c2id[cross.fi], v = c2id[cross.se];\n            G[u].pb(v);\n            C[u][v]=1;\n            d[u][v] = d[v][u] = 1;\n            arr[u][v] = true;\n        }\n\n        int V = c2id.size();\n\n        rep(k,V)rep(i,V)rep(j,V) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        auto same_degree = [&](int a, int b){\n            bool same = false;\n            rep(i,V){\n                if( (arr[a][i]||arr[i][a]) && (arr[b][i]||arr[i][b]) ) same = true;\n            }\n            if(!same) return false;\n\n            rep(i,V){\n                if(arr[i][a]&&arr[b][i]) return false;\n                if(arr[a][i]&&arr[i][b]) return false;\n            }\n            return true;\n        };\n\n        rep(i,V)rep(j,i){\n            if(same_degree(i,j)){\n                // cout << \"DEG :: \" << names[i] << \" \" << names[j] << endl;\n                C[i][j] = C[j][i] = 1;\n            }\n        }\n        rep(k,V)rep(i,V)rep(j,V) C[i][j] = min(C[i][j], C[i][k]+C[k][j]);\n\n        if(V>N) while(1){}\n        cout << V << endl;\n\n        int Q;\n        cin >>Q;\n        while(Q--){\n            string q;\n            cin >>q;\n\n            ps qc = split(q);\n\n            bool ok = false;\n            if(c2id.count(qc.fi) && c2id.count(qc.se)){\n                int u = c2id[qc.fi], v = c2id[qc.se];\n                // dbg(C[u][v]);\n\n                if(d[u][v]%2==1 && C[u][v]<INF) ok = true;\n            }\n            cout << (ok?\"YES\":\"NO\") << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nmap<string,int> ms;\nint e[222][222];\nint g[222][222];\nint used[222];\nint v;\nvoid dfs(int u,int d){\n  if(~used[u]) return;\n  //cout<<u<<\" \"<<d<<endl;\n  used[u]=d;\n  for(int i=0;i<v;i++){\n    if(used[i]<0){\n      if(e[u][i]) dfs(i,!d);\n      if(g[u][i]) dfs(i,d);\n    }\n  }\n} \nsigned main(){\n  int n,m;\n  while(cin>>n,n){\n    ms.clear();\n    string s[n];\n    for(int i=0;i<n;i++) cin>>s[i];\n    cin>>m;\n    string t[m];\n    for(int i=0;i<m;i++) cin>>t[i];\n    memset(e,0,sizeof(e));\n    v=0;\n    for(int i=0;i<n;i++){\n      int k=s[i].find('-');\n      string x=s[i].substr(0,k);\n      string y=s[i].substr(k+1,s[i].size()-(k+1));\n      if(!ms.count(x)) ms[x]=v++;\n      if(!ms.count(y)) ms[y]=v++;\n      //cout<<x<<\" \"<<y<<\" \"<<ms[x]<<\" \"<<ms[y]<<endl;\n      e[ms[x]][ms[y]]=1;\n    }\n    assert(v<=200);\n    for(int i=0;i<v;i++){\n      for(int j=i+1;j<v;j++){\n\tbool f1=0,f2=0;\n\tfor(int k=0;k<v;k++){\n\t  if(i==k||j==k) continue;\n\t  f1|=(e[i][k]||e[k][i])&&(e[j][k]||e[k][j]);\n\t  f2|=(e[k][i]&&e[j][k]);\n\t  f2|=(e[i][k]&&e[k][j]);\n\t}\n\tif(f1&&!f2) g[i][j]=g[j][i]=1;\n      }\n    }\n    cout<<v<<endl;\n    for(int i=0;i<m;i++){\n      int k=t[i].find('-');\n      string x=t[i].substr(0,k);\n      string y=t[i].substr(k+1,t[i].size()-(k+1));\n      if(!ms.count(x)||!ms.count(y)){\n\tcout<<\"NO\"<<endl;\n\tcontinue;\n      }\n      memset(used,-1,sizeof(used));\n      dfs(ms[x],0);\n      //cout<<used[ms[y]]<<endl;\n      cout<<(used[ms[y]]==1?\"YES\":\"NO\")<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\n#include <cassert>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\n\nint N, M;\nmap<string, int> mp;\nbool e[200][200];\nbool ee[200][200];\nint t[200];\n\nvoid dfs(int v, int c){\n    t[v] = c;\n    for(int i=0; i<mp.size(); i++) if(i != v && (e[v][i] || e[i][v])){\n        if(t[i]) assert(t[i] == -c);\n        else dfs(i, -c);\n    }\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin >> N, N){\n        //init\n        mp.clear();\n        for(int i=0; i<200; i++){\n            for(int j=0; j<N; j++){\n                e[i][j] = ee[i][j] = i == j;\n            }\n            t[i] = 0;\n        }\n        \n        string st;\n        for(int i=0; i<N; i++){\n            cin >> st;\n            int j = 0;\n            while(st[j]!='-') j++;\n            string xx = st.substr(0, j);\n            string yy = st.substr(j+1, st.size()-j);\n            if(!mp.count(xx)) mp[xx] = mp.size();\n            if(!mp.count(yy)) mp[yy] = mp.size();\n            e[mp[xx]][mp[yy]] = true;\n        }\n        \n        int J = 1;\n        for(int i=0; i<mp.size(); i++){\n            if(t[i] == 0)\n                dfs(i, J++);\n        }\n        \n        for(int i=0; i<mp.size(); i++){\n            for(int j=0; j<mp.size(); j++) if(i != j){\n                bool fc = false;\n                bool fd = false;\n                for(int k=0; k<mp.size(); k++) if(k != i && k != j){\n                    fc |= (e[i][k] && e[j][k]) || (e[k][i] && e[k][j]);\n                    fd |= (e[i][k] && e[k][j]) || (e[j][k] && e[k][i]);\n                }\n                ee[i][j] = fc && !fd;\n            }\n        }\n        \n        for(int i=0; i<mp.size(); i++)\n            for(int j=0; j<mp.size(); j++)\n                e[i][j] |= ee[i][j];\n        \n        for(int k=0; k<mp.size(); k++)\n            for(int i=0; i<mp.size(); i++)\n                for(int j=0; j<mp.size(); j++)\n                    e[i][j] |= e[i][k] && e[k][j];\n        \n        cin >> M;\n        cout << mp.size() << endl;\n        for(int i=0; i<M; i++){\n            cin >> st;\n            int j = 0;\n            while(st[j]!='-') j++;\n            string xx = st.substr(0, j);\n            string yy = st.substr(j+1, st.size()-j);\n            \n            bool flag;\n            if(mp.count(xx) && mp.count(yy)){\n                int x = mp[xx], y = mp[yy];\n                flag = e[x][y] && !ee[x][y] && t[x] == -t[y];\n            }else{\n                flag = false;\n            }\n            cout << (flag? \"YES\": \"NO\") << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nmap<string,int> ms;\nint e[222][222];\nint g[222][222];\nint used[222];\nint v;\nvoid dfs(int u,int d){\n  //cout<<u<<\" \"<<d<<endl;\n  if(~used[u]) assert(used[u]==d);\n  if(~used[u]) return;\n  //cout<<u<<\" \"<<d<<endl;\n  used[u]=d;\n  for(int i=0;i<v;i++){\n    if(e[u][i]) dfs(i,!d);\n    if(g[u][i]) dfs(i,d);\n  }\n} \nsigned main(){\n  int n,m;\n  while(cin>>n,n){\n    ms.clear();\n    string s[n];\n    for(int i=0;i<n;i++) cin>>s[i];\n    cin>>m;\n    string t[m];\n    for(int i=0;i<m;i++) cin>>t[i];\n    memset(e,0,sizeof(e));\n    memset(g,0,sizeof(g));\n    v=0;\n    for(int i=0;i<n;i++){\n      int k=s[i].find('-');\n      string x=s[i].substr(0,k);\n      string y=s[i].substr(k+1,s[i].size()-(k+1));\n      if(!ms.count(x)) ms[x]=v++;\n      if(!ms.count(y)) ms[y]=v++;\n      e[ms[x]][ms[y]]=1;\n    }\n    assert(v<=200);\n    for(int i=0;i<v;i++){\n      for(int j=i+1;j<v;j++){\n\tbool f1=0,f2=0;\n\tfor(int k=0;k<v;k++){\n\t  if(i==k||j==k) continue;\n\t  f1|=(e[i][k]||e[k][i])&&(e[j][k]||e[k][j]);\n\t  f2|=(e[k][i]&&e[j][k]);\n\t  f2|=(e[i][k]&&e[k][j]);\n\t}\n\tif(f1&&!f2) g[i][j]=g[j][i]=1;\n\t//if(f1&&!f2) cout<<i<<\" \"<<j<<endl;\n      }\n    }\n    cout<<v<<endl;\n    for(int i=0;i<m;i++){\n      int k=t[i].find('-');\n      string x=t[i].substr(0,k);\n      string y=t[i].substr(k+1,t[i].size()-(k+1));\n      if(!ms.count(x)||!ms.count(y)){\n\tcout<<\"NO\"<<endl;\n\tcontinue;\n      }\n      //cout<<x<<\" \"<<y<<\" \"<<ms[x]<<\" \"<<ms[y]<<endl;\n      memset(used,-1,sizeof(used));\n      dfs(ms[x],0);\n      //cout<<used[ms[y]]<<endl;\n      cout<<(used[ms[y]]==1?\"YES\":\"NO\")<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\ndouble const pi = acos(-1);\nmap<string,int> rtoi;\n\nint d[256][256];\nint V;\n\nvoid solve(){\n    rep(i,V)rep(j,V){\n        bool C=false, DE=true;\n        if(d[i][j]==1 || d[j][i]==1) continue;\n        rep(k,V){\n            if(k==i || k==j) continue;\n            if((d[i][k]==1||d[k][i]==1) && (d[j][k]==1||d[k][j]==1))\n                C=true;\n            if((d[i][k]==1&&d[k][j]==1) || (d[k][i]==1&&d[j][k]==1))\n                DE=false;\n        }\n        if(C&&DE) d[i][j]=d[j][i]=0;\n    }\n    rep(k,V)rep(i,V)rep(j,V){\n        d[i][j]=min(d[i][j], d[i][k] + d[k][j]);\n    }\n}\n\nbool ask(string p, string q){\n    int pi=inf,qi=inf;\n    if(rtoi.count(p)==1 || rtoi.count(q)==1){\n        pi=rtoi[p], qi=rtoi[q];\n    }\n    return d[pi][qi]!=inf && d[pi][qi]&1;\n}\n\nint main(){\n    int n;\n    while(cin>>n, n){\n        rep(i,256) rep(j,256) d[i][j]=inf;\n        rep(i,n){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x);\n            string q=s.substr(x+1);\n            if(rtoi.count(p)==0)rtoi[p]=V++;\n            if(rtoi.count(q)==0)rtoi[q]=V++;\n            int ip=rtoi[p], iq=rtoi[q];\n            d[ip][iq]=1;\n        }\n        solve();\n        cout<<V<<endl;\n        int m; cin>>m;\n        rep(i,m){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x), q=s.substr(x+1);\n            puts(ask(p,q)  ? \"YES\" : \"NO\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nstruct Node {\n    int level;\n    int color;\n    int group;\n    vector<int> edges, back_edges;\n    vector<int> pending;\n    Node() : level(0), color(1) {}\n};\n\nstruct Dict {\n    int idx;\n    map<string,int> dict;\n\n    Dict() : idx(0) {}\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = idx++;\n    }\n\n    int size() const {\n        return idx;\n    }\n};\n\n#define FOREACH(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define TIMES(i,n) for(int (i) = 0; (i) < (n); ++(i))\n\ntypedef vector<unsigned char> Flag;\n\nvoid preprocess(int pos, vector<Node> &nodes, Flag &visited, int group) {\n    if(visited[pos]) return;\n    visited[pos] = 1;\n\n    Node &cur = nodes[pos];\n    cur.group = group;\n    FOREACH(it, cur.edges) {\n        if(visited[*it]) continue;\n        nodes[*it].level = cur.level+1;\n        nodes[*it].color = 1 - cur.color;\n        preprocess(*it, nodes, visited, group);\n    }\n    FOREACH(it, cur.back_edges) {\n        if(visited[*it]) continue;\n        nodes[*it].level = cur.level-1;\n        nodes[*it].color = 1 - cur.color;\n        preprocess(*it, nodes, visited, group);\n    }\n}\n\nbool is_same_level(int a, int b, const vector<Node> &nodes) {\n    vector<int> states(nodes.size(), 0);\n    FOREACH(it, nodes[a].edges) {\n        states[*it] |= 1;\n    }\n    FOREACH(it, nodes[b].edges) {\n        states[*it] |= 2;\n    }\n    FOREACH(it, nodes[a].back_edges) {\n        states[*it] |= 4;\n    }\n    FOREACH(it, nodes[b].back_edges) {\n        states[*it] |= 8;\n    }\n    bool has_c = false, has_d = false;\n    TIMES(i, nodes.size()) {\n        if(i == a || i == b) continue;\n        int state = states[i];\n        if((state & 0x0c) == 0x0c || (state & 0x03) == 0x03) {\n            has_c = true;\n        }\n        if((state & 0x09) == 0x09 || (state & 0x06) == 0x06) {\n            has_d = true;\n        }\n    }\n    return has_c && !has_d;\n}\n\nbool check(int from, int to, const vector<Node> &nodes, Flag &visited) {\n    if(visited[from]) return false;\n    if(from == to) return true;\n    visited[from] = 1;\n    const Node &cur = nodes[from];\n    FOREACH(it, cur.edges) {\n        if(check(*it, to, nodes, visited)) return true;\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Node> nodes(2*N);\n        Dict dict;\n        TIMES(_, N) {\n            string cross;\n            cin >> cross;\n            const int hyphen = cross.find('-');\n            const int a = dict.get(cross.substr(0, hyphen));\n            const int b = dict.get(cross.substr(hyphen+1));\n            nodes[b].edges.push_back(a);\n            nodes[a].back_edges.push_back(b);\n        }\n        N = dict.size();\n        nodes.resize(N);\n        Flag visited(N, 0);\n        TIMES(i, N) {\n            if(!visited[i]) {\n                preprocess(i, nodes, visited, i);\n            }\n        }\n        TIMES(i, N) {\n            TIMES(j, i) {\n                if(nodes[i].group == nodes[j].group) {\n                    if(is_same_level(i, j, nodes)) {\n                        nodes[i].pending.push_back(j);\n                        nodes[j].pending.push_back(i);\n                    }\n                }\n            }\n        }\n        TIMES(i, N) {\n            nodes[i].edges.insert(nodes[i].edges.end(), nodes[i].pending.begin(), nodes[i].pending.end());\n        }\n        cout << N << endl;\n\n        int M;\n        cin >> M;\n        TIMES(_, M) {\n            string cross;\n            cin >> cross;\n            const int hyphen = cross.find('-');\n            const int a = dict.get(cross.substr(0, hyphen));\n            const int b = dict.get(cross.substr(hyphen+1));\n            bool ans = true;\n            if(a >= N || b >= N) {\n                ans = false;\n            } else if(nodes[a].group != nodes[b].group) {\n                ans = false;\n            } else if(nodes[a].color == nodes[b].color) {\n                ans = false;\n            } else {\n                fill(visited.begin(), visited.end(), 0);\n                ans = check(b, a, nodes, visited);\n            }\n            cout << (ans?\"YES\":\"NO\") << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint M;\nmap<string,int> mp;\nbool e[200][200],ee[200][200];\nint t[200];\nvoid dfs(int x,int c){\n\tt[x]=c;\n\trep(i,200) if(e[x][i]&&t[i]==0) dfs(i,-c);\n\trep(i,200) if(e[i][x]&&t[i]==0) dfs(i,-c);\n}\nint main(){\n\twhile(true){\n\t\tcin>>M;\n\t\tif(M==0) break;\n\t\tmp.clear();\n\t\trep(i,200) rep(j,200) e[i][j]=ee[i][j]=(i==j);\n\t\trep(i,200) t[i]=0;\n\t\tint J=0;\n\t\trep(i,M){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tif(!mp.count(xx)) mp[xx]=J++;\n\t\t\tif(!mp.count(yy)) mp[yy]=J++;\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\te[x][y]=1;\n\t\t}\n\t\tint N=mp.size();\n\t\tcout<<N<<endl;\n\t\tint I=1;\n\t\trep(i,N) if(t[i]==0) dfs(i,I++);\n\t\trep(i,N) rep(j,N) rep(k,N){\n\t\t\tif((e[i][k]||e[k][i])&&(e[j][k]||e[k][j])&&!(e[i][k]&&e[k][j])&&!(e[j][k]&&e[k][i])) ee[i][j]=1;\n\t\t}\n\t\trep(i,N) rep(j,N) e[i][j]|=ee[i][j];\n\t\trep(i,N) rep(j,N) rep(k,N) if(e[j][i]&&e[i][k]) e[j][k]=1;\n\t\tint Q;\n\t\tcin>>Q;\n\t\trep(tt,Q){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\tif(t[x]==-t[y]&&e[x][y]) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n    bool used[201];\n    map<string,int>m;\n    char qq;\n    vector<int>mg[201],yg[201];\n    int o,a[201];\n    int c=1;\n    scanf(\"%c\",&qq);\n    for(int i=0;i<n;i++){\n      string s1,s2;\n      int ccc=0;\n      while(1){\n        char cc;\n        scanf(\"%c\",&cc);\n        if(cc=='\\n')break;\n        if(cc=='-'){ccc++;continue;}\n        if(!ccc)s1+=cc;\n        else s2+=cc;\n        }//cout<<s1<<endl<<s2<<endl;\n        if(!m[s1])m[s1]=c++;\n        if(!m[s2])m[s2]=c++;\n        yg[m[s1]].push_back(m[s2]);\n        mg[m[s1]].push_back(m[s2]);\n        mg[m[s2]].push_back(m[s1]);\n      }\n      r(i,201)used[i]=0;\n      queue<pair<int,int> >q;\n      q.push(mk(1,0));\n      while(!q.empty()){\n        pair<int,int>p=q.front();q.pop();\n        a[p.f]=p.s%2;\n        r(i,mg[p.f].size())\n        if(!used[mg[p.f][i]]){\n          q.push(mk(mg[p.f][i],p.s+1));\n          used[mg[p.f][i]]=1;\n        }\n      }\n      cout<<c-1<<endl;\n      cin>>o;\n      char kl;\n      scanf(\"%c\",&kl);\n      while(o--){//cout<<1;\n        string s1,s2;\n        int ccc=0,u=0;\n        while(1){\n          char cc;\n          scanf(\"%c\",&cc);\n          if(cc=='\\n')break;\n          if(cc=='-'){ccc++;continue;}\n          if(!ccc)s1+=cc;\n          else s2+=cc;\n        }\n        if(a[m[s1]]==a[m[s2]])cout<<\"No\"<<endl;\n        else if(!m[s1])cout<<\"No\"<<endl;\n        else if(!m[s2])cout<<\"No\"<<endl;\n        else{//cout<<1;\n          r(i,201)used[i]=0;\n          queue<int>p;\n          p.push(m[s1]);\n          used[m[s1]]=1;\n          while(!p.empty()){\n            int t=p.front();p.pop();\n            r(i,yg[t].size())\n            if(!used[yg[t][i]]){\n              if(yg[t][i]==m[s2]){cout<<\"Yes\"<<endl;u++;goto KKK;}\n              p.push(yg[t][i]);\n              used[yg[t][i]]=1;\n            }\n            }//cout<<1;\n            KKK:;\n            if(!u){r(i,201)used[i]=0;\n              queue<int> w;\n              w.push(m[s2]);\n              used[m[s2]]=1;\n              while(!w.empty()){\n                int t=w.front();w.pop();\n                r(i,yg[t].size())\n                if(!used[yg[t][i]]){\n                  if(yg[t][i]==m[s1]){cout<<\"No\"<<endl;goto LLL;}\n                  w.push(yg[t][i]);\n                  used[yg[t][i]]=1;\n                }\n              }\n              cout<<\"Yes\"<<endl;\n            }\n            if(0)LLL:;\n          }\n        }\n      }\n    }"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nmap<string,int> dat;\nint tn;\n\ntypedef pair<string,string> smp;\nsmp gettn(char* s){\n\tint ls=strlen(s);\n\tstring sa,sb;\n\tint hp=0;\n\trep(j,ls)if(s[j]=='-')hp=j;\n\trep(j,hp)sa+=s[j];\n\treg(j,hp+1,ls-1)sb+=s[j];\n\treturn smp(sa,sb);\n}\n\nint strtot(string s,bool re){\n\tif(re){\n\t\tif(dat.find(s)==dat.end()){\n\t\t\t//printf(\"%s %d\\n\",s.c_str(),tn);\n\t\t\tdat[s]=tn; tn++;\n\t\t}\n\t}\n\treturn dat[s];\n}\n\nint vs[205][205];\nint gone[205][2];\n\nvoid dfs(int no,int ty){\n\tif(gone[no][ty])return;\n\tgone[no][ty]=1;\n\trep(to,tn){\n\t\tif(vs[no][to]==0)continue;\n\t\tif(gone[to][1-ty]==1)continue;\n\t\tif(vs[no][to]&1)dfs(to,1-ty);\n\t\telse if(vs[no][to]&2)dfs(to,ty);\n\t}\n}\n\nint main(void){\n\tfor(;;){\n\t\tint n,m;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\ttn=0;\n\t\tdat.clear();\n\t\tmemset(vs,0,sizeof(vs));\n\t\t\n\t\trep(i,n){\n\t\t\tchar s[50];\n\t\t\tscanf(\"%s\",s);\n\t\t\t\n\t\t\tsmp pa=gettn(s);\n\t\t\tint a=strtot(pa.fir,true),\n\t\t\t\tb=strtot(pa.sec,true);\n\t\t\t\n\t\t\tvs[a][b]|=1;\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i,tn){\n\t\t\trep(j,tn){\n\t\t\t\tprintf(\"%d \",vs[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t\n\t\tvector<mp> cad;\n\t\trep(i,tn){\n\t\t\trep(j,tn){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tbool has=false,ok=true;\n\t\t\t\trep(k,tn){\n\t\t\t\t\tif(i==k || j==k)continue;\n\t\t\t\t\tif(vs[i][k]==1 && vs[k][j]==1)ok=false;\n\t\t\t\t\tif(vs[k][i]==1 && vs[j][k]==1)ok=false;\n\t\t\t\t\tif(vs[i][k]==1 && vs[j][k]==1)has=true;\n\t\t\t\t\tif(vs[k][i]==1 && vs[k][j]==1)has=true;\n\t\t\t\t\tif(!ok)break;\n\t\t\t\t}\n\t\t\t\tif((!has) || (!ok))continue;\n\t\t\t\tcad.push_back(mp(i,j));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,cad.size()){\n\t\t\tint a=cad[i].fir,b=cad[i].sec;\n\t\t\tvs[a][b]|=2;\n\t\t\tvs[b][a]|=2;\n\t\t}\n\n\n\t\tprintf(\"%d\\n\",dat.size());\n\t\tscanf(\"%d\",&m);\n\t\trep(i,m){\n\t\t\tchar s[50];\n\t\t\tscanf(\"%s\",s);\n\t\t\t\n\t\t\tsmp pa=gettn(s);\n\t\t\tint a=strtot(pa.fir,false),\n\t\t\t\tb=strtot(pa.sec,false);\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tdfs(a,0);\n\t\t\tif(gone[b][1]==1)printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<string,int> M;\n\nint str2int(string S){\n    if(M.find(S)==M.end()){\n        int n = M.size();\n        M[S]=n;\n    }\n    return M[S];\n}\n\nint E[200][200];//[a][b]=a to b\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        fill(E[0],E[200],10000);\n        M.clear();\n        for(int i=0;i<N;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    E[i1][i2]=1;\n                    break;\n                }\n            }\n        }\n        int m = M.size();\n        cout<<m<<endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<m;j++){\n                if(E[i][j]==1||E[j][i]==1) continue;\n                //cond1\n                bool b=false;\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[i][k]==1||E[k][i]==1)&&(E[j][k]==1||E[k][j]==1)){\n                        b=true;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                //cond2,3\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[k][i]==1&&E[j][k]==1)||(E[i][k]==1&&E[k][j]==1)){\n                        b=false;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                E[i][j]=E[j][i]=2;\n            }\n        }\n        //WF\n        // for(int i=0;i<m;i++) E[i][i]=0;\n        for(int k=0;k<m;k++){\n            for(int i=0;i<m;i++){\n                for(int j=0;j<m;j++){\n                    E[i][j]=min(E[i][j],E[i][k]+E[k][j]);\n                }\n            }\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    if(i1>=m||i2>=m||E[i1][i2]%2==0){\n                        cout<<\"NO\"<<endl;\n                    }else{\n                        cout<<\"YES\"<<endl;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    map< string, int > conv;\n    bool mat[201][201] = {{}}, beet[201][201] = {{}};\n    int M = 200;\n    UnionFind tree(M + M);\n\n    for(int i = 0; i < M; i++) beet[i][i] = true;\n\n    for(int i = 0; i < N; i++) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S)) conv[S] = conv.size();\n      if(!conv.count(T)) conv[T] = conv.size();\n      int a = conv[S], b = conv[T];\n      mat[a][b] = beet[a][b] = true;\n      tree.unite(a + M, b);\n      tree.unite(b + M, a);\n    }\n    for(int i = 0; i < M; i++) {\n      for(int j = i + 1; j < M; j++) {\n        bool f = [&]()\n        {\n          bool flag = false;\n          for(int k = 0; k < M; k++) {\n            if(mat[i][k] & mat[j][k]) flag = true;\n            if(mat[k][i] & mat[k][j]) flag = true;\n            if(mat[i][k] & mat[k][j]) return (false);\n            if(mat[j][k] & mat[k][i]) return (false);\n          }\n          return (flag);\n        }();\n        beet[i][j] |= beet[j][i] |= f;\n      }\n    }\n    for(int k = 0; k < M; k++) {\n      for(int i = 0; i < M; i++) {\n        for(int j = 0; j < M; j++) {\n          beet[i][j] |= beet[i][k] & beet[k][j];\n        }\n      }\n    }\n\n    int Q;\n    cin >> Q;\n    cout << conv.size() << endl;\n    while(Q--) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S) || !conv.count(T)) {\n        cout << \"NO\" << endl;\n      } else {\n        int a = conv[S];\n        int b = conv[T];\n        if(tree.find(a) != tree.find(b + M) || tree.find(b) != tree.find(a + M) || !beet[a][b]) {\n          cout << \"NO\" << endl;\n        } else {\n          cout << \"YES\" << endl;\n        }\n      }\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\nmap<string,int> rtoi;\nint d[256][256];\nint V;\n\nvoid solve(){\n    rep(i,V)rep(j,V){\n        bool C=false, DE=true;\n        if(d[i][j]==1 || d[j][i]==1) continue;\n        rep(k,V){\n            if(k==i || k==j) continue;\n            if((d[i][k]==1||d[k][i]==1) && (d[j][k]==1||d[k][j]==1))\n                C=true;\n            if((d[i][k]==1&&d[k][j]==1) || (d[k][i]==1&&d[j][k]==1))\n                DE=false;\n        }\n        if(C&&DE) d[i][j]=d[j][i]=0;\n    }\n    rep(k,V)rep(i,V)rep(j,V){\n        d[i][j]=min(d[i][j], d[i][k] + d[k][j]);\n    }\n}\n\nbool ask(string const& p, string const& q){\n    int pi=inf,qi=inf;\n    if(rtoi.count(p)==1 && rtoi.count(q)==1){\n        pi=rtoi[p], qi=rtoi[q];\n    }\n    return max(pi,qi)!=inf && d[pi][qi]!=inf && d[pi][qi]&1;\n}\n\nint main(){\n    int n;\n    while(cin>>n, n){\n        rtoi.clear();\n        rep(i,256) rep(j,256) d[i][j]=inf;\n        rep(i,n){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x);\n            string q=s.substr(x+1);\n            if(rtoi.count(p)==0)rtoi[p]=V++;\n            if(rtoi.count(q)==0)rtoi[q]=V++;\n            int ip=rtoi[p], iq=rtoi[q];\n            d[ip][iq]=1;\n        }\n        solve();\n        cout<<V<<endl;\n        int m; cin>>m;\n        rep(i,m){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x), q=s.substr(x+1);\n            puts(ask(p,q) ? \"YES\" : \"NO\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n#include <cstring>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define pii pair<int,int>\n\n#define MAXT 200\n\nbool graph[MAXT][MAXT]={};\nint color[MAXT];\n\nvoid dfs(int a){\n    rep(i,MAXT){\n        if(color[i]==-1 && (graph[a][i]||graph[i][a])){\n            color[i]=!color[a];\n            dfs(i);\n        }\n    }\n}\n\nvoid read(string &s1, string &s2){\n    string s;\n    cin>>s;\n    int i=s.find_first_of('-');\n    s1=s.substr(0, i);\n    s2=s.substr(i+1);\n}\n\nint main(){\n    while(1){\n        fill_n(*graph, MAXT*MAXT, false);\n        fill_n(color, MAXT, -1);\n\n        int N,M;\n        cin>>N;\n        if(N==0) break;\n        map<string,int> lnames;\n        int lindex = 0;\n        rep(ii,N){\n            string s1,s2;\n            read(s1,s2);\n            //cout<<s1<<\" \"<<s2<<endl;\n            if(!lnames.count(s1)){\n                lnames[s1] = lindex++;\n            }\n            if(!lnames.count(s2)){\n                lnames[s2] = lindex++;\n            }\n            graph[lnames[s1]][lnames[s2]]=true;\n            //cout<<lnames[s1]<<\" \"<<lnames[s2]<<endl;\n        }\n\n        /*rep(i,lindex){\n            rep(j,lindex){\n                cout<<graph[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n\n        color[0]=0;\n        dfs(0);\n\n        rep(i,lindex){\n            rep(j,lindex){\n                rep(k,lindex){\n                    if(graph[i][k] && graph[j][k] && !(graph[k][i] || graph[k][j])){\n                        graph[i][j] = true;\n                        graph[j][i] = true;\n                    }\n                }\n            }\n        }\n\n        rep(k,lindex){\n            rep(i,lindex){\n                rep(j,lindex){\n                    if(graph[i][k] && graph[k][j]){\n                        graph[i][j]=true;\n                    }\n                }\n            }\n        }\n\n        /*cout<<endl;\n        rep(i,lindex){\n            rep(j,lindex){\n                cout<<graph[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n\n        cout<<lindex<<endl;\n\n        cin>>M;\n        rep(ii,M){\n            string s1,s2;\n            read(s1,s2);\n\n            if(!lnames.count(s1) || !lnames.count(s2)){\n                cout<<\"NO\"<<endl;\n            }\n            else\n            {\n                int p1=lnames[s1],p2=lnames[s2];\n                if(graph[p1][p2] && (color[p1] != color[p2])){\n                    cout<<\"YES\"<<endl;\n                }\n                else\n                {\n                    cout<<\"NO\"<<endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \n#define rep(i,n) for(ll i = 0; i < ll(n); ++i) \n#define FOR(i,a,b) for(ll i = (a); i < ll(b); ++i) \n#define ROF(i,a,b) for(ll i = (a)-1; i >= ll(b); --i) \n#define all(a) (a).begin(),(a).end() \n#define fst first \n#define snd second \ntypedef long long ll; \ntypedef vector<ll> vi;\ntypedef vector<vi> vii;\nconst ll inf = 1ll<<10;\n\nbool dfs(const vii &g, ll i, vi &color){\n  ll sz = g.size();\n  stack<ll> st;\n  color[i] = 1;\n  st.push(i);\n\n  while(!st.empty()){\n    int now = st.top();\n    st.pop();\n\n    rep(next,sz){\n      if(now == next) continue;\n      if(g[now][next] + g[next][now] == 0){ // now<->next\n\tif(color[next] and color[next] != color[now]){\n\t  //cout << now << endl << next << endl;\n\t  return false; \n\t}else if(color[next] and color[next] == color[now]) continue;\n\telse{\n\t  color[next] = color[now];\n\t  st.push(next);\n\t}\n      }else if(g[now][next] * g[next][now] == 0){ // now->next or next->now\n\tif(color[next] and color[next] == color[now]){\n\t  //cout << now << endl << next << endl;\n\t  return false;\n\t}else if(color[next] and color[next] != color[now]) continue;\n\telse{\n\t  color[next] = -color[now];\n\t  st.push(next);\n\t}\n      }\n    }\n  }\n  return true;\n}\n\nbool paintable(const vii &g, vi &color){\n  ll sz = g.size();\n  rep(i,sz) if(color[i] == 0 and dfs(g,i,color) == false) return false;\n  return true;\n}\n\nmain(){\n  ll m,n; \n  while(cin >> m, m){ \n    vector<string> input(m); \n    vector<vector<string>> cross(m,vector<string>(2)); \n    set<string> street; \n    rep(i,m){ \n      cin >> input[i]; \n      FOR(k,1,input[i].size()){ // A-BをAとBに分ける \n\tif(input[i][k] == '-'){ \n\t  cross[i][0] = input[i].substr(0,k); \n\t  cross[i][1] = input[i].substr(k+1,input[i].size()-k-1); \n\t  street.insert(cross[i][0]); \n\t  street.insert(cross[i][1]); \n\t  //cerr << cross[i][0] << endl << cross[i][1] << endl; \n\t  break; \n\t} \n      } \n    } \n    map<string,ll> ntoi; // 通りの名前からindex\n    vector<string> iton; // indexから通りの名前\n    ll tmpi = 0;\n    for(auto name : street){ \n      ntoi[name] = tmpi;\n      iton.push_back(name);\n      tmpi++;\n    }\n    ll sz = street.size(); //cout << sz << endl;\n    vii g(sz,vi(sz,1)); \n    rep(i,m) g[ ntoi[cross[i][0]] ][ ntoi[cross[i][1]] ] = 0; // A->B\n    \n    vector<pair<ll,ll>> eqp; // 同水準のpair\n    rep(i,sz) rep(j,sz){ // iとjが同水準か\n      bool ieqj = false;\n      rep(k,sz){\n\tif((g[i][k] + g[k][j]) * (g[j][k] + g[k][i]) == 0){ // i->k->jかj->k->iがある\n\t  ieqj = false;\n\t  break;\n\t}else if((g[i][k] + g[j][k]) * (g[k][i] + g[k][j]) == 0){ // i->k,j->kかk->i,k->jがある\n\t  ieqj = true;\n\t}\n      }\n      if(ieqj) eqp.push_back(make_pair(i,j));\n    }\n    rep(i,eqp.size()) g[eqp[i].fst][eqp[i].snd] = g[eqp[i].snd][eqp[i].fst] = 0; // A<->B\n    //rep(i,sz){ rep(j,sz) cout << g[i][j] << \" \"; cout << endl; }\n\n    vii d = g; // path i->j がある <=> d[i][j] == 0\n    rep(k,sz) rep(i,sz) rep(j,sz) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n    vi color(sz);\n    bool p = paintable(g,color);\n    //cout << \"p : \" << p << endl;\n    //rep(i,sz) cout << iton[i] << \" : \" << color[i] << endl;\n\n    cin >> n;\n    rep(k,n){\n      string q; cin >> q;\n      if(p == false){\n\tcout << \"NO\\n\";\n\tcontinue;\n      }\n      string ql, qr;\n      FOR(i,1,q.size()){ // A-BをAとBに分ける \n\tif(q[i] == '-'){ \n\t  ql = q.substr(0,i); \n\t  qr = q.substr(i+1,q.size()-i-1);\n\t  break; \n\t} \n      }\n      if(d[ntoi[ql]][ntoi[qr]] != 0){\n\tcout << \"NO\\n\";\n\tcontinue;\n      }\n      //cout << color[ntoi[ql]] << endl << color[ntoi[qr]] << endl;\n      if(color[ntoi[ql]] != color[ntoi[qr]]) cout << \"YES\\n\";\n      else cout << \"NO\\n\";\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Pair = pair<int, int>;\n\nint N;\nint M;\nint g_idx;\nchar buf[114514];\nint par[4145];\nint myrank[4145];\nbool used[4145];\nbool isr[4145][4145];\nbool isr2[4145][4145];\n\nvector<int> vs[4145];\nvector<int> es[4145];\nvector<int> res[4145];\nvector<int> bs[4145];\nmap<string, int> mp;\n\nint root(int v) {\n  if (par[v] == v) return v;\n  return par[v] = root(par[v]);\n}\n\nvoid unite(int a, int b) {\n  a = root(a);\n  b = root(b);\n  if (a == b) return;\n  if (myrank[a] < myrank[b]) par[a] = b;\n  else if (myrank[b] < myrank[a]) par[b] = a;\n  else {\n    par[a] = b;\n    myrank[a]++;\n  }\n}\n\n\nPair GetIdx(string &s) {\n  auto itr = s.find('-');\n  string a;\n  a.assign(s, 0, itr);\n  string b;\n  b.assign(s, itr+1, s.size()-itr-1);\n  if (!mp.count(a)) mp[a] = g_idx++;\n  if (!mp.count(b)) mp[b] = g_idx++;\n  return Pair(mp[a], mp[b]);\n}\n\nvoid dfs1(int v, int k) {\n  isr[k][v] = true;\n  for (int u : es[v]) {\n    if (isr[k][u]) continue;\n    dfs1(u, k);\n  }\n}\n\nvoid dfs2(int v, int k) {\n  for (int dv : vs[root(v)]) {\n    isr2[k][dv] = true;\n    for (int u : es[dv]) {\n      if (isr2[k][u]) continue;\n      dfs2(u, k);\n    }\n  }\n}\n\nint dfs3(int v, int k) {\n  if (used[v]) return -1;\n  if (v == k) return 0;\n  used[v] = true;\n\n  int ret = -1;\n  for (int u : bs[v]) {\n    ret = max(ret, dfs3(u, k));\n  }\n  if (ret == -1) return -1;\n  //printf(\"%d %d: %d\\n\", v, k, ret);\n  return ret+1;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) return 0;\n\n    mp.clear();\n    g_idx = 0;\n    for (int i=0; i<N; i++) {\n      scanf(\"%s\", buf);\n      string s = buf;\n      int a, b;\n      tie(a, b) = GetIdx(s);\n      bs[a].emplace_back(b);\n      bs[b].emplace_back(a);\n      es[a].emplace_back(b);\n      res[b].emplace_back(a);\n    }\n    printf(\"%d\\n\", g_idx);\n\n    for (int i=0; i<g_idx; i++) {\n      par[i] = i;\n      myrank[i] = 0;\n      for (int j=0; j<g_idx; j++) {\n        isr[i][j] = false;\n        isr2[i][j] = false;\n      }\n    }\n\n    for (int i=0; i<g_idx; i++) {\n      vs[i].clear();\n      dfs1(i, i);\n    }\n\n    for (int i=0; i<g_idx; i++) {\n      for (int u : es[i]) {\n        for (int v : es[i]) {\n          if (!isr[u][v] && !isr[v][u]) unite(u, v);\n        }\n      }\n\n      for (int u : res[i]) {\n        for (int v : res[i]) {\n          if (!isr[u][v] && !isr[v][u]) unite(u, v);\n        }\n      }\n    }\n\n    for (int i=0; i<g_idx; i++) {\n      vs[root(i)].emplace_back(i);\n    }\n\n    for (int i=0; i<g_idx; i++) {\n      dfs2(i, i);\n    }\n    \n    scanf(\"%d\", &M);\n    for (int i=0; i<M; i++) {\n      scanf(\"%s\", buf);\n      string s = buf;\n      int a, b;\n      tie(a, b) = GetIdx(s);\n      //for (int i=0; i<g_idx; i++) used[i] = false;\n      //printf(\"%d %d : %d\\n\", a, b, dfs3(a, b));\n      for (int i=0; i<g_idx; i++) used[i] = false;\n      if (isr2[a][b] && dfs3(a, b)%2 == 1) puts(\"YES\");\n      else puts(\"NO\");\n    }\n\n    for (int i=0; i<g_idx; i++) {\n      es[i].clear();\n      res[i].clear();\n      bs[i].clear();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\treturn vs{ l,r };\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n, q;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p));\n\t\tREP(i, p) dist[i][i] = 1;\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] || dist[k][i]) && (dist[j][k] || dist[k][j])) f1 = true;\n\t\t\t\tif ((dist[i][k] && dist[k][j]) || (dist[k][i] && dist[j][k])) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p)\n\t\t{\n\t\t\tif (dist[i][k] && dist[k][j]) dist[i][j] = 1;\n\t\t}\n\t\tvi color(p);\n\t\tint col = 1;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i]) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = -col;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to]) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol++;\n\t\t}\n\t\tcout << p << endl;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif (color[l] == -color[r] && dist[r][l])\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\treturn vs{ l,r };\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n, q;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] || dist[k][i]) && (dist[j][k] || dist[k][j])) f1 = true;\n\t\t\t\tif ((dist[i][k] && dist[k][j]) || (dist[k][i] && dist[j][k])) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p)\n\t\t{\n\t\t\tif (dist[i][k] && dist[k][j]) dist[i][j] = 1;\n\t\t}\n\t\tvi color(p);\n\t\tint col = 1;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i]) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = -col;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to]) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol++;\n\t\t}\n\t\tcout << p << endl;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif (color[l] == -color[r] && dist[r][l])\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<string, string> pss;\n\npss split(string s) {\n  ll k;\n  REP(i, 0, s.size()) if(s[i] == '-') k = i;\n  string fi = s.substr(0, k);\n  string se = s.substr(k + 1, s.size() - k - 1);\n  return pss(fi, se);\n}\n\nvoid dfs(ll v, vector<vector<ll>> &E, vector<bool> &used, vector<ll> &color, ll c) {\n  if(used[v]) return;\n  used[v] = true;\n\n  color[v] = c;\n  for(ll u : E[v]) dfs(u, E, used, color, 1 - c);\n}\n\nbool dfs2(ll v, ll g, vector<vector<ll>> &E, vector<bool> &used) {\n  if(v == g) return true;\n\n  if(used[v]) return false;\n  used[v] = true;\n\n  bool ret = false;\n  for(ll u : E[v]) ret = ret || dfs2(u, g, E, used);\n  return ret;\n}\n\nint main(void) {\n  ll N, M;\n  while(cin >> N, N) {\n    vector<string> uniq;\n    vector<pss> C(N);\n    REP(i, 0, N) {\n      string s;\n      cin >> s;\n      C[i] = split(s);\n      uniq.push_back(C[i].first);\n      uniq.push_back(C[i].second);\n    }\n    cin >> M;\n    vector<pss> Q(M);\n    REP(i, 0, M) {\n      string s;\n      cin >> s;\n      Q[i] = split(s);\n      uniq.push_back(Q[i].first);\n      uniq.push_back(Q[i].second);\n    }\n    sort(uniq.begin(), uniq.end());\n    uniq.erase(unique(uniq.begin(), uniq.end()), uniq.end());\n\n    vector<pll> cross(N), query(M);\n    REP(i, 0, N) {\n      cross[i].first = lower_bound(uniq.begin(), uniq.end(), C[i].first) - uniq.begin();\n      cross[i].second = lower_bound(uniq.begin(), uniq.end(), C[i].second) - uniq.begin();\n    }\n    REP(i, 0, M) {\n      query[i].first = lower_bound(uniq.begin(), uniq.end(), Q[i].first) - uniq.begin();\n      query[i].second = lower_bound(uniq.begin(), uniq.end(), Q[i].second) - uniq.begin();\n    }\n\n    ll n = uniq.size();\n    vector<vector<ll>> E(n), R(n), A(n);\n    REP(i, 0, N) {\n      E[cross[i].first].push_back(cross[i].second);\n      R[cross[i].second].push_back(cross[i].first);\n      A[cross[i].first].push_back(cross[i].second);\n      A[cross[i].second].push_back(cross[i].first);\n    }\n\n    vector<bool> used(n, false);\n    vector<ll> color(n);\n    REP(i, 0, n) if(!used[i]) dfs(i, A, used, color, 0);\n\n    REP(i, 0, n) {\n      for(ll u : E[i]) for(ll v : E[i]) if(u != v) E[u].push_back(v);\n      for(ll u : R[i]) for(ll v : R[i]) if(u != v) E[u].push_back(v);\n    }\n\n    set<ll> st;\n    REP(i, 0, N) {\n      st.insert(cross[i].first);\n      st.insert(cross[i].second);\n    }\n\n    cout << st.size() << endl;\n    REP(i, 0, M) {\n      ll s = query[i].first, t = query[i].second;\n      vector<bool> used(n);\n      bool ok = color[s] != color[t] && dfs2(s, t, E, used);\n      cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)n;i++)\nconst int INF = (1<<29) + 1;\n\nint n, m;\n\ntemplate<typename T>\nstruct Serializer{\n\tmap<T, int> enc;\n\tvector<T> dec;\n\tint operator()(const T &t){\n\t\tauto it = enc.find(t);\n\t\tif(it != enc.end()) return it->second;\n\t\tdec.push_back(t);\n\t\treturn enc[t] = dec.size() - 1;\n\t}\n\tsize_t size(){\n\t\treturn dec.size();\n\t}\n};\n\nint g[201][201], g2[201][201];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tSerializer<string> se;\n\t\tREP(i, 200)REP(j, 200)\n\t\t\tg[i][j] = g2[i][j] = i == j ? 0 : INF;\n\t\tREP(i, n){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tg[u][v] = g2[u][v] = g2[v][u] = 1;\n\t\t}\n\t\tn = se.size();\n\t\tREP(i, n)REP(j, i){\n\t\t\tint f = 0;\n\t\t\tREP(k, n){\n\t\t\t\tif(g[i][k] == 1 && g[k][j] == 1 || g[j][k] == 1 && g[k][i] == 1){\n\t\t\t\t\tf = 0; break;\n\t\t\t\t}\n\t\t\t\tif(g[i][k] == 1 && g[j][k] == 1 || g[k][i] == 1 && g[k][j] == 1)\n\t\t\t\t\tf = 1;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tif(g[i][j] == INF) g[i][j] = 501;\n\t\t\t\tif(g[j][i] == INF) g[j][i] = 501;\n\t\t\t}\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tREP(k, n)REP(i, n)REP(j, n) g2[i][j] = min(g2[i][j], g2[i][k] + g2[k][j]);\n\t\tcout << n << endl;\n\t\tcin >> m;\n\t\tREP(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tif((g2[u][v] & 1) && g[u][v] < INF) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst int INF = 2000;\nconst int MAX = 200;\nstring a, b;\nint num;\nint mat[MAX][MAX];\nbool dmat[MAX][MAX];\nbool visited[MAX];\n\nvoid input() {\n\tstring s;\n\tcin >> s;\n\n\tconst int pos = s.find('-');\n\ta = s.substr(0, pos);\n\tb = s.substr(pos + 1);\n}\n\nvoid dfs(int v) {\n\tvisited[v] = true;\n\tfor(int i = 0; i < num; ++i)\n\t\tif(!visited[i] && dmat[v][i])\n\t\t\tdfs(i);\n}\n\nbool check(int from, int to) {\n\tif(mat[from][to] % 2 == 0)\n\t\treturn false;\n\tmemset(visited, false, sizeof(visited));\n\tdfs(from);\n\treturn visited[to];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tmap<string, int> convert;\n\t\tmemset(dmat, false, sizeof(dmat));\n\t\tfill(mat[0], mat[0] + MAX * MAX, INF);\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tmat[i][i] = 0;\n\n\t\twhile(n--) {\n\t\t\tinput();\n\n\t\t\tif(!convert.count(a))\n\t\t\t\tconvert.insert(make_pair(a, convert.size()));\n\n\t\t\tif(!convert.count(b))\n\t\t\t\tconvert.insert(make_pair(b, convert.size()));\n\n\t\t\tconst int a_id = convert[a], b_id = convert[b];\n\t\t\tdmat[a_id][b_id] = mat[a_id][b_id] = mat[b_id][a_id] = 1;\n\t\t}\n\n\t\tnum = convert.size();\n\t\tfor(int k = 0; k < num; ++k)\n\t\t\tfor(int i = 0; i < num; ++i)\n\t\t\t\tfor(int j = 0; j < num; ++j)\n\t\t\t\t\tchmin(mat[i][j], mat[i][k] + mat[k][j]);\n\n\t\tvector<vector<bool> > same(num, vector<bool>(num, false));\n\t\tfor(int i = 0; i < num; ++i) {\n\t\t\tfor(int j = i + 1; j < num; ++j) {\n\t\t\t\tif(mat[i][j] & 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbool is_same = false;\n\n\t\t\t\tfor(int k = 0; k < num; ++k) {\n\t\t\t\t\tif(i == k || j == k)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif((dmat[i][k] && dmat[j][k]) || (dmat[k][i] && dmat[k][j]))\n\t\t\t\t\t\tis_same = true;\n\n\t\t\t\t\tif((dmat[i][k] && dmat[k][j]) || (dmat[j][k] && dmat[k][i]))\n\t\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tsame[i][j] = same[j][i] = is_same;\n\t\t\tnext:;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tfor(int j = 0; j < num; ++j)\n\t\t\t\tdmat[i][j] |= same[i][j];\n\n\t\tint m;\n\t\tcin >> m;\n\n\t\twhile(m--) {\n\t\t\tinput();\n\t\t\tif(!(convert.count(a) && convert.count(b))) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcout << (check(convert[a], convert[b]) ? \"YES\" : \"NO\") << endl;\t\t\t\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <string.h>\n#define pb push_back\nusing namespace std;\n\nint n,m;\n\nint g1[200][200],g2[200][200],g3[200][200];\nbool vis[200];\nint iro[200];\nmap<string,int> mp;\n\nvoid iroduke(int x,int y){\n  if(vis[x]) return;\n  if(y==0) {iro[x]=1; y=1;}\n  else {iro[x]=2;y=0;}\n  \n  int i;\n  vis[x]=true;\n  for(i=0;i<mp.size();i++){\n    if(g3[x][i]==1) iroduke(i,y);\n  }\n}\n\nbool dfs(int x,int y,int z){\n  if(y==z&&iro[x]!=iro[z]) return true;\n  if(vis[y]) return false;\n  //cout<<x<<\":\"<<y<<endl;\n  int i;\n  vis[y]=true;\n  for(i=0;i<mp.size();i++){\n    if(g1[y][i]==1) if(dfs(x,i,z)) return true;\n  }\n  return false;\n}\n\nint main(){\n  int i,j,k;\n  string s;\n  string st1,st2;\n  while(cin>>n,n){\n    k=0;\n    mp.clear();memset(g1,0,sizeof(g1));memset(g2,0,sizeof(g2));memset(g3,0,sizeof(g3));memset(iro,0,sizeof(iro));\n    for(i=0;i<n;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      if(mp.find(st1)==mp.end()) mp[st1]=k++;\n      if(mp.find(st2)==mp.end()) mp[st2]=k++;\n      g1[mp[st1]][mp[st2]]=1;\n      g2[mp[st2]][mp[st1]]=1;\n      g3[mp[st1]][mp[st2]]=1;\n      g3[mp[st2]][mp[st1]]=1;\n      //cout<<st1<<\":\"<<mp[st1]<<endl;\n      //cout<<st2<<\":\"<<mp[st2]<<endl;\n    }\n    iroduke(0,0);\n    memset(vis,0,sizeof(vis));\n    for(i=0;i<mp.size();i++){\n      j=0;\n      while(g2[i][j]!=1&&j<mp.size()) j++;\n      k=j++;\n      for(;j<mp.size();j++){\n        if(g2[i][j]==1){\n          g1[k][j]=1;\n          g1[j][k]=1;\n          k=j;\n        }\n      }\n    }\n    /*\n    for(i=0;i<mp.size();i++){\n      cout<<i<<\":\"<<iro[i]<<endl;\n    }\n    */\n    cin>>m;\n    cout<<mp.size()<<endl;\n    for(i=0;i<m;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      memset(vis,0,sizeof(vis));\n      if(dfs(mp[st1],mp[st1],mp[st2])) cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) ((int)(a).size())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nint n;\nmap<string, int> memo;\nvector<string> mstr;\nint get(string a){\n  if(memo.count(a))\n    return memo[a];\n  int sz = SZ(memo);\n  mstr.pb(a);\n  return memo[a] = sz;\n}\n\nvector<PI> G[2000];\nint vis[2000];\nint vcnt;\nbool app[2000][2000];\n\nvector<int> cG[2000];\n\nvoid solve(){\n  memo.clear();\n  mstr.clear();\n  rep(i, n*2) G[i].clear();\n  rep(i, n*2) cG[i].clear();\n  \n  set<PI> input;\n  rep(i, n){\n    string a, b;\n    cin >> a;\n    a[a.find('-')] = ' ';\n    stringstream ss(a);\n    ss >> a >> b;\n    int u = get(a);\n    int v = get(b);\n    G[u].pb(mp(v,1));\n    cG[u].pb(v);\n    cG[v].pb(u);\n    input.insert(mp(u, v));\n  }\n  \n  \n  cout << SZ(memo) << endl;\n  rep(i, SZ(memo)) rep(j, SZ(memo)) app[i][j] = 0;\n  for(auto e : input) app[e.F][e.S] = 1;\n\n  \n  // rep(d, SZ(memo)){\n  //   sort(ALL(cG[d]));\n  //   cG[d].erase(unique(ALL(cG[d])), cG[d].end());\n\n  //   for(auto a : cG[d]) for(auto b : cG[d]){\n  //       if(a == b) break;\n        \n  //       if(app[a][d] && app[d][b]) continue;\n  //       if(app[b][d] && app[d][a]) continue;\n  //       G[a].pb(mp(b,0));\n  //       G[b].pb(mp(a,0));\n  //     }\n  // }\n\n  rep(i, SZ(memo)) rep(j, i){\n    bool ok = false;\n    rep(k, SZ(memo))\n      if((app[i][k]|app[k][i]) && (app[k][j]|app[j][k])){\n        ok = true;\n        break;\n      }\n    if(!ok) continue;\n    ok = true;\n    rep(k, SZ(memo)) if(app[i][k] && app[k][j]) ok = false;\n    rep(k, SZ(memo)) if(app[j][k] && app[k][i]) ok = false;\n    if(ok){\n      G[i].pb(mp(j,0));\n      G[j].pb(mp(i,0));\n    }\n  }\n  \n  rep(d, SZ(memo)){\n    sort(ALL(G[d]));\n    G[d].erase(unique(ALL(G[d])), G[d].end());\n  }\n  \n  // rep(d, SZ(memo)){\n  //   cout << mstr[d] << \": \";\n  //   for(auto e : G[d])\n  //     cout << mstr[e.F] << \",\";\n  //   cout << endl;\n  // }\n  \n  int q;\n  cin >> q;\n  rep(i, q){\n    string a, b;\n    cin >> a;\n    a[a.find('-')] = ' ';\n    stringstream ss(a);\n    ss >> a >> b;\n    \n    if(!(memo.count(a) && memo.count(b))){\n      cout << \"NO\" << endl;\n      continue;\n    }\n    \n    int u = get(a);\n    int v = get(b);\n    queue<PI> q;\n    q.push(mp(u,0));\n    \n    bool ok = false;\n    ++vcnt;\n    while(!q.empty()){\n      int cv = q.front().F;\n      int cc = q.front().S;\n      q.pop();\n      if(cv == v){\n        //cout << \"cc \" << cc << endl;\n        ok = cc & 1;\n        break;\n      }\n      \n      if(vis[cv] == vcnt) continue;\n      //cout << mstr[cv] << endl;\n      vis[cv] = vcnt;\n      for(auto e : G[cv])\n        if(vis[e.F] != vcnt)\n          q.push(mp(e.F, cc + e.S));\n    }\n    \n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n \nusing namespace std;\n \nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n \nmultimap<string,string>m1,m2;\nmap<string,int>color;\n \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n \nint graph[200][200];\n \nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n    graph[i][j]|=graph[i][k]&graph[k][j];\n}\n \nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    bool g[200][200];\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tg[i][j]=false;\n\tgraph[i][j]=i==j?1:0; \n      }\n    }\n    \n    multimap<string,string>::iterator it,it2;\n    \n    for(it=m1.begin();it!=m1.end();it++){\n      for(it2=m1.begin();it2!=m1.end();it2++){\n\tif(it==it2)continue;\n\t\n\tif((*it).fst==(*it2).sec){\n\t  g[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  g[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  g[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  g[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n      }\n    }\n    \n    for(it=m1.begin();it!=m1.end();it++){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n   \n      for(it2=m1.begin();it2!=m1.end();it2++){\n\tif(it==it2)continue;\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n      }\n    }\n    \n    warshall_floyd(node3.size());\n    \n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    map< string, int > conv;\n    bool mat[201][201] = {{}}, beet[201][201] = {{}};\n    int M = 200;\n    UnionFind tree(M + M);\n\n    for(int i = 0; i < M; i++) beet[i][i] = true;\n\n    for(int i = 0; i < N; i++) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S)) conv[S] = conv.size() - 1;\n      if(!conv.count(T)) conv[T] = conv.size() - 1;\n      int a = conv[S], b = conv[T];\n      mat[a][b] = beet[a][b] = true;\n      tree.unite(a + M, b);\n      tree.unite(b + M, a);\n    }\n    for(int i = 0; i < M; i++) {\n      for(int j = i + 1; j < M; j++) {\n        if([&]()\n        {\n          bool flag = false;\n          for(int k = 0; k < M; k++) {\n            if(mat[i][k] & mat[j][k]) flag = true;\n            if(mat[k][i] & mat[k][j]) flag = true;\n            if(mat[i][k] & mat[k][j]) return (false);\n            if(mat[j][k] & mat[k][i]) return (false);\n          }\n          return (flag);\n        }())\n          beet[i][j] = beet[j][i] = true;\n      }\n    }\n    for(int k = 0; k < M; k++) {\n      for(int i = 0; i < M; i++) {\n        for(int j = 0; j < M; j++) {\n          beet[i][j] |= beet[i][k] & beet[k][j];\n        }\n      }\n    }\n\n    int Q;\n    cin >> Q;\n    cout << conv.size() << endl;\n    while(Q--) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S) || !conv.count(T)) {\n        cout << \"NO\" << endl;\n      } else {\n        int a = conv[S];\n        int b = conv[T];\n        if(tree.find(a) != tree.find(b + M) || tree.find(b) != tree.find(a + M) || !beet[a][b]) {\n          cout << \"NO\" << endl;\n        } else {\n          cout << \"YES\" << endl;\n        }\n      }\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\nint n,m,size;\nstring str,a,b;\nmap<string,int> mp;\nint G[201][201];\nint g[201][201];\nint T[201][201];\nint t[201][201];\n\nvoid init(){\n  mp.clear();\n  size=0;\n  for(int i=1;i<=200;i++){\n    for(int j=1;j<=200;j++){\n      G[i][j]=(i==j?0:INF);\n      T[i][j]=(i==j?0:INF);\n      g[i][j]=0;\n      t[i][j]=0;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n\n    for(int i=0;i<n;i++){\n      cin>>str;\n      for(int j=0;j<(int)str.size();j++){\n        if(str[j]=='-'){\n          a=str.substr(0,j);\n          b=str.substr(j+1);\n          break;\n        }\n      }\n      if(mp[a]==0)mp[a]=++size;\n      if(mp[b]==0)mp[b]=++size;\n      G[mp[a]][mp[b]]=1;\n      T[mp[a]][mp[b]]=1;\n      g[mp[a]][mp[b]]=1;\n    }\n    \n    for(int i=1;i<=size;i++){\n      for(int j=i+1;j<=size;j++){\n        if(i==j)continue;\n        bool flg=false;\n        for(int k=1;k<=size;k++){\n          if((g[i][k]||g[k][i])&&(g[j][k]||g[k][j])){\n            flg=true;\n          }\n        }\n        for(int k=1;k<=size;k++){\n          if(g[k][i]&&g[j][k])flg=false;\n          if(g[i][k]&&g[k][j])flg=false;\n        }\n        if(flg){\n          T[i][j]=1;\n          T[j][i]=1;\n          t[i][j]=1;\n          t[j][i]=1;\n        }\n      }\n    }\n    \n    for(int k=1;k<=size;k++){\n      for(int i=1;i<=size;i++){\n        for(int j=1;j<=size;j++){\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n          T[i][j]=min(T[i][j],T[i][k]+T[k][j]);\n        }\n      }\n    }\n\n    cout<<size<<endl;\n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>str;\n      for(int j=0;j<(int)str.size();j++){\n        if(str[j]=='-'){\n          a=str.substr(0,j);\n          b=str.substr(j+1);\n          break;\n        }\n      }\n      int A=mp[a],B=mp[b];\n      \n      if(G[A][B]%2==0&&G[A][B]!=INF){\n        cout<<\"NO\"<<endl;\n      }else if(T[A][B]==INF){\n        cout<<\"NO\"<<endl;\n      }else if(t[A][B]){\n        cout<<\"NO\"<<endl;\n      }else{\n        cout<<\"YES\"<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nbool g[200][200];\nbool tate[200];\nbool same[200][200];\nbool visited[200];\nbool func(int a, int b, int n) {\n  if (a==b) return 1;\n  visited[a] = 1;\n  REP(i,n) {\n    if (g[a][i] && !visited[i] && func(i, b, n)) return 1;\n  }\n  return 0;\n}\n\nint main() {\n  int n,m;\n  while(cin >> n, n) {\n    memset(g, 0, sizeof(g));\n    map<string, int> id;\n    int num = 0;\n    UnionFind uf(n*4);\n    REP(i, n) {\n      string s;\n      cin >> s;\n      int p = s.find('-');\n      string a = s.substr(0, p);\n      string b = s.substr(p+1);\n      if (id.count(a) == 0) id[a] = num++;\n      if (id.count(b) == 0) id[b] = num++;\n      g[id[a]][id[b]] = 1;\n      uf.unionSet(id[a]*2, id[b]*2+1);\n      uf.unionSet(id[a]*2+1, id[b]*2);\n    }\n    memset(same, 0, sizeof(same));\n    REP(i, num) {\n      REP(j, num) {\n        if (i == j) continue;\n        bool f1=0,f2=1;\n        REP(k, num) {\n          if (k==i||k==j) continue;\n          if (g[i][k]&&g[j][k] || g[k][i]&&g[k][j]) f1 = 1;\n          if (g[i][k]&&g[k][j] || g[k][i]&&g[j][k]) f2 = 0;\n        }\n        if (f1&&f2) {\n          same[i][j] = 1;\n          same[j][i] = 1;\n        }\n      }\n    }\n    REP(i, num) REP(j, num)\n      g[i][j] |= same[i][j];\n    // REP(i, num) {\n    //   REP(j, num) {\n    //     cout << g[i][j];\n    //   }\n    //   cout << endl;\n    // }\n\n    cout << num << endl;\n    cin >> m;\n    REP(i,m) {\n      string s;\n      cin >> s;\n      int p = s.find('-');\n      string a = s.substr(0, p);\n      string b = s.substr(p+1);\n      if (id.count(a) == 0 || id.count(b) == 0 || uf.findSet(id[a]*2, id[b]*2) || uf.findSet(id[a]*2+1, id[b]*2+1)) {\n        cout << \"NO\" << endl;\n        continue;\n      }\n      memset(visited,0,sizeof(visited));\n      if (func(id[a], id[b], num)) {\n        cout << \"YES\" << endl;\n      } else {\n        cout << \"NO\" << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nvector<string> split(const string &s, char delim) {\n    vector<int> pos;\n    pos.push_back(-1);\n    rep(i, s.size()) if(s[i] == delim) pos.push_back(i);\n    pos.push_back(s.size());\n    vector<string> res;\n    rep(i, pos.size() - 1) res.push_back(s.substr(pos[i] + 1, pos[i + 1] - pos[i] - 1));\n    return res;\n}\n\ntuple<string, string> input() {\n    string s; cin >> s;\n    auto a = split(s, '-');\n    assert(a.size() == 2);\n    return make_tuple(a[0], a[1]);\n}\n\nclass Solver {\n  public:\n    void dfs(int now, int color, vector<int> &coloring, const vector<vector<int>> &G) {\n        coloring[now] = color;\n        rep(nxt, G.size()) {\n            if(G[now][nxt] and coloring[nxt] < 0) {\n                dfs(nxt, (color / 2) * 2 + (color + 1) % 2, coloring, G);\n            }\n        }\n    }\n    bool solve() {\n        int N;\n        map<string, int> road_map;    \n        int road_cnt = 0;\n        cin >> N;\n        if(N == 0) return false;\n        vector<pii> E(N);\n        rep(i, N) {\n            string a, b;            \n            tie(a, b) = input();\n            if(not road_map.count(a)) road_map[a] = road_cnt++;\n            if(not road_map.count(b)) road_map[b] = road_cnt++;\n            int ai = road_map[a], bi = road_map[b];\n            E[i] = pii(ai, bi);\n        }\n        vector<vector<int>> G(road_cnt, vector<int>(road_cnt));\n        rep(i, N) G[E[i].first][E[i].second] = 1;\n        vector<int> color(road_cnt, -1);\n        {\n            int cnt = 0;\n            rep(i, road_cnt) {\n                if(color[i] < 0) dfs(i, (cnt++)*2, color, G);\n            }\n        }        \n        rep(a, road_cnt) {\n            rep(b, road_cnt) {\n                if(a == b) continue;\n                int flg[3];\n                flg[0] = 0;\n                flg[1] = flg[2] = 1;\n                rep(c, road_cnt) {\n                    // A???B????????¨?????????????????\\?????????????????????????????????C????????????\n                    flg[0] |= (G[a][c] and G[b][c]) or \n                              (G[a][c] and G[c][b]) or\n                              (G[c][a] and G[b][c]) or\n                              (G[c][a] and G[c][b]);\n                    // D-A??¨B-D?????\\?????????????????????????????????D????????????\n                    flg[1] &= not (G[c][a] and G[b][c]);\n                    // A-E??¨E-B?????\\?????????????????????????????????E????????????\n                    flg[1] &= not (G[a][c] and G[c][b]);\n                }\n                if(flg[0] and flg[1] and flg[2]) {\n                    G[a][b] = 1;\n                    G[b][a] = 1;\n                }\n            }\n        }\n        rep(k, road_cnt) {\n            rep(i, road_cnt) {\n                rep(j, road_cnt) {\n                    if(G[i][k] and G[k][j]) G[i][j] = 1;\n                }\n            }\n        }\n        // debug(G);\n        // debug(color);\n        cout << road_cnt << endl;\n        int M; cin >> M;\n        rep(m, M) {\n            string a, b;\n            tie(a, b) = input();\n            if(not road_map.count(a) or not road_map.count(b)) {\n                cout << \"NO\" << endl;\n                continue;\n            }\n            int ai = road_map[a], bi=road_map[b];\n            bool ok = G[ai][bi];\n            ok &= (color[ai] % 2 != color[bi] % 2) or (color[ai] / 2 != color[bi] / 2);\n            cout << (ok ? \"YES\" : \"NO\") << endl;\n        }\n        \n        return true;\n    }\n};\n\nint main() {\n    while(true) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint N, M;\nint G[205][205];\nmap<string, int> mp;\nvector<int> g[205];\nint V;\nbool used[205];\nint color[205];\n\nbool dfs(int v, int t)\n{\n\tused[v] = true;\n\tif(v == t) return true;\n\t\n\tbool ret = false;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(used[g[v][i]]) continue;\n\t\tret |= dfs(g[v][i], t);\n\t}\n\treturn ret;\n}\n\nvoid color_dfs(int v, int c)\n{\n\tcolor[v] = c;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(color[g[v][i]]) continue;\n\t\tcolor_dfs(g[v][i], -c);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(int i = 1; i <= 200; i++){\n\t\t\tfor(int j = 1; j <= 200; j++){\n\t\t\t\tG[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint id = 1;\n\t\tstring s, t;\n\t\tmp.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0) mp[s] = id++;\n\t\t\tif(mp.count(t) == 0) mp[t] = id++;\n\t\t\tG[mp[s]][mp[t]] = 1;\n\t\t}\n\t\tV = id-1;\n\t\tcout << V << endl;\n\t\t\n\t\tfor(int i = 1; i <= V; i++) g[i].clear();\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]){\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t\tg[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++) color[i] = 0;\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tif(!color[i]) color_dfs(i, 1);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tint prev = 0, front = 0;\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j] == 1){\n\t\t\t\t\tif(prev == 0) front = j;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[prev][j] == 0) G[prev][j] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tprev = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev != front) if(G[prev][front]) G[prev][front] = 2;\n\t\t}\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tint prev = 0, front = 0;\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[j][i] == 1){\n\t\t\t\t\tif(prev == 0) front = j;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[prev][j] == 0) G[prev][j] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tprev = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev != front) if(G[prev][front] == 0) G[prev][front] = 2;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tg[i].clear();\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]) g[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0 || mp.count(t) == 0){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint S = mp[s], T = mp[t];\n\t\t\t\n\t\t\tif(color[S] == color[T]){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i <= V; i++) used[i] = false;\n\t\t\tif(dfs(S, T)) cout << \"YES\" << endl;\n\t\t\telse cout << \"NO\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\n\ntypedef struct{\n\tint l,r;\n}CROSS;\n\ntypedef struct {\n\tbool walk;\n\tchar name[16+1];\n}LOAD;\n\nint N,M,L;\nLOAD loads[200]; //¹¼Û¶\n\nCROSS crosses[1000];\n\n\nint AddLoad(char *load)\n{\n\tint i;\n\tfor(i = 0; i < L; i++){\n\t\tif(strcmp(load,loads[i].name) == 0) return i;\n\t}\n\tstrcpy(loads[i].name,load); //ÇÁ·é\n\tL++;\n\treturn i;\n}\n\nCROSS AddCross(char *cross)\n{\n\tint len = strlen(cross);\n\tfor(int i = 0; i <= len; i++){\n\t\tif(cross[i] == '-'){\n\t\t\tCROSS cr;\n\t\t\tcross[i] = '\\0';\n\t\t\tcr.l = AddLoad(cross);\n\t\t\tcr.r = AddLoad(cross+i+1);\n\t\t\treturn cr;\n\t\t}\n\t}\n\n\tCROSS dummy;\n\treturn dummy;\n}\n\nint GetLoad(char *load)\n{\n\tfor(int i = 0; i < L; i++){\n\t\tif(strcmp(load,loads[i].name) == 0) return i;\n\t}\n\treturn -1;\n}\n\nCROSS GetCross(char *cross)\n{\n\tint len = strlen(cross);\n\tfor(int i = 0; i <= len; i++){\n\t\tif(cross[i] == '-'){\n\t\t\tCROSS cr;\n\t\t\tcross[i] = '\\0';\n\t\t\tcr.l = GetLoad(cross);\n\t\t\tcr.r = GetLoad(cross+i+1);\n\t\t\treturn cr;\n\t\t}\n\t}\n\n\tCROSS dummy;\n\treturn dummy;\n}\n\ntypedef enum {NONE,OK,NO = -1} FLAG;\nFLAG flag;\n\nvoid JudgeVaild(int l,int r,bool other)\n{\n\tif(flag != NONE) return ; //tO è\n\tif(loads[l].walk) return ; //ùÉà¢½\n\tif(l == r){ //½Çè¢½\n\t\tflag = other ? OK : NO;\n\t\treturn;\n\t}\n\tloads[l].walk = true; //à¢½\n\tfor(int i= 0; i < N; i++){\n\t\tif(crosses[i].l == l) //o­_êv\n\t\t\tJudgeVaild(crosses[i].r,r,!other);\n\t\tif(flag != NONE) return;\n\t}\n}\n\nvoid Pallarel(int l,int r,int dep,bool other)\n{\n\tif(flag != NONE) return ; //tO è\n\tif(loads[l].walk) return ; //ùÉà¢½\n\tif(l == r){ //½Çè¢½\n\t\tflag = (other && dep >= 0) ? OK : NO;\n\t\treturn;\n\t}\n\tloads[l].walk = true; //à¢½\n\tfor(int i= 0; i < N; i++){\n\t\tif(crosses[i].l == l) \n\t\t\tPallarel(crosses[i].r,r,dep + 1,!other);\n\t\tif(crosses[i].r == l) \n\t\t\tPallarel(crosses[i].l,r,dep - 1,!other);\n\t\tif(flag != NONE) return;\n\t}\n}\n\n\nbool IsOk(CROSS crs)\n{\n\tif(crs.l == -1 || crs.r == -1) return false;\n\n\tfor(int j = 0; j < L; j++) loads[j].walk = false; //à¢Ä¢È¢\n\tflag = NONE; //Ü¾tOÈµ\n\tJudgeVaild(crs.l,crs.r,false); //s¯é©Ç¤©»è( l --- r )\n\tif(flag != NONE) \n\t\treturn flag == OK;\n\tfor(int j = 0; j < L; j++) loads[j].walk = false; //à¢Ä¢È¢\n\tJudgeVaild(crs.r,crs.l,false); //s¯é©Ç¤©»è( r --- l )\n\tif(flag != NONE)\n\t\treturn false; //½Çè¢½_ÅAEg\n\n\tint dep = 0;\n\tfor(int j = 0; j < L; j++) loads[j].walk = false; //à¢Ä¢È¢\n\tPallarel(crs.l,crs.r,dep,false);\n\treturn (int)flag == OK; // r ---> l És¯éêÍNGÅ é\n}\n\nvoid solve()\n{\n\tL = 0;\n\n\tfor(int i =0 ; i < N; i++){\n\t\tchar str[34];\n\t\tcin >> str; //¶ñÇÝÝ\n\t\tcrosses[i] = AddCross(str);\n\t}\n\n\tcout << L << endl; //¹oÍ\n\n\tcin >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tchar str[34];\n\t\tcin >> str; //¶ñÇÝÝ\n\t\tCROSS judge = GetCross(str);\n\n\t\tcout << (IsOk(judge) ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n}\n\nint main()\n{\n\twhile(cin >> N,N){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int INF = 1e8;\n\nint bfs(int s, int t, vector< vector<pii> > &g){\n  int n = g.size();\n  vector<int> d(n,INF);\n  d[s] = 0;\n  deque<int> q;\n  q.push_back(s);\n\n  while(q.size()){\n    int v = q.front(); q.pop_front();\n    if(v==t)break;\n    \n    for(pii p : g[v]){\n      int u = p.second;\n      if(p.first == 0 && d[u]==INF){\n\td[u] = d[v];\n\tq.push_front(u);\n      }else if(p.first == 1 && d[u]==INF){\n\td[u] = d[v]+1;\n\tq.push_back(u);\n      }\n    }\n  }\n  return d[t];\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int n;\n  while(cin >> n, n){\n    int ns = 0;\n    map<string,int> id;\n    vector<pii> edges;\n    vector<string> vs;\n\n    rep(i,n){\n      string s; cin >> s;\n      vs.push_back(s);\n      int p = s.find(\"-\");\n      string a = s.substr(0,p), b = s.substr(p+1);\n      if(id.count(a)==0)id[a] = ns++;\n      if(id.count(b)==0)id[b] = ns++;\n      edges.push_back(pii(id[a],id[b]));\n    }\n\n    vector<vi> adj(ns,vi(ns,0));\n    vector< vector<pii> > g(ns);\n    for(pii e : edges){\n      int u = e.first, v = e.second;\n      adj[u][v] = 1;\n      g[u].push_back(pii(1,v));\n    }\n\n    rep(i,ns)rep(j,i){\n      int a = 0, b = 0, c = 0;\n      rep(k,ns){\n\tif((adj[i][k] && adj[j][k]) || (adj[k][i] && adj[k][j]))a++;\n\tif(adj[i][k] && adj[k][j])b++;\n\tif(adj[j][k] && adj[k][i])c++;\n      }\n      if(a && !b && !c){\n\tg[i].push_back(pii(0,j));\n\tg[j].push_back(pii(0,i));\n      }\n    }\n    cout << ns << endl;\n\n    int m;\n    cin >> m;\n    rep(i,m){\n      string s; cin >> s;\n      vs.push_back(s);\n      int p = s.find(\"-\");\n      string a = s.substr(0,p), b = s.substr(p+1);\n      if(id.count(a)==0 || id.count(b)==0){\n\tcout << \"NO\" << endl; continue;\n      }\n\n      int d = bfs(id[a],id[b],g);\n      if(d==INF || d%2==0)cout << \"NO\" << endl;\n      else cout << \"YES\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef string Vertex;\ntypedef pair<Vertex, Vertex> PVV;\ntypedef map <Vertex, int> Index;\n\nconst int inf = 1<<24;\nconst int size = 201;\nIndex ID;\nint N;\n\nbool F[size][size];\nbool D[size][size];\nbool W[size][size];\nint  T[size][size];\n\nvoid init() {\n    ID.clear();\n    N = 0;\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            F[i][j] = false;\n            D[i][j] = false;\n            W[i][j] = false;\n            T[i][j] = inf;\n        }\n    }\n}\n\nbool exist( Vertex v ) {\n    return ID.find(v) != ID.end();\n}\n\nvoid addVertex( Vertex v ) {\n    if ( exist( v ) ) return;\n    ID[v] = N++;\n}\n\nint getIndex( Vertex v ) {\n    return ID[v];\n}\n\nPVV input() {\n    string line;\n    cin >> line;\n    replace( line.begin(), line.end(), '-', ' ' );\n    istringstream is( line );\n    PVV answer;\n    is >> answer.first >> answer.second;\n    return answer;\n}\n\nbool solve( PVV e ) {\n    if ( !exist(e.first) || !exist(e.second) ) return false;\n    int a = getIndex( e.first );\n    int b = getIndex( e.second );\n    return W[a][b] && ( T[a][b] != inf && T[a][b]%2 );\n}\n\nbool check( int a, int b ) {\n    if ( a == b ) return false;\n    bool flag = false;\n    for ( int i = 0; i < N; i++ ) {\n        if ( ( F[a][i] && F[b][i] ) || ( F[i][a] && F[i][b] ) ) {\n            flag = true;\n        }\n        if ( ( F[a][i] && F[i][b] ) || ( F[i][a] && F[b][i] ) ) {\n            return false;\n        }\n    }\n    return flag;\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        init();\n        for ( int i = 0; i < n; i++ ) {\n            PVV in = input();\n            addVertex(in.first);\n            addVertex(in.second);\n            int a = getIndex(in.first);\n            int b = getIndex(in.second);\n            F[a][b] = true;\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                D[i][j] = check( i, j );\n            }\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                W[i][j] = F[i][j] || D[i][j];\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    W[i][j] = W[i][j] || ( W[i][k] && W[k][j] );\n                }\n            }\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                if ( F[i][j] ) T[i][j] = 1;\n                else if ( D[i][j] ) T[i][j] = T[j][i] = 0;\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    T[i][j] = min( T[i][j], T[i][k] + T[k][j] );\n                }\n            }\n        }\n        int m;\n        cin >> m;\n        cout << N << endl;\n        for ( int i = 0; i < m; i++ ) {\n            PVV in = input();\n            cout << ( solve( in ) ? \"YES\" : \"NO\" ) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\treturn vs{ l,r };\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n, q;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p, INF));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f = false;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k]==1 && dist[j][k]==1) || (dist[k][i]==1 && dist[k][j]==1)) f = true;\n\t\t\t\tif ((dist[i][k]==1 && dist[k][j]==1) || (dist[k][i]==1 && dist[j][k]==1))\n\t\t\t\t{\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p) chmin(dist[i][j], dist[i][k] + dist[k][j]);\n\t\tvi color(p, -1);\n\t\tint col = 0;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i] != -1) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = col + 1;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to] != -1) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol += 2;\n\t\t}\n\t\tcout << p << endl;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif ((color[l] != color[r] && color[l] / 2 == color[r] / 2) && dist[r][l] != INF)\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<vector>\n#include<tuple>\nusing namespace std;\n\nconst int INF = 10000;\n\nint main() {\n    int n, m;\n    while(cin >> n, n) {\n        map<string, int> id;\n        vector<tuple<int, int>> cross;\n        int size = 0;\n        for(int i = 0; i < n; ++i) {\n            string x, y, input;\n            int index;\n            cin >> input;\n            index = input.find(\"-\");\n            x = input.substr(0, index);\n            y = input.substr(index + 1, input.size() - index - 1);\n            if(!id.count(x)) id[x] = size++;\n            if(!id.count(y)) id[y] = size++;\n            cross.push_back(tuple<int, int>(id[x], id[y]));\n        }\n\n        // adjacent matrix\n        vector<vector<int>> distance(size, vector<int>(size, INF));\n        for(auto& c: cross) distance[get<0>(c)][get<1>(c)] = 1;\n        for(int a = 0; a < size; ++a) for(int b  = a + 1; b < size; ++b) {\n            set<int> ac, ca, bc, cb;\n            for(auto c: cross) {\n                if(get<0>(c) == a) ac.insert(get<1>(c));\n                if(get<1>(c) == a) ca.insert(get<0>(c));\n                if(get<0>(c) == b) bc.insert(get<1>(c));\n                if(get<1>(c) == b) cb.insert(get<0>(c));\n            }\n            bool condition1 = false;\n            bool condition2 = true;\n            bool condition3 = true;\n            for(auto v: ca) {\n                if(bc.count(v)) condition2 = false;\n                if(cb.count(v)) condition1 = true;\n            }\n            for(auto v: ac) {\n                if(cb.count(v)) condition3 = false;\n                if(bc.count(v)) condition1 = true;\n            }\n            if(condition1 && condition2 && condition3) {\n                distance[a][b] = distance[b][a] = 0;\n            }\n        }\n\n        // Warshal-Floyd\n        for(int k = 0; k < size; ++k) for(int i = 0; i < size; ++i) for(int j = 0; j < size; ++j)\n            distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]);\n\n        // output\n        cout << size << endl;\n        for(cin >> m; m > 0; --m) {\n            string x, y, input;\n            int index;\n            cin >> input;\n            index = input.find(\"-\");\n            x = input.substr(0, index);\n            y = input.substr(index + 1, input.size() - index - 1);\n\n            cout << (distance[id[x]][id[y]] & 1 ? \"YES\" : \"NO\") << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing ps = pair<string,string>;\n\nps split(string s){\n    int n = s.size();\n    int idx = 0;\n    while(idx<n && s[idx]!='-') ++idx;\n\n    return {s.substr(0,idx), s.substr(idx+1)};\n}\n\nconst int N = 202;\nconst int INF = 101010;\n\n// 入力から分かる強さ関係\nvector<int> G[N];\nbool arr[N][N];\n\nint d[N][N];\n\n// 水準関係\nint C[N][N];\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        rep(i,N) G[i].clear();\n        rep(i,N)rep(j,N) arr[i][j] = false;\n\n        rep(i,N)rep(j,N) d[i][j]=INF;\n        rep(i,N) d[i][i]=0;\n\n        rep(i,N)rep(j,N) C[i][j]=INF;\n        rep(i,N) C[i][i]=0;\n\n        map<string,int> c2id;\n        vector<string> names;\n        rep(i,n){\n            string s;\n            cin >>s;\n            ps cross = split(s);\n\n            if(!c2id.count(cross.fi)){\n                c2id[cross.fi] = c2id.size();\n                names.pb(cross.fi);\n            }\n            if(!c2id.count(cross.se)){\n                c2id[cross.se] = c2id.size();\n                names.pb(cross.se);\n            }\n            int u = c2id[cross.fi], v = c2id[cross.se];\n            G[u].pb(v);\n            C[u][v] = 1;\n            d[u][v] = d[v][u] = 1;\n            arr[u][v] = true;\n        }\n\n        int V = c2id.size();\n\n        rep(k,V)rep(i,V)rep(j,V) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        auto same_degree = [&](int a, int b){\n            bool same = false;\n            rep(i,V){\n                if( (arr[a][i]||arr[i][a]) && (arr[b][i]||arr[i][b]) ) same = true;\n            }\n            if(!same) return false;\n\n            rep(i,V){\n                if(arr[i][a]&&arr[b][i]) return false;\n                if(arr[a][i]&&arr[i][b]) return false;\n            }\n            return true;\n        };\n\n        rep(i,V)rep(j,i){\n            if(same_degree(i,j)){\n                // cout << \"DEG :: \" << names[i] << \" \" << names[j] << endl;\n                C[i][j] = C[j][i] = 1;\n            }\n        }\n        rep(k,V)rep(i,V)rep(j,V) C[i][j] = min(C[i][j], C[i][k]+C[k][j]);\n\n        cout << V << endl;\n\n        int Q;\n        cin >>Q;\n        while(Q--){\n            string q;\n            cin >>q;\n\n            ps qc = split(q);\n\n            bool ok = false;\n            if(c2id.count(qc.fi) && c2id.count(qc.se)){\n                int u = c2id[qc.fi], v = c2id[qc.se];\n                // dbg(C[u][v]);\n\n                if(d[u][v]%2==1 && C[u][v]<INF) ok = true;\n            }\n            cout << (ok?\"YES\":\"NO\") << endl;\n        }\n        // dbg(c2id.size());\n        // dbg(names);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing ps = pair<string,string>;\n\nps split(string s){\n    int n = s.size();\n    int idx = 0;\n    while(idx<n && s[idx]!='-') ++idx;\n\n    return {s.substr(0,idx), s.substr(idx+1)};\n}\n\nconst int N = 300;\nconst int INF = 191919;\n\n// 入力から分かる強さ関係\nvector<int> G[N];\nbool arr[N][N];\n\nint d[N][N];\n\n// 水準関係\nint C[N][N];\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        rep(i,N) G[i].clear();\n        rep(i,N)rep(j,N) C[i][j]=INF;\n        rep(i,N) C[i][i]=0;\n        rep(i,N)rep(j,N) d[i][j]=INF;\n        rep(i,N) d[i][i]=0;\n        rep(i,N)rep(j,N) arr[i][j] = false;\n\n\n        map<string,int> c2id;\n        vector<string> names;\n        rep(i,n){\n            string s;\n            cin >>s;\n            ps cross = split(s);\n\n            if(!c2id.count(cross.fi)){\n                c2id[cross.fi] = c2id.size();\n                names.pb(cross.fi);\n            }\n            if(!c2id.count(cross.se)){\n                c2id[cross.se] = c2id.size();\n                names.pb(cross.se);\n            }\n            int u = c2id[cross.fi], v = c2id[cross.se];\n            G[u].pb(v);\n            C[u][v]=1;\n            d[u][v] = d[v][u] = 1;\n            arr[u][v] = true;\n        }\n\n        int V = c2id.size();\n\n        rep(k,V)rep(i,V)rep(j,V) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        auto same_degree = [&](int a, int b){\n            bool same = false;\n            rep(i,V){\n                if( (arr[a][i]||arr[i][a]) && (arr[b][i]||arr[i][b]) ) same = true;\n            }\n            if(!same) return false;\n\n            rep(i,V){\n                if(arr[i][a]&&arr[b][i]) return false;\n                if(arr[a][i]&&arr[i][b]) return false;\n            }\n\n            return true;\n        };\n\n        rep(i,V)rep(j,i){\n            if(same_degree(i,j)){\n                // cout << \"DEG :: \" << names[i] << \" \" << names[j] << endl;\n                C[i][j] = C[j][i] = 1;\n            }\n        }\n        rep(k,V)rep(i,V)rep(j,V) C[i][j] = min(C[i][j], C[i][k]+C[k][j]);\n\n        cout << V << endl;\n\n        int Q;\n        cin >>Q;\n        while(Q--){\n            string q;\n            cin >>q;\n\n            ps qc = split(q);\n\n            int u = c2id[qc.fi], v = c2id[qc.se];\n            // dbg(C[u][v]);\n\n            bool ok = false;\n            if(d[u][v]%2==1 && C[u][v]<INF) ok = true;\n            cout << (ok?\"YES\":\"NO\") << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    map< string, int > conv;\n    int s[201], t[201];\n    bool mat[201][201] = {{}}, beet[201][201] = {{}};\n    int M = 200;\n    UnionFind tree(M + M);\n\n    for(int i = 0; i < M; i++) beet[i][i] = true;\n\n    for(int i = 0; i < N; i++) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S)) conv[S] = conv.size() - 1;\n      if(!conv.count(T)) conv[T] = conv.size() - 1;\n      int a = conv[S], b = conv[T];\n      mat[a][b] = beet[a][b] = true;\n      tree.unite(a + M, b);\n      tree.unite(b + M, a);\n    }\n    for(int i = 0; i < M; i++) {\n      for(int j = i + 1; j < M; j++) {\n        bool f = [&]()\n        {\n          bool flag = false;\n          for(int k = 0; k < M; k++) {\n            if(mat[i][k] & mat[j][k]) flag = true;\n            if(mat[k][i] & mat[k][j]) flag = true;\n            if(mat[i][k] & mat[k][j]) return (false);\n            if(mat[j][k] & mat[k][i]) return (false);\n          }\n          return (flag);\n        }();\n        beet[i][j] |= beet[j][i] |= f;\n      }\n    }\n    for(int k = 0; k < M; k++) {\n      for(int i = 0; i < M; i++) {\n        for(int j = 0; j < M; j++) {\n          beet[i][j] |= beet[i][k] & beet[k][j];\n        }\n      }\n    }\n\n    int Q;\n    cin >> Q;\n    cout << conv.size() << endl;\n    while(Q--) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S) || !conv.count(T)) {\n        cout << \"NO\" << endl;\n      } else {\n        int a = conv[S];\n        int b = conv[T];\n        if(tree.find(a) != tree.find(b + M) || tree.find(b) != tree.find(a + M) || !beet[a][b]) {\n          cout << \"NO\" << endl;\n        } else {\n          cout << \"YES\" << endl;\n        }\n      }\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing ps = pair<string,string>;\n\nps split(string s){\n    int n = s.size();\n    int idx = 0;\n    while(idx<n && s[idx]!='-') ++idx;\n\n    return {s.substr(0,idx), s.substr(idx+1)};\n}\n\nconst int N = 200;\nconst int INF = 191919;\n\n// 入力から分かる強さ関係\nvector<int> G[N];\nbool arr[N][N];\n\nint d[N][N];\n\n// 水準関係\nint C[N][N];\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        rep(i,N) G[i].clear();\n        rep(i,N)rep(j,N) C[i][j]=INF;\n        rep(i,N) C[i][i]=0;\n        rep(i,N)rep(j,N) d[i][j]=INF;\n        rep(i,N) d[i][i]=0;\n        rep(i,N)rep(j,N) arr[i][j] = false;\n\n\n        map<string,int> c2id;\n        vector<string> names;\n        rep(i,n){\n            string s;\n            cin >>s;\n            ps cross = split(s);\n\n            if(!c2id.count(cross.fi)){\n                c2id[cross.fi] = c2id.size();\n                names.pb(cross.fi);\n            }\n            if(!c2id.count(cross.se)){\n                c2id[cross.se] = c2id.size();\n                names.pb(cross.se);\n            }\n            int u = c2id[cross.fi], v = c2id[cross.se];\n            G[u].pb(v);\n            C[u][v]=1;\n            d[u][v] = d[v][u] = 1;\n            arr[u][v] = true;\n        }\n\n        int V = c2id.size();\n\n        rep(k,V)rep(i,V)rep(j,V) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        auto same_degree = [&](int a, int b){\n            bool same = false;\n            rep(i,V){\n                if( (arr[a][i]||arr[i][a]) && (arr[b][i]||arr[i][b]) ) same = true;\n            }\n            if(!same) return false;\n\n            rep(i,V){\n                if(arr[i][a]&&arr[b][i]) return false;\n                if(arr[a][i]&&arr[i][b]) return false;\n            }\n\n            return true;\n        };\n\n        rep(i,V)rep(j,i){\n            if(same_degree(i,j)){\n                // cout << \"DEG :: \" << names[i] << \" \" << names[j] << endl;\n                C[i][j] = C[j][i] = 1;\n            }\n        }\n        rep(k,V)rep(i,V)rep(j,V) C[i][j] = min(C[i][j], C[i][k]+C[k][j]);\n\n        cout << V << endl;\n\n        int Q;\n        cin >>Q;\n        while(Q--){\n            string q;\n            cin >>q;\n\n            ps qc = split(q);\n\n            bool ok = false;\n            if(c2id.count(qc.fi) && c2id.count(qc.se)){\n                int u = c2id[qc.fi], v = c2id[qc.se];\n                // dbg(C[u][v]);\n\n                if(d[u][v]%2==1 && C[u][v]<INF) ok = true;\n            }\n            cout << (ok?\"YES\":\"NO\") << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<string,int> M;\n\nint str2int(string S){\n    if(M.find(S)==M.end()){\n        int n = M.size();\n        M[S]=n;\n    }\n    return M[S];\n}\n\nint E[200][200];//[a][b]=a to b\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        fill(E[0],E[200],100000000);\n        M.clear();\n        for(int i=0;i<N;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    E[i1][i2]=1;\n                    break;\n                }\n            }\n        }\n        int m = M.size();\n        cout<<m<<endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<m;j++){\n                if(E[i][j]==1||E[j][i]==1) continue;\n                //cond1\n                bool b=false;\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[i][k]==1||E[k][i]==1)&&(E[j][k]==1||E[k][j]==1)){\n                        b=true;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                //cond2,3\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[k][i]==1&&E[j][k]==1)||(E[i][k]==1&&E[k][j]==1)){\n                        b=false;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                E[i][j]=E[j][i]=2;\n            }\n        }\n        //WF\n        // for(int i=0;i<m;i++) E[i][i]=0;\n        for(int k=0;k<m;k++){\n            for(int i=0;i<m;i++){\n                for(int j=0;j<m;j++){\n                    E[i][j]=min(E[i][j],E[i][k]+E[k][j]);\n                }\n            }\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    if(E[i1][i2]%2==0){\n                        cout<<\"NO\"<<endl;\n                    }else{\n                        cout<<\"YES\"<<endl;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\tvs res;\n\tres.push_back(l); res.push_back(r);\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p;\n\t\t\tp++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] || dist[k][i]) && (dist[j][k] || dist[k][j])) f1 = true;\n\t\t\t\tif ((dist[i][k] && dist[k][j]) || (dist[k][i] && dist[j][k])) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p)\n\t\t{\n\t\t\tif (dist[i][k] && dist[k][j]) dist[i][j] = 1;\n\t\t}\n\t\tvi color(p);\n\t\tint col = 1;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i]) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = -col;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to]) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol++;\n\t\t}\n\t\tcout << p << endl;\n\t\tint q;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif (color[l] == -color[r] && dist[r][l])\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nvoid pkuassert(bool t){t=1/t;};\n\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint N,M;\n\nmap<string,int> s2im;\nint s2i(string a){\n  if(s2im.count(a))\n    return s2im[a];\n  int sz=SZ(s2im);\n  return s2im[a]=sz;\n}\n\nint in[200][200];\nint g[200][200];\n\nvoid solve(){\n  rep(i,200)rep(j,200) g[i][j]=in[i][j]=9999+1;\n  s2im.clear();\n  rep(i,N) {\n    string a,b;\n    cin >> a;\n    FOR(it,a) if(*it=='-') *it=' ';\n    stringstream ss(a);\n    ss >> a >> b;\n    in[s2i(a)][s2i(b)]=1;\n  }\n\n  int n=SZ(s2im);\n  rep(i,n)rep(j,n){\n    bool ok=false;\n    rep(k,n){\n      if(in[i][k]==1 && in[j][k]==1) ok=true;\n      if(in[i][k]==1 && in[k][j]==1) ok=true;\n      if(in[k][i]==1 && in[j][k]==1) ok=true;\n      if(in[k][i]==1 && in[k][j]==1) ok=true;\n    }\n    if(!ok) continue;\n    ok=false;\n    rep(k,n) if(in[k][i]==1 && in[j][k]==1) ok=true;\n    if(ok) continue;\n    rep(k,n) if(in[i][k]==1 && in[k][j]==1) ok=true;\n    if(ok) continue;\n    g[i][j]=g[j][i]=1;\n  }\n  \n  rep(i,n)rep(j,n) g[i][j]=min(g[i][j],in[i][j]);\n  rep(i,n)rep(j,n) if(in[i][j]==1) in[j][i]=1;\n\n\n  \n  rep(k,n)rep(i,n)rep(j,n){\n    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    in[i][j]=min(in[i][j],in[i][k]+in[k][j]);\n  }\n  \n\n  cout << n << endl;\n  cin >> M;\n  rep(i, M){\n    string a,b;\n    cin >> a;\n    FOR(it,a) if(*it=='-') *it=' ';\n    stringstream ss(a);\n    ss >> a >> b;\n    int av=s2i(a);\n    int bv=s2i(b);\n    //cout << av << ' ' << bv << ' ' << g[av][bv] << ' ' << in[av][bv] << ' ' << in[bv][av] << endl;\n    if(av<n && bv<n && g[av][bv]<9999 &&\n       (in[av][bv]&1))cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> N && N) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\treturn vs{ l,r };\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n, q;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p, INF));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] == 1 || dist[k][i] == 1) && (dist[j][k] == 1 || dist[k][j] == 1)) f1 = true;\n\t\t\t\tif ((dist[i][k] == 1 && dist[k][j] == 1) || (dist[k][i] == 1 && dist[j][k] == 1)) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p) chmin(dist[i][j], dist[i][k] + dist[k][j]);\n\t\tvi color(p, -1);\n\t\tint col = 0;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i] != -1) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = col + 1;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to] != -1) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol += 2;\n\t\t}\n\t\tcout << p << endl;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif ((color[l] != color[r] && color[l] / 2 == color[r] / 2) && dist[r][l] != INF)\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\ntypedef pair<int,int>P;\n\nint n,NUM,dp[222][222];\n\nint boo[222][222];\n\nint graph[222][222];\n\nvector<int>rv[222],v[222];\n\nbool used[222];\n\nset<int>st[222];\n\nmap<string,int>M;\n\nmap<pair<int,int>,int>MAP;\n\n\nvoid INIT(){\n\tM.clear();\n\tmemset(graph,0,sizeof(graph));\n\tmemset(boo,0,sizeof(boo));\n\tMAP.clear();\n\tNUM=1;\n\tr(i,222)v[i].clear(),rv[i].clear(),st[i].clear();\n\tr(i,222)r(j,222)dp[i][j]=(i==j?0:1e8+1);\n}\n\nvoid WAR(){\n\tr(o,n)r(i,n)r(j,n)dp[i][j]=min(dp[i][j],dp[i][o]+dp[o][j]);\n}\n\n\n\nvoid make_graph(){\n\n\tMAP.clear();\n\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tMAP[P(i,v[i][j])]=1;\n\n\t\t\t//\tcout<<MM[i]<<' '<<MM[v[i][j]]<<endl;\n\t\t}\n\t}\n\t//cout<<endl<<endl<<endl;\n\n\tfor(int A=1;A<NUM;A++){\n\n\t\tfor(int B=A+1;B<NUM;B++){\n\n\t\t\tint flag = 1,flag2=0;\n\n\t\t\tfor(int D=1;D<NUM;D++){\n\n\t\t\t\tif(MAP[P(A,D)]&&MAP[P(D,B)])flag=0;\n\n\t\t\t\tif(MAP[P(D,A)]&&MAP[P(B,D)])flag=0;\n\n\t\t\t\tif(( (MAP[P(D,A)]&&MAP[P(D,B)]) || (MAP[P(A,D)]&&MAP[P(B,D)]) )) flag2 =1;\n\t\t\t}\n\n\t\t\t//\tif(A==2&&B==3)cout<<flag<<' '<<flag2<<endl;\n\n\t\t\tif(flag && flag2){\n\t\t\t\tboo[A][B] = boo[B][A] = 1;\n\n\t\t\t\t//cout<<MM[A]<<' '<<MM[B]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*vector<int>mato[222];\n\t\n\tfor(int i=1;i<NUM;i++){\n\t\t\n\t\tfor(int j=0;j<rv[i].size();j++){\n\t\t\t\n\t\t\tfor(int k=j+1;k<rv[i].size();k++){\n\t\t\t\t\n\t\t\t\tmato[rv[i][j]].push_back(rv[i][k]);\n\t\t\t\tmato[rv[i][k]].push_back(rv[i][j]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tr(i,NUM-1)cout<<MM[i+1]<<' '<<mato[i+1].size()<<endl;\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tr(k,mato[v[i][j]].size()){\n\t\t\t\tif(!st[i].count(mato[v[i][j]][k])){\n\t\t\t\t\t\n\t\t\t\t\tv[i].push_back(mato[v[i][j]][k]);\n\t\t\t\t\t\n\t\t\t\t\t st[i].insert(mato[v[i][j]][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}*/\n\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=0;j<v[i].size();j++){\n\n\t\t\tint now = v[i][j];\n\n\t\t\tgraph[i][now] = 1;\n\n\t\t\tfor(int k=1;k<NUM;k++){\n\t\t\t\tif(boo[now][k]){\n\n\t\t\t\t\tgraph[i][k] = 1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i=1;i<NUM;i++){\n\n\t\tfor(int j=1;j<NUM;j++){\n\n\t\t\tif(boo[i][j]){\n\n\t\t\t\tfor(int k=0;k<v[j].size();k++){\n\t\t\t\t\tgraph[i][v[j][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tr(i,222)v[i].clear();\n\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=1;j<NUM;j++){\n\t\t\tif(graph[i][j]){\n\n\t\t\t\tv[i].push_back(j);\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid INPUT(){\n\tr(i,n){\n\t\tint idx=0;\n\t\tstring s,s1,s2;      //cout<<1<<endl;\n\t\tcin>>s;\n\t\twhile(s[idx]!='-')s1+=s[idx++];             //cout<<s1<<endl;\n\t\tidx++;\n\t\twhile(idx<(int)s.size())s2+=s[idx++];\n\t\tif(M[s1]==0)M[s1]=NUM++;\n\t\tif(M[s2]==0)M[s2]=NUM++;    //cout<<NUM<<endl;\n\t\t\n\t\tdp[M[s1]-1][M[s2]-1]=dp[M[s2]-1][M[s1]-1]=1;\n\t\t\n\t\tv[M[s1]].push_back(M[s2]);\n\t\tst[M[s1]].insert(M[s2]);\n\t\trv[M[s2]].push_back(M[s1]);\n\n\t\t//\tcout<<M[s1]<<' '<<M[s2]<<endl;\n\n\t\t//MAP[P(M[s1],M[s2])]=1;\n\t}\n\n\t//\tcout<<endl<<endl;\n\n\n\tr(i,NUM)make_graph();\n}\n\nbool BFS(int s,int t){\n\tmemset(used,0,sizeof(used));\n\tused[s]=1;\n\tqueue<int>q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();\n\t\tr(i,(int)v[x].size()){\n\t\t\tint to = v[x][i];\n\t\t\tif(used[to])continue;\n\t\t\tused[to]=1;\n\t\t\tq.push(to);\n\t\t\tif(to==t)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid QUERY(){\n\n\t//cout<<grap\n\n\n\t/*for(int i=1;i<NUM;i++){\n\t\tcout<<endl;\n\t\tcout<<endl;\n\t\tcout<<MM[i]<<endl;\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tcout<<MM[v[i][j]]<<endl;\n\t\t}\n\t\t}*/\n\n\t\n\tcout<<NUM-1<<endl;\n\tint Q;\n\tcin>>Q;\n\twhile(Q--){\n\t\tint idx=0,start,goal;\n\t\tstring s,s1,s2;\n\t\tcin>>s;\n\t\twhile(s[idx]!='-')s1+=s[idx++];\n\t\tidx++;\n\t\twhile(idx<s.size())s2+=s[idx++];\n\n\t\tif(M[s1]==0||M[s2]==0){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(dp[M[s1]-1][M[s2]-1]<1e6&&dp[M[s1]-1][M[s2]-1]%2==0){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstart = M[s1];\n\t\tgoal  = M[s2];\n\n\t\tif(BFS(start,goal)||!BFS(goal,start)) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t\t\n\t}\n}\n\n\nint main(){\n\twhile(cin>>n,n){\n\t\tINIT();\n\t  INPUT();\n\t\tWAR();\n\t\tQUERY();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef string Vertex;\ntypedef pair<Vertex, Vertex> PVV;\ntypedef map <Vertex, int> Index;\n\nconst int inf = 1<<24;\nconst int size = 201;\nIndex ID;\nint N;\n\nbool F[size][size];\nbool D[size][size];\nbool W[size][size];\nint  T[size][size];\n\nvoid init() {\n    ID.clear();\n    N = 0;\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            F[i][j] = false;\n            D[i][j] = false;\n            W[i][j] = false;\n            T[i][j] = inf;\n        }\n    }\n}\n\nbool exist( Vertex v ) {\n    return ID.find(v) != ID.end();\n}\n\nvoid addVertex( Vertex v ) {\n    if ( exist( v ) ) return;\n    ID[v] = N++;\n}\n\nint getIndex( Vertex v ) {\n    return ID[v];\n}\n\nPVV input() {\n    string line;\n    cin >> line;\n    replace( line.begin(), line.end(), '-', ' ' );\n    istringstream is( line );\n    PVV answer;\n    is >> answer.first >> answer.second;\n    return answer;\n}\n\nbool solve( PVV e ) {\n    if ( !exist(e.first) || !exist(e.second) ) return false;\n    int a = getIndex( e.first );\n    int b = getIndex( e.second );\n    return W[a][b] && ( T[a][b] != inf && T[a][b]%2 );\n}\n\nbool check1( int a, int b, int c ) {\n    if ( a == b || b == c || c == a ) return false;\n    return ( F[a][c] && !F[c][a] && F[b][c] && !F[c][b] )\n        || ( F[c][a] && !F[a][c] && F[c][b] && !F[b][c] );\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        init();\n        for ( int i = 0; i < n; i++ ) {\n            PVV in = input();\n            addVertex(in.first);\n            addVertex(in.second);\n            int a = getIndex(in.first);\n            int b = getIndex(in.second);\n            F[a][b] = true;\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                for ( int k = 0; k < N; k++ ) {\n                    if ( check1( i, j, k ) ) {\n                        D[i][j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                W[i][j] = F[i][j] || D[i][j];\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    W[i][j] = W[i][j] || ( W[i][k] && W[k][j] );\n                }\n            }\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                if ( F[i][j] ) T[i][j] = 1;\n                else if ( D[i][j] ) T[i][j] = T[j][i] = 0;\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    T[i][j] = min( T[i][j], T[i][k] + T[k][j] );\n                }\n            }\n        }\n        int m;\n        cin >> m;\n        cout << N << endl;\n        for ( int i = 0; i < m; i++ ) {\n            PVV in = input();\n            cout << ( solve( in ) ? \"YES\" : \"NO\" ) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\tvs res;\n\tres.push_back(l); res.push_back(r);\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p;\n\t\t\tp++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] || dist[k][i]) && (dist[j][k] || dist[k][j])) f1 = true;\n\t\t\t\tif ((dist[i][k] && dist[k][j]) || (dist[k][i] && dist[j][k])) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p)\n\t\t{\n\t\t\tif (dist[i][k] && dist[k][j]) dist[i][j] = 1;\n\t\t}\n\t\tvi color(p);\n\t\tint col = 1;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i]) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = -col;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to]) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol++;\n\t\t}\n\t\tcout << p << endl;\n\t\tint q;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif (color[l] == -color[r] && dist[r][l])\n\t\t\t{\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\nmap<string,int> rtoi;\nint d[256][256];\nint V;\n\nvoid solve(){\n    rep(i,V)rep(j,V){\n        bool C=false, DE=true;\n        if(d[i][j]==1 || d[j][i]==1) continue;\n        rep(k,V){\n            if(k==i || k==j) continue;\n            if((d[i][k]==1||d[k][i]==1) && (d[j][k]==1||d[k][j]==1))\n                C=true;\n            if((d[i][k]==1&&d[k][j]==1) || (d[k][i]==1&&d[j][k]==1))\n                DE=false;\n        }\n        if(C&&DE) d[i][j]=d[j][i]=0;\n    }\n    rep(k,V)rep(i,V)rep(j,V){\n        d[i][j]=min(d[i][j], d[i][k] + d[k][j]);\n    }\n}\n\nbool ask(string const& p, string const& q){\n    int pi=inf,qi=inf;\n    if(rtoi.count(p)==1 && rtoi.count(q)==1){\n        pi=rtoi[p], qi=rtoi[q];\n    }\n    return max(pi,qi)!=inf && d[pi][qi]!=inf && d[pi][qi]&1;\n}\n\nint main(){\n    int n;\n    while(cin>>n, n){\n        rep(i,256) rep(j,256) d[i][j]=inf;\n        rep(i,n){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x);\n            string q=s.substr(x+1);\n            if(rtoi.count(p)==0)rtoi[p]=V++;\n            if(rtoi.count(q)==0)rtoi[q]=V++;\n            int ip=rtoi[p], iq=rtoi[q];\n            d[ip][iq]=1;\n        }\n        solve();\n        cout<<V<<endl;\n        int m; cin>>m;\n        rep(i,m){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x), q=s.substr(x+1);\n            puts(1|ask(p,q)  ? \"YES\" : \"NO\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n\nusing namespace std;\n\nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n\nbool eq_str(const string& p,const string& q){ p==q; }\n\nmultimap<string,string>m1,m2;\nmap<string,int>color;\n\nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n\nint graph[200][200];\n\nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tgraph[i][j]|=graph[i][k]&graph[k][j];\n}\n\nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n\n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n\n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node),eq_str),node.end());\n\n    cout << node.size() << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n\n    sort(all(node3));\n    node3.erase(unique(all(node3),eq_str),node3.end());\n\n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n  \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n\n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)graph[i][j]=i==j?1:0;\n\n    bool g[200][200];\n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)g[i][j]=false;\n\n    multimap<string,string>::iterator it=m1.begin(),it2=m1.begin();\n\n    while(it!=m1.end()){\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).sec){\n\t  graph[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  graph[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  graph[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  graph[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n\tit2++;\n      }\n      it++;\n    }\n\n    it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n  \n    warshall_floyd(node3.size());\n\n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO \" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\tvs res;\n\tres.push_back(l); res.push_back(r);\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p;\n\t\t\tp++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] || dist[k][i]) && (dist[j][k] || dist[k][j])) f1 = true;\n\t\t\t\tif ((dist[i][k] && dist[k][j]) || (dist[k][i] && dist[j][k])) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p)\n\t\t{\n\t\t\tif (dist[i][k] && dist[k][j]) dist[i][j] = 1;\n\t\t}\n\t\tvi color(p);\n\t\tint col = 1;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i]) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = -col;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to]) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol++;\n\t\t}\n\t\tcout << p << endl;\n\t\tint q;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif (color[l] == -color[r] && dist[r][l])\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//1818\n#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define EPS 0.000001\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\n\n\nint main(){\n\tint n,m;\n\twhile(cin >> n){\n\t\tif(n==0) break;\n\t\tint c=0;\n\t\tmap<string,int> mp;\n\t\tchar in1[20],in2[20];\n\t\tint g[201][201];\n\t\tint i,j,k;\n\t\tfor(i=0;i<201;i++) for(j=0;j<201;j++) g[i][j]=INF;\n\t\t\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%s\",in1);\n\t\t\tstring x,y,in=in1;\n\t\t\tfor(j=0;j<in.length(),in[j]!='-';j++) x+=in[j];\n\t\t\tj++;\n\t\t\tfor(;j<in.length();j++) y+=in[j];\n\t\t\tif(mp.find(x)==mp.end()) mp.insert(pair<string,int>(x,c++));\n\t\t\tif(mp.find(y)==mp.end()) mp.insert(pair<string,int>(y,c++));\n\t\t\tg[(*mp.find(x)).second][(*mp.find(y)).second]=1;\n\t\t}\n\t\t\n\t\tfor(i=0;i<c;i++){\n\t\t\tfor(j=i+1;j<c;j++){\n\t\t\t\tif(g[i][j]==INF && g[j][i]==INF){\n\t\t\t\t\tint f=INF;\n\t\t\t\t\tfor(k=0;k<c;k++){\n\t\t\t\t\t\tif(k==i || k==j) continue;\n\t\t\t\t\t\tif(g[i][k]==1 && g[j][k]==1) f=0;\n\t\t\t\t\t\tif(g[k][i]==1 && g[j][k]==1) f=0;\n\t\t\t\t\t\tif(g[i][k]==1 && g[k][j]==1) f=INF;\n\t\t\t\t\t\tif(g[j][k]==1 && g[k][i]==1) f=INF;\n\t\t\t\t\t}\n\t\t\t\t\tg[i][j]=f;\n\t\t\t\t\tg[j][i]=f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<c;k++){\n\t\t\tfor(i=0;i<c;i++){\n\t\t\t\tfor(j=0;j<c;j++){\n\t\t\t\t\tif(g[i][j] > g[i][k]+g[k][j]) g[i][j]=g[i][k]+g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << c << endl;\n\t\tcin >> m;\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%s\",in1);\n\t\t\tstring x,y,in=in1;\n\t\t\tfor(j=0;j<in.length(),in[j]!='-';j++) x+=in[j];\n\t\t\tj++;\n\t\t\tfor(;j<in.length();j++) y+=in[j];\n\t\t\tif(mp.find(x)==mp.end() || mp.find(y)==mp.end()) cout << \"NO\" << endl;\n\t\t\telse if(g[(*mp.find(x)).second][(*mp.find(y)).second]<INF && g[(*mp.find(x)).second][(*mp.find(y)).second]%2==1){\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nstruct Node {\n    int level;\n    int color;\n    int group;\n    vector<int> edges, back_edges;\n    vector<int> pending;\n    Node() : level(0), color(1) {}\n};\n\nstruct Dict {\n    int idx;\n    map<string,int> dict;\n\n    Dict() : idx(0) {}\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = idx++;\n    }\n\n    int size() const {\n        return idx;\n    }\n};\n\n#define FOREACH(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define TIMES(i,n) for(int (i) = 0; (i) < (n); ++(i))\n\ntypedef vector<unsigned char> Flag;\n\nvoid preprocess(int pos, vector<Node> &nodes, Flag &visited, int group) {\n    if(visited[pos]) return;\n    visited[pos] = 1;\n\n    Node &cur = nodes[pos];\n    cur.group = group;\n    FOREACH(it, cur.edges) {\n        if(visited[*it]) continue;\n        nodes[*it].level = cur.level+1;\n        nodes[*it].color = 1 - cur.color;\n        preprocess(*it, nodes, visited, group);\n    }\n    FOREACH(it, cur.back_edges) {\n        if(visited[*it]) continue;\n        nodes[*it].level = cur.level-1;\n        nodes[*it].color = 1 - cur.color;\n        preprocess(*it, nodes, visited, group);\n    }\n}\n\nbool is_same_level(int a, int b, const vector<Node> &nodes) {\n    vector<int> states(nodes.size(), 0);\n    FOREACH(it, nodes[a].edges) {\n        states[*it] |= 1;\n    }\n    FOREACH(it, nodes[b].edges) {\n        states[*it] |= 2;\n    }\n    FOREACH(it, nodes[a].back_edges) {\n        states[*it] |= 4;\n    }\n    FOREACH(it, nodes[b].back_edges) {\n        states[*it] |= 8;\n    }\n    bool has_c = false, has_d = false;\n    TIMES(i, nodes.size()) {\n        if(i == a || i == b) continue;\n        int state = states[i];\n        if((state & 0x0c) == 0x0c || (state & 0x03) == 0x03) {\n            has_c = true;\n        }\n        if((state & 0x09) == 0x09 || (state & 0x06) == 0x06) {\n            has_d = true;\n        }\n    }\n    return has_c && !has_d;\n}\n\nbool check(int from, int to, const vector<Node> &nodes, Flag &visited) {\n    if(visited[from]) return false;\n    if(from == to) return true;\n    visited[from] = 1;\n    const Node &cur = nodes[from];\n    FOREACH(it, cur.edges) {\n        if(check(*it, to, nodes, visited)) return true;\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Node> nodes(2*N);\n        Dict dict;\n        TIMES(_, N) {\n            string cross;\n            cin >> cross;\n            const int hyphen = cross.find('-');\n            const int a = dict.get(cross.substr(0, hyphen));\n            const int b = dict.get(cross.substr(hyphen+1));\n            nodes[b].edges.push_back(a);\n            nodes[a].back_edges.push_back(b);\n        }\n        N = dict.size();\n        nodes.resize(N);\n        Flag visited(N, 0);\n        TIMES(i, N) {\n            if(!visited[i]) {\n                preprocess(i, nodes, visited, i);\n            }\n        }\n        TIMES(i, N) {\n            TIMES(j, i) {\n                if(nodes[i].group == nodes[j].group) {\n                    if(is_same_level(i, j, nodes)) {\n                        nodes[i].pending.push_back(j);\n                        nodes[j].pending.push_back(i);\n                    }\n                }\n            }\n        }\n        TIMES(i, N) {\n            nodes[i].edges.insert(nodes[i].edges.end(), nodes[i].pending.begin(), nodes[i].pending.end());\n        }\n        cout << N << endl;\n\n        int M;\n        cin >> M;\n        TIMES(_, M) {\n            string cross;\n            cin >> cross;\n            const int hyphen = cross.find('-');\n            const int a = dict.get(cross.substr(0, hyphen));\n            const int b = dict.get(cross.substr(hyphen+1));\n            bool ans = true;\n            if(a >= N || b >= N) {\n                ans = false;\n            } else if(nodes[a].group != nodes[b].group) {\n                ans = false;\n            } else if(nodes[a].color == nodes[b].color) {\n                ans = false;\n            } else {\n                fill(visited.begin(), visited.end(), 0);\n                ans = check(b, a, nodes, visited);\n            }\n            cout << (ans?\"YES\":\"NO\") << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nchar in[50];\nchar L[50];\nchar R[50];\nint p[50];\nint q[50];\nint UF[500];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint g[310][310];\nint g2[310][310];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<string,int>m;\n\t\tint n=0;\n\t\tfor(int i=0;i<500;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tint at=0;\n\t\t\tint j;\n\t\t\tfor(j=0;in[j]!='-';j++){\n\t\t\t\tL[at]=in[j];at++;\n\t\t\t}L[at]=0;\n\t\t\tat=0;\n\t\t\tj++;\n\t\t\tfor(;in[j];j++){\n\t\t\t\tR[at]=in[j];at++;\n\t\t\t}R[at]=0;\n\t//\t\tprintf(\"%s %s\\n\",L,R);\n\t\t\tstring l=L;\n\t\t\tstring r=R;\n\t\t\tif(m.count(l))p[i]=m[l];\n\t\t\telse{\n\t\t\t\tm[l]=n;\n\t\t\t\tp[i]=n++;\n\t\t\t}\n\t\t\tif(m.count(r)){\n\t\t\t\tq[i]=m[r];\n\t\t\t}else{\n\t\t\t\tm[r]=n;q[i]=n++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[p[i]][q[i]]=1;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)g2[i][j]=0;\n\t\tfor(int i=0;i<n;i++)g2[i][i]=1;\n\t\tfor(int i=0;i<a;i++)g2[p[i]][q[i]]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tbool ok1=false;\n\t\t\t\tbool ok2=true;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(g[i][k]&&g[j][k])ok1=true;\n\t\t\t\t\tif(g[k][i]&&g[k][j])ok1=true;\n\t\t\t\t\tif(g[i][k]&&g[k][j])ok2=false;\n\t\t\t\t\tif(g[j][k]&&g[k][i])ok2=false;\n\t\t\t\t}\n\t\t\t\tif(ok1&&ok2)g2[i][j]=g2[j][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)\n\t\t\tg2[i][j]|=g2[i][k]&g2[k][j];\n\t\tprintf(\"%d\\n\",n);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tUNION(p[i]*2,q[i]*2+1);UNION(p[i]*2+1,q[i]*2);\n\t\t}\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tint at=0;int j;\n\t\t\tfor(j=0;in[j]!='-';j++){\n\t\t\t\tL[at]=in[j];at++;\n\t\t\t}L[at]=0;\n\t\t\tat=0;\n\t\t\tj++;\n\t\t\tfor(;in[j];j++){\n\t\t\t\tR[at]=in[j];at++;\n\t\t\t}R[at]=0;\n\t\t\tstring l=L;string r=R;\n\t\t\tif(!m.count(l)||!m.count(r)){printf(\"NO\\n\");continue;}\n\t\t\tint P=m[l];\n\t\t\tint Q=m[r];\n\t\t\tif(FIND(P*2)!=FIND(Q*2+1)||FIND(P*2+1)!=FIND(Q*2)){printf(\"NO\\n\");continue;}\n\t\t\tif(g2[P][Q])printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint M;\nmap<string,int> mp;\nbool e[200][200],ee[200][200];\nint t[200];\nvoid dfs(int x,int c){\n\tt[x]=c;\n\trep(i,200) if(e[x][i]&&t[i]==0) dfs(i,-c);\n\trep(i,200) if(e[i][x]&&t[i]==0) dfs(i,-c);\n}\nint main(){\n\twhile(true){\n\t\tcin>>M;\n\t\tif(M==0) break;\n\t\tmp.clear();\n\t\trep(i,200) rep(j,200) e[i][j]=0,ee[i][j]=(i==j);\n\t\trep(i,200) t[i]=0;\n\t\tint J=0;\n\t\trep(i,M){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tif(!mp.count(xx)) mp[xx]=J++;\n\t\t\tif(!mp.count(yy)) mp[yy]=J++;\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\te[x][y]=1;\n\t\t}\n\t\tint N=mp.size();\n\t\tcout<<N<<endl;\n\t\tint I=1;\n\t\trep(i,N) if(t[i]==0) dfs(i,I++);\n\t\trep(i,N) rep(j,N){\n\t\t\tbool a=0,b=1;\n\t\t\trep(k,N){\n\t\t\t\tif((e[i][k]||e[k][i])&&(e[j][k]||e[k][j])) a=1;\n\t\t\t\tif((e[i][k]&&e[k][j])||(e[j][k]&&e[k][i])) b=0;\n\t\t\t}\n\t\t\tif(a&&b) ee[i][j]=1;\n\t\t}\n\t\trep(i,N) rep(j,N) e[i][j]|=ee[i][j];\n\t\trep(i,N) rep(j,N) rep(k,N) if(e[j][i]&&e[i][k]) e[j][k]=1;\n\t\tint Q;\n\t\tcin>>Q;\n\t\trep(tt,Q){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\tif(t[x]==-t[y]&&e[x][y]) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define MOD 1000000007\n#define F first\n#define S second\n\ntypedef long long ll;\ntypedef vector<long long> vll;\ntypedef vector<int> vint;\ntypedef vector<vector<long long> > vvll;\ntypedef vector<vector<int> > vvint;\n\n\nvoid dfs(int x, int y, int c, vint& d, vvint &vv) {\n\td[x] = c;\n\trep(i, 210) {\n\t\tif(i == y) continue;\n\t\tif(vv[x][i] && d[i] < 0) {\n\t\t\tdfs(i, x, 1 - c, d, vv);\n\t\t}\n\t\tif(vv[i][x] && d[i] < 0) {\n\t\t\tdfs(i, x, 1 - c, d, vv);\n\t\t}\n\t}\n}\n\nbool dfs2(int x, int y, vint &used, vvint &vv, vvint &same) {\n\tif(used[x]) return false;\n\t// cout<<x<<\" \"<<y<<endl;\n\tif(x == y) return true;\n\tused[x] = 1;\n\trep(i, 210) {\n\t\tif(vv[x][i] || same[x][i]) {\n\t\t\t// cout<<\"next \"<<i<<endl;\n\t\t\tif(dfs2(i, y, used, vv, same)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tmap<string, int> ma;\n\t\tvector<pair<string, string>> v(n);\n\t\trep(i, n) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\trep(j, s.size()) {\n\t\t\t\tif(s[j] == '-') {\n\t\t\t\t\tstring a = s.substr(0, j);\n\t\t\t\t\tstring b = s.substr(j + 1);\n\t\t\t\t\tif(ma.count(a) == 0) {\n\t\t\t\t\t\tma[a] = ma.size();\n\t\t\t\t\t}\n\t\t\t\t\tif(ma.count(b) == 0) {\n\t\t\t\t\t\tma[b] = ma.size();\n\t\t\t\t\t}\n\t\t\t\t\tv[i] = mkp(a, b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvint vv;\n\t\tint MX = 210;\n\t\tvv.assign(MX, vint(MX, 0));\n\t\tvvint same = vv;\n\t\tfor(auto x : v) {\n\t\t\tvv[ma[x.F]][ma[x.S]] = 1;\n\t\t}\n\t\trep(i, MX) {\n\t\t\trep(j, MX) {\n\t\t\t\tbool f1 = false;\n\t\t\t\tbool f2 = true;\n\t\t\t\trep(k, MX) {\n\t\t\t\t\tif(vv[i][k] && vv[j][k]) f1 = true;\n\t\t\t\t\tif(vv[k][i] && vv[k][j]) f1 = true;\n\t\t\t\t\tif(vv[i][k] && vv[k][j]) f2 = false;\n\t\t\t\t\tif(vv[k][i] && vv[j][k]) f2 = false;\n\t\t\t\t}\n\t\t\t\tif(f1 && f2) {\n\t\t\t\t\tsame[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvint d(MX, -1);\n\t\trep(i, MX) {\n\t\t\tif(d[i] == -1) dfs(i, -1, 0, d, vv);\n\t\t}\n\t\tint q;\n\t\tcin >> q;\n\t\tcout << ma.size() << endl;\n\t\trep(i, q) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\trep(j, s.size()) {\n\t\t\t\tif(s[j] == '-') {\n\t\t\t\t\tstring a = s.substr(0, j);\n\t\t\t\t\tstring b = s.substr(j + 1);\n\t\t\t\t\tint aa, bb;\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tif(ma.count(a) == 0 || ma.count(b) == 0) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\taa = ma[a];\n\t\t\t\t\t\tbb = ma[b];\n\t\t\t\t\t\tif(min(d[aa], d[bb]) == -1 || d[aa] == d[bb]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvint used(MX, 0);\n\t\t\t\t\t\t\tok = dfs2(aa, bb, used, vv, same);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok) {\n\t\t\t\t\t\tcout << \"YES\" << endl;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint M;\nmap<string,int> mp;\nbool e[200][200],ee[200][200];\nint t[200];\nvoid dfs(int x,int c){\n\tt[x]=c;\n\trep(i,200) if(e[x][i]&&t[i]==0) dfs(i,-c);\n\trep(i,200) if(e[i][x]&&t[i]==0) dfs(i,-c);\n}\nint main(){\n\twhile(true){\n\t\tcin>>M;\n\t\tif(M==0) break;\n\t\tmp.clear();\n\t\trep(i,200) rep(j,200) e[i][j]=ee[i][j]=(i==j);\n\t\trep(i,200) t[i]=0;\n\t\tint J=0;\n\t\trep(i,M){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tif(!mp.count(xx)) mp[xx]=J++;\n\t\t\tif(!mp.count(yy)) mp[yy]=J++;\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\te[x][y]=1;\n\t\t}\n\t\tint N=mp.size();\n\t\tcout<<N<<endl;\n\t\tint I=1;\n\t\trep(i,N) if(t[i]==0) dfs(i,I++);\n\t\trep(i,N) rep(j,N) rep(k,N){\n\t\t\tif((e[i][k]||e[k][i])&&(e[j][k]||e[k][j])&&!(e[i][k]&&e[k][j])&&!(e[j][k]&&e[k][i])) ee[i][j]=1;\n\t\t}\n\t\trep(i,N) rep(j,N) e[i][j]|=ee[i][j];\n\t\trep(i,N) rep(j,N) rep(k,N) if(e[j][i]&&e[i][k]) e[j][k]=1;\n\t\tint Q;\n\t\tcin>>Q;\n\t\trep(tt,Q){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tif(!mp.count(xx)) mp[xx]=mp.size();\n\t\t\tif(!mp.count(yy)) mp[yy]=mp.size();\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\tif(t[x]!=0&&t[x]==-t[y]&&e[x][y]) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n \nusing namespace std;\n \nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n \nbool eq_str(const string& p,const string& q){ p==q; }\n \nmultimap<string,string>m1,m2;\nmap<string,int>color;\n \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n \nint graph[300][300];\n \nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n    graph[i][j]|=graph[i][k]&graph[k][j];\n}\n \nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n    \n    //for(int i=0;i<node.size();i++)cout << node[i] << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    bool g[300][300];\n    for(int i=0;i<300;i++){\n      for(int j=0;j<300;j++){\n\tg[i][j]=false;\n\tgraph[i][j]=i==j?1:0; \n      }\n    }\n    \n    multimap<string,string>::iterator it=m1.begin(),it2=m1.begin();\n    \n    while(it!=m1.end()){\n      it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).sec){\n\t  g[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  g[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  g[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  g[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n\tit2++;\n      }\n      it++;\n    }\n    \n    it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n    \n    warshall_floyd(node3.size());\n    \n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO \" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint nr;\nint dfs(vvi &gg,int index,vi &used,int rc,int goal){\n\tused[index]=1;\n\tif(index==goal){\n\t\treturn rc;\n\t}\n\tREP(i,nr){\n\t\tif(gg[index][i]&&!used[i]){\n\t\t\tif(dfs(gg,i,used,gg[index][i]==2?rc:1-rc,goal)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tset<string> roads;\n\t\tvector<pair<string,string> > pairs;\n\t\tvs vroads;\n\t\tREP(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tint cur=0;\n\t\t\tstring ls;\n\t\t\tstring rs;\n\t\t\tREP(i,s.size()){\n\t\t\t\tif(s[i]=='-'){\n\t\t\t\t\tcur++;\n\t\t\t\t}else if(cur==0){\n\t\t\t\t\tls+=s[i];\n\t\t\t\t}else{\n\t\t\t\t\trs+=s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\troads.insert(ls);\n\t\t\troads.insert(rs);\n\t\t\tpairs.push_back(make_pair(ls,rs));\n\t\t}\n\t\tfor(set<string>::iterator it=roads.begin();it!=roads.end();it++){\n\t\t\tvroads.push_back(*it);\n\t\t}\n\t\tnr=vroads.size();\n\t\tvvi g(nr,vi(nr));\n\t\tREP(i,pairs.size()){\n\t\t\tint li=find(ALL(vroads),pairs[i].first)-vroads.begin();\n\t\t\tint ri=find(ALL(vroads),pairs[i].second)-vroads.begin();\n\t\t\tg[li][ri]=1;\n\t\t}\n\n\t\tvvi gg(g);\n\t\tREP(i,nr){\n\t\t\tREP(j,nr){\n\t\t\t\tbool flag=true;\n\t\t\t\tbool found=false;\n\t\t\t\tREP(k,nr){\n\t\t\t\t\tif((g[i][k]==1&&g[j][k]==1)||(g[k][i]==1&&g[k][j]==1)){\n\t\t\t\t\t\tfound=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\tfound=false;\n\t\t\t\tREP(k,nr){\n\t\t\t\t\tif((g[i][k]==1&&g[k][j]==1)||(g[j][k]==1&&g[k][i]==1)){\n\t\t\t\t\t\tfound=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(found){\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tgg[i][j]=2;\n\t\t\t\t\tgg[j][i]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tcout<<nr<<endl;\n\t\tint m;\n\t\tcin>>m;\n\t\tREP(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tint cur=0;\n\t\t\tstring ls;\n\t\t\tstring rs;\n\t\t\tREP(i,s.size()){\n\t\t\t\tif(s[i]=='-'){\n\t\t\t\t\tcur++;\n\t\t\t\t}else if(cur==0){\n\t\t\t\t\tls+=s[i];\n\t\t\t\t}else{\n\t\t\t\t\trs+=s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring ans;\n\t\t\tint li=find(ALL(vroads),ls)-vroads.begin();\n\t\t\tint ri=find(ALL(vroads),rs)-vroads.begin();\n\t\t\tif(li==vroads.size()||ri==vroads.size()){\n\t\t\t\tans=\"NO\";\n\t\t\t}else{\n\t\t\t\tvi used(nr);\n\t\t\t\tans=(dfs(gg,li,used,0,ri)?\"YES\":\"NO\");\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Pair = pair<int, int>;\n\nint N;\nint M;\nint g_idx;\nchar buf[114514];\nint par[4145];\nint myrank[4145];\nbool used[4145];\nbool isr[4145][4145];\nbool isr2[4145][4145];\n\nvector<int> vs[4145];\nvector<int> es[4145];\nvector<int> res[4145];\nvector<int> bs[4145];\nmap<string, int> mp;\n\nint root(int v) {\n  if (par[v] == v) return v;\n  return par[v] = root(par[v]);\n}\n\nvoid unite(int a, int b) {\n  a = root(a);\n  b = root(b);\n  if (a == b) return;\n  if (myrank[a] < myrank[b]) par[a] = b;\n  else if (myrank[b] < myrank[a]) par[b] = a;\n  else {\n    par[a] = b;\n    myrank[a]++;\n  }\n}\n\n\nPair GetIdx(string &s) {\n  auto itr = s.find('-');\n  string a;\n  a.assign(s, 0, itr);\n  string b;\n  b.assign(s, itr+1, s.size()-itr-1);\n  if (!mp.count(a)) mp[a] = g_idx++;\n  if (!mp.count(b)) mp[b] = g_idx++;\n  return Pair(mp[a], mp[b]);\n}\n\nvoid dfs1(int v, int k) {\n  isr[k][v] = true;\n  for (int u : es[v]) {\n    if (isr[k][u]) continue;\n    dfs1(u, k);\n  }\n}\n\nvoid dfs2(int v, int k) {\n  for (int dv : vs[root(v)]) {\n    if (isr2[k][dv]) return;\n  }\n\n  for (int dv : vs[root(v)]) {\n    isr2[k][dv] = true;\n    for (int u : es[dv]) {\n      if (isr2[k][u]) continue;\n      dfs2(u, k);\n    }\n  }\n}\n\nint dfs3(int v, int k) {\n  if (used[v]) return -1;\n  if (v == k) return 0;\n  used[v] = true;\n\n  int ret = -1;\n  for (int u : bs[v]) {\n    ret = max(ret, dfs3(u, k));\n  }\n  if (ret == -1) return -1;\n  //printf(\"%d %d: %d\\n\", v, k, ret);\n  return ret+1;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) return 0;\n\n    mp.clear();\n    g_idx = 0;\n    for (int i=0; i<N; i++) {\n      scanf(\"%s\", buf);\n      string s = buf;\n      int a, b;\n      tie(a, b) = GetIdx(s);\n      bs[a].emplace_back(b);\n      bs[b].emplace_back(a);\n      es[a].emplace_back(b);\n      res[b].emplace_back(a);\n    }\n    printf(\"%d\\n\", g_idx);\n\n    for (int i=0; i<g_idx; i++) {\n      par[i] = i;\n      myrank[i] = 0;\n      for (int j=0; j<g_idx; j++) {\n        isr[i][j] = false;\n        isr2[i][j] = false;\n      }\n    }\n\n    for (int i=0; i<g_idx; i++) {\n      dfs1(i, i);\n    }\n\n    for (int i=0; i<g_idx; i++) {\n      for (int u : es[i]) {\n        for (int v : es[i]) {\n          if (!isr[u][v] && !isr[v][u]) unite(u, v);\n        }\n      }\n\n      for (int u : res[i]) {\n        for (int v : res[i]) {\n          if (!isr[u][v] && !isr[v][u]) unite(u, v);\n        }\n      }\n    }\n\n    for (int i=0; i<g_idx; i++) {\n      vs[root(i)].emplace_back(i);\n    }\n\n    for (int i=0; i<g_idx; i++) {\n      dfs2(i, i);\n    }\n    \n    scanf(\"%d\", &M);\n    for (int i=0; i<M; i++) {\n      scanf(\"%s\", buf);\n      string s = buf;\n      int a, b;\n      tie(a, b) = GetIdx(s);\n      //for (int i=0; i<g_idx; i++) used[i] = false;\n      //printf(\"%d %d : %d\\n\", a, b, dfs3(a, b));\n      for (int i=0; i<g_idx; i++) used[i] = false;\n      if (isr2[a][b] && dfs3(a, b)%2 == 1) puts(\"YES\");\n      else puts(\"NO\");\n    }\n\n    for (int i=0; i<g_idx; i++) {\n      es[i].clear();\n      res[i].clear();\n      bs[i].clear();\n      vs[i].clear();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)n;i++)\nconst int INF = (1<<29);\n\nint n, m;\n\ntemplate<typename T>\nstruct Serializer{\n\tmap<T, int> enc;\n\tvector<T> dec;\n\tint operator()(const T &t){\n\t\tauto it = enc.find(t);\n\t\tif(it != enc.end()) return it->second;\n\t\tdec.push_back(t);\n\t\treturn enc[t] = dec.size() - 1;\n\t}\n\tsize_t size(){\n\t\treturn dec.size();\n\t}\n};\n\nint g[201][201], g2[201][201];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tSerializer<string> se;\n\t\tREP(i, 200)REP(j, 200)\n\t\t\tg[i][j] = g2[i][j] = i == j ? 0 : INF;\n\t\tREP(i, n){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tg[u][v] = 1;\n\t\t}\n\t\tn = se.size();\n\t\tREP(i, n)REP(j, n)if(g[i][j] == INF){\n\t\t\tint f = 0;\n\t\t\tREP(k, n){\n\t\t\t\tif(g[i][k] == 1 && g[k][j] == 1 || g[j][k] == 1 && g[k][i] == 1){\n\t\t\t\t\tf = 0; break;\n\t\t\t\t}\n\t\t\t\tif(g[i][k] == 1 && g[j][k] == 1 || g[k][i] == 1 && g[k][j] == 1)\n\t\t\t\t\tf = 1;\n\t\t\t}\n\t\t\tif(f) g[i][j] = 0;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tcout << n << endl;\n\t\tcin >> m;\n\t\tREP(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tif(g[u][v] & 1) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n\nmap<string,int> dict;\nmap<int,string> rdict;\nint dic(string s){\n\tif( dict.count(s) ) return dict[s];\n\telse{\n\t\tint k = dict.size();\n\t\trdict[k] = s;\n\t\treturn dict[s] = k;\n\t}\n}\n\nint info[210][210];\n\nint same[210][210];\nint muki[210];\n\nvector<int> g[210];\nvector<int> ag[210];\n\nint dfs(int x,int t){\n\tif( muki[x] != -1 ) return 0;\n\tmuki[x] = t;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tdfs(g[x][i],t^1);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tmemset(same,0,sizeof(same));\n\t\tdict.clear();\n\t\tfor(int i = 0 ; i < 210 ; i++) g[i].clear() , ag[i].clear();\n\t\tvector< pair<int,int> > v;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tv.push_back( make_pair( dic(a) , dic(b) ) );\n\t\t\tg[dic(a)].push_back(dic(b));\n\t\t\tg[dic(b)].push_back(dic(a));\n\t\t\tag[dic(a)].push_back(dic(b));\t\n\t\t\tinfo[dic(a)][dic(b)] = 1;\n\t\t}\n\t\t\n\t\tmemset(muki,-1,sizeof(muki));\n\t\tdfs(0,0);\n\t\t\n\t\tint N = dict.size();\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tif( muki[i] != muki[j] ) continue;\n\t\t\t\tint fl1 = 0 , fl2 = 1;\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( (info[j][k]||info[k][j]) && (info[i][k]||info[k][i]) ){\n\t\t\t\t\t\tfl1 = 1; // onajiyatudousi is same\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( info[k][i] && info[j][k] ) fl2 = 0;\n\t\t\t\t\tif( info[i][k] && info[k][j] ) fl2 = 0;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( fl1 && fl2 ){\n\t\t\t\t\t//cout << rdict[i] << \" \" << rdict[j] << \" \" << \"SAME\" << endl;\n\t\t\t\t\tsame[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int x = 0 ; x < m ; x++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tif( !dict.count(a) || !dict.count(b) || muki[dic(a)] == muki[dic(b)] ){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue<int> Q;\n\t\t\tQ.push(dic(a));\n\t\t\tint dn[210];\n\t\t\tmemset(dn,-1,sizeof(dn));\n\t\t\tdn[dic(a)] = 1;\n\t\t\twhile(Q.size()){\n\t\t\t\tint q = Q.front(); Q.pop();\n\t\t\t\t//cout << rdict[q] << endl;\n\t\t\t\tfor(int i = 0 ; i < ag[q].size() ; i++){\n\t\t\t\t\tif( dn[ag[q][i]] == -1 ) Q.push(ag[q][i]) , dn[ag[q][i]] = 1;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t\t\tif( same[q][i] ){\n\t\t\t\t\t\tif( dn[i] == -1 ) Q.push(i) , dn[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( dn[dic(b)] == 1){\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef string Vertex;\ntypedef pair<Vertex, Vertex> PVV;\ntypedef map <Vertex, int> Index;\n\nconst int inf = 1<<24;\nconst int size = 201;\nIndex ID;\nint N;\n\nbool F[size][size];\nbool D[size][size];\nbool W[size][size];\nint  T[size][size];\n\nvoid init() {\n    ID.clear();\n    N = 0;\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            F[i][j] = false;\n            D[i][j] = false;\n            W[i][j] = false;\n            T[i][j] = inf;\n        }\n    }\n}\n\nbool exist( Vertex v ) {\n    return ID.find(v) != ID.end();\n}\n\nvoid addVertex( Vertex v ) {\n    if ( exist( v ) ) return;\n    ID[v] = N++;\n}\n\nint getIndex( Vertex v ) {\n    return ID[v];\n}\n\nPVV input() {\n    string line;\n    cin >> line;\n    replace( line.begin(), line.end(), '-', ' ' );\n    istringstream is( line );\n    PVV answer;\n    is >> answer.first >> answer.second;\n    return answer;\n}\n\nbool solve( PVV e ) {\n    if ( !exist(e.first) || !exist(e.second) ) return false;\n    int a = getIndex( e.first );\n    int b = getIndex( e.second );\n    return W[a][b] && ( T[a][b] != inf && T[a][b]%2 );\n}\n\nbool check1( int a, int b, int c ) {\n    if ( a == b || b == c || c == a ) return false;\n    return ( F[a][c] && !F[c][a] && F[b][c] && !F[c][b] )\n        || ( F[c][a] && !F[a][c] && F[c][b] && !F[b][c] );\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        init();\n        for ( int i = 0; i < n; i++ ) {\n            PVV in = input();\n            addVertex(in.first);\n            addVertex(in.second);\n            int a = getIndex(in.first);\n            int b = getIndex(in.second);\n            F[a][b] = true;\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                for ( int k = 0; k < N; k++ ) {\n                    if ( check1( i, j, k ) ) {\n                        D[i][j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                W[i][j] = F[i][j] || D[i][j];\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    W[i][j] = W[i][j] || ( W[i][k] && W[k][j] );\n                }\n            }\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                if ( F[i][j] ) T[i][j] = 1;\n                else if ( D[i][j] ) T[i][j] = 0;\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    T[i][j] = min( T[i][j], T[i][k] + T[k][j] );\n                }\n            }\n        }\n        int m;\n        cin >> m;\n        cout << N << endl;\n        for ( int i = 0; i < m; i++ ) {\n            PVV in = input();\n            cout << ( solve( in ) ? \"YES\" : \"NO\" ) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct ID{\n  map<string, int > maker;\n  int get(string s){\n    int m = maker.size();\n    if(maker.count(s)) return maker[s];\n    else return maker[s] = m;\n  }\n  int size(){\n    return maker.size();\n  }\n};\nstruct edge{\n  int from, to, c;\n  edge () {}\n  edge(int from, int to , int c) :\n    from(from), to(to), c(c) {}\n};\ntypedef vector<edge> edges;\nbool used[500];\nbool dfs(vector<edges>& G, int u, int v, int c, int t){\n  if(u == v){\n    if(c < 0 && t == 1) return true;\n    else return false;\n  }\n  used[u] = true;\n  FORIT(it, G[u])if(!used[it->to]){\n    if(dfs(G, it->to, v, c + it->c, t ^ 1)) return true;\n  }\n  return false;\n}\nint main(){\n  int N;\n  while(cin>>N && N){\n    vector<string> crossing(N);\n    REP(i, N) cin>>crossing[i];\n    ID id;\n    vector<edges> G(500);\n    REP(i, N){\n      string cross = crossing[i];\n      int a, b;\n      REP(i, cross.size())if(cross[i] == '-'){\n        a = id.get(cross.substr(0, i));\n        b = id.get(cross.substr(i+1));\n      }\n      G[a].push_back(edge(a, b, -1));\n      G[b].push_back(edge(b, a, +1));\n    }\n    cout<<id.size()<<endl;\n    int M; cin>>M;\n    REP(i, M){\n      string cross;\n      cin>>cross;\n      int a, b;\n      REP(i, cross.size())if(cross[i] == '-'){\n        a = id.get(cross.substr(0, i));\n        b = id.get(cross.substr(i+1));\n      }\n      memset(used, 0, sizeof(used));\n      if(dfs(G, a, b, 0, 0)) cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <assert.h>\n#include <iomanip>\n#include <bitset>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define IS_BIT_ON(bit, i) (bit & (1 << i))\n#define BIT_ON(bit, i) (bit |= (1 << i))\n#define BIT_OFF(bit, i) (bit &= ~(1 << i))\n#define BIT_COUNT(bit) (__builtin_popcount(bit))\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\nvoid print() { std::cout << std::endl; }\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) { std::cout << head; if (sizeof...(tail) != 0) {std::cout << \" \";} print(std::forward<Tail>(tail)...); }\ntemplate <class T> void print(std::vector<T> &v) {for (auto& a : v) { std::cout << a; if (&a != &v.back()) {std::cout << \" \";} }std::cout << std::endl;}\ntemplate <class T> void print(std::vector<std::vector<T>> &vv) { for (auto& v : vv) { print(v); }}\ninline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\n// 2のべき乗数かどうか\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\n// aとbの最大公約数 O(log min(a, b))\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\n// 数列vの最大公約数 O(N log d)\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < (int)v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\n// aとbの最小公倍数 O(log min(a, b))\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1u << 30u;\nconst long long LINF = 1ull << 58u;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下\nconst std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};    // 右，下，左，上\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n// strをdelimiterで分割する\nvector<string> split(const string &str, const string &delimiter) {\n    vector<string> res;\n    size_t current = 0, found, delimlen = delimiter.size();\n    while ((found = str.find(delimiter, current)) != string::npos) {\n        res.emplace_back(string(str, current, found - current));\n        current = found + delimlen;\n    }\n    res.emplace_back(string(str, current, str.size() - current));\n    return res;\n}\n\nclass Edge {\npublic:\n    const int no = 0;\n    const int from = 0;\n    const int to = 0;\n    const long long weight = 0;\n\n    Edge(int no, int from, int to, long long weight) : no(no), from(from), to(to), weight(weight) {\n    }\n\n};\n\nclass Graph {\npublic:\n    const int N;    // ノード数\n    int M = 0;      // エッジ数\n    std::vector<std::vector<Edge>> graph;\n    Graph(int N) : N(N) {\n        this->graph.resize(N);\n    }\n\n    void add_undirected_edge(const int no, const int u, const int v, const long long w) {\n        this->graph.at(u).emplace_back(Edge(no, u, v, w));\n        this->graph.at(v).emplace_back(Edge(no, v, u, w));\n        this->M++;\n    }\n\n    void add_directed_edge(const int no, const int from, const int to, const long long w) {\n        this->graph.at(from).emplace_back(Edge(no, from, to, w));\n        this->M++;\n    }\n\n    std::vector<Edge> &operator[](const int u) {\n        return this->graph[u];\n    }\n\n    std::vector<std::vector<long long>> make_matrix_graph() {\n        std::vector<std::vector<long long>> matrix(this->N, std::vector<long long>(this->N, INT_MAX));\n        for (const auto &v : this->graph) {\n            for (const auto &e : v) {\n                matrix[e.from][e.to] = e.weight;\n            }\n        }\n        return matrix;\n    }\n\n    // mode 0: undirected edge\n    // mode 1: directed edge\n    void show(int mode = 0) {\n        std::cout << this->M << std::endl;\n        for (const auto &v : this->graph) {\n            for (const auto &e : v) {\n                if (mode == 0) {\n                    if (e.from < e.to) {\n                        std::cout << e.from << \" \" << e.to << std::endl;\n                    }\n                }\n                else {\n                    std::cout << e.from << \" \" << e.to << std::endl;\n                }\n            }\n        }\n    }\n};\n\nvoid dfs(int u, int i, const int base, vector<int> &color, Graph &graph) {\n    color[u] = base + (i % 2);\n    FOE(e, graph[u]) {\n        if (color[e.to] == -1) {\n            dfs(e.to, i + 1, base, color, graph);\n        }\n    }\n}\n\n/**\n * 全ノード間の最短距離をもとめる\n * matrix[i][j]には辺e=(i,j)のコスト(辺が存在しない場合はINF)\n * 負の閉路がある場合は空を返す\n * O(|V|^3)\n */\nstd::vector<std::vector<int>> warshall_floyd(std::vector<std::vector<int>> matrix) {\n    const unsigned long num_node = matrix.size();\n\n    // 自分の距離は0\n    for (int i = 0; i < num_node; ++i) {\n        matrix.at(i).at(i) = 0;\n    }\n\n    for (int m = 0; m < num_node; ++m) {\n        for (int s = 0; s < num_node; ++s) {\n            for (int e = 0; e < num_node; ++e) {\n                // sからeへmを経由して到達可能\n                if (matrix.at(s).at(m) != INF and matrix.at(m).at(e) != INF) {\n                    matrix.at(s).at(e) = std::min(matrix.at(s).at(e), matrix.at(s).at(m) + matrix.at(m).at(e));\n                }\n            }\n        }\n    }\n\n    // 負閉路チェック\n    for (int u = 0; u < num_node; ++u) {\n        if (matrix.at(u).at(u) < 0) {\n            return {};\n        }\n    }\n\n    return matrix;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        LL N;\n        cin >> N;\n\n        if (N == 0) {\n            return 0;\n        }\n\n        int no = 0;\n        unordered_map<string, int> name_no;\n        vector<pair<int, int>> edges;\n        FOR(i, 0, N) {\n            string S;\n            cin >> S;\n            auto p = split(S, \"-\");\n            string a = p[0];\n            string b = p[1];\n\n            if (name_no.find(a) == name_no.end()) {\n                name_no[a] = no;\n                no++;\n            }\n\n            if (name_no.find(b) == name_no.end()) {\n                name_no[b] = no;\n                no++;\n            }\n            edges.emplace_back(make_pair(name_no[a], name_no[b]));\n        }\n\n        Graph graph(no);\n        auto g = make_v<int>(no, no);\n        std::vector<std::vector<int>> matrix(no, vector<int>(no, INF));\n        FOE(p, edges) {\n            graph.add_undirected_edge(0, p.first, p.second, 1);\n\n            g[p.first][p.second] = 1;\n            g[p.second][p.first] = 2;\n            matrix[p.first][p.second] = 1;\n        }\n\n        auto color = make_v<int>(no);\n        fill_v(color, -1);\n        int base = 0;\n        FOR(i, 0, no) {\n            if (color[i] == -1) {\n                dfs(i, 0, base, color, graph);\n                base += 4;\n            }\n        }\n\n        FOR(a, 0, no) {\n            FOR(b, a + 1, no) {\n\n                bool found1 = false, found2 = false, found3 = false;\n                FOR(c, 0, no) {\n                    if (a == b or a == c or b == c) {\n                        continue;\n                    }\n\n                    if (g[a][c] and g[b][c]) {\n                        found1 = true;\n                    }\n\n                    if (g[c][a] == 1 and g[b][c] == 1) {\n                        found2 = true;\n                    }\n\n                    if (g[a][c] == 1 and g[c][b] == 1) {\n                        found3 = true;\n                    }\n                }\n\n                if (found1 and not found2 and not found3) {\n                    matrix[a][b] = 1;\n                    matrix[b][a] = 1;\n                }\n            }\n        }\n\n        auto cost = warshall_floyd(matrix);\n\n        print(no);\n        LL M;\n        cin >> M;\n        FOR(i, 0, M) {\n            string S;\n            cin >> S;\n            auto p = split(S, \"-\");\n            string a = p[0];\n            string b = p[1];\n\n            if (name_no.find(a) == name_no.end()) {\n                print(\"NO\");\n                continue;\n            }\n\n            if (name_no.find(b) == name_no.end()) {\n                print(\"NO\");\n                continue;\n            }\n\n            int u = name_no[a];\n            int v = name_no[b];\n\n            if (abs(color[u] - color[v]) != 1) {\n                print(\"NO\");\n                continue;\n            }\n\n            if (cost[u][v] != INF) {\n                print(\"YES\");\n            }\n            else {\n                print(\"NO\");\n            }\n\n        }\n\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n \nusing namespace std;\n \nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n \nbool eq_str(const string& p,const string& q){ p==q; }\n \nmultimap<string,string>m1,m2;\nmap<string,int>color;\n \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n \nint graph[300][300];\n \nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n    graph[i][j]|=graph[i][k]&graph[k][j];\n}\n \nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n    \n    for(int i=0;i<node.size();i++)cout << node[i] << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    for(int i=0;i<300;i++)\n      for(int j=0;j<300;j++)graph[i][j]=i==j?1:0;\n    \n    bool g[300][300];\n    for(int i=0;i<300;i++)\n      for(int j=0;j<300;j++)g[i][j]=false;\n    \n    multimap<string,string>::iterator it=m1.begin(),it2=m1.begin();\n    \n    for(it=m1.begin();it!=m1.end();it++){\n      for(it2=m1.begin();it2!=m1.end();it2++){\n\tif(it==it2)continue;\n\t\n\tif((*it).fst==(*it2).sec){\n\t  graph[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  graph[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  graph[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  graph[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n      }\n    }\n    \n  \n    for(it=m1.begin();it!=m1.end();it++){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      for(it2=m1.begin();it2!=m1.end();it2++){\n\tif(it==it2)continue;\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n    }\n    \n    warshall_floyd(node3.size());\n    \n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO \" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n  \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n  \nusing namespace std;\n\nmultimap<string,string>m1,m2;\nmap<string,int>color;\nint graph[200][200];\n\nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n  \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n\nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n    \n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    bool g[200][200];\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tg[i][j]=false;\n\tgraph[i][j]=i==j?1:0; \n      }\n    }\n    \n    multimap<string,string>::iterator it,it2;\n    \n    for(it=m1.begin();it!=m1.end();it++){\n      for(it2=m1.begin();it2!=m1.end();it2++){\n\tif(it==it2)continue;\n\n\tif((*it).fst==(*it2).sec){\n\t  g[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  g[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  g[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  g[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n      }\n    }\n    \n    for(it=m1.begin();it!=m1.end();it++){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n        \n      for(it2=m1.begin();it2!=m1.end();it2++){\n\tif(it==it2)continue;\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n      }\n    }\n\n    for(int k=0;k<node3.size();k++)\n      for(int i=0;i<node3.size();i++)\n\tfor(int j=0;j<node3.size();j++)\n\tgraph[i][j]|=graph[i][k]&graph[k][j];\n\n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nstruct Manager{\n  map<string, int> m;\n  int size(){\n    return m.size();\n  }\n  int get_id(string s){\n    if(m.count(s)) return m[s];\n    int id = m.size();\n    return m[s] = id;\n  }\n};\n\nstruct Edge{\n  int to, cost;\n  Edge(int a, int b) : to(a), cost(b) {}\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    Manager manager;\n    bool exist[300][300] = {};\n    REP(i, N){\n      string s;\n      cin >> s;\n      string t1, t2;\n      REP(i, s.size()) if(s[i] == '-') t1 = s.substr(0, i), t2 = s.substr(i + 1);\n      int x = manager.get_id(string(t1));\n      int y = manager.get_id(string(t2));\n      exist[x][y] = true;\n    }\n    int L = manager.size();\n    cout << L << endl;\n    Graph G(L);\n    REP(i, L) REP(j, L) if(i != j) {\n      bool ok = false;\n      REP(k, L) if(exist[i][k] && exist[j][k]) ok = true;\n      REP(k, L) if(exist[k][i] && exist[k][j]) ok = true;\n      REP(k, L) if(exist[i][k] && exist[k][j]) ok = false;\n      REP(k, L) if(exist[k][i] && exist[j][k]) ok = false;\n      if(ok){\n        assert(!exist[i][j]);\n        G[i].push_back(Edge(j, 0));\n      }else if(exist[i][j]){\n        G[i].push_back(Edge(j, 1));\n      }\n    }\n    int M;\n    cin >> M;\n    REP(_, M){\n      string s;\n      cin >> s;\n      string t1, t2;\n      REP(i, s.size()) if(s[i] == '-') t1 = s.substr(0, i), t2 = s.substr(i + 1);\n      int x = manager.get_id(string(t1));\n      int y = manager.get_id(string(t2));\n      if(x >= L || y >= L){\n        cout << \"NO\" << endl;\n        continue;\n      }\n      queue<int> que;\n      int dist[300] = {};\n      memset(dist, -1, sizeof dist);\n      que.push(x);\n      dist[x] = 0;\n      while(!que.empty()){\n        int u = que.front(); que.pop();\n        REP(i, G[u].size()){\n          int v = G[u][i].to;\n          int d = dist[u] + G[u][i].cost;\n          if(dist[v] == -1 || dist[v] > d){\n            dist[v] = d;\n            que.push(v);\n          }\n        }\n      }\n      if(dist[y] > 0 && dist[y] % 2 == 1){\n        cout << \"YES\" << endl;\n      }else{\n        cout << \"NO\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) ((int)(a).size())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nint n;\nmap<string, int> memo;\nvector<string> mstr;\nint get(string a){\n  if(memo.count(a))\n    return memo[a];\n  int sz = SZ(memo);\n  mstr.pb(a);\n  return memo[a] = sz;\n}\n\nvector<PI> G[2000];\nint vis[2000];\nint vcnt;\nbool app[2000][2000];\n\nvector<int> cG[2000];\n\nvoid solve(){\n  memo.clear();\n  mstr.clear();\n  rep(i, n*2) G[i].clear();\n  rep(i, n*2) cG[i].clear();\n  \n  set<PI> input;\n  rep(i, n){\n    string a, b;\n    cin >> a;\n    a[a.find('-')] = ' ';\n    stringstream ss(a);\n    ss >> a >> b;\n    int u = get(a);\n    int v = get(b);\n    G[u].pb(mp(v,1));\n    cG[u].pb(v);\n    cG[v].pb(u);\n    input.insert(mp(u, v));\n  }\n  \n  \n  cout << SZ(memo) << endl;\n  rep(i, SZ(memo)) rep(j, SZ(memo)) app[i][j] = 0;\n  for(auto e : input) app[e.F][e.S] = 1;\n  \n  rep(d, SZ(memo)){\n    sort(ALL(cG[d]));\n    cG[d].erase(unique(ALL(cG[d])), cG[d].end());\n\n\n    for(auto a : cG[d]) for(auto b : cG[d]){\n        if(a == b) break;\n        if(app[a][d] && app[d][b]) continue;\n        if(app[b][d] && app[d][a]) continue;\n        G[a].pb(mp(b,0));\n        G[b].pb(mp(a,0));\n      }\n  }\n\n  rep(d, SZ(memo)){\n    sort(ALL(G[d]));\n    G[d].erase(unique(ALL(G[d])), G[d].end());\n  }\n  \n  // rep(d, SZ(memo)){\n  //   cout << mstr[d] << \": \";\n  //   for(auto e : G[d])\n  //     cout << mstr[e.F] << \",\";\n  //   cout << endl;\n  // }\n  \n  int q;\n  cin >> q;\n  rep(i, q){\n    string a, b;\n    cin >> a;\n    a[a.find('-')] = ' ';\n    stringstream ss(a);\n    ss >> a >> b;\n    \n    if(memo.count(a) && memo.count(b));\n    else{\n      cout << \"NO\" << endl;\n      continue;\n    }\n    \n    int u = get(a);\n    int v = get(b);\n    queue<PI> q;\n    q.push(mp(u,0));\n    \n    bool ok = false;\n    ++vcnt;\n    while(!q.empty()){\n      int cv = q.front().F;\n      int cc = q.front().S;\n      q.pop();\n      if(cv == v){\n        //cout << \"cc \" << cc << endl;\n        ok = cc & 1;\n        break;\n      }\n      if(vis[cv] == vcnt) continue;\n      //cout << mstr[cv] << endl;\n      vis[cv] = vcnt;\n      for(auto e : G[cv])\n        if(vis[e.F] != vcnt)\n          q.push(mp(e.F, cc+e.S));\n    }\n    \n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint N, M;\nint G[205][205];\nmap<string, int> mp;\nvector<int> g[205];\nint V;\nbool used[205];\nint color[205];\n\nbool dfs(int v, int t)\n{\n\tused[v] = true;\n\tif(v == t) return true;\n\t\n\tbool ret = false;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(used[g[v][i]]) continue;\n\t\tret |= dfs(g[v][i], t);\n\t}\n\treturn ret;\n}\n\nvoid color_dfs(int v, int c)\n{\n\tcolor[v] = c;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(color[g[v][i]]) continue;\n\t\tcolor_dfs(g[v][i], -c);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(int i = 1; i <= 200; i++){\n\t\t\tfor(int j = 1; j <= 200; j++){\n\t\t\t\tG[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint id = 1;\n\t\tstring s, t;\n\t\tmp.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0) mp[s] = id++;\n\t\t\tif(mp.count(t) == 0) mp[t] = id++;\n\t\t\tG[mp[s]][mp[t]] = 1;\n\t\t}\n\t\tV = id-1;\n\t\tcout << V << endl;\n\t\t\n\t\tfor(int i = 1; i <= V; i++) g[i].clear();\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]){\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t\tg[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++) color[i] = 0;\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tif(!color[i]) color_dfs(i, 1);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tint prev = 0, front = 0;\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j] == 1){\n\t\t\t\t\tif(prev == 0) front = j;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[prev][j] == 0) G[prev][j] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tprev = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev != front) if(G[prev][front] == 0) G[prev][front] = 2;\n\t\t}\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tint prev = 0, front = 0;\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[j][i] == 1){\n\t\t\t\t\tif(prev == 0) front = j;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[prev][j] == 0) G[prev][j] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tprev = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev != front) if(G[prev][front] == 0) G[prev][front] = 2;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tg[i].clear();\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]) g[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0 || mp.count(t) == 0){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint S = mp[s], T = mp[t];\n\t\t\t\n\t\t\tif(color[S] == color[T]){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i <= V; i++) used[i] = false;\n\t\t\tif(dfs(S, T)) cout << \"YES\" << endl;\n\t\t\telse cout << \"NO\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\treturn vs{ l,r };\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n, q;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p, INF));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[l][r] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f = false;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k]==1 && dist[j][k]==1) || (dist[k][i]==1 && dist[k][j]==1)) f = true;\n\t\t\t\tif ((dist[i][k]==1 && dist[k][j]==1) || (dist[k][i]==1 && dist[j][k]==1))\n\t\t\t\t{\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p) chmin(dist[i][j], dist[i][k] + dist[k][j]);\n\t\tvi color(p, -1);\n\t\tint col = 0;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i] != -1) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = col + 1;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to] != -1) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol += 2;\n\t\t}\n\t\tcout << p << endl;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif ((color[l] != color[r] && color[l] / 2 == color[r] / 2) && dist[l][r] != INF)\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nint v=0;\nmap<string,int> nameToVertex;\n\nbool cGraph[202][202];\nbool eGraph[202][202];\nbool visited[202];\n\nint N,M;\n\nstring buf;\n\nvoid buildE(){\n    for(int i=0;i<v;i++){\n        for(int j=i+1;j<v;j++){\n            bool comm=false,order=false;\n            for(int k=0;k<v;k++){\n                if (i==k||j==k) continue;\n                comm |= (cGraph[i][k]||cGraph[k][i])&&(cGraph[j][k]||cGraph[k][j]);\n                order |= (cGraph[i][k]&&cGraph[k][j])||(cGraph[j][k]&&cGraph[k][i]);\n            }\n            if (comm&&!order) eGraph[i][j]=eGraph[j][i]=true;\n        }\n    }\n}\n\nbool DFS1(int cur,int target,bool d){\n    if (cur==target) return d;\n    visited[cur]=true;\n    for(int i=0;i<v;i++){\n        if (visited[i]) continue;\n        if ((cGraph[cur][i]||cGraph[i][cur])&&DFS1(i,target,!d)) return true;\n    }\n    return false;\n}\n\nbool DFS2(int cur,int target){\n    if (cur==target) return true;\n    visited[cur]=true;\n    for(int i=0;i<v;i++){\n        if (visited[i]) continue;\n        if ((cGraph[cur][i]||eGraph[cur][i])&&DFS2(i,target)) return true;\n    }\n    return false;\n}\n\n\nint main(){\n\n    while(true){\n        cin>>N;\n        if (!N) break;\n\n        for(int i=0;i<v;i++) \n            for(int j=0;j<v;j++)\n                cGraph[i][j]=false,eGraph[i][j]=false;\n        \n        nameToVertex.clear();\n        v=0;\n\n        for(int k=0;k<N;k++) {\n            cin>>buf;\n            int i=0;\n            while(buf[i]!='-') i++;\n            auto fst=buf.substr(0,i);\n            auto snd=buf.substr(i+1);\n\n            if(!nameToVertex.count(fst)) \n                nameToVertex[fst]=v++;\n            \n\n            if(!nameToVertex.count(snd)) \n                nameToVertex[snd]=v++;\n            \n\n            auto fstNum=nameToVertex[fst],sndNum=nameToVertex[snd];\n            cGraph[fstNum][sndNum]=true;\n        }\n\n        buildE();\n\n        cin>>M;\n        cout<<v<<endl;\n\n        for(int k=0;k<M;k++) {\n            cin>>buf;\n            int i=0;\n            while(buf[i]!='-') i++;\n            auto fst=buf.substr(0,i);\n            auto snd=buf.substr(i+1);\n\n            if (!nameToVertex.count(fst)||!nameToVertex.count(snd)){\n                puts(\"NO\");\n                continue;\n            }\n\n            auto fstNum=nameToVertex[fst],sndNum=nameToVertex[snd];\n            \n            for(int i=0;i<v;i++) visited[i]=false;\n            if (!DFS1(fstNum,sndNum,false)){\n                puts(\"NO\");\n                continue;\n            }\n\n            for(int i=0;i<v;i++) visited[i]=false;\n\n            if (DFS2(fstNum,sndNum)) puts(\"YES\");\n            else puts(\"NO\");\n            \n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef string Vertex;\ntypedef pair<Vertex, Vertex> PVV;\ntypedef map <Vertex, int> Index;\n\nconst int inf = 1<<24;\nconst int size = 201;\nIndex ID;\nint N;\n\nbool F[size][size];\nbool D[size][size];\nbool W[size][size];\nint  T[size][size];\n\nvoid init() {\n    ID.clear();\n    N = 0;\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            F[i][j] = false;\n            D[i][j] = false;\n            W[i][j] = false;\n            T[i][j] = inf;\n        }\n    }\n}\n\nbool exist( Vertex v ) {\n    return ID.find(v) != ID.end();\n}\n\nvoid addVertex( Vertex v ) {\n    if ( exist( v ) ) return;\n    ID[v] = N++;\n}\n\nint getIndex( Vertex v ) {\n    return ID[v];\n}\n\nPVV input() {\n    string line;\n    cin >> line;\n    replace( line.begin(), line.end(), '-', ' ' );\n    istringstream is( line );\n    PVV answer;\n    is >> answer.first >> answer.second;\n    return answer;\n}\n\nbool solve( PVV e ) {\n    if ( !exist(e.first) || !exist(e.second) ) return false;\n    int a = getIndex( e.first );\n    int b = getIndex( e.second );\n    return W[a][b] && ( T[a][b] != inf && T[a][b]%2 );\n}\n\nbool check1( int a, int b, int c ) {\n    if ( a == b || b == c || c == a ) return false;\n    if ( ( F[a][c] && F[b][c] ) || ( F[c][a] && F[c][b] ) ) {\n        if ( ( !F[a][c] || !F[c][b] ) && ( !F[c][a] || !F[b][c] ) ) return true; \n    }\n    return false;\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        init();\n        for ( int i = 0; i < n; i++ ) {\n            PVV in = input();\n            addVertex(in.first);\n            addVertex(in.second);\n            int a = getIndex(in.first);\n            int b = getIndex(in.second);\n            F[a][b] = true;\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                for ( int k = 0; k < N; k++ ) {\n                    if ( check1( i, j, k ) ) {\n                        D[i][j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                W[i][j] = F[i][j] || D[i][j];\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    W[i][j] = W[i][j] || ( W[i][k] && W[k][j] );\n                }\n            }\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                if ( F[i][j] ) T[i][j] = 1;\n                else if ( D[i][j] ) T[i][j] = T[j][i] = 0;\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    T[i][j] = min( T[i][j], T[i][k] + T[k][j] );\n                }\n            }\n        }\n        int m;\n        cin >> m;\n        cout << N << endl;\n        for ( int i = 0; i < m; i++ ) {\n            PVV in = input();\n            cout << ( solve( in ) ? \"YES\" : \"NO\" ) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nchar in[50];\nchar L[50];\nchar R[50];\nint p[50];\nint q[50];\nint UF[500];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint g[210][210];\nint g2[210][210];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<string,int>m;\n\t\tint n=0;\n\t\tfor(int i=0;i<500;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tint at=0;\n\t\t\tint j;\n\t\t\tfor(j=0;in[j]!='-';j++){\n\t\t\t\tL[at]=in[j];at++;\n\t\t\t}L[at]=0;\n\t\t\tat=0;\n\t\t\tj++;\n\t\t\tfor(;in[j];j++){\n\t\t\t\tR[at]=in[j];at++;\n\t\t\t}R[at]=0;\n\t//\t\tprintf(\"%s %s\\n\",L,R);\n\t\t\tstring l=L;\n\t\t\tstring r=R;\n\t\t\tif(m.count(l))p[i]=m[l];\n\t\t\telse{\n\t\t\t\tm[l]=n;\n\t\t\t\tp[i]=n++;\n\t\t\t}\n\t\t\tif(m.count(r)){\n\t\t\t\tq[i]=m[r];\n\t\t\t}else{\n\t\t\t\tm[r]=n;q[i]=n++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[p[i]][q[i]]=1;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)g2[i][j]=0;\n\t\tfor(int i=0;i<n;i++)g2[i][i]=1;\n\t\tfor(int i=0;i<a;i++)g2[p[i]][q[i]]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tbool ok1=false;\n\t\t\t\tbool ok2=true;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(g[i][k]&&g[j][k])ok1=true;\n\t\t\t\t\tif(g[k][i]&&g[k][j])ok1=true;\n\t\t\t\t\tif(g[i][k]&&g[k][j])ok2=false;\n\t\t\t\t\tif(g[j][k]&&g[k][i])ok2=false;\n\t\t\t\t}\n\t\t\t\tif(ok1&&ok2)g2[i][j]=g2[j][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)\n\t\t\tg2[i][j]|=g2[i][k]&g2[k][j];\n\t\tprintf(\"%d\\n\",n);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tUNION(p[i]*2,q[i]*2+1);UNION(p[i]*2+1,q[i]*2);\n\t\t}\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tint at=0;int j;\n\t\t\tfor(j=0;in[j]!='-';j++){\n\t\t\t\tL[at]=in[j];at++;\n\t\t\t}L[at]=0;\n\t\t\tat=0;\n\t\t\tj++;\n\t\t\tfor(;in[j];j++){\n\t\t\t\tR[at]=in[j];at++;\n\t\t\t}R[at]=0;\n\t\t\tstring l=L;string r=R;\n\t\t\tif(!m.count(l)||!m.count(r)){printf(\"NO\\n\");continue;}\n\t\t\tint P=m[l];\n\t\t\tint Q=m[r];\n\t\t\tif(FIND(P*2)!=FIND(Q*2+1)||FIND(P*2+1)!=FIND(Q*2)){printf(\"NO\\n\");continue;}\n\t\t\tif(g2[P][Q])printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 25;\npair<string, string> cross[1000];\nint dist[200][200];\nint wf[200][200];\nint same[200][200];\n\nint main() {\n\tint n, m;\n\twhile(cin >> n, n) {\n\t\tint sn = 0;\n\t\tmap<string, int> indexer;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tstring s, s1, s2;\n\t\t\tcin >> s;\n\t\t\tint pos = s.find('-');\n\t\t\ts1 = s.substr(0, pos);\n\t\t\ts2 = s.substr(pos + 1, s.size() - (pos + 1));\n\t\t\tcross[i].first = s1;\n\t\t\tcross[i].second = s2;\n\t\t\tif(indexer.count(s1) == 0) {\n\t\t\t\tindexer[s1] = sn++;\n\t\t\t}\n\t\t\tif(indexer.count(s2) == 0) {\n\t\t\t\tindexer[s2] = sn++;\n\t\t\t}\n\t\t}\n\n\t\tcout << sn << endl;\n\n\t\tfor(int i = 0; i < sn; i++) {\n\t\t\tfor(int j = 0; j < sn; j++) {\n\t\t\t\tdist[i][j] = (i == j) ? 0 : INF;\n\t\t\t\tsame[i][j] = wf[i][j] = i == j;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint v1 = indexer[cross[i].first], v2 = indexer[cross[i].second];\n\t\t\tdist[v1][v2] = dist[v2][v1] = 1;\n\t\t\twf[v1][v2] = 1;\n\t\t}\n\n\t\tfor(int i = 0; i < sn; i++) {\n\t\t\tfor(int j = i + 1; j < sn; j++) {\n\t\t\t\tbool flag1 = false, flag2 = true;\n\t\t\t\tfor(int k = 0; k < sn; k++) {\n\t\t\t\t\tif(wf[i][k] && wf[j][k]) flag1 = true;\n\t\t\t\t\tif(wf[k][i] && wf[k][j]) flag1 = true;\n\t\t\t\t\tif(wf[i][k] && wf[k][j]) flag2 = false;\n\t\t\t\t\tif(wf[j][k] && wf[k][i]) flag2 = false;\n\t\t\t\t}\n\t\t\t\tsame[i][j] = same[j][i] = flag1 && flag2;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < sn; i++) {\n\t\t\tfor(int j = 0; j < sn; j++) {\n\t\t\t\tif(same[i][j]) wf[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < sn; k++) {\n\t\t\tfor(int i = 0; i < sn; i++) {\n\t\t\t\tfor(int j = 0; j < sn; j++) {\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t\twf[i][j] |= wf[i][k] && wf[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> m;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tstring s, s1, s2;\n\t\t\tcin >> s;\n\t\t\tint pos = s.find('-');\n\t\t\ts1 = s.substr(0, pos);\n\t\t\ts2 = s.substr(pos + 1, s.size() - (pos + 1));\n\t\t\tif(indexer.count(s1) == 0 || indexer.count(s2) == 0) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint v1 = indexer[s1], v2 = indexer[s2];\n\t\t\tint d = dist[v1][v2];\n\t\t\tif(d != INF && d % 2 && wf[v1][v2]) {\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint matrix[200][200] = { { 0 } };\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){ break; }\n\t\tfor(int i = 0; i < 200; ++i){\n\t\t\tfor(int j = 0; j < 200; ++j){ matrix[i][j] = 1000; }\n\t\t}\n\t\tmap<string, int> names;\n\t\twhile(N--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tif(names.find(a) == names.end()){\n\t\t\t\tnames.insert(make_pair(a, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tif(names.find(b) == names.end()){\n\t\t\t\tnames.insert(make_pair(b, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tmatrix[ai][bi] = 1;\n\t\t}\n\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\tif(matrix[i][j] < 1000 || matrix[j][i] < 1000){ continue; }\n\t\t\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\t\t\tif(matrix[i][k] == 1 && matrix[j][k] == 1){\n\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(matrix[k][i] == 1 && matrix[k][j] == 1){\n\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint M;\n\t\tcin >> M;\n\t\twhile(M--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tif(matrix[ai][bi] < 1000){\n\t\t\t\tcout << (matrix[ai][bi] % 2 == 1 ? \"YES\" : \"NO\") << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<string,int> M;\n\nint str2int(string S){\n    if(M.find(S)==M.end()){\n        int n = M.size();\n        M[S]=n;\n    }\n    return M[S];\n}\n\nint E[200][200];//[a][b]=a to b\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        fill(E[0],E[200],100000000);\n        M.clear();\n        for(int i=0;i<N;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    E[i1][i2]=1;\n                    break;\n                }\n            }\n        }\n        int m = M.size();\n        cout<<m<<endl;\n        for(int i=0;i<m;i++){\n            for(int j=i+1;j<m;j++){\n                //cond1\n                bool b=false;\n                for(int k=0;k<m;k++){\n                    if((E[i][k]==1||E[k][i]==1)&&(E[j][k]==1||E[k][j]==1)){\n                        b=true;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                //cond2,3\n                for(int k=0;k<m;k++){\n                    if((E[k][i]==1&&E[j][k]==1)||(E[i][k]==1&&E[k][j]==1)){\n                        b=false;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                E[i][j]=E[j][i]=2;\n            }\n        }\n        //WF\n        for(int i=0;i<m;i++) E[i][i]=0;\n        for(int k=0;k<m;k++){\n            for(int i=0;i<m;i++){\n                for(int j=0;j<m;j++){\n                    E[i][j]=min(E[i][j],E[i][k]+E[k][j]);\n                }\n            }\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    if(E[i1][i2]%2==0){\n                        cout<<\"NO\"<<endl;\n                    }else{\n                        cout<<\"YES\"<<endl;\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\n//bool dfs(const vvi& g1,const vvi& g2,int u,int c,vi& color)\n//{\n//\tif(color[u]!=-1) return color[u]!=c;\n//\tcolor[u]=c;\n//\tfor(int v:g1[u]) if(!dfs(g1,g2,v,!c,color)) return false;\n//\tfor(int v:g2[u]) if(!dfs(g1,g2,v,!c,color)) return false;\n//\treturn true;\n//}\nint dist(const vvi& g1,const vvi& g2,int u,int v)\n{\n\tvi vis(g1.size());\n\tqueue<pii> q; q.emplace(u,0);\n\twhile(q.size()){\n\t\tint x,d; tie(x,d)=q.front(); q.pop();\n\t\tif(vis[x]) continue;\n\t\tvis[x]=1;\n\t\tif(x==v) return d;\n\t\tfor(int y:g1[x]) q.emplace(y,d+1);\n\t\tfor(int y:g2[x]) q.emplace(y,d+1);\n\t}\n\treturn INF;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tcin.ignore();\n\t\t\n\t\tmap<string,int> f;\n\t\tvector<pii> es;\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tgetline(cin,s,'-');\n\t\t\tf.insert(mp(s,f.size()));\n\t\t\tint u=f[s];\n\t\t\tgetline(cin,s);\n\t\t\tf.insert(mp(s,f.size()));\n\t\t\tint v=f[s];\n\t\t\tes.emplace_back(u,v);\n\t\t}\n\t\t\n\t\tn=f.size();\n\t\tvvi g1(n,vi(n));\n\t\tfor(auto e:es){\n\t\t\tint u,v; tie(u,v)=e;\n\t\t\tg1[u][v]=1;\n\t\t}\n\t\t\n\t\tvvi g(n,vi(n,INF));\n\t\trep(i,n) rep(j,n){\n\t\t\trep(k,n) if((g1[i][k]||g1[k][i])&&(g1[j][k]||g1[k][j]))\n\t\t\t\tg[i][j]=0;\n\t\t\trep(k,n) if((g1[i][k]&&g1[k][j])||(g1[j][k]&&g1[k][i]))\n\t\t\t\tg[i][j]=INF;\n\t\t}\n\t\trep(i,n) rep(j,n) if(g1[i][j]) g[i][j]=1;\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\t\n\t\tcout<<n<<endl;\n\t\t\n\t\tint m; cin>>m;\n\t\tcin.ignore();\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tgetline(cin,s,'-');\n\t\t\tint u=f.count(s)?f[s]:-1;\n\t\t\tgetline(cin,s);\n\t\t\tint v=f.count(s)?f[s]:-1;\n\t\t\t\n\t\t\tif(u==-1 || v==-1)\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\telse\n\t\t\t\tcout<<(g[u][v]%2?\"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2004à\\IF : Name the Crossing\n\n#include <iostream>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nint c[200][200];\n\n// ¯ÌÊèð`FbN\nbool check(int A, int B, int size){\n\tbool flag = false;\n\tfor(int i=0;i<size;i++){\n\t\tif(i==A||i==B) continue;\n\t\tif(c[i][A]==1&&c[i][B]==1) flag = true;\n\t\tif(c[i][A]==1&&c[B][i]==1) return false;\n\t\tif(c[A][i]==1&&c[i][B]==1) return false;\n\t\tif(c[A][i]==1&&c[B][i]==1) flag = true;\n\t}\n\treturn flag;\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n, n){\n\t\t// Ot(×Úsñ)Ìú»\n\t\tfor(int i=0;i<200;i++)\n\t\t\tfor(int j=0;j<200;j++) c[i][j] = 1000000;\n\t\t// ÊèÌ¼OÆÔðÎt¯émap\n\t\tmap<string, int> mp;\n\t\tint size = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring name; cin >> name;\n\t\t\tint pos = name.find(\"-\");\n\t\t\tstring A = name.substr(0,pos);\n\t\t\tstring B = name.substr(pos+1);\n\t\t\tif(!mp.count(A)) mp[A] = size++;\n\t\t\tif(!mp.count(B)) mp[B] = size++;\n\t\t\t// AÆBÍá¤ûüÌÊè\n\t\t\tc[mp[A]][mp[B]] = 1;\n\t\t}\n\t\t// ¯ÈÊèð`FbN\n\t\tfor(int i=0;i<size;i++){\n\t\t\tfor(int j=i+1;j<size;j++){\n\t\t\t\t// ¯ÈçiÆjÍ¯¶ûüÌÊè\n\t\t\t\tif(check(i,j,size)) c[i][j] = c[j][i] = 2;\n\t\t\t}\n\t\t}\n\t\t// Warshall Floyd@\n\t\t// Ê|ÈÌÅC ç©¶ßS_ÔÌ£ðßÄµÜ¤\n\t\tfor(int k=0;k<size;k++)\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tif(k==i) continue;\n\t\t\t\tfor(int j=0;j<size;j++)\n\t\t\t\t\tc[i][j] = min(c[i][j],c[i][k]+c[k][j]);\n\t\t\t}\n\t\tcout << size << endl; \n\t\tcin >> m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring name; cin >> name;\n\t\t\tint pos = name.find(\"-\");\n\t\t\tstring A = name.substr(0,pos);\n\t\t\tstring B = name.substr(pos+1);\n\t\t\t// \\zµ½OtãÅCA-BÖÌpXª¶ÝµC\n\t\t\t// pXÌ·³ªï(ÙÈéûüÌÊè)ÈçYES\n\t\t\tif(mp.count(A)&&mp.count(B)&&c[mp[A]][mp[B]]%2==1) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nvector<string> split(const string &s, char delim) {\n    vector<int> pos;\n    pos.push_back(-1);\n    rep(i, s.size()) if(s[i] == delim) pos.push_back(i);\n    pos.push_back(s.size());\n    vector<string> res;\n    rep(i, pos.size() - 1) res.push_back(s.substr(pos[i] + 1, pos[i + 1] - pos[i] - 1));\n    return res;\n}\n\ntuple<string, string> input() {\n    string s; cin >> s;\n    auto a = split(s, '-');\n    assert(a.size() == 2);\n    return make_tuple(a[0], a[1]);\n}\n\nclass Solver {\n  public:\n    void dfs(int now, int color, vector<int> &coloring, const vector<vector<int>> &G) {\n        coloring[now] = color;\n        rep(nxt, G.size()) {\n            if((G[nxt][now] or G[now][nxt]) and coloring[nxt] < 0) {\n                dfs(nxt, (color + 1) % 2, coloring, G);\n            }\n        }\n    }\n    bool solve() {\n        int N;\n        map<string, int> road_map;    \n        int road_cnt = 0;\n        cin >> N;\n        if(N == 0) return false;\n        vector<pii> E(N);\n        rep(i, N) {\n            string a, b;            \n            tie(a, b) = input();\n            if(not road_map.count(a)) road_map[a] = road_cnt++;\n            if(not road_map.count(b)) road_map[b] = road_cnt++;\n            int ai = road_map[a], bi = road_map[b];\n            E[i] = pii(ai, bi);\n        }\n        vector<vector<int>> G(road_cnt, vector<int>(road_cnt));\n        rep(i, N) G[E[i].first][E[i].second] = 1;\n        vector<int> color(road_cnt, -1);\n        rep(i, road_cnt) if(color[i] < 0) dfs(i, 0, color, G);\n        rep(a, road_cnt) {\n            rep(b, road_cnt) {\n                if(a == b) continue;\n                int flg[3];\n                flg[0] = 0;\n                flg[1] = flg[2] = 1;\n                rep(c, road_cnt) if(c != a and c != b) {\n                    // A???B????????¨?????????????????\\?????????????????????????????????C????????????\n                    flg[0] |= (G[a][c] and G[b][c]) or \n                              (G[a][c] and G[c][b]) or\n                              (G[c][a] and G[b][c]) or\n                              (G[c][a] and G[c][b]);\n                    // D-A??¨B-D?????\\?????????????????????????????????D????????????\n                    flg[1] &= not (G[c][a] and G[b][c]);\n                    // A-E??¨E-B?????\\?????????????????????????????????E????????????\n                    flg[2] &= not (G[a][c] and G[c][b]);\n                }\n                if(flg[0] and flg[1] and flg[2]) {\n                    G[a][b] = 1;\n                    G[b][a] = 1;\n                }\n            }\n        }\n        rep(k, road_cnt) {\n            rep(i, road_cnt) {\n                rep(j, road_cnt) {\n                    if(G[i][k] and G[k][j]) G[i][j] = 1;\n                }\n            }\n        }\n         // debug(G);\n         // debug(color);\n        cout << road_cnt << endl;\n        int M; cin >> M;\n        rep(m, M) {\n            string a, b;\n            tie(a, b) = input();\n            if(not road_map.count(a) or not road_map.count(b)) {\n                cout << \"NO\" << endl;\n                continue;\n            }\n            int ai = road_map[a], bi = road_map[b];\n            bool ok = G[ai][bi];\n            ok &= color[ai] != color[bi];\n            cout << (ok ? \"YES\" : \"NO\") << endl;\n        }\n        \n        return true;\n    }\n};\n\nint main() {\n    while(true) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint matrix[200][200] = { { 0 } };\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){ break; }\n\t\tfor(int i = 0; i < 200; ++i){\n\t\t\tfor(int j = 0; j < 200; ++j){ matrix[i][j] = 1000; }\n\t\t}\n\t\tmap<string, int> names;\n\t\twhile(N--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tif(names.find(a) == names.end()){\n\t\t\t\tnames.insert(make_pair(a, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tif(names.find(b) == names.end()){\n\t\t\t\tnames.insert(make_pair(b, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tmatrix[ai][bi] = 1;\n\t\t}\n\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\tif(matrix[i][j] <= 2 || matrix[j][i] <= 2){ continue; }\n\t\t\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\t\t\tif(matrix[i][k] == 1 && matrix[j][k] == 1){\n\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(matrix[k][i] == 1 && matrix[k][j] == 1){\n\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint M;\n\t\tcin >> M;\n\t\twhile(M--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tif(names.find(a) == names.end() || names.find(b) == names.end()){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tif(matrix[ai][bi] < 1000){\n\t\t\t\tcout << (matrix[ai][bi] % 2 == 1 ? \"YES\" : \"NO\") << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst int INF = 0xfffffff;\nconst int MAX = 200;\nstring a, b;\nint num;\nint mat[MAX][MAX];\nbool dmat[MAX][MAX];\nbool visited[MAX];\n\nvoid input() {\n\tstring s;\n\tcin >> s;\n\n\tconst int pos = s.find('-');\n\ta = s.substr(0, pos);\n\tb = s.substr(pos + 1);\n}\n\nvoid dfs(int v) {\n\tvisited[v] = true;\n\tfor(int i = 0; i < num; ++i)\n\t\tif(!visited[i] && dmat[v][i])\n\t\t\tdfs(i);\n}\n\nbool reach(int from, int to) {\n\tmemset(visited, false, sizeof(visited));\n\tdfs(from);\n\treturn visited[to];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tmap<string, int> convert;\n\t\tmemset(dmat, false, sizeof(dmat));\n\t\tfill(mat[0], mat[0] + MAX * MAX, INF);\n\t\twhile(n--) {\n\t\t\tinput();\n\n\t\t\tif(!convert.count(a))\n\t\t\t\tconvert.insert(make_pair(a, convert.size()));\n\n\t\t\tif(!convert.count(b))\n\t\t\t\tconvert.insert(make_pair(b, convert.size()));\n\n\t\t\tconst int a_id = convert[a], b_id = convert[b];\n\t\t\tdmat[a_id][b_id] = mat[a_id][b_id] = mat[b_id][a_id] = 1;\n\t\t}\n\n\t\tnum = convert.size();\n\t\tfor(int k = 0; k < num; ++k)\n\t\t\tfor(int i = 0; i < num; ++i)\n\t\t\t\tfor(int j = 0; j < num; ++j)\n\t\t\t\t\tchmin(mat[i][j], mat[i][k] + mat[k][j]);\n\n\t\tvector<vector<bool> > same(num, vector<bool>(num, false));\n\t\tfor(int i = 0; i < num; ++i) {\n\t\t\tfor(int j = i + 1; j < num; ++j) {\n\t\t\t\tif(dmat[i][j] || dmat[j][i] || (mat[i][j] & 1))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbool is_same = false;\n\n\t\t\t\tfor(int k = 0; k < num; ++k) {\n\t\t\t\t\tif((dmat[i][k] && dmat[j][k]) || (dmat[k][i] && dmat[k][j]))\n\t\t\t\t\t\tis_same = true;\n\n\t\t\t\t\tif((dmat[i][k] && dmat[k][j]) || (dmat[j][k] && dmat[k][i]))\n\t\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tsame[i][j] = same[j][i] = is_same;\n\t\t\tnext:;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tfor(int j = 0; j < num; ++j)\n\t\t\t\tdmat[i][j] |= same[i][j];\n\n\t\tint m;\n\t\tcin >> m;\n\n\t\twhile(m--) {\n\t\t\tinput();\n\t\t\tif(!(convert.count(a) && convert.count(b))) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst int a_id = convert[a], b_id = convert[b];\n\t\t\tif(mat[a_id][b_id] % 2 == 0) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcout << (reach(a_id, b_id) ? \"YES\" : \"NO\") << endl;\t\t\t\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nstruct Node {\n    int level;\n    int color;\n    int group;\n    vector<int> edges, back_edges;\n    Node() : level(0), color(1) {}\n};\n\nstruct Dict {\n    int idx;\n    map<string,int> dict;\n\n    Dict() : idx(0) {}\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = idx++;\n    }\n\n    int size() const {\n        return idx;\n    }\n};\n\n#define FOREACH(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define TIMES(i,n) for(int (i) = 0; (i) < (n); ++(i))\n\ntypedef vector<unsigned char> Flag;\n\nvoid preprocess(int pos, vector<Node> &nodes, Flag &visited, int group) {\n    if(visited[pos]) return;\n    visited[pos] = 1;\n\n    Node &cur = nodes[pos];\n    cur.group = group;\n    FOREACH(it, cur.edges) {\n        if(visited[*it]) continue;\n        nodes[*it].level = cur.level+1;\n        nodes[*it].color = 1 - cur.color;\n        preprocess(*it, nodes, visited, group);\n    }\n    FOREACH(it, cur.back_edges) {\n        if(visited[*it]) continue;\n        nodes[*it].level = cur.level-1;\n        nodes[*it].color = 1 - cur.color;\n        preprocess(*it, nodes, visited, group);\n    }\n}\n\nbool check(int from, int to, const vector<Node> &nodes, Flag &visited) {\n    if(visited[from]) return false;\n    if(from == to) return true;\n    visited[from] = 1;\n    const Node &cur = nodes[from];\n    FOREACH(it, cur.edges) {\n        if(check(*it, to, nodes, visited)) return true;\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Node> nodes(2*N);\n        Dict dict;\n        TIMES(_, N) {\n            string cross;\n            cin >> cross;\n            const int hyphen = cross.find('-');\n            const int a = dict.get(cross.substr(0, hyphen));\n            const int b = dict.get(cross.substr(hyphen+1));\n            nodes[b].edges.push_back(a);\n            nodes[a].back_edges.push_back(b);\n        }\n        N = dict.size();\n        nodes.resize(N);\n        Flag visited(N, 0);\n        TIMES(i, N) {\n            if(!visited[i]) {\n                preprocess(i, nodes, visited, i);\n            }\n        }\n        TIMES(i, N) {\n            TIMES(j, i) {\n                if(nodes[i].group == nodes[j].group && nodes[i].level == nodes[j].level) {\n                    nodes[i].edges.push_back(j);\n                    nodes[j].edges.push_back(i);\n                }\n            }\n        }\n        cout << N << endl;\n\n        int M;\n        cin >> M;\n        TIMES(_, M) {\n            string cross;\n            cin >> cross;\n            const int hyphen = cross.find('-');\n            const int a = dict.get(cross.substr(0, hyphen));\n            const int b = dict.get(cross.substr(hyphen+1));\n            bool ans = true;\n            if(a >= N || b >= N) {\n                ans = false;\n            } else if(nodes[a].group != nodes[b].group) {\n                ans = false;\n            } else if(nodes[a].color == nodes[b].color) {\n                ans = false;\n            } else {\n                fill(visited.begin(), visited.end(), 0);\n                ans = check(b, a, nodes, visited);\n            }\n            cout << (ans?\"YES\":\"NO\") << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)n;i++)\nconst int INF = (1<<29) + 1;\n\nint n, m;\n\ntemplate<typename T>\nstruct Serializer{\n\tmap<T, int> enc;\n\tvector<T> dec;\n\tint operator()(const T &t){\n\t\tauto it = enc.find(t);\n\t\tif(it != enc.end()) return it->second;\n\t\tdec.push_back(t);\n\t\treturn enc[t] = dec.size() - 1;\n\t}\n\tsize_t size(){\n\t\treturn dec.size();\n\t}\n};\n\nint g[201][201], g2[201][201];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tSerializer<string> se;\n\t\tREP(i, 200)REP(j, 200)\n\t\t\tg[i][j] = g2[i][j] = i == j ? 0 : INF;\n\t\tREP(i, n){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tg[u][v] = g2[u][v] = g2[v][u] = 1;\n\t\t}\n\t\tn = se.size();\n\t\tREP(i, n)REP(j, i){\n\t\t\tint f = 0;\n\t\t\tREP(k, n){\n\t\t\t\tif(g[i][k] == 1 && g[k][j] == 1 || g[j][k] == 1 && g[k][i] == 1){\n\t\t\t\t\tf = 0; break;\n\t\t\t\t}\n\t\t\t\tif(g[i][k] == 1 && g[j][k] == 1 || g[k][i] == 1 && g[j][i] == 1)\n\t\t\t\t\tf = 1;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tif(g[i][j] == INF) g[i][j] = 501;\n\t\t\t\tif(g[j][i] == INF) g[j][i] = 501;\n\t\t\t}\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tREP(k, n)REP(i, n)REP(j, n) g2[i][j] = min(g2[i][j], g2[i][k] + g2[k][j]);\n\t\tcout << n << endl;\n\t\tcin >> m;\n\t\tREP(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tif((g2[u][v] & 1) && g[u][v] < INF) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        vector<vector<Edge> > edges;\n        vector<vector<int> > rev;\n        for(int i=0; i<n; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                a = edges.size();\n                edges.resize(a + 1);\n                rev.resize(a + 1);\n                index[s1] = a;\n            }else{\n                a = it->second;\n            }\n            it = index.find(s2);\n            if(it == index.end()){\n                b = edges.size();\n                edges.resize(b + 1);\n                rev.resize(b + 1);\n                index[s2] = b;\n            }else{\n                b = it->second;\n            }\n            edges[a].push_back(Edge(b, 1));\n            rev[b].push_back(a);\n        }\n\n        n = edges.size();\n        vector<vector<bool> > check(n, vector<bool>(n, false));\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<edges[i].size(); ++j){\n                int a = edges[i][j].to;\n                for(unsigned k=0; k<rev[a].size(); ++k){\n                    int b = rev[a][k];\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n        }\n        for(int i=0; i<n; ++i){\n            for(unsigned j=1; j<edges[i].size(); ++j){\n                int a = edges[i][j-1].to;\n                int b = edges[i][j].to;\n                if(!check[a][b]){\n                    edges[a].push_back(Edge(b, 2));\n                    edges[b].push_back(Edge(a, 2));\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n            for(unsigned j=1; j<rev[i].size(); ++j){\n                int a = rev[i][j-1];\n                int b = rev[i][j];\n                if(!check[a][b]){\n                    edges[a].push_back(Edge(b, 2));\n                    edges[b].push_back(Edge(a, 2));\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges, dist);\n\n        cout << n << endl;\n        int m;\n        cin >> m;\n        for(int i=0; i<m; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            a = it->second;\n            it = index.find(s2);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            b = it->second;\n\n            if(dist[a][b] != -1 && dist[a][b] % 2 == 1)\n                cout << \"YES\" << endl;\n            else\n                cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 202;\n\nusing vint = vector<int>;\n\nvint G[MAX_N];\nbool H[MAX_N][MAX_N];\n\nint col[MAX_N];\nbool dfs(int u, int c) {\n col[u] = c;\n  for(int v : G[u]) {\n    if(col[v] == c) assert(false);//return false;\n    if(col[v] == 0) dfs(v, -c);\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    for(int i = 0; i < MAX_N; ++i) G[i].clear();\n    memset(H, false, sizeof(H));\n    memset(col, 0, sizeof(col));\n    map<string, int> mp;\n    int sz = 0;\n    for(int i = 0; i < n; ++i) {\n      string cross;\n      cin >> cross;\n      int idx = cross.find('-');\n      string s = cross.substr(0, idx);\n      string t = cross.substr(idx+1);\n      if(!mp.count(s)) mp[s] = sz++;\n      if(!mp.count(t)) mp[t] = sz++;\n      int u = mp[s], v = mp[t];\n      G[u].push_back(v);\n      G[v].push_back(u);\n      H[u][v] = true;\n    }\n    cout << sz << endl;\n    for(int i = 0; i < sz; ++i) {\n      if(!col[i]) dfs(i, 1);\n    }\n    for(int i = 0; i < sz; ++i) {\n      for(int j = i+1; j < sz; ++j) {\n\tbool c = false;\n\tbool d = true;\n\tbool e = true;\n\tfor(int k = 0; k < sz; ++k) {\n\t  if(i == k || j == k) continue;\n\t  if(H[i][k] && H[j][k]) c = true;\n\t  if(H[k][i] && H[k][j]) c = true;\n\t  if(H[k][i] && H[j][k]) d = false;\n\t  if(H[i][k] && H[k][j]) e = false;\n\t}\n\tH[i][j] |= (c&&d&&e);\n\tH[j][i] |= (c&&d&&e);\n      }\n    }\n    for(int i = 0; i < sz; ++i) {\n      for(int j = 0; j < sz; ++j) {\n\tfor(int k = 0; k < sz; ++k) {\n\t  H[j][k] |= H[j][i]&H[i][k];\n\t}\n      }\n    }\n    int m;\n    cin >> m;\n    for(int i = 0; i < m; ++i) {\n      string cross;\n      cin >> cross;\n      int idx = cross.find('-');\n      string s = cross.substr(0, idx);\n      string t = cross.substr(idx+1);\n      if(!mp.count(s)) {\n\tcout << \"NO\" << endl;\n\tcontinue;\n      }\n      if(!mp.count(t)) {\n\tcout << \"NO\" << endl;\n\tcontinue;      \n      }\n      int u = mp[s], v = mp[t];\n      //cout<<col[u]<<\" \"<<col[v]<<endl;      \n      if(col[u] == col[v]) {\n\tcout << \"NO\" << endl;\n\tcontinue;\n      }\n      if(H[u][v]) cout << \"YES\" << endl;\n      else cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nint c[200][200];\n\nbool check(int A, int B, int size){\n\tbool flag = false;\n\tfor(int i=0;i<size;i++){\n\t\tif(i==A||i==B) continue;\n\t\tif(c[i][A]==1&&c[i][B]==1) flag = true;\n\t\tif(c[i][A]==1&&c[B][i]==1) return false;\n\t\tif(c[A][i]==1&&c[i][B]==1) return false;\n\t\tif(c[A][i]==1&&c[B][i]==1) flag = true;\n\t}\n\treturn flag;\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n, n){\n\t\tfor(int i=0;i<200;i++)\n\t\t\tfor(int j=0;j<200;j++) c[i][j] = 1000000;\n\t\tmap<string, int> mp;\n\t\tint size = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring name; cin >> name;\n\t\t\tint pos = name.find(\"-\");\n\t\t\tstring A = name.substr(0,pos);\n\t\t\tstring B = name.substr(pos+1);\n\t\t\tif(!mp.count(A)) mp[A] = size++;\n\t\t\tif(!mp.count(B)) mp[B] = size++;\n\t\t\tc[mp[A]][mp[B]] = 1;\n\t\t}\n\t\tfor(int i=0;i<size;i++){\n\t\t\tfor(int j=i+1;j<size;j++){\n\t\t\t\tif(check(i,j,size)) c[i][j]=2, c[j][i]=2;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<size;k++)\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tif(k==i) continue;\n\t\t\t\tfor(int j=0;j<size;j++)\n\t\t\t\t\tc[i][j] = min(c[i][j],c[i][k]+c[k][j]);\n\t\t\t}\n\t\tcout << size << endl; \n\t\tcin >> m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring name; cin >> name;\n\t\t\tint pos = name.find(\"-\");\n\t\t\tstring A = name.substr(0,pos);\n\t\t\tstring B = name.substr(pos+1);\n\t\t\tif(mp.count(A)&&mp.count(B)&&c[mp[A]][mp[B]]%2==1) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n\nusing namespace std;\n\nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n\nbool eq_str(const string& p,const string& q){ p==q; }\n\nmultimap<string,string>m1,m2;\nmap<string,int>color;\n\nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n\nint graph[300][300];\nvector<string>node;\n\nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tgraph[i][j]|=graph[i][k]&graph[k][j];\n}\n\nint main(void){\n  int n,m;\n  string in,s1,s2;\n  map<string,int>node2;\n\n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n\n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node),eq_str),node.end());\n    \n    for(int i=0;i<node.size();i++)node2[node[i]]=i;\n\n    for(int i=0;i<node.size();i++)color[node[i]]=0;\n\n    for(int i=0,j=1;i<node.size();i++)\n      if(color[node[i]]==0)dfs(node[i],j++);\n\n    for(int i=0;i<300;i++)\n      for(int j=0;j<300;j++)graph[i][j]=i==j?1:0;\n\n    multimap<string,string>::iterator it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      multimap<string,string>::iterator it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).fst){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n\n    warshall_floyd(node.size());\n\n    cin >> m;\n    cout << node.size() << endl;\n\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      if(color[s1]+color[s2]==0 &&\n\t graph[node2[s1]][node2[s2]]==1)cout << \"YES\" << endl;\n      else cout << \"NO \" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\ntypedef pair<int,int>P;\n\nint n,NUM,dp[222][222];\n\nint boo[222][222];\n\nint graph[222][222];\n\nvector<int>rv[222],v[222];\n\nbool used[222];\n\nset<int>st[222];\n\nmap<string,int>M;\n\nmap<pair<int,int>,int>MAP;\n\nmap<int,string>MM;\n\nvoid INIT(){\n\tmemset(graph,0,sizeof(graph));\n\tmemset(boo,0,sizeof(boo));\n\tMAP.clear();\n\tNUM=1;\n\tr(i,222)v[i].clear(),rv[i].clear(),st[i].clear();\n\tr(i,222)r(j,222)dp[i][j]=(i==j?0:1e8+1);\n}\n\nvoid WAR(){\n\tr(o,n)r(i,n)r(j,n)dp[i][j]=min(dp[i][j],dp[i][o]+dp[o][j]);\n}\n\n\n\nvoid make_graph(){\n\n\tMAP.clear();\n\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tMAP[P(i,v[i][j])]=1;\n\n\t\t\t//\tcout<<MM[i]<<' '<<MM[v[i][j]]<<endl;\n\t\t}\n\t}\n\t//cout<<endl<<endl<<endl;\n\n\tfor(int A=1;A<NUM;A++){\n\n\t\tfor(int B=A+1;B<NUM;B++){\n\n\t\t\tint flag = 1,flag2=0;\n\n\t\t\tfor(int D=1;D<NUM;D++){\n\n\t\t\t\tif(MAP[P(A,D)]&&MAP[P(D,B)])flag=0;\n\n\t\t\t\tif(MAP[P(D,A)]&&MAP[P(B,D)])flag=0;\n\n\t\t\t\tif(( (MAP[P(D,A)]&&MAP[P(D,B)]) || (MAP[P(A,D)]&&MAP[P(B,D)]) )) flag2 =1;\n\t\t\t}\n\n\t\t\t//\tif(A==2&&B==3)cout<<flag<<' '<<flag2<<endl;\n\n\t\t\tif(flag && flag2){\n\t\t\t\tboo[A][B] = boo[B][A] = 1;\n\n\t\t\t\t//cout<<MM[A]<<' '<<MM[B]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*vector<int>mato[222];\n\t\n\tfor(int i=1;i<NUM;i++){\n\t\t\n\t\tfor(int j=0;j<rv[i].size();j++){\n\t\t\t\n\t\t\tfor(int k=j+1;k<rv[i].size();k++){\n\t\t\t\t\n\t\t\t\tmato[rv[i][j]].push_back(rv[i][k]);\n\t\t\t\tmato[rv[i][k]].push_back(rv[i][j]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tr(i,NUM-1)cout<<MM[i+1]<<' '<<mato[i+1].size()<<endl;\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tr(k,mato[v[i][j]].size()){\n\t\t\t\tif(!st[i].count(mato[v[i][j]][k])){\n\t\t\t\t\t\n\t\t\t\t\tv[i].push_back(mato[v[i][j]][k]);\n\t\t\t\t\t\n\t\t\t\t\t st[i].insert(mato[v[i][j]][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}*/\n\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=0;j<v[i].size();j++){\n\n\t\t\tint now = v[i][j];\n\n\t\t\tgraph[i][now] = 1;\n\n\t\t\tfor(int k=1;k<NUM;k++){\n\t\t\t\tif(boo[now][k]){\n\n\t\t\t\t\tgraph[i][k] = 1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i=1;i<NUM;i++){\n\n\t\tfor(int j=1;j<NUM;j++){\n\n\t\t\tif(boo[i][j]){\n\n\t\t\t\tfor(int k=0;k<v[j].size();k++){\n\t\t\t\t\tgraph[i][v[j][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tr(i,222)v[i].clear();\n\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=1;j<NUM;j++){\n\t\t\tif(graph[i][j]){\n\n\t\t\t\tv[i].push_back(j);\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid INPUT(){\n\tr(i,n){\n\t\tint idx=0;\n\t\tstring s,s1,s2;      //cout<<1<<endl;\n\t\tcin>>s;\n\t\twhile(s[idx]!='-')s1+=s[idx++];             //cout<<s1<<endl;\n\t\tidx++;\n\t\twhile(idx<(int)s.size())s2+=s[idx++];\n\t\tif(M[s1]==0)M[s1]=NUM++,MM[NUM-1]=s1;\n\t\tif(M[s2]==0)M[s2]=NUM++,MM[NUM-1]=s2;    //cout<<NUM<<endl;\n\t\t\n\t\tdp[M[s1]-1][M[s2]-1]=dp[M[s2]-1][M[s1]-1]=1;\n\t\t\n\t\tv[M[s1]].push_back(M[s2]);\n\t\tst[M[s1]].insert(M[s2]);\n\t\trv[M[s2]].push_back(M[s1]);\n\n\t\t//\tcout<<M[s1]<<' '<<M[s2]<<endl;\n\n\t\t//MAP[P(M[s1],M[s2])]=1;\n\t}\n\n\t//\tcout<<endl<<endl;\n\n\n\tr(i,NUM)make_graph();\n}\n\nbool BFS(int s,int t){\n\tmemset(used,0,sizeof(used));\n\tused[s]=1;\n\tqueue<int>q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();\n\t\tr(i,v[x].size()){\n\t\t\tint to = v[x][i];\n\t\t\tif(used[to])continue;\n\t\t\tused[to]=1;\n\t\t\tq.push(to);\n\t\t\tif(to==t)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid QUERY(){\n\n\t//cout<<grap\n\n\n\t/*for(int i=1;i<NUM;i++){\n\t\tcout<<endl;\n\t\tcout<<endl;\n\t\tcout<<MM[i]<<endl;\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tcout<<MM[v[i][j]]<<endl;\n\t\t}\n\t\t}*/\n\n\t\n\tcout<<NUM-1<<endl;\n\tint Q;\n\tcin>>Q;\n\twhile(Q--){\n\t\tint idx=0,start,goal;\n\t\tstring s,s1,s2;\n\t\tcin>>s;\n\t\twhile(s[idx]!='-')s1+=s[idx++];\n\t\tidx++;\n\t\twhile(idx<s.size())s2+=s[idx++];\n\n\t\tif(M[s1]==0||M[s2]==0){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(dp[M[s1]-1][M[s2]-1]<1e6&&dp[M[s1]-1][M[s2]-1]%2==0){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstart = M[s1];\n\t\tgoal  = M[s2];\n\n\t\tif(BFS(start,goal)||!BFS(goal,start)) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t\t\n\t}\n}\n\n\nint main(){\n\twhile(cin>>n,n){\n\t\tINIT();\n\t  INPUT();\n\t\tWAR();\n\t\tQUERY();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\treturn vs{ l,r };\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] || dist[k][i]) && (dist[j][k] || dist[k][j])) f1 = true;\n\t\t\t\tif ((dist[i][k] && dist[k][j]) || (dist[k][i] && dist[j][k])) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p)\n\t\t{\n\t\t\tif (dist[i][k] && dist[k][j]) dist[i][j] = 1;\n\t\t}\n\t\tvi color(p);\n\t\tint col = 1;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i]) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = -col;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to]) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol++;\n\t\t}\n\t\tcout << p << endl;\n\t\tint q;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif (color[l] == -color[r] && dist[r][l])\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint N,m,n,st[210][210],same[210][210];\n\nint main(){\n\twhile(cin>>N && N){\n\t\trep(i,210)rep(j,210)st[i][j]=i==j?0:INF;\n\t\tmap<string,int> M;\n\t\tn=0;\n\t\trep(i,N){\n\t\t\tstring s,t,u;\n\t\t\tcin>>s;\n\t\t\tint mode=0;\n\t\t\trep(j,s.sz){\n\t\t\t\tif(s[j]=='-')mode=1;\n\t\t\t\telse mode?u+=s[j]:t+=s[j];\n\t\t\t}\n\t\t\tif(M.find(t)==M.end())M[t]=n++;\n\t\t\tif(M.find(u)==M.end())M[u]=n++;\n\t\t\tst[M[t]][M[u]]=1;\n\t\t}\n\t\trep(i,n)rep(j,n){\n\t\t\tint ok=0;\n\t\t\trep(k,n){\n\t\t\t\tif(st[i][k]==1&&st[j][k]==1\n\t\t\t\t|| st[k][i]==1&&st[k][j]==1)ok=1;\n\t\t\t\tif(st[i][k]==1&&st[k][j]==1\n\t\t\t\t|| st[j][k]==1&&st[k][i]==1){\n\t\t\t\t\tok=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)st[i][j]=0;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tst[i][j]=min(st[i][j],st[i][k]+st[k][j]);\n\t\t}\n\t\tcout<<n<<endl;\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tstring s,t,u;\n\t\t\tcin>>s;\n\t\t\tint mode=0;\n\t\t\trep(j,s.sz){\n\t\t\t\tif(s[j]=='-')mode=1;\n\t\t\t\telse mode?u+=s[j]:t+=s[j];\n\t\t\t}\n\t\t\tint T=M[t],U=M[u];\n\t\t\tcout<<(st[T][U]<INF && st[T][U]%2 ? \"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\ntypedef long long ll;\n\nvoid parse(char *s1,char *s2){\n\tchar s[64]; gets(s);\n\tint i;\n\tfor(i=0;s[i]!='-';i++);\n\ts[i]='\\0';\n\tstrcpy(s1,s);\n\tstrcpy(s2,s+i+1);\n}\n\nll hash(const char *s){\n\tconst ll P=1000000007;\n\tll h=0;\n\tfor(int i=0;s[i];i++) h=h*P+s[i];\n\treturn h;\n}\n\nint main(){\n\tfor(int m;scanf(\"%d \",&m),m;){\n\t\tll h1[1000],h2[1000],H[2000];\n\t\trep(i,m){\n\t\t\tchar s1[17],s2[17];\n\t\t\tparse(s1,s2);\n\t\t\tH[2*i+0]=h1[i]=hash(s1);\n\t\t\tH[2*i+1]=h2[i]=hash(s2);\n\t\t}\n\t\tsort(H,H+2*m);\n\t\tint n=unique(H,H+2*m)-H;\n\n\t\tint u1[1000],u2[1000];\n\t\tbool G[200][200]={};\n\t\trep(i,m){\n\t\t\tu1[i]=lower_bound(H,H+n,h1[i])-H;\n\t\t\tu2[i]=lower_bound(H,H+n,h2[i])-H;\n\t\t\tG[u1[i]][u2[i]]=true;\n\t\t}\n\n\t\tint d[200][200]; // 距離行列\n\t\trep(u,n) rep(v,n) {\n\t\t\tbool ok=false;\n\t\t\trep(w,n){\n\t\t\t\tif(G[u][w] && G[v][w]) ok=true;\n\t\t\t\tif(G[w][u] && G[w][v]) ok=true;\n\t\t\t\tif(G[u][w] && G[w][v]){ ok=false; break; }\n\t\t\t\tif(G[v][w] && G[w][u]){ ok=false; break; }\n\t\t\t}\n\t\t\td[u][v]=(ok?0:INF);\n\t\t}\n\t\trep(i,m) d[u1[i]][u2[i]]=1;\n\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tint q; scanf(\"%d \",&q);\n\t\tprintf(\"%d\\n\",n);\n\t\twhile(q--){\n\t\t\tchar s1[17],s2[17];\n\t\t\tparse(s1,s2);\n\t\t\tll h1=hash(s1),h2=hash(s2);\n\t\t\tif(binary_search(H,H+n,h1) && binary_search(H,H+n,h2)){\n\t\t\t\tint u=lower_bound(H,H+n,h1)-H;\n\t\t\t\tint v=lower_bound(H,H+n,h2)-H;\n\t\t\t\tputs(d[u][v]<INF&&d[u][v]%2==1?\"YES\":\"NO\");\n\t\t\t}\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        vector<vector<Edge> > edges;\n        vector<vector<int> > rev;\n        for(int i=0; i<n; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                a = edges.size();\n                edges.resize(a + 1);\n                rev.resize(a + 1);\n                index[s1] = a;\n            }else{\n                a = it->second;\n            }\n            it = index.find(s2);\n            if(it == index.end()){\n                b = edges.size();\n                edges.resize(b + 1);\n                rev.resize(b + 1);\n                index[s2] = b;\n            }else{\n                b = it->second;\n            }\n            edges[a].push_back(Edge(b, 1));\n            rev[b].push_back(a);\n        }\n\n        n = edges.size();\n        vector<vector<bool> > check(n, vector<bool>(n, false));\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<edges[i].size(); ++j){\n                int a = edges[i][j].to;\n                for(unsigned k=0; k<edges[a].size(); ++k){\n                    int b = edges[a][k].to;\n                    check[i][b] = check[b][i] = true;\n                }\n            }\n        }\n        for(int i=0; i<n; ++i){\n            for(unsigned j=1; j<edges[i].size(); ++j){\n                if(edges[i][j].cost == 2)\n                    continue;\n                int a = edges[i][j-1].to;\n                int b = edges[i][j].to;\n                if(!check[a][b]){\n                    edges[a].push_back(Edge(b, 2));\n                    edges[b].push_back(Edge(a, 2));\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n            for(unsigned j=1; j<rev[i].size(); ++j){\n                int a = rev[i][j-1];\n                int b = rev[i][j];\n                if(!check[a][b]){\n                    edges[a].push_back(Edge(b, 2));\n                    edges[b].push_back(Edge(a, 2));\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges, dist);\n\n        cout << n << endl;\n        int m;\n        cin >> m;\n        for(int i=0; i<m; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            a = it->second;\n            it = index.find(s2);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            b = it->second;\n\n            if(dist[a][b] != -1 && dist[a][b] % 2 == 1)\n                cout << \"YES\" << endl;\n            else\n                cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n\nusing namespace std;\n\nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n\nbool eq_str(const string& p,const string& q){ p==q; }\n\nmultimap<string,string>m1,m2;\nmap<string,int>color;\n\nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n\nint graph[200][200];\nvector<string>node;\n\nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tgraph[i][j]|=graph[i][k]&graph[k][j];\n}\n\nint main(void){\n  int n,m;\n  string in,s1,s2;\n  map<string,int>node2;\n\n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n\n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node),eq_str),node.end());\n    \n    for(int i=0;i<node.size();i++)node2[node[i]]=i;\n\n    for(int i=0;i<node.size();i++)color[node[i]]=0;\n\n    for(int i=0,j=1;i<node.size();i++)\n      if(color[node[i]]==0)dfs(node[i],j++);\n\n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)graph[i][j]=i==j?1:0;\n\n    multimap<string,string>::iterator it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      multimap<string,string>::iterator it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).fst){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n\n    warshall_floyd(node.size());\n\n    for(int i=0;i<node.size();i++)\n      cout << node[i] << \" \" << i << endl;\n\n    for(int i=0;i<node.size();i++){\n      for(int j=0;j<node.size();j++)\n\tcout << graph[i][j]<<\" \";\n\tcout << endl;\n\t}\n    cin >> m;\n    cout << node.size() << endl;\n\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      if(color[s1]+color[s2]==0 &&\n\t graph[node2[s1]][node2[s2]]==1)cout << \"YES\" << endl;\n      else cout << \"NO \" <<graph[node2[s1]][node2[s2]] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\treturn vs{ l,r };\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n, q;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p, INF));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] == 1 || dist[k][i] == 1) && (dist[j][k] == 1 || dist[k][j] == 1)) f1 = true;\n\t\t\t\tif ((dist[i][k] == 1 && dist[k][j] == 1) || (dist[k][i] == 1 && dist[j][k] == 1)) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p) chmin(dist[i][j], dist[i][k] + dist[k][j]);\n\t\tvi color(p);\n\t\tint col = 1;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i]) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = -col;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to]) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol++;\n\t\t}\n\t\tcout << p << endl;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif (color[l] == -color[r] && dist[r][l] != INF)\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n \nusing namespace std;\n \nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i);\n      return;\n    }\n  }\n}\n \nbool eq_str(const string& p,const string& q){ p==q; }\n \nmultimap<string,string>m1,m2;\nmap<string,int>color;\n \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n \nint graph[300][300];\n \nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n    graph[i][j]|=graph[i][k]&graph[k][j];\n}\n \nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n    \n    //for(int i=0;i<node.size();i++)cout << node[i] << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    bool g[300][300];\n    for(int i=0;i<300;i++){\n      for(int j=0;j<300;j++){\n\tg[i][j]=false;\n\tgraph[i][j]=i==j?1:0; \n      }\n    }\n    \n    multimap<string,string>::iterator it=m1.begin(),it2=m1.begin();\n    \n    while(it!=m1.end()){\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).sec){\n\t  graph[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  graph[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  graph[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  graph[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n\tit2++;\n      }\n      it++;\n    }\n    \n    it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n    \n    warshall_floyd(node3.size());\n    \n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO \" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nint N, M;\nint V;\nvector<vector<int> > E;\nvector<vector<int> > rE;\nvector<vector<int> > undE;\n\nint tag[310];\nint even[310];\n\nvoid init() {\n\tE.clear(); rE.clear(); undE.clear();\n\trep(i,310) {\n\t\ttag[i] = -1;\n\t\teven[i] = -1;\n\t}\n};\n\nbool dfs(int n, int tg, int d) {\n\tif(tag[n]+1)\n\t\treturn false;\n\ttag[n] = tg;\n\teven[n] = d % 2;\n\tfor(int i = 0; i < undE[n].size(); i++) {\n\t\tdfs(undE[n][i], tg, d+1);\n\t}\n\treturn true;\n}\n\nbool used[310];\nbool solve(int n, int gl) {\n\tif(n == gl) return true;\n\tif(used[n]) return false;\n\tused[n] = true;\n\n\tbool res = false;\n\trep(i,rE[n].size()) {\n\t\tif(solve(rE[n][i], gl))\n\t\t\tres = true;\n\t}\n\trep(i,E[n].size()) {\n\t\trep(j,rE[E[n][i]].size()) {\n\t\t\tif(solve(rE[E[n][i]][j], gl))\n\t\t\t\tres = true;\n\t\t}\n\t}\n\trep(i,rE[n].size()) {\n\t\trep(j,E[rE[n][i]].size()) {\n\t\t\tif(solve(E[rE[n][i]][j], gl))\n\t\t\t\tres = true;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> N, N) {\n\t\tinit();\n\t\tmap<string, int> mp;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tstring s, s0, s1;\n\t\t\tcin >> s;\n\t\t\ts0 = string(s.begin(), s.begin()+s.find('-'));\n\t\t\ts1 = string(s.begin()+s0.size()+1, s.end());\n\t\t\tvector<string> vs;\n\t\t\tvs.pb(s0); vs.pb(s1);\n\t\t\tfor(int j = 0; j < vs.size(); j++) {\n\t\t\t\tif(mp.find(vs[j]) == mp.end()) {\n\t\t\t\t\tint id = mp.size();\n\t\t\t\t\tmp[vs[j]] = id;\n\t\t\t\t\tE.pb(vector<int>());\n\t\t\t\t\trE.pb(vector<int>());\n\t\t\t\t\tundE.pb(vector<int>());\n\t\t\t\t}\n\t\t\t}\n\t\t\tint a, b;\n\t\t\ta = mp[s0];\n\t\t\tb = mp[s1];\n\t\t\tE[b].pb(a);\n\t\t\trE[a].pb(b);\n\t\t\tundE[b].pb(a);\n\t\t\tundE[a].pb(b);\n\t\t}\n\t\tV = mp.size();\n\t\tcout << V << endl;\n\t\t//for(auto it = mp.begin(); it != mp.end(); it++) cout << it->second << \":\" << it->first << endl;\n\t\tint tg = 0;\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\ttg += dfs(i, tg, 0);\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i < 10; i++)\n\t\t\tcout << even[i] << \" \" ;\n\t\tcout << endl;\n\t\t// */\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\trep(j,310) used[j] = false;\n\t\t\tstring s, ss[2];\n\t\t\tcin >> s;\n\t\t\tss[0] = string(s.begin(), s.begin()+s.find('-'));\n\t\t\tss[1] = string(s.begin()+s.find('-')+1, s.end());\n\t\t\tbool res = true;\n\t\t\tif(mp.find(ss[0]) == mp.end() || mp.find(ss[1]) == mp.end()\n\t\t\t\t\t|| ss[0] == ss[1] || even[mp[ss[0]]] == even[mp[ss[1]]])\n\t\t\t\tres = false;\n\t\t\tif(res)\n\t\t\t\tres = solve(mp[ss[0]], mp[ss[1]]);\n\t\t\t\n\t\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<string,int> M;\n\nint str2int(string S){\n    if(M.find(S)==M.end()){\n        int n = M.size();\n        M[S]=n;\n    }\n    return M[S];\n}\n\nint E[200][200];//[a][b]=a to b\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        fill(E[0],E[200],10000);\n        M.clear();\n        for(int i=0;i<N;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    E[i1][i2]=1;\n                    break;\n                }\n            }\n        }\n        int m = M.size();\n        cout<<m<<endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<m;j++){\n                if(E[i][j]==1||E[j][i]==1) continue;\n                //cond1\n                bool b=false;\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[i][k]==1||E[k][i]==1)&&(E[j][k]==1||E[k][j]==1)){\n                        b=true;\n                        break;\n                    }\n                }\n                //cond2,3\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[k][i]==1&&E[j][k]==1)||(E[i][k]==1&&E[k][j]==1)){\n                        b=false;\n                        break;\n                    }\n                }\n                if(b) E[i][j]=E[j][i]=0;\n            }\n        }\n        //WF\n        for(int i=0;i<m;i++) E[i][i]=0;\n        for(int k=0;k<m;k++){\n            for(int i=0;i<m;i++){\n                for(int j=0;j<m;j++){\n                    E[i][j]=min(E[i][j],E[i][k]+E[k][j]);\n                }\n            }\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    if(i1>=m||i2>=m||E[i1][i2]%2==0){\n                        cout<<\"NO\"<<endl;\n                    }else{\n                        cout<<\"YES\"<<endl;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<vector>\n#include<tuple>\nusing namespace std;\n\nconst int INF = 9;\n\nint main() {\n    int n, m;\n    while(cin >> n, n) {\n        map<string, int> id;\n        vector<tuple<int, int>> cross;\n        int size = 0;\n        for(int i = 0; i < n; ++i) {\n            string x, y, input;\n            int index;\n            cin >> input;\n            index = input.find(\"-\");\n            x = input.substr(0, index);\n            y = input.substr(index + 1, input.size() - index - 1);\n            if(!id.count(x)) id[x] = size++;\n            if(!id.count(y)) id[y] = size++;\n            cross.push_back(tuple<int, int>(id[x], id[y]));\n        }\n\n        // adjacent matrix\n        vector<vector<int>> distance(size, vector<int>(size, INF));\n        for(auto& c: cross) distance[get<0>(c)][get<1>(c)] = 1;\n        for(int a = 0; a < size; ++a) for(int b  = a + 1; b < size; ++b) {\n            set<int> ac, ca, bc, cb;\n            for(auto c: cross) {\n                if(get<0>(c) == a) ac.insert(get<1>(c));\n                if(get<1>(c) == a) ca.insert(get<0>(c));\n                if(get<0>(c) == b) bc.insert(get<1>(c));\n                if(get<1>(c) == b) cb.insert(get<0>(c));\n            }\n            bool condition1 = false;\n            bool condition2 = true;\n            bool condition3 = true;\n            for(auto v: ca) {\n                if(bc.count(v)) condition2 = false;\n                if(cb.count(v)) condition1 = true;\n            }\n            for(auto v: ac) {\n                if(cb.count(v)) condition3 = false;\n                if(bc.count(v)) condition1 = true;\n            }\n            if(condition1 && condition2 && condition3) {\n                distance[a][b] = distance[b][a] = 0;\n            }\n        }\n\n        // Warshal-Floyd\n        for(int k = 0; k < size; ++k) for(int i = 0; i < size; ++i) for(int j = 0; j < size; ++j)\n            distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]);\n\n        // output\n        cout << size << endl;\n        for(cin >> m; m > 0; --m) {\n            string x, y, input;\n            int index;\n            cin >> input;\n            index = input.find(\"-\");\n            x = input.substr(0, index);\n            y = input.substr(index + 1, input.size() - index - 1);\n\n            cout << (id.count(x) && id.count(y) && (distance[id[x]][id[y]] & 1) ? \"YES\" : \"NO\") << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing ps = pair<string,string>;\n\nps split(string s){\n    int n = s.size();\n    int idx = 0;\n    while(idx<n && s[idx]!='-') ++idx;\n\n    return {s.substr(0,idx), s.substr(idx+1)};\n}\n\nconst int N = 300;\nconst int INF = 191919;\n\n// 入力から分かる強さ関係\nvector<int> G[N];\nbool arr[N][N];\n\nint d[N][N];\n\n// 水準関係\nint C[N][N];\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        rep(i,N) G[i].clear();\n        rep(i,N)rep(j,N) C[i][j]=INF;\n        rep(i,N) C[i][i]=0;\n        rep(i,N)rep(j,N) d[i][j]=INF;\n        rep(i,N) d[i][i]=0;\n        rep(i,N)rep(j,N) arr[i][j] = false;\n\n\n        map<string,int> c2id;\n        vector<string> names;\n        rep(i,n){\n            string s;\n            cin >>s;\n            ps cross = split(s);\n\n            if(!c2id.count(cross.fi)){\n                c2id[cross.fi] = c2id.size();\n                names.pb(cross.fi);\n            }\n            if(!c2id.count(cross.se)){\n                c2id[cross.se] = c2id.size();\n                names.pb(cross.se);\n            }\n            int u = c2id[cross.fi], v = c2id[cross.se];\n            G[u].pb(v);\n            C[u][v]=1;\n            d[u][v] = d[v][u] = 1;\n            arr[u][v] = true;\n        }\n\n        int V = c2id.size();\n\n        rep(k,V)rep(i,V)rep(j,V) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        auto same_degree = [&](int a, int b){\n            bool same = false;\n            rep(i,V){\n                if( (arr[a][i]||arr[i][a]) && (arr[b][i]||arr[i][b]) ) same = true;\n            }\n            if(!same) return false;\n\n            rep(i,V){\n                if(arr[i][a]&&arr[b][i]) return false;\n                if(arr[a][i]&&arr[i][b]) return false;\n            }\n\n            return true;\n        };\n\n        rep(i,V)rep(j,i){\n            if(same_degree(i,j)){\n                // cout << \"DEG :: \" << names[i] << \" \" << names[j] << endl;\n                C[i][j] = C[j][i] = 1;\n            }\n        }\n        rep(k,V)rep(i,V)rep(j,V) C[i][j] = min(C[i][j], C[i][k]+C[k][j]);\n\n        cout << V << endl;\n\n        int Q;\n        cin >>Q;\n        while(Q--){\n            string q;\n            cin >>q;\n\n            ps qc = split(q);\n\n            bool ok = false;\n            if(c2id.count(qc.fi) && c2id.count(qc.se)){\n                int u = c2id[qc.fi], v = c2id[qc.se];\n                // dbg(C[u][v]);\n\n                if(d[u][v]%2==1 && C[u][v]<INF) ok = true;\n            }\n            cout << (ok?\"YES\":\"NO\") << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <map>\nconst int INF = 1e9;\nusing namespace std;\n\npair<string, string> get_name(string S){\n  string s, t;\n  for(int i = 0; i < S.length(); ++i){\n    if(S[i] == '-'){\n      t = S.substr(i+1);\n      break;\n    }\n    s += S[i];\n  }\n  return pair<string, string>(s, t);\n}\n\nvoid dfs(vector< vector<int> > &G, vector<int> &C, int v){\n  int n = G.size();\n  for(int i = 0; i < n; ++i){\n    if(G[v][i] >= INF && G[i][v] >= INF) continue;\n    if(C[i] == 0){\n      C[i] = -C[v];\n      dfs(G, C, i);\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(cin >> N, N){\n  map<string, int> m;\n  vector<string> from(N), to(N);\n  for(int i = 0; i < N; ++i){\n    string s;\n    cin >> s;\n    pair<string, string> E = get_name(s);\n    m[E.first] = 1;\n    m[E.second] = 1;\n    from[i] = E.first;\n    to[i] = E.second;\n  }\n  int t = 1;\n  for(auto itr = m.begin(); itr != m.end(); ++itr){\n    itr->second = t;\n    ++t;\n  }\n  int n = m.size();\n  cout << n << endl;\n  vector< vector<int> > G(n, vector<int>(n, INF));\n  for(int i = 0; i < N; ++i){\n    int u = m[from[i]] - 1, v = m[to[i]] - 1;\n    G[u][v] = 1;\n  }\n  vector<int> C(n, 0);\n  for(int i = 0; i < n; ++i){\n    if(!C[i]){\n      C[i] = 1;\n      dfs(G, C, i);\n    }\n  }\n\n  vector< vector<int> > G_ = G;\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(G[i][j] < INF || G[j][i] < INF) continue;\n      bool f = false;\n      for(int k = 0; k < n; ++k){\n        if((G[i][k] < INF && G[j][k] < INF) || (G[k][i] < INF && G[k][j] < INF)){\n          f = true;\n          break;\n        }\n      }\n      for(int k = 0; k < n; ++k){\n        if((G[i][k] < INF && G[k][j] < INF) || (G[k][i] < INF && G[j][k] < INF)){\n          f = false;\n          break;\n        }\n      }\n      if(f){\n        G_[i][j] = 1;\n        G_[j][i] = 1;\n      }\n    }\n  }\n\n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        G_[i][j] = min(G_[i][j], G_[i][k] + G_[k][j]);\n      }\n    }\n  }\n\n  int M;\n  cin >> M;\n  for(int i = 0; i < M; ++i){\n    string S;\n    cin >> S;\n    pair<string, string> Q = get_name(S);\n    int u = m[Q.first] - 1, v = m[Q.second] - 1;\n    if(u < 0 || v < 0){\n      cout << \"NO\" << endl;\n      continue;\n    }\n    if(C[u] != C[v] && G_[u][v] < INF) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 202;\n\nusing vint = vector<int>;\n\nvint G[MAX_N];\nbool H[MAX_N][MAX_N];\n\nint col[MAX_N];\nbool dfs(int u, int c) {\n col[u] = c;\n  for(int v : G[u]) {\n    if(col[v] == c) assert(false);//return false;\n    if(col[v] == 0) dfs(v, -c);\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    for(int i = 0; i < MAX_N; ++i) G[i].clear();\n    memset(H, false, sizeof(H));\n    memset(col, 0, sizeof(col));\n    map<string, int> mp;\n    int sz = 0;\n    for(int i = 0; i < n; ++i) {\n      string cross;\n      cin >> cross;\n      int idx = cross.find('-');\n      string s = cross.substr(0, idx);\n      string t = cross.substr(idx+1);\n      if(!mp.count(s)) mp[s] = sz++;\n      if(!mp.count(t)) mp[t] = sz++;\n      int u = mp[s], v = mp[t];\n      G[u].push_back(v);\n      G[v].push_back(u);\n      H[u][v] = true;\n    }\n    cout << sz << endl;\n    for(int i = 0; i < sz; ++i) {\n      if(!col[i]) dfs(i, 1);\n    }\n    for(int i = 0; i < sz; ++i) {\n      for(int j = i+1; j < sz; ++j) {\n\tbool c = false;\n\tbool d = true;\n\tbool e = true;\n\tfor(int k = 0; k < sz; ++k) {\n\t  if(i == k || j == k) continue;\n\t  if(H[i][k] && H[j][k]) c = true;\n\t  if(H[k][i] && H[k][j]) c = true;\n\t  if(H[k][i] && H[j][k]) d = false;\n\t  if(H[i][k] && H[k][j]) e = false;\n\t}\n\tH[i][j] |= (c&&d&&e);\n\tH[j][i] |= (c&&d&&e);\n      }\n    }\n    for(int i = 0; i < sz; ++i) {\n      for(int j = 0; j < sz; ++j) {\n\tfor(int k = 0; k < sz; ++k) {\n\t  H[j][k] |= H[j][i]&H[i][k];\n\t}\n      }\n    }\n    int m;\n    cin >> m;\n    for(int i = 0; i < m; ++i) {\n      string cross;\n      cin >> cross;\n      int idx = cross.find('-');\n      string s = cross.substr(0, idx);\n      string t = cross.substr(idx+1);\n      if(!mp.count(s)) {\n\tcout << \"NO\" << endl;\n\tcontinue;\n      }\n      if(!mp.count(t)) {\n\tcout << \"NO\" << endl;\n\tcontinue;      \n      }\n      int u = mp[s], v = mp[t];\n      //cout<<col[u]<<\" \"<<col[v]<<endl;      \n      if(col[u] == col[v]) {\n\tcout << \"NO\" << endl;\n\tcontinue;\n      }\n      if(H[u][v]) cout << \"YES\" << endl;\n      else cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst int INF = 2000;\nconst int MAX = 200;\nstring a, b;\nint num;\nint mat[MAX][MAX];\nbool dmat[MAX][MAX];\nbool visited[MAX];\n\nvoid input() {\n\tstring s;\n\tcin >> s;\n\n\tconst int pos = s.find('-');\n\ta = s.substr(0, pos);\n\tb = s.substr(pos + 1);\n}\n\nvoid dfs(int v) {\n\tvisited[v] = true;\n\tfor(int i = 0; i < num; ++i)\n\t\tif(!visited[i] && dmat[v][i])\n\t\t\tdfs(i);\n}\n\nbool check(int from, int to) {\n\tif(mat[from][to] % 2 == 0)\n\t\treturn false;\n\tmemset(visited, false, sizeof(visited));\n\tdfs(from);\n\treturn visited[to];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tmap<string, int> convert;\n\t\tmemset(dmat, false, sizeof(dmat));\n\t\tfill(mat[0], mat[0] + MAX * MAX, INF);\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tmat[i][i] = 0;\n\n\t\twhile(n--) {\n\t\t\tinput();\n\n\t\t\tif(!convert.count(a))\n\t\t\t\tconvert.insert(make_pair(a, convert.size()));\n\n\t\t\tif(!convert.count(b))\n\t\t\t\tconvert.insert(make_pair(b, convert.size()));\n\n\t\t\tconst int a_id = convert[a], b_id = convert[b];\n\t\t\tdmat[a_id][b_id] = mat[a_id][b_id] = mat[b_id][a_id] = 1;\n\t\t}\n\n\t\tnum = convert.size();\n\t\tfor(int k = 0; k < num; ++k)\n\t\t\tfor(int i = 0; i < num; ++i)\n\t\t\t\tfor(int j = 0; j < num; ++j)\n\t\t\t\t\tchmin(mat[i][j], mat[i][k] + mat[k][j]);\n\n\t\tvector<vector<bool> > same(num, vector<bool>(num, false));\n\t\tfor(int i = 0; i < num; ++i) {\n\t\t\tfor(int j = i + 1; j < num; ++j) {\n\t\t\t\tif(dmat[i][j] || dmat[j][i] || (mat[i][j] & 1))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbool is_same = false;\n\n\t\t\t\tfor(int k = 0; k < num; ++k) {\n\t\t\t\t\tif((dmat[i][k] && dmat[j][k]) || (dmat[k][i] && dmat[k][j]))\n\t\t\t\t\t\tis_same = true;\n\n\t\t\t\t\tif((dmat[i][k] && dmat[k][j]) || (dmat[j][k] && dmat[k][i]))\n\t\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tsame[i][j] = same[j][i] = is_same;\n\t\t\tnext:;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tfor(int j = 0; j < num; ++j)\n\t\t\t\tdmat[i][j] |= same[i][j];\n\n\t\tint m;\n\t\tcin >> m;\n\n\t\twhile(m--) {\n\t\t\tinput();\n\t\t\tif(!(convert.count(a) && convert.count(b))) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcout << (check(convert[a], convert[b]) ? \"YES\" : \"NO\") << endl;\t\t\t\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint M;\nmap<string,int> mp;\nbool e[200][200],ee[200][200];\nint t[200];\nvoid dfs(int x,int c){\n\tt[x]=c;\n\trep(i,200) if(e[x][i]&&t[i]==0) dfs(i,-c);\n\trep(i,200) if(e[i][x]&&t[i]==0) dfs(i,-c);\n}\nint main(){\n\twhile(true){\n\t\tcin>>M;\n\t\tif(M==0) break;\n\t\tmp.clear();\n\t\trep(i,200) rep(j,200) e[i][j]=0,ee[i][j]=(i==j);\n\t\trep(i,200) t[i]=0;\n\t\tint J=0;\n\t\trep(i,M){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tif(!mp.count(xx)) mp[xx]=J++;\n\t\t\tif(!mp.count(yy)) mp[yy]=J++;\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\te[x][y]=1;\n\t\t}\n\t\tint N=mp.size();\n\t\tcout<<N<<endl;\n\t\tint I=1;\n\t\trep(i,N) if(t[i]==0) dfs(i,I++);\n\t\trep(i,N) rep(j,N) rep(k,N){\n\t\t\tif((e[i][k]||e[k][i])&&(e[j][k]||e[k][j])&&!(e[i][k]&&e[k][j])&&!(e[j][k]&&e[k][i])) ee[i][j]=1;\n\t\t}\n\t\trep(i,N) rep(j,N) e[i][j]|=ee[i][j];\n\t\trep(i,N) rep(j,N) rep(k,N) if(e[j][i]&&e[i][k]) e[j][k]=1;\n\t\tint Q;\n\t\tcin>>Q;\n\t\trep(tt,Q){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\tif(t[x]==-t[y]&&e[x][y]) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\n#include <cassert>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\n\nconst int VMAX = 210;\nint N, M;\nmap<string, int> mp;\nbool e[VMAX][VMAX];\nbool ee[VMAX][VMAX];\nint t[VMAX];\n\nvoid dfs(int v, int c){\n    t[v] = c;\n    for(int i=0; i<mp.size(); i++) if(i != v && (e[v][i] || e[i][v])){\n        if(t[i]) assert(t[i] == -c);\n        else dfs(i, -c);\n    }\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin >> N, N){\n        //init\n        mp.clear();\n        for(int i=0; i<VMAX; i++){\n            for(int j=0; j<VMAX; j++){\n                e[i][j] = ee[i][j] = i == j;\n            }\n            t[i] = 0;\n        }\n        \n        string st;\n        for(int i=0; i<N; i++){\n            cin >> st;\n            int j = 0;\n            while(st[j]!='-') j++;\n            string xx = st.substr(0, j);\n            string yy = st.substr(j+1, st.size()-j);\n            if(!mp.count(xx)) mp[xx] = mp.size();\n            if(!mp.count(yy)) mp[yy] = mp.size();\n            e[mp[xx]][mp[yy]] = true;\n        }\n        \n        int J = 1;\n        for(int i=0; i<mp.size(); i++){\n            if(t[i] == 0)\n                dfs(i, J++);\n        }\n        \n        for(int i=0; i<mp.size(); i++){\n            for(int j=0; j<mp.size(); j++) if(i != j){\n                bool fc = false;\n                bool fd = false;\n                for(int k=0; k<mp.size(); k++) if(k != i && k != j){\n                    fc |= (e[i][k] && e[j][k]) || (e[k][i] && e[k][j]);\n                    fd |= (e[i][k] && e[k][j]) || (e[j][k] && e[k][i]);\n                }\n                ee[i][j] = fc && !fd;\n            }\n        }\n        \n        for(int i=0; i<mp.size(); i++)\n            for(int j=0; j<mp.size(); j++)\n                e[i][j] |= ee[i][j];\n        \n        for(int k=0; k<mp.size(); k++)\n            for(int i=0; i<mp.size(); i++)\n                for(int j=0; j<mp.size(); j++)\n                    e[i][j] |= e[i][k] && e[k][j];\n        \n        cin >> M;\n        cout << mp.size() << endl;\n        for(int i=0; i<M; i++){\n            cin >> st;\n            int j = 0;\n            while(st[j]!='-') j++;\n            string xx = st.substr(0, j);\n            string yy = st.substr(j+1, st.size()-j);\n            \n            bool flag;\n            if(mp.count(xx) && mp.count(yy)){\n                int x = mp[xx], y = mp[yy];\n                flag = e[x][y] && !ee[x][y] && t[x] == -t[y];\n            }else{\n                flag = false;\n            }\n            cout << (flag? \"YES\": \"NO\") << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\n#include <cassert>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\n\nconst int VMAX = 210;\nint N, M;\nmap<string, int> mp;\nbool e[VMAX][VMAX];\nbool ee[VMAX][VMAX];\nint t[VMAX];\n\nvoid dfs(int v, int c){\n    t[v] = c;\n    for(int i=0; i<mp.size(); i++) if(i != v && (e[v][i] || e[i][v])){\n        if(t[i]) assert(t[i] == -c);\n        else dfs(i, -c);\n    }\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin >> N, N){\n        //init\n        mp.clear();\n        for(int i=0; i<VMAX; i++){\n            for(int j=0; j<VMAX; j++){\n                e[i][j] = ee[i][j] = i == j;\n            }\n            t[i] = 0;\n        }\n        \n        string st;\n        for(int i=0; i<N; i++){\n            cin >> st;\n            int j = 0;\n            while(st[j]!='-') j++;\n            string xx = st.substr(0, j);\n            string yy = st.substr(j+1);\n            if(!mp.count(xx)) mp[xx] = mp.size();\n            if(!mp.count(yy)) mp[yy] = mp.size();\n            e[mp[xx]][mp[yy]] = true;\n        }\n        \n        int J = 1;\n        for(int i=0; i<mp.size(); i++){\n            if(t[i] == 0)\n                dfs(i, J++);\n        }\n        \n        for(int i=0; i<mp.size(); i++){\n            for(int j=0; j<mp.size(); j++) if(i != j){\n                bool fc = false;\n                bool fd = false;\n                for(int k=0; k<mp.size(); k++) if(k != i && k != j){\n                    fc |= (e[i][k] && e[j][k]) || (e[k][i] && e[k][j]);\n                    fd |= (e[i][k] && e[k][j]) || (e[j][k] && e[k][i]);\n                }\n                ee[i][j] = fc && !fd;\n            }\n        }\n        \n        for(int i=0; i<mp.size(); i++)\n            for(int j=0; j<mp.size(); j++)\n                e[i][j] |= ee[i][j];\n        \n        for(int k=0; k<mp.size(); k++)\n            for(int i=0; i<mp.size(); i++)\n                for(int j=0; j<mp.size(); j++)\n                    e[i][j] |= e[i][k] && e[k][j];\n        \n        cin >> M;\n        cout << mp.size() << endl;\n        for(int i=0; i<M; i++){\n            cin >> st;\n            int j = 0;\n            while(st[j]!='-') j++;\n            string xx = st.substr(0, j);\n            string yy = st.substr(j+1);\n            \n            bool flag;\n            if(mp.count(xx) && mp.count(yy)){\n                int x = mp[xx], y = mp[yy];\n                flag = e[x][y] && !ee[x][y] && t[x] == -t[y];\n            }else{\n                flag = false;\n            }\n            cout << (flag? \"YES\": \"NO\") << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)n;i++)\nconst int INF = (1<<29) + 1;\n\nint n, m;\n\ntemplate<typename T>\nstruct Serializer{\n\tmap<T, int> enc;\n\tvector<T> dec;\n\tint operator()(const T &t){\n\t\tauto it = enc.find(t);\n\t\tif(it != enc.end()) return it->second;\n\t\tdec.push_back(t);\n\t\treturn enc[t] = dec.size() - 1;\n\t}\n\tsize_t size(){\n\t\treturn dec.size();\n\t}\n};\n\nint g[201][201], g2[201][201];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tSerializer<string> se;\n\t\tREP(i, 200)REP(j, 200)\n\t\t\tg[i][j] = g2[i][j] = i == j ? 0 : INF;\n\t\tREP(i, n){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tg[u][v] = g2[u][v] = g2[v][u] = 1;\n\t\t}\n\t\tn = se.size();\n\t\tREP(i, n)REP(j, i){\n\t\t\tint f = 0;\n\t\t\tREP(k, n){\n\t\t\t\tif(g[i][k] == 1 && g[k][j] == 1 || g[j][k] == 1 && g[k][i] == 1){\n\t\t\t\t\tf = 0; break;\n\t\t\t\t}\n\t\t\t\tif(g[i][k] == 1 && g[j][k] == 1 || g[k][i] == 1 && g[j][i] == 1)\n\t\t\t\t\tf = 1;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tg[i][j] = g[j][i] = 501;\n\t\t\t}\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tREP(k, n)REP(i, n)REP(j, n) g2[i][j] = min(g2[i][j], g2[i][k] + g2[k][j]);\n\t\tcout << n << endl;\n\t\tcin >> m;\n\t\tREP(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint p = s.find('-');\n\t\t\tint u = se(s.substr(0, p));\n\t\t\tint v = se(s.substr(p+1));\n\t\t\tif((g2[u][v] & 1) && g[u][v] < INF) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<string,int> M;\n\nint str2int(string S){\n    if(M.find(S)==M.end()){\n        int n = M.size();\n        M[S]=n;\n    }\n    return M[S];\n}\n\nint E[200][200];//[a][b]=a to b\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        fill(E[0],E[200],10000);\n        M.clear();\n        for(int i=0;i<N;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    E[i1][i2]=1;\n                    break;\n                }\n            }\n        }\n        int m = M.size();\n        cout<<m<<endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<m;j++){\n                if(E[i][j]==1||E[j][i]==1) continue;\n                //cond1\n                bool b=false;\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[i][k]==1||E[k][i]==1)&&(E[j][k]==1||E[k][j]==1)){\n                        b=true;\n                        break;\n                    }\n                }\n                //cond2,3\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[k][i]==1&&E[j][k]==1)||(E[i][k]==1&&E[k][j]==1)){\n                        b=false;\n                        break;\n                    }\n                }\n                if(b) E[i][j]=E[j][i]=0;\n            }\n        }\n        //WF\n        for(int i=0;i<m;i++) E[i][i]=0;\n        for(int k=0;k<m;k++){\n            for(int i=0;i<m;i++){\n                for(int j=0;j<m;j++){\n                    E[i][j]=min(E[i][j],E[i][k]+E[k][j]);\n                }\n            }\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    if(i1>=m||i2>=m||E[i1][i2]%2==0){\n                        cout<<\"NO\"<<endl;\n                    }else{\n                        cout<<\"YES\"<<endl;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\tvs res;\n\tres.push_back(l); res.push_back(r);\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p;\n\t\t\tp++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] || dist[k][i]) && (dist[j][k] || dist[k][j])) f1 = true;\n\t\t\t\tif ((dist[i][k] && dist[k][j]) || (dist[k][i] && dist[j][k])) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p)\n\t\t{\n\t\t\tif (dist[i][k] && dist[k][j]) dist[i][j] = 1;\n\t\t}\n\t\tvi color(p);\n\t\tint col = 1;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i]) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = -col;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to]) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol++;\n\t\t}\n\t\tcout << p << endl;\n\t\tint q;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif (color[l] == -color[r] && dist[r][l])\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//1818\n#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define EPS 0.000001\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\n\n\nint main(){\n\tint n,m;\n\twhile(cin >> n){\n\t\tif(n==0) break;\n\t\tint c=0;\n\t\tmap<string,int> mp;\n\t\tchar in1[50],in2[50];\n\t\tstatic int g[401][401];\n\t\tint i,j,k;\n\t\tfor(i=0;i<201;i++) for(j=0;j<201;j++) g[i][j]=INF;\n\t\t\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%s\",in1);\n\t\t\tstring x,y,in=in1;\n\t\t\tfor(j=0;j<in.length(),in[j]!='-';j++) x+=in[j];\n\t\t\tj++;\n\t\t\tfor(;j<in.length();j++) y+=in[j];\n\t\t\tif(mp.find(x)==mp.end()) mp.insert(pair<string,int>(x,c++));\n\t\t\tif(mp.find(y)==mp.end()) mp.insert(pair<string,int>(y,c++));\n\t\t\tg[(*mp.find(x)).second][(*mp.find(y)).second]=1;\n\t\t}\n\t\t\n\t\tfor(i=0;i<c;i++){\n\t\t\tfor(j=i+1;j<c;j++){\n\t\t\t\tif(g[i][j]==INF && g[j][i]==INF){\n\t\t\t\t\tint f=INF;\n\t\t\t\t\tfor(k=0;k<c;k++){\n\t\t\t\t\t\tif(k==i || k==j) continue;\n\t\t\t\t\t\tif(f!=-1 && g[i][k]==1 && g[j][k]==1) f=0;\n\t\t\t\t\t\tif(f!=-1 && g[k][i]==1 && g[k][j]==1) f=0;\n\t\t\t\t\t\tif(g[i][k]==1 && g[k][j]==1) f=-1;\n\t\t\t\t\t\tif(g[j][k]==1 && g[k][i]==1) f=-1;\n\t\t\t\t\t}\n\t\t\t\t\tif(f==-1) f=INF;\n\t\t\t\t\tg[i][j]=f;\n\t\t\t\t\tg[j][i]=f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<c;k++){\n\t\t\tfor(i=0;i<c;i++){\n\t\t\t\tfor(j=0;j<c;j++){\n\t\t\t\t\tif(g[i][j] > g[i][k]+g[k][j]) g[i][j]=g[i][k]+g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << c << endl;\n\t/*\tfor(i=0;i<c;i++){\n\t\t\tfor(j=0;j<c;j++){\n\t\t\t\tcout << (g[i][j]==INF?-1:g[i][j]) << '\t';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcin >> m;\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%s\",in1);\n\t\t\tstring x,y,in=in1;\n\t\t\tfor(j=0;j<in.length(),in[j]!='-';j++) x+=in[j];\n\t\t\tj++;\n\t\t\tfor(;j<in.length();j++) y+=in[j];\n\t\t\t\n\t\t\tif(mp.find(x)==mp.end() || mp.find(y)==mp.end()) printf(\"NO\\n\");\n\t\t\telse if(g[(*mp.find(x)).second][(*mp.find(y)).second]<INF && g[(*mp.find(x)).second][(*mp.find(y)).second]%2==1){\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\npair<string, string> read(){\n  string str;\n  pair<string, string> res;\n  cin >> str;\n  replace(ALL(str), '-', ' ');\n  istringstream iss(str);\n  iss >> res.first >> res.second;\n  return res;\n}\n\nint main(){\n  int N, M;\n  const int INF = 1e9;\n  while (cin >> N && N){\n    string A, B;\n    map<string, int> I;\n    map<int, string> S;\n    map<int, vector<int> > E, R;\n    \n    REP(i, N){\n      tie(A, B) = read();\n      if (I.count(A) == 0) {\n        int id = I.size();\n        I[A] = id;\n        S[I[A]] = A;\n      }\n\n      if (I.count(B) == 0) {\n        int id = I.size();\n        I[B] = id;\n        S[I[B]] = B;\n      }\n      E[I[A]].push_back(I[B]);\n      R[I[B]].push_back(I[A]);\n    }\n\n    int n = I.size();\n    REP(i, n){\n      sort(ALL(E[i]));\n      sort(ALL(R[i]));\n    }\n\n    vector<vector<int> > D_(n, vector<int>(n, 0));\n    REP(u, n) for (int v : E[u]) D_[u][v] = true;\n\n    \n    vector<vector<int> > D(n, vector<int>(n, INF));\n    REP(i, n) REP(j, i){\n      bool ok = false;\n      REP(k, n) if ((D_[i][k] || D_[k][i]) && (D_[j][k] || D_[k][j])) ok= true;\n      REP(k, n) if (D_[i][k] && D_[k][j]) ok = false;\n      REP(k, n) if (D_[k][i] && D_[j][k]) ok = false;\n      if (ok) D[i][j] = D[j][i] = 0;\n    }\n    REP(i, n) REP(j, n) if (D_[i][j]) D[i][j] = 1;\n    \n    REP(k, n) REP(i, n) REP(j, n) D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n    \n    cout << n << endl;\n    cin >> M;\n    REP(i, M){\n      tie(A, B) = read();\n      if (D[I[A]][I[B]] % 2 == 1) cout << \"YES\" << endl;\n      else cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\nmap<string,int> rtoi;\nint d[256][256];\nint V;\n\nvoid solve(){\n    rep(i,V)rep(j,V){\n        bool C=false, DE=true;\n        if(d[i][j]==1 || d[j][i]==1) continue;\n        rep(k,V){\n            if(k==i || k==j) continue;\n            if((d[i][k]==1||d[k][i]==1) && (d[j][k]==1||d[k][j]==1))\n                C=true;\n            if((d[i][k]==1&&d[k][j]==1) || (d[k][i]==1&&d[j][k]==1))\n                DE=false;\n        }\n        if(C&&DE) d[i][j]=d[j][i]=0;\n    }\n    rep(k,V)rep(i,V)rep(j,V){\n        d[i][j]=min(d[i][j], d[i][k] + d[k][j]);\n    }\n}\n\nbool ask(string const& p, string const& q){\n    int pi=inf,qi=inf;\n    if(rtoi.count(p)==1 || rtoi.count(q)==1){\n        pi=rtoi[p], qi=rtoi[q];\n    }\n    return d[pi][qi]!=inf && d[pi][qi]&1;\n}\n\nint main(){\n    int n;\n    while(cin>>n, n){\n        rep(i,256) rep(j,256) d[i][j]=inf;\n        rep(i,n){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x);\n            string q=s.substr(x+1);\n            if(rtoi.count(p)==0)rtoi[p]=V++;\n            if(rtoi.count(q)==0)rtoi[q]=V++;\n            int ip=rtoi[p], iq=rtoi[q];\n            d[ip][iq]=1;\n        }\n        // solve();\n        cout<<V<<endl;\n        int m; cin>>m;\n        rep(i,m){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x), q=s.substr(x+1);\n            puts(ask(p,q)  ? \"YES\" : \"NO\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing ps = pair<string,string>;\n\nps split(string s){\n    int n = s.size();\n    int idx = 0;\n    while(idx<n && s[idx]!='-') ++idx;\n\n    return {s.substr(0,idx), s.substr(idx+1)};\n}\n\nconst int N = 200;\nconst int INF = 101010;\n\n// 入力から分かる強さ関係\nvector<int> G[N];\nbool arr[N][N];\n\nint d[N][N];\n\n// 水準関係\nint C[N][N];\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        rep(i,N) G[i].clear();\n        rep(i,N)rep(j,N) arr[i][j] = false;\n\n        rep(i,N)rep(j,N) d[i][j]=INF;\n        rep(i,N) d[i][i]=0;\n\n        rep(i,N)rep(j,N) C[i][j]=INF;\n        rep(i,N) C[i][i]=0;\n\n        map<string,int> c2id;\n        vector<string> names;\n        rep(i,n){\n            string s;\n            cin >>s;\n            ps cross = split(s);\n\n            if(!c2id.count(cross.fi)){\n                c2id[cross.fi] = c2id.size();\n                names.pb(cross.fi);\n            }\n            if(!c2id.count(cross.se)){\n                c2id[cross.se] = c2id.size();\n                names.pb(cross.se);\n            }\n            int u = c2id[cross.fi], v = c2id[cross.se];\n            G[u].pb(v);\n            C[u][v]=1;\n            d[u][v] = d[v][u] = 1;\n            arr[u][v] = true;\n        }\n\n        int V = c2id.size();\n\n        rep(k,V)rep(i,V)rep(j,V) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        auto same_degree = [&](int a, int b){\n            bool same = false;\n            rep(i,V){\n                if( (arr[a][i]||arr[i][a]) && (arr[b][i]||arr[i][b]) ) same = true;\n            }\n            if(!same) return false;\n\n            rep(i,V){\n                if(arr[i][a]&&arr[b][i]) return false;\n                if(arr[a][i]&&arr[i][b]) return false;\n            }\n            return true;\n        };\n\n        rep(i,V)rep(j,i){\n            if(same_degree(i,j)){\n                // cout << \"DEG :: \" << names[i] << \" \" << names[j] << endl;\n                C[i][j] = C[j][i] = 1;\n            }\n        }\n        rep(k,V)rep(i,V)rep(j,V) C[i][j] = min(C[i][j], C[i][k]+C[k][j]);\n\n        cout << V << endl;\n\n        int Q;\n        cin >>Q;\n        while(Q--){\n            string q;\n            cin >>q;\n\n            ps qc = split(q);\n\n            bool ok = false;\n            if(c2id.count(qc.fi) && c2id.count(qc.se)){\n                int u = c2id[qc.fi], v = c2id[qc.se];\n                // dbg(C[u][v]);\n\n                if(d[u][v]%2==1 && C[u][v]<INF) ok = true;\n            }\n            cout << (ok?\"YES\":\"NO\") << endl;\n        }\n        // dbg(c2id.size());\n        // dbg(names);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n#define pb push_back\n#define pf push_front\n#define rep(i,n) for (int i=0; i < (n); i++)\n#define all(c) (c).begin(), (c).end()\n \nstruct michi{\n  VS upper,lower;\n  char verti;\n  bool check;\n};\nmap<string,michi> mamap;\nvoid nocheck(){\n  for(map<string,michi>::iterator a=mamap.begin();\n      a!=mamap.end();a++){\n    a->second.check=false;\n  }\n}\nbool jouge(VS upper,VS lower){\n    for(VS::iterator a=upper.begin();\n      a!=upper.end();a++){\n      for(VS::iterator b=lower.begin();\n\t  b!=lower.end();b++){\n\tif(*a==*b) return true;\n      }\n\n    }\n    return false;\n}\n \nbool searchup(string desti,string pres){\n  // cout<<pres<<\" dddddddd    \";\n  if(mamap[pres].check) return false;\n  mamap[pres].check=true;\n   \n  if(desti==pres) return true;\n  VS dolist=mamap[pres].lower;\n  VS uplist=mamap[pres].upper;\n  //  cout<<uplist.size();\n  for(VS::iterator a=dolist.begin();\n      a!=dolist.end();a++){\n    //    cout<<*a<<\"  keke\";\n    VS uup=mamap[*a].upper;\n    for(VS::iterator b=uup.begin();\n\tb!=uup.end();b++){\n      if(jouge(dolist,mamap[*b].upper)) continue;\n      if(jouge(uplist,mamap[*b].lower)) continue;\n      if(searchup(desti,*b)) return true; \n    }\n  }  \n  for(VS::iterator a=uplist.begin();\n      a!=uplist.end();a++){\n    //    cout<<*a<<\"  keke\";\n    VS uup=mamap[*a].lower;\n    for(VS::iterator b=uup.begin();\n\tb!=uup.end();b++){\n      if(jouge(dolist,mamap[*b].upper)) continue;\n      if(jouge(uplist,mamap[*b].lower)) continue;\n      if(searchup(desti,*b)) return true; \n    }\n  }    \n  \n  for(VS::iterator a=uplist.begin();\n      a!=uplist.end();a++){\n    //    cout<<*a<<\"  keke\";\n    if(searchup(desti,*a)) return true;  \n  }\n \n  return false;\n}\nbool sesearch(string fir,string sec){\n  michi strong,weak;\n  strong=mamap[fir];\n  weak=mamap[sec];\n  // cout<<endl<<endl<<endl<<fir<<sec<<endl;\n  // cout<<(int)strong.verti<<(int)weak.verti<<endl;\n  if(strong.verti==weak.verti) return false;\n \n  nocheck();\n  if(searchup(fir,sec)) return true;\n  // if(searchup(sec,fir)){\n  //   cout<<\"hehe\";\n  //   nocheck();\n  //   if(searchup(fir,sec)) return true;\n  //   else return false;\n  // }\n  return false;\n}\nvoid vertisho(string fir,char vert){\n  if(mamap[fir].verti!=-1) return; \n  mamap[fir].verti=vert;\n \n  if(vert==1) vert=0;\n  else if(vert==0) vert=1;\n  //cout<<fir<<\" \"<<(int)mamap[fir].verti<<endl;\n  for(VS::iterator a=mamap[fir].upper.begin();\n      a!=mamap[fir].upper.end();a++){\n    //    cout<<*a<<endl;\n    vertisho(*a,vert);\n  }\n  for(VS::iterator a=mamap[fir].lower.begin();\n      a!=mamap[fir].lower.end();a++)\n    vertisho(*a,vert);\n}\nvoid wakeru(string& a,string& b){\n  int i;\n  string tmp;\n  cin>>tmp;\n  for(i=0;i<tmp.size();i++){\n    if(tmp[i]=='-') break;\n  }\n  a=tmp.substr(0,i);\n  b=tmp.substr(i+1);\n  // cout<<a<<endl<<b<<endl;\n \n}\n \nint main() {\n  int n,m,tmptmp;\n  string fir,sec,tmpst;\n  michi ue,sita;\n  while(true){\n    mamap=map<string,michi>();\n    cin>>n;\n    if(n==0) return 0;\n    //    cout<<\"n:\"<<n<<\"m:\"<<m<<endl;\n    rep(i,n){\n      wakeru(fir,sec);\n      //cin>>fir>>sec;\n      //cout<<fir<<endl<<sec<<endl;\n      // mamap[fir].lower.pb[sec];\n      // mamap[sec].upper.pb[fir];\n      ue=mamap[fir];\n      sita=mamap[sec];\n      ue.lower.pb(sec);\n      sita.upper.pb(fir);\n      mamap[fir]=ue;\n      mamap[sec]=sita;\n    }\n     for(map<string,michi>::iterator a=mamap.begin();\n      a!=mamap.end();a++){\n       a->second.verti=-1;\n       //       cout<<a->first<<(int)a->second.verti<<endl;\n    }\n     nocheck();\n     vertisho(fir,0);\n     cout<<mamap.size()<<endl;\n     cin>>m;\n     rep(i,m){\n       wakeru(fir,sec);\n \n       //cout<<fir<<endl<<sec<<endl;\n       nocheck();\n       if(sesearch(fir,sec)) cout<<\"YES\"<<endl;\n       else cout<<\"NO\"<<endl;\n       \n     }\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\nmap<string,int> rtoi;\nint d[256][256];\nint V;\n\nvoid solve(){\n    rep(i,V)rep(j,V){\n        bool C=false, DE=true;\n        if(d[i][j]==1 || d[j][i]==1) continue;\n        rep(k,V){\n            if(k==i || k==j) continue;\n            if((d[i][k]==1||d[k][i]==1) && (d[j][k]==1||d[k][j]==1))\n                C=true;\n            if((d[i][k]==1&&d[k][j]==1) || (d[k][i]==1&&d[j][k]==1))\n                DE=false;\n        }\n        if(C&&DE) d[i][j]=d[j][i]=0;\n    }\n    rep(k,V)rep(i,V)rep(j,V){\n        d[i][j]=min(d[i][j], d[i][k] + d[k][j]);\n    }\n}\n\nbool ask(string const& p, string const& q){\n    int pi=inf,qi=inf;\n    if(rtoi.count(p)==1 && rtoi.count(q)==1){\n        pi=rtoi[p], qi=rtoi[q];\n    }\n    return max(pi,qi)!=inf && d[pi][qi]!=inf && d[pi][qi]&1;\n}\n\nint main(){\n    int n;\n    while(cin>>n, n){\n        V=0;\n        rtoi.clear();\n        rep(i,256)rep(j,256) d[i][j]=inf;\n        rep(i,n){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x);\n            string q=s.substr(x+1);\n            if(rtoi.count(p)==0)rtoi[p]=V++;\n            if(rtoi.count(q)==0)rtoi[q]=V++;\n            int ip=rtoi[p], iq=rtoi[q];\n            d[ip][iq]=1;\n        }\n        solve();\n        cout<<V<<endl;\n        int m; cin>>m;\n        rep(i,m){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x), q=s.substr(x+1);\n            puts(ask(p,q) ? \"YES\" : \"NO\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n#include <cstring>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define pii pair<int,int>\n\n#define MAXT 200\n\nbool graph[MAXT][MAXT]={};\nbool graph2[MAXT][MAXT]={};\nint color[MAXT];\n\nvoid dfs(int a, int base){\n    rep(i,MAXT){\n        if(color[i]==0 && (graph[a][i]||graph[i][a])){\n            color[i]=-color[a];\n            dfs(i,base);\n        }\n    }\n}\n\nvoid read(string &s1, string &s2){\n    string s;\n    cin>>s;\n    int i=s.find_first_of('-');\n    s1=s.substr(0, i);\n    s2=s.substr(i+1);\n}\n\nint main(){\n    while(1){\n        fill_n(*graph, MAXT*MAXT, false);\n        fill_n(*graph2, MAXT*MAXT, false);\n        fill_n(color, MAXT, 0);\n\n        int N,M;\n        cin>>N;\n        if(N==0) break;\n        map<string,int> lnames;\n        int lindex = 0;\n        rep(ii,N){\n            string s1,s2;\n            read(s1,s2);\n            //cout<<s1<<\" \"<<s2<<endl;\n            if(!lnames.count(s1)){\n                lnames[s1] = lindex++;\n            }\n            if(!lnames.count(s2)){\n                lnames[s2] = lindex++;\n            }\n            graph[lnames[s1]][lnames[s2]]=true;\n            //cout<<lnames[s1]<<\" \"<<lnames[s2]<<endl;\n        }\n\n        /*rep(i,lindex){\n            rep(j,lindex){\n                cout<<graph[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n\n        int base=1;\n        rep(i,lindex){\n            if(color[i]!=0) continue;\n            color[i]=base;\n            dfs(i,base);\n            base++;\n        }\n\n        rep(i,lindex){\n            rep(j,lindex){\n                bool fa = false,fb=true;\n                rep(k,lindex){\n                    if((graph[i][k] || graph[k][i]) && (graph[j][k] || graph[k][j])){\n                        fa = true;\n                    }\n                    if((graph[k][i] && graph[j][k]) || (graph[i][k] && graph[k][j])){\n                        fb=false;break;\n                    }\n                }\n                if(fa&&fb){\n                    graph2[i][j] = true;\n                    graph2[j][i] = true;\n                }\n            }\n        }\n        rep(i,lindex){\n            rep(j,lindex){\n                graph[i][j] |= graph2[i][j];\n            }\n        }\n\n        rep(k,lindex){\n            rep(i,lindex){\n                rep(j,lindex){\n                    if(graph[i][k] && graph[k][j]){\n                        graph[i][j]=true;\n                    }\n                }\n            }\n        }\n\n        /*cout<<endl;\n        rep(i,lindex){\n            rep(j,lindex){\n                cout<<graph[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n\n        cout<<lindex<<endl;\n\n        cin>>M;\n        rep(ii,M){\n            string s1,s2;\n            read(s1,s2);\n\n            if(!lnames.count(s1) || !lnames.count(s2)){\n                cout<<\"NO\"<<endl;\n            }\n            else\n            {\n                int p1=lnames[s1], p2=lnames[s2];\n                if(graph[p1][p2] && color[p1] != color[p2] && color[p1] + color[p2] == 0){\n                    cout<<\"YES\"<<endl;\n                }\n                else\n                {\n                    cout<<\"NO\"<<endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n  bool used[201];\n  map<string,int>m;\n  char qq;\n  vector<int>mg[201],yg[201];\n  int o,a[201];\n  int c=1;\n  scanf(\"%c\",&qq);\n  for(int i=0;i<n;i++){\n    string s1,s2;\n    int ccc=0;\n    while(1){\n      char cc;\n      scanf(\"%c\",&cc);\n      if(cc=='\\n')break;\n      if(cc=='-'){ccc++;continue;}\n      if(!ccc)s1+=cc;\n      else s2+=cc;\n    }//cout<<s1<<endl<<s2<<endl;\n    if(!m[s1])m[s1]=c++;\n    if(!m[s2])m[s2]=c++;\n    yg[m[s1]].push_back(m[s2]);\n    mg[m[s1]].push_back(m[s2]);\n    mg[m[s2]].push_back(m[s1]);\n  }\n  r(i,201)used[i]=0;\n  queue<pair<int,int> >q;\n  q.push(mk(1,0));\n  while(!q.empty()){\n      pair<int,int>p=q.front();q.pop();\n      a[p.f]=p.s%2;\n      r(i,mg[p.f].size())\n    if(!used[mg[p.f][i]]){\n      q.push(mk(mg[p.f][i],p.s+1));\n      used[mg[p.f][i]]=1;\n    }\n  }\n    cout<<c-1<<endl;\n    cin>>o;\n    char kl;\n    scanf(\"%c\",&kl);\n    while(o--){//cout<<1;\n      string s1,s2;\n      int ccc=0,u=0;\n      while(1){\n        char cc;\n        scanf(\"%c\",&cc);\n        if(cc=='\\n')break;\n        if(cc=='-'){ccc++;continue;}\n        if(!ccc)s1+=cc;\n        else s2+=cc;\n      }\n      if(a[m[s1]]==a[m[s2]])cout<<\"No\"<<endl;\n      else if(!m[s1])cout<<\"No\"<<endl;\n      else if(!m[s2])cout<<\"No\"<<endl;\n      else{//cout<<1;\n    r(i,201)used[i]=0;\n    queue<int>p;\n    p.push(m[s1]);\n    used[m[s1]]=1;\n    while(!p.empty()){\n      int t=p.front();p.pop();\n      r(i,yg[t].size())\n        if(!used[yg[t][i]]){\n          if(yg[t][i]==m[s2]){cout<<\"Yes\"<<endl;u++;goto KKK;}\n          p.push(yg[t][i]);\n          used[yg[t][i]]=1;\n        }\n    }//cout<<1;\n    KKK:;\n    if(!u){r(i,201)used[i]=0;\n      queue<pair<int,int> > w;\n      w.push(mk(m[s2],0));\n    used[m[s2]]=1;\n    while(!w.empty()){\n      pair<int,int> ttt=w.front();w.pop();\n      int t=ttt.first;\n      if(ttt.second>1){cout<<\"No\"<<endl;goto LLL;}\n      r(i,yg[t].size())\n        if(!used[yg[t][i]]){\n          if(yg[t][i]==m[s1]){cout<<\"No\"<<endl;goto LLL;}\n          w.push(mk(yg[t][i],ttt.second+1));\n          used[yg[t][i]]=1;\n        }\n    }\n    cout<<\"Yes\"<<endl;}\n    if(0)LLL:;\n      }\n    }\n  }\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nvoid input_crossing(string &a, string &b){\n    string in;\n    cin >> in;\n    int n = in.length();\n    for(int i=0; i<n; i++){\n        if(in[i] == '-'){\n            a = in.substr(0, i);\n            b = in.substr(i+1, n-i-1);\n            break;\n        }\n    }\n}\n\nint dfs(int curr, int g, vector<vector<pii>> &adj, vector<bool> &used){\n    if(used[curr]) return -1;\n    used[curr] = true;\n    if(curr == g) return 0;\n    \n    for(auto next: adj[curr]){\n        int ret = dfs(next.first, g, adj, used);\n        if(ret != -1){\n            return ret+next.second;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n\n        vector<string> a(n),b(n);\n        int id=0;\n        map<string, int> to_id;\n        for(int i=0; i<n; i++){\n            input_crossing(a[i], b[i]);\n            if(to_id.count(a[i]) == 0){\n                to_id[a[i]] = id++;\n            }\n            if(to_id.count(b[i]) == 0){\n                to_id[b[i]] = id++;\n            }\n        }\n\n        vector<int> aid(n),bid(n);\n        int num_st = to_id.size();\n        vector<vector<pii>> adj(num_st);\n        for(int i=0; i<n; i++){\n            aid[i] = to_id[a[i]];\n            bid[i] = to_id[b[i]];\n            adj[aid[i]].emplace_back(bid[i], 1);\n        }\n        vector<vector<int>> eq(num_st, vector<int>(num_st, 0));\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                if(aid[i]==aid[j] and eq[bid[i]][bid[j]]==0){\n                    eq[bid[i]][bid[j]] = 1;\n                }\n                if(bid[i]==bid[j] and eq[aid[i]][aid[j]]==0){\n                    eq[aid[i]][aid[j]] = 1;\n                }\n                if(aid[i]==bid[j]){\n                    eq[bid[i]][aid[j]] = eq[aid[j]][bid[i]] = -1;\n                }\n            }\n        }\n        for(int i=0; i<num_st; i++){\n            for(int j=i+1; j<num_st; j++){\n                if(eq[i][j] == 1){\n                    adj[i].emplace_back(j, 0);\n                    adj[j].emplace_back(i, 0);\n                }\n            }\n        }\n\n        int m;\n        cin >> m;\n        cout << id << endl;\n        for(int i=0; i<m; i++){\n            string s,g;\n            input_crossing(s, g);\n            if(to_id.count(s)==0 or to_id.count(g)==0){\n            \tcout << \"NO\" << endl;\n            \tcontinue;\n            }\n            vector<bool> used(num_st, false);\n            int ret = dfs(to_id[s], to_id[g], adj, used);\n            if(ret!=-1 and ret%2==1){\n                cout << \"YES\" << endl;\n            }else{\n                cout << \"NO\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint matrix[200][200] = { { 0 } };\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){ break; }\n\t\tfor(int i = 0; i < 200; ++i){\n\t\t\tfor(int j = 0; j < 200; ++j){ matrix[i][j] = 1000; }\n\t\t}\n\t\tmap<string, int> names;\n\t\twhile(N--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tif(names.find(a) == names.end()){\n\t\t\t\tnames.insert(make_pair(a, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tif(names.find(b) == names.end()){\n\t\t\t\tnames.insert(make_pair(b, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tmatrix[ai][bi] = 1;\n\t\t}\n\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\tif(matrix[i][j] <= 2 || matrix[j][i] <= 2){ continue; }\n\t\t\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\t\t\tif(matrix[i][k] == 1 && matrix[j][k] == 1){\n\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(matrix[k][i] == 1 && matrix[k][j] == 1){\n\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint M;\n\t\tcin >> M;\n\t\twhile(M--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tif(names.find(a) == names.end() || names.find(b) == names.end()){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tif(matrix[ai][bi] < 1000){\n\t\t\t\tcout << (matrix[ai][bi] % 2 == 1 ? \"YES\" : \"NO\") << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tcin.ignore();\n\t\t\n\t\tmap<string,int> f;\n\t\tvector<pii> es;\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tgetline(cin,s,'-');\n\t\t\tf.insert(mp(s,f.size()));\n\t\t\tint u=f[s];\n\t\t\tgetline(cin,s);\n\t\t\tf.insert(mp(s,f.size()));\n\t\t\tint v=f[s];\n\t\t\tes.emplace_back(u,v);\n\t\t}\n\t\t\n\t\tn=f.size();\n\t\tvvi g1(n,vi(n));\n\t\tfor(auto e:es){\n\t\t\tint u,v; tie(u,v)=e;\n\t\t\tg1[u][v]=1;\n\t\t}\n\t\t\n\t\tvvi g(n,vi(n,INF));\n\t\trep(i,n) rep(j,n){\n\t\t\trep(k,n) if((g1[i][k]||g1[k][i])&&(g1[j][k]||g1[k][j]))\n\t\t\t\tg[i][j]=0;\n\t\t\trep(k,n) if((g1[i][k]&&g1[k][j])||(g1[j][k]&&g1[k][i]))\n\t\t\t\tg[i][j]=INF;\n\t\t}\n\t\trep(i,n) rep(j,n) if(g1[i][j]) g[i][j]=1;\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\t\n\t\tcout<<n<<endl;\n\t\t\n\t\tint m; cin>>m;\n\t\tcin.ignore();\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tgetline(cin,s,'-');\n\t\t\tint u=f.count(s)?f[s]:-1;\n\t\t\tgetline(cin,s);\n\t\t\tint v=f.count(s)?f[s]:-1;\n\t\t\t\n\t\t\tif(u==-1 || v==-1)\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\telse\n\t\t\t\tcout<<(g[u][v]%2?\"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint N,M;\nmap<string,int> mp;\nbool e[200][200],ee[200][200];\nint t[200];\nvoid dfs(int x,int c){\n\tt[x]=c;\n\trep(i,N){\n\t\tif(e[x][i]&&t[i]==0) dfs(i,-c);\n\t\telse if(e[x][i]) assert(t[i]==-t[x]);\n\t}\n\trep(i,N){\n\t\tif(e[i][x]&&t[i]==0) dfs(i,-c);\n\t\telse if(e[i][x]) assert(t[i]==-t[x]);\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>M;\n\t\tif(M==0) break;\n\t\tmp.clear();\n\t\trep(i,200) rep(j,200) e[i][j]=0,ee[i][j]=(i==j);\n\t\trep(i,200) t[i]=0;\n\t\tint J=0;\n\t\trep(i,M){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tif(!mp.count(xx)) mp[xx]=J++;\n\t\t\tif(!mp.count(yy)) mp[yy]=J++;\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\te[x][y]=1;\n\t\t}\n\t\tN=mp.size();\n\t\tcout<<N<<endl;\n\t\tint I=1;\n\t\trep(i,N) if(t[i]==0) dfs(i,I++);\n\t\trep(i,N) rep(j,N){\n\t\t\tbool a=0,b=1;\n\t\t\trep(k,N){\n\t\t\t\tif((e[i][k]||e[k][i])&&(e[j][k]||e[k][j])) a=1;\n\t\t\t\tif((e[i][k]&&e[k][j])||(e[j][k]&&e[k][i])) b=0;\n\t\t\t}\n\t\t\tif(a&&b) ee[i][j]=1;\n\t\t}\n\t\trep(i,N) rep(j,N) e[i][j]|=ee[i][j];\n\t\trep(i,N) rep(j,N) rep(k,N) if(e[j][i]&&e[i][k]) e[j][k]=1;\n\t\tint Q;\n\t\tcin>>Q;\n\t\trep(tt,Q){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tif(!mp.count(xx)||!mp.count(yy)){\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\tif(t[x]==-t[y]&&e[x][y]) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<tuple>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct edge{\n  int v,f;\n};\n\nmap<string,int> m;\nvector<edge> G[200];\n\nint num(string s){\n  if(!m.count(s)){\n    auto n=m.size();\n    m[s]=n;\n    if(n<200){\n      G[n].clear();\n    }\n  }\n  return m[s];\n}\n\ntuple<int,int> input(){\n  string s;\n  cin>>s;\n  int h=s.find('-');\n  int x=num(s.substr(0,h));\n  int y=num(s.substr(h+1));\n  return make_tuple(x,y);\n}\n\nbool dfs(int x,int y,int f,set<int> &s){\n  if(x==y)return f;\n  if(!s.insert(x).second)return false;\n  for(auto e:G[x]){\n    if(dfs(e.v,y,f^e.f,s))return true;\n  }\n  return false;\n}\n\nint main(){\n  for(int N;cin>>N,N;){\n    m.clear();\n    bool d[200][200]={};\n    for(int i=0;i<N;i++){\n      int x,y;\n      tie(x,y)=input();\n      G[y].push_back({x,1});\n      d[y][x]=true;\n    }\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tfor(int k=0;k<j;k++){\n\t  if(!d[j][k]&&!d[k][j]&&(d[i][j]&&d[i][k]||d[j][i]&&d[k][i])){\n\t    G[j].push_back({k,0});\n\t    G[k].push_back({j,0});\n\t  }\n\t}\n      }\n    }\n    cout<<m.size()<<endl;\n    int M;\n    cin>>M;\n    while(M--){\n      int x,y;\n      tie(x,y)=input();\n      set<int> s;\n      cout<<(dfs(y,x,0,s)?\"YES\":\"NO\")<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint matrix[200][200] = { { 0 } };\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){ break; }\n\t\tfor(int i = 0; i < 200; ++i){\n\t\t\tfor(int j = 0; j < 200; ++j){ matrix[i][j] = 1000; }\n\t\t}\n\t\tmap<string, int> names;\n\t\twhile(N--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tif(names.find(a) == names.end()){\n\t\t\t\tnames.insert(make_pair(a, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tif(names.find(b) == names.end()){\n\t\t\t\tnames.insert(make_pair(b, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tmatrix[ai][bi] = 1;\n\t\t}\n\t\tbool modified = false;\n\t\tdo {\n\t\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmodified = false;\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] <= 2 || matrix[j][i] <= 2){ continue; }\n\t\t\t\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\t\t\t\tif(matrix[i][k] == 1 && matrix[j][k] == 1){\n\t\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matrix[k][i] == 1 && matrix[k][j] == 1){\n\t\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while(modified);\n\t\tint M;\n\t\tcin >> M;\n\t\twhile(M--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tif(matrix[ai][bi] < 1000){\n\t\t\t\tcout << (matrix[ai][bi] % 2 == 1 ? \"YES\" : \"NO\") << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tchar name[20];\n};\n\nint N,table[200][200],index;\nInfo info[200];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nbool check(int A,int B){\n\n\tbool FLG = false;\n\n\tfor(int k = 0; k < index; k++){\n\t\tif(k == A || k == B)continue;\n\n\t\tif((table[k][A] == 1 && table[k][B] == 1) || (table[A][k] == 1 && table[B][k]== 1)){\n\t\t\tFLG = true;\n\t\t}else if((table[k][A] == 1 && table[B][k] == 1) || (table[A][k] == 1 && table[k][B] == 1)){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn FLG;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 200; i++){\n\t\tfor(int k = 0; k < 200; k++){\n\t\t\ttable[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tindex = 0;\n\tint work_index,left_id,right_id,start;\n\tchar buf[40],work[20];\n\n\tbool FLG;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(work_index = 0; buf[work_index] != '-'; work_index++){\n\t\t\twork[work_index] = buf[work_index];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tFLG = false;\n\t\tfor(int k = 0; k < index; k++){\n\t\t\tif(strCmp(info[k].name,work)){\n\t\t\t\tleft_id = k;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tleft_id = index;\n\t\t\tstrcpy(info[index].name,work);\n\t\t\tindex++;\n\t\t}\n\n\t\tstart = work_index+1;\n\n\t\tfor(work_index = 0; buf[start+work_index] != '\\0'; work_index++){\n\t\t\twork[work_index] = buf[start+work_index];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tFLG = false;\n\n\t\tfor(int k = 0; k < index; k++){\n\t\t\tif(strCmp(info[k].name,work)){\n\t\t\t\tright_id = k;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tright_id = index;\n\t\t\tstrcpy(info[index].name,work);\n\t\t\tindex++;\n\t\t}\n\t\ttable[left_id][right_id] = 1;\n\t}\n\n\tfor(int i = 0; i < index-1; i++){\n\t\tfor(int k = i+1; k < index; k++){\n\t\t\tif(check(i,k)){\n\t\t\t\ttable[i][k] = 2;\n\t\t\t\ttable[k][i] = 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int mid = 0; mid < index; mid++){\n\t\tfor(int start = 0; start < index; start++){\n\t\t\tif(table[start][mid] == BIG_NUM)continue;\n\t\t\tfor(int goal = 0; goal < index; goal++){\n\t\t\t\tif(table[mid][goal] == BIG_NUM)continue;\n\t\t\t\ttable[start][goal] = min(table[start][goal],table[start][mid]+table[mid][goal]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",index);\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(work_index = 0; buf[work_index] != '-'; work_index++){\n\t\t\twork[work_index] = buf[work_index];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tFLG = false;\n\t\tfor(int k = 0; k < index; k++){\n\t\t\tif(strCmp(info[k].name,work)){\n\t\t\t\tleft_id = k;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tstart = work_index+1;\n\n\t\tfor(work_index = 0; buf[start+work_index] != '\\0'; work_index++){\n\t\t\twork[work_index] = buf[start+work_index];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tFLG = false;\n\n\t\tfor(int k = 0; k < index; k++){\n\t\t\tif(strCmp(info[k].name,work)){\n\t\t\t\tright_id = k;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(table[left_id][right_id]%2 == 1){\n\t\t\tprintf(\"YES\\n\");\n\t\t}else{\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nmap<string,int> dat;\nint tn;\n\ntypedef pair<string,string> smp;\nsmp gettn(char* s){\n\tint ls=strlen(s);\n\tstring sa,sb;\n\tint hp=0;\n\trep(j,ls)if(s[j]=='-')hp=j;\n\trep(j,hp)sa+=s[j];\n\treg(j,hp+1,ls-1)sb+=s[j];\n\treturn smp(sa,sb);\n}\n\nint strtot(string s,bool re){\n\tif(re){\n\t\tif(dat.find(s)==dat.end()){\n\t\t\t//printf(\"%s %d\\n\",s.c_str(),tn);\n\t\t\tdat[s]=tn; tn++;\n\t\t}\n\t}\n\treturn dat[s];\n}\n\nint vs[205][205];\nint gone[205][2];\n\nvoid dfs(int no,int ty){\n\tif(gone[no][ty])return;\n\tgone[no][ty]=1;\n\trep(to,tn){\n\t\tif(vs[no][to]==0)continue;\n\t\tif(gone[to][1-ty]==1)continue;\n\t\tif(vs[no][to]==1)dfs(to,1-ty);\n\t\telse if(vs[no][to]==2)dfs(to,ty);\n\t}\n}\n\nint main(void){\n\tfor(;;){\n\t\tint n,m;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\ttn=0;\n\t\tdat.clear();\n\t\tmemset(vs,0,sizeof(vs));\n\t\t\n\t\trep(i,n){\n\t\t\tchar s[50];\n\t\t\tscanf(\"%s\",s);\n\t\t\t\n\t\t\tsmp pa=gettn(s);\n\t\t\tint a=strtot(pa.fir,true),\n\t\t\t\tb=strtot(pa.sec,true);\n\t\t\t\n\t\t\tvs[a][b]=1;\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i,tn){\n\t\t\trep(j,tn){\n\t\t\t\tprintf(\"%d \",vs[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t\n\t\tvector<mp> cad;\n\t\trep(i,tn){\n\t\t\trep(j,tn){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tbool has=false,ok=true;\n\t\t\t\trep(k,tn){\n\t\t\t\t\tif(i==k || j==k)continue;\n\t\t\t\t\tif(vs[i][k]==1 && vs[k][j]==1)ok=false;\n\t\t\t\t\tif(vs[k][i]==1 && vs[j][k]==1)ok=false;\n\t\t\t\t\tif(vs[i][k]==1 && vs[j][k]==1)has=true;\n\t\t\t\t\tif(vs[k][i]==1 && vs[k][j]==1)has=true;\n\t\t\t\t\tif(!ok)break;\n\t\t\t\t}\n\t\t\t\tif((!has) || (!ok))continue;\n\t\t\t\tcad.push_back(mp(i,j));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,cad.size()){\n\t\t\tint a=cad[i].fir,b=cad[i].sec;\n\t\t\tvs[a][b]=vs[b][a]=2;\n\t\t}\n\n\n\t\tprintf(\"%d\\n\",dat.size());\n\t\tscanf(\"%d\",&m);\n\t\trep(i,m){\n\t\t\tchar s[50];\n\t\t\tscanf(\"%s\",s);\n\t\t\t\n\t\t\tsmp pa=gettn(s);\n\t\t\tint a=strtot(pa.fir,false),\n\t\t\t\tb=strtot(pa.sec,false);\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tdfs(a,0);\n\t\t\tif(gone[b][1]==1)printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n\n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n\n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define LENGTH 20\nint N, M;\n\n#define INF 1000\n#define MAX 210\nmap<string, int> ids;\nint dmatrix[MAX][MAX];\nint matrix[MAX][MAX];\nint same[MAX][MAX];\nint visited[MAX];\n\nint num;\n\nint get_id(string key)\n{\n\tif (ids.count(key) == 0) return INF;\n\treturn ids[key];\n}\n\nvoid dfs(int id)\n{\n\tif (visited[id]) return;\n\tvisited[id] = true;\n\n\trep(to, num) {\n\t\tif (dmatrix[id][to] || same[id][to]) {\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\n\nbool check(int from, int to)\n{\n\tif (matrix[from][to]%2==0) return false;\n\tmemset(visited, 0, sizeof(visited));\n\t\n\tdfs(from);\n\treturn visited[to];\n}\n\nint main(void)\n{\n\twhile(cin >> N, N) {\n\t\tids.clear();\n\n\t\tmemset(dmatrix, 0, sizeof(dmatrix));\n\t\tmemset(same, 0, sizeof(same));\n\t\tfill(matrix[0], matrix[0]+MAX*MAX, INF);\n\t\trep(i, MAX) matrix[i][i] = 0;\n\n\t\trep(i, N) {\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tstring a, b;\n\t\t\tint pos = line.find('-');\n\t\t\ta = line.substr(0, pos);\n\t\t\tb = line.substr(pos+1);\n\t\t\tif (ids.count(a) == 0)\n\t\t\t\tids.insert(make_pair(a, ids.size()));\n\t\t\tif (ids.count(b) == 0)\n\t\t\t\tids.insert(make_pair(b, ids.size()));\n\n\t\t\tint aid, bid;\n\t\t\taid = get_id(a); bid = get_id(b);\n\t\t\tdmatrix[aid][bid] = true;\n\t\t\tmatrix[aid][bid] = 1;\n\t\t\tmatrix[bid][aid] = 1;\n\t\t}\n\n\t\tnum = ids.size();\n\t\trep(i, num)\n\t\t\trep(j, num)\n\t\t\t\trep(k, num)\n\t\t\t\t\tmatrix[j][k] = min(matrix[j][k], matrix[j][i]+matrix[i][k]);\n\t\trep(i, num) {\n\t\t\tREP(j, i+1, num) {\n\t\t\t\tbool one, two, three;\n\t\t\t\tone = false;\n\t\t\t\ttwo = true;\n\t\t\t\tthree = true;\n\t\t\t\trep(k, num) {\n\t\t\t\t\tif (i == k || j == k) continue;\n\t\t\t\t\tif ((dmatrix[i][k] && dmatrix[j][k])\n\t\t\t\t\t\t|| (dmatrix[k][i] && dmatrix[k][j]))\n\t\t\t\t\t\tone = true;\n\t\t\t\t\tif (dmatrix[k][i] && dmatrix[j][k]) {\n\t\t\t\t\t\ttwo = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (dmatrix[i][k] && dmatrix[k][j]) {\n\t\t\t\t\t\tthree = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (one & two & three) {\n\t\t\t\t\tsame[i][j] = true;\n\t\t\t\t\tsame[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << num << endl;\n\n\t\tcin >> M;\n\t\trep(i, M) {\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tstring a, b;\n\t\t\tint pos = line.find('-');\n\t\t\ta = line.substr(0, pos);\n\t\t\tb = line.substr(pos+1);\n\t\t\tif (ids.count(a) == 0 || ids.count(b) == 0) {\n\t\t\t\tputs(\"NO\");\n\t\t\t} else {\n\t\t\t\tint from, to;\n\t\t\t\tfrom = get_id(a); to = get_id(b);\n\n\t\t\t\tcout << (check(from, to)?\"YES\":\"NO\") << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nchar in[50];\nchar L[50];\nchar R[50];\nint p[500];\nint q[500];\nint UF[500];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint g[310][310];\nint g2[310][310];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<string,int>m;\n\t\tint n=0;\n\t\tfor(int i=0;i<500;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tint at=0;\n\t\t\tint j;\n\t\t\tfor(j=0;in[j]!='-';j++){\n\t\t\t\tL[at]=in[j];at++;\n\t\t\t}L[at]=0;\n\t\t\tat=0;\n\t\t\tj++;\n\t\t\tfor(;in[j];j++){\n\t\t\t\tR[at]=in[j];at++;\n\t\t\t}R[at]=0;\n\t//\t\tprintf(\"%s %s\\n\",L,R);\n\t\t\tstring l=L;\n\t\t\tstring r=R;\n\t\t\tif(m.count(l))p[i]=m[l];\n\t\t\telse{\n\t\t\t\tm[l]=n;\n\t\t\t\tp[i]=n++;\n\t\t\t}\n\t\t\tif(m.count(r)){\n\t\t\t\tq[i]=m[r];\n\t\t\t}else{\n\t\t\t\tm[r]=n;q[i]=n++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[p[i]][q[i]]=1;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)g2[i][j]=0;\n\t\tfor(int i=0;i<n;i++)g2[i][i]=1;\n\t\tfor(int i=0;i<a;i++)g2[p[i]][q[i]]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tbool ok1=false;\n\t\t\t\tbool ok2=true;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(g[i][k]&&g[j][k])ok1=true;\n\t\t\t\t\tif(g[k][i]&&g[k][j])ok1=true;\n\t\t\t\t\tif(g[i][k]&&g[k][j])ok2=false;\n\t\t\t\t\tif(g[j][k]&&g[k][i])ok2=false;\n\t\t\t\t}\n\t\t\t\tif(ok1&&ok2)g2[i][j]=g2[j][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)\n\t\t\tg2[i][j]|=g2[i][k]&g2[k][j];\n\t\tprintf(\"%d\\n\",n);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tUNION(p[i]*2,q[i]*2+1);UNION(p[i]*2+1,q[i]*2);\n\t\t}\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tint at=0;int j;\n\t\t\tfor(j=0;in[j]!='-';j++){\n\t\t\t\tL[at]=in[j];at++;\n\t\t\t}L[at]=0;\n\t\t\tat=0;\n\t\t\tj++;\n\t\t\tfor(;in[j];j++){\n\t\t\t\tR[at]=in[j];at++;\n\t\t\t}R[at]=0;\n\t\t\tstring l=L;string r=R;\n\t\t\tif(!m.count(l)||!m.count(r)){printf(\"NO\\n\");continue;}\n\t\t\tint P=m[l];\n\t\t\tint Q=m[r];\n\t\t\tif(FIND(P*2)!=FIND(Q*2+1)||FIND(P*2+1)!=FIND(Q*2)){printf(\"NO\\n\");continue;}\n\t\t\tif(g2[P][Q])printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll M = 100000007;\n\nll extgcd(ll a,ll b,ll& x,ll& y){\n  ll d = a ;\n  if ( b != 0 ) {\n    d = extgcd( b , a%b , y , x ) ;\n    y -= ( a / b ) * x ;\n  }else{\n    x = 1 ; y = 0 ;\n  }\n  return d;\n}\nll mod_inverse(ll a,ll m){\n  ll x , y ;\n  extgcd( a , m , x , y ) ;\n  return ( m + x % m ) % m ;\n}\n\nll combination(ll N,ll K){\n  ll res = 1;\n  for( int i = 0; i < K; i++ ) res = (res * ((N - i) % M )) % M;\n  for( int i = 1; i <= K; i++ ) res = (res * mod_inverse(i,M)) % M;\n  return res;\n}\n\nint main() {\n\tint cnt = 0;\n\tint mi = M;\n\tint r, c, a1, a2, b1, b2;\n\n\tcin >> r >> c >> a1 >> a2 >> b1 >> b2;\n\tfor ( int i = -1; i <= 1; i++ ) {\n\t\tfor ( int j = -1; j <= 1; j++ ) {\n\t\t\tint c1 = b1+r*i, c2 = b2+c*j;\n\t\t\tmi = min(mi, abs(c1-a1)+abs(c2-a2));\n\t\t}\n\t}\n\t//cout << combination(400, 200) << endl;\n\t//cout << mi << endl;\n\tfor ( int i = -1; i <= 1; i++ ) {\n\t\tfor ( int j = -1; j <= 1; j++ ) {\n\t\t\tint c1 = b1+r*i, c2 = b2+c*j;\n\t\t\tif ( abs(c1-a1)+abs(c2-a2) == mi ) {\n\t\t\t\tcnt += combination(mi, abs(c1-a1));\n\t\t\t\t//cout << cnt << endl;\n\t\t\t\tcnt %= M;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << cnt << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//1818\n#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define EPS 0.000001\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\n\n\nint main(){\n\tint n,m;\n\twhile(cin >> n){\n\t\tif(n==0) break;\n\t\tint c=0;\n\t\tmap<string,int> mp;\n\t\tchar in1[50],in2[50];\n\t\tstatic int g[401][401];\n\t\tint i,j,k;\n\t\tfor(i=0;i<201;i++) for(j=0;j<201;j++) g[i][j]=INF;\n\t\t\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%s\",in1);\n\t\t\tstring x,y,in=in1;\n\t\t\tfor(j=0;j<in.length(),in[j]!='-';j++) x+=in[j];\n\t\t\tj++;\n\t\t\tfor(;j<in.length();j++) y+=in[j];\n\t\t\tif(mp.find(x)==mp.end()) mp.insert(pair<string,int>(x,c++));\n\t\t\tif(mp.find(y)==mp.end()) mp.insert(pair<string,int>(y,c++));\n\t\t\tg[(*mp.find(x)).second][(*mp.find(y)).second]=1;\n\t\t}\n\t\t\n\t\tfor(i=0;i<c;i++){\n\t\t\tfor(j=i+1;j<c;j++){\n\t\t\t\tif(g[i][j]==INF && g[j][i]==INF){\n\t\t\t\t\tint f=INF;\n\t\t\t\t\tfor(k=0;k<c;k++){\n\t\t\t\t\t\tif(k==i || k==j) continue;\n\t\t\t\t\t\tif(g[i][k]==1 && g[j][k]==1) f=0;\n\t\t\t\t\t\tif(g[k][i]==1 && g[k][j]==1) f=0;\n\t\t\t\t\t\tif(g[i][k]==1 && g[k][j]==1) f=INF;\n\t\t\t\t\t\tif(g[j][k]==1 && g[k][i]==1) f=INF;\n\t\t\t\t\t}\n\t\t\t\t\tg[i][j]=f;\n\t\t\t\t\tg[j][i]=f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<c;k++){\n\t\t\tfor(i=0;i<c;i++){\n\t\t\t\tfor(j=0;j<c;j++){\n\t\t\t\t\tif(g[i][j] > g[i][k]+g[k][j]) g[i][j]=g[i][k]+g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << c << endl;\n\t/*\tfor(i=0;i<c;i++){\n\t\t\tfor(j=0;j<c;j++){\n\t\t\t\tcout << (g[i][j]==INF?-1:g[i][j]) << '\t';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcin >> m;\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%s\",in1);\n\t\t\tstring x,y,in=in1;\n\t\t\tfor(j=0;j<in.length(),in[j]!='-';j++) x+=in[j];\n\t\t\tj++;\n\t\t\tfor(;j<in.length();j++) y+=in[j];\n\t\t\t\n\t\t\tif(mp.find(x)==mp.end() || mp.find(y)==mp.end()) printf(\"NO\\n\");\n\t\t\telse if(g[(*mp.find(x)).second][(*mp.find(y)).second]<INF && g[(*mp.find(x)).second][(*mp.find(y)).second]%2==1){\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint N, M;\nint G[205][205];\nmap<string, int> mp;\nvector<int> g[205];\nint V;\nbool used[205];\nint color[205];\n\nbool dfs(int v, int t)\n{\n\tused[v] = true;\n\tif(v == t) return true;\n\t\n\tbool ret = false;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(used[g[v][i]]) continue;\n\t\tret |= dfs(g[v][i], t);\n\t}\n\treturn ret;\n}\n\nvoid color_dfs(int v, int c)\n{\n\tcolor[v] = c;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(color[g[v][i]]) continue;\n\t\tcolor_dfs(g[v][i], -c);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(int i = 1; i <= 200; i++){\n\t\t\tfor(int j = 1; j <= 200; j++){\n\t\t\t\tG[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint id = 1;\n\t\tstring s, t;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0) mp[s] = id++;\n\t\t\tif(mp.count(t) == 0) mp[t] = id++;\n\t\t\tG[mp[s]][mp[t]] = 1;\n\t\t}\n\t\tV = id-1;\n\t\tcout << V << endl;\n\t\t\n\t\tfor(int i = 1; i <= V; i++) g[i].clear();\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]){\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t\tg[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++) color[i] = 0;\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tif(!color[i]) color_dfs(i, 1);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tint prev = 0, front = 0;\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j] == 1){\n\t\t\t\t\tif(prev == 0) front = j;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[prev][j] == 0) G[prev][j] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tprev = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev != front) if(G[prev][front]) G[prev][front] = 2;\n\t\t}\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tint prev = 0, front = 0;\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[j][i] == 1){\n\t\t\t\t\tif(prev == 0) front = j;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[prev][j] == 0) G[prev][j] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tprev = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev != front) if(G[prev][front]) G[prev][front] = 2;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tg[i].clear();\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]) g[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0 || mp.count(t) == 0){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint S = mp[s], T = mp[t];\n\t\t\t\n\t\t\tif(color[S] == color[T]){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i <= V; i++) used[i] = false;\n\t\t\tif(dfs(S, T)) cout << \"YES\" << endl;\n\t\t\telse cout << \"NO\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<string,int> M;\n\nint str2int(string S){\n    if(M.find(S)==M.end()){\n        int n = M.size();\n        M[S]=n;\n    }\n    return M[S];\n}\n\nint E[200][200];//[a][b]=a to b\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        fill(E[0],E[200],10000);\n        M.clear();\n        for(int i=0;i<N;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    E[i1][i2]=1;\n                    break;\n                }\n            }\n        }\n        int m = M.size();\n        cout<<m<<endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<m;j++){\n                if(E[i][j]==1||E[j][i]==1) continue;\n                //cond1\n                bool b=false;\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[i][k]==1||E[k][i]==1)&&(E[j][k]==1||E[k][j]==1)){\n                        b=true;\n                        break;\n                    }\n                }\n                //cond2,3\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[k][i]==1&&E[j][k]==1)||(E[i][k]==1&&E[k][j]==1)){\n                        b=false;\n                        break;\n                    }\n                }\n                if(b) E[i][j]=E[j][i]=0;\n            }\n        }\n        //WF\n        for(int i=0;i<m;i++) E[i][i]=0;\n        for(int k=0;k<m;k++){\n            for(int i=0;i<m;i++){\n                for(int j=0;j<m;j++){\n                    E[i][j]=min(E[i][j],E[i][k]+E[k][j]);\n                }\n            }\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    if(i1>=m||i2>=m||E[i1][i2]%2==0){\n                        cout<<\"NO\"<<endl;\n                    }else{\n                        cout<<\"YES\"<<endl;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<string,int> M;\n\nint str2int(string S){\n    if(M.find(S)==M.end()){\n        int n = M.size();\n        M[S]=n;\n    }\n    return M[S];\n}\n\nint E[200][200];//[a][b]=a to b\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        fill(E[0],E[200],100000000);\n        M.clear();\n        for(int i=0;i<N;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    E[i1][i2]=1;\n                    break;\n                }\n            }\n        }\n        int m = M.size();\n        cout<<m<<endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<m;j++){\n                if(i==j){\n                    E[i][j]=2;\n                    continue;\n                }\n                if(E[i][j]==1) continue;\n                //cond1\n                bool b=false;\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[i][k]==1||E[k][i]==1)&&(E[j][k]==1||E[k][j]==1)){\n                        b=true;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                //cond2,3\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[k][i]==1&&E[j][k]==1)||(E[i][k]==1&&E[k][j]==1)){\n                        b=false;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                E[i][j]=E[j][i]=2;\n            }\n        }\n        //WF\n        for(int i=0;i<m;i++) E[i][i]=0;\n        for(int k=0;k<m;k++){\n            for(int i=0;i<m;i++){\n                for(int j=0;j<m;j++){\n                    E[i][j]=min(E[i][j],E[i][k]+E[k][j]);\n                }\n            }\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    if(E[i1][i2]%2==0){\n                        cout<<\"NO\"<<endl;\n                    }else{\n                        cout<<\"YES\"<<endl;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n  \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n  \nusing namespace std;\n\nmultimap<string,string>m1,m2;\nmap<string,int>color;\nint graph[200][200];\n\nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n  \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n  \nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n    graph[i][j]|=graph[i][k]&graph[k][j];\n}\n  \nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n    \n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    bool g[200][200];\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tg[i][j]=false;\n\tgraph[i][j]=i==j?1:0; \n      }\n    }\n    \n    multimap<string,string>::iterator it,it2;\n    \n    for(it=m1.begin();it!=m1.end();it++){\n      for(it2=m1.begin();it2!=m1.end();it2++){\n\tif(it==it2)continue;\n\n\tif((*it).fst==(*it2).sec){\n\t  g[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  g[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  g[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  g[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n      }\n    }\n    \n    for(it=m1.begin();it!=m1.end();it++){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n        \n      for(it2=m1.begin();it2!=m1.end();it2++){\n\tif(it==it2)continue;\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n      }\n    }\n    \n    warshall_floyd(node3.size());\n    \n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n\nmap<string,int> dict;\nmap<int,string> rdict;\nint dic(string s){\n\tif( dict.count(s) ) return dict[s];\n\telse{\n\t\tint k = dict.size();\n\t\trdict[k] = s;\n\t\treturn dict[s] = k;\n\t}\n}\n\nint info[210][210];\n\nint same[210][210];\nint muki[210];\n\nvector<int> g[210];\nvector<int> ag[210];\n\nint dfs(int x,int t){\n\tif( muki[x] != -1 ){\n\t\tif( muki[x] != t ){\n\t\t\twhile(1){}\n\t\t}\n\t\treturn 0;\n\t}\n\tmuki[x] = t;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tdfs(g[x][i],t^1);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tmemset(same,0,sizeof(same));\n\t\tmemset(same,0,sizeof(info));\n\t\tdict.clear();\n\t\tfor(int i = 0 ; i < 210 ; i++) g[i].clear() , ag[i].clear();\n\t\tvector< pair<int,int> > v;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tv.push_back( make_pair( dic(a) , dic(b) ) );\n\t\t\tg[dic(a)].push_back(dic(b));\n\t\t\tg[dic(b)].push_back(dic(a));\n\t\t\tag[dic(a)].push_back(dic(b));\t\n\t\t\tinfo[dic(a)][dic(b)] = 1;\n\t\t}\n\t\t\n\t\tmemset(muki,-1,sizeof(muki));\n\t\tdfs(0,0);\n\t\t\n\t\tint N = dict.size();\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint fl1 = 0 , fl2 = 1;\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( (info[j][k]||info[k][j]) && (info[i][k]||info[k][i]) ){\n\t\t\t\t\t\tfl1 = 1; // onajiyatudousi is same\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( info[k][i] && info[j][k] ) fl2 = 0;\n\t\t\t\t\tif( info[i][k] && info[k][j] ) fl2 = 0;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( fl1 && fl2 ){\n\t\t\t\t\t//cout << rdict[i] << \" \" << rdict[j] << \" \" << \"SAME\" << endl;\n\t\t\t\t\tsame[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tcout << N << endl;\n\t\tfor(int x = 0 ; x < m ; x++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tif( !dict.count(a) || !dict.count(b) || muki[dic(a)] == muki[dic(b)] ){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue<int> Q;\n\t\t\tQ.push(dic(a));\n\t\t\tint dn[210];\n\t\t\tmemset(dn,-1,sizeof(dn));\n\t\t\tdn[dic(a)] = 1;\n\t\t\twhile(Q.size()){\n\t\t\t\tint q = Q.front(); Q.pop();\n\t\t\t\t//cout << rdict[q] << endl;\n\t\t\t\tfor(int i = 0 ; i < ag[q].size() ; i++){\n\t\t\t\t\tif( dn[ag[q][i]] == -1 ) Q.push(ag[q][i]) , dn[ag[q][i]] = 1;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t\t\tif( same[q][i] ){\n\t\t\t\t\t\tif( dn[i] == -1 ) Q.push(i) , dn[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif( dn[dic(b)] == 1){\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//1818\n#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define EPS 0.000001\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\n\n\nint main(){\n\tint n,m;\n\twhile(cin >> n){\n\t\tif(n==0) break;\n\t\tint c=0;\n\t\tmap<string,int> mp;\n\t\tchar in1[50],in2[50];\n\t\tstatic int g[401][401];\n\t\tint i,j,k;\n\t\tfor(i=0;i<201;i++) for(j=0;j<201;j++) g[i][j]=INF;\n\t\t\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%s\",in1);\n\t\t\tstring x,y,in=in1;\n\t\t\tfor(j=0;j<in.length(),in[j]!='-';j++) x+=in[j];\n\t\t\tj++;\n\t\t\tfor(;j<in.length();j++) y+=in[j];\n\t\t\tif(mp.find(x)==mp.end()) mp.insert(pair<string,int>(x,c++));\n\t\t\tif(mp.find(y)==mp.end()) mp.insert(pair<string,int>(y,c++));\n\t\t\tg[(*mp.find(x)).second][(*mp.find(y)).second]=1;\n\t\t}\n\t\t\n\t\tfor(i=0;i<c;i++){\n\t\t\tfor(j=i+1;j<c;j++){\n\t\t\t\tif(g[i][j]==INF && g[j][i]==INF){\n\t\t\t\t\tint f=INF;\n\t\t\t\t\tfor(k=0;k<c;k++){\n\t\t\t\t\t\tif(k==i || k==j) continue;\n\t\t\t\t\t\tif(g[i][k]==1 && g[j][k]==1) f=0;\n\t\t\t\t\t\tif(g[k][i]==1 && g[j][k]==1) f=0;\n\t\t\t\t\t\tif(g[i][k]==1 && g[k][j]==1) f=INF;\n\t\t\t\t\t\tif(g[j][k]==1 && g[k][i]==1) f=INF;\n\t\t\t\t\t}\n\t\t\t\t\tg[i][j]=f;\n\t\t\t\t\tg[j][i]=f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<c;k++){\n\t\t\tfor(i=0;i<c;i++){\n\t\t\t\tfor(j=0;j<c;j++){\n\t\t\t\t\tif(g[i][j] > g[i][k]+g[k][j]) g[i][j]=g[i][k]+g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << c << endl;\n\t/*\tfor(i=0;i<c;i++){\n\t\t\tfor(j=0;j<c;j++){\n\t\t\t\tcout << (g[i][j]==INF?-1:g[i][j]) << '\t';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcin >> m;\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%s\",in1);\n\t\t\tstring x,y,in=in1;\n\t\t\tfor(j=0;j<in.length(),in[j]!='-';j++) x+=in[j];\n\t\t\tj++;\n\t\t\tfor(;j<in.length();j++) y+=in[j];\n\t\t\t\n\t\t\tif(mp.find(x)==mp.end() || mp.find(y)==mp.end()) printf(\"NO\\n\");\n\t\t\telse if(g[(*mp.find(x)).second][(*mp.find(y)).second]<INF && g[(*mp.find(x)).second][(*mp.find(y)).second]%2==1){\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef string Vertex;\ntypedef pair<Vertex, Vertex> PVV;\ntypedef map <Vertex, int> Index;\n\nconst int inf = 1<<24;\nconst int size = 201;\nIndex ID;\nint N;\n\nbool F[size][size];\nbool D[size][size];\nbool W[size][size];\nint  T[size][size];\n\nvoid init() {\n    ID.clear();\n    N = 0;\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            F[i][j] = false;\n            D[i][j] = false;\n            W[i][j] = false;\n            T[i][j] = inf;\n        }\n    }\n}\n\nbool exist( Vertex v ) {\n    return ID.find(v) != ID.end();\n}\n\nvoid addVertex( Vertex v ) {\n    if ( exist( v ) ) return;\n    ID[v] = N++;\n}\n\nint getIndex( Vertex v ) {\n    return ID[v];\n}\n\nPVV input() {\n    string line;\n    cin >> line;\n    replace( line.begin(), line.end(), '-', ' ' );\n    istringstream is( line );\n    PVV answer;\n    is >> answer.first >> answer.second;\n    return answer;\n}\n\nbool solve( PVV e ) {\n    if ( !exist(e.first) || !exist(e.second) ) return false;\n    int a = getIndex( e.first );\n    int b = getIndex( e.second );\n    return W[a][b] && ( T[a][b] != inf && T[a][b]%2 );\n}\n\nbool check1( int a, int b, int c ) {\n    if ( a == b || b == c || c == a ) return false;\n    return ( F[a][c] && !F[c][a] && F[b][c] && !F[c][b] )\n        || ( F[c][a] && !F[a][c] && F[c][b] && !F[b][c] );\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        init();\n        for ( int i = 0; i < n; i++ ) {\n            PVV in = input();\n            addVertex(in.first);\n            addVertex(in.second);\n            int a = getIndex(in.first);\n            int b = getIndex(in.second);\n            F[a][b] = true;\n            T[a][b] = T[b][a] = 1;\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                for ( int k = 0; k < N; k++ ) {\n                    if ( check1( i, j, k ) ) {\n                        D[i][j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        for ( int i = 0; i < N; i++ ) {\n            for ( int j = 0; j < N; j++ ) {\n                W[i][j] = F[i][j] || D[i][j];\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    W[i][j] = W[i][j] || ( W[i][k] && W[k][j] );\n                }\n            }\n        }\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    T[i][j] = min( T[i][j], T[i][k] + T[k][j] );\n                }\n            }\n        }\n        int m;\n        cin >> m;\n        cout << N << endl;\n        for ( int i = 0; i < m; i++ ) {\n            PVV in = input();\n            cout << ( solve( in ) ? \"YES\" : \"NO\" ) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \n#define rep(i,n) for(ll i = 0; i < ll(n); ++i) \n#define FOR(i,a,b) for(ll i = (a); i < ll(b); ++i) \n#define ROF(i,a,b) for(ll i = (a)-1; i >= ll(b); --i) \n#define all(a) (a).begin(),(a).end() \n#define fst first \n#define snd second \ntypedef long long ll; \ntypedef vector<ll> vi;\ntypedef vector<vi> vii;\nconst ll inf = 1ll<<10;\n\nbool dfs(const vii &g, ll i, vi &color){\n  ll sz = g.size();\n  stack<ll> st;\n  color[i] = 1;\n  st.push(i);\n\n  while(!st.empty()){\n    int now = st.top();\n    st.pop();\n\n    rep(next,sz){\n      if(now == next) continue;\n      if(g[now][next] + g[next][now] == 0){ // now<->next\n\tif(color[next] and color[next] != color[now]){\n\t  //cout << now << endl << next << endl;\n\t  return false; \n\t}else if(color[next] and color[next] == color[now]) continue;\n\telse{\n\t  color[next] = color[now];\n\t  st.push(next);\n\t}\n      }else if(g[now][next] * g[next][now] == 0){ // now->next or next->now\n\tif(color[next] and color[next] == color[now]){\n\t  //cout << now << endl << next << endl;\n\t  return false;\n\t}else if(color[next] and color[next] != color[now]) continue;\n\telse{\n\t  color[next] = -color[now];\n\t  st.push(next);\n\t}\n      }\n    }\n  }\n  return true;\n}\n\nbool paintable(const vii &g, vi &color){\n  ll sz = g.size();\n  rep(i,sz) if(color[i] == 0) if(dfs(g,i,color) == false) return false;\n  return true;\n}\n\nmain(){\n  ll m,n; \n  while(cin >> m, m){ \n    vector<string> input(m); \n    vector<vector<string>> cross(m,vector<string>(2)); \n    set<string> street; \n    rep(i,m){ \n      cin >> input[i]; \n      FOR(k,1,input[i].size()){ // A-BをAとBに分ける \n\tif(input[i][k] == '-'){ \n\t  cross[i][0] = input[i].substr(0,k); \n\t  cross[i][1] = input[i].substr(k+1,input[i].size()-k-1); \n\t  street.insert(cross[i][0]); \n\t  street.insert(cross[i][1]); \n\t  //cerr << cross[i][0] << endl << cross[i][1] << endl; \n\t  break; \n\t} \n      } \n    } \n    map<string,ll> ntoi; // 通りの名前からindex\n    vector<string> iton; // indexから通りの名前\n    ll tmpi = 0;\n    for(auto name : street){ \n      ntoi[name] = tmpi;\n      iton.push_back(name);\n      tmpi++;\n    }\n    ll sz = street.size(); cout << sz << endl;\n    vii g(sz,vi(sz,1)); \n    rep(i,m) g[ ntoi[cross[i][0]] ][ ntoi[cross[i][1]] ] = 0; // A->B\n    \n    vector<pair<ll,ll>> eqp; // 同水準のpair\n    rep(i,sz) rep(j,sz){ // iとjが同水準か\n      bool ieqj = false;\n      rep(k,sz){\n\tif((g[i][k] + g[k][j]) * (g[j][k] + g[k][i]) == 0){ // i->k->jかj->k->iがある\n\t  ieqj = false;\n\t  break;\n\t}else if((g[i][k] + g[j][k]) * (g[k][i] + g[k][j]) == 0){ // i->k,j->kかk->i,k->jがある\n\t  ieqj = true;\n\t}\n      }\n      if(ieqj) eqp.push_back(make_pair(i,j));\n    }\n    rep(i,eqp.size()) g[eqp[i].fst][eqp[i].snd] = g[eqp[i].snd][eqp[i].fst] = 0; // A<->B\n    //rep(i,sz){ rep(j,sz) cout << g[i][j] << \" \"; cout << endl; }\n\n    vii d = g; // path i->j がある <=> d[i][j] == 0\n    rep(k,sz) rep(i,sz) rep(j,sz) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n    vi color(sz);\n    bool p = paintable(g,color);\n    //cout << \"p : \" << p << endl;\n    //rep(i,sz) cout << iton[i] << \" : \" << color[i] << endl;\n\n    cin >> n;\n    rep(k,n){\n      string q; cin >> q;\n      if(p == false){\n\tcout << \"NO\\n\";\n\tcontinue;\n      }\n      string ql, qr;\n      FOR(i,1,q.size()){ // A-BをAとBに分ける \n\tif(q[i] == '-'){ \n\t  ql = q.substr(0,i); \n\t  qr = q.substr(i+1,q.size()-i-1);\n\t  break; \n\t} \n      }\n      if(ntoi.count(ql) * ntoi.count(qr) == 0){\n\tcout << \"NO\\n\";\n\tcontinue;\n      }\n      if(d[ntoi[ql]][ntoi[qr]] != 0){\n\tcout << \"NO\\n\";\n\tcontinue;\n      }\n      //cout << color[ntoi[ql]] << endl << color[ntoi[qr]] << endl;\n      if(color[ntoi[ql]] != color[ntoi[qr]]) cout << \"YES\\n\";\n      else cout << \"NO\\n\";\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n\nmap<string,int> dict;\nmap<int,string> rdict;\nint dic(string s){\n\tif( dict.count(s) ) return dict[s];\n\telse{\n\t\tint k = dict.size();\n\t\trdict[k] = s;\n\t\treturn dict[s] = k;\n\t}\n}\n\nint info[210][210];\n\nint same[210][210];\nint muki[210];\n\nvector<int> g[210];\nvector<int> ag[210];\n\nint dfs(int x,int t){\n\tif( muki[x] != -1 ) return 0;\n\tmuki[x] = t;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tdfs(g[x][i],t^1);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tmemset(same,0,sizeof(same));\n\t\tmemset(same,0,sizeof(info));\n\t\tdict.clear();\n\t\tfor(int i = 0 ; i < 210 ; i++) g[i].clear() , ag[i].clear();\n\t\tvector< pair<int,int> > v;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tv.push_back( make_pair( dic(a) , dic(b) ) );\n\t\t\tg[dic(a)].push_back(dic(b));\n\t\t\tg[dic(b)].push_back(dic(a));\n\t\t\tag[dic(a)].push_back(dic(b));\t\n\t\t\tinfo[dic(a)][dic(b)] = 1;\n\t\t}\n\t\t\n\t\tmemset(muki,-1,sizeof(muki));\n\t\tdfs(0,0);\n\t\t\n\t\tint N = dict.size();\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint fl1 = 0 , fl2 = 1;\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( (info[j][k]||info[k][j]) && (info[i][k]||info[k][i]) ){\n\t\t\t\t\t\tfl1 = 1; // onajiyatudousi is same\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( info[k][i] && info[j][k] ) fl2 = 0;\n\t\t\t\t\tif( info[i][k] && info[k][j] ) fl2 = 0;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( fl1 && fl2 ){\n\t\t\t\t\t//cout << rdict[i] << \" \" << rdict[j] << \" \" << \"SAME\" << endl;\n\t\t\t\t\tsame[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int x = 0 ; x < m ; x++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tif( !dict.count(a) || !dict.count(b) || muki[dic(a)] == muki[dic(b)] ){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue<int> Q;\n\t\t\tQ.push(dic(a));\n\t\t\tint dn[210];\n\t\t\tmemset(dn,-1,sizeof(dn));\n\t\t\tdn[dic(a)] = 1;\n\t\t\twhile(Q.size()){\n\t\t\t\tint q = Q.front(); Q.pop();\n\t\t\t\t//cout << rdict[q] << endl;\n\t\t\t\tfor(int i = 0 ; i < ag[q].size() ; i++){\n\t\t\t\t\tif( dn[ag[q][i]] == -1 ) Q.push(ag[q][i]) , dn[ag[q][i]] = 1;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t\t\tif( same[q][i] ){\n\t\t\t\t\t\tif( dn[i] == -1 ) Q.push(i) , dn[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( dn[dic(b)] == 1){\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\nint n,m,size;\nstring str,a,b;\nmap<string,int> mp;\nint G[201][201];\nint g[201][201];\nint T[201][201];\nint t[201][201];\n\nvoid init(){\n  mp.clear();\n  size=0;\n  for(int i=1;i<=200;i++){\n    for(int j=1;j<=200;j++){\n      G[i][j]=(i==j?0:INF);\n      T[i][j]=(i==j?0:INF);\n      g[i][j]=0;\n      t[i][j]=0;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n\n    for(int i=0;i<n;i++){\n      cin>>str;\n      for(int j=0;j<(int)str.size();j++){\n        if(str[j]=='-'){\n          a=str.substr(0,j);\n          b=str.substr(j+1);\n          break;\n        }\n      }\n      if(mp[a]==0)mp[a]=++size;\n      if(mp[b]==0)mp[b]=++size;\n      G[mp[a]][mp[b]]=1;\n      T[mp[a]][mp[b]]=1;\n      g[mp[a]][mp[b]]=1;\n    }\n    \n    for(int i=1;i<=size;i++){\n      for(int j=1;j<=size;j++){\n        if(i==j)continue;\n        bool flg=false;\n        for(int k=1;k<=size;k++){\n          if((g[i][k]||g[k][i])&&(g[j][k]||g[k][j])){\n            flg=true;\n          }\n        }\n        if(flg){\n          t[i][j]=1;\n          t[j][i]=1;\n        }\n              \n        for(int k=1;k<=size;k++){\n          if(g[k][i]&&g[j][k])flg=false;\n          if(g[i][k]&&g[k][j])flg=false;\n        }\n        if(flg){\n          T[i][j]=1;\n          T[j][i]=1;\n        }\n      }\n    }\n    \n    for(int k=1;k<=size;k++){\n      for(int i=1;i<=size;i++){\n        for(int j=1;j<=size;j++){\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n          T[i][j]=min(T[i][j],T[i][k]+T[k][j]);\n        }\n      }\n    }\n\n    cout<<size<<endl;\n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>str;\n      for(int j=0;j<(int)str.size();j++){\n        if(str[j]=='-'){\n          a=str.substr(0,j);\n          b=str.substr(j+1);\n          break;\n        }\n      }\n      int A=mp[a],B=mp[b];\n      \n      if(G[A][B]%2==0&&G[A][B]!=INF){\n        cout<<\"NO\"<<endl;\n      }else if(T[A][B]==INF){\n        cout<<\"NO\"<<endl;\n      }else if(t[A][B]){\n        cout<<\"NO\"<<endl;\n      }else{\n        cout<<\"YES\"<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint N, M;\nint G[205][205];\nmap<string, int> mp;\nvector<int> g[205];\nint V;\nbool used[205];\nint color[205];\n\nbool dfs(int v, int t)\n{\n\tused[v] = true;\n\tif(v == t) return true;\n\t\n\tbool ret = false;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(used[g[v][i]]) continue;\n\t\tret |= dfs(g[v][i], t);\n\t}\n\treturn ret;\n}\n\nvoid color_dfs(int v, int c)\n{\n\tcolor[v] = c;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(color[g[v][i]]) continue;\n\t\tcolor_dfs(g[v][i], -c);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(int i = 1; i <= 200; i++){\n\t\t\tfor(int j = 1; j <= 200; j++){\n\t\t\t\tG[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint id = 1;\n\t\tstring s, t;\n\t\tmp.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0) mp[s] = id++;\n\t\t\tif(mp.count(t) == 0) mp[t] = id++;\n\t\t\tG[mp[s]][mp[t]] = 1;\n\t\t}\n\t\tV = id-1;\n\t\tcout << V << endl;\n\t\t\n\t\tfor(int i = 1; i <= V; i++) g[i].clear();\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]){\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t\tg[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++) color[i] = 0;\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tif(!color[i]) color_dfs(i, 1);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tint prev = 0, front = 0;\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j] == 1){\n\t\t\t\t\tif(prev == 0) front = j;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[prev][j] == 0) G[prev][j] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tprev = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev != front) if(G[prev][front]) G[prev][front] = 2;\n\t\t}\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tint prev = 0, front = 0;\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[j][i] == 1){\n\t\t\t\t\tif(prev == 0) front = j;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[prev][j] == 0) G[prev][j] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tprev = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev != front) if(G[prev][front]) G[prev][front] = 2;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tg[i].clear();\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]) g[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0 || mp.count(t) == 0){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint S = mp[s], T = mp[t];\n\t\t\t\n\t\t\tif(color[S] == color[T]){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i <= V; i++) used[i] = false;\n\t\t\tif(dfs(S, T)) cout << \"YES\" << endl;\n\t\t\telse cout << \"NO\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nint N, M;\nint V;\nvector<vector<int> > E;\nvector<vector<int> > rE;\nvector<vector<int> > undE;\n\nint tag[310];\nint even[310];\n\nvoid init() {\n\tE.clear(); rE.clear(); undE.clear();\n\trep(i,310) {\n\t\ttag[i] = -1;\n\t\teven[i] = -1;\n\t}\n};\n\nbool dfs(int n, int tg, int d) {\n\tif(tag[n]+1)\n\t\treturn false;\n\ttag[n] = tg;\n\teven[n] = d % 2;\n\tfor(int i = 0; i < undE[n].size(); i++) {\n\t\tdfs(undE[n][i], tg, d+1);\n\t}\n\treturn true;\n}\n\nbool used[310];\nbool solve(int n, int gl) {\n\tif(n == gl) return true;\n\tif(used[n]) return false;\n\tused[n] = true;\n\n\tbool res = false;\n\trep(i,rE[n].size()) {\n\t\tif(solve(rE[n][i], gl))\n\t\t\tres = true;\n\t}\n\trep(i,E[n].size()) {\n\t\trep(j,rE[E[n][i]].size()) {\n\t\t\tif(solve(rE[E[n][i]][j], gl))\n\t\t\t\tres = true;\n\t\t}\n\t}\n\trep(i,rE[n].size()) {\n\t\trep(j,E[rE[n][i]].size()) {\n\t\t\tif(solve(E[rE[n][i]][j], gl))\n\t\t\t\tres = true;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> N, N) {\n\t\tinit();\n\t\tmap<string, int> mp;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tstring s, s0, s1;\n\t\t\tcin >> s;\n\t\t\ts0 = string(s.begin(), s.begin()+s.find('-'));\n\t\t\ts1 = string(s.begin()+s0.size()+1, s.end());\n\t\t\tvector<string> vs;\n\t\t\tvs.pb(s0); vs.pb(s1);\n\t\t\tfor(int j = 0; j < vs.size(); j++) {\n\t\t\t\tif(mp.find(vs[j]) == mp.end()) {\n\t\t\t\t\tmp[vs[j]] = mp.size();\n\t\t\t\t\tE.pb(vector<int>());\n\t\t\t\t\trE.pb(vector<int>());\n\t\t\t\t\tundE.pb(vector<int>());\n\t\t\t\t}\n\t\t\t}\n\t\t\tint a, b;\n\t\t\ta = mp[s0];\n\t\t\tb = mp[s1];\n\t\t\tE[b].pb(a);\n\t\t\trE[a].pb(b);\n\t\t\tundE[b].pb(a);\n\t\t\tundE[a].pb(b);\n\t\t}\n\t\tV = mp.size();\n\t\tcout << V << endl;\n\t\t//for(auto it = mp.begin(); it != mp.end(); it++) cout << it->second << \":\" << it->first << endl;\n\t\tint tg = 0;\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\ttg += dfs(i, tg, 0);\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i < 10; i++)\n\t\t\tcout << even[i] << \" \" ;\n\t\tcout << endl;\n\t\t// */\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\trep(j,310) used[j] = false;\n\t\t\tstring s, ss[2];\n\t\t\tcin >> s;\n\t\t\tss[0] = string(s.begin(), s.begin()+s.find('-'));\n\t\t\tss[1] = string(s.begin()+s.find('-')+1, s.end());\n\t\t\tbool res = true;\n\t\t\tif(mp.find(ss[0]) == mp.end() || mp.find(ss[1]) == mp.end()\n\t\t\t\t\t|| ss[0] == ss[1] || even[mp[ss[0]]] == even[mp[ss[1]]])\n\t\t\t\tres = false;\n\t\t\tif(res)\n\t\t\t\tres = solve(mp[ss[0]], mp[ss[1]]);\n\t\t\t\n\t\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    map< string, int > conv;\n    bool mat[201][201] = {{}}, beet[201][201] = {{}};\n    int M = 200;\n    UnionFind tree(M + M);\n\n    for(int i = 0; i < M; i++) beet[i][i] = true;\n\n    for(int i = 0; i < N; i++) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S)) conv[S] = conv.size();\n      if(!conv.count(T)) conv[T] = conv.size();\n      int a = conv[S], b = conv[T];\n      mat[a][b] = beet[a][b] = true;\n      tree.unite(a + M, b);\n      tree.unite(b + M, a);\n    }\n    for(int i = 0; i < M; i++) {\n      for(int j = i + 1; j < M; j++) {\n        if([&]()\n        {\n          bool flag = false;\n          for(int k = 0; k < M; k++) {\n            if(mat[i][k] & mat[j][k]) flag = true;\n            if(mat[k][i] & mat[k][j]) flag = true;\n            if(mat[i][k] & mat[k][j]) return (false);\n            if(mat[j][k] & mat[k][i]) return (false);\n          }\n          return (flag);\n        }())\n          beet[i][j] = beet[j][i] = true;\n      }\n    }\n    for(int k = 0; k < M; k++) {\n      for(int i = 0; i < M; i++) {\n        for(int j = 0; j < M; j++) {\n          beet[i][j] |= beet[i][k] & beet[k][j];\n        }\n      }\n    }\n\n    int Q;\n    cin >> Q;\n    cout << conv.size() << endl;\n    while(Q--) {\n      string S;\n      cin >> S;\n      string T = S.substr(S.find('-') + 1);\n      S = S.substr(0, S.find('-'));\n      if(!conv.count(S) || !conv.count(T)) {\n        cout << \"NO\" << endl;\n      } else {\n        int a = conv[S];\n        int b = conv[T];\n        if(tree.find(a) != tree.find(b + M) || tree.find(b) != tree.find(a + M) || !beet[a][b]) {\n          cout << \"NO\" << endl;\n        } else {\n          cout << \"YES\" << endl;\n        }\n      }\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n\nmap<string,int> dict;\nmap<int,string> rdict;\nint dic(string s){\n\tif( dict.count(s) ) return dict[s];\n\telse{\n\t\tint k = dict.size();\n\t\trdict[k] = s;\n\t\treturn dict[s] = k;\n\t}\n}\n\nint info[210][210];\n\nint same[210][210];\nint muki[210];\n\nvector<int> g[210];\nvector<int> ag[210];\n\nint dfs(int x,int t){\n\tif( muki[x] != -1 ){\n\t\treturn 0;\n\t}\n\tmuki[x] = t;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tdfs(g[x][i],t^1);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tmemset(same,0,sizeof(same));\n\t\tmemset(info,0,sizeof(info));\n\t\tdict.clear();\n\t\trdict.clear();\n\t\tfor(int i = 0 ; i < 210 ; i++) g[i].clear() , ag[i].clear();\n\t\tvector< pair<int,int> > v;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tv.push_back( make_pair( dic(a) , dic(b) ) );\n\t\t\tg[dic(a)].push_back(dic(b));\n\t\t\tg[dic(b)].push_back(dic(a));\n\t\t\tag[dic(a)].push_back(dic(b));\t\n\t\t\tinfo[dic(a)][dic(b)] = 1;\n\t\t}\n\t\t\n\t\tmemset(muki,-1,sizeof(muki));\n\t\tdfs(0,0);\n\t\t\n\t\tint N = dict.size();\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint fl1 = 0 , fl2 = 1;\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( (info[j][k]&&info[i][k])||(info[k][i]&&info[k][j]) ){\n\t\t\t\t\t\tfl1 = 1; // onajiyatudousi is same\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( info[k][i] && info[j][k] ) fl2 = 0;\n\t\t\t\t\tif( info[i][k] && info[k][j] ) fl2 = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( fl1 && fl2 ){\n\t\t\t\t\t//cout << rdict[i] << \" \" << rdict[j] << \" \" << \"SAME\" << endl;\n\t\t\t\t\tsame[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tcout << N << endl;\n\t\tfor(int x = 0 ; x < m ; x++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tif( !dict.count(a) || !dict.count(b) || muki[dic(a)] == muki[dic(b)] ){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue<int> Q;\n\t\t\tQ.push(dic(a));\n\t\t\tint dn[210];\n\t\t\tmemset(dn,-1,sizeof(dn));\n\t\t\tdn[dic(a)] = 1;\n\t\t\twhile(Q.size()){\n\t\t\t\tint q = Q.front(); Q.pop();\n\t\t\t\t//cout << rdict[q] << endl;\n\t\t\t\tfor(int i = 0 ; i < ag[q].size() ; i++){\n\t\t\t\t\tif( dn[ag[q][i]] == -1 ) Q.push(ag[q][i]) , dn[ag[q][i]] = 1;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t\t\tif( same[q][i] ){\n\t\t\t\t\t\tif( dn[i] == -1 ) Q.push(i) , dn[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif( dn[dic(b)] == 1){\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\n#include <cassert>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\n\nint N, M;\nmap<string, int> mp;\nbool e[200][200];\nbool ee[200][200];\nint t[200];\n\nvoid dfs(int v, int c){\n    t[v] = c;\n    for(int i=0; i<mp.size(); i++) if(i != v && (e[v][i] || e[i][v])){\n        if(t[i]) assert(t[i] == -c);\n        else dfs(i, -c);\n    }\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin >> N, N){\n        //init\n        mp.clear();\n        for(int i=0; i<200; i++){\n            for(int j=0; j<200; j++){\n                e[i][j] = ee[i][j] = i == j;\n            }\n            t[i] = 0;\n        }\n        \n        string st;\n        for(int i=0; i<N; i++){\n            cin >> st;\n            int j = 0;\n            while(st[j]!='-') j++;\n            string xx = st.substr(0, j);\n            string yy = st.substr(j+1, st.size()-j);\n            if(!mp.count(xx)) mp[xx] = mp.size();\n            if(!mp.count(yy)) mp[yy] = mp.size();\n            e[mp[xx]][mp[yy]] = true;\n        }\n        \n        int J = 1;\n        for(int i=0; i<mp.size(); i++){\n            if(t[i] == 0)\n                dfs(i, J++);\n        }\n        \n        for(int i=0; i<mp.size(); i++){\n            for(int j=0; j<mp.size(); j++) if(i != j){\n                bool fc = false;\n                bool fd = false;\n                for(int k=0; k<mp.size(); k++) if(k != i && k != j){\n                    fc |= (e[i][k] && e[j][k]) || (e[k][i] && e[k][j]);\n                    fd |= (e[i][k] && e[k][j]) || (e[j][k] && e[k][i]);\n                }\n                ee[i][j] = fc && !fd;\n            }\n        }\n        \n        for(int i=0; i<mp.size(); i++)\n            for(int j=0; j<mp.size(); j++)\n                e[i][j] |= ee[i][j];\n        \n        for(int k=0; k<mp.size(); k++)\n            for(int i=0; i<mp.size(); i++)\n                for(int j=0; j<mp.size(); j++)\n                    e[i][j] |= e[i][k] && e[k][j];\n        \n        cin >> M;\n        cout << mp.size() << endl;\n        for(int i=0; i<M; i++){\n            cin >> st;\n            int j = 0;\n            while(st[j]!='-') j++;\n            string xx = st.substr(0, j);\n            string yy = st.substr(j+1, st.size()-j);\n            \n            bool flag;\n            if(mp.count(xx) && mp.count(yy)){\n                int x = mp[xx], y = mp[yy];\n                flag = e[x][y] && !ee[x][y] && t[x] == -t[y];\n            }else{\n                flag = false;\n            }\n            cout << (flag? \"YES\": \"NO\") << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n#define pb push_back\n#define pf push_front\n#define rep(i,n) for (int i=0; i < (n); i++)\n#define all(c) (c).begin(), (c).end()\n \nstruct michi{\n  VS upper,lower;\n  char verti;\n  bool check;\n};\nmap<string,michi> mamap;\nvoid nocheck(){\n  for(map<string,michi>::iterator a=mamap.begin();\n      a!=mamap.end();a++){\n    a->second.check=false;\n  }\n}\nbool jouge(VS upper,VS lower){\n    for(VS::iterator a=upper.begin();\n      a!=upper.end();a++){\n      for(VS::iterator b=lower.begin();\n\t  b!=lower.end();b++){\n\tif(*a==*b) return true;\n      }\n\n    }\n    return false;\n}\n \nbool searchup(string desti,string pres){\n  // cout<<pres<<\" dddddddd    \";\n  if(mamap[pres].check) return false;\n  mamap[pres].check=true;\n   \n  if(desti==pres) return true;\n  VS dolist=mamap[pres].lower;\n  VS uplist=mamap[pres].upper;\n  //  cout<<uplist.size();\n  for(VS::iterator a=dolist.begin();\n      a!=dolist.end();a++){\n    //    cout<<*a<<\"  keke\";\n    VS uup=mamap[*a].upper;\n    for(VS::iterator b=uup.begin();\n\tb!=uup.end();b++){\n      if(jouge(dolist,mamap[*b].upper)) continue;\n      if(jouge(uplist,mamap[*b].lower)) continue;\n      if(searchup(desti,*b)) return true; \n    }\n  }  \n  for(VS::iterator a=uplist.begin();\n      a!=uplist.end();a++){\n    //    cout<<*a<<\"  keke\";\n    VS uup=mamap[*a].lower;\n    for(VS::iterator b=uup.begin();\n\tb!=uup.end();b++){\n      if(jouge(dolist,mamap[*b].upper)) continue;\n      if(jouge(uplist,mamap[*b].lower)) continue;\n      if(searchup(desti,*b)) return true; \n    }\n  }    \n  \n  for(VS::iterator a=uplist.begin();\n      a!=uplist.end();a++){\n    //    cout<<*a<<\"  keke\";\n    if(searchup(desti,*a)) return true;  \n  }\n \n  return false;\n}\nbool sesearch(string fir,string sec){\n  michi strong,weak;\n  strong=mamap[fir];\n  weak=mamap[sec];\n  // cout<<endl<<endl<<endl<<fir<<sec<<endl;\n  // cout<<(int)strong.verti<<(int)weak.verti<<endl;\n  if(strong.verti==weak.verti) return false;\n \n  nocheck();\n  if(searchup(fir,sec)) return true;\n  // if(searchup(sec,fir)){\n  //   cout<<\"hehe\";\n  //   nocheck();\n  //   if(searchup(fir,sec)) return true;\n  //   else return false;\n  // }\n  return false;\n}\nvoid vertisho(string fir,char vert){\n  if(mamap[fir].verti!=-1) return; \n  mamap[fir].verti=vert;\n \n  if(vert==1) vert=0;\n  else if(vert==0) vert=1;\n  //cout<<fir<<\" \"<<(int)mamap[fir].verti<<endl;\n  for(VS::iterator a=mamap[fir].upper.begin();\n      a!=mamap[fir].upper.end();a++){\n    //    cout<<*a<<endl;\n    vertisho(*a,vert);\n  }\n  for(VS::iterator a=mamap[fir].lower.begin();\n      a!=mamap[fir].lower.end();a++)\n    vertisho(*a,vert);\n}\nvoid wakeru(string& a,string& b){\n  int i;\n  string tmp;\n  cin>>tmp;\n  for(i=0;i<tmp.size();i++){\n    if(tmp[i]=='-') break;\n  }\n  a=tmp.substr(0,i);\n  b=tmp.substr(i+1);\n  // cout<<a<<endl<<b<<endl;\n \n}\n \nint main() {\n  int n,m,tmptmp;\n  string fir,sec,tmpst;\n  michi ue,sita;\n  while(true){\n    mamap=map<string,michi>();\n    cin>>n;\n    if(n==0) return 0;\n    //    cout<<\"n:\"<<n<<\"m:\"<<m<<endl;\n    rep(i,n){\n      wakeru(fir,sec);\n      //cin>>fir>>sec;\n      //cout<<fir<<endl<<sec<<endl;\n      // mamap[fir].lower.pb[sec];\n      // mamap[sec].upper.pb[fir];\n      ue=mamap[fir];\n      sita=mamap[sec];\n      ue.lower.pb(sec);\n      sita.upper.pb(fir);\n      mamap[fir]=ue;\n      mamap[sec]=sita;\n    }\n     for(map<string,michi>::iterator a=mamap.begin();\n      a!=mamap.end();a++){\n       a->second.verti=-1;\n       //       cout<<a->first<<(int)a->second.verti<<endl;\n    }\n     nocheck();\n     for(map<string,michi>::iterator a=mamap.begin();\n      a!=mamap.end();a++){\n       if(a->second.verti==-1)\n\t vertisho(a->first,0);\n       //       cout<<a->first<<(int)a->second.verti<<endl;\n    }\n     //     vertisho(fir,0);\n     cout<<mamap.size()<<endl;\n     cin>>m;\n     rep(i,m){\n       wakeru(fir,sec);\n \n       //cout<<fir<<endl<<sec<<endl;\n       nocheck();\n       if(sesearch(fir,sec)) cout<<\"YES\"<<endl;\n       else cout<<\"NO\"<<endl;\n       \n     }\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<string, string> pss;\n\npss split(string s) {\n  ll k;\n  REP(i, 0, s.size()) if(s[i] == '-') k = i;\n  string fi = s.substr(0, k);\n  string se = s.substr(k + 1, s.size() - k - 1);\n  return pss(fi, se);\n}\n\nvoid dfs(ll v, vector<vector<ll>> &E, vector<bool> &used, vector<ll> &color, ll c) {\n  if(used[v]) return;\n  used[v] = true;\n\n  color[v] = c;\n  for(ll u : E[v]) dfs(u, E, used, color, 1 - c);\n}\n\nbool dfs2(ll v, ll g, vector<vector<ll>> &E, vector<bool> &used) {\n  if(v == g) return true;\n\n  if(used[v]) return false;\n  used[v] = true;\n\n  bool ret = false;\n  for(ll u : E[v]) ret = ret || dfs2(u, g, E, used);\n  return ret;\n}\n\nint main(void) {\n  ll N, M;\n  while(cin >> N, N) {\n    vector<string> uniq;\n    vector<pss> C(N);\n    REP(i, 0, N) {\n      string s;\n      cin >> s;\n      C[i] = split(s);\n      uniq.push_back(C[i].first);\n      uniq.push_back(C[i].second);\n    }\n    cin >> M;\n    vector<pss> Q(M);\n    REP(i, 0, M) {\n      string s;\n      cin >> s;\n      Q[i] = split(s);\n      uniq.push_back(Q[i].first);\n      uniq.push_back(Q[i].second);\n    }\n    sort(uniq.begin(), uniq.end());\n    uniq.erase(unique(uniq.begin(), uniq.end()), uniq.end());\n\n    vector<pll> cross(N), query(M);\n    REP(i, 0, N) {\n      cross[i].first = lower_bound(uniq.begin(), uniq.end(), C[i].first) - uniq.begin();\n      cross[i].second = lower_bound(uniq.begin(), uniq.end(), C[i].second) - uniq.begin();\n    }\n    REP(i, 0, M) {\n      query[i].first = lower_bound(uniq.begin(), uniq.end(), Q[i].first) - uniq.begin();\n      query[i].second = lower_bound(uniq.begin(), uniq.end(), Q[i].second) - uniq.begin();\n    }\n\n    ll n = uniq.size();\n    vector<vector<ll>> E(n), R(n), A(n);\n    REP(i, 0, N) {\n      E[cross[i].first].push_back(cross[i].second);\n      R[cross[i].second].push_back(cross[i].first);\n      A[cross[i].first].push_back(cross[i].second);\n      A[cross[i].second].push_back(cross[i].first);\n    }\n\n    vector<bool> used(n, false);\n    vector<ll> color(n);\n    REP(i, 0, n) if(!used[i]) dfs(i, A, used, color, 0);\n\n    REP(i, 0, n) {\n      for(ll u : E[i]) for(ll v : E[i]) if(u != v) E[u].push_back(v);\n      for(ll u : R[i]) for(ll v : R[i]) if(u != v) E[u].push_back(v);\n    }\n\n    set<ll> st;\n    REP(i, 0, N) {\n      st.insert(cross[i].first);\n      st.insert(cross[i].second);\n    }\n\n    cout << st.size() << endl;\n    REP(i, 0, M) {\n      ll s = query[i].first, t = query[i].second;\n      vector<bool> used(n);\n      bool ok = color[s] != color[t] && dfs2(s, t, E, used);\n      cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nmap<string,int> dat;\nint tn;\n\ntypedef pair<string,string> smp;\nsmp gettn(char* s){\n\tint ls=strlen(s);\n\tstring sa,sb;\n\tint hp=0;\n\trep(j,ls)if(s[j]=='-')hp=j;\n\trep(j,hp)sa+=s[j];\n\treg(j,hp+1,ls-1)sb+=s[j];\n\treturn smp(sa,sb);\n}\n\nint strtot(string s,bool re){\n\tif(re){\n\t\tif(dat.find(s)==dat.end()){\n\t\t\t//printf(\"%s %d\\n\",s.c_str(),tn);\n\t\t\tdat[s]=tn; tn++;\n\t\t}\n\t}\n\treturn dat[s];\n}\n\nint vs[205][205];\nint gone[205][2];\n\nvoid dfs(int no,int ty){\n\tif(gone[no][ty])return;\n\tgone[no][ty]=1;\n\trep(to,tn){\n\t\tif(vs[no][to]==0)continue;\n\t\tif(gone[to][1-ty]==1)continue;\n\t\tif(vs[no][to]==1)dfs(to,1-ty);\n\t\telse if(vs[no][to]==2)dfs(to,ty);\n\t}\n}\n\nint main(void){\n\tfor(;;){\n\t\tint n,m;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\ttn=0;\n\t\tdat.clear();\n\t\tmemset(vs,0,sizeof(vs));\n\t\t\n\t\trep(i,n){\n\t\t\tchar s[50];\n\t\t\tscanf(\"%s\",s);\n\t\t\t\n\t\t\tsmp pa=gettn(s);\n\t\t\tint a=strtot(pa.fir,true),\n\t\t\t\tb=strtot(pa.sec,true);\n\t\t\t\n\t\t\tvs[a][b]=1;\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i,tn){\n\t\t\trep(j,tn){\n\t\t\t\tprintf(\"%d \",vs[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t\n\t\tvector<mp> cad;\n\t\trep(i,tn){\n\t\t\trep(j,tn){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tbool has=false,ok=true;\n\t\t\t\trep(k,tn){\n\t\t\t\t\tif(i==k || j==k)continue;\n\t\t\t\t\tif(vs[i][k]==1 && vs[k][j]==1)ok=false;\n\t\t\t\t\tif(vs[k][i]==1 && vs[j][k]==1)ok=false;\n\t\t\t\t\tif(vs[i][k]==1 && vs[j][k]==1)has=true;\n\t\t\t\t\tif(vs[k][i]==1 && vs[k][j]==1)has=true;\n\t\t\t\t\tif(!ok)break;\n\t\t\t\t}\n\t\t\t\tif((!has) || (!ok))continue;\n\t\t\t\tcad.push_back(mp(i,j));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,cad.size()){\n\t\t\tint a=cad[i].fir,b=cad[i].sec;\n\t\t\tvs[a][b]=vs[b][a]=2;\n\t\t\t//printf(\"----------------samel %d %d\\n\",a,b);\n\t\t}\n\n\t\t/*\n\t\trep(i,tn){\n\t\t\trep(j,tn){\n\t\t\t\tprintf(\"%d \",vs[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\tprintf(\"%d\\n\",dat.size());\n\t\tscanf(\"%d\",&m);\n\t\trep(i,m){\n\t\t\tchar s[50];\n\t\t\tscanf(\"%s\",s);\n\t\t\t\n\t\t\tsmp pa=gettn(s);\n\t\t\tint a=strtot(pa.fir,false),\n\t\t\t\tb=strtot(pa.sec,false);\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tdfs(a,0);\n\t\t\tif(gone[b][1]==1)printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nconst int INF = 1000, MAX = 200;\nstring a, b;\nint num;\nint mat[MAX][MAX];\nbool dmat[MAX][MAX];\nbool visited[MAX];\n\nvoid input() {\n\tstring s;\n\tcin >> s;\n\n\tconst int pos = s.find('-');\n\ta = s.substr(0, pos);\n\tb = s.substr(pos + 1);\n}\n\nvoid dfs(int v) {\n\tvisited[v] = true;\n\tfor(int i = 0; i < num; ++i)\n\t\tif(!visited[i] && dmat[v][i])\n\t\t\tdfs(i);\n}\n\nbool check(int from, int to) {\n\tif(mat[from][to] % 2 == 0)\n\t\treturn false;\n\tmemset(visited, false, sizeof(visited));\n\tdfs(from);\n\treturn visited[to];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tmap<string, int> convert;\n\t\tmemset(dmat, false, sizeof(dmat));\n\t\tfill(mat[0], mat[0] + MAX * MAX, INF);\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tmat[i][i] = 0;\n\n\t\twhile(n--) {\n\t\t\tinput();\n\n\t\t\tif(!convert.count(a))\n\t\t\t\tconvert.insert(make_pair(a, convert.size()));\n\n\t\t\tif(!convert.count(b))\n\t\t\t\tconvert.insert(make_pair(b, convert.size()));\n\n\t\t\tconst int a_id = convert[a], b_id = convert[b];\n\t\t\tdmat[a_id][b_id] = mat[a_id][b_id] = mat[b_id][a_id] = 1;\n\t\t}\n\n\t\tnum = convert.size();\n\t\tfor(int k = 0; k < num; ++k)\n\t\t\tfor(int i = 0; i < num; ++i)\n\t\t\t\tfor(int j = 0; j < num; ++j)\n\t\t\t\t\tchmin(mat[i][j], mat[i][k] + mat[k][j]);\n\n\t\tvector<vector<bool> > same(num, vector<bool>(num, false));\n\t\tfor(int i = 0; i < num; ++i) {\n\t\t\tfor(int j = i + 1; j < num; ++j) {\n\t\t\t\tif(mat[i][j] & 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbool is_same = false;\n\n\t\t\t\tfor(int k = 0; k < num; ++k) {\n\t\t\t\t\tif(i == k || j == k)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif((dmat[i][k] && dmat[j][k]) || (dmat[k][i] && dmat[k][j]))\n\t\t\t\t\t\tis_same = true;\n\n\t\t\t\t\tif((dmat[i][k] && dmat[k][j]) || (dmat[j][k] && dmat[k][i]))\n\t\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tsame[i][j] = same[j][i] = is_same;\n\t\t\tnext:;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tfor(int j = 0; j < num; ++j)\n\t\t\t\tdmat[i][j] |= same[i][j];\n\n\t\tint m;\n\t\tcin >> m;\n\n\t\tcout << convert.size() << endl;\n\t\twhile(m--) {\n\t\t\tinput();\n\t\t\tif(!convert.count(a) || !convert.count(b))\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\telse\n\t\t\t\tcout << (check(convert[a], convert[b]) ? \"YES\" : \"NO\") << endl;\t\t\t\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint N,M;\nmap<string,int> mp;\nbool e[200][200],ee[200][200];\nint t[200];\nvoid dfs(int x,int c){\n\tt[x]=c;\n\trep(i,N){\n\t\tif(e[x][i]&&t[i]==0) dfs(i,-c);\n\t\telse if(e[x][i]) assert(t[i]==-t[x]);\n\t}\n\trep(i,N){\n\t\tif(e[i][x]&&t[i]==0) dfs(i,-c);\n\t\telse if(e[i][x]) assert(t[i]==-t[x]);\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>M;\n\t\tif(M==0) break;\n\t\tmp.clear();\n\t\trep(i,200) rep(j,200) e[i][j]=0,ee[i][j]=(i==j);\n\t\trep(i,200) t[i]=0;\n\t\tint J=0;\n\t\trep(i,M){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tif(!mp.count(xx)) mp[xx]=J++;\n\t\t\tif(!mp.count(yy)) mp[yy]=J++;\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\te[x][y]=1;\n\t\t}\n\t\tN=mp.size();\n\t\tcout<<N<<endl;\n\t\tint I=1;\n\t\trep(i,N) if(t[i]==0) dfs(i,I++);\n\t\trep(i,N) rep(j,N){\n\t\t\tbool a=0,b=1;\n\t\t\trep(k,N){\n\t\t\t\tif((e[i][k]||e[k][i])&&(e[j][k]||e[k][j])) a=1;\n\t\t\t\tif((e[i][k]&&e[k][j])||(e[j][k]&&e[k][i])) b=0;\n\t\t\t}\n\t\t\tif(a&&b) ee[i][j]=1;\n\t\t}\n\t\trep(i,N) rep(j,N) e[i][j]|=ee[i][j];\n\t\trep(i,N) rep(j,N) rep(k,N) if(e[j][i]&&e[i][k]) e[j][k]=1;\n\t\tint Q;\n\t\tcin>>Q;\n\t\trep(tt,Q){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tint j=0;\n\t\t\twhile(st[j]!='-') j++;\n\t\t\tstring xx=st.substr(0,j),yy=st.substr(j+1);\n\t\t\tif(!mp.count(xx)||!mp.count(yy)){\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint x=mp[xx],y=mp[yy];\n\t\t\tif(t[x]==-t[y]&&e[x][y]) puts(\"YES\");\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n \nusing namespace std;\n \nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n \nmultimap<string,string>m1,m2;\nmap<string,int>color;\n \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n \nint graph[200][200];\n \nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n    graph[i][j]|=graph[i][k]&graph[k][j];\n}\n \nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    bool g[200][200];\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tg[i][j]=false;\n\tgraph[i][j]=i==j?1:0; \n      }\n    }\n    \n    multimap<string,string>::iterator it,it2;\n    \n    for(it=m1.begin();it!=m1.end();it++){\n      for(it2=m1.begin();it2!=m1.end();it2++){\n\tif(it==it2)continue;\n\t\n\tif((*it).fst==(*it2).sec){\n\t  g[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  g[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  g[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  g[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n      }\n    }\n    \n\n    for(it=m1.begin();it!=m1.end();it++){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n   \n      for(it2=m1.begin();it2!=m1.end();it2++){\n\tif(it==it2)continue;\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n      }\n    }\n    \n    warshall_floyd(node3.size());\n    \n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct Node{\n    string name;\n    vector<int> edge,rev,eq;\n};\n\nstd::vector<string> splitAll(string s,string t){\n  std::vector<string> v;\n  for(int p=0; (p = s.find(t)) != s.npos; ){\n    v.push_back(s.substr(0,p));\n    s=s.substr(p+t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\nint dist[201][201];\n\nvoid make_graph(vector<Node> &g) {\n    for(int i=0; i<g.size(); ++i)\n        for(int j=i+1; j<g.size(); ++j) {\n            bool ok = false;\n            for(int k=0; k<g.size(); ++k) {\n                int c1 = count(g[i].edge.begin(), g[i].edge.end(), k);\n                int c2 = count(g[i].rev.begin(), g[i].rev.end(), k);\n                int d1 = count(g[j].edge.begin(), g[j].edge.end(), k);\n                int d2 = count(g[j].rev.begin(), g[j].rev.end(), k);\n                if((c1 > 0 && d2 > 0) || (c2 > 0 && d1 > 0)) goto NEXT;\n                if((c1 > 0 && d1 > 0) || (c2 > 0 && d2 > 0)) ok = true;\n            }\n            if(ok) g[i].eq.push_back(j),g[j].eq.push_back(i);\n        NEXT:;\n        }\n\n    for(int i=0; i<201; ++i) for(int j=0; j<201; ++j) dist[i][j] = 1<<29;\n    for(int i=0; i<g.size(); ++i) dist[i][i] = 0;\n    for(int i=0; i<g.size(); ++i) {\n        for(int j=0; j<g[i].eq.size(); ++j)\n            dist[i][g[i].eq[j]] = dist[g[i].eq[j]][i] = 0;\n        for(int j=0; j<g[i].edge.size(); ++j)\n            dist[i][g[i].edge[j]] = 1;\n    }\n\n    for(int k=0; k<g.size(); ++k)\n        for(int i=0; i<g.size(); ++i)\n            for(int j=0; j<g.size(); ++j)\n                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n}\n\nint main() {\n    int n,m;\n    string in;\n    while(cin>>n) {\n        if(n == 0) break;\n        map<string, int> idx;\n        vector<Node> g;\n        for(int i=0; i<n; ++i) {\n            cin>>in;\n            vector<string> vs = splitAll(in, \"-\");\n            string name1 = vs[0],name2 = vs[1];\n            if(idx.find(name1) == idx.end()) {\n                idx[name1] = g.size();\n                Node no; no.name = name1;\n                g.push_back(no);\n            }\n            if(idx.find(name2) == idx.end()) {\n                idx[name2] = g.size();\n                Node no; no.name = name2;\n                g.push_back(no);\n            }\n            g[idx[name1]].edge.push_back(idx[name2]);\n            g[idx[name2]].rev.push_back(idx[name1]);\n        }\n\n        make_graph(g);\n        cout<<g.size()<<endl;\n        // for(int i=0; i<g.size(); ++i)\n        //     cout<<i<<\" : \"<<g[i].name<<endl;\n\n        cin>>m;\n        for(int i=0; i<m; ++i) {\n            cin>>in;\n            vector<string> vs = splitAll(in, \"-\");\n            string name1 = vs[0], name2 = vs[1];\n            if(idx.find(name1) == idx.end() || idx.find(name2) == idx.end()) {\n                cout<<\"NO\"<<endl;\n                continue;\n            }\n\n            if(dist[idx[name1]][idx[name2]] < 1<<29\n               && dist[idx[name1]][idx[name2]]%2) {\n                cout<<\"YES\"<<endl;\n            }else{\n                cout<<\"NO\"<<endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\tvs res;\n\tres.push_back(l); res.push_back(r);\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p;\n\t\t\tp++;\n\t\t}\n\t\tcout << p << endl;\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] || dist[k][i]) && (dist[j][k] || dist[k][j])) f1 = true;\n\t\t\t\tif ((dist[i][k] && dist[k][j]) || (dist[k][i] && dist[j][k])) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p)\n\t\t{\n\t\t\tif (dist[i][k] && dist[k][j])\n\t\t\t{\n\t\t\t\tdist[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tvi color(p);\n\t\tint col = 1;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i]) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = -col;\n\t\t\tcolor[i] = c;\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to]) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol++;\n\t\t}\n\t\tint q;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif (color[l] == -color[r] && dist[r][l])\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\nvoid chmin(int &a, int b) {\n    a = min(a, b);\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N;\nmap<string, int> mp;\nset<string> st;\nstring intersection[1005];\nstring before[1005], after[1005];\nstring name[205];\nint dist[205][205];\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    UnionFind uni;\n    while(true) {\n        uni.init(500);\n        st.clear();\n        mp.clear();\n        cin >> N;\n        if(N == 0) break;\n        for(int i = 1; i <= N; i++) {\n            cin >> intersection[i];\n            int moji = 0;\n            while(intersection[i][moji] != '-') moji++;\n            before[i] = intersection[i].substr(0, moji);\n            after[i] = intersection[i].substr(moji + 1);\n            st.insert(before[i]);\n            st.insert(after[i]);\n            //cerr << before[i] << \" \" << after[i] << endl;\n        }\n        int num = 0;\n        for(auto itr = st.begin(); itr != st.end(); itr++) {\n            num++;\n            mp[*itr] = num;\n            name[num] = *itr;\n        }\n        for(int i = 1; i <= num; i++) {\n            for(int j = i + 1; j <= num; j++) {\n                bool beforei[205], afteri[205], beforej[205], afterj[205];\n                for(int i = 1; i <= num; i++) {\n                    beforei[i] = false;\n                    beforej[i] = false;\n                    afteri[i] = false;\n                    afterj[i] = false;\n                }\n                for(int k = 1; k <= N; k++) {\n                    if(mp[before[k]] == i) afteri[mp[after[k]]] = true;\n                    if(mp[before[k]] == j) afterj[mp[after[k]]] = true;\n                    if(mp[after[k]] == i) beforei[mp[before[k]]] = true;\n                    if(mp[after[k]] == j) beforej[mp[before[k]]] = true;\n                }\n                /*\n                cerr << \"----\" << i << \"----\" << endl;\n                for(int k = 1; k <= num; k++) {\n                    cerr << k << \" \" << beforei[k] << \" \" << afteri[k] << endl;\n                }\n                */\n                bool isok = false;\n                for(int k = 1; k <= num; k++) {\n                    if(beforei[k] && beforej[k]) isok = true;\n                    if(afteri[k] && afterj[k]) isok = true;\n                }\n                if(!isok) continue;\n                for(int k = 1; k <= num; k++) {\n                    if(beforei[k] && afterj[k]) isok = false;\n                    if(beforej[k] && afteri[k]) isok = false;\n                }\n                if(isok) uni.merge(i, j);\n            }\n        }\n        /*\n        for(int i = 1; i <= num; i++) {\n            cerr << i << \" \" << name[i] << \" \" << uni.root(i) << endl;\n        }\n        */\n        for(int i = 1; i <= num; i++) {\n            for(int j = 1; j <= num; j++) {\n                dist[i][j] = INF;\n            }\n            dist[i][i] = 0;\n        }\n        /*\n        UnionFind uni2(1000);\n        for(int i = 1; i <= N; i++) {\n            uni2.merge(mp[before[i]], mp[after[i]] + 200);\n            uni2.merge(mp[before[i]] + 200, mp[after[i]]);\n            dist[mp[before[i]]][mp[after[i]]] = 1;\n        }\n        */\n       for(int i = 1; i <= N; i++) {\n           dist[uni.root(mp[before[i]])][uni.root(mp[after[i]])] = 1;\n       }\n        for(int i = 1; i <= num; i++) {\n            for(int j = 1; j <= num; j++) {\n                for(int k = 1; k <= num; k++) {\n                    chmin(dist[j][k], dist[j][i] + dist[i][k]);\n                }\n            }\n        }\n        /*\n        for(int i = 1; i <= num; i++) {\n            for(int j = 1; j <= num; j++) cerr << dist[i][j] << \" \";\n            cerr << endl;\n        }\n        */\n        int M;\n        cin >> M;\n        cout  << st.size() << endl;\n        while(M--) {\n            string in;\n            cin >> in;\n            string a, b;\n            int moji = 0;\n            while(in[moji] != '-') moji++;\n            a = in.substr(0, moji);\n            b = in.substr(moji + 1);\n            if(st.find(a) == st.end() || st.find(b) == st.end()) {\n                cout << \"NO\" << endl;\n                continue;\n            }\n            a = name[uni.root(mp[a])];\n            b = name[uni.root(mp[b])];\n            //cerr << a << \" \" << mp[a] << \" \" << b << \" \" << mp[b] << endl;\n            /*\n            if(!uni2.issame(mp[a], mp[b] + 200)) {\n                //cerr << \"NOT CONNECTED\" << endl;\n                cout << \"NO\" << endl;\n                continue;\n            }\n            */\n            //cerr << dist[mp[a]][mp[b]] << endl;\n            if(dist[mp[a]][mp[b]] == INF) cout << \"NO\" << endl;\n            else if(dist[mp[a]][mp[b]] % 2 == 0) cout << \"NO\" << endl;\n            else cout << \"YES\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\n\ntypedef struct{\n\tint l,r;\n}CROSS;\n\ntypedef struct {\n\tbool walk;\n\tchar name[16+1];\n}LOAD;\n\nint N,M,L;\nLOAD loads[200]; //¹¼Û¶\n\nCROSS crosses[1000];\n\n\nint AddLoad(char *load)\n{\n\tint i;\n\tfor(i = 0; i < L; i++){\n\t\tif(strcmp(load,loads[i].name) == 0) return i;\n\t}\n\tstrcpy(loads[i].name,load); //ÇÁ·é\n\tL++;\n\treturn i;\n}\n\nCROSS AddCross(char *cross)\n{\n\tint len = strlen(cross);\n\tfor(int i = 0; i <= len; i++){\n\t\tif(cross[i] == '-'){\n\t\t\tCROSS cr;\n\t\t\tcross[i] = '\\0';\n\t\t\tcr.l = AddLoad(cross);\n\t\t\tcr.r = AddLoad(cross+i+1);\n\t\t\treturn cr;\n\t\t}\n\t}\n\n\tCROSS dummy;\n\treturn dummy;\n}\n\nint GetLoad(char *load)\n{\n\tfor(int i = 0; i < L; i++){\n\t\tif(strcmp(load,loads[i].name) == 0) return i;\n\t}\n\treturn -1;\n}\n\nCROSS GetCross(char *cross)\n{\n\tint len = strlen(cross);\n\tfor(int i = 0; i <= len; i++){\n\t\tif(cross[i] == '-'){\n\t\t\tCROSS cr;\n\t\t\tcross[i] = '\\0';\n\t\t\tcr.l = GetLoad(cross);\n\t\t\tcr.r = GetLoad(cross+i+1);\n\t\t\treturn cr;\n\t\t}\n\t}\n\n\tCROSS dummy;\n\treturn dummy;\n}\n\ntypedef enum {NONE,OK,NO = -1} FLAG;\nFLAG flag;\n\nvoid JudgeVaild(int l,int r,bool other)\n{\n\tif(flag != NONE) return ; //tO è\n\tif(loads[l].walk) return ; //ùÉà¢½\n\tif(l == r){ //½Çè¢½\n\t\tflag = other ? OK : NO;\n\t\treturn;\n\t}\n\tloads[l].walk = true; //à¢½\n\tfor(int i= 0; i < N; i++){\n\t\tif(crosses[i].l == l) {\n\t\t\tJudgeVaild(crosses[i].r,r,!other);\n\t\t\tif(flag != NONE) return;\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == j || crosses[i].r != crosses[j].r || loads[crosses[j].l].walk) continue;\n\t\t\t\tJudgeVaild(crosses[j].l,r,other);\n\t\t\t\tif(flag != NONE) return;\n\t\t\t}\n\t\t}\n\t\telse if(crosses[i].r == l){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == j || crosses[i].l != crosses[j].l || loads[crosses[j].r].walk) continue;\n\t\t\t\tJudgeVaild(crosses[j].r,r,other);\n\t\t\t\tif(flag != NONE) return;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool IsOk(CROSS crs)\n{\n\tif(crs.l == -1 || crs.r == -1) return false;\n\n\tfor(int j = 0; j < L; j++) loads[j].walk = false; //à¢Ä¢È¢\n\tflag = NONE; //Ü¾tOÈµ\n\tJudgeVaild(crs.l,crs.r,false); //s¯é©Ç¤©»è( l --- r )\n\treturn flag == OK;\n}\n\nvoid solve()\n{\n\tL = 0;\n\n\tfor(int i =0 ; i < N; i++){\n\t\tchar str[34];\n\t\tcin >> str; //¶ñÇÝÝ\n\t\tcrosses[i] = AddCross(str);\n\t}\n\n\tcout << L << endl; //¹oÍ\n\n\tcin >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tchar str[34];\n\t\tcin >> str; //¶ñÇÝÝ\n\t\tCROSS judge = GetCross(str);\n\n\t\tcout << (IsOk(judge) ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n}\n\nint main()\n{\n\twhile(cin >> N,N){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 25;\npair<string, string> cross[1000];\nint dist[200][200];\nint wf[200][200];\nint same[200][200];\n\nint main() {\n\tint n, m;\n\twhile(cin >> n, n) {\n\t\tint sn = 0;\n\t\tmap<string, int> indexer;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tstring s, s1, s2;\n\t\t\tcin >> s;\n\t\t\tint pos = s.find('-');\n\t\t\ts1 = s.substr(0, pos);\n\t\t\ts2 = s.substr(pos + 1, s.size() - (pos + 1));\n\t\t\tcross[i].first = s1;\n\t\t\tcross[i].second = s2;\n\t\t\tif(indexer.count(s1) == 0) {\n\t\t\t\tindexer[s1] = sn++;\n\t\t\t}\n\t\t\tif(indexer.count(s2) == 0) {\n\t\t\t\tindexer[s2] = sn++;\n\t\t\t}\n\t\t}\n\n\t\tcout << sn << endl;\n\n\t\tfor(int i = 0; i < sn; i++) {\n\t\t\tfor(int j = 0; j < sn; j++) {\n\t\t\t\tdist[i][j] = (i == j) ? 0 : INF;\n\t\t\t\twf[i][j] = (i == j) ? 0 : INF;\n\t\t\t\tsame[i][j] = i == j;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint v1 = indexer[cross[i].first], v2 = indexer[cross[i].second];\n\t\t\tdist[v1][v2] = dist[v2][v1] = 1;\n\t\t\twf[v1][v2] = 1;\n\t\t}\n\n\t\tfor(int i = 0; i < sn; i++) {\n\t\t\tfor(int j = i + 1; j < sn; j++) {\n\t\t\t\tbool flag1 = false, flag2 = true;\n\t\t\t\tfor(int k = 0; k < sn; k++) {\n\t\t\t\t\tif(wf[i][k] != INF && wf[j][k] != INF) flag1 = true;\n\t\t\t\t\tif(wf[k][i] != INF && wf[k][j] != INF) flag1 = true;\n\t\t\t\t\tif(wf[i][k] != INF && wf[k][j] != INF) flag2 = false;\n\t\t\t\t\tif(wf[j][k] != INF && wf[k][i] != INF) flag2 = false;\n\t\t\t\t}\n\t\t\t\tsame[i][j] = same[j][i] = flag1 && flag2;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < sn; i++) {\n\t\t\tfor(int j = 0; j < sn; j++) {\n\t\t\t\tif(same[i][j]) wf[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < sn; k++) {\n\t\t\tfor(int i = 0; i < sn; i++) {\n\t\t\t\tfor(int j = 0; j < sn; j++) {\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> m;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tstring s, s1, s2;\n\t\t\tcin >> s;\n\t\t\tint pos = s.find('-');\n\t\t\ts1 = s.substr(0, pos);\n\t\t\ts2 = s.substr(pos + 1, s.size() - (pos + 1));\n\t\t\tif(indexer.count(s1) == 0 || indexer.count(s2) == 0) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint v1 = indexer[s1], v2 = indexer[s2];\n\t\t\tint d = dist[v1][v2];\n\t\t\tif(d != INF && d % 2 && wf[v1][v2] != INF) {\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tchar name[20];\n};\n\nint N,table[200][200],index;\nInfo info[200];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nbool check(int A,int B){\n\n\tbool FLG = false;\n\n\tfor(int k = 0; k < index; k++){\n\t\tif(k == A || k == B)continue;\n\n\t\tif((table[k][A] == 1 && table[k][B] == 1) || (table[A][k] == 1 && table[B][k]== 1)){\n\t\t\tFLG = true;\n\t\t}else if((table[k][A] == 1 && table[B][k] == 1) || (table[A][k] == 1 && table[k][B] == 1)){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn FLG;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 200; i++){\n\t\tfor(int k = 0; k < 200; k++){\n\t\t\ttable[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tindex = 0;\n\tint work_index,left_id,right_id,start;\n\tchar buf[20],work[20];\n\n\tbool FLG;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(work_index = 0; buf[work_index] != '-'; work_index++){\n\t\t\twork[work_index] = buf[work_index];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tFLG = false;\n\t\tfor(int k = 0; k < index; k++){\n\t\t\tif(strCmp(info[k].name,work)){\n\t\t\t\tleft_id = k;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tleft_id = index;\n\t\t\tstrcpy(info[index].name,work);\n\t\t\tindex++;\n\t\t}\n\n\t\tstart = work_index+1;\n\n\t\tfor(work_index = 0; buf[start+work_index] != '\\0'; work_index++){\n\t\t\twork[work_index] = buf[start+work_index];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tFLG = false;\n\n\t\tfor(int k = 0; k < index; k++){\n\t\t\tif(strCmp(info[k].name,work)){\n\t\t\t\tright_id = k;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tright_id = index;\n\t\t\tstrcpy(info[index].name,work);\n\t\t\tindex++;\n\t\t}\n\t\ttable[left_id][right_id] = 1;\n\t}\n\n\tfor(int i = 0; i < index-1; i++){\n\t\tfor(int k = i+1; k < index; k++){\n\t\t\tif(check(i,k)){\n\t\t\t\ttable[i][k] = 2;\n\t\t\t\ttable[k][i] = 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int mid = 0; mid < index; mid++){\n\t\tfor(int start = 0; start < index; start++){\n\t\t\tif(table[start][mid] == BIG_NUM)continue;\n\t\t\tfor(int goal = 0; goal < index; goal++){\n\t\t\t\tif(table[mid][goal] == BIG_NUM)continue;\n\t\t\t\ttable[start][goal] = min(table[start][goal],table[start][mid]+table[mid][goal]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",index);\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(work_index = 0; buf[work_index] != '-'; work_index++){\n\t\t\twork[work_index] = buf[work_index];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tFLG = false;\n\t\tfor(int k = 0; k < index; k++){\n\t\t\tif(strCmp(info[k].name,work)){\n\t\t\t\tleft_id = k;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tstart = work_index+1;\n\n\t\tfor(work_index = 0; buf[start+work_index] != '\\0'; work_index++){\n\t\t\twork[work_index] = buf[start+work_index];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tFLG = false;\n\n\t\tfor(int k = 0; k < index; k++){\n\t\t\tif(strCmp(info[k].name,work)){\n\t\t\t\tright_id = k;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(table[left_id][right_id]%2 == 1){\n\t\t\tprintf(\"YES\\n\");\n\t\t}else{\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\nusing namespace std;\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<iomanip>\n#include<stack>\n#include<set>\n#include<functional>\n#include<map>\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\nconst int dr[] = { 0, 1, 0, -1 };\nconst int dc[] = { 1, 0, -1, 0 };\n\nint f1[212][212];\nint f2[212][212];\n\nint a[3123];\nint b[3123];\nint c[3123];\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\nint N, M;\nmap<string, int> sato;\nvoid init(){\n\tsato.clear();\n\tREP(i, 212)REP(j, 212){\n\t\tf1[i][j] = 0;\n\t\tf2[i][j] = 1;\n\t}\n}\n\nstring nobu[212];\n\nint dfs(int v, int t,V &used,VV &g,int cc){\n\tif (v == t&&cc==0)return 1;\n\tif (used[v])return 0;\n\tused[v] = 1;\n\tint res = 0;\n\tfor (auto &e : g[v]){\n\t\tint u = b[e];\n\t\t//cout << \"edge:\"<<nobu[v] << \" \" << nobu[u] << endl;\n\t\tres |= dfs(u, t, used, g,(cc+c[e])%2);\n\n\t}\n\treturn res;\n}\nint main(){\n\twhile (cin >> N, N){\n\t\tinit();\n\t\tint id = 0;\n\t\tREP(i, N){\n\t\t\tstring xy;\n\t\t\tcin >> xy;\n\t\t\tint pos = 0;\n\t\t\twhile (xy[pos] != '-')pos++;\n\t\t\tauto x = xy.substr(0, pos);\n\t\t\tauto y = xy.substr(pos+1, xy.size() - pos-1);\n\n\t\t\tif (sato.count(x) == 0)sato[x] = id++;\n\t\t\tif (sato.count(y) == 0)sato[y] = id++;\n\t\t\ta[i] = sato[x];\n\t\t\tb[i] = sato[y];\n\t\t\tc[i] = 1;\n\t\t}\n\t\tVV g(id);\n\t\tREP(i, N){\n\t\t\tg[a[i]].push_back(i);\n\t\t}\n\t\tfor (auto &it : sato)nobu[it.second] = it.first;\n\n\t\tREP(i, N)FOR(j, i + 1, N){\n\t\t\tif (a[i] == a[j])f1[b[i]][b[j]] = f1[b[j]][b[i]] = 1;\n\t\t\tif (b[i] == b[j])f1[a[i]][a[j]] = f1[a[j]][a[i]] = 1;\n\t\t\tif (a[i] == b[j])f2[a[j]][b[i]] = f2[b[i]][a[j]] = 0;\n\t\t\tif (b[i] == a[j])f2[a[i]][b[j]] = f2[b[j]][a[i]] = 0;\n\t\t}\n\n\t\tREP(i, id)FOR(j, i + 1, id)if (f1[i][j] && f2[i][j]){\n\t\t\ta[N] = i;\n\t\t\tb[N] = j;\n\t\t\tc[N] = 0;\n\t\t\tg[i].push_back(N++);\n\t\t\ta[N] = j;\n\t\t\tb[N] = i;\n\t\t\tc[N] = 0;\n\t\t\tg[j].push_back(N++);\n\t\t\t//cout << nobu[i] << \" \" << nobu[j] << endl;\n\t\t}\n\n\t\tcout << id << endl;\n\n\t\tint M;\n\t\tcin >> M;\n\n\n\t\tREP(_, M){\n\t\t\tstring xy;\n\t\t\tcin >> xy;\n\t\t\tint pos = 0;\n\t\t\twhile (xy[pos] != '-')pos++;\n\t\t\tauto x = xy.substr(0, pos);\n\t\t\tauto y = xy.substr(pos+1, xy.size() - pos-1);\n\t\t\tif (sato.count(x) == 0 || sato.count(y) == 0){ cout << \"NO\" << endl; continue; }\n\t\t\tint xx = sato[x];\n\t\t\tint yy = sato[y];\n\t\t\tV used(id, 0);\n\t\t\tif (dfs(xx, yy, used, g, 1))cout << \"YES\" << endl;\n\t\t\telse cout << \"NO\" << endl;\n\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        vector<vector<Edge> > edges;\n        vector<vector<int> > rev;\n        for(int i=0; i<n; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                a = edges.size();\n                edges.resize(a + 1);\n                rev.resize(a + 1);\n                index[s1] = a;\n            }else{\n                a = it->second;\n            }\n            it = index.find(s2);\n            if(it == index.end()){\n                b = edges.size();\n                edges.resize(b + 1);\n                rev.resize(b + 1);\n                index[s2] = b;\n            }else{\n                b = it->second;\n            }\n            edges[a].push_back(Edge(b, 1));\n            rev[b].push_back(a);\n        }\n\n        n = edges.size();\n        vector<vector<bool> > check(n, vector<bool>(n, false));\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<edges[i].size(); ++j){\n                int a = edges[i][j].to;\n                for(unsigned k=0; k<edges[a].size(); ++k){\n                    int b = edges[a][k].to;\n                    check[i][b] = check[b][i] = true;\n                }\n            }\n        }\n        for(int i=0; i<n; ++i){\n            for(unsigned j=1; j<edges[i].size(); ++j){\n                if(edges[i][j].cost == 0)\n                    continue;\n                int a = edges[i][j-1].to;\n                int b = edges[i][j].to;\n                if(!check[a][b]){\n                    edges[a].push_back(Edge(b, 0));\n                    edges[b].push_back(Edge(a, 0));\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n            for(unsigned j=1; j<rev[i].size(); ++j){\n                int a = rev[i][j-1];\n                int b = rev[i][j];\n                if(!check[a][b]){\n                    edges[a].push_back(Edge(b, 0));\n                    edges[b].push_back(Edge(a, 0));\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges, dist);\n\n        cout << n << endl;\n        int m;\n        cin >> m;\n        for(int i=0; i<m; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            a = it->second;\n            it = index.find(s2);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            b = it->second;\n\n            if(dist[a][b] != -1 && dist[a][b] % 2 == 1)\n                cout << \"YES\" << endl;\n            else\n                cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\nint n,m,size;\nstring str,a,b;\nmap<string,int> mp;\nint G[201][201];\nint g[201][201];\nint T[201][201];\n\n\nvoid init(){\n  mp.clear();\n  size=0;\n  for(int i=1;i<=200;i++){\n    for(int j=1;j<=200;j++){\n      G[i][j]=(i==j?0:INF);\n      T[i][j]=(i==j?0:INF);\n      g[i][j]=0;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n\n    for(int i=0;i<n;i++){\n      cin>>str;\n      for(int j=0;j<(int)str.size();j++){\n        if(str[j]=='-'){\n          a=str.substr(0,j);\n          b=str.substr(j+1);\n          break;\n        }\n      }\n      if(mp[a]==0)mp[a]=++size;\n      if(mp[b]==0)mp[b]=++size;\n      G[mp[a]][mp[b]]=1;\n      G[mp[b]][mp[a]]=1;\n      T[mp[a]][mp[b]]=1;\n      g[mp[a]][mp[b]]=1;\n    }\n    \n    \n    for(int i=1;i<=size;i++){\n      for(int j=1;j<=size;j++){\n        if(i==j)continue;\n\n        bool flg=false;\n\n        for(int k=1;k<=size;k++){\n          if((g[i][k]||g[k][i])&&(g[j][k]||g[k][j])){\n            flg=true;\n          }\n        }\n              \n        for(int k=1;k<=size;k++){\n          if(g[k][i]&&g[j][k])flg=false;\n          if(g[i][k]&&g[k][j])flg=false;\n        }\n        if(flg){\n          T[i][j]=1;\n        }\n      }\n    }\n    \n    for(int k=1;k<=size;k++){\n      for(int i=1;i<=size;i++){\n        for(int j=1;j<=size;j++){\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n          T[i][j]=min(T[i][j],T[i][k]+T[k][j]);\n        }\n      }\n    }\n\n    cout<<size<<endl;\n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>str;\n      for(int j=0;j<(int)str.size();j++){\n        if(str[j]=='-'){\n          a=str.substr(0,j);\n          b=str.substr(j+1);\n          break;\n        }\n      }\n      int A=mp[a],B=mp[b];\n      \n      if(G[A][B]%2==0&&G[A][B]!=INF){\n        cout<<\"NO\"<<endl;\n      }else if(T[A][B]==INF){\n        cout<<\"NO\"<<endl;\n      }else{\n        cout<<\"YES\"<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n \nusing namespace std;\n \nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n \nbool eq_str(const string& p,const string& q){ p==q; }\n \nmultimap<string,string>m1,m2;\nmap<string,int>color;\n \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n \nint graph[300][300];\n \nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n    graph[i][j]|=graph[i][k]&graph[k][j];\n}\n \nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n    \n    //for(int i=0;i<node.size();i++)cout << node[i] << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    bool g[300][300];\n    for(int i=0;i<300;i++){\n      for(int j=0;j<300;j++){\n\tg[i][j]=false;\n\tgraph[i][j]=i==j?1:0; \n      }\n    }\n    \n    multimap<string,string>::iterator it=m1.begin(),it2=m1.begin();\n    \n    while(it!=m1.end()){\n      it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).sec){\n\t  g[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  g[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  g[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  g[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n\tit2++;\n      }\n      it++;\n    }\n    \n    it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n    \n    warshall_floyd(node3.size());\n    \n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\nvoid split(string s, string &s1, string &s2){\n  for(int i=0;i<s.size();i++){\n    if (s[i] == '-') {\n      s1 = s.substr(0, i);\n      s2 = s.substr(i+1, s.size() - (i + 1));\n      return;\n    }\n  }\n\n  return;\n}\n\nint dist[SIZE][SIZE];\nbool exist[SIZE][SIZE] = {};\n\nbool solve(){\n  int n;\n  map<string, int> dict;\n  int ids = 0;\n  int p[SIZE][2];\n  string s;\n\n  cin >> n;\n\n  if(n == 0) return false;\n\n  for(int i=0;i<200;i++){\n    for(int j=0;j<200;j++){\n      dist[i][j] = INF;\n      exist[i][j] = false;\n    }\n    dist[i][i] = 0;\n  }\n  \n  for(int i=0;i<n;i++){\n    string s1, s2;\n    cin >> s;\n    split(s, s1, s2);\n\n    if(dict.find(s1) == dict.end()) dict[s1] =  ids++;\n    if(dict.find(s2) == dict.end()) dict[s2] =  ids++;\n\n    p[i][0] = dict[s1];\n    p[i][1] = dict[s2];\n\n    dist[p[i][0]][p[i][1]] = 1;\n    exist[p[i][0]][p[i][1]] = true;\n  }\n\n  for(int i=0;i<ids;i++){\n    for(int j=0;j<ids;j++){\n      bool f = false;\n\n      for(int k=0;k<ids;k++){\n        f |= (exist[i][k] || exist[k][i]) && (exist[j][k] || exist[k][j]);\n      }\n\n      for(int k=0;k<ids;k++){\n        f &= !(exist[i][k] && exist[k][j]);\n        f &= !(exist[k][i] && exist[j][k]);\n      }\n\n      if(f) dist[i][j] = dist[j][i] = 2;\n    }\n  }\n\n  for(int k=0;k<ids;k++){\n    for(int i=0;i<ids;i++){\n      for(int j=0;j<ids;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n\n  int q;\n\n  scanf(\"%d\", &q);\n\n  printf(\"%d\\n\", ids);\n  \n  for(int i=0;i<q;i++){\n    string s1, s2;\n    cin >> s;\n    split(s, s1, s2);\n\n    if (dict.find(s1) == dict.end() || dict.find(s2) == dict.end()){\n      puts(\"NO\");\n      continue;\n    }\n    \n    int res = dist[dict[s1]][dict[s2]];\n\n    //debug(dict[s1]); debug(dict[s2]);\n    //debug(res);\n    \n    if(res != INF && res%2){\n      puts(\"YES\");\n    }else{\n      puts(\"NO\");\n    }\n  }\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\nmap<string,int> rtoi;\nint d[256][256];\nint V;\n\nvoid solve(){\n    rep(i,V)rep(j,V){\n        bool C=false, DE=true;\n        if(d[i][j]==1 || d[j][i]==1) continue;\n        rep(k,V){\n            if(k==i || k==j) continue;\n            if((d[i][k]==1||d[k][i]==1) && (d[j][k]==1||d[k][j]==1))\n                C=true;\n            if((d[i][k]==1&&d[k][j]==1) || (d[k][i]==1&&d[j][k]==1))\n                DE=false;\n        }\n        if(C&&DE) d[i][j]=d[j][i]=0;\n    }\n    rep(k,V)rep(i,V)rep(j,V){\n        d[i][j]=min(d[i][j], d[i][k] + d[k][j]);\n    }\n}\n\nbool ask(string const& p, string const& q){\n    int pi=inf,qi=inf;\n    if(rtoi.count(p)==1 || rtoi.count(q)==1){\n        pi=rtoi[p], qi=rtoi[q];\n    }\n    return d[pi][qi]!=inf && d[pi][qi]&1;\n}\n\nint main(){\n    int n;\n    while(cin>>n, n){\n        rep(i,256) rep(j,256) d[i][j]=inf;\n        rep(i,n){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x);\n            string q=s.substr(x+1);\n            if(rtoi.count(p)==0)rtoi[p]=V++;\n            if(rtoi.count(q)==0)rtoi[q]=V++;\n            int ip=rtoi[p], iq=rtoi[q];\n            d[ip][iq]=1;\n        }\n        solve();\n        cout<<V<<endl;\n        int m; cin>>m;\n        rep(i,m){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x), q=s.substr(x+1);\n            continue;\n            puts(ask(p,q)  ? \"YES\" : \"NO\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\nmap<string,int> rtoi;\nint d[256][256];\nint V;\n\nvoid solve(){\n    rep(i,V)rep(j,V){\n        bool C=false, DE=true;\n        if(d[i][j]==1 || d[j][i]==1) continue;\n        rep(k,V){\n            if(k==i || k==j) continue;\n            if((d[i][k]==1||d[k][i]==1) && (d[j][k]==1||d[k][j]==1))\n                C=true;\n            if((d[i][k]==1&&d[k][j]==1) || (d[k][i]==1&&d[j][k]==1))\n                DE=false;\n        }\n        if(C&&DE) d[i][j]=d[j][i]=0;\n    }\n    rep(k,V)rep(i,V)rep(j,V){\n        d[i][j]=min(d[i][j], d[i][k] + d[k][j]);\n    }\n}\n\nbool ask(string const& p, string const& q){\n    int pi=inf,qi=inf;\n    if(rtoi.count(p)==1 || rtoi.count(q)==1){\n        pi=rtoi[p], qi=rtoi[q];\n    }\n    return d[pi][qi]!=inf && d[pi][qi]&1;\n}\n\nint main(){\n    int n;\n    while(cin>>n, n){\n        rep(i,256) rep(j,256) d[i][j]=inf;\n        rep(i,n){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x);\n            string q=s.substr(x+1);\n            if(rtoi.count(p)==0)rtoi[p]=V++;\n            if(rtoi.count(q)==0)rtoi[q]=V++;\n            int ip=rtoi[p], iq=rtoi[q];\n            d[ip][iq]=1;\n        }\n        solve();\n        cout<<V<<endl;\n        int m; cin>>m;\n        rep(i,m){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x), q=s.substr(x+1);\n            puts(ask(p,q)  ? \"YES\" : \"NO\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nmap<string,int> dat;\nint tn;\n\ntypedef pair<string,string> smp;\nsmp gettn(char* s){\n\tint ls=strlen(s);\n\tstring sa,sb;\n\tint hp=0;\n\trep(j,ls)if(s[j]=='-')hp=j;\n\trep(j,hp)sa+=s[j];\n\treg(j,hp+1,ls-1)sb+=s[j];\n\treturn smp(sa,sb);\n}\n\nint strtot(string s,bool re){\n\tif(dat.find(s)==dat.end()){\n\t\tif(re){\n\t\t\tdat[s]=tn; tn++;\n\t\t}\n\t\telse return -1;\n\t}\n\treturn dat[s];\n}\n\nint vs[205][205];\nint gone[205][2];\n\nvoid dfs(int no,int ty){\n\tif(gone[no][ty])return;\n\tgone[no][ty]=1;\n\trep(to,tn){\n\t\tif(vs[no][to]==0)continue;\n\t\tif(gone[to][1-ty]==1)continue;\n\t\tif(vs[no][to]&1)dfs(to,1-ty);\n\t\telse if(vs[no][to]&2)dfs(to,ty);\n\t}\n}\n\nint main(void){\n\tfor(;;){\n\t\tint n,m;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\ttn=0;\n\t\tdat.clear();\n\t\tmemset(vs,0,sizeof(vs));\n\t\t\n\t\trep(i,n){\n\t\t\tchar s[50];\n\t\t\tscanf(\"%s\",s);\n\t\t\t\n\t\t\tsmp pa=gettn(s);\n\t\t\tint a=strtot(pa.fir,true),\n\t\t\t\tb=strtot(pa.sec,true);\n\t\t\t\n\t\t\tvs[a][b]|=1;\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i,tn){\n\t\t\trep(j,tn){\n\t\t\t\tprintf(\"%d \",vs[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t\n\t\tvector<mp> cad;\n\t\trep(i,tn){\n\t\t\trep(j,tn){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tbool has=false,ok=true;\n\t\t\t\trep(k,tn){\n\t\t\t\t\tif(i==k || j==k)continue;\n\t\t\t\t\tif(vs[i][k]==1 && vs[k][j]==1)ok=false;\n\t\t\t\t\tif(vs[k][i]==1 && vs[j][k]==1)ok=false;\n\t\t\t\t\tif(vs[i][k]==1 && vs[j][k]==1)has=true;\n\t\t\t\t\tif(vs[k][i]==1 && vs[k][j]==1)has=true;\n\t\t\t\t\tif(!ok)break;\n\t\t\t\t}\n\t\t\t\tif((!has) || (!ok))continue;\n\t\t\t\tcad.push_back(mp(i,j));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,cad.size()){\n\t\t\tint a=cad[i].fir,b=cad[i].sec;\n\t\t\tvs[a][b]|=2;\n\t\t\tvs[b][a]|=2;\n\t\t}\n\n\n\t\tprintf(\"%d\\n\",dat.size());\n\t\tscanf(\"%d\",&m);\n\t\trep(i,m){\n\t\t\tchar s[50];\n\t\t\tscanf(\"%s\",s);\n\t\t\t\n\t\t\tsmp pa=gettn(s);\n\t\t\tint a=strtot(pa.fir,false),\n\t\t\t\tb=strtot(pa.sec,false);\n\t\t\tif(a==-1 || b==-1){\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tdfs(a,0);\n\t\t\tif(gone[b][1]==1)printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct Node{\n    string name;\n    vector<int> edge,rev,eq;\n    int col;\n};\n\nstd::vector<string> splitAll(string s,string t){\n  std::vector<string> v;\n  for(int p=0; (p = s.find(t)) != s.npos; ){\n    v.push_back(s.substr(0,p));\n    s=s.substr(p+t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\nvoid dfs(vector<Node> &g,int v,int use,bool col) {\n    if(g[v].col != -1) return;\n    g[v].col = use - (col?1:0);\n    for(int i=0; i<g[v].edge.size(); ++i)\n        dfs(g,g[v].edge[i], use, !col);\n\n    for(int i=0; i<g[v].rev.size(); ++i)\n        dfs(g,g[v].rev[i], use, !col);\n\n    return;\n}\n\nint dist[201][201];\n\nvoid make_graph(vector<Node> &g) {\n    for(int i=0; i<g.size(); ++i)\n        for(int j=i+1; j<g.size(); ++j) {\n            bool ok = false;\n            for(int k=0; k<g.size(); ++k) {\n                int c1 = count(g[i].edge.begin(), g[i].edge.end(), k);\n                int c2 = count(g[i].rev.begin(), g[i].rev.end(), k);\n                int d1 = count(g[j].edge.begin(), g[j].edge.end(), k);\n                int d2 = count(g[j].rev.begin(), g[j].rev.end(), k);\n                if((c1 > 0 && d2 > 0) || (c2 > 0 && d1 > 0)) goto NEXT;\n                if((c1 > 0 && d1 > 0) || (c2 > 0 && d2 > 0)) ok = true;\n            }\n            if(ok) g[i].eq.push_back(j),g[j].eq.push_back(i);\n        NEXT:;\n        }\n\n    for(int i=0; i<201; ++i) for(int j=0; j<201; ++j) dist[i][j] = 1<<29;\n    for(int i=0; i<g.size(); ++i) dist[i][i] = 0;\n    for(int i=0; i<g.size(); ++i) {\n        for(int j=0; j<g[i].eq.size(); ++j)\n            dist[i][g[i].eq[j]] = dist[g[i].eq[j]][i] = 0;\n        for(int j=0; j<g[i].edge.size(); ++j)\n            dist[i][g[i].edge[j]] = 1;\n    }\n\n    for(int k=0; k<g.size(); ++k)\n        for(int i=0; i<g.size(); ++i)\n            for(int j=0; j<g.size(); ++j)\n                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n}\n\nvoid coloring(vector<Node> &g) {\n    int use = -1;\n    for(int i=0; i<g.size(); ++i) {\n        if(g[i].col != -1) continue;\n        use += 2;\n        dfs(g, i, use, true);\n    }\n}\n\nbool seen[205];\n\nbool dfs2(vector<Node> &g,int v,int target) {\n    if(v == target) return true;\n    seen[v] = true;\n    for(int i=0; i<g[v].edge.size(); ++i) {\n        if(seen[g[v].edge[i]]) continue;\n        if(dfs2(g, g[v].edge[i], target)) return true;\n    }\n    return false;\n}\n\nint main() {\n    int n,m;\n    string in;\n    while(cin>>n) {\n        if(n == 0) break;\n        map<string, int> idx;\n        vector<Node> g;\n        for(int i=0; i<n; ++i) {\n            cin>>in;\n            vector<string> vs = splitAll(in, \"-\");\n            string name1 = vs[0],name2 = vs[1];\n            if(idx.find(name1) == idx.end()) {\n                idx[name1] = g.size();\n                Node no; no.name = name1; no.col = -1;\n                g.push_back(no);\n            }\n            if(idx.find(name2) == idx.end()) {\n                idx[name2] = g.size();\n                Node no; no.name = name2; no.col = -1;\n                g.push_back(no);\n            }\n            g[idx[name1]].edge.push_back(idx[name2]);\n            g[idx[name2]].rev.push_back(idx[name1]);\n        }\n\n        make_graph(g);\n        cout<<g.size()<<endl;\n        // for(int i=0; i<g.size(); ++i)\n        //     cout<<i<<\" : \"<<g[i].name<<endl;\n\n        cin>>m;\n        for(int i=0; i<m; ++i) {\n            cin>>in;\n            vector<string> vs = splitAll(in, \"-\");\n            string name1 = vs[0], name2 = vs[1];\n            if(idx.find(name1) == idx.end() || idx.find(name2) == idx.end()) {\n                cout<<\"NO\"<<endl;\n                continue;\n            }\n\n//            cout<<dist[idx[name1]][idx[name2]]<<endl;\n            if(dist[idx[name1]][idx[name2]] <= 200\n               && dist[idx[name1]][idx[name2]]%2) {\n                cout<<\"YES\"<<endl;\n            }else{\n                cout<<\"NO\"<<endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\npair<string, string> read(){\n  string str;\n  pair<string, string> res;\n  cin >> str;\n  replace(ALL(str), '-', ' ');\n  istringstream iss(str);\n  iss >> res.first >> res.second;\n  return res;\n}\n\nint main(){\n  int N, M;\n  const int INF = 1e9;\n  while (cin >> N && N){\n    string A, B;\n    map<string, int> I;\n    map<int, string> S;\n    map<int, vector<int> > E;\n    \n    REP(i, N){\n      tie(A, B) = read();\n      if (I.count(A) == 0) {\n        int id = I.size();\n        I[A] = id;\n        S[I[A]] = A;\n      }\n\n      if (I.count(B) == 0) {\n        int id = I.size();\n        I[B] = id;\n        S[I[B]] = B;\n      }\n      E[I[A]].push_back(I[B]);\n    }\n\n    int n = I.size();\n    REP(i, n) sort(ALL(E[i]));\n    \n    vector<vector<int> > D_(n, vector<int>(n, 0));\n    REP(u, n) for (int v : E[u]) D_[u][v] = true;\n\n    \n    vector<vector<int> > D(n, vector<int>(n, INF));\n    REP(i, n) REP(j, i){\n      bool ok = false;\n      REP(k, n) if ((D_[i][k] || D_[k][i]) && (D_[j][k] || D_[k][j])) ok= true;\n      REP(k, n) if (D_[i][k] && D_[k][j]) ok = false;\n      REP(k, n) if (D_[k][i] && D_[j][k]) ok = false;\n      if (ok) D[i][j] = D[j][i] = 0;\n    }\n    REP(i, n) REP(j, n) if (D_[i][j]) D[i][j] = 1;\n    \n    REP(k, n) REP(i, n) REP(j, n) D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n    \n    cout << n << endl;\n    cin >> M;\n    REP(i, M){\n      tie(A, B) = read();\n      if (I.count(A) && I.count(B) && D[I[A]][I[B]] % 2 == 1) cout << \"YES\" << endl;\n      else cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<tuple>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct edge{\n  int v,f;\n};\n\nmap<string,int> m;\nvector<edge> G[2000];\n\nint num(string s){\n  if(!m.count(s)){\n    auto n=m.size();\n    m[s]=n;\n    G[n].clear();\n  }\n  return m[s];\n}\n\ntuple<int,int> input(){\n  string s;\n  cin>>s;\n  int h=s.find('-');\n  int x=num(s.substr(0,h));\n  int y=num(s.substr(h+1));\n  return make_tuple(x,y);\n}\n\nbool dfs(int x,int y,int f,set<int> &s){\n  if(x==y)return f;\n  if(!s.insert(x).second)return false;\n  for(auto e:G[x]){\n    if(dfs(e.v,y,f^e.f,s))return true;\n  }\n  return false;\n}\n\nint main(){\n  for(int N;cin>>N,N;){\n    m.clear();\n    bool d[200][200]={};\n    for(int i=0;i<N;i++){\n      int x,y;\n      tie(x,y)=input();\n      G[y].push_back({x,1});\n      d[y][x]=true;\n    }\n    for(int i=0;i<200;i++){\n      for(int j=0;j<i;j++){\n\tbool s=false,df=false;\n\tfor(int k=0;k<200;k++){\n\t  s|=d[i][k]&&d[j][k]||d[k][i]&&d[k][j];\n\t  df|=d[i][k]&&d[k][j]||d[j][k]&&d[k][i];\n\t}\n\tif(s&&!df){\n\t  G[j].push_back({i,0});\n\t  G[i].push_back({j,0});\n\t}\n      }\n    }\n    cout<<m.size()<<endl;\n    int M;\n    cin>>M;\n    while(M--){\n      int x,y;\n      tie(x,y)=input();\n      set<int> s;\n      cout<<(dfs(y,x,0,s)?\"YES\":\"NO\")<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    vector<int> parent; // em[h\n    vector<int> rank;   // ØÌ³ÌãÀ\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n){ // RXgN^\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n    }\n    void unite(int x, int y){ // xÆyÌO[vð¹\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y])\n                parent[x] = y;\n            else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n            }\n        }\n    }\n    bool same(int x, int y){ // xÆyÌO[vª¯¶©ð²×é\n        return find(x) == find(y);\n    }\n};\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        vector<vector<Edge> > edges;\n        vector<vector<int> > rev;\n        for(int i=0; i<n; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                a = edges.size();\n                edges.resize(a + 1);\n                rev.resize(a + 1);\n                index[s1] = a;\n            }else{\n                a = it->second;\n            }\n            it = index.find(s2);\n            if(it == index.end()){\n                b = edges.size();\n                edges.resize(b + 1);\n                rev.resize(b + 1);\n                index[s2] = b;\n            }else{\n                b = it->second;\n            }\n            edges[a].push_back(Edge(b, 1));\n            rev[b].push_back(a);\n        }\n\n        n = edges.size();\n        vector<vector<bool> > check(n, vector<bool>(n, false));\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<edges[i].size(); ++j){\n                int a = edges[i][j].to;\n                for(unsigned k=0; k<rev[a].size(); ++k){\n                    int b = rev[a][k];\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n        }\n        UnionFindTree uft(n); // ¯\n        for(int i=0; i<n; ++i){\n            for(unsigned j=1; j<edges[i].size(); ++j){\n                int a = edges[i][j-1].to;\n                int b = edges[i][j].to;\n                if(!check[a][b])\n                    uft.unite(a, b);\n            }\n            for(unsigned j=1; j<rev[i].size(); ++j){\n                int a = rev[i][j-1];\n                int b = rev[i][j];\n                if(!check[a][b])\n                    uft.unite(a, b);\n            }\n        }\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                if(uft.same(i, j)){\n                    edges[i].push_back(Edge(j, 2));\n                    edges[j].push_back(Edge(i, 2));\n                }\n            }\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges, dist);\n\n        cout << n << endl;\n        int m;\n        cin >> m;\n        for(int i=0; i<m; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end())\n                continue;\n            a = it->second;\n            it = index.find(s2);\n            if(it == index.end())\n                continue;\n            b = it->second;\n\n            if(dist[a][b] != -1 && dist[a][b] % 2 == 1)\n                cout << \"YES\" << endl;\n            else\n                cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <string.h>\n#define pb push_back\nusing namespace std;\n\nint n,m;\nvector<string> snum;\nvector<vector<int> >g1,g2;\nint g[2000][2000];\nvector<bool> vis;\nvector<int> iro;\n\nint find1(string st){\n  int i;\n  for(i=0;i<snum.size();i++){\n    if(snum[i]==st) return i;\n  }\n  return -1;\n}\n\nbool sol1(int t1,int t2,int x){\n  if(t1==t2){\n    if(x%2==1)return true;\n    else return false;\n  }  \n  int i;\n  for(i=0;i<g1[t1].size();i++){\n    if(vis[g1[t1][i]]==false){\n      vis[g1[t1][i]]=true;\n      if(g[t1][g1[t1][i]]==1){\n        if(sol1(g1[t1][i],t2,x)) return true;\n      }\n      else{\n        if(sol1(g1[t1][i],t2,x+1)) return true;\n      }\n      vis[g1[t1][i]]=false;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int i,j,k;\n  string s;\n  string st1,st2;\n  while(cin>>n,n){\n    memset(g,0,sizeof(g));\n    snum.clear();g1.clear();g2.clear();vis.clear();iro.clear();\n    for(i=0;i<n;i++){\n      vector<int> b1,b2;\n      g1.pb(b1);\n      g2.pb(b2);\n      vis.pb(false);\n    }\n    k=0;\n    for(i=0;i<n;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      if(find1(st1)==-1) snum.pb(st1);\n      if(find1(st2)==-1) snum.pb(st2);\n      g1[find1(st1)].pb(find1(st2));\n      g2[find1(st2)].pb(find1(st1));\n    }\n  \n    for(i=0;i<g2.size();i++){\n      for(j=0;j<g2[i].size();j++){\n        int t=g2[i][j];\n        for(k=j;k<g2[i].size();k++){\n          g1[t].pb(g2[i][k]);\n          g1[g2[i][k]].pb(t);\n          g[t][g2[i][k]]=1;\n          g[g2[i][k]][t]=1;\n        }\n      }      \n    }\n  \n    cin>>m;\n    for(i=0;i<m;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      for(j=0;j<g1.size();j++){vis[j]=false;}\n      if(sol1(find1(st1),find1(st2),0)) cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n\nmap<string,int> dict;\nmap<int,string> rdict;\nint dic(string s){\n\tif( dict.count(s) ) return dict[s];\n\telse{\n\t\tint k = dict.size();\n\t\trdict[k] = s;\n\t\treturn dict[s] = k;\n\t}\n}\n\nint info[210][210];\n\nint same[210][210];\nint muki[210];\n\nvector<int> g[210];\nvector<int> ag[210];\n\nint dfs(int x,int t){\n\tif( muki[x] != -1 ) return 0;\n\tmuki[x] = t;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tdfs(g[x][i],t^1);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tmemset(same,0,sizeof(same));\n\t\tmemset(same,0,sizeof(info));\n\t\tdict.clear();\n\t\tfor(int i = 0 ; i < 210 ; i++) g[i].clear() , ag[i].clear();\n\t\tvector< pair<int,int> > v;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tv.push_back( make_pair( dic(a) , dic(b) ) );\n\t\t\tg[dic(a)].push_back(dic(b));\n\t\t\tg[dic(b)].push_back(dic(a));\n\t\t\tag[dic(a)].push_back(dic(b));\t\n\t\t\tinfo[dic(a)][dic(b)] = 1;\n\t\t}\n\t\t\n\t\tmemset(muki,-1,sizeof(muki));\n\t\tdfs(0,0);\n\t\t\n\t\tint N = dict.size();\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint fl1 = 0 , fl2 = 1;\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( (info[j][k]||info[k][j]) && (info[i][k]||info[k][i]) ){\n\t\t\t\t\t\tfl1 = 1; // onajiyatudousi is same\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( info[k][i] && info[j][k] ) fl2 = 0;\n\t\t\t\t\tif( info[i][k] && info[k][j] ) fl2 = 0;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( fl1 && fl2 ){\n\t\t\t\t\t//cout << rdict[i] << \" \" << rdict[j] << \" \" << \"SAME\" << endl;\n\t\t\t\t\tsame[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tcout << N << endl;\n\t\tfor(int x = 0 ; x < m ; x++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tif( !dict.count(a) || !dict.count(b) || muki[dic(a)] == muki[dic(b)] ){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue<int> Q;\n\t\t\tQ.push(dic(a));\n\t\t\tint dn[210];\n\t\t\tmemset(dn,-1,sizeof(dn));\n\t\t\tdn[dic(a)] = 1;\n\t\t\twhile(Q.size()){\n\t\t\t\tint q = Q.front(); Q.pop();\n\t\t\t\t//cout << rdict[q] << endl;\n\t\t\t\tfor(int i = 0 ; i < ag[q].size() ; i++){\n\t\t\t\t\tif( dn[ag[q][i]] == -1 ) Q.push(ag[q][i]) , dn[ag[q][i]] = 1;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t\t\tif( same[q][i] ){\n\t\t\t\t\t\tif( dn[i] == -1 ) Q.push(i) , dn[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif( dn[dic(b)] == 1){\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<string,int> M;\n\nint str2int(string S){\n    if(M.find(S)==M.end()){\n        int n = M.size();\n        M[S]=n;\n    }\n    return M[S];\n}\n\nint E[200][200];//[a][b]=a to b\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        fill(E[0],E[200],100000000);\n        M.clear();\n        for(int i=0;i<N;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    E[i1][i2]=1;\n                    break;\n                }\n            }\n        }\n        int m = M.size();\n        cout<<m<<endl;\n        for(int i=0;i<m;i++){\n            for(int j=i+1;j<m;j++){\n                //cond1\n                bool b=false;\n                for(int k=0;k<m;k++){\n                    if((E[i][k]==1||E[k][i]==1)&&(E[j][k]==1||E[k][j]==1)){\n                        b=true;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                //cond2,3\n                for(int k=0;k<m;k++){\n                    if((E[k][i]==1&&E[j][k]==1)||(E[i][k]==1&&E[k][j]==1)){\n                        b=false;\n                        break;\n                    }\n                }\n                if(!b) break;\n\n                E[i][j]=E[j][i]=2;\n            }\n        }\n        //WF\n        for(int k=0;k<m;k++){\n            for(int i=0;i<m;i++){\n                for(int j=0;j<m;j++){\n                    E[i][j]=min(E[i][j],E[i][k]+E[k][j]);\n                }\n            }\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    if(E[i1][i2]%2==0){\n                        cout<<\"NO\"<<endl;\n                    }else{\n                        cout<<\"YES\"<<endl;\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\nconst int MAX = 500;\nconst int INF = 1<<29;\n\nmap<string,int> ma;\nint ndp[MAX][MAX];\nint ddp[MAX][MAX];\nint dp[MAX][MAX];\n\nint N, M;\n\nint main() {\n    //freopen( \"/Users/macuser/Dropbox/Contest/input.in\", \"r\", stdin );\n    \n    while (cin >> N) {\n        if (N == 0) break;\n        ma.clear();\n        for (int i = 0; i < MAX; ++i) for (int j = 0; j < MAX; ++j) ndp[i][j] = ddp[i][j] = dp[i][j] = INF;\n        for (int i = 0; i < MAX; ++i) ndp[i][i] = ddp[i][i] = dp[i][i] = 0;\n        \n        vector<string> alt;\n        int it = 0;\n        for (int i = 0; i < N; ++i) {\n            string str; cin >> str;\n            for (int j = 0; j < str.size(); ++j) if (str[j] == '-') str[j] = ' ';\n            istringstream sin(str);\n            string sub1, sub2;\n            sin >> sub1 >> sub2;\n            \n            if (!ma.count(sub1)) ma[sub1] = it++, alt.PB(sub1);\n            if (!ma.count(sub2)) ma[sub2] = it++, alt.PB(sub2);\n            \n            ndp[ma[sub1]][ma[sub2]] = 1;\n            ndp[ma[sub2]][ma[sub1]] = 1;\n            ddp[ma[sub1]][ma[sub2]] = 1;\n        }\n        \n        int n = it;\n        for (int k = 0; k < n; ++k) for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n            chmin(ndp[i][j], ndp[i][k] + ndp[k][j]);\n            chmin(ddp[i][j], ddp[i][k] + ddp[k][j]);\n        }\n        for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n            chmin(dp[i][j], ddp[i][j]);\n            if (ndp[i][j] == 2 && ddp[i][j] >= INF && ddp[j][i] >= INF) dp[i][j] = 0;\n        }\n        for (int k = 0; k < n; ++k) for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n            chmin(dp[i][j], dp[i][k] + dp[k][j]);\n        }\n        \n       // COUT(ma);\n        for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n            //cout << alt[i] << \", \" << alt[j] << \" : \" << ndp[i][j] << \", \" << ddp[i][j] << \", \" << dp[i][j] << endl;\n        }\n         \n        cout << ma.size() << endl;\n        cin >> M;\n        for (int i = 0; i < M; ++i) {\n            string str; cin >> str;\n            for (int j = 0; j < str.size(); ++j) if (str[j] == '-') str[j] = ' ';\n            istringstream sin(str);\n            string sub1, sub2;\n            sin >> sub1 >> sub2;\n            \n            if (!ma.count(sub1)) { puts(\"NO\"); continue; }\n            if (!ma.count(sub2)) { puts(\"NO\"); continue; }\n            int u = ma[sub1], v = ma[sub2];\n            if (ndp[u][v] >= INF) puts(\"NO\");\n            else {\n                if (ndp[u][v] % 2 == 0) puts(\"NO\");\n                else {\n                    if (dp[u][v] < INF) puts(\"YES\");\n                    else puts(\"NO\");\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <string.h>\n#define pb push_back\nusing namespace std;\n\nint n,m;\nvector<string> snum;\nvector<vector<int> >g1,g2;\nint g[1000][1000];\nvector<bool> vis;\nvector<int> iro;\n\nint find1(string st){\n  int i;\n  for(i=0;i<snum.size();i++){\n    if(snum[i]==st) return i;\n  }\n  return -1;\n}\n\nbool sol1(int t1,int t2,int x){\n  if(t1==t2){\n    if(x%2==1)return true;\n    else return false;\n  }  \n  int i;\n  for(i=0;i<g1[t1].size();i++){\n    if(vis[g1[t1][i]]==false){\n      vis[g1[t1][i]]=true;\n      if(g[t1][g1[t1][i]]==1){\n        if(sol1(g1[t1][i],t2,x)) return true;\n      }\n      else{\n        if(sol1(g1[t1][i],t2,x+1)) return true;\n      }\n      vis[g1[t1][i]]=false;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int i,j,k;\n  string s;\n  string st1,st2;\n  while(cin>>n,n){\n    memset(g,0,sizeof(g));\n    snum.clear();g1.clear();g2.clear();vis.clear();iro.clear();\n    for(i=0;i<n;i++){\n      vector<int> b1,b2;\n      g1.pb(b1);\n      g2.pb(b2);\n      vis.pb(false);\n    }\n    k=0;\n    for(i=0;i<n;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      if(find1(st1)==-1) snum.pb(st1);\n      if(find1(st2)==-1) snum.pb(st2);\n      g1[find1(st1)].pb(find1(st2));\n      g2[find1(st2)].pb(find1(st1));\n    }\n  \n    for(i=0;i<g2.size();i++){\n      for(j=0;j<g2[i].size();j++){\n        int t=g2[i][j];\n        for(k=j;k<g2[i].size();k++){\n          g1[t].pb(g2[i][k]);\n          g1[g2[i][k]].pb(t);\n          g[t][g2[i][k]]=1;\n          g[g2[i][k]][t]=1;\n        }\n      }      \n    }\n  \n    cin>>m;\n    for(i=0;i<m;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      for(j=0;j<g1.size();j++){vis[j]=false;}\n      if(sol1(find1(st1),find1(st2),0)) cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        vector<vector<Edge> > edges;\n        vector<vector<int> > rev;\n        for(int i=0; i<n; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                a = edges.size();\n                edges.resize(a + 1);\n                rev.resize(a + 1);\n                index[s1] = a;\n            }else{\n                a = it->second;\n            }\n            it = index.find(s2);\n            if(it == index.end()){\n                b = edges.size();\n                edges.resize(b + 1);\n                rev.resize(b + 1);\n                index[s2] = b;\n            }else{\n                b = it->second;\n            }\n            edges[a].push_back(Edge(b, 1));\n            rev[b].push_back(a);\n        }\n\n        n = edges.size();\n        vector<vector<bool> > check(n, vector<bool>(n, false));\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<edges[i].size(); ++j){\n                int a = edges[i][j].to;\n                for(unsigned k=0; k<rev[a].size(); ++k){\n                    int b = rev[a][k];\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n        }\n        for(int i=0; i<n; ++i){\n            for(unsigned j=1; j<edges[i].size(); ++j){\n                int a = edges[i][j-1].to;\n                int b = edges[i][j].to;\n                if(!check[a][b]){\n                    edges[a].push_back(Edge(b, 2));\n                    edges[b].push_back(Edge(a, 2));\n                }\n            }\n            for(unsigned j=1; j<rev[i].size(); ++j){\n                int a = rev[i][j-1];\n                int b = rev[i][j];\n                if(!check[a][b]){\n                    edges[a].push_back(Edge(b, 2));\n                    edges[b].push_back(Edge(a, 2));\n                }\n            }\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges, dist);\n\n        cout << n << endl;\n        int m;\n        cin >> m;\n        for(int i=0; i<m; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            a = it->second;\n            it = index.find(s2);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            b = it->second;\n\n            if(dist[a][b] != -1 && dist[a][b] % 2 == 1)\n                cout << \"YES\" << endl;\n            else\n                cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing ps = pair<string,string>;\n\nps split(string s){\n    int n = s.size();\n    int idx = 0;\n    while(idx<n && s[idx]!='-') ++idx;\n\n    return {s.substr(0,idx), s.substr(idx+1)};\n}\n\nconst int N = 200;\nconst int INF = 101010;\n\n// 入力から分かる強さ関係\nvector<int> G[N];\nbool arr[N][N];\n\nint d[N][N];\n\n// 水準関係\nint C[N][N];\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        rep(i,N) G[i].clear();\n        rep(i,N)rep(j,N) arr[i][j] = false;\n\n        rep(i,N)rep(j,N) d[i][j]=INF;\n        rep(i,N) d[i][i]=0;\n\n        rep(i,N)rep(j,N) C[i][j]=INF;\n        rep(i,N) C[i][i]=0;\n\n\n        map<string,int> c2id;\n        vector<string> names;\n        rep(i,n){\n            string s;\n            cin >>s;\n            ps cross = split(s);\n\n            if(!c2id.count(cross.fi)){\n                c2id[cross.fi] = c2id.size();\n                names.pb(cross.fi);\n            }\n            if(!c2id.count(cross.se)){\n                c2id[cross.se] = c2id.size();\n                names.pb(cross.se);\n            }\n            int u = c2id[cross.fi], v = c2id[cross.se];\n            G[u].pb(v);\n            C[u][v]=1;\n            d[u][v] = d[v][u] = 1;\n            arr[u][v] = true;\n        }\n\n        int V = c2id.size();\n\n        rep(k,V)rep(i,V)rep(j,V) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        auto same_degree = [&](int a, int b){\n            bool same = false;\n            rep(i,V){\n                if( (arr[a][i]||arr[i][a]) && (arr[b][i]||arr[i][b]) ) same = true;\n            }\n            if(!same) return false;\n\n            rep(i,V){\n                if(arr[i][a]&&arr[b][i]) return false;\n                if(arr[a][i]&&arr[i][b]) return false;\n            }\n            return true;\n        };\n\n        rep(i,V)rep(j,i){\n            if(same_degree(i,j)){\n                // cout << \"DEG :: \" << names[i] << \" \" << names[j] << endl;\n                C[i][j] = C[j][i] = 1;\n            }\n        }\n        rep(k,V)rep(i,V)rep(j,V) C[i][j] = min(C[i][j], C[i][k]+C[k][j]);\n\n        cout << V << endl;\n\n        int Q;\n        cin >>Q;\n        while(Q--){\n            string q;\n            cin >>q;\n\n            ps qc = split(q);\n\n            bool ok = false;\n            if(c2id.count(qc.fi) && c2id.count(qc.se)){\n                int u = c2id[qc.fi], v = c2id[qc.se];\n                // dbg(C[u][v]);\n\n                if(d[u][v]%2==1 && C[u][v]<INF) ok = true;\n            }\n            cout << (ok?\"YES\":\"NO\") << endl;\n        }\n        // dbg(c2id.size());\n        // dbg(names);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\tvs res;\n\tres.push_back(l); res.push_back(r);\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p;\n\t\t\tp++;\n\t\t}\n\t\tcout << p << endl;\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] || dist[k][i]) && (dist[j][k] || dist[k][j])) f1 = true;\n\t\t\t\tif ((dist[i][k] && dist[k][j]) || (dist[k][i] && dist[j][k])) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p)\n\t\t{\n\t\t\tif (dist[i][k] && dist[k][j]) dist[i][j] = 1;\n\t\t}\n\t\tvi color(p);\n\t\tint col = 1;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i]) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = -col;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to]) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol++;\n\t\t}\n\t\tint q;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif (color[l] == -color[r] && dist[r][l])\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nint N, M;\nint V;\nvector<vector<int> > E;\nvector<vector<int> > rE;\nvector<vector<int> > undE;\n\nint tag[310];\nint even[310];\nbool same[310][310];\nint adj[310][310];\n\nvoid init() {\n\tE.clear(); rE.clear(); undE.clear();\n\trep(i,310) {\n\t\ttag[i] = -1;\n\t\teven[i] = -1;\n\t\trep(j,310) {\n\t\t\tsame[i][j] = false;\n\t\t\tadj[i][j] = 0;\n\t\t}\n\t}\n};\n\nbool dfs(int n, int tg, int d) {\n\tif(tag[n]+1)\n\t\treturn false;\n\ttag[n] = tg;\n\teven[n] = d % 2;\n\tfor(int i = 0; i < undE[n].size(); i++) {\n\t\tdfs(undE[n][i], tg, d+1);\n\t}\n\treturn true;\n}\n\nbool used[310];\nbool solve(int n, int gl) {\n\tif(n == gl) return true;\n\tif(used[n]) return false;\n\tused[n] = true;\n\n\tbool res = false;\n\trep(i,rE[n].size()) {\n\t\tif(solve(rE[n][i], gl))\n\t\t\tres = true;\n\t}\n\trep(i,V) {\n\t\tif(same[n][i]) {\n\t\t\tif(solve(i,gl)) res = true;\n\t\t}\n\t}\n\t/*\n\trep(i,E[n].size()) {\n\t\trep(j,rE[E[n][i]].size()) {\n\t\t\tif(solve(rE[E[n][i]][j], gl))\n\t\t\t\tres = true;\n\t\t}\n\t}\n\trep(i,rE[n].size()) {\n\t\trep(j,E[rE[n][i]].size()) {\n\t\t\tif(solve(E[rE[n][i]][j], gl))\n\t\t\t\tres = true;\n\t\t}\n\t}\n\t// */\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> N, N) {\n\t\tinit();\n\t\tmap<string, int> mp;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tstring s, s0, s1;\n\t\t\tcin >> s;\n\t\t\ts0 = string(s.begin(), s.begin()+s.find('-'));\n\t\t\ts1 = string(s.begin()+s0.size()+1, s.end());\n\t\t\tvector<string> vs;\n\t\t\tvs.pb(s0); vs.pb(s1);\n\t\t\tfor(int j = 0; j < vs.size(); j++) {\n\t\t\t\tif(mp.find(vs[j]) == mp.end()) {\n\t\t\t\t\tint id = mp.size();\n\t\t\t\t\tmp[vs[j]] = id;\n\t\t\t\t\tE.pb(vector<int>());\n\t\t\t\t\trE.pb(vector<int>());\n\t\t\t\t\tundE.pb(vector<int>());\n\t\t\t\t}\n\t\t\t}\n\t\t\tint a, b;\n\t\t\ta = mp[s0];\n\t\t\tb = mp[s1];\n\t\t\tE[b].pb(a);\n\t\t\trE[a].pb(b);\n\t\t\tundE[b].pb(a);\n\t\t\tundE[a].pb(b);\n\t\t\tadj[b][a] = true;\n\t\t}\n\t\tV = mp.size();\n\t\tcout << V << endl;\n\t\t//for(auto it = mp.begin(); it != mp.end(); it++) cout << it->second << \":\" << it->first << endl;\n\t\tint tg = 0;\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\ttg += dfs(i, tg, 0);\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i < 10; i++)\n\t\t\tcout << even[i] << \" \" ;\n\t\tcout << endl;\n\t\t// */\n\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\trep(k, V) {\n\t\t\t\t\tif((adj[i][k] && adj[j][k]) || (adj[k][i] && adj[k][j])) {\n\t\t\t\t\t\tsame[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k, V) {\n\t\t\t\t\tif((adj[i][k] && adj[k][j]) || (adj[j][k] && adj[k][i])) {\n\t\t\t\t\t\tsame[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\trep(j,310) used[j] = false;\n\t\t\tstring s, ss[2];\n\t\t\tcin >> s;\n\t\t\tss[0] = string(s.begin(), s.begin()+s.find('-'));\n\t\t\tss[1] = string(s.begin()+s.find('-')+1, s.end());\n\t\t\tbool res = true;\n\t\t\tif(mp.find(ss[0]) == mp.end() || mp.find(ss[1]) == mp.end()\n\t\t\t\t\t|| ss[0] == ss[1] || even[mp[ss[0]]] == even[mp[ss[1]]])\n\t\t\t\tres = false;\n\t\t\tif(res)\n\t\t\t\tres = solve(mp[ss[0]], mp[ss[1]]);\n\t\t\t\n\t\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\n#include <cassert>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\n\nconst int VMAX = 210;\nint N, M;\nmap<string, int> mp;\nbool e[VMAX][VMAX];\nbool ee[VMAX][VMAX];\nint t[VMAX];\n\nvoid dfs(int v, int c){\n    t[v] = c;\n    for(int i=0; i<mp.size(); i++) if(i != v && (e[v][i] || e[i][v])){\n        if(t[i]) assert(t[i] == -c);\n        else dfs(i, -c);\n    }\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin >> N, N){\n        //init\n        mp.clear();\n        for(int i=0; i<VMAX; i++){\n            for(int j=0; j<VMAX; j++){\n                e[i][j] = ee[i][j] = i == j;\n            }\n            t[i] = 0;\n        }\n        \n        string st;\n        for(int i=0; i<N; i++){\n            cin >> st;\n            int j = 0;\n            while(st[j]!='-') j++;\n            string xx = st.substr(0, j);\n            string yy = st.substr(j+1, st.size()-j);\n            if(!mp.count(xx)) mp[xx] = mp.size();\n            if(!mp.count(yy)) mp[yy] = mp.size();\n            e[mp[xx]][mp[yy]] = true;\n        }\n        \n        int J = 1;\n        for(int i=0; i<mp.size(); i++){\n            if(t[i] == 0)\n                dfs(i, J++);\n        }\n        \n        for(int i=0; i<mp.size(); i++){\n            for(int j=0; j<mp.size(); j++) if(i != j){\n                bool fc = false;\n                bool fd = false;\n                for(int k=0; k<mp.size(); k++) if(k != i && k != j){\n                    fc |= (e[i][k] && e[j][k]) || (e[k][i] && e[k][j]);\n                    fd |= (e[i][k] && e[k][j]) || (e[j][k] && e[k][i]);\n                }\n                ee[i][j] = fc && !fd;\n            }\n        }\n        \n        for(int i=0; i<mp.size(); i++)\n            for(int j=0; j<mp.size(); j++)\n                e[i][j] |= ee[i][j];\n        \n        for(int k=0; k<mp.size(); k++)\n            for(int i=0; i<mp.size(); i++)\n                for(int j=0; j<mp.size(); j++)\n                    e[i][j] |= e[i][k] && e[k][j];\n        \n        cin >> M;\n        cout << mp.size() << endl;\n        for(int i=0; i<M; i++){\n            cin >> st;\n            int j = 0;\n            while(st[j]!='-') j++;\n            string xx = st.substr(0, j);\n            string yy = st.substr(j+1, st.size()-j);\n            \n            bool flag;\n            if(mp.count(xx) && mp.count(yy)){\n                int x = mp[xx], y = mp[yy];\n                flag = e[x][y] && t[x] == -t[y];\n            }else{\n                flag = false;\n            }\n            cout << (flag? \"YES\": \"NO\") << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (int)(1e7)\nusing namespace std;\n\nstruct intersection {\n  string s, t;\n};\n\nint n, m;\nmap<string, int> mp;\nvector<vector<int>> dist;\nvector<vector<bool>> memo;\nvector<intersection> v;\n\nintersection parse(string &s);\n\nint main() {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    v.resize(n);\n    mp.clear();\n    for(int i = 0; i < n; ++i) {\n      string s;\n      cin >> s;\n      intersection in = parse(s);\n      if(mp.find(in.s) == mp.end()) {\n        int x = mp.size();\n        mp[in.s] = x;\n      }\n      if(mp.find(in.t) == mp.end()) {\n        int x = mp.size();\n        mp[in.t] = x;\n      }\n      v[i] = in;\n    }\n    cout << mp.size() << endl;\n    dist.assign(mp.size(), vector<int>(mp.size(), inf));\n    memo.assign(mp.size(), vector<bool>(mp.size(), 0));\n    for(int i = 0; i < n; ++i)\n      dist[mp[v[i].s]][mp[v[i].t]] =\n          memo[mp[v[i].s]][mp[v[i].t]] = 1;\n    n = mp.size();\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j)\n        if(!memo[i][j]) {\n          bool ch = 0;\n          for(int k = 0; k < n; ++k)\n            if((memo[i][k] && memo[j][k]) ||\n               (memo[k][i] && memo[k][j]))\n              ch = 1;\n          for(int k = 0; k < n; ++k)\n            if((memo[i][k] && memo[k][j]) ||\n               (memo[j][k] && memo[k][i]))\n              ch = 0;\n          if(ch) dist[i][j] = 2;\n        }\n    for(int k = 0; k < n; ++k)\n      for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n          dist[i][j] =\n              min(dist[i][j], dist[i][k] + dist[k][j]);\n    cin >> m;\n    for(int i = 0; i < m; ++i) {\n      string s;\n      cin >> s;\n      intersection now = parse(s);\n      if(mp.find(now.s) == mp.end() ||\n         mp.find(now.t) == mp.end() ||\n         dist[mp[now.s]][mp[now.t]] % 2 == 0)\n        cout << \"NO\" << endl;\n      else\n        cout << \"YES\" << endl;\n    }\n  }\n  return 0;\n}\n\nintersection parse(string &s) {\n  bool ch = 0;\n  intersection res = {\"\", \"\"};\n  int len = s.size();\n  for(int i = 0; i < len; ++i) {\n    if(s[i] == '-') {\n      ch = 1;\n      continue;\n    }\n    if(!ch)\n      res.s += s[i];\n    else\n      res.t += s[i];\n  }\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <string.h>\n#define pb push_back\nusing namespace std;\n\nint n,m;\nvector<string> snum;\nvector<vector<int> >g1,g2;\nint g[200][200];\nvector<bool> vis;\nvector<int> iro;\n\nint find1(string st){\n  int i;\n  for(i=0;i<snum.size();i++){\n    if(snum[i]==st) return i;\n  }\n  return -1;\n}\n\nbool sol1(int t1,int t2,int x){\n  if(t1==t2){\n    if(x%2==1)return true;\n    else return false;\n  }  \n  int i;\n  for(i=0;i<g1[t1].size();i++){\n    if(vis[g1[t1][i]]==false){\n      vis[g1[t1][i]]=true;\n      if(g[t1][g1[t1][i]]==1){\n        if(sol1(g1[t1][i],t2,x)) return true;\n      }\n      else{\n        if(sol1(g1[t1][i],t2,x+1)) return true;\n      }\n      vis[g1[t1][i]]=false;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int i,j,k;\n  string s;\n  string st1,st2;\n  while(cin>>n,n){\n    memset(g,0,sizeof(g));\n    snum.clear();g1.clear();g2.clear();vis.clear();iro.clear();\n    for(i=0;i<n;i++){\n      vector<int> b1,b2;\n      g1.pb(b1);\n      g2.pb(b2);\n      vis.pb(false);\n    }\n    k=0;\n    for(i=0;i<n;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      if(find1(st1)==-1) snum.pb(st1);\n      if(find1(st2)==-1) snum.pb(st2);\n      g1[find1(st1)].pb(find1(st2));\n      g2[find1(st2)].pb(find1(st1));\n    }\n  \n    for(i=0;i<g2.size();i++){\n      for(j=0;j<g2[i].size();j++){\n        int t=g2[i][j];\n        for(k=j;k<g2[i].size();k++){\n          g1[t].pb(g2[i][k]);\n          g1[g2[i][k]].pb(t);\n          g[t][g2[i][k]]=1;\n          g[g2[i][k]][t]=1;\n        }\n      }      \n    }\n  \n    cin>>m;\n    for(i=0;i<m;i++){\n      cin>>s;\n      st1=s.substr(0,s.find('-'));\n      st2=s.substr(s.find('-')+1,s.size());\n      for(j=0;j<g1.size();j++){vis[j]=false;}\n      if(sol1(find1(st1),find1(st2),0)) cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int inf = 1e9;\n\nclass quick_find {\npublic:\n    quick_find(int n) : par(n, -1), cmp(n) {\n        for(int i = 0; i < n; ++i) {\n            cmp[i].push_back(i);\n        }\n    }\n\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if(x == y) return false;\n        if(cmp[x].size() > cmp[y].size()) swap(x, y);\n        for(auto v : cmp[y]) {\n            cmp[x].push_back(v);\n        }\n        cmp[y].clear();\n        par[y] = x;\n        return true;\n    }\n\n    std::vector<int> component(int v) {\n        return cmp[root(v)];\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int v) {\n        return cmp[root(v)].size();\n    }\n\nprivate:\n    std::vector<int> par;\n    std::vector<std::vector<int>> cmp;\n};\n\npair<string, string> split(string cross) {\n    int sp = cross.find('-');\n    return {cross.substr(0, sp), cross.substr(sp + 1)};\n}\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        vector<vector<int>> g(2 * N), rg(2 * N), g2(2 * N);\n        map<string, int> idx;\n        for(int i = 0; i < N; ++i) {\n            string cross;\n            cin >> cross;\n            string s, t;\n            tie(s, t) = split(cross);\n            if(idx.count(s) == 0) {\n                const int nid = idx.size();\n                idx[s] = nid;\n            }\n            if(idx.count(t) == 0) {\n                const int nid = idx.size();\n                idx[t] = nid;\n            }\n            g[idx[s]].push_back(idx[t]);\n            rg[idx[t]].push_back(idx[s]);\n            g2[idx[s]].push_back(idx[t]);\n            g2[idx[t]].push_back(idx[s]);\n        }\n\n        N = idx.size();\n        cout << N << endl;\n\n        quick_find qf(N);\n        vector<vector<bool>> can_go(N, vector<bool>(N));\n        vector<int> dir(N, -1);\n        function<void(int, int)> dfs = [&](int root, int v) {\n            if(can_go[root][v]) return;\n            can_go[root][v] = true;\n            for(auto to : g[v]) {\n                dfs(root, to);\n            }\n        };\n        for(int i = 0; i < N; ++i) {\n            dfs(i, i);\n        }\n        for(int i = 0; i < N; ++i) {\n            for(auto j = 0; j < (int)g[i].size(); ++j) {\n                for(int k = j + 1; k < (int)g[i].size(); ++k) {\n                    int v1 = g[i][j], v2 = g[i][k];\n                    if(!can_go[v1][v2] && !can_go[v2][v1]) {\n                        qf.unite(v1, v2);\n                    }\n                }\n            }\n            for(int j = 0; j < (int)rg[i].size(); ++j) {\n                for(int k = j + 1; k < (int)rg[i].size(); ++k) {\n                    int v1 = rg[i][j], v2 = rg[i][k];\n                    if(!can_go[v1][v2] && !can_go[v2][v1]) {\n                        qf.unite(v1, v2);\n                    }\n                }\n            }\n        }\n        \n        can_go = vector<vector<bool>>(N, vector<bool>(N));\n        for(int i = 0; i < N; ++i) {\n            auto now = qf.component(i);\n            for(auto from : now) {\n                for(auto to : g[from]) {\n                    if(can_go[i][to]) continue;\n                    auto cmp = qf.component(to);\n                    for(auto to2 : cmp) {\n                        can_go[i][to2] = true;\n                    }\n                }\n            }\n        }\n        for(int k = 0; k < N; ++k) {\n            for(int i = 0; i < N; ++i) {\n                for(int j = 0; j < N; ++j) {\n                    can_go[i][j] = can_go[i][j] | (can_go[i][k] && can_go[k][j]);\n                }\n            }\n        }\n        function<void(int, int, int)> dfs2 = [&](int v, int p, int d) {\n            if(dir[v] != -1) return;\n            dir[v] = d;\n            for(auto to : g2[v]) {\n                if(to == p) continue;\n                dfs2(to, v, d ^ 1);\n            }\n        };\n        for(int i = 0; i < N; ++i) {\n            dfs2(i, -1, 0);\n        }\n\n        int M;\n        cin >> M;\n        while(M--) {\n            string query;\n            cin >> query;\n            string s, t;\n            tie(s, t) = split(query);\n            if(s == t || idx.count(s) == 0 || idx.count(t) == 0) {\n                cout << \"NO\" << endl;\n            } else {\n                int si = idx[s], ti = idx[t];\n                if(dir[si] == dir[ti]) {\n                    cout << \"NO\" << endl;\n                } else {\n                    if(can_go[si][ti]) {\n                        cout << \"YES\" << endl;\n                    } else {\n                        cout << \"NO\" << endl;\n                    }\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n#define pb push_back\n#define pf push_front\n#define rep(i,n) for (int i=0; i < (n); i++)\n#define all(c) (c).begin(), (c).end()\n\nstruct michi{\n  VS upper,lower;\n  char verti;\n  bool check;\n};\nmap<string,michi> mamap;\nvoid nocheck(){\n  for(map<string,michi>::iterator a=mamap.begin();\n      a!=mamap.end();a++){\n    a->second.check=false;\n  }\n}\n\n\nbool searchup(string desti,string pres){\n  // cout<<pres<<\" dddddddd    \";\n  if(mamap[pres].check) return false;\n  mamap[pres].check=true;\n  \n  if(desti==pres) return true;\n  VS dolist=mamap[pres].lower;\n  //  cout<<uplist.size();\n  for(VS::iterator a=dolist.begin();\n      a!=dolist.end();a++){\n    //    cout<<*a<<\"  keke\";\n    VS uup=mamap[*a].upper;\n    for(VS::iterator b=uup.begin();\n\tb!=uup.end();b++){\n      if(searchup(desti,*b)) return true;\n    }    \n  }\n  VS uplist=mamap[pres].upper;\n  for(VS::iterator a=uplist.begin();\n      a!=uplist.end();a++){\n    //    cout<<*a<<\"  keke\";\n    if(searchup(desti,*a)) return true;  \n  }\n\n  return false;\n}\nbool sesearch(string fir,string sec){\n  michi strong,weak;\n  strong=mamap[fir];\n  weak=mamap[sec];\n  // cout<<endl<<endl<<endl<<fir<<sec<<endl;\n  // cout<<(int)strong.verti<<(int)weak.verti<<endl;\n  if(strong.verti==weak.verti) return false;\n\n  nocheck();\n  if(searchup(fir,sec)) return true;\n  // if(searchup(sec,fir)){\n  //   cout<<\"hehe\";\n  //   nocheck();\n  //   if(searchup(fir,sec)) return true;\n  //   else return false;\n  // }\n  return false;\n}\nvoid vertisho(string fir,char vert){\n  if(mamap[fir].verti!=-1) return; \n  mamap[fir].verti=vert;\n\n  if(vert==1) vert=0;\n  else if(vert==0) vert=1;\n  //cout<<fir<<\" \"<<(int)mamap[fir].verti<<endl;\n  for(VS::iterator a=mamap[fir].upper.begin();\n      a!=mamap[fir].upper.end();a++){\n    //    cout<<*a<<endl;\n    vertisho(*a,vert);\n  }\n  for(VS::iterator a=mamap[fir].lower.begin();\n      a!=mamap[fir].lower.end();a++)\n    vertisho(*a,vert);\n}\nvoid wakeru(string& a,string& b){\n  int i;\n  string tmp;\n  cin>>tmp;\n  for(i=0;i<tmp.size();i++){\n    if(tmp[i]=='-') break;\n  }\n  a=tmp.substr(0,i);\n  b=tmp.substr(i+1);\n  // cout<<a<<endl<<b<<endl;\n\n}\n\nint main() {\n  int n,m,tmptmp;\n  string fir,sec,tmpst;\n  michi ue,sita;\n  while(true){\n    mamap=map<string,michi>();\n    cin>>n;\n    if(n==0) return 0;\n    //    cout<<\"n:\"<<n<<\"m:\"<<m<<endl;\n    rep(i,n){\n      wakeru(fir,sec);\n      //cin>>fir>>sec;\n      //cout<<fir<<endl<<sec<<endl;\n      // mamap[fir].lower.pb[sec];\n      // mamap[sec].upper.pb[fir];\n      ue=mamap[fir];\n      sita=mamap[sec];\n      ue.lower.pb(sec);\n      sita.upper.pb(fir);\n      mamap[fir]=ue;\n      mamap[sec]=sita;\n    }\n     for(map<string,michi>::iterator a=mamap.begin();\n      a!=mamap.end();a++){\n       a->second.verti=-1;\n       //       cout<<a->first<<(int)a->second.verti<<endl;\n    }\n     nocheck();\n     vertisho(fir,0);\n     cout<<mamap.size()<<endl;\n     cin>>m;\n     rep(i,m){\n       wakeru(fir,sec);\n\n       //cout<<fir<<endl<<sec<<endl;\n       nocheck();\n       if(sesearch(fir,sec)) cout<<\"YES\"<<endl;\n       else cout<<\"NO\"<<endl;\n      \n     }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint N,m,n,st[210][210],same[210][210];\n\nint main(){\n\twhile(cin>>N && N){\n\t\trep(i,210)rep(j,210)st[i][j]=i==j?0:INF;\n\t\tmap<string,int> M;\n\t\tn=0;\n\t\trep(i,N){\n\t\t\tstring s,t,u;\n\t\t\tcin>>s;\n\t\t\tint mode=0;\n\t\t\trep(j,s.sz){\n\t\t\t\tif(s[j]=='-')mode=1;\n\t\t\t\telse mode?u+=s[j]:t+=s[j];\n\t\t\t}\n\t\t\tif(M.find(t)==M.end())M[t]=n++;\n\t\t\tif(M.find(u)==M.end())M[u]=n++;\n\t\t\tst[M[t]][M[u]]=1;\n\t\t}\n\t\trep(i,n)rep(j,n){\n\t\t\tint ok=0;\n\t\t\trep(k,n){\n\t\t\t\tif(st[i][k]==1&&st[j][k]==1\n\t\t\t\t|| st[k][i]==1&&st[k][j]==1)ok=1;\n\t\t\t\tif(st[i][k]==1&&st[k][j]==1\n\t\t\t\t|| st[j][k]==1&&st[k][i]==1){\n\t\t\t\t\tok=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)st[i][j]=0;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tst[i][j]=min(st[i][j],st[i][k]+st[k][j]);\n\t\t}\n\t\tcout<<n<<endl;\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tstring s,t,u;\n\t\t\tcin>>s;\n\t\t\tint mode=0;\n\t\t\trep(j,s.sz){\n\t\t\t\tif(s[j]=='-')mode=1;\n\t\t\t\telse mode?u+=s[j]:t+=s[j];\n\t\t\t}\n\t\t\tif(M.find(t)==M.end() || M.find(u)==M.end()){\n\t\t\t\tcout<<\"NO\"<<endl;continue;\n\t\t\t}\n\t\t\tint T=M[t],U=M[u];\n\t\t\tcout<<(st[T][U]<INF && st[T][U]%2 ? \"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\nmap<string,int> rtoi;\nint d[256][256];\nint V;\n\nvoid solve(){\n    rep(i,V)rep(j,V){\n        bool C=false, DE=true;\n        if(d[i][j]==1 || d[j][i]==1) continue;\n        rep(k,V){\n            if(k==i || k==j) continue;\n            if((d[i][k]==1||d[k][i]==1) && (d[j][k]==1||d[k][j]==1))\n                C=true;\n            if((d[i][k]==1&&d[k][j]==1) || (d[k][i]==1&&d[j][k]==1))\n                DE=false;\n        }\n        if(C&&DE) d[i][j]=d[j][i]=0;\n    }\n    rep(k,V)rep(i,V)rep(j,V){\n        d[i][j]=min(d[i][j], d[i][k] + d[k][j]);\n    }\n}\n\nbool ask(string const& p, string const& q){\n    int pi=inf,qi=inf;\n    if(rtoi.count(p)==1 && rtoi.count(q)==1){\n        pi=rtoi[p], qi=rtoi[q];\n    }\n    return max(pi,qi)!=inf && d[pi][qi]!=inf && d[pi][qi]&1;\n}\n\nint main(){\n    int n;\n    while(cin>>n, n){\n        rep(i,256) rep(j,256) d[i][j]=inf;\n        rep(i,n){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x);\n            string q=s.substr(x+1);\n            if(rtoi.count(p)==0)rtoi[p]=V++;\n            if(rtoi.count(q)==0)rtoi[q]=V++;\n            int ip=rtoi[p], iq=rtoi[q];\n            d[ip][iq]=1;\n        }\n        solve();\n        cout<<V<<endl;\n        int m; cin>>m;\n        rep(i,m){\n            string s;cin>>s;\n            int x=s.find('-');\n            string p=s.substr(0,x), q=s.substr(x+1);\n            puts(ask(p,q)  ? \"YES\" : \"NO\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) ((int)(a).size())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nint n;\nmap<string, int> memo;\nvector<string> mstr;\nint get(string a){\n  if(memo.count(a))\n    return memo[a];\n  int sz = SZ(memo);\n  mstr.pb(a);\n  return memo[a] = sz;\n}\n\nvector<PI> G[2000];\nint vis[2000];\nint vcnt;\nbool app[2000][2000];\n\nvector<int> cG[2000];\n\nvoid solve(){\n  memo.clear();\n  mstr.clear();\n  rep(i, n*2) G[i].clear();\n  rep(i, n*2) cG[i].clear();\n  \n  set<PI> input;\n  rep(i, n){\n    string a, b;\n    cin >> a;\n    a[a.find('-')] = ' ';\n    stringstream ss(a);\n    ss >> a >> b;\n    int u = get(a);\n    int v = get(b);\n    G[u].pb(mp(v,1));\n    cG[u].pb(v);\n    cG[v].pb(u);\n    input.insert(mp(u, v));\n  }\n  \n  \n  cout << SZ(memo) << endl;\n  rep(i, SZ(memo)) rep(j, SZ(memo)) app[i][j] = 0;\n  for(auto e : input) app[e.F][e.S] = 1;\n  \n  rep(d, SZ(memo)){\n    for(auto a : cG[d]) for(auto b : cG[d]){\n        if(a == b) break;\n        if((!app[d][a] || !app[b][d]) &&\n           (!app[d][b] || !app[a][d])){\n          G[a].pb(mp(b,0));\n          G[b].pb(mp(a,0));\n        }\n      }\n  }\n\n  // rep(d, SZ(memo)){\n  //   cout << mstr[d] << \": \";\n  //   for(auto e : G[d])\n  //     cout << mstr[e.F] << \",\";\n  //   cout << endl;\n  // }\n  \n  int q;\n  cin >> q;\n  rep(i, q){\n    string a, b;\n    cin >> a;\n    a[a.find('-')] = ' ';\n    stringstream ss(a);\n    ss >> a >> b;\n\n    if(memo.count(a) && memo.count(b));\n    else{\n      cout << \"NO\" << endl;\n      continue;\n    }\n    \n    int u = get(a);\n    int v = get(b);\n    queue<PI> q;\n    q.push(mp(u,0));\n    \n    bool ok = false;\n    ++vcnt;\n    while(!q.empty()){\n      int cv = q.front().F;\n      int cc = q.front().S;\n      q.pop();\n      if(cv == v){\n        //cout << \"cc \" << cc << endl;\n        ok = cc & 1;\n        break;\n      }\n      if(vis[cv] == vcnt) continue;\n      //cout << mstr[cv] << endl;\n      vis[cv] = vcnt;\n      for(auto e : G[cv]) if(vis[e.F] != vcnt) q.push(mp(e.F, cc+e.S));\n    }\n    \n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<string, string> pss;\n\npss split(string s) {\n  ll k;\n  REP(i, 0, s.size()) if(s[i] == '-') k = i;\n  string fi = s.substr(0, k);\n  string se = s.substr(k + 1, s.size() - k - 1);\n  return pss(fi, se);\n}\n\nvoid dfs(ll v, vector<vector<ll>> &E, vector<bool> &used, vector<ll> &color, ll c) {\n  if(used[v]) return;\n  used[v] = true;\n\n  color[v] = c;\n  for(ll u : E[v]) dfs(u, E, used, color, -c);\n}\n\nbool dfs2(ll v, ll g, vector<vector<ll>> &E, vector<bool> &used) {\n  if(v == g) return true;\n\n  if(used[v]) return false;\n  used[v] = true;\n\n  bool ret = false;\n  for(ll u : E[v]) ret = ret || dfs2(u, g, E, used);\n  return ret;\n}\n\nint main(void) {\n  ll N, M;\n  while(cin >> N, N) {\n    vector<string> uniq;\n    vector<pss> C(N);\n    REP(i, 0, N) {\n      string s;\n      cin >> s;\n      C[i] = split(s);\n      uniq.push_back(C[i].first);\n      uniq.push_back(C[i].second);\n    }\n    cin >> M;\n    vector<pss> Q(M);\n    REP(i, 0, M) {\n      string s;\n      cin >> s;\n      Q[i] = split(s);\n      uniq.push_back(Q[i].first);\n      uniq.push_back(Q[i].second);\n    }\n    sort(uniq.begin(), uniq.end());\n    uniq.erase(unique(uniq.begin(), uniq.end()), uniq.end());\n\n    vector<pll> cross(N), query(M);\n    REP(i, 0, N) {\n      cross[i].first = lower_bound(uniq.begin(), uniq.end(), C[i].first) - uniq.begin();\n      cross[i].second = lower_bound(uniq.begin(), uniq.end(), C[i].second) - uniq.begin();\n    }\n    REP(i, 0, M) {\n      query[i].first = lower_bound(uniq.begin(), uniq.end(), Q[i].first) - uniq.begin();\n      query[i].second = lower_bound(uniq.begin(), uniq.end(), Q[i].second) - uniq.begin();\n    }\n\n    ll n = uniq.size();\n    vector<vector<ll>> E(n), R(n), A(n), X(n);\n    REP(i, 0, N) {\n      E[cross[i].first].push_back(cross[i].second);\n      R[cross[i].second].push_back(cross[i].first);\n      A[cross[i].first].push_back(cross[i].second);\n      A[cross[i].second].push_back(cross[i].first);\n      X[cross[i].first].push_back(cross[i].second);\n    }\n\n    vector<bool> used(n, false);\n    vector<ll> color(n);\n    ll c = 1;\n    REP(i, 0, n) if(!used[i]) dfs(i, A, used, color, c++);\n\n    vector<vector<bool>> e(n, vector<bool>(n, false));\n    REP(i, 0, N) e[cross[i].first][cross[i].second] = true;\n    REP(i, 0, n) REP(j, 0, n) {\n      bool c1 = false, c2 = true;\n      REP(k, 0, n) {\n        c1 = c1 || (e[i][k] && e[j][k]) || (e[k][i] && e[k][j]);\n        c2 = c2 && !(e[i][k] && e[k][j]) && !(e[j][k] && e[k][i]);\n      }\n      if(c1 && c2) {\n        X[i].push_back(j);\n        X[j].push_back(i);\n      }\n    }\n\n    set<ll> st;\n    REP(i, 0, N) {\n      st.insert(cross[i].first);\n      st.insert(cross[i].second);\n    }\n\n    cout << st.size() << endl;\n    REP(i, 0, M) {\n      ll s = query[i].first, t = query[i].second;\n      vector<bool> used2(n, false);\n      bool ok = color[s] == -color[t] && dfs2(s, t, X, used2);\n      cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n\nmap<string,int> dict;\nmap<int,string> rdict;\nint dic(string s){\n\tif( dict.count(s) ) return dict[s];\n\telse{\n\t\tint k = dict.size();\n\t\trdict[k] = s;\n\t\treturn dict[s] = k;\n\t}\n}\n\nint info[210][210];\n\nint same[210][210];\nint muki[210];\n\nvector<int> g[210];\nvector<int> ag[210];\n\nint dfs(int x,int t){\n\tif( muki[x] != -1 ){\n\t\treturn 0;\n\t}\n\tmuki[x] = t;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tdfs(g[x][i],t^1);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tmemset(same,0,sizeof(same));\n\t\tmemset(info,0,sizeof(info));\n\t\tdict.clear();\n\t\trdict.clear();\n\t\tfor(int i = 0 ; i < 210 ; i++) g[i].clear() , ag[i].clear();\n\t\tvector< pair<int,int> > v;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tv.push_back( make_pair( dic(a) , dic(b) ) );\n\t\t\tg[dic(a)].push_back(dic(b));\n\t\t\tg[dic(b)].push_back(dic(a));\n\t\t\tag[dic(a)].push_back(dic(b));\t\n\t\t\tinfo[dic(a)][dic(b)] = 1;\n\t\t}\n\t\tint N = dict.size();\n\t\t\n\t\tmemset(muki,-1,sizeof(muki));\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tif( muki[i] == -1 ) dfs(i,0);\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint fl1 = 0 , fl2 = 1;\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( (info[j][k]&&info[i][k])||(info[k][i]&&info[k][j]) ){\n\t\t\t\t\t\tfl1 = 1; // onajiyatudousi is same\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( info[k][i] && info[j][k] ) fl2 = 0;\n\t\t\t\t\tif( info[i][k] && info[k][j] ) fl2 = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( fl1 && fl2 ){\n\t\t\t\t\t//cout << rdict[i] << \" \" << rdict[j] << \" \" << \"SAME\" << endl;\n\t\t\t\t\tsame[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tcout << N << endl;\n\t\tfor(int x = 0 ; x < m ; x++){\n\t\t\tstring l; cin >> l;\n\t\t\tfor(int j = 0 ; j < l.size() ; j++) if( l[j] == '-' ) l[j] = ' ';\n\t\t\tstringstream ss(l);\n\t\t\tstring a,b;\n\t\t\tss >> a >> b;\n\t\t\tif( !dict.count(a) || !dict.count(b) || muki[dic(a)] == muki[dic(b)] ){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue<int> Q;\n\t\t\tQ.push(dic(a));\n\t\t\tint dn[210];\n\t\t\tmemset(dn,-1,sizeof(dn));\n\t\t\tdn[dic(a)] = 1;\n\t\t\twhile(Q.size()){\n\t\t\t\tint q = Q.front(); Q.pop();\n\t\t\t\t//cout << rdict[q] << endl;\n\t\t\t\tfor(int i = 0 ; i < ag[q].size() ; i++){\n\t\t\t\t\tif( dn[ag[q][i]] == -1 ) Q.push(ag[q][i]) , dn[ag[q][i]] = 1;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t\t\tif( same[q][i] ){\n\t\t\t\t\t\tif( dn[i] == -1 ) Q.push(i) , dn[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif( dn[dic(b)] == 1){\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nstruct Node {\n    int level;\n    int color;\n    int group;\n    vector<int> edges, back_edges;\n    vector<int> pending;\n    Node() : level(0), color(1) {}\n};\n\nstruct Dict {\n    int idx;\n    map<string,int> dict;\n\n    Dict() : idx(0) {}\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = idx++;\n    }\n\n    int size() const {\n        return idx;\n    }\n};\n\n#define FOREACH(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define TIMES(i,n) for(int (i) = 0; (i) < (n); ++(i))\n\ntypedef vector<unsigned char> Flag;\n\nvoid preprocess(int pos, vector<Node> &nodes, Flag &visited, int group) {\n    if(visited[pos]) return;\n    visited[pos] = 1;\n\n    Node &cur = nodes[pos];\n    cur.group = group;\n    FOREACH(it, cur.edges) {\n        if(visited[*it]) continue;\n        nodes[*it].level = cur.level+1;\n        nodes[*it].color = 1 - cur.color;\n        preprocess(*it, nodes, visited, group);\n    }\n    FOREACH(it, cur.back_edges) {\n        if(visited[*it]) continue;\n        nodes[*it].level = cur.level-1;\n        nodes[*it].color = 1 - cur.color;\n        preprocess(*it, nodes, visited, group);\n    }\n}\n\nbool is_same_level(int a, int b, const vector<Node> &nodes) {\n    vector<int> states(nodes.size(), 0);\n    FOREACH(it, nodes[a].edges) {\n        states[*it] |= 1;\n    }\n    FOREACH(it, nodes[b].edges) {\n        states[*it] |= 2;\n    }\n    FOREACH(it, nodes[a].back_edges) {\n        states[*it] |= 4;\n    }\n    FOREACH(it, nodes[b].back_edges) {\n        states[*it] |= 8;\n    }\n    bool has_c = false, has_d = false;\n    TIMES(i, nodes.size()) {\n        if(i == a || i == b) continue;\n        int state = states[i];\n        if((state & 0x0c) == 0x0c) {\n            has_c = true;\n        }\n        if((state & 0x09) == 0x09 || (state & 0x0a) == 0x0a) {\n            has_d = true;\n        }\n    }\n    return has_c && !has_d;\n}\n\nbool check(int from, int to, const vector<Node> &nodes, Flag &visited) {\n    if(visited[from]) return false;\n    if(from == to) return true;\n    visited[from] = 1;\n    const Node &cur = nodes[from];\n    FOREACH(it, cur.edges) {\n        if(check(*it, to, nodes, visited)) return true;\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Node> nodes(2*N);\n        Dict dict;\n        TIMES(_, N) {\n            string cross;\n            cin >> cross;\n            const int hyphen = cross.find('-');\n            const int a = dict.get(cross.substr(0, hyphen));\n            const int b = dict.get(cross.substr(hyphen+1));\n            nodes[b].edges.push_back(a);\n            nodes[a].back_edges.push_back(b);\n        }\n        N = dict.size();\n        nodes.resize(N);\n        Flag visited(N, 0);\n        TIMES(i, N) {\n            if(!visited[i]) {\n                preprocess(i, nodes, visited, i);\n            }\n        }\n        TIMES(i, N) {\n            TIMES(j, i) {\n                if(nodes[i].group == nodes[j].group) {\n                    if(is_same_level(i, j, nodes)) {\n                        nodes[i].pending.push_back(j);\n                        nodes[j].pending.push_back(i);\n                    }\n                }\n            }\n        }\n        TIMES(i, N) {\n            nodes[i].edges.insert(nodes[i].edges.end(), nodes[i].pending.begin(), nodes[i].pending.end());\n        }\n        cout << N << endl;\n\n        int M;\n        cin >> M;\n        TIMES(_, M) {\n            string cross;\n            cin >> cross;\n            const int hyphen = cross.find('-');\n            const int a = dict.get(cross.substr(0, hyphen));\n            const int b = dict.get(cross.substr(hyphen+1));\n            bool ans = true;\n            if(a >= N || b >= N) {\n                ans = false;\n            } else if(nodes[a].group != nodes[b].group) {\n                ans = false;\n            } else if(nodes[a].color == nodes[b].color) {\n                ans = false;\n            } else {\n                fill(visited.begin(), visited.end(), 0);\n                ans = check(b, a, nodes, visited);\n            }\n            cout << (ans?\"YES\":\"NO\") << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <map>\nconst int INF = 1e9;\nusing namespace std;\n\npair<string, string> get_name(string S){\n  string s, t;\n  for(int i = 0; i < S.length(); ++i){\n    if(S[i] == '-'){\n      t = S.substr(i+1);\n      break;\n    }\n    s += S[i];\n  }\n  return pair<string, string>(s, t);\n}\n\nvoid dfs(vector< vector<int> > &G, vector<int> &C, int v){\n  int n = G.size();\n  for(int i = 0; i < n; ++i){\n    if(G[v][i] >= INF && G[i][v] >= INF) continue;\n    if(C[i] == 0){\n      C[i] = -C[v];\n      dfs(G, C, i);\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(cin >> N, N){\n  map<string, int> m;\n  vector<string> from(N), to(N);\n  for(int i = 0; i < N; ++i){\n    string s;\n    cin >> s;\n    pair<string, string> E = get_name(s);\n    //cout << E.first << \" \" << E.second << endl;\n    m[E.first] = 1;\n    m[E.second] = 1;\n    from[i] = E.first;\n    to[i] = E.second;\n  }\n  int t = 1;\n  for(auto itr = m.begin(); itr != m.end(); ++itr){\n    itr->second = t;\n    ++t;\n  }\n  int n = m.size();\n  cout << n << endl;\n  vector< vector<int> > G(n, vector<int>(n, INF));\n  for(int i = 0; i < N; ++i){\n    int u = m[from[i]] - 1, v = m[to[i]] - 1;\n    G[u][v] = 1;\n  }\n  vector<int> C(n, 0);\n  for(int i = 0; i < n; ++i){\n    if(!C[i]){\n      C[i] = 1;\n      dfs(G, C, i);\n    }\n  }\n\n  vector< vector<int> > G_ = G;\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(G[i][j] < INF || G[j][i] < INF) continue;\n      bool f = false;\n      for(int k = 0; k < n; ++k){\n        if((G[i][k] < INF && G[j][k] < INF) || (G[k][i] < INF && G[k][j] < INF)){\n          f = true;\n          break;\n        }\n      }\n      for(int k = 0; k < n; ++k){\n        if((G[i][k] < INF && G[k][j] < INF) || (G[k][i] < INF && G[j][k] < INF)){\n          f = false;\n          break;\n        }\n      }\n      if(f){\n        G_[i][j] = 1;\n        G_[j][i] = 1;\n      }\n    }\n  }\n\n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        G_[i][j] = min(G_[i][j], G_[i][k] + G_[k][j]);\n      }\n    }\n  }\n\n  //for(auto itr = m.begin(); itr != m.end(); ++itr) cout << itr->first << \" \" << itr->second << endl;\n  //for(int i = 0; i < n; ++i) cout << C[i] << \" \";cout << endl;\n\n  int M;\n  cin >> M;\n  for(int i = 0; i < M; ++i){\n    string S;\n    cin >> S;\n    pair<string, string> Q = get_name(S);\n    int u = m[Q.first] - 1, v = m[Q.second] - 1;\n    if(u < 0 || v < 0){\n      cout << \"NO\" << endl;\n      continue;\n    }\n    if(C[u] != C[v] && G_[u][v] < INF) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<string,int> M;\n\nint str2int(string S){\n    if(M.find(S)==M.end()){\n        int n = M.size();\n        M[S]=n;\n    }\n    return M[S];\n}\n\nint E[200][200];//[a][b]=a to b\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        fill(E[0],E[200],10000);\n        M.clear();\n        for(int i=0;i<N;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    E[i1][i2]=1;\n                    break;\n                }\n            }\n        }\n        int m = M.size();\n        cout<<m<<endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<m;j++){\n                if(E[i][j]==1||E[j][i]==1) continue;\n                //cond1\n                bool b=false;\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[i][k]==1||E[k][i]==1)&&(E[j][k]==1||E[k][j]==1)){\n                        b=true;\n                        break;\n                    }\n                }\n                //cond2,3\n                for(int k=0;k<m;k++){\n                    if(k==i||k==j) continue;\n                    if((E[k][i]==1&&E[j][k]==1)||(E[i][k]==1&&E[k][j]==1)){\n                        b=false;\n                        break;\n                    }\n                }\n                if(b) E[i][j]=E[j][i]=0;\n            }\n        }\n        //WF\n        for(int i=0;i<m;i++) E[i][i]=0;\n        for(int k=0;k<m;k++){\n            for(int i=0;i<m;i++){\n                for(int j=0;j<m;j++){\n                    E[i][j]=min(E[i][j],E[i][k]+E[k][j]);\n                }\n            }\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;i++){\n            string S;\n            cin>>S;\n            for(int c=0;c<S.size();c++){\n                if(S[c]=='-'){\n                    string S1=S.substr(0,c);\n                    string S2=S.substr(c+1,S.size()-c-1);\n                    int i1=str2int(S1);\n                    int i2=str2int(S2);\n                    if(i1>=m||i2>=m||E[i1][i2]%2==0){\n                        cout<<\"NO\"<<endl;\n                    }else{\n                        cout<<\"YES\"<<endl;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        vector<vector<Edge> > edges;\n        vector<vector<int> > rev;\n        for(int i=0; i<n; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                a = edges.size();\n                edges.resize(a + 1);\n                rev.resize(a + 1);\n                index[s1] = a;\n            }else{\n                a = it->second;\n            }\n            it = index.find(s2);\n            if(it == index.end()){\n                b = edges.size();\n                edges.resize(b + 1);\n                rev.resize(b + 1);\n                index[s2] = b;\n            }else{\n                b = it->second;\n            }\n            edges[a].push_back(Edge(b, 1));\n            rev[b].push_back(a);\n        }\n\n        n = edges.size();\n        vector<vector<bool> > check(n, vector<bool>(n, false));\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<edges[i].size(); ++j){\n                int a = edges[i][j].to;\n                for(unsigned k=0; k<edges[a].size(); ++k){\n                    int b = edges[a][k].to;\n                    check[i][b] = check[b][i] = true;\n                }\n            }\n        }\n        for(int i=0; i<n; ++i){\n            for(unsigned j=1; j<edges[i].size(); ++j){\n                int a = edges[i][j-1].to;\n                int b = edges[i][j].to;\n                if(!check[a][b]){\n                    edges[a].push_back(Edge(b, 2));\n                    edges[b].push_back(Edge(a, 2));\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n            for(unsigned j=1; j<rev[i].size(); ++j){\n                int a = rev[i][j-1];\n                int b = rev[i][j];\n                if(!check[a][b]){\n                    edges[a].push_back(Edge(b, 2));\n                    edges[b].push_back(Edge(a, 2));\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges, dist);\n\n        cout << n << endl;\n        int m;\n        cin >> m;\n        for(int i=0; i<m; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            a = it->second;\n            it = index.find(s2);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            b = it->second;\n\n            if(dist[a][b] != -1 && dist[a][b] % 2 == 1)\n                cout << \"YES\" << endl;\n            else\n                cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n \n#define all(a) (a).begin(),(a).end()\n#define pb(a) push_back((a))\n#define mp(a,b) make_pair((a),(b))\n#define fst first\n#define sec second\n \nusing namespace std;\n \nvoid split(string in,string& s1,string& s2){\n  for(int i=0;i<in.size();i++){\n    if(in[i]=='-'){\n      s1=in.substr(0,i);\n      s2=in.substr(i+1,in.size()-i-1);\n      return;\n    }\n  }\n}\n \nbool eq_str(const string& p,const string& q){ p==q; }\n \nmultimap<string,string>m1,m2;\nmap<string,int>color;\n \nvoid dfs(string v,int c){\n  color[v]=c;\n  multimap<string,string>::iterator it=m2.begin();\n  while(it!=m2.end()){\n    if((*it).fst==v && color[(*it).sec]==0)dfs((*it).sec,-c);\n    it++;\n  }\n}\n \nint graph[200][200];\n \nvoid warshall_floyd(int V){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n    graph[i][j]|=graph[i][k]&graph[k][j];\n}\n \nint main(void){\n  int n,m;\n  string in,s1,s2;\n  vector<string>node,node3;\n  map<string,int>node2;\n  vector<pair<string,string> >query;\n  \n  while(cin >> n,n){\n    m1.clear();\n    m2.clear();\n    color.clear();\n    node.clear();\n    node2.clear();\n    node3.clear();\n    query.clear();\n    \n    for(int i=0;i<n;i++){\n      cin >> in;\n      split(in,s1,s2);\n      node.pb(s1);\n      node.pb(s2);\n      node3.pb(s1);\n      node3.pb(s2);\n      m1.insert(mp(s1,s2));\n      //m1.insert(mp(s2,s1));\n      m2.insert(mp(s1,s2));\n      m2.insert(mp(s2,s1));\n    }\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    \n    cout << node.size() << endl;\n    \n    //for(int i=0;i<node.size();i++)cout << node[i] << endl;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> in;\n      split(in,s1,s2);\n      query.pb(mp(s1,s2));\n      node3.pb(s1);\n      node3.pb(s2);\n    }\n    \n    sort(all(node3));\n    node3.erase(unique(all(node3)),node3.end());\n    \n    for(int i=0;i<node3.size();i++){\n      color[node3[i]]=0;\n      node2[node3[i]]=i;\n    }\n    \n    for(int i=0,j=1;i<node3.size();i++)\n      if(color[node3[i]]==0)dfs(node3[i],j++);\n    \n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)graph[i][j]=i==j?1:0;\n    \n    bool g[200][200];\n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)g[i][j]=false;\n    \n    multimap<string,string>::iterator it=m1.begin(),it2=m1.begin();\n    \n    while(it!=m1.end()){\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\tif((*it).fst==(*it2).sec){\n\t  graph[node2[(*it).sec]][node2[(*it2).fst]]=true;\n\t  graph[node2[(*it2).fst]][node2[(*it).sec]]=true;\n\t}\n\tif((*it).sec==(*it2).fst){\n\t  graph[node2[(*it).fst]][node2[(*it2).sec]]=true;\n\t  graph[node2[(*it2).sec]][node2[(*it).fst]]=true;\n\t}\n\tit2++;\n      }\n      it++;\n    }\n    \n    it=m1.begin();\n    while(it!=m1.end()){\n      graph[node2[(*it).fst]][node2[(*it).sec]]=1;\n      \n      it2=m1.begin();\n      while(it2!=m1.end()){\n\tif(it==it2){\n\t  it2++;\n\t  continue;\n\t}\n\t\n\tif((*it).fst==(*it2).fst && !g[node2[(*it).sec]][node2[(*it2).sec]]){\n\t  graph[node2[(*it).sec]][node2[(*it2).sec]]=1;\n\t  graph[node2[(*it2).sec]][node2[(*it).sec]]=1;\n\t}\n\t\n\tif((*it).sec==(*it2).sec && !g[node2[(*it).fst]][node2[(*it2).fst]]){\n\t  graph[node2[(*it).fst]][node2[(*it2).fst]]=1;\n\t  graph[node2[(*it2).fst]][node2[(*it).fst]]=1;\n\t}\n\tit2++;\n      }\n      //graph[node2[(*it).sec]][node2[(*it).fst]]=1;\n      it++;\n    }\n    \n    warshall_floyd(node3.size());\n    \n    for(int i=0;i<query.size();i++){\n      if(color[query[i].fst]+color[query[i].sec]==0 &&\n\t graph[node2[query[i].fst]][node2[query[i].sec]]==1)\n\tcout << \"YES\" << endl;\n      else cout << \"NO \" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint N, M;\nint G[205][205];\nmap<string, int> mp;\nvector<int> g[205];\nint V;\nbool used[205];\nint color[205];\n\nbool dfs(int v, int t)\n{\n\tused[v] = true;\n\tif(v == t) return true;\n\t\n\tbool ret = false;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(used[g[v][i]]) continue;\n\t\tret |= dfs(g[v][i], t);\n\t}\n\treturn ret;\n}\n\nvoid color_dfs(int v, int c)\n{\n\tcolor[v] = c;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(color[g[v][i]]) continue;\n\t\tcolor_dfs(g[v][i], -c);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(int i = 1; i <= 200; i++){\n\t\t\tfor(int j = 1; j <= 200; j++){\n\t\t\t\tG[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint id = 1;\n\t\tstring s, t;\n\t\tmp.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0) mp[s] = id++;\n\t\t\tif(mp.count(t) == 0) mp[t] = id++;\n\t\t\tG[mp[s]][mp[t]] = 1;\n\t\t}\n\t\tV = id-1;\n\t\tcout << V << endl;\n\t\t\n\t\tfor(int i = 1; i <= V; i++) g[i].clear();\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]){\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t\tg[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++) color[i] = 0;\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tif(!color[i]) color_dfs(i, 1);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\tif(G[i][j]) continue;\n\t\t\t\t\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int k = 1; k <= V; k++){\n\t\t\t\t\tif(G[i][k] == 1 && G[j][k] == 1){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(G[k][i] == 1 && G[k][j] == 1){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag) continue;\n\t\t\t\t\n\t\t\t\tflag = true;\n\t\t\t\tfor(int k = 1; k <= V; k++){\n\t\t\t\t\tif(G[i][k] == 1 && G[k][j] == 1){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(G[k][i] == 1 && G[j][k] == 1){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag) G[i][j] = 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tg[i].clear();\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]) g[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0 || mp.count(t) == 0){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint S = mp[s], T = mp[t];\n\t\t\t\n\t\t\tif(color[S] == color[T]){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i <= V; i++) used[i] = false;\n\t\t\tif(dfs(S, T)) cout << \"YES\" << endl;\n\t\t\telse cout << \"NO\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define f first\n#define s second\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n  bool used[201];\n  map<string,int>m;\n  char qq;\n  vector<int>mg[201],yg[201];\n  int o,a[201];\n  int c=1;\n  scanf(\"%c\",&qq);\n  for(int i=0;i<n;i++){\n    string s1,s2;\n    int ccc=0;\n    while(1){\n      char cc;\n      scanf(\"%c\",&cc);\n      if(cc=='\\n')break;\n      if(cc=='-'){ccc++;continue;}\n      if(!ccc)s1+=cc;\n      else s2+=cc;\n    }//cout<<s1<<endl<<s2<<endl;\n    if(!m[s1])m[s1]=c++;\n    if(!m[s2])m[s2]=c++;\n    yg[m[s1]].push_back(m[s2]);\n    mg[m[s1]].push_back(m[s2]);\n    mg[m[s2]].push_back(m[s1]);\n  }\n  r(i,201)used[i]=0;\n  queue<pair<int,int> >q;\n  q.push(mk(1,0));\n  while(!q.empty()){\n      pair<int,int>p=q.front();q.pop();\n      a[p.f]=p.s%2;\n      r(i,mg[p.f].size())\n    if(!used[mg[p.f][i]]){\n      q.push(mk(mg[p.f][i],p.s+1));\n      used[mg[p.f][i]]=1;\n    }\n  }\n    cout<<c-1<<endl;\n    cin>>o;\n    char kl;\n    scanf(\"%c\",&kl);\n    while(o--){//cout<<1;\n      string s1,s2;\n      int ccc=0,u=0;\n      while(1){\n        char cc;\n        scanf(\"%c\",&cc);\n        if(cc=='\\n')break;\n        if(cc=='-'){ccc++;continue;}\n        if(!ccc)s1+=cc;\n        else s2+=cc;\n      }\n      if(a[m[s1]]==a[m[s2]])cout<<\"No\"<<endl;\n      else if(!m[s1])cout<<\"No\"<<endl;\n      else if(!m[s2])cout<<\"No\"<<endl;\n      else{//cout<<1;\n    r(i,201)used[i]=0;\n    queue<int>p;\n    p.push(m[s1]);\n    used[m[s1]]=1;\n    while(!p.empty()){\n      int t=p.front();p.pop();\n      r(i,yg[t].size())\n        if(!used[yg[t][i]]){\n          if(yg[t][i]==m[s2]){cout<<\"Yes\"<<endl;u++;goto KKK;}\n          p.push(yg[t][i]);\n          used[yg[t][i]]=1;\n        }\n    }//cout<<1;\n    KKK:;\n    if(!u){r(i,201)used[i]=0;\n      queue<pair<int,int> > w;\n      w.push(mk(m[s2],0));\n    used[m[s2]]=1;\n    while(!w.empty()){\n      pair<int,int> ttt=w.front();w.pop();\n      int t=ttt.first;\n      if(ttt.second>1){cout<<\"No\"<<endl;goto LLL;}\n      r(i,yg[t].size())\n        if(!used[yg[t][i]]){\n          if(yg[t][i]==m[s1]){cout<<\"No\"<<endl;goto LLL;}\n          w.push(mk(yg[t][i],ttt.second+1));\n          used[yg[t][i]]=1;\n        }\n    }\n    cout<<\"Yes\"<<endl;}\n    if(0)LLL:;\n      }\n    }\n  }\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint N,m,n,st[210][210],same[210][210];\n\nint main(){\n\twhile(cin>>N && N){\n\t\trep(i,210)rep(j,210)st[i][j]=i==j?0:INF;\n\t\tmap<string,int> M;\n\t\tn=0;\n\t\trep(i,N){\n\t\t\tstring s,t,u;\n\t\t\tcin>>s;\n\t\t\tint mode=0;\n\t\t\trep(j,s.sz){\n\t\t\t\tif(s[j]=='-')mode=1;\n\t\t\t\telse mode?u+=s[j]:t+=s[j];\n\t\t\t}\n\t\t\tif(M.find(t)==M.end())M[t]=n++;\n\t\t\tif(M.find(u)==M.end())M[u]=n++;\n\t\t\tst[M[t]][M[u]]=1;\n\t\t}\n\t\trep(i,n)rep(j,n){\n\t\t\tint ok=0;\n\t\t\trep(k,n){\n\t\t\t\tif(st[i][k]==1&&st[j][k]==1\n\t\t\t\t|| st[k][i]==1&&st[k][j]==1)ok=1;\n\t\t\t\tif(st[i][k]==1&&st[k][j]==1\n\t\t\t\t|| st[j][k]==1&&st[k][i]==1){\n\t\t\t\t\tok=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)st[i][j]=0;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tst[i][j]=min(st[i][j],st[i][k]+st[k][j]);\n\t\t}\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tstring s,t,u;\n\t\t\tcin>>s;\n\t\t\tint mode=0;\n\t\t\trep(j,s.sz){\n\t\t\t\tif(s[j]=='-')mode=1;\n\t\t\t\telse mode?u+=s[j]:t+=s[j];\n\t\t\t}\n\t\t\tint T=M[t],U=M[u];\n\t\t\tcout<<(st[T][U]<INF && st[T][U]%2 ? \"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \n#define rep(i,n) for(ll i = 0; i < ll(n); ++i) \n#define FOR(i,a,b) for(ll i = (a); i < ll(b); ++i) \n#define ROF(i,a,b) for(ll i = (a)-1; i >= ll(b); --i) \n#define all(a) (a).begin(),(a).end() \n#define fst first \n#define snd second \ntypedef long long ll; \ntypedef vector<ll> vi;\ntypedef vector<vi> vii;\nconst ll inf = 1ll<<10;\n\nbool dfs(const vii &g, ll i, vi &color){\n  ll sz = g.size();\n  stack<ll> st;\n  color[i] = 1;\n  st.push(i);\n\n  while(!st.empty()){\n    int now = st.top();\n    st.pop();\n\n    rep(next,sz){\n      if(now == next) continue;\n      if(g[now][next] + g[next][now] == 0){ // now<->next\n\tif(color[next] and color[next] != color[now]){\n\t  //cout << now << endl << next << endl;\n\t  return false; \n\t}else if(color[next] and color[next] == color[now]) continue;\n\telse{\n\t  color[next] = color[now];\n\t  st.push(next);\n\t}\n      }else if(g[now][next] * g[next][now] == 0){ // now->next or next->now\n\tif(color[next] and color[next] == color[now]){\n\t  //cout << now << endl << next << endl;\n\t  return false;\n\t}else if(color[next] and color[next] != color[now]) continue;\n\telse{\n\t  color[next] = -color[now];\n\t  st.push(next);\n\t}\n      }\n    }\n  }\n  return true;\n}\n\nbool paintable(const vii &g, vi &color){\n  ll sz = g.size();\n  rep(i,sz) if(color[i] == 0 and dfs(g,i,color) == false) return false;\n  return true;\n}\n\nmain(){\n  ll m,n; \n  while(cin >> m, m){ \n    vector<string> input(m); \n    vector<vector<string>> cross(m,vector<string>(2)); \n    set<string> street; \n    rep(i,m){ \n      cin >> input[i]; \n      FOR(k,1,input[i].size()){ // A-BをAとBに分ける \n\tif(input[i][k] == '-'){ \n\t  cross[i][0] = input[i].substr(0,k); \n\t  cross[i][1] = input[i].substr(k+1,input[i].size()-k-1); \n\t  street.insert(cross[i][0]); \n\t  street.insert(cross[i][1]); \n\t  //cerr << cross[i][0] << endl << cross[i][1] << endl; \n\t  break; \n\t} \n      } \n    } \n    map<string,ll> ntoi; // 通りの名前からindex\n    vector<string> iton; // indexから通りの名前\n    ll tmpi = 0;\n    for(auto name : street){ \n      ntoi[name] = tmpi;\n      iton.push_back(name);\n      tmpi++;\n    }\n    ll sz = street.size(); cout << sz << endl;\n    vii g(sz,vi(sz,1)); \n    rep(i,m) g[ ntoi[cross[i][0]] ][ ntoi[cross[i][1]] ] = 0; // A->B\n    \n    vector<pair<ll,ll>> eqp; // 同水準のpair\n    rep(i,sz) rep(j,sz){ // iとjが同水準か\n      bool ieqj = false;\n      rep(k,sz){\n\tif((g[i][k] + g[k][j]) * (g[j][k] + g[k][i]) == 0){ // i->k->jかj->k->iがある\n\t  ieqj = false;\n\t  break;\n\t}else if((g[i][k] + g[j][k]) * (g[k][i] + g[k][j]) == 0){ // i->k,j->kかk->i,k->jがある\n\t  ieqj = true;\n\t}\n      }\n      if(ieqj) eqp.push_back(make_pair(i,j));\n    }\n    rep(i,eqp.size()) g[eqp[i].fst][eqp[i].snd] = g[eqp[i].snd][eqp[i].fst] = 0; // A<->B\n    //rep(i,sz){ rep(j,sz) cout << g[i][j] << \" \"; cout << endl; }\n\n    vii d = g; // path i->j がある <=> d[i][j] == 0\n    rep(k,sz) rep(i,sz) rep(j,sz) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n    vi color(sz);\n    bool p = paintable(g,color);\n    //cout << \"p : \" << p << endl;\n    //rep(i,sz) cout << iton[i] << \" : \" << color[i] << endl;\n\n    cin >> n;\n    rep(k,n){\n      string q; cin >> q;\n      if(p == false){\n\tcout << \"NO\\n\";\n\tcontinue;\n      }\n      string ql, qr;\n      FOR(i,1,q.size()){ // A-BをAとBに分ける \n\tif(q[i] == '-'){ \n\t  ql = q.substr(0,i); \n\t  qr = q.substr(i+1,q.size()-i-1);\n\t  break; \n\t} \n      }\n      if(d[ntoi[ql]][ntoi[qr]] != 0){\n\tcout << \"NO\\n\";\n\tcontinue;\n      }\n      //cout << color[ntoi[ql]] << endl << color[ntoi[qr]] << endl;\n      if(color[ntoi[ql]] != color[ntoi[qr]]) cout << \"YES\\n\";\n      else cout << \"NO\\n\";\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint N, M;\nint G[205][205];\nmap<string, int> mp;\nvector<int> g[205];\nint V;\nbool used[205];\nint color[205];\n\nbool dfs(int v, int t)\n{\n\tused[v] = true;\n\tif(v == t) return true;\n\t\n\tbool ret = false;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(used[g[v][i]]) continue;\n\t\tret |= dfs(g[v][i], t);\n\t}\n\treturn ret;\n}\n\nvoid color_dfs(int v, int c)\n{\n\tcolor[v] = c;\n\tfor(int i = 0; i < g[v].size(); i++){\n\t\tif(color[g[v][i]]) continue;\n\t\tcolor_dfs(g[v][i], -c);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(int i = 1; i <= 200; i++){\n\t\t\tfor(int j = 1; j <= 200; j++){\n\t\t\t\tG[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint id = 1;\n\t\tstring s, t;\n\t\tmp.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0) mp[s] = id++;\n\t\t\tif(mp.count(t) == 0) mp[t] = id++;\n\t\t\tG[mp[s]][mp[t]] = 1;\n\t\t}\n\t\tV = id-1;\n\t\tcout << V << endl;\n\t\t\n\t\tfor(int i = 1; i <= V; i++) g[i].clear();\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]){\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t\t//g[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++) color[i] = 0;\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tif(!color[i]) color_dfs(i, 1);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tint prev = 0, front = 0;\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j] == 1){\n\t\t\t\t\tif(prev == 0) front = j;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[prev][j] == 0) G[prev][j] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tprev = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev != front) if(G[prev][front] == 0) G[prev][front] = 2;\n\t\t}\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tint prev = 0, front = 0;\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[j][i] == 1){\n\t\t\t\t\tif(prev == 0) front = j;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[prev][j] == 0) G[prev][j] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tprev = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev != front) if(G[prev][front] == 0) G[prev][front] = 2;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= V; i++){\n\t\t\tg[i].clear();\n\t\t\tfor(int j = 1; j <= V; j++){\n\t\t\t\tif(G[i][j]) g[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(s[j] == '-'){\n\t\t\t\t\tt = s.substr(j+1);\n\t\t\t\t\ts = s.substr(0, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp.count(s) == 0 || mp.count(t) == 0){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint S = mp[s], T = mp[t];\n\t\t\t\n\t\t\tif(color[S] == color[T]){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i <= V; i++) used[i] = false;\n\t\t\tif(dfs(S, T)) cout << \"YES\" << endl;\n\t\t\telse cout << \"NO\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\ntypedef long long ll;\n\nvoid parse(char *s1,char *s2){\n\tchar s[64]; gets(s);\n\tint i;\n\tfor(i=0;s[i]!='-';i++);\n\ts[i]='\\0';\n\tstrcpy(s1,s);\n\tstrcpy(s2,s+i+1);\n}\n\nll hash(const char *s){\n\tconst ll P=1000000007;\n\tll h=0;\n\tfor(int i=0;s[i];i++) h=h*P+s[i];\n\treturn h;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d \",&n),n;){\n\t\tll h1[1000],h2[1000],H[2000];\n\t\trep(i,n){\n\t\t\tchar s1[17],s2[17];\n\t\t\tparse(s1,s2);\n\t\t\tH[2*i+0]=h1[i]=hash(s1);\n\t\t\tH[2*i+1]=h2[i]=hash(s2);\n\t\t}\n\t\tsort(H,H+2*n);\n\t\tint m=unique(H,H+2*n)-H;\n\n\t\tint u1[1000],u2[1000];\n\t\tstatic bool E[1000][1000];\n\t\trep(i,n) rep(j,n) E[i][j]=false;\n\t\trep(i,n){\n\t\t\tu1[i]=lower_bound(H,H+m,h1[i])-H;\n\t\t\tu2[i]=lower_bound(H,H+m,h2[i])-H;\n\t\t\tE[u1[i]][u2[i]]=true;\n\t\t}\n\n\t\tint d[200][200]; // 距離行列\n\t\trep(u,m) rep(v,m) {\n\t\t\tbool ok=false;\n\t\t\trep(w,m){\n\t\t\t\tif(E[u][w] && E[v][w]) ok=true;\n\t\t\t\tif(E[w][u] && E[w][v]) ok=true;\n\t\t\t\tif(E[u][w] && E[w][v]){ ok=false; break; }\n\t\t\t\tif(E[v][w] && E[w][u]){ ok=false; break; }\n\t\t\t}\n\t\t\td[u][v]=(ok?0:INF);\n\t\t}\n\t\trep(i,n) d[u1[i]][u2[i]]=1;\n\n\t\trep(w,m) rep(u,m) rep(v,m) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tint q; scanf(\"%d \",&q);\n\t\tprintf(\"%d\\n\",m);\n\t\twhile(q--){\n\t\t\tchar s1[17],s2[17];\n\t\t\tparse(s1,s2);\n\t\t\tll h1=hash(s1),h2=hash(s2);\n\t\t\tif(binary_search(H,H+m,h1) && binary_search(H,H+m,h2)){\n\t\t\t\tint u=lower_bound(H,H+m,h1)-H;\n\t\t\t\tint v=lower_bound(H,H+m,h2)-H;\n\t\t\t\tputs(d[u][v]<INF&&d[u][v]%2==1?\"YES\":\"NO\");\n\t\t\t}\n\t\t\telse puts(\"NO\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing ps = pair<string,string>;\n\nps split(string s){\n    int n = s.size();\n    int idx = 0;\n    while(idx<n && s[idx]!='-') ++idx;\n\n    return {s.substr(0,idx), s.substr(idx+1)};\n}\n\nconst int N = 202;\nconst int INF = 101010;\n\n// 入力から分かる強さ関係\nvector<int> G[N];\nbool arr[N][N];\n\nint d[N][N];\n\n// 水準関係\nint C[N][N];\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        rep(i,N) G[i].clear();\n        rep(i,N)rep(j,N) arr[i][j] = false;\n\n        rep(i,N)rep(j,N) d[i][j]=INF;\n        rep(i,N) d[i][i]=0;\n\n        rep(i,N)rep(j,N) C[i][j]=INF;\n        rep(i,N) C[i][i]=0;\n\n        map<string,int> c2id;\n        int V = 0;\n        vector<string> names;\n        rep(i,n){\n            string s;\n            cin >>s;\n            ps cross = split(s);\n\n            if(!c2id.count(cross.fi)){\n                c2id[cross.fi] = V;\n                ++V;\n                names.pb(cross.fi);\n            }\n            if(!c2id.count(cross.se)){\n                c2id[cross.se] = V;\n                ++V;\n                names.pb(cross.se);\n            }\n            int u = c2id[cross.fi], v = c2id[cross.se];\n            G[u].pb(v);\n            C[u][v] = 1;\n            d[u][v] = d[v][u] = 1;\n            arr[u][v] = true;\n        }\n\n        rep(k,V)rep(i,V)rep(j,V) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        auto same_degree = [&](int a, int b){\n            bool same = false;\n            rep(i,V){\n                if( (arr[a][i]||arr[i][a]) && (arr[b][i]||arr[i][b]) ) same = true;\n            }\n            if(!same) return false;\n\n            rep(i,V){\n                if(arr[i][a]&&arr[b][i]) return false;\n                if(arr[a][i]&&arr[i][b]) return false;\n            }\n            return true;\n        };\n\n        rep(i,V)rep(j,i){\n            if(same_degree(i,j)){\n                // cout << \"DEG :: \" << names[i] << \" \" << names[j] << endl;\n                C[i][j] = C[j][i] = 1;\n            }\n        }\n        rep(k,V)rep(i,V)rep(j,V) C[i][j] = min(C[i][j], C[i][k]+C[k][j]);\n\n        cout << V << endl;\n\n        int Q;\n        cin >>Q;\n        while(Q--){\n            string q;\n            cin >>q;\n\n            ps qc = split(q);\n\n            bool ok = false;\n            if(c2id.count(qc.fi) && c2id.count(qc.se)){\n                int u = c2id[qc.fi], v = c2id[qc.se];\n                // dbg(C[u][v]);\n\n                if(d[u][v]%2==1 && C[u][v]<INF) ok = true;\n            }\n            cout << (ok?\"YES\":\"NO\") << endl;\n        }\n        // dbg(c2id.size());\n        // dbg(names);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\nint n,m,size;\nstring str,a,b;\nmap<string,int> mp;\nint G[201][201];\nint g[201][201];\nint T[201][201];\nint t[201][201];\n\nvoid init(){\n  mp.clear();\n  size=0;\n  for(int i=1;i<=200;i++){\n    for(int j=1;j<=200;j++){\n      G[i][j]=(i==j?0:INF);\n      T[i][j]=(i==j?0:INF);\n      g[i][j]=0;\n      t[i][j]=0;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n\n    for(int i=0;i<n;i++){\n      cin>>str;\n      for(int j=0;j<(int)str.size();j++){\n        if(str[j]=='-'){\n          a=str.substr(0,j);\n          b=str.substr(j+1);\n          break;\n        }\n      }\n      if(mp[a]==0)mp[a]=++size;\n      if(mp[b]==0)mp[b]=++size;\n      G[mp[a]][mp[b]]=1;\n      T[mp[a]][mp[b]]=1;\n      g[mp[a]][mp[b]]=1;\n    }\n    \n    for(int i=1;i<=size;i++){\n      for(int j=1;j<=size;j++){\n        if(i==j)continue;\n        \n        bool flg=false;\n        for(int k=1;k<=size;k++){\n          if((g[i][k]||g[k][i])&&(g[j][k]||g[k][j])){\n            flg=true;\n          }\n        }\n\n              \n        for(int k=1;k<=size;k++){\n          if(g[k][i]&&g[j][k])flg=false;\n          if(g[i][k]&&g[k][j])flg=false;\n        }\n        if(flg){\n          T[i][j]=1;\n          T[j][i]=1;\n        }\n      }\n    }\n    \n    for(int k=1;k<=size;k++){\n      for(int i=1;i<=size;i++){\n        for(int j=1;j<=size;j++){\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n          T[i][j]=min(T[i][j],T[i][k]+T[k][j]);\n        }\n      }\n    }\n\n    cout<<size<<endl;\n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>str;\n      for(int j=0;j<(int)str.size();j++){\n        if(str[j]=='-'){\n          a=str.substr(0,j);\n          b=str.substr(j+1);\n          break;\n        }\n      }\n      int A=mp[a],B=mp[b];\n      \n      if(G[A][B]%2==0&&G[A][B]!=INF){\n        cout<<\"NO\"<<endl;\n      }else if(T[A][B]==INF){\n        cout<<\"NO\"<<endl;\n      }else if(t[A][B]){\n        cout<<\"NO\"<<endl;\n      }else{\n        cout<<\"YES\"<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool same(int x, int y) { return find(x) == find(y); }\n};\n\nint n;\nmap<string,int> r;\nstring crs[1000];\nbool es[222][222];\nbool ess[222][222];\nbool esss[222][222];\nint dir[222];\n\nvoid dfs(int v,int nd){\n  dir[v]=nd;\n  repl(i,1,n){\n    if(!esss[v][i])continue;\n    if(dir[i]==-1)dfs(i,1-nd);\n  }\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int N;\n    cin>>N;\n    if(N==0)break;\n    r.clear();\n    memset(es,0,sizeof(es));\n    memset(esss,0,sizeof(esss));\n    n=1;\n    rep(i,N){\n      cin>>crs[i];\n      rep(j,crs[i].length()){\n        if(crs[i][j]=='-'){\n          string ls=crs[i].substr(0,j);\n          string rs=crs[i].substr(j+1,crs[i].length()-j);\n          if(!r[ls])r[ls]=n++;\n          if(!r[rs])r[rs]=n++;\n          es[r[ls]][r[rs]]=true;\n          esss[r[ls]][r[rs]]=esss[r[rs]][r[ls]]=true;\n          break;\n        }\n      }\n    }\n    /*\n    each(it,r){\n      printf(\"%s %d\\n\", it.first.c_str(),it.second);\n    }*/\n    cout<<n-1<<endl;\n    UnionFind uf(n);\n    repl(i,1,n)repl(j,i+1,n){\n      bool ok=false;\n      repl(k,1,n){\n        if((es[k][i]&&es[k][j])||(es[i][k]&&es[j][k]))ok=true;\n      }\n      repl(k,1,n){\n        if((es[i][k]&&es[k][j])||(es[j][k]&&es[k][i]))ok=false;\n      }\n      if(ok)uf.unite(i,j);\n    }\n    repl(i,1,n)repl(j,1,n){\n      ess[i][j]=i==j?true:false;\n    }\n    repl(i,1,n)repl(j,1,n){\n      if(es[i][j])ess[uf.find(i)][uf.find(j)]=true;;\n    }\n    /*\n    repl(i,1,n)repl(j,1,n){\n      printf(\"%d%c\", ess[i][j],j==n-1?'\\n':' ');\n    }*/\n    repl(k,1,n)repl(i,1,n)repl(j,1,n)ess[i][j]|=ess[i][k]&ess[k][j];\n    /*\n    repl(i,1,n)repl(j,1,n){\n      printf(\"%d%c\", ess[i][j],j==n-1?'\\n':' ');\n    }*/\n    int q;\n    cin>>q;\n    while(q--){\n      string qs;\n      cin>>qs;\n      rep(i,qs.length()){\n        if(qs[i]=='-'){\n          string ls=qs.substr(0,i);\n          string rs=qs.substr(i+1,qs.length()-i);\n          memset(dir,-1,sizeof(dir));\n          dfs(r[ls],0);\n          if(ess[uf.find(r[ls])][uf.find(r[rs])]&&dir[r[rs]]!=-1&&dir[r[ls]]!=dir[r[rs]])cout<<\"YES\"<<endl;\n          else cout<<\"NO\"<<endl;\n          break;\n        }\n      }\n    }\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\n\nvector<string> split(const string &s, char delim) {\n    vector<int> pos;\n    pos.push_back(-1);\n    rep(i, s.size()) if(s[i] == delim) pos.push_back(i);\n    pos.push_back(s.size());\n    vector<string> res;\n    rep(i, pos.size() - 1) res.push_back(s.substr(pos[i] + 1, pos[i + 1] - pos[i] - 1));\n    return res;\n}\n\ntuple<string, string> input() {\n    string s; cin >> s;\n    auto a = split(s, '-');\n    assert(a.size() == 2);\n    return make_tuple(a[0], a[1]);\n}\n\nclass Solver {\n  public:\n    void dfs(int now, int color, vector<int> &coloring, const vector<vector<int>> &G) {\n        coloring[now] = color;\n        rep(nxt, G.size()) {\n            if((G[nxt][now] or G[now][nxt]) and coloring[nxt] < 0) {\n                dfs(nxt, (color + 1) % 2, coloring, G);\n            }\n        }\n    }\n    bool solve() {\n        int N;\n        map<string, int> road_map;    \n        int road_cnt = 0;\n        cin >> N;\n        if(N == 0) return false;\n        vector<pii> E(N);\n        rep(i, N) {\n            string a, b;            \n            tie(a, b) = input();\n            if(not road_map.count(a)) road_map[a] = road_cnt++;\n            if(not road_map.count(b)) road_map[b] = road_cnt++;\n            int ai = road_map[a], bi = road_map[b];\n            E[i] = pii(ai, bi);\n        }\n        vector<vector<int>> G(road_cnt, vector<int>(road_cnt));\n        rep(i, N) G[E[i].first][E[i].second] = 1;\n        vector<int> color(road_cnt, -1);\n        rep(i, road_cnt) if(color[i] < 0) dfs(i, 0, color, G);\n        rep(a, road_cnt) {\n            rep(b, road_cnt) {\n                if(a == b) continue;\n                int flg[3];\n                flg[0] = 0;\n                flg[1] = flg[2] = 1;\n                rep(c, road_cnt) if(c != a and c != b) {\n                    // A???B????????¨?????????????????\\?????????????????????????????????C????????????\n                    flg[0] |= (G[a][c] and G[b][c]) or \n                              (G[a][c] and G[c][b]) or\n                              (G[c][a] and G[b][c]) or\n                              (G[c][a] and G[c][b]);\n                    // D-A??¨B-D?????\\?????????????????????????????????D????????????\n                    flg[1] &= not (G[c][a] and G[b][c]);\n                    // A-E??¨E-B?????\\?????????????????????????????????E????????????\n                    flg[2] &= not (G[a][c] and G[c][b]);\n                }\n                if(flg[0] and flg[1] and flg[2]) {\n                    G[a][b] = 1;\n                    G[b][a] = 1;\n                }\n            }\n        }\n        rep(k, road_cnt) {\n            rep(i, road_cnt) {\n                rep(j, road_cnt) {\n                    if(G[i][k] and G[k][j]) G[i][j] = 1;\n                }\n            }\n        }\n        cout << road_cnt << endl;\n        int M; cin >> M;\n        rep(m, M) {\n            string a, b;\n            tie(a, b) = input();\n            if(not road_map.count(a) or not road_map.count(b)) {\n                cout << \"NO\" << endl;\n                continue;\n            }\n            int ai = road_map[a], bi = road_map[b];\n            bool ok = G[ai][bi];\n            ok &= color[ai] != color[bi];\n            cout << (ok ? \"YES\" : \"NO\") << endl;\n        }\n        return true;\n    }\n};\n\nint main() {\n    while(true) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nbool g[2000][2000];\nbool tate[2000];\nbool same[2000][2000];\nbool visited[2000];\nbool func(int a, int b, int n) {\n  if (a==b) return 1;\n  visited[a] = 1;\n  REP(i,n) {\n    if (g[a][i] && !visited[i] && func(i, b, n)) return 1;\n  }\n  return 0;\n}\n\nint main() {\n  int n,m;\n  while(cin >> n, n) {\n    memset(g, 0, sizeof(g));\n    map<string, int> id;\n    int num = 0;\n    UnionFind uf(2000*2);\n    REP(i, n) {\n      string s;\n      cin >> s;\n      int p = s.find('-');\n      string a = s.substr(0, p);\n      string b = s.substr(p+1);\n      if (id.count(a) == 0) id[a] = num++;\n      if (id.count(b) == 0) id[b] = num++;\n      g[id[a]][id[b]] = 1;\n      uf.unionSet(id[a]*2, id[b]*2+1);\n      uf.unionSet(id[a]*2+1, id[b]*2);\n    }\n    memset(same, 0, sizeof(same));\n    REP(i, num) {\n      REP(j, num) {\n        if (i == j) continue;\n        bool f1=0,f2=1;\n        REP(k, num) {\n          if (k==i||k==j) continue;\n          if (g[i][k]&&g[j][k] || g[k][i]&&g[k][j]) f1 = 1;\n          if (g[i][k]&&g[k][j] || g[k][i]&&g[j][k]) f2 = 0;\n        }\n        if (f1&&f2) {\n          same[i][j] = 1;\n          same[j][i] = 1;\n        }\n      }\n    }\n    REP(i, num) REP(j, num)\n      g[i][j] |= same[i][j];\n    // REP(i, num) {\n    //   REP(j, num) {\n    //     cout << g[i][j];\n    //   }\n    //   cout << endl;\n    // }\n\n    cout << num << endl;\n    cin >> m;\n    REP(i,m) {\n      string s;\n      cin >> s;\n      int p = s.find('-');\n      string a = s.substr(0, p);\n      string b = s.substr(p+1);\n      if (uf.findSet(id[a]*2, id[b]*2) || uf.findSet(id[a]*2+1, id[b]*2+1)) {\n        cout << \"NO\" << endl;\n        continue;\n      }\n      memset(visited,0,sizeof(visited));\n      if (func(id[a], id[b], num)) {\n        cout << \"YES\" << endl;\n      } else {\n        cout << \"NO\" << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint matrix[200][200] = { { 0 } };\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){ break; }\n\t\tfor(int i = 0; i < 200; ++i){\n\t\t\tfor(int j = 0; j < 200; ++j){ matrix[i][j] = 1000; }\n\t\t}\n\t\tmap<string, int> names;\n\t\twhile(N--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tif(names.find(a) == names.end()){\n\t\t\t\tnames.insert(make_pair(a, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tif(names.find(b) == names.end()){\n\t\t\t\tnames.insert(make_pair(b, static_cast<int>(names.size())));\n\t\t\t}\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tmatrix[ai][bi] = 1;\n\t\t}\n\t\tbool modified = false;\n\t\tdo {\n\t\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\t\tif(matrix[i][j] > matrix[i][k] + matrix[k][j]){\n\t\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmodified = false;\n\t\t\tfor(int i = 0; i < names.size(); ++i){\n\t\t\t\tfor(int j = 0; j < names.size(); ++j){\n\t\t\t\t\tif(matrix[i][j] <= 2 || matrix[j][i] <= 2){ continue; }\n\t\t\t\t\tfor(int k = 0; k < names.size(); ++k){\n\t\t\t\t\t\tif(matrix[i][k] == 1 && matrix[j][k] == 1){\n\t\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matrix[k][i] == 1 && matrix[k][j] == 1){\n\t\t\t\t\t\t\tmatrix[i][j] = matrix[j][i] = 0;\n\t\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while(modified);\n\t\tint M;\n\t\tcin >> M;\n\t\twhile(M--){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tint delimiter = line.find_first_of('-');\n\t\t\tstring a = line.substr(0, delimiter), b = line.substr(delimiter + 1);\n\t\t\tif(names.find(a) == names.end() || names.find(b) == names.end()){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ai = names[a], bi = names[b];\n\t\t\tif(matrix[ai][bi] < 1000){\n\t\t\t\tcout << (matrix[ai][bi] % 2 == 1 ? \"YES\" : \"NO\") << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<map>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define stop char nyaa;cin>>nyaa;\n#define per(i,n) for(int i=n-1;i>=0;i--)\ntypedef long double ld;\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint n, m;\nvoid solve() {\n\tmap<string, int> mp;\n\tmap<string, bool> used;\n\tint tmp = 0;\n\tvector<P> v(n);\n\trep(i, n) {\n\t\tstring s; cin >> s;\n\t\trep(j, s.length()) {\n\t\t\tif (s[j] == '-') {\n\t\t\t\tstring le = s.substr(0, j);\n\t\t\t\tstring ri = s.substr(j + 1, (int)s.length() - (j+1));\n\t\t\t\tint lid, rid;\n\t\t\t\tif (!used[le]) {\n\t\t\t\t\tused[le] = true;\n\t\t\t\t\tmp[le] = tmp; tmp++;\n\t\t\t\t}\n\t\t\t\tlid = mp[le];\n\t\t\t\tif (!used[ri]) {\n\t\t\t\t\tused[ri] = true;\n\t\t\t\t\tmp[ri] = tmp; tmp++;\n\t\t\t\t}\n\t\t\t\trid = mp[ri];\n\t\t\t\tv[i] = { lid,rid };\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> vl(tmp), vr(tmp);\n\trep(i, n) {\n\t\tvl[v[i].first].push_back(i);\n\t\tvr[v[i].second].push_back(i);\n\t}\n\tvector<vector<bool>> b(tmp);\n\trep(i, tmp)b[i].resize(tmp, false);\n\trep(i, tmp) {\n\t\trep(j, vl[i].size()) {\n\t\t\tRep(k,j+1, vl[i].size()) {\n\t\t\t\tint lid = v[vl[i][j]].second;\n\t\t\t\tint rid = v[vl[i][k]].second;\n\t\t\t\tb[lid][rid] = b[rid][lid] = true;\n\t\t\t}\n\t\t}\n\t\trep(j, vr[i].size()) {\n\t\t\tRep(k, j + 1, vr[i].size()) {\n\t\t\t\tint lid = v[vr[i][j]].first;\n\t\t\t\tint rid = v[vr[i][k]].first;\n\t\t\t\tb[lid][rid] = b[rid][lid] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, tmp) {\n\t\trep(j, vl[i].size()) {\n\t\t\trep(k, vr[i].size()) {\n\t\t\t\tint lid = v[vl[i][j]].second;\n\t\t\t\tint rid = v[vr[i][k]].first;\n\t\t\t\tb[lid][rid] = b[rid][lid] = false;\n\t\t\t}\n\t\t}\n\t}\n\tuf u(tmp); vector<vector<int>> bG(tmp);\n\trep(i, n) {\n\t\tu.unite(v[i].first, v[i].second);\n\t\tbG[v[i].first].push_back(v[i].second);\n\t\tbG[v[i].second].push_back(v[i].first);\n\t}\n\t//uf u(tmp);\n\t//rep(i, tmp)rep(j, tmp)if (b[i][j])u.unite(i, j);\n\tvector<int> isns(tmp);\n\tvector<bool> chked(tmp, false);\n\trep(i, tmp) {\n\t\tif (chked[i])continue;\n\t\tint cur = 0;\n\t\tqueue<int> q; q.push(i);\n\t\twhile (!q.empty()) {\n\t\t\tint len = q.size();\n\t\t\trep(aa, len) {\n\t\t\t\tint id = q.front(); q.pop();\n\t\t\t\tisns[id] = cur;\n\t\t\t\trep(j, bG[id].size()) {\n\t\t\t\t\tint to = bG[id][j];\n\t\t\t\t\tif (chked[to])continue;\n\t\t\t\t\tchked[to] = true;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur ^= 1;\n\t\t}\n\t}\n\n\tvector<vector<int>> G(tmp);\n\trep(i, n) {\n\t\tint lid = v[i].first;\n\t\tint rid = v[i].second;\n\t\tG[lid].push_back(rid);\n\t}\n\trep(i, tmp)rep(j, tmp)if (b[i][j])G[i].push_back(j);\n\n\tcout << tmp << endl;\n\tint m; cin >> m;\n\trep(i, m) {\n\t\tstring s; cin >> s;\n\t\tint len = s.length();\n\t\tint lid, rid;\n\t\tbool valid = true;\n\t\trep(j, len) {\n\t\t\tif (s[j] == '-') {\n\t\t\t\tstring le = s.substr(0, j);\n\t\t\t\tstring ri = s.substr(j + 1, len - (j + 1));\n\t\t\t\tif (!used[le] || !used[ri])valid = false;\n\t\t\t\tlid = mp[le], rid = mp[ri];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!valid) {\n\t\t\tcout << \"NO\" << endl; continue;\n\t\t}\n\t\tif (!u.same(lid, rid)) {\n\t\t\tcout << \"NO\" << endl; continue;\n\t\t}\n\t\tif (isns[lid] == isns[rid]) {\n\t\t\tcout << \"NO\" << endl; continue;\n\t\t}\n\t\tfill(chked.begin(), chked.begin() + tmp, false);\n\t\tqueue<int> q; q.push(lid);\n\t\tbool f = false;\n\t\twhile (!q.empty()) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\tif (id == rid)f = true;\n\t\t\trep(j, G[id].size()) {\n\t\t\t\tint to = G[id][j];\n\t\t\t\tif (!chked[to]) {\n\t\t\t\t\tchked[to] = true;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\twhile(cin>>n,n)solve();\n\t//stop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    vector<int> parent; // em[h\n    vector<int> rank;   // ØÌ³ÌãÀ\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n){ // RXgN^\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n    }\n    void unite(int x, int y){ // xÆyÌO[vð¹\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y])\n                parent[x] = y;\n            else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n            }\n        }\n    }\n    bool same(int x, int y){ // xÆyÌO[vª¯¶©ð²×é\n        return find(x) == find(y);\n    }\n};\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        vector<vector<Edge> > edges;\n        vector<vector<int> > rev;\n        for(int i=0; i<n; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                a = edges.size();\n                edges.resize(a + 1);\n                rev.resize(a + 1);\n                index[s1] = a;\n            }else{\n                a = it->second;\n            }\n            it = index.find(s2);\n            if(it == index.end()){\n                b = edges.size();\n                edges.resize(b + 1);\n                rev.resize(b + 1);\n                index[s2] = b;\n            }else{\n                b = it->second;\n            }\n            edges[a].push_back(Edge(b, 1));\n            rev[b].push_back(a);\n        }\n\n        n = edges.size();\n        vector<vector<bool> > check(n, vector<bool>(n, false));\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<edges[i].size(); ++j){\n                int a = edges[i][j].to;\n                for(unsigned k=0; k<rev[a].size(); ++k){\n                    int b = rev[a][k];\n                    check[a][b] = check[b][a] = true;\n                }\n            }\n        }\n        UnionFindTree uft(n); // ¯\n        for(int i=0; i<n; ++i){\n            for(unsigned j=1; j<edges[i].size(); ++j){\n                int a = edges[i][j-1].to;\n                int b = edges[i][j].to;\n                if(!check[a][b])\n                    uft.unite(a, b);\n            }\n            for(unsigned j=1; j<rev[i].size(); ++j){\n                int a = rev[i][j-1];\n                int b = rev[i][j];\n                if(!check[a][b])\n                    uft.unite(a, b);\n            }\n        }\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                if(uft.same(i, j)){\n                    edges[i].push_back(Edge(j, 2));\n                    edges[j].push_back(Edge(i, 2));\n                }\n            }\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges, dist);\n\n        cout << n << endl;\n        int m;\n        cin >> m;\n        for(int i=0; i<m; ++i){\n            string s;\n            cin >> s;\n            string s1, s2;\n            s1 = s.substr(0, s.find('-'));\n            s2 = s.substr(s.find('-') + 1);\n\n            int a, b;\n            map<string, int>::iterator it;\n            it = index.find(s1);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            a = it->second;\n            it = index.find(s2);\n            if(it == index.end()){\n                cout << \"NO\" << endl;\n                continue;\n            }\n            b = it->second;\n\n            if(dist[a][b] != -1 && dist[a][b] % 2 == 1)\n                cout << \"YES\" << endl;\n            else\n                cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\ntypedef pair<int,int>P;\n\nint n,NUM,dp[222][222];\n\nint boo[222][222];\n\nint graph[222][222];\n\nvector<int>rv[222],v[222];\n\nbool used[222];\n\nset<int>st[222];\n\nmap<string,int>M;\n\nmap<pair<int,int>,int>MAP;\n\n\nvoid INIT(){\n\tmemset(graph,0,sizeof(graph));\n\tmemset(boo,0,sizeof(boo));\n\tMAP.clear();\n\tNUM=1;\n\tr(i,222)v[i].clear(),rv[i].clear(),st[i].clear();\n\tr(i,222)r(j,222)dp[i][j]=(i==j?0:1e8+1);\n}\n\nvoid WAR(){\n\tr(o,n)r(i,n)r(j,n)dp[i][j]=min(dp[i][j],dp[i][o]+dp[o][j]);\n}\n\n\n\nvoid make_graph(){\n\n\tMAP.clear();\n\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tMAP[P(i,v[i][j])]=1;\n\n\t\t\t//\tcout<<MM[i]<<' '<<MM[v[i][j]]<<endl;\n\t\t}\n\t}\n\t//cout<<endl<<endl<<endl;\n\n\tfor(int A=1;A<NUM;A++){\n\n\t\tfor(int B=A+1;B<NUM;B++){\n\n\t\t\tint flag = 1,flag2=0;\n\n\t\t\tfor(int D=1;D<NUM;D++){\n\n\t\t\t\tif(MAP[P(A,D)]&&MAP[P(D,B)])flag=0;\n\n\t\t\t\tif(MAP[P(D,A)]&&MAP[P(B,D)])flag=0;\n\n\t\t\t\tif(( (MAP[P(D,A)]&&MAP[P(D,B)]) || (MAP[P(A,D)]&&MAP[P(B,D)]) )) flag2 =1;\n\t\t\t}\n\n\t\t\t//\tif(A==2&&B==3)cout<<flag<<' '<<flag2<<endl;\n\n\t\t\tif(flag && flag2){\n\t\t\t\tboo[A][B] = boo[B][A] = 1;\n\n\t\t\t\t//cout<<MM[A]<<' '<<MM[B]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*vector<int>mato[222];\n\t\n\tfor(int i=1;i<NUM;i++){\n\t\t\n\t\tfor(int j=0;j<rv[i].size();j++){\n\t\t\t\n\t\t\tfor(int k=j+1;k<rv[i].size();k++){\n\t\t\t\t\n\t\t\t\tmato[rv[i][j]].push_back(rv[i][k]);\n\t\t\t\tmato[rv[i][k]].push_back(rv[i][j]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tr(i,NUM-1)cout<<MM[i+1]<<' '<<mato[i+1].size()<<endl;\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tr(k,mato[v[i][j]].size()){\n\t\t\t\tif(!st[i].count(mato[v[i][j]][k])){\n\t\t\t\t\t\n\t\t\t\t\tv[i].push_back(mato[v[i][j]][k]);\n\t\t\t\t\t\n\t\t\t\t\t st[i].insert(mato[v[i][j]][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}*/\n\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=0;j<v[i].size();j++){\n\n\t\t\tint now = v[i][j];\n\n\t\t\tgraph[i][now] = 1;\n\n\t\t\tfor(int k=1;k<NUM;k++){\n\t\t\t\tif(boo[now][k]){\n\n\t\t\t\t\tgraph[i][k] = 1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i=1;i<NUM;i++){\n\n\t\tfor(int j=1;j<NUM;j++){\n\n\t\t\tif(boo[i][j]){\n\n\t\t\t\tfor(int k=0;k<v[j].size();k++){\n\t\t\t\t\tgraph[i][v[j][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tr(i,222)v[i].clear();\n\n\tfor(int i=1;i<NUM;i++){\n\t\tfor(int j=1;j<NUM;j++){\n\t\t\tif(graph[i][j]){\n\n\t\t\t\tv[i].push_back(j);\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid INPUT(){\n\tr(i,n){\n\t\tint idx=0;\n\t\tstring s,s1,s2;      //cout<<1<<endl;\n\t\tcin>>s;\n\t\twhile(s[idx]!='-')s1+=s[idx++];             //cout<<s1<<endl;\n\t\tidx++;\n\t\twhile(idx<(int)s.size())s2+=s[idx++];\n\t\tif(M[s1]==0)M[s1]=NUM++;\n\t\tif(M[s2]==0)M[s2]=NUM++; //cout<<NUM<<endl;\n\t\t\n\t\tdp[M[s1]-1][M[s2]-1]=dp[M[s2]-1][M[s1]-1]=1;\n\t\t\n\t\tv[M[s1]].push_back(M[s2]);\n\t\tst[M[s1]].insert(M[s2]);\n\t\trv[M[s2]].push_back(M[s1]);\n\n\t\t//\tcout<<M[s1]<<' '<<M[s2]<<endl;\n\n\t\t//MAP[P(M[s1],M[s2])]=1;\n\t}\n\n\t//\tcout<<endl<<endl;\n\n\n\tr(i,NUM)make_graph();\n}\n\nbool BFS(int s,int t){\n\tmemset(used,0,sizeof(used));\n\tused[s]=1;\n\tqueue<int>q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();\n\t\tr(i,v[x].size()){\n\t\t\tint to = v[x][i];\n\t\t\tif(used[to])continue;\n\t\t\tused[to]=1;\n\t\t\tq.push(to);\n\t\t\tif(to==t)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid QUERY(){\n\n\t//cout<<grap\n\n\n\t/*for(int i=1;i<NUM;i++){\n\t\tcout<<endl;\n\t\tcout<<endl;\n\t\tcout<<MM[i]<<endl;\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tcout<<MM[v[i][j]]<<endl;\n\t\t}\n\t\t}*/\n\n\t\n\tcout<<NUM-1<<endl;\n\tint Q;\n\tcin>>Q;\n\twhile(Q--){\n\t\tint idx=0,start,goal;\n\t\tstring s,s1,s2;\n\t\tcin>>s;\n\t\twhile(s[idx]!='-')s1+=s[idx++];\n\t\tidx++;\n\t\twhile(idx<s.size())s2+=s[idx++];\n\n\t\tif(M[s1]==0||M[s2]==0){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(dp[M[s1]-1][M[s2]-1]<1e6&&dp[M[s1]-1][M[s2]-1]%2==0){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstart = M[s1];\n\t\tgoal  = M[s2];\n\n\t\tif(BFS(start,goal)||!BFS(goal,start)) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t\t\n\t}\n}\n\n\nint main(){\n\twhile(cin>>n,n){\n\t\tINIT();\n\t  INPUT();\n\t\tWAR();\n\t\tQUERY();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing ps = pair<string,string>;\n\nps split(string s){\n    int n = s.size();\n    int idx = 0;\n    while(idx<n && s[idx]!='-') ++idx;\n\n    return {s.substr(0,idx), s.substr(idx+1)};\n}\n\nconst int N = 200;\nconst int INF = 191919;\n\n// 入力から分かる強さ関係\nvector<int> G[N];\nbool arr[N][N];\n\nint d[N][N];\n\n// 水準関係\nint C[N][N];\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        rep(i,N) G[i].clear();\n        rep(i,N)rep(j,N) C[i][j]=INF;\n        rep(i,N) C[i][i]=0;\n        rep(i,N)rep(j,N) d[i][j]=INF;\n        rep(i,N) d[i][i]=0;\n        rep(i,N)rep(j,N) arr[i][j] = false;\n\n\n        map<string,int> c2id;\n        vector<string> names;\n        rep(i,n){\n            string s;\n            cin >>s;\n            ps cross = split(s);\n\n            if(!c2id.count(cross.fi)){\n                c2id[cross.fi] = c2id.size();\n                names.pb(cross.fi);\n            }\n            if(!c2id.count(cross.se)){\n                c2id[cross.se] = c2id.size();\n                names.pb(cross.se);\n            }\n            int u = c2id[cross.fi], v = c2id[cross.se];\n            G[u].pb(v);\n            C[u][v]=1;\n            d[u][v] = d[v][u] = 1;\n            arr[u][v] = true;\n        }\n\n        int V = c2id.size();\n\n        rep(k,V)rep(i,V)rep(j,V) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        auto same_degree = [&](int a, int b){\n            bool same = false;\n            rep(i,V){\n                if( (arr[a][i]||arr[i][a]) && (arr[b][i]||arr[i][b]) ) same = true;\n            }\n            if(!same) return false;\n\n            rep(i,V){\n                if(arr[i][a]&&arr[b][i]) return false;\n                if(arr[a][i]&&arr[i][b]) return false;\n            }\n\n            return true;\n        };\n\n        rep(i,V)rep(j,i){\n            if(same_degree(i,j)){\n                // cout << \"DEG :: \" << names[i] << \" \" << names[j] << endl;\n                C[i][j] = C[j][i] = 1;\n            }\n        }\n        rep(k,V)rep(i,V)rep(j,V) C[i][j] = min(C[i][j], C[i][k]+C[k][j]);\n\n        cout << V << endl;\n\n        int Q;\n        cin >>Q;\n        while(Q--){\n            string q;\n            cin >>q;\n\n            ps qc = split(q);\n\n            int u = c2id[qc.fi], v = c2id[qc.se];\n            // dbg(C[u][v]);\n\n            bool ok = false;\n            if(d[u][v]%2==1 && C[u][v]<INF) ok = true;\n            cout << (ok?\"YES\":\"NO\") << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n) break;\n    vector<pair<string, string>> cross;\n    vector<string> lines;\n    REP(i,n) {\n      string l;\n      cin>>l;\n      int p = l.find('-');\n      string left = l.substr(0, p);\n      lines.push_back(left);\n      string right = l.substr(p+1);\n      lines.push_back(right);\n      cross.emplace_back(left, right);\n    }\n    sort(ALL(lines));\n    lines.erase(unique(ALL(lines)), end(lines));\n    int s = lines.size();\n    vector<vector<int>> mat(s, vector<int>(s, INF));\n    REP(i,n) {\n      string left, right;\n      tie(left, right) = cross[i];\n      int beg = lower_bound(ALL(lines), left) - begin(lines);\n      int ed = lower_bound(ALL(lines), right) - begin(lines);\n      mat[beg][ed] = 1;\n    }\n    REP(i,s)REP(j,s) {\n      bool ok = true;\n      bool valid = false;\n      REP(k,s) {\n        if (mat[i][k] < INF && mat[k][j] < INF) ok = false;\n        if (mat[j][k] < INF && mat[k][i] < INF) ok = false;\n        if (mat[i][k] < INF && mat[j][k] < INF) valid = true;\n        if (mat[k][i] < INF && mat[k][j] < INF) valid = true;\n      }\n      if (valid && ok) {\n        mat[i][j] = 0;\n        mat[j][i] = 0;\n      }\n    }\n    REP(k,s)REP(i,s)REP(j,s) mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j]);\n    int m;\n    cin>>m;\n    cout << lines.size() << endl;\n    REP(i,m) {\n      bool ok = true;\n      string l;\n      cin>>l;\n      int p = l.find('-');\n      string left = l.substr(0, p);\n      string right = l.substr(p+1);\n      auto itr = lower_bound(ALL(lines), left);\n      int li = itr - begin(lines);\n      if (itr == end(lines) || *itr != left) {\n        ok = false;\n      }\n      itr = lower_bound(ALL(lines), right);\n      int ri = itr - begin(lines);\n      if (itr == end(lines) || *itr != right) {\n        ok = false;\n      }\n      int d1 = mat[li][ri];\n      int d2 = mat[ri][li];\n      if ((d1 % 2) == 0 && (d2 % 2) == 0) {\n        ok = false;\n      }\n      if (ok && d1 < INF) {\n        cout << \"YES\" << endl;\n      } else {\n        cout << \"NO\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<string, string> pss;\n\npss split(string s) {\n  ll k;\n  REP(i, 0, s.size()) if(s[i] == '-') k = i;\n  string fi = s.substr(0, k);\n  string se = s.substr(k + 1, s.size() - k - 1);\n  return pss(fi, se);\n}\n\nvoid dfs(ll v, vector<vector<ll>> &E, vector<bool> &used, vector<ll> &color, ll c) {\n  if(used[v]) return;\n  used[v] = true;\n\n  color[v] = c;\n  for(ll u : E[v]) dfs(u, E, used, color, 1 - c);\n}\n\nbool dfs2(ll v, ll g, vector<vector<ll>> &E, vector<bool> &used) {\n  if(v == g) return true;\n\n  if(used[v]) return false;\n  used[v] = true;\n\n  bool ret = false;\n  for(ll u : E[v]) ret = ret || dfs2(u, g, E, used);\n  return ret;\n}\n\nint main(void) {\n  ll N, M;\n  while(cin >> N, N) {\n    vector<string> uniq;\n    vector<pss> C(N);\n    REP(i, 0, N) {\n      string s;\n      cin >> s;\n      C[i] = split(s);\n      uniq.push_back(C[i].first);\n      uniq.push_back(C[i].second);\n    }\n    cin >> M;\n    vector<pss> Q(M);\n    REP(i, 0, M) {\n      string s;\n      cin >> s;\n      Q[i] = split(s);\n      uniq.push_back(Q[i].first);\n      uniq.push_back(Q[i].second);\n    }\n    sort(uniq.begin(), uniq.end());\n    uniq.erase(unique(uniq.begin(), uniq.end()), uniq.end());\n\n    vector<pll> cross(N), query(M);\n    REP(i, 0, N) {\n      cross[i].first = lower_bound(uniq.begin(), uniq.end(), C[i].first) - uniq.begin();\n      cross[i].second = lower_bound(uniq.begin(), uniq.end(), C[i].second) - uniq.begin();\n    }\n    REP(i, 0, M) {\n      query[i].first = lower_bound(uniq.begin(), uniq.end(), Q[i].first) - uniq.begin();\n      query[i].second = lower_bound(uniq.begin(), uniq.end(), Q[i].second) - uniq.begin();\n    }\n\n    ll n = uniq.size();\n    vector<vector<ll>> E(n), R(n), A(n);\n    REP(i, 0, N) {\n      E[cross[i].first].push_back(cross[i].second);\n      R[cross[i].second].push_back(cross[i].first);\n      A[cross[i].first].push_back(cross[i].second);\n      A[cross[i].second].push_back(cross[i].first);\n    }\n\n    vector<bool> used(n, false);\n    vector<ll> color(n);\n    REP(i, 0, n) if(!used[i]) dfs(i, A, used, color, 0);\n\n    vector<vector<ll>> X(n);\n    REP(i, 0, N) X[cross[i].first].push_back(cross[i].second);\n    REP(i, 0, n) {\n      for(ll u : E[i]) for(ll v : E[i]) if(u != v) X[u].push_back(v);\n      for(ll u : R[i]) for(ll v : R[i]) if(u != v) X[u].push_back(v);\n    }\n\n    set<ll> st;\n    REP(i, 0, N) {\n      st.insert(cross[i].first);\n      st.insert(cross[i].second);\n    }\n\n    cout << st.size() << endl;\n    REP(i, 0, M) {\n      ll s = query[i].first, t = query[i].second;\n      vector<bool> used(n);\n      bool ok = color[s] != color[t] && dfs2(s, t, X, used);\n      cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\treturn vs{ l,r };\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n, q;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p++;\n\t\t}\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p, INF));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] == 1 || dist[k][i] == 1) && (dist[j][k] == 1 || dist[k][j] == 1)) f1 = true;\n\t\t\t\tif ((dist[i][k] == 1 && dist[k][j] == 1) || (dist[k][i] == 1 && dist[j][k] == 1)) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p) chmin(dist[i][j], dist[i][k] + dist[k][j]);\n\t\tvi color(p, -1);\n\t\tint col = 0;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i] != -1) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = col + 1;\n\t\t\tcolor[i] = c;\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to] != -1) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol += 2;\n\t\t}\n\t\tcout << p << endl;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif ((color[l] != color[r] && color[l] / 2 == color[r] / 2) && dist[r][l] != INF)\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvs input(string& s)\n{\n\tint t = s.find('-');\n\tstring l = s.substr(0, t);\n\tstring r = s.substr(t + 1);\n\tvs res;\n\tres.push_back(l); res.push_back(r);\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vs> v(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tv[i] = input(s);\n\t\t}\n\t\tint p = 0;\n\t\tREP(i, n)REP(j, 2)\n\t\t{\n\t\t\tstring tmp = v[i][j];\n\t\t\tif (mp.count(tmp)) continue;\n\t\t\tmp[tmp] = p;\n\t\t\tp++;\n\t\t}\n\t\tcout << p << endl;\n\t\tGraph g(p);\n\t\tMatrix dist(p, Array(p));\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l = mp[v[i][0]], r = mp[v[i][1]];\n\t\t\tadd_edge(g, l, r, 1);\n\t\t\tadd_edge(g, r, l, 1);\n\t\t\tdist[r][l] = 1;\n\t\t}\n\t\tvector<pii> same;\n\t\tREP(i, p)REP(j, i)\n\t\t{\n\t\t\tbool f1 = false, f2 = true;\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif ((dist[i][k] || dist[k][i]) && (dist[j][k] || dist[k][j])) f1 = true;\n\t\t\t\tif ((dist[i][k] && dist[k][j]) || (dist[k][i] && dist[j][k])) f2 = false;\n\t\t\t}\n\t\t\tif (f1&&f2) same.emplace_back(i, j);\n\t\t}\n\t\tfor (auto i : same)\n\t\t{\n\t\t\tdist[i.first][i.second] = 1;\n\t\t\tdist[i.second][i.first] = 1;\n\t\t}\n\t\tREP(k, p)REP(i, p)REP(j, p)\n\t\t{\n\t\t\tif (dist[i][k] && dist[k][j]) dist[i][j] = 1;\n\t\t}\n\t\tvi color(p);\n\t\tint col = 1;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (color[i]) continue;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\tint c = col, d = -col;\n\t\t\tcolor[i] = c;\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint nx = (color[t] == c ? d : c);\n\t\t\t\tREP(j, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (color[g[t][j].to]) continue;\n\t\t\t\t\tcolor[g[t][j].to] = nx;\n\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol++;\n\t\t}\n\t\tint q;\n\t\tcin >> q;\n\t\tREP(i, q)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tvs t = input(s);\n\t\t\tif (!mp.count(t[0]) || !mp.count(t[1]))\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = mp[t[0]], r = mp[t[1]];\n\t\t\tif (color[l] == -color[r] && dist[r][l])\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n#include <cstring>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define pii pair<int,int>\n\n#define MAXT 200\n\nbool graph[MAXT][MAXT]={};\nint color[MAXT];\n\nvoid dfs(int a, int base){\n    rep(i,MAXT){\n        if(color[i]==-1 && (graph[a][i]||graph[i][a])){\n            color[i]=(color[a]+1)%2+base;\n            dfs(i,base);\n        }\n    }\n}\n\nvoid read(string &s1, string &s2){\n    string s;\n    cin>>s;\n    int i=s.find_first_of('-');\n    s1=s.substr(0, i);\n    s2=s.substr(i+1);\n}\n\nint main(){\n    while(1){\n        fill_n(*graph, MAXT*MAXT, false);\n        fill_n(color, MAXT, -1);\n\n        int N,M;\n        cin>>N;\n        if(N==0) break;\n        map<string,int> lnames;\n        int lindex = 0;\n        rep(ii,N){\n            string s1,s2;\n            read(s1,s2);\n            //cout<<s1<<\" \"<<s2<<endl;\n            if(!lnames.count(s1)){\n                lnames[s1] = lindex++;\n            }\n            if(!lnames.count(s2)){\n                lnames[s2] = lindex++;\n            }\n            graph[lnames[s1]][lnames[s2]]=true;\n            //cout<<lnames[s1]<<\" \"<<lnames[s2]<<endl;\n        }\n\n        /*rep(i,lindex){\n            rep(j,lindex){\n                cout<<graph[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n\n        int base=0;\n        rep(i,lindex){\n            if(color[i]!=-1) continue;\n            color[i]=base;\n            dfs(i,base);\n            base+=2;\n        }\n\n        rep(i,lindex){\n            rep(j,lindex){\n                rep(k,lindex){\n                    if(graph[i][k] && graph[j][k] && !(graph[k][i] || graph[k][j])){\n                        graph[i][j] = true;\n                        graph[j][i] = true;\n                    }\n                }\n            }\n        }\n\n        rep(k,lindex){\n            rep(i,lindex){\n                rep(j,lindex){\n                    if(graph[i][k] && graph[k][j]){\n                        graph[i][j]=true;\n                    }\n                }\n            }\n        }\n\n        /*cout<<endl;\n        rep(i,lindex){\n            rep(j,lindex){\n                cout<<graph[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n\n        cout<<lindex<<endl;\n\n        cin>>M;\n        rep(ii,M){\n            string s1,s2;\n            read(s1,s2);\n\n            if(!lnames.count(s1) || !lnames.count(s2)){\n                cout<<\"NO\"<<endl;\n            }\n            else\n            {\n                int p1=lnames[s1],p2=lnames[s2];\n                if(graph[p1][p2] && color[p1] != color[p2] && abs(color[p1] - color[p2]) == 1){\n                    cout<<\"YES\"<<endl;\n                }\n                else\n                {\n                    cout<<\"NO\"<<endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1134: Name the Crossing\n// 2017.11.13 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HASHSIZ 503\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\t\t\t// Hash table\n\nint insert(char *s, int w, int id)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nint lookup(char *s, int w)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\treturn -1;\n}\n\nchar name[202][36]; int sz;\nchar rel[202][202], tmp[202][202];\nint cross[202];\n\nvoid found(int j, int k)\n{\n\tint i;\n\n\tcross[j] = k;\n\tfor (i = 0; i < sz; i++) {\n\t\tif (!cross[i] && (rel[i][j] || rel[j][i])) found(i, -k);\n\t}\n}\n\nint main()\n{\n\tint n, m, w, i, j, k;\n\tchar buf[36], *p, *q;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tmemset(rel, 0, sizeof(rel));\n\n\t\tn = atoi(buf), sz = 0;\n\t\twhile (n--) {\n\t\t\tfgets(name[sz], 35, stdin);\n\t\t\tp = q = name[sz]; while (*p != '-') p++; w = p - q, *p++ = 0;\n\t\t\tif ((i = insert(q, w, sz)) < 0) i = sz++;\n\t\t\tq = p; while (*p > ' ') p++; w = p - q, *p = 0;\n\t\t\tif ((j = insert(q, w, sz)) < 0) j = sz++;\n\t\t\trel[i][j] = 1;\n\t\t}\n\t\tprintf(\"%d\\n\", sz);\n\n\t\tmemset(cross, 0, sizeof(cross));\n\t\tfor (k = 1, i = 0; i < sz; i++)\tif (!cross[i]) found(i, k++);\n\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tfor (i = 0; i < sz; i++) for (j = 0; j < sz; j++) if (j != i) {\n\t\t\tint comm = 0, strong = 1;\n\t\t\tfor (k = 0; k < sz; k++) if (k != i && k != j) {\n\t\t\t\tif ((rel[i][k] || rel[k][i]) && (rel[j][k] || rel[k][j])) comm = 1;\n\t\t\t\tif ((rel[i][k] && rel[k][j]) || (rel[j][k] && rel[k][i])) strong = 0;\n\t\t\t\tif (comm && !strong) break;\n\t\t\t}\n\t\t\tif (comm && strong) tmp[i][j] = 1;\n\t\t}\n\t\tfor (i = 0; i < sz; i++) for (j = 0; j < sz; j++) rel[i][j] |= tmp[i][j];\n\n\t\tfor (k = 0; k < sz; k++) for (i = 0; i < sz; i++) for (j = 0; j < sz; j++)\n\t\t\tif (rel[i][k] && rel[k][j]) rel[i][j] = 1;\n\n\t\tfgets(buf, 10, stdin); m = atoi(buf);\n\t\twhile (m--) {\n\t\t\tfgets(buf, 35, stdin);\n\t\t\tp = q = buf; while (*p != '-') p++;\tw = p - q, *p++ = 0;\n\t\t\tif ((i = lookup(q, w)) < 0) goto no;\n\t\t\tq = p; while (*p > ' ') p++; w = p - q, *p = 0;\n\t\t\tif ((j = lookup(q, w)) < 0) goto no;\n\t\t\tif (cross[i] == -cross[j] && rel[i][j]) puts(\"YES\");\n\t\t\telse {\nno:\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1134: Name the Crossing\n// 2017.11.13 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HASHSIZ 503\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\t\t\t// Hash table\n\nint insert(char *s, int w, int id)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nint lookup(char *s, int w)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\treturn -1;\n}\n\n#define INT 0x11111111\nchar name[202][36]; int sz;\nint rel[202][202];\n\nint main()\n{\n\tint n, m, w, i, j, k, f;\n\tchar buf[36], *p, *q;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tmemset(rel, INT, sizeof(rel));\n\n\t\tn = atoi(buf), sz = 0;\n\t\twhile (n--) {\n\t\t\tfgets(name[sz], 35, stdin);\n\t\t\tp = q = name[sz]; while (*p != '-') p++; w = p - q, *p++ = 0;\n\t\t\tif ((i = insert(q, w, sz)) < 0) i = sz++;\n\t\t\tq = p; while (*p > ' ') p++; w = p - q, *p = 0;\n\t\t\tif ((j = insert(q, w, sz)) < 0) j = sz++;\n\t\t\trel[i][j] = 1;\n\t\t}\n\t\tprintf(\"%d\\n\", sz);\n\n\t\tfor (i = 0; i < sz; i++) for (j = 0; j < sz; j++) if (i != j) {\n\t\t\tf = 0;\n\t\t\tfor (k = 0; k < sz; k++) {\n\t\t\t\tif ((rel[i][k] == 1 && rel[k][j] == 1) ||\n\t\t\t\t\t(rel[j][k] == 1 && rel[k][i] == 1)) { f = 0; break; }\n\t\t\t\tif ((rel[i][k] == 1 && rel[j][k] == 1) ||\n\t\t\t\t\t(rel[k][i] == 1 && rel[k][j] == 1)) f = 1;\n\t\t\t}\n\t\t\tif (f) rel[i][j] = rel[j][i] = 0;\n\t\t}\n\n\t\tfor (k = 0; k < sz; k++) for (i = 0; i < sz; i++) for (j = 0; j < sz; j++)\n\t\t\tif (rel[i][j] > rel[i][k] + rel[k][j]) rel[i][j] = rel[i][k] + rel[k][j];\n\n\t\tfgets(buf, 10, stdin); m = atoi(buf);\n\t\twhile (m--) {\n\t\t\tfgets(buf, 35, stdin);\n\t\t\tp = q = buf; while (*p != '-') p++;\tw = p - q, *p++ = 0;\n\t\t\tif ((i = lookup(q, w)) < 0) goto no;\n\t\t\tq = p; while (*p > ' ') p++; w = p - q, *p = 0;\n\t\t\tif ((j = lookup(q, w)) < 0) goto no;\n\t\t\tif (rel[i][j] < INT && (rel[i][j] & 1)) puts(\"YES\");\n\t\t\telse {\nno:\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1134: Name the Crossing\n// 2017.11.13 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HASHSIZ 503\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\t\t\t// Hash table\n\nint insert(char *s, int w, int id)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nint lookup(char *s, int w)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\treturn -1;\n}\n\nchar name[202][36]; int sz;\nchar rel[202][202], tmp[202][202];\nint cross[202];\n\nvoid found(int j, int k)\n{\n\tint i;\n\n\tcross[j] = k;\n\tfor (i = 0; i < sz; i++) {\n\t\tif (!cross[i] && (rel[i][j] || rel[j][i])) found(i, -k);\n\t}\n}\n\nint main()\n{\n\tint n, m, w, i, j, k;\n\tchar buf[36], *p, *q;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tmemset(rel, 0, sizeof(rel));\n\n\t\tn = atoi(buf), sz = 0;\n\t\twhile (n--) {\n\t\t\tfgets(name[sz], 35, stdin);\n\t\t\tp = q = name[sz]; while (*p != '-') p++; w = p - q, *p++ = 0;\n\t\t\tif ((i = insert(q, w, sz)) < 0) i = sz++;\n\t\t\tq = p; while (*p > ' ') p++; w = p - q, *p = 0;\n\t\t\tif ((j = insert(q, w, sz)) < 0) j = sz++;\n\t\t\trel[i][j] = 1;\n\t\t}\n\t\tprintf(\"%d\\n\", sz);\n\n\t\tmemset(cross, 0, sizeof(cross));\n\t\tfor (k = 1, i = 0; i < sz; i++)\tif (!cross[i]) found(i, k++);\n\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tfor (i = 0; i < sz; i++) for (j = 0; j < sz; j++) {\n\t\t\tint comm = 0, strong = 1;\n\t\t\tfor (k = 0; k < sz; k++) {\n\t\t\t\tif ((rel[i][k] || rel[k][i]) && (rel[j][k] || rel[k][j])) comm = 1;\n\t\t\t\tif ((rel[i][k] && rel[k][j]) || (rel[j][k] && rel[k][i])) strong = 0;\n\t\t\t\tif (comm && !strong) break;\n\t\t\t}\n\t\t\tif (comm && strong) tmp[i][j] = 1;\n\t\t}\n\t\tfor (i = 0; i < sz; i++) for (j = 0; j < sz; j++) rel[i][j] |= tmp[i][j];\n\n\t\tfor (k = 0; k < sz; k++) for (i = 0; i < sz; i++) for (j = 0; j < sz; j++)\n\t\t\tif (rel[i][k] && rel[k][j]) rel[i][j] = 1;\n\n\t\tfgets(buf, 10, stdin); m = atoi(buf);\n\t\twhile (m--) {\n\t\t\tfgets(buf, 35, stdin);\n\t\t\tp = q = buf; while (*p != '-') p++;\tw = p - q, *p++ = 0;\n\t\t\tif ((i = lookup(q, w)) < 0) goto no;\n\t\t\tq = p; while (*p > ' ') p++; w = p - q, *p = 0;\n\t\t\tif ((j = lookup(q, w)) < 0) goto no;\n\t\t\tif (cross[i] == -cross[j] && rel[i][j]) puts(\"YES\");\n\t\t\telse {\nno:\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1134: Name the Crossing\n// 2017.11.13 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HASHSIZ 503\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\t\t\t// Hash table\n\nint insert(char *s, int w, int id)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nint lookup(char *s, int w)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\treturn -1;\n}\n\n#define INT 0x20202020\nchar name[202][36]; int sz;\nint rel[202][202];\n\nint main()\n{\n\tint n, m, w, i, j, k;\n\tchar buf[36], *p, *q;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tmemset(rel, INT, sizeof(rel));\n\n\t\tn = atoi(buf), sz = 0;\n\t\twhile (n--) {\n\t\t\tfgets(name[sz], 35, stdin);\n\t\t\tp = q = name[sz]; while (*p != '-') p++; w = p - q, *p++ = 0;\n\t\t\tif ((i = insert(q, w, sz)) < 0) i = sz++;\n\t\t\tq = p; while (*p > ' ') p++; w = p - q, *p = 0;\n\t\t\tif ((j = insert(q, w, sz)) < 0) j = sz++;\n\t\t\trel[i][j] = 1;\n\t\t}\n\t\tprintf(\"%d\\n\", sz);\n\n\t\tfor (i = 0; i < sz; i++) for (j = 0; j < sz; j++) if (j != i) {\n\t\t\tint f = 0;\n\t\t\tfor (k = 0; k < sz; k++) {\n\t\t\t\tif (rel[i][k] & 1 && rel[k][j] & 1 ||\n\t\t\t\t\trel[j][k] & 1 && rel[k][i] & 1) { f = 0; break; }\n\t\t\t\tif (!f) {\n\t\t\t\t\tif (rel[i][k] & 1 && rel[j][k] & 1 ||\n\t\t\t\t\t\trel[k][i] & 1 && rel[k][j] & 1) f = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) rel[i][j] = rel[j][i] = 0;\n\t\t}\n\n\t\tfor (k = 0; k < sz; k++) for (i = 0; i < sz; i++) for (j = 0; j < sz; j++)\n\t\t\tif (rel[i][j] > rel[i][k] + rel[k][j]) rel[i][j] = rel[i][k] + rel[k][j];\n\n\t\tfgets(buf, 10, stdin); m = atoi(buf);\n\t\twhile (m--) {\n\t\t\tfgets(buf, 35, stdin);\n\t\t\tp = q = buf; while (*p != '-') p++;\tw = p - q, *p++ = 0;\n\t\t\tif ((i = lookup(q, w)) < 0) goto no;\n\t\t\tq = p; while (*p > ' ') p++; w = p - q, *p = 0;\n\t\t\tif ((j = lookup(q, w)) < 0) goto no;\n\t\t\tif (rel[i][j] & 1) puts(\"YES\");\n\t\t\telse {\nno:\t\t\t\tputs(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Name the Crossing\npublic class Main{\n\n\tclass R{\n\t\tint id, col;\n\t\tSet<Integer> adj, eq;\n\t\tboolean visit;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tcol = -1;\n\t\t\teq = new HashSet<Integer>();\n\t\t\tadj = new HashSet<Integer>();\n\t\t}\n\t\tvoid color(int c){\n\t\t\tif(visit)return;\n\t\t\tcol = c;\n\t\t\tvisit = true;\n\t\t\tfor(int v:adj)rs[v].color(c%2==0?(c+1):(c-1));\n\t\t}\n\t\tboolean reach(int g){\n\t\t\tif(id==g)return true;\n\t\t\tif(visit)return false;\n\t\t\tvisit = true;\n\t\t\tfor(int v:eq)if(rs[v].reach(g))return true;\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tint ID;\n\tMap<String, R> ref;\n\tSet<String> streets;\n\tString[] names;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR res = new R(ID);\n\t\tnames[ID] = s;\n\t\trs[ID++] = res;\n\t\tref.put(s, res);\n\t\treturn res;\n\t}\n\tR[] rs;\n\t\n\tvoid reset(){\n\t\tfor(int i=0;i<ID;i++)rs[i].visit = false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tID = 0;\n\t\t\tref = new HashMap<String, R>();\n\t\t\trs = new R[200];\n\t\t\tnames = new String[200];\n\t\t\tstreets = new HashSet<String>();\n\t\t\twhile(n--!=0){\n\t\t\t\tString t = sc.next();\n\t\t\t\tstreets.add(t);\n\t\t\t\tString s[] = t.split(\"-\");\n\t\t\t\tR a = get(s[0]), b = get(s[1]);\n\t\t\t\ta.adj.add(b.id); b.adj.add(a.id);\n\t\t\t\tb.eq.add(a.id);\n\t\t\t}\n\t\t\tint col = 0;\n\t\t\tfor(int i=0;i<ID;i++){\n\t\t\t\tif(rs[i].visit)continue;\n\t\t\t\trs[i].color(col);\n\t\t\t\tcol+=2;\n\t\t\t}\n\t\t\tint N =\tID;\n\t\t\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\t\t\tboolean C, D, E;\n\t\t\t\tC = false;\n\t\t\t\tD = E = true;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\t\tif(rs[i].adj.contains(k)&&rs[j].adj.contains(k))C = true;\n\t\t\t\t\tif(streets.contains(names[k]+\"-\"+names[i])&&streets.contains(names[j]+\"-\"+names[k]))D = false;\n\t\t\t\t\tif(streets.contains(names[i]+\"-\"+names[k])&&streets.contains(names[k]+\"-\"+names[j]))E = false;\n\t\t\t\t\tif(!(C&&D&&E))break;\n\t\t\t\t}\n\t\t\t\tif(C&&D&&E){\n\t\t\t\t\tR a = get(names[i]), b = get(names[j]);\n\t\t\t\t\ta.eq.add(b.id); b.eq.add(a.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(N);\n\t\t\tint m = sc.nextInt();\n\t\t\twhile(m--!=0){\n\t\t\t\tString[] t = sc.next().split(\"-\");\n\t\t\t\tR a = get(t[0]), b = get(t[1]);\n\t\t\t\tif(a.col==b.col||Math.abs(a.col-b.col)>=2||a.col==-1||b.col==-1){\n\t\t\t\t\tSystem.out.println(\"NO\"); continue;\n\t\t\t\t}\n\t\t\t\treset();\n\t\t\t\tSystem.out.println(b.reach(a.id)?\"YES\":\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Name the Crossing\npublic class Main{\n\n\tclass R{\n\t\tint id, col;\n\t\tSet<Integer> adj, eq;\n\t\tboolean visit;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tcol = -1;\n\t\t\teq = new HashSet<Integer>();\n\t\t\tadj = new HashSet<Integer>();\n\t\t}\n\t\tvoid color(int c){\n\t\t\tif(visit)return;\n\t\t\tcol = c;\n\t\t\tvisit = true;\n\t\t\tfor(int v:adj)rs[v].color(c%2==0?(c+1):(c-1));\n\t\t}\n\t\tboolean reach(int g){\n\t\t\tif(id==g)return true;\n\t\t\tif(visit)return false;\n\t\t\tvisit = true;\n\t\t\tfor(int v:eq)if(rs[v].reach(g))return true;\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tint ID;\n\tMap<String, R> ref;\n\tSet<String> streets;\n\tString[] names;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR res = new R(ID);\n\t\tnames[ID] = s;\n\t\trs[ID++] = res;\n\t\tref.put(s, res);\n\t\treturn res;\n\t}\n\tR[] rs;\n\t\n\tvoid reset(){\n\t\tfor(int i=0;i<ID;i++)rs[i].visit = false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tID = 0;\n\t\t\tref = new HashMap<String, R>();\n\t\t\trs = new R[200];\n\t\t\tnames = new String[200];\n\t\t\tstreets = new HashSet<String>();\n\t\t\twhile(n--!=0){\n\t\t\t\tString t = sc.next();\n\t\t\t\tstreets.add(t);\n\t\t\t\tString s[] = t.split(\"-\");\n\t\t\t\tR a = get(s[0]), b = get(s[1]);\n\t\t\t\ta.adj.add(b.id); b.adj.add(a.id);\n\t\t\t\tb.eq.add(a.id);\n\t\t\t}\n\t\t\tint col = 0;\n\t\t\tfor(int i=0;i<ID;i++){\n\t\t\t\tif(rs[i].visit)continue;\n\t\t\t\trs[i].color(col);\n\t\t\t\tcol+=2;\n\t\t\t}\n\t\t\tint N =\tID;\n\t\t\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\t\t\tboolean C, D, E;\n\t\t\t\tC = false;\n\t\t\t\tD = E = true;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\t\tif(rs[i].adj.contains(k)&&rs[j].adj.contains(k))C = true;\n\t\t\t\t\tif(streets.contains(names[k]+\"-\"+names[i])&&streets.contains(names[j]+\"-\"+names[k]))D = false;\n\t\t\t\t\tif(streets.contains(names[i]+\"-\"+names[k])&&streets.contains(names[k]+\"-\"+names[j]))E = false;\n\t\t\t\t}\n\t\t\t\tif(C&&D&&E){\n\t\t\t\t\tR a = get(names[i]), b = get(names[j]);\n\t\t\t\t\ta.eq.add(b.id); b.eq.add(a.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(N);\n\t\t\tint m = sc.nextInt();\n\t\t\twhile(m--!=0){\n\t\t\t\tString[] t = sc.next().split(\"-\");\n\t\t\t\tR a = get(t[0]), b = get(t[1]);\n\t\t\t\tif(a.col==b.col||Math.abs(a.col-b.col)>=2||a.col==-1||b.col==-1){\n\t\t\t\t\tSystem.out.println(\"NO\"); continue;\n\t\t\t\t}\n\t\t\t\treset();\n\t\t\t\tSystem.out.println(b.reach(a.id)?\"YES\":\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Name the Crossing\npublic class Main{\n\n\tclass R{\n\t\tint id, col;\n\t\tSet<Integer> adj, eq;\n\t\tboolean visit;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tcol = -1;\n\t\t\teq = new HashSet<Integer>();\n\t\t\tadj = new HashSet<Integer>();\n\t\t}\n\t\tvoid color(int c){\n\t\t\tif(visit)return;\n\t\t\tcol = c;\n\t\t\tvisit = true;\n\t\t\tfor(int v:adj)rs[v].color(c%2==0?(c+1):(c-1));\n\t\t}\n\t\tboolean reach(int g){\n\t\t\tif(id==g)return true;\n\t\t\tif(visit)return false;\n\t\t\tvisit = true;\n\t\t\tfor(int v:eq)if(rs[v].reach(g))return true;\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tint ID;\n\tMap<String, R> ref;\n\tSet<String> streets;\n\tString[] names;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR res = new R(ID);\n\t\tnames[ID] = s;\n\t\trs[ID++] = res;\n\t\tref.put(s, res);\n\t\treturn res;\n\t}\n\tR[] rs;\n\t\n\tvoid reset(){\n\t\tfor(int i=0;i<ID;i++)rs[i].visit = false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tID = 0;\n\t\t\tref = new HashMap<String, R>();\n\t\t\trs = new R[200];\n\t\t\tnames = new String[200];\n\t\t\tstreets = new HashSet<String>();\n\t\t\twhile(n--!=0){\n\t\t\t\tString t = sc.next();\n\t\t\t\tstreets.add(t);\n\t\t\t\tString s[] = t.split(\"-\");\n\t\t\t\tR a = get(s[0]), b = get(s[1]);\n\t\t\t\ta.adj.add(b.id); b.adj.add(a.id);\n\t\t\t\tb.eq.add(a.id);\n\t\t\t}\n\t\t\tint col = 0;\n\t\t\tfor(int i=0;i<ID;i++){\n\t\t\t\tif(rs[i].visit)continue;\n\t\t\t\trs[i].color(col);\n\t\t\t\tcol+=2;\n\t\t\t}\n\t\t\tint N =\tID;\n\t\t\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\t\t\tboolean C, D, E;\n\t\t\t\tC = false;\n\t\t\t\tD = E = true;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\t\tif(rs[i].adj.contains(k)&&rs[j].adj.contains(k))C = true;\n\t\t\t\t\tif(streets.contains(names[k]+\"-\"+names[i])&&streets.contains(names[j]+\"-\"+names[k]))D = false;\n\t\t\t\t\tif(streets.contains(names[i]+\"-\"+names[k])&&streets.contains(names[k]+\"-\"+names[j]))E = false;\n\t\t\t\t\tif(!D||!E||C&&D&&E)break;\n\t\t\t\t}\n\t\t\t\tif(C&&D&&E){\n\t\t\t\t\tR a = get(names[i]), b = get(names[j]);\n\t\t\t\t\ta.eq.add(b.id); b.eq.add(a.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(N);\n\t\t\tint m = sc.nextInt();\n\t\t\twhile(m--!=0){\n\t\t\t\tString[] t = sc.next().split(\"-\");\n\t\t\t\tR a = get(t[0]), b = get(t[1]);\n\t\t\t\tif(a.col==b.col||Math.abs(a.col-b.col)>=2||a.col==-1||b.col==-1){\n\t\t\t\t\tSystem.out.println(\"NO\"); continue;\n\t\t\t\t}\n\t\t\t\treset();\n\t\t\t\tSystem.out.println(b.reach(a.id)?\"YES\":\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Name the Crossing\npublic class Main{\n\n\tclass R{\n\t\tint id, col;\n\t\tSet<Integer> adj, eq;\n\t\tboolean visit;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tcol = -1;\n\t\t\teq = new HashSet<Integer>();\n\t\t\tadj = new HashSet<Integer>();\n\t\t}\n\t\tvoid color(int c){\n\t\t\tif(visit)return;\n\t\t\tcol = c;\n\t\t\tvisit = true;\n\t\t\tfor(int v:adj)rs[v].color(c%2==0?(c+1):(c-1));\n\t\t}\n\t\tboolean reach(int g){\n\t\t\tif(id==g)return true;\n\t\t\tif(visit)return false;\n\t\t\tvisit = true;\n\t\t\tfor(int v:eq)if(rs[v].reach(g))return true;\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tint ID;\n\tMap<String, R> ref;\n\tSet<String> streets;\n\tString[] names;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR res = new R(ID);\n\t\tnames[ID] = s;\n\t\trs[ID++] = res;\n\t\tref.put(s, res);\n\t\treturn res;\n\t}\n\tR[] rs;\n\t\n\tvoid reset(){\n\t\tfor(int i=0;i<ID;i++)rs[i].visit = false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tID = 0;\n\t\t\tref = new HashMap<String, R>();\n\t\t\trs = new R[200];\n\t\t\tnames = new String[200];\n\t\t\tstreets = new HashSet<String>();\n\t\t\twhile(n--!=0){\n\t\t\t\tString t = sc.next();\n\t\t\t\tstreets.add(t);\n\t\t\t\tString s[] = t.split(\"-\");\n\t\t\t\tR a = get(s[0]), b = get(s[1]);\n\t\t\t\ta.adj.add(b.id); b.adj.add(a.id);\n\t\t\t\tb.eq.add(a.id);\n\t\t\t}\n\t\t\tint col = 0;\n\t\t\tfor(int i=0;i<ID;i++){\n\t\t\t\tif(rs[i].visit)continue;\n\t\t\t\trs[i].color(col);\n\t\t\t\tcol+=2;\n\t\t\t}\n\t\t\tint N =\tID;\n\t\t\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\t\t\tboolean C, D, E;\n\t\t\t\tC = false;\n\t\t\t\tD = E = true;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\t\tif(rs[i].adj.contains(k)&&rs[j].adj.contains(k))C = true;\n\t\t\t\t\tif(streets.contains(names[k]+\"-\"+names[i])&&streets.contains(names[j]+\"-\"+names[k]))D = false;\n\t\t\t\t\tif(streets.contains(names[i]+\"-\"+names[k])&&streets.contains(names[k]+\"-\"+names[j]))E = false;\n\t\t\t\t\tif(!D||!E)break;\n\t\t\t\t}\n\t\t\t\tif(C&&D&&E){\n\t\t\t\t\tR a = get(names[i]), b = get(names[j]);\n\t\t\t\t\ta.eq.add(b.id); b.eq.add(a.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(N);\n\t\t\tint m = sc.nextInt();\n\t\t\twhile(m--!=0){\n\t\t\t\tString[] t = sc.next().split(\"-\");\n\t\t\t\tR a = get(t[0]), b = get(t[1]);\n\t\t\t\tif(a.col==b.col||Math.abs(a.col-b.col)>=2||a.col==-1||b.col==-1){\n\t\t\t\t\tSystem.out.println(\"NO\"); continue;\n\t\t\t\t}\n\t\t\t\treset();\n\t\t\t\tSystem.out.println(b.reach(a.id)?\"YES\":\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "def warshall_floyd(dist_matrix)\n\tdist = dist_matrix\n\tn = dist.size\n\traise \"dist_matrix is not square\" if dist.any?{|row| row.size != n}\n\n\tnext_dist = (1..n).map{ Array.new(n) }\t\n\t(0..n-1).each{|k|\n\t\tdist_k = dist[k]\n\t\t(0..n-1).each{|i|\n\t\t\tdist_i = dist[i]\n\t\t\tnext_dist_i = next_dist[i]\n\t\t\t(0..n-1).each{|j|\n\t\t\t\tx = dist_i[j]\n\t\t\t\ty = dist_i[k] + dist_k[j]\n\t\t\t\tnext_dist_i[j] = (x < y ? x : y)\n\t\t\t}\n\t\t}\n\t\tdist = next_dist\n\t}\n\tdist\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tnode_idx = {}\n\tout_neighbour = Hash.new(0)\n\tin_neighbour = Hash.new(0)\n\n\tcross_points = (1..n).map { gets.chomp.split(?-) }\n\tputs node_num = cross_points.flatten.uniq.size\n\tgraph = (1..node_num).map { [Float::INFINITY] * node_num }\n\t\n\tcross_points.each do |s, t|\n\t\ti = (node_idx[s] ||= node_idx.size)\n\t\tj = (node_idx[t] ||= node_idx.size)\n\t\tout_neighbour[i] |= (1 << j)\n\t\tin_neighbour[j] |= (1 << i)\n\t\tgraph[i][j] = 1\n\tend\n\n\t(0..node_num-1).each do |i|\n\t\tneighbours = (0..node_num-1).select{|x| out_neighbour[i][x] == 1}\n\t\tneighbours.combination(2) do |j, k|\n\t\t\tnext if in_neighbour[j] & out_neighbour[k] > 0\n\t\t\tnext if in_neighbour[k] & out_neighbour[j] > 0\n\t\t\tgraph[j][k] = 2\n\t\t\tgraph[k][j] = 2\n\t\tend\n\t\tneighbours = (0..node_num-1).select{|x| in_neighbour[i][x] == 1}\n\t\tneighbours.combination(2) do |j, k|\n\t\t\tnext if in_neighbour[j] & out_neighbour[k] > 0\n\t\t\tnext if in_neighbour[k] & out_neighbour[j] > 0\n\t\t\tgraph[j][k] = 2\n\t\t\tgraph[k][j] = 2\n\t\tend\n\tend\n\n\tdist = warshall_floyd(graph)\n    \n\tm = gets.to_i\n\tm.times do\n\t\ts, t = gets.chomp.split(?-)\n\t\ti = node_idx[s]\n\t\tj = node_idx[t]\n\t\tif !i || !j\n\t\t\tputs 'NO'\n\t\t\tnext\n\t\tend\n\t\t\n\t\td = dist[i][j]\n\t\tif d == Float::INFINITY || d.even?\n\t\t\tputs 'NO'\n\t\telse\n\t\t\tputs 'YES'\n\t\tend\n\tend\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_N = 200\n\nD_NS = 0\nD_EW = 1\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  nm2id = {}\n  nid = 0\n  cpairs = []\n\n  n.times do\n    st0, st1 = gets.strip.split('-')\n\n    if nm2id[st0].nil?\n      nm2id[st0] = nid\n      nid += 1\n    end\n    if nm2id[st1].nil?\n      nm2id[st1] = nid\n      nid += 1\n    end\n    cpairs << [nm2id[st0], nm2id[st1]]\n  end\n  #p nm2id\n  #p cpairs\n\n  cmat = nid.times.map{nid.times.map{nil}}\n  nbrs = nid.times.map{[]}\n\n  cpairs.each do |st0, st1|\n    cmat[st0][st1] = 1\n    cmat[st1][st0] = -1\n    nbrs[st0] << st1\n    nbrs[st1] << st0\n  end\n\n  cgrps = []\n  ncgrp = 0\n  drcs = []\n\n  for id in (0...nid)\n    next if drcs[id]\n\n    cgrps[id] = ncgrp\n    drcs[id] = D_NS\n    q = [id]\n\n    while ! q.empty?\n      u = q.shift\n      ud = drcs[u]\n\n      for v in nbrs[u]\n        if ! drcs[v]\n          cgrps[v] = ncgrp\n          drcs[v] = 1 - ud\n          q << v\n        end\n      end\n    end\n    #p drcs\n\n    ncgrp += 1\n  end\n\n  dsts = ncgrp.times.map{2.times.map{[]}}\n  (0...nid).each{|id| dsts[cgrps[id]][drcs[id]] << id}\n  #p dsts\n\n  for i in (0...nid)\n    cgrp = cgrps[i]\n    d = drcs[i]\n\n    for j in dsts[cgrp][d]\n      next if i >= j\n\n      cnd1 = false\n      cnd23 = true\n\n      for k in dsts[cgrp][1 - d]\n        cik = cmat[i][k]\n        cjk = cmat[j][k]\n        if cik && cjk\n          cnd1 = true\n          if cik != cjk\n            cnd23 = false\n            break\n          end\n        end\n      end\n\n      if cnd1 && cnd23\n        cmat[i][j] = cmat[j][i] = 0\n        nbrs[i] << j\n        nbrs[j] << i\n      end\n    end\n  end\n  #p cmat\n  #p nbrs\n\n  puts nid\n\n  m = gets.to_i\n\n  m.times do\n    q0, q1 = gets.strip.split('-').map{|st| nm2id[st]}\n\n    yorn = false\n    if q0 && q1 && drcs[q0] && drcs[q1] && drcs[q0] != drcs[q1]\n      visited = nid.times.map{false}\n      visited[q0] = true\n      q = [q0]\n\n      while ! q.empty?\n        u = q.shift\n        if u == q1\n          yorn = true\n          break\n        end\n\n        for v in nbrs[u]\n          next if visited[v]\n          cuv = cmat[u][v]\n          if cuv && cuv >= 0\n            visited[v] = true\n            q << v\n          end\n        end\n      end\n    end\n\n    puts (yorn ? \"YES\" : \"NO\")\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_N = 200\n\nD_NS = 0\nD_EW = 1\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  nm2id = {}\n  nid = 0\n  cpairs = []\n\n  n.times do\n    st0, st1 = gets.strip.split('-')\n\n    if nm2id[st0].nil?\n      nm2id[st0] = nid\n      nid += 1\n    end\n    if nm2id[st1].nil?\n      nm2id[st1] = nid\n      nid += 1\n    end\n    cpairs << [nm2id[st0], nm2id[st1]]\n  end\n  #p nm2id\n  #p cpairs\n\n  cmat = nid.times.map{nid.times.map{nil}}\n  nbrs = nid.times.map{[]}\n\n  cpairs.each do |st0, st1|\n    cmat[st0][st1] = 1\n    cmat[st1][st0] = -1\n    nbrs[st0] << st1\n    nbrs[st1] << st0\n  end\n\n  drcs = []\n  drcs[0] = D_NS\n  q = [0]\n\n  while ! q.empty?\n    u = q.shift\n    ud = drcs[u]\n\n    for v in nbrs[u]\n      if ! drcs[v]\n        drcs[v] = 1 - ud\n        q << v\n      end\n    end\n  end\n  #p drcs\n\n  dsts = 2.times.map{[]}\n  (0...nid).each{|id| dsts[drcs[id]] << id}\n  #p dsts\n\n  for d in [D_NS, D_EW]\n    sts0 = dsts[d]\n    sts1 = dsts[1 - d]\n    nsts0 = sts0.length\n    nsts1 = sts1.length\n\n    for i in (0...nsts0)\n      sti = sts0[i]\n      for j in ((i + 1)...nsts0)\n        stj = sts0[j]\n        cnd1 = false\n        cnd23 = true\n\n        for k in (0...nsts1)\n          stk = sts1[k]\n\n          cik = cmat[sti][stk]\n          cjk = cmat[stj][stk]\n          if cik && cjk\n            cnd1 = true\n            if cik != cjk\n              cnd23 = false\n              break\n            end\n          end\n        end\n\n        if cnd1 && cnd23\n          cmat[sti][stj] = cmat[stj][sti] = 0\n          nbrs[sti] << stj\n          nbrs[stj] << sti\n        end\n      end\n    end\n  end\n  #p cmat\n  #p nbrs\n\n  puts nid\n\n  m = gets.to_i\n\n  m.times do\n    q0, q1 = gets.strip.split('-').map{|st| nm2id[st]}\n\n    yorn = false\n    if q0 && q1 && drcs[q0] && drcs[q1] && drcs[q0] != drcs[q1]\n      visited = nid.times.map{false}\n      visited[q0] = true\n      q = [q0]\n\n      while ! q.empty?\n        u = q.shift\n        if u == q1\n          yorn = true\n          break\n        end\n\n        for v in nbrs[u]\n          next if visited[v]\n          cuv = cmat[u][v]\n          if cuv && cuv >= 0\n            visited[v] = true\n            q << v\n          end\n        end\n      end\n    end\n\n    puts (yorn ? \"YES\" : \"NO\")\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_N = 200\n\nD_NS = 0\nD_EW = 1\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  nm2id = {}\n  nid = 0\n  cpairs = []\n\n  n.times do\n    st0, st1 = gets.strip.split('-')\n\n    if nm2id[st0].nil?\n      nm2id[st0] = nid\n      nid += 1\n    end\n    if nm2id[st1].nil?\n      nm2id[st1] = nid\n      nid += 1\n    end\n    cpairs << [nm2id[st0], nm2id[st1]]\n  end\n  #p nm2id\n  #p cpairs\n\n  cmat = nid.times.map{nid.times.map{nil}}\n  nbrs = nid.times.map{[]}\n\n  cpairs.each do |st0, st1|\n    cmat[st0][st1] = 1\n    cmat[st1][st0] = -1\n    nbrs[st0] << st1\n    nbrs[st1] << st0\n  end\n\n  drcs = []\n  drcs[0] = D_NS\n  q = [0]\n\n  while ! q.empty?\n    u = q.shift\n    ud = drcs[u]\n\n    for v in (0...nid)\n      if cmat[u][v] && ! drcs[v]\n        drcs[v] = 1 - ud\n        q << v\n      end\n    end\n  end\n  #p drcs\n\n  dsts = 2.times.map{[]}\n  (0...nid).each{|id| dsts[drcs[id]] << id}\n  #p dsts\n\n  for d in [D_NS, D_EW]\n    sts0 = dsts[d]\n    sts1 = dsts[1 - d]\n    nsts0 = sts0.length\n    nsts1 = sts1.length\n\n    for i in (0...nsts0)\n      sti = sts0[i]\n      for j in ((i + 1)...nsts0)\n        stj = sts0[j]\n        cnd1 = false\n        cnd23 = true\n\n        for k in (0...nsts1)\n          stk = sts1[k]\n\n          cik = cmat[sti][stk]\n          cjk = cmat[stj][stk]\n          if cik && cjk\n            cnd1 = true\n            if cik != cjk\n              cnd23 = false\n              break\n            end\n          end\n        end\n\n        if cnd1 && cnd23\n          cmat[sti][stj] = cmat[stj][sti] = 0\n          nbrs[sti] << stj\n          nbrs[stj] << sti\n        end\n      end\n    end\n  end\n  #p cmat\n  #p nbrs\n\n  puts nid\n\n  m = gets.to_i\n\n  m.times do\n    q0, q1 = gets.strip.split('-').map{|st| nm2id[st]}\n\n    yorn = false\n    if q0 && q1 && drcs[q0] && drcs[q1] && drcs[q0] != drcs[q1]\n      visited = nid.times.map{false}\n      visited[q0] = true\n      q = [q0]\n\n      while ! q.empty?\n        u = q.shift\n        if u == q1\n          yorn = true\n          break\n        end\n\n        for v in nbrs[u]\n          next if visited[v]\n          cuv = cmat[u][v]\n          if cuv && cuv >= 0\n            visited[v] = true\n            q << v\n          end\n        end\n      end\n    end\n\n    puts (yorn ? \"YES\" : \"NO\")\n  end\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.algorithm, std.math;\n\nint calcSimple( int y, int money, double rate, int commission ) {\n  int ans = 0;\n  foreach ( i; 0 .. y ) {\n\tans += to!int( money * rate );\n\tmoney -= commission;\n  }\n  return ans + money;\n}\n\nint calcCompound( int y, int money, double rate, int commission ) {\n  foreach ( i; 0 .. y ) {\n\tmoney = to!int( money * ( 1 + rate ) );\n\tmoney -= commission;\n  }\n  return money;\n}\n\nvoid main()\n{\n  int m = to!int( strip( readln ) );\n  foreach ( i; 0 .. m ) {\n\tint money = to!int( strip( readln ) );\n\tint y = to!int( strip( readln ) );\n\tint n = to!int( strip( readln ) );\n\tint ans = 0;\n\tforeach ( j; 0 .. n ) {\n\t  \n\t  auto line = split( strip( readln ), \" \" );\n\t  int isCompoundInterest = to!int( line[ 0 ] );\n\t  double rate = to!double( line[ 1 ] );\n\t  int commission = to!int( line[ 2 ] );\n\t  if ( isCompoundInterest == 0 ) {\n\t\tans = max( ans, calcSimple( y, money, rate, commission ) );\n\t  } else {\n\t\tans = max( ans, calcCompound( y, money, rate, commission ) );\n\t  }\n\t}\n\twriteln( ans );\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\n/* 驥阪∩縺、縺攻nionFind譛ィ */\nclass UnionFindW {\n    alias int INT;\n    static const INT INF = int.max / 4;\n    struct Pair {\n        int index;\n        INT value;\n    }\n    int[] parent;\n    INT[] value;\n    this(int N) {\n        parent = new int[N + 1]; parent[] = -1;\n        value = new INT[N + 1];  value[] = 0;\n    }\n    /* \n     * root :: 繧、繝ウ繝?ャ繧ッ繧ケ -> (繝ォ繝シ繝医?繧、繝ウ繝?ャ繧ッ繧ケ, 繝ォ繝シ繝医→縺ョ霍晞屬)\n     */\n    Pair root(int x) {\n        if (parent[x] == -1) return Pair(x, 0);\n        int p = parent[x];\n        auto v = value[x];\n        auto proot = root(p);\n        parent[x] = proot.index;\n        value[x] = v + proot.value;\n        return Pair(parent[x], value[x]);\n    }\n    /* \n     * query :: (繧、繝ウ繝?ャ繧ッ繧ケx, 繧、繝ウ繝?ャ繧ッ繧ケy) -> y縺ィx縺ョ蟾ョ\n     */\n    INT query(int x, int y) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index != yroot.index) return INF;\n        return yroot.value - xroot.value;\n    }\n    /*\n     * merge :: (繧、繝ウ繝?ャ繧ッ繧ケx, 繧、繝ウ繝?ャ繧ッ繧ケy, y縺ィx縺ョ蟾ョw) -> ()\n     *\n     * x縺ィy縺後☆縺ァ縺ォ隕ェ蟄宣未菫ゅｒ謖√▲縺ヲ縺?※,縺昴?蟾ョ縺詣縺ァ縺ェ縺代ｌ縺ー逡ー蟶ク邨ゆコ?     */\n    void merge(int x, int y, INT w) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index == yroot.index) {\n            //assert(query(x, y) == w);\n            return;\n        }\n        auto px = xroot.index, py = yroot.index;\n        auto dx = xroot.value, dy = yroot.value;\n        /* value[y] - value[x] = w\n         * value[x] - value[px] = dx\n         * value[y] - value[py] = dy\n         * value[py] - value[px] = (value[y] - dy) - (value[x] - dx)\n         *                       = (value[y] - value[x]) - (dy - dx)\n         *                       = w - dy + dx\n         */\n        parent[py] = px;\n        value[py] = w - dy + dx;\n    }\n}\n\nvoid main() {\n    int N;\n    int[string] M;\n    int C;\n\n    int[][] G;\n    int[][] rG;\n    UnionFindW uf;\n\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        M.destroy; C = 0;\n        G = new int[][201];\n        rG = new int[][201];\n        uf = new UnionFindW(201);\n        foreach (i; 0 .. N) {\n            auto ss = readln.chomp.split(\"-\");\n            auto s = ss[0],\n                 t = ss[1];\n            if (s !in M) { M[ s ] = C++; }\n            if (t !in M) { M[ t ] = C++; }\n            G[ M[s] ] ~= M[t];\n            rG[ M[t] ] ~= M[s];\n            uf.merge(M[s], M[t], 1);\n        }\n        return true;\n    }\n\n    bool reachable(int u, int v) {\n        auto used = new bool[C];\n        bool dfs(int prev, int cur) {\n            if (cur == v) return true;\n            if (prev >= 0 && used[cur]) return false;\n            used[cur] = true;\n            foreach (next; G[cur]) {\n                if (next == prev) continue;\n                if (dfs(cur, next)) return true;\n            }\n            return false;\n        }\n        return dfs(-1, u);\n    }\n\n    int[] dist;\n    void calcDist(int root) {\n        dist = new int[C];\n        dist[] = -1;\n        DList!(Tuple!(int, int)) Q;\n        Q.insert(tuple(root, 0));\n        while (!Q.empty) {\n            auto c = Q.front; Q.removeFront;\n            dist[c[0]] = c[1];\n            foreach (next; rG[c[0]]) {\n                if (dist[next] >= 0) continue;\n                Q.insert(tuple(next, c[1] + 1));\n            }\n        }\n    }\n\n    void solve() {\n        writeln(C);\n        foreach (int i; 0 .. C) {\n            calcDist(i);\n            foreach (int x; 0 .. C) {\n                foreach (int y; 0 .. C) {\n                    if (dist[x] < 0 || dist[y] < 0) continue;\n                    if (dist[x] == dist[y]) {\n                        G[x] ~= y;\n                        G[y] ~= x;\n                    }\n                }\n            }\n        }\n        int Q; scanf(\"%d\\n\", &Q);\n        foreach (q; 0 .. Q) {\n            auto ss = readln.chomp.split(\"-\");\n            auto s = ss[0],\n                 t = ss[1];\n            void doit() {\n                if (s !in M || t !in M) {\n                    writeln(\"NO\");\n                    return;\n                }\n                if (uf.query(M[s], M[t]) % 2 == 0) {\n                    writeln(\"NO\");\n                    return;\n                }\n                if (reachable(M[s], M[t])) {\n                    writeln(\"YES\");\n                    return;\n                }\n                writeln(\"NO\");\n            }\n            doit;\n        }\n    }\n\n    while (input) solve;\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\n/* 驥阪∩縺、縺攻nionFind譛ィ */\nclass UnionFindW {\n    alias int INT;\n    static const INT INF = int.max / 4;\n    struct Pair {\n        int index;\n        INT value;\n    }\n    int[] parent;\n    INT[] value;\n    this(int N) {\n        parent = new int[N + 1]; parent[] = -1;\n        value = new INT[N + 1];  value[] = 0;\n    }\n    /* \n     * root :: 繧、繝ウ繝?ャ繧ッ繧ケ -> (繝ォ繝シ繝医?繧、繝ウ繝?ャ繧ッ繧ケ, 繝ォ繝シ繝医→縺ョ霍晞屬)\n     */\n    Pair root(int x) {\n        if (parent[x] == -1) return Pair(x, 0);\n        int p = parent[x];\n        auto v = value[x];\n        auto proot = root(p);\n        parent[x] = proot.index;\n        value[x] = v + proot.value;\n        return Pair(parent[x], value[x]);\n    }\n    /* \n     * query :: (繧、繝ウ繝?ャ繧ッ繧ケx, 繧、繝ウ繝?ャ繧ッ繧ケy) -> y縺ィx縺ョ蟾ョ\n     */\n    INT query(int x, int y) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index != yroot.index) return INF;\n        return yroot.value - xroot.value;\n    }\n    /*\n     * merge :: (繧、繝ウ繝?ャ繧ッ繧ケx, 繧、繝ウ繝?ャ繧ッ繧ケy, y縺ィx縺ョ蟾ョw) -> ()\n     *\n     * x縺ィy縺後☆縺ァ縺ォ隕ェ蟄宣未菫ゅｒ謖√▲縺ヲ縺?※,縺昴?蟾ョ縺詣縺ァ縺ェ縺代ｌ縺ー逡ー蟶ク邨ゆコ?     */\n    void merge(int x, int y, INT w) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index == yroot.index) {\n            //assert(query(x, y) == w);\n            return;\n        }\n        auto px = xroot.index, py = yroot.index;\n        auto dx = xroot.value, dy = yroot.value;\n        /* value[y] - value[x] = w\n         * value[x] - value[px] = dx\n         * value[y] - value[py] = dy\n         * value[py] - value[px] = (value[y] - dy) - (value[x] - dx)\n         *                       = (value[y] - value[x]) - (dy - dx)\n         *                       = w - dy + dx\n         */\n        parent[py] = px;\n        value[py] = w - dy + dx;\n    }\n}\n\nvoid main() {\n    int N;\n    int[string] M;\n    int C;\n\n    int[][] G;\n    int[][] rG;\n    UnionFindW uf;\n\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        M.destroy; C = 0;\n        G = new int[][201];\n        rG = new int[][201];\n        uf = new UnionFindW(201);\n        foreach (i; 0 .. N) {\n            auto ss = readln.chomp.split(\"-\");\n            auto s = ss[0],\n                 t = ss[1];\n            if (s !in M) { M[ s ] = C++; }\n            if (t !in M) { M[ t ] = C++; }\n            G[ M[s] ] ~= M[t];\n            rG[ M[t] ] ~= M[s];\n            uf.merge(M[s], M[t], 1);\n        }\n        return true;\n    }\n\n    bool reachable(int u, int v) {\n        auto used = new bool[C];\n        bool dfs(int prev, int cur) {\n            if (cur == v) return true;\n            if (prev >= 0 && used[cur]) return false;\n            used[cur] = true;\n            foreach (next; G[cur]) {\n                if (next == prev) continue;\n                if (dfs(cur, next)) return true;\n            }\n            return false;\n        }\n        return dfs(-1, u);\n    }\n\n    int[] dist;\n    void calcDist(int root) {\n        struct S { int v, cost; }\n        dist = new int[C];\n        dist[] = -1;\n        DList!(S) Q;\n        Q.insert(S(root, 0));\n        while (!Q.empty) {\n            auto c = Q.front; Q.removeFront;\n            dist[c.v] = c.cost;\n            foreach (next; rG[c.v]) {\n                if (dist[next] >= 0) continue;\n                Q.insert(S(next, c.cost + 1));\n            }\n        }\n    }\n\n    void solve() {\n        writeln(C);\n        foreach (int i; 0 .. C) {\n            calcDist(i);\n            foreach (int x; 0 .. C) {\n                foreach (int y; 0 .. C) {\n                    if (dist[x] < 0 || dist[y] < 0) continue;\n                    if (dist[x] == dist[y]) {\n                        G[x] ~= y;\n                        G[y] ~= x;\n                    }\n                }\n            }\n        }\n        int Q; scanf(\"%d\\n\", &Q);\n        foreach (q; 0 .. Q) {\n            auto ss = readln.chomp.split(\"-\");\n            auto s = ss[0],\n                 t = ss[1];\n            void doit() {\n                if (s !in M || t !in M) {\n                    writeln(\"NO\");\n                    return;\n                }\n                if (uf.query(M[s], M[t]) % 2 == 0) {\n                    writeln(\"NO\");\n                    return;\n                }\n                if (reachable(M[s], M[t])) {\n                    writeln(\"YES\");\n                    return;\n                }\n                writeln(\"NO\");\n            }\n            doit;\n        }\n    }\n\n    while (input) solve;\n\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef solve():\n    N = int(readline())\n    if N == 0:\n        return False\n    L = 0\n    n_map = {}\n    def get(s):\n        nonlocal L\n        if s in n_map:\n            return n_map[s]\n        n_map[s] = L\n        L += 1\n        return L-1\n\n    G = [[] for i in range(2*N)]\n    RG = [[] for i in range(2*N)]\n    for i in range(N):\n        a, b = readline().strip().split(\"-\")\n        ka = get(a); kb = get(b)\n        G[ka].append(kb)\n        RG[kb].append(ka)\n\n    F = [[-1]*L for i in range(L)]\n    for v in range(L):\n        for w1 in G[v]:\n            for w2 in G[v]:\n                F[w1][w2] = 1\n        for w1 in RG[v]:\n            for w2 in RG[v]:\n                F[w1][w2] = 1\n    for v in range(L):\n        for w1 in G[v]:\n            for w2 in RG[v]:\n                F[w1][w2] = F[w2][w1] = 0\n\n    G0 = [[] for i in range(L)]\n    for v in range(L):\n        for w in range(L):\n            if F[v][w] == 1:\n                G0[v].append(w)\n                G0[w].append(v)\n\n    PS = []\n    que = deque()\n    for i in range(L):\n        P = [-1]*L\n        que.append(i)\n        P[i] = 0\n        while que:\n            v = que.popleft()\n            p = P[v]\n            for w in G[v]:\n                if P[w] != -1:\n                    continue\n                P[w] = p^1\n                que.append(w)\n            for w in G0[v]:\n                if P[w] != -1:\n                    continue\n                P[w] = p\n                que.append(w)\n        PS.append(P)\n\n    write(\"%d\\n\" % L)\n    M = int(readline())\n    for i in range(M):\n        a, b = readline().strip().split(\"-\")\n        ka = n_map.get(a, -1); kb = n_map.get(b, -1)\n        if ka == -1 or kb == -1:\n            write(\"NO\\n\")\n            continue\n        write(\"YES\\n\" if PS[ka][kb] == 1 else \"NO\\n\")\n    return True\nwhile solve():\n    ...\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::hash_set::Iter;\nuse std::rc::Rc;\nuse std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer.trim().to_owned()\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split_whitespace().map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: String) => {\n        let mut $ident = read_value::<String>();\n    };\n    ($ident: ident: String) => {\n        let $ident = read_value::<String>();\n    };\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n\nstruct UnionFind {\n    vec: Vec<i32>\n}\nimpl UnionFind {\n    fn new(size: usize) -> UnionFind {\n        UnionFind{vec: vec![-1; size]}\n    }\n    fn find(&mut self, a: usize) -> usize {\n        if self.vec[a] < 0 {\n            a\n        }else {\n            let parent = self.vec[a];\n            let root = self.find(parent as usize);\n            self.vec[a] = root as i32;\n            root\n        }\n    }\n    fn same(&mut self, a: usize, b: usize) -> bool {\n        self.find(a) == self.find(b)\n    }\n    fn unite(&mut self, mut a: usize, mut b: usize) {\n        a = self.find(a);\n        b = self.find(b);\n        if a == b {return ;}\n        if self.vec[a] < self.vec[b] {\n            self.vec[a] += self.vec[b];\n            self.vec[b] = a as i32;\n        }else {\n            self.vec[b] += self.vec[a];\n            self.vec[a] = b as i32;\n        }\n    }\n}\nfn main() {\n    loop {\n        read!(n: usize);\n        if n == 0 {break;}\n        read_map!(cross: [{\n            read!(name: String);\n            let names = name.split('-').collect::<Vec<_>>();\n            let prior = names[0];\n            let sub = names[1];\n            (prior.to_owned(), sub.to_owned())\n        }; n]);\n        let mut roads = HashMap::<String, Vec<HashSet<String>>>::new();\n        for t in &cross {\n            let p = t.0.to_owned();\n            let s = t.1.to_owned();\n            roads.entry(p.to_owned()).or_insert(vec![HashSet::new(); 2])[1].insert(s.to_owned());\n            roads.entry(s.to_owned()).or_insert(vec![HashSet::new(); 2])[0].insert(p.to_owned());\n            //println!(\"{:?}\", roads);\n        }\n        let names = roads.iter().map(|(s, _)| s).cloned().collect::<Vec<_>>();\n        let mut indices = HashMap::<String, usize>::new();\n        for i in 0 .. names.len() {\n            indices.insert(names[i].to_owned(), i);\n        }\n        let mut same_level = UnionFind::new(roads.len());\n        for i in 0 .. names.len() {\n            for j in 0 .. i {\n                if roads[&names[i]][0].intersection(&roads[&names[j]][1]).next().is_none() && \n                    roads[&names[j]][0].intersection(&roads[&names[i]][1]).next().is_none() && \n                    !(roads[&names[i]][0].intersection(&roads[&names[j]][0]).next().is_none() &&\n                    roads[&names[i]][1].intersection(&roads[&names[j]][1]).next().is_none()) {\n                    same_level.unite(i, j);\n                }\n            }\n        }\n        for i in 0 .. names.len() {\n            let root = same_level.find(i);\n            if root == i { continue; }\n            let mut relation = roads.get_mut(&names[i]).unwrap().drain(..).collect::<Vec<_>>();\n            roads.remove(&names[i]);\n            for (j, mut set) in relation.drain(..).enumerate() {\n                for name in set.drain() {\n                    roads.get_mut(&names[root]).unwrap()[j].insert(name);\n                }\n            }\n        }\n        println!(\"{}\", indices.len());\n        read!(m: usize);\n        for _ in 0 .. m {\n            read!(query: String);\n            let pair = query.split('-').map(|name| name.to_owned()).filter(|name| indices.contains_key(name)).map(|name| same_level.find(indices[&name])).collect::<Vec<_>>();\n            if pair.len() == 2{\n                let from = pair[0];\n                let to = pair[1];\n                let mut depth = vec![-1; indices.len()];\n                let mut stack = Vec::new();\n                depth[from] = 0;\n                stack.push(from);\n                while let Some(top) = stack.pop() {\n                    if depth[to] >= 0 {break;}\n                    for name in & roads[&names[top]][1] {\n                        let i = same_level.find(indices[name]);\n                        if depth[i] >= 0{continue;}\n                        stack.push(i);\n                        depth[i] = depth[top] + 1;\n                    }\n                }\n                if depth[to] >= 0 && (depth[from] ^ depth[to]) & 1 == 1 {\n                    println!(\"YES\");\n                }else {\n                    println!(\"NO\");\n                }\n            }else {\n                println!(\"NO\");\n            }\n        }\n    }\n}\n"
  }
]