[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_STREETS 200\n#define MAX_NAME_LENGTH 21\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int index;\n} Street;\n\ntypedef struct {\n    int stronger[MAX_STREETS];\n    int count;\n} StreetRelations;\n\nStreet streets[MAX_STREETS];\nStreetRelations relations[MAX_STREETS];\nint streetCount = 0;\n\nint findStreetIndex(const char* name) {\n    for (int i = 0; i < streetCount; i++) {\n        if (strcmp(streets[i].name, name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint addStreet(const char* name) {\n    int index = findStreetIndex(name);\n    if (index == -1) {\n        strcpy(streets[streetCount].name, name);\n        streets[streetCount].index = streetCount;\n        relations[streetCount].count = 0;\n        streetCount++;\n        return streetCount - 1;\n    }\n    return index;\n}\n\nvoid addRelation(int stronger, int weaker) {\n    for (int i = 0; i < relations[stronger].count; i++) {\n        if (relations[stronger].stronger[i] == weaker) {\n            return;\n        }\n    }\n    relations[stronger].stronger[relations[stronger].count++] = weaker;\n}\n\nint isStronger(int a, int b) {\n    if (a == b) return 1;\n    for (int i = 0; i < relations[a].count; i++) {\n        if (isStronger(relations[a].stronger[i], b)) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 0; i < N; i++) {\n        char street1[MAX_NAME_LENGTH], street2[MAX_NAME_LENGTH];\n        scanf(\"%s %s\", street1, street2);\n        int s1 = addStreet(street1);\n        int s2 = addStreet(street2);\n        addRelation(s1, s2);\n    }\n\n    for (int i = 0; i < M; i++) {\n        char street1[MAX_NAME_LENGTH], street2[MAX_NAME_LENGTH];\n        scanf(\"%s %s\", street1, street2);\n        int s1 = findStreetIndex(street1);\n        int s2 = findStreetIndex(street2);\n\n        if (s1 == -1 || s2 == -1) {\n            printf(\"unknown\\n\");\n            continue;\n        }\n\n        if (isStronger(s1, s2)) {\n            printf(\"yes\\n\");\n        } else if (isStronger(s2, s1)) {\n            printf(\"no\\n\");\n        } else {\n            printf(\"unknown\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass StreetOrder {\n    private Map<String, Set<String>> strongerStreets;\n    private Map<String, Set<String>> equalStreets;\n\n    public StreetOrder() {\n        strongerStreets = new HashMap<>();\n        equalStreets = new HashMap<>();\n    }\n\n    public void addCrossing(String street1, String street2, char relationship) {\n        if (relationship == '>') {\n            addStrongerRelation(street1, street2);\n        } else if (relationship == '=') {\n            addEqualRelation(street1, street2);\n        }\n    }\n\n    private void addStrongerRelation(String stronger, String weaker) {\n        strongerStreets.computeIfAbsent(stronger, k -> new HashSet<>()).add(weaker);\n        propagateStrongerRelations(stronger, weaker);\n    }\n\n    private void addEqualRelation(String street1, String street2) {\n        equalStreets.computeIfAbsent(street1, k -> new HashSet<>()).add(street2);\n        equalStreets.computeIfAbsent(street2, k -> new HashSet<>()).add(street1);\n        \n        Set<String> street1Stronger = new HashSet<>(strongerStreets.getOrDefault(street1, Collections.emptySet()));\n        Set<String> street2Stronger = new HashSet<>(strongerStreets.getOrDefault(street2, Collections.emptySet()));\n        \n        for (String s1 : street1Stronger) {\n            addStrongerRelation(street2, s1);\n        }\n        for (String s2 : street2Stronger) {\n            addStrongerRelation(street1, s2);\n        }\n    }\n\n    private void propagateStrongerRelations(String stronger, String weaker) {\n        Set<String> weakerStreets = strongerStreets.getOrDefault(weaker, Collections.emptySet());\n        for (String furtherWeaker : weakerStreets) {\n            if (!isStrongerOrEqual(stronger, furtherWeaker)) {\n                addStrongerRelation(stronger, furtherWeaker);\n            }\n        }\n\n        Set<String> equalToWeaker = equalStreets.getOrDefault(weaker, Collections.emptySet());\n        for (String equalStreet : equalToWeaker) {\n            if (!isStrongerOrEqual(stronger, equalStreet)) {\n                addStrongerRelation(stronger, equalStreet);\n            }\n        }\n    }\n\n    public boolean isStrongerOrEqual(String street1, String street2) {\n        if (street1.equals(street2)) return true;\n        \n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        queue.add(street1);\n        visited.add(street1);\n        \n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            \n            Set<String> strongerSet = strongerStreets.getOrDefault(current, Collections.emptySet());\n            Set<String> equalSet = equalStreets.getOrDefault(current, Collections.emptySet());\n            \n            if (strongerSet.contains(street2)) return true;\n            if (equalSet.contains(street2)) return true;\n            \n            for (String stronger : strongerSet) {\n                if (!visited.contains(stronger)) {\n                    queue.add(stronger);\n                    visited.add(stronger);\n                }\n            }\n            \n            for (String equal : equalSet) {\n                if (!visited.contains(equal)) {\n                    queue.add(equal);\n                    visited.add(equal);\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    public boolean validateCrossing(String street1, String street2) {\n        return !isStrongerOrEqual(street1, street2) && !isStrongerOrEqual(street2, street1);\n    }\n}",
    "timestamp": "2025-08-05 19:07:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nmap<string, int> street_id;\nvector<vector<int>> adj;\nvector<int> in_degree;\nvector<int> strength;\nvector<bool> visited;\n\nint get_id(const string& s) {\n    if (street_id.find(s) == street_id.end()) {\n        int id = street_id.size();\n        street_id[s] = id;\n        adj.push_back(vector<int>());\n        in_degree.push_back(0);\n        strength.push_back(0);\n    }\n    return street_id[s];\n}\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            strength[v] = max(strength[v], strength[u] + 1);\n            dfs(v);\n        }\n    }\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    \n    for (int i = 0; i < N; ++i) {\n        string a, b;\n        cin >> a >> b;\n        int u = get_id(a);\n        int v = get_id(b);\n        adj[u].push_back(v);\n        in_degree[v]++;\n    }\n    \n    visited.assign(street_id.size(), false);\n    for (int i = 0; i < street_id.size(); ++i) {\n        if (in_degree[i] == 0 && !visited[i]) {\n            dfs(i);\n        }\n    }\n    \n    for (int i = 0; i < Q; ++i) {\n        string a, b;\n        cin >> a >> b;\n        if (street_id.find(a) == street_id.end() || street_id.find(b) == street_id.end()) {\n            cout << \"unknown\" << endl;\n            continue;\n        }\n        int u = street_id[a];\n        int v = street_id[b];\n        if (strength[u] > strength[v]) {\n            cout << \"forward\" << endl;\n        } else if (strength[u] < strength[v]) {\n            cout << \"backward\" << endl;\n        } else {\n            cout << \"unknown\" << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:07:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_STREETS 101\n#define MAX_NAME_LENGTH 21\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int graph[MAX_STREETS][MAX_STREETS];\n    int visited[MAX_STREETS];\n    int street_count;\n} StreetNetwork;\n\nint find_street_index(StreetNetwork* network, const char* street_name) {\n    for (int i = 0; i < network->street_count; i++) {\n        if (strcmp(network->name + i * MAX_NAME_LENGTH, street_name) == 0) {\n            return i;\n        }\n    }\n    \n    strcpy(network->name + network->street_count * MAX_NAME_LENGTH, street_name);\n    network->street_count++;\n    return network->street_count - 1;\n}\n\nbool dfs_strength(StreetNetwork* network, int start, int end) {\n    if (start == end) return true;\n    \n    network->visited[start] = 1;\n    \n    for (int i = 0; i < network->street_count; i++) {\n        if (network->graph[start][i] && !network->visited[i]) {\n            if (dfs_strength(network, i, end)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nbool is_stronger_street(StreetNetwork* network, const char* street1, const char* street2) {\n    int start = find_street_index(network, street1);\n    int end = find_street_index(network, street2);\n    \n    memset(network->visited, 0, sizeof(network->visited[0]) * network->street_count);\n    \n    return dfs_strength(network, start, end);\n}\n\nvoid add_street_relationship(StreetNetwork* network, const char* stronger, const char* weaker) {\n    int strong_idx = find_street_index(network, stronger);\n    int weak_idx = find_street_index(network, weaker);\n    \n    network->graph[strong_idx][weak_idx] = 1;\n}\n\nint main() {\n    StreetNetwork network = {0};\n    int crossings, queries;\n    \n    scanf(\"%d %d\", &crossings, &queries);\n    \n    for (int i = 0; i < crossings; i++) {\n        char strong[MAX_NAME_LENGTH], weak[MAX_NAME_LENGTH];\n        scanf(\"%s %s\", strong, weak);\n        add_street_relationship(&network, strong, weak);\n    }\n    \n    for (int i = 0; i < queries; i++) {\n        char street1[MAX_NAME_LENGTH], street2[MAX_NAME_LENGTH];\n        scanf(\"%s %s\", street1, street2);\n        \n        printf(\"%s\\n\", is_stronger_street(&network, street1, street2) ? \"Yes\" : \"No\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:07:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nclass StreetGraph {\nprivate:\n    std::unordered_map<std::string, std::unordered_set<std::string>> stronger;\n    std::unordered_map<std::string, int> inDegree;\n\n    bool isStronger(const std::string& a, const std::string& b) {\n        std::unordered_set<std::string> visited;\n        std::queue<std::string> q;\n        q.push(a);\n        \n        while (!q.empty()) {\n            std::string current = q.front();\n            q.pop();\n            \n            if (current == b) return true;\n            \n            if (visited.count(current)) continue;\n            visited.insert(current);\n            \n            for (const auto& next : stronger[current]) {\n                if (!visited.count(next)) {\n                    q.push(next);\n                }\n            }\n        }\n        \n        return false;\n    }\n\npublic:\n    void addCrossing(const std::string& street1, const std::string& street2) {\n        if (stronger[street1].count(street2) == 0) {\n            stronger[street1].insert(street2);\n            inDegree[street2]++;\n        }\n    }\n\n    bool canDeterminePriority(const std::string& street1, const std::string& street2) {\n        return isStronger(street1, street2) || isStronger(street2, street1);\n    }\n};\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    StreetGraph graph;\n    \n    for (int i = 0; i < n; i++) {\n        std::string street1, street2;\n        std::cin >> street1 >> street2;\n        graph.addCrossing(street1, street2);\n    }\n    \n    for (int i = 0; i < m; i++) {\n        std::string street1, street2;\n        std::cin >> street1 >> street2;\n        \n        if (graph.canDeterminePriority(street1, street2)) {\n            std::cout << \"YES\\n\";\n        } else {\n            std::cout << \"NO\\n\";\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:08:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class KyotoStreetOrder {\n    private Map<String, Set<String>> strongerThan = new HashMap<>();\n\n    public KyotoStreetOrder(String[] crossings) {\n        for (String crossing : crossings) {\n            String[] streets = crossing.split(\" \");\n            String street1 = streets[0];\n            String street2 = streets[1];\n            addRelation(street1, street2);\n        }\n        buildTransitiveClosure();\n    }\n\n    private void addRelation(String stronger, String weaker) {\n        strongerThan.computeIfAbsent(stronger, k -> new HashSet<>()).add(weaker);\n    }\n\n    private void buildTransitiveClosure() {\n        boolean changed;\n        do {\n            changed = false;\n            for (String street : new ArrayList<>(strongerThan.keySet())) {\n                Set<String> directlyStronger = strongerThan.get(street);\n                if (directlyStronger == null) continue;\n                Set<String> toAdd = new HashSet<>();\n                for (String weaker : directlyStronger) {\n                    Set<String> indirectlyStronger = strongerThan.get(weaker);\n                    if (indirectlyStronger != null) {\n                        for (String s : indirectlyStronger) {\n                            if (!directlyStronger.contains(s)) {\n                                toAdd.add(s);\n                            }\n                        }\n                    }\n                }\n                if (!toAdd.isEmpty()) {\n                    directlyStronger.addAll(toAdd);\n                    changed = true;\n                }\n            }\n        } while (changed);\n    }\n\n    public boolean isStronger(String street1, String street2) {\n        if (street1.equals(street2)) return false;\n        Set<String> strongerStreets = strongerThan.get(street1);\n        return strongerStreets != null && strongerStreets.contains(street2);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n        String[] crossings = new String[N];\n        for (int i = 0; i < N; i++) {\n            crossings[i] = scanner.nextLine();\n        }\n\n        KyotoStreetOrder order = new KyotoStreetOrder(crossings);\n\n        int Q = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n        for (int i = 0; i < Q; i++) {\n            String query = scanner.nextLine();\n            String[] streets = query.split(\" \");\n            boolean valid = order.isStronger(streets[0], streets[1]);\n            System.out.println(valid ? \"yes\" : \"no\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:08:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve_street_order(n, crossings, q, queries):\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n\n    for a, b in crossings:\n        graph[a].append(b)\n        in_degree[b] += 1\n\n    topo_order = []\n    queue = deque()\n\n    # Find all vertices with no incoming edges\n    for street in graph:\n        if in_degree[street] == 0:\n            queue.append(street)\n\n    # Topological sorting\n    while queue:\n        street = queue.popleft()\n        topo_order.append(street)\n        for neighbor in graph[street]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Creating index for the topological order\n    index = {street: i for i, street in enumerate(topo_order)}\n\n    results = []\n    for x, y in queries:\n        if x in index and y in index and index[x] < index[y]:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n\n    return results\n\n# Example usage:\nn = 5\ncrossings = [(\"A\", \"B\"), (\"B\", \"D\"), (\"C\", \"D\"), (\"D\", \"E\")]\nq = 3\nqueries = [(\"A\", \"E\"), (\"B\", \"C\"), (\"D\", \"A\")]\nprint(solve_street_order(n, crossings, q, queries))",
    "timestamp": "2025-08-13 02:31:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class KyotoStreetOrder {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(); // number of known crossings\n        int m = scanner.nextInt(); // number of queries\n\n        Map<String, List<String>> graph = new HashMap<>();\n\n        // Read the known crossings\n        for (int i = 0; i < n; i++) {\n            String A = scanner.next();\n            String B = scanner.next();\n            graph.putIfAbsent(A, new ArrayList<>());\n            graph.get(A).add(B);\n            graph.putIfAbsent(B, new ArrayList<>());\n            graph.get(B).add(A);\n        }\n\n        // Process queries\n        for (int i = 0; i < m; i++) {\n            String C = scanner.next();\n            String D = scanner.next();\n\n            if (isStronger(graph, C, D)) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        scanner.close();\n    }\n\n    public static boolean isStronger(Map<String, List<String>> graph, String C, String D) {\n        Set<String> visited = new HashSet<>();\n        return dfs(graph, C, D, visited);\n    }\n\n    public static boolean dfs(Map<String, List<String>> graph, String current, String target, Set<String> visited) {\n        if (current.equals(target)) {\n            return true;\n        }\n        visited.add(current);\n\n        List<String> neighbors = graph.get(current);\n        if (neighbors != null) {\n            for (String neighbor : neighbors) {\n                if (!visited.contains(neighbor) && dfs(graph, neighbor, target, visited)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-13 02:32:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_STREETS 100\n#define MAX_NAME_LENGTH 100\n\nint strength[MAX_STREETS][MAX_STREETS];\nchar streets[MAX_STREETS][MAX_NAME_LENGTH];\n\nint findStreetIndex(const char *name, int streetCount) {\n    for (int i = 0; i < streetCount; ++i) {\n        if (strcmp(streets[i], name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint isStronger(int from, int to, int streetCount) {\n    if (strength[from][to]) {\n        return 1;\n    }\n    \n    for (int i = 0; i < streetCount; ++i) {\n        if (strength[from][i] && isStronger(i, to, streetCount)) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int n, q, streetCount = 0;\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < MAX_STREETS; ++i) {\n        memset(strength[i], 0, sizeof(strength[i]));\n    }\n\n    for (int i = 0; i < n; ++i) {\n        char street1[MAX_NAME_LENGTH], street2[MAX_NAME_LENGTH];\n        scanf(\"%s %s\", street1, street2);\n\n        int index1 = findStreetIndex(street1, streetCount);\n        if (index1 == -1) {\n            index1 = streetCount++;\n            strcpy(streets[index1], street1);\n        }\n        \n        int index2 = findStreetIndex(street2, streetCount);\n        if (index2 == -1) {\n            index2 = streetCount++;\n            strcpy(streets[index2], street2);\n        }\n        \n        strength[index1][index2] = 1;\n    }\n\n    scanf(\"%d\", &q);\n\n    while (q--) {\n        char street1[MAX_NAME_LENGTH], street2[MAX_NAME_LENGTH];\n        scanf(\"%s %s\", street1, street2);\n\n        int index1 = findStreetIndex(street1, streetCount);\n        int index2 = findStreetIndex(street2, streetCount);\n\n        if (index1 == -1 || index2 == -1) {\n            printf(\"invalid\\n\");\n        } else if (isStronger(index1, index2, streetCount) || isStronger(index2, index1, streetCount)) {\n            printf(\"valid\\n\");\n        } else {\n            printf(\"invalid\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:32:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\nclass StreetNetwork:\n    def __init__(self):\n        self.graph = defaultdict(set)\n        self.strength = {}\n\n    def add_crossing(self, street1, street2):\n        self.graph[street1].add(street2)\n        if street1 not in self.strength:\n            self.strength[street1] = len(self.strength)\n        if street2 not in self.strength:\n            self.strength[street2] = len(self.strength)\n\n    def is_stronger(self, street1, street2):\n        if street1 == street2:\n            return True\n        \n        visited = set()\n        queue = deque([street1])\n        \n        while queue:\n            current = queue.popleft()\n            if current == street2:\n                return True\n            \n            if current in visited:\n                continue\n            \n            visited.add(current)\n            \n            for neighbor in self.graph[current]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n        \n        return False\n\ndef solve_kyoto_street_problem(crossings, queries):\n    network = StreetNetwork()\n    \n    for street1, street2 in crossings:\n        network.add_crossing(street1, street2)\n    \n    results = []\n    for query_type, street1, street2 in queries:\n        if query_type == 'stronger':\n            results.append(network.is_stronger(street1, street2))\n        else:\n            results.append(None)\n    \n    return results",
    "timestamp": "2025-08-13 02:32:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    K = int(input[ptr])\n    ptr += 1\n    \n    adj = defaultdict(set)\n    in_degree = defaultdict(int)\n    streets = set()\n    \n    for _ in range(M):\n        u = input[ptr]\n        v = input[ptr + 1]\n        ptr += 2\n        adj[u].add(v)\n        in_degree[v] += 1\n        streets.add(u)\n        streets.add(v)\n    \n    # Kahn's algorithm for topological sort\n    queue = deque()\n    for s in streets:\n        if in_degree.get(s, 0) == 0:\n            queue.append(s)\n    \n    topo_order = []\n    while queue:\n        if len(queue) > 1:\n            # Multiple streets with zero in-degree, no unique order\n            break\n        u = queue.popleft()\n        topo_order.append(u)\n        for v in adj.get(u, set()):\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    \n    # Assign ranks based on topological order\n    rank = {}\n    for i, s in enumerate(topo_order):\n        rank[s] = i\n    \n    # Process queries\n    output = []\n    for _ in range(K):\n        x = input[ptr]\n        y = input[ptr + 1]\n        ptr += 2\n        if x in rank and y in rank:\n            if rank[x] < rank[y]:\n                output.append(\"1\")\n            else:\n                output.append(\"-1\")\n        else:\n            output.append(\"?\")\n    \n    print('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:32:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\n// Function to perform BFS to find if there is a valid path of stronger or equal streets\nbool isStrongerOrEqual(unordered_map<string, vector<string>>& graph, const string& u, const string& v) {\n    if (u == v) return true;\n    unordered_map<string, bool> visited;\n    queue<string> q;\n    q.push(u);\n    visited[u] = true;\n    \n    while (!q.empty()) {\n        string current = q.front();\n        q.pop();\n        \n        for (const string& neighbor : graph[current]) {\n            if (!visited[neighbor]) {\n                if (neighbor == v) return true;\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    unordered_map<string, vector<string>> graph;\n    \n    for (int i = 0; i < n; ++i) {\n        string u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n   \n    for (int i = 0; i < m; ++i) {\n        string u, v;\n        cin >> u >> v;\n        if (isStrongerOrEqual(graph, u, v)) {\n            cout << \"Valid\" << endl;\n        } else {\n            cout << \"Invalid\" << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:06:24"
  }
]